{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_content_storage ( MXFContext * mxf , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x1901 : \n mxf -> packages_count = get_be32 ( pb ) ; \n if ( mxf -> packages_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n mxf -> packages_refs = av_malloc ( mxf -> packages_count * sizeof ( UID ) ) ; \n if ( ! mxf -> packages_refs ) \n return -1 ; \n url_fskip ( pb , 4 ) ; \n get_buffer ( pb , ( uint8_t * ) mxf -> packages_refs , mxf -> packages_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 125}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) \n { \n void * * ptrptr = ptr ; \n void * ret ; \n if ( size <= 0 || nmemb >= INT_MAX / size ) \n return AVERROR ( ENOMEM ) ; \n if ( nmemb <= 0 ) { \n av_freep ( ptr ) ; \n return 0 ; \n } \n ret = av_realloc ( * ptrptr , nmemb * size ) ; \n if ( ! ret ) { \n av_freep ( ptr ) ; \n return AVERROR ( ENOMEM ) ; \n } \n * ptrptr = ret ; \n return 0 ; \n }", "idx": 127}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 16 ) ; \n }", "idx": 137}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_dolby ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] -= output [ 3 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 3 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 183}
{"project": "FFmpeg", "commit_id": "d2a2b08cfe2ab382a4ad756c0a08ff78eb284ef9", "target": 0, "func": "static int config_props ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n AVFilterLink * inlink = outlink -> src -> inputs [ 0 ] ; \n ScaleContext * scale = ctx -> priv ; \n int64_t w , h ; \n if ( ! ( w = scale -> w ) ) \n w = inlink -> w ; \n if ( ! ( h = scale -> h ) ) \n h = inlink -> h ; \n if ( w == -1 ) \n w = av_rescale ( h , inlink -> w , inlink -> h ) ; \n if ( h == -1 ) \n h = av_rescale ( w , inlink -> h , inlink -> w ) ; \n if ( w > INT_MAX || h > INT_MAX || \n ( h * inlink -> w ) > INT_MAX || \n ( w * inlink -> h ) > INT_MAX ) \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n outlink -> w = w ; \n outlink -> h = h ; \n scale -> sws = sws_getContext ( inlink -> w , inlink -> h , inlink -> format , \n outlink -> w , outlink -> h , outlink -> format , \n SWS_BILINEAR , NULL , NULL , NULL ) ; \n av_log ( ctx , AV_LOG_INFO , \" \\n \" , \n outlink -> w , outlink -> h , av_pix_fmt_descriptors [ outlink -> format ] . name ) ; \n scale -> input_is_pal = inlink -> format == PIX_FMT_PAL8 || \n inlink -> format == PIX_FMT_BGR4_BYTE || \n inlink -> format == PIX_FMT_RGB4_BYTE || \n inlink -> format == PIX_FMT_BGR8 || \n inlink -> format == PIX_FMT_RGB8 ; \n return ! scale -> sws ; \n }", "idx": 188}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int find_stream_index ( AVFormatContext * s ) \n { \n int i ; \n AVStream * st ; \n if ( s -> nb_streams <= 0 ) \n return -1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( st -> codec . codec_type == CODEC_TYPE_VIDEO ) { \n return i ; \n } \n } \n return 0 ; \n }", "idx": 253}
{"project": "FFmpeg", "commit_id": "d0d8a9b1384ba3cd465d6ef3439f3979d4518b4b", "target": 1, "func": "void ff_rtsp_undo_setup ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n RTSPStream * rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( ! rtsp_st ) \n continue ; \n if ( rtsp_st -> transport_priv ) { \n if ( s -> oformat ) { \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n av_write_trailer ( rtpctx ) ; \n if ( rt -> lower_transport == RTSP_LOWER_TRANSPORT_TCP ) { \n uint8_t * ptr ; \n url_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } else { \n url_fclose ( rtpctx -> pb ) ; \n } \n av_metadata_free ( & rtpctx -> streams [ 0 ] -> metadata ) ; \n av_metadata_free ( & rtpctx -> metadata ) ; \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n } else if ( rt -> transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else if ( CONFIG_RTPDEC ) \n rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n rtsp_st -> transport_priv = NULL ; \n if ( rtsp_st -> rtp_handle ) \n url_close ( rtsp_st -> rtp_handle ) ; \n rtsp_st -> rtp_handle = NULL ; \n } \n }", "idx": 268}
{"project": "FFmpeg", "commit_id": "69e7daf6ce2a5893936ba18572c58180b29d67f9", "target": 1, "func": "static void generate_offset_lut ( DiracGolombLUT * lut , int off ) \n { \n int idx ; \n for ( idx = 0 ; idx < LUT_SIZE ; idx ++ ) { \n DiracGolombLUT * l = & lut [ idx ] ; \n INIT_RESIDUE ( res ) ; \n SET_RESIDUE ( res , idx , LUT_BITS ) ; \n l -> preamble = CONVERT_TO_RESIDUE ( res >> ( RSIZE_BITS - off ) , off ) ; \n l -> preamble_bits = off ; \n l -> sign = ( ( l -> preamble >> ( RSIZE_BITS - l -> preamble_bits ) ) & 1 ) ? -1 : +1 ; \n search_for_golomb ( l , res << off , LUT_BITS - off ) ; \n } \n }", "idx": 342}
{"project": "FFmpeg", "commit_id": "a165b53daa8a3a526d2328ca72c4aa9e7f163045", "target": 1, "func": "static void RENAME ( vertical_compose53iL0 ) ( uint8_t * _b0 , uint8_t * _b1 , uint8_t * _b2 , \n int width ) \n { \n int i ; \n TYPE * b0 = ( TYPE * ) _b0 ; \n TYPE * b1 = ( TYPE * ) _b1 ; \n TYPE * b2 = ( TYPE * ) _b2 ; \n for ( i = 0 ; i < width ; i ++ ) \n b1 [ i ] -= ( b0 [ i ] + b2 [ i ] + 2 ) >> 2 ; \n }", "idx": 368}
{"project": "FFmpeg", "commit_id": "a8d67efa53dae1d14614e3a7bd4e77e4eab066ab", "target": 0, "func": "static int count_paired_channels ( uint8_t ( * layout_map ) [ 3 ] , int tags , int pos , int * current ) { \n int num_pos_channels = 0 ; \n int first_cpe = 0 ; \n int sce_parity = 0 ; \n int i ; \n for ( i = * current ; i < tags ; i ++ ) { \n if ( layout_map [ i ] [ 2 ] != pos ) \n break ; \n if ( layout_map [ i ] [ 0 ] == TYPE_CPE ) { \n if ( sce_parity ) { \n if ( pos == AAC_CHANNEL_FRONT || ! first_cpe ) { \n sce_parity = 0 ; \n } else { \n return -1 ; \n } \n } \n num_pos_channels += 2 ; \n first_cpe = 1 ; \n } else { \n num_pos_channels ++ ; \n sce_parity ^= 1 ; \n } \n } \n if ( sce_parity && \n ( ( pos == AAC_CHANNEL_FRONT && first_cpe ) || pos == AAC_CHANNEL_SIDE ) ) \n return -1 ; \n * current = i ; \n return num_pos_channels ; \n }", "idx": 420}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n VideoData * s = s1 -> priv_data ; \n char filename [ 1024 ] ; \n int ret ; \n ByteIOContext f1 , * f ; \n if ( get_frame_filename ( filename , sizeof ( filename ) , \n s -> path , s -> img_number ) < 0 ) \n return - EIO ; \n if ( ! s -> is_pipe ) { \n f = & f1 ; \n if ( url_fopen ( f , filename , URL_RDONLY ) < 0 ) \n return - EIO ; \n } else { \n f = & s1 -> pb ; \n if ( url_feof ( f ) ) \n return - EIO ; \n } \n av_new_packet ( pkt , s -> img_size ) ; \n pkt -> stream_index = 0 ; \n switch ( s -> img_fmt ) { \n case IMGFMT_PGMYUV : \n ret = pgm_read ( s , f , pkt -> data , pkt -> size , 1 ) ; \n break ; \n case IMGFMT_PGM : \n ret = pgm_read ( s , f , pkt -> data , pkt -> size , 0 ) ; \n break ; \n case IMGFMT_YUV : \n ret = yuv_read ( s , filename , pkt -> data , pkt -> size ) ; \n break ; \n case IMGFMT_PPM : \n ret = ppm_read ( s , f , pkt -> data , pkt -> size ) ; \n break ; \n default : \n return - EIO ; \n } \n if ( ! s -> is_pipe ) { \n url_fclose ( f ) ; \n } \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return - EIO ; \n } else { \n s -> img_number ++ ; \n return 0 ; \n } \n }", "idx": 446}
{"project": "FFmpeg", "commit_id": "330deb75923675224fb9aed311d3d6ce3ec52420", "target": 1, "func": "static void backup_duplicate_context ( MpegEncContext * bak , MpegEncContext * src ) { \n #define COPY ( a )  bak->a= src->a  \n  \n  COPY ( allocated_edge_emu_buffer ) ; \n COPY ( edge_emu_buffer ) ; \n COPY ( me . scratchpad ) ; \n COPY ( me . temp ) ; \n COPY ( rd_scratchpad ) ; \n COPY ( b_scratchpad ) ; \n COPY ( obmc_scratchpad ) ; \n COPY ( me . map ) ; \n COPY ( me . score_map ) ; \n COPY ( blocks ) ; \n COPY ( block ) ; \n COPY ( start_mb_y ) ; \n COPY ( end_mb_y ) ; \n COPY ( me . map_generation ) ; \n COPY ( pb ) ; \n COPY ( dct_error_sum ) ; \n COPY ( dct_count [ 0 ] ) ; \n COPY ( dct_count [ 1 ] ) ; \n COPY ( ac_val_base ) ; \n COPY ( ac_val [ 0 ] ) ; \n COPY ( ac_val [ 1 ] ) ; \n COPY ( ac_val [ 2 ] ) ; \n #undef  COPY  \n  \n  }", "idx": 646}
{"project": "FFmpeg", "commit_id": "84343dd9d3b8e19c95c0f641a9f97915efec0633", "target": 0, "func": "static av_cold void free_frame_buffers ( Indeo3DecodeContext * ctx ) \n { \n int p ; \n ctx -> width = \n ctx -> height = 0 ; \n for ( p = 0 ; p < 3 ; p ++ ) { \n av_freep ( & ctx -> planes [ p ] . buffers [ 0 ] ) ; \n av_freep ( & ctx -> planes [ p ] . buffers [ 1 ] ) ; \n ctx -> planes [ p ] . pixels [ 0 ] = ctx -> planes [ p ] . pixels [ 1 ] = 0 ; \n } \n }", "idx": 653}
{"project": "FFmpeg", "commit_id": "a8dbe9514f865f6a8efb304a720025cb1ef9ae3f", "target": 0, "func": "static AVInputFormat * probe_input_format ( AVProbeData * pd , int is_opened ) \n { \n AVInputFormat * fmt1 , * fmt ; \n int score , score_max ; \n fmt = NULL ; \n score_max = 0 ; \n for ( fmt1 = first_iformat ; fmt1 != NULL ; fmt1 = fmt1 -> next ) { \n if ( ! is_opened && ! ( fmt1 -> flags & AVFMT_NOFILE ) ) \n continue ; \n score = 0 ; \n if ( fmt1 -> extensions ) { \n if ( match_ext ( pd -> filename , fmt1 -> extensions ) ) { \n score = 50 ; \n } \n } else if ( fmt1 -> read_probe ) { \n score = fmt1 -> read_probe ( pd ) ; \n } \n if ( score > score_max ) { \n score_max = score ; \n fmt = fmt1 ; \n } \n } \n return fmt ; \n }", "idx": 668}
{"project": "FFmpeg", "commit_id": "69fa23961ededd725c68b188493cf2653d70f4fd", "target": 1, "func": "int av_seek_frame ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n int ret ; \n AVStream * st ; \n ff_read_frame_flush ( s ) ; \n if ( flags & AVSEEK_FLAG_BYTE ) \n return av_seek_frame_byte ( s , stream_index , timestamp , flags ) ; \n if ( stream_index < 0 ) { \n stream_index = av_find_default_stream_index ( s ) ; \n if ( stream_index < 0 ) \n return -1 ; \n st = s -> streams [ stream_index ] ; \n timestamp = av_rescale ( timestamp , st -> time_base . den , AV_TIME_BASE * ( int64_t ) st -> time_base . num ) ; \n } \n if ( s -> iformat -> read_seek ) \n ret = s -> iformat -> read_seek ( s , stream_index , timestamp , flags ) ; \n else \n ret = -1 ; \n if ( ret >= 0 ) { \n return 0 ; \n } \n if ( s -> iformat -> read_timestamp ) \n return av_seek_frame_binary ( s , stream_index , timestamp , flags ) ; \n else \n return av_seek_frame_generic ( s , stream_index , timestamp , flags ) ; \n }", "idx": 682}
{"project": "FFmpeg", "commit_id": "fa0f62c37d90c0760bddccba2054578e2c61ae1a", "target": 0, "func": "static int mpeg_mux_end ( AVFormatContext * ctx ) \n { \n StreamInfo * stream ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) { \n stream = ctx -> streams [ i ] -> priv_data ; \n if ( stream -> buffer_ptr > 0 ) { \n if ( i == ( ctx -> nb_streams - 1 ) ) \n flush_packet ( ctx , i , 1 ) ; \n else \n flush_packet ( ctx , i , 0 ) ; \n } \n } \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) \n av_freep ( & ctx -> streams [ i ] -> priv_data ) ; \n return 0 ; \n }", "idx": 691}
{"project": "FFmpeg", "commit_id": "ca8064d2d1b293d7a8011bf0a08005c11ae8ba67", "target": 1, "func": "static int opt_new_stream ( const char * opt , const char * arg ) \n { \n AVFormatContext * oc ; \n if ( nb_output_files <= 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n oc = output_files [ nb_output_files - 1 ] ; \n if ( ! strcmp ( opt , \" \" ) ) new_video_stream ( oc ) ; \n else if ( ! strcmp ( opt , \" \" ) ) new_audio_stream ( oc ) ; \n else if ( ! strcmp ( opt , \" \" ) ) new_subtitle_stream ( oc ) ; \n else av_assert0 ( 0 ) ; \n return 0 ; \n }", "idx": 713}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_v_loop_filter_c ( uint8_t * first_pixel , int stride , int * bounding_values ) \n { \n unsigned char * end ; \n int filter_value ; \n const int nstride = - stride ; \n for ( end = first_pixel + 8 ; first_pixel < end ; first_pixel ++ ) { \n filter_value = \n ( first_pixel [ 2 * nstride ] - first_pixel [ stride ] ) \n + 3 * ( first_pixel [ 0 ] - first_pixel [ nstride ] ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ nstride ] = av_clip_uint8 ( first_pixel [ nstride ] + filter_value ) ; \n first_pixel [ 0 ] = av_clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 734}
{"project": "FFmpeg", "commit_id": "12ba1b2b4d5592c0e27b0fcc83db929e8d6a8eee", "target": 0, "func": "static inline void mct_decode ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile ) \n { \n int i , csize = 1 ; \n void * src [ 3 ] ; \n for ( i = 1 ; i < 3 ; i ++ ) \n if ( tile -> codsty [ 0 ] . transform != tile -> codsty [ i ] . transform ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) \n if ( tile -> codsty [ 0 ] . transform == FF_DWT97 ) \n src [ i ] = tile -> comp [ i ] . f_data ; \n else \n src [ i ] = tile -> comp [ i ] . i_data ; \n for ( i = 0 ; i < 2 ; i ++ ) \n csize *= tile -> comp [ 0 ] . coord [ i ] [ 1 ] - tile -> comp [ 0 ] . coord [ i ] [ 0 ] ; \n s -> dsp . mct_decode [ tile -> codsty [ 0 ] . transform ] ( src [ 0 ] , src [ 1 ] , src [ 2 ] , csize ) ; \n }", "idx": 757}
{"project": "FFmpeg", "commit_id": "25a6666f6c07c6ac8449a63d7fbce0dfd29c54cd", "target": 0, "func": "static int ivi_mc ( ivi_mc_func mc , int16_t * buf , const int16_t * ref_buf , \n int offs , int mv_x , int mv_y , uint32_t pitch , \n int mc_type ) \n { \n int ref_offs = offs + mv_y * pitch + mv_x ; \n if ( offs < 0 || ref_offs < 0 || ! ref_buf ) \n return AVERROR_INVALIDDATA ; \n mc ( buf + offs , ref_buf + ref_offs , pitch , mc_type ) ; \n return 0 ; \n }", "idx": 795}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static av_always_inline void decode_dc_coeffs ( GetBitContext * gb , int16_t * out , \n int blocks_per_slice ) \n { \n int16_t prev_dc ; \n int code , i , sign ; \n OPEN_READER ( re , gb ) ; \n DECODE_CODEWORD ( code , FIRST_DC_CB ) ; \n prev_dc = TOSIGNED ( code ) ; \n out [ 0 ] = prev_dc ; \n out += 64 ; \n code = 5 ; \n sign = 0 ; \n for ( i = 1 ; i < blocks_per_slice ; i ++ , out += 64 ) { \n DECODE_CODEWORD ( code , dc_codebook [ FFMIN ( code , 6U ) ] ) ; \n if ( code ) sign ^= - ( code & 1 ) ; \n else sign = 0 ; \n prev_dc += ( ( ( code + 1 ) >> 1 ) ^ sign ) - sign ; \n out [ 0 ] = prev_dc ; \n } \n CLOSE_READER ( re , gb ) ; \n }", "idx": 850}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_midh_qrt_and_aver_dst_8w_msa ( const uint8_t * src , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride , \n int32_t height , \n uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_and_aver_dst_4w_msa ( src , src_stride , dst , dst_stride , \n height , horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 854}
{"project": "FFmpeg", "commit_id": "f1cd9b03f3fa875eb5e394281b4b688cec611658", "target": 1, "func": "static av_cold OMXContext * omx_init ( void * logctx , const char * libname , const char * prefix ) \n { \n static const char * const libnames [ ] = { \n \" \" , \n \" \" , \n NULL \n } ; \n const char * const * nameptr ; \n int ret = AVERROR_ENCODER_NOT_FOUND ; \n OMXContext * omx_context ; \n omx_context = av_mallocz ( sizeof ( * omx_context ) ) ; \n if ( ! omx_context ) \n return NULL ; \n if ( libname ) { \n ret = omx_try_load ( omx_context , logctx , libname , prefix ) ; \n if ( ret < 0 ) { \n av_free ( omx_context ) ; \n return NULL ; \n } \n } else { \n for ( nameptr = libnames ; * nameptr ; nameptr ++ ) \n if ( ! ( ret = omx_try_load ( omx_context , logctx , * nameptr , prefix ) ) ) \n break ; \n if ( ! * nameptr ) { \n av_free ( omx_context ) ; \n return NULL ; \n } \n } \n omx_context -> ptr_Init ( ) ; \n return omx_context ; \n }", "idx": 863}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int av_get_channel_layout_nb_channels ( int64_t channel_layout ) \n { \n int count ; \n uint64_t x = channel_layout ; \n for ( count = 0 ; x ; count ++ ) \n x &= x - 1 ; \n return count ; \n }", "idx": 867}
{"project": "FFmpeg", "commit_id": "f1a4dd5e480932ee580fb686988599d46bb71637", "target": 1, "func": "static int decode0 ( GetByteContext * gb , RangeCoder * rc , unsigned cumFreq , unsigned freq , unsigned total_freq ) \n { \n int t ; \n if ( total_freq == 0 ) \n return AVERROR_INVALIDDATA ; \n t = rc -> range * ( uint64_t ) cumFreq / total_freq ; \n rc -> code1 += t + 1 ; \n rc -> range = rc -> range * ( uint64_t ) ( freq + cumFreq ) / total_freq - ( t + 1 ) ; \n while ( rc -> range < TOP && bytestream2_get_bytes_left ( gb ) > 0 ) { \n unsigned byte = bytestream2_get_byte ( gb ) ; \n rc -> code = ( rc -> code << 8 ) | byte ; \n rc -> code1 <<= 8 ; \n rc -> range <<= 8 ; \n } \n return 0 ; \n }", "idx": 1003}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_410 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , \n uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y , i , j ; \n int width = frame -> width ; \n int ystride = frame -> linesize [ 0 ] ; \n int ustride = frame -> linesize [ 1 ] ; \n int vstride = frame -> linesize [ 2 ] ; \n uint8_t * Y = frame -> data [ 0 ] + ystride * line ; \n uint8_t * U = frame -> data [ 1 ] + ( ustride >> 2 ) * line ; \n uint8_t * V = frame -> data [ 2 ] + ( vstride >> 2 ) * line ; \n for ( y = 0 ; y < left - 3 && get_bits_left ( gb ) > 16 ; y += 4 ) { \n for ( x = 0 ; x < width ; x += 4 ) { \n for ( j = 0 ; j < 4 ; j ++ ) \n for ( i = 0 ; i < 4 ; i ++ ) \n Y [ x + i + j * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n U [ x >> 2 ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; \n V [ x >> 2 ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; \n } \n Y += ystride << 2 ; \n U += ustride ; \n V += vstride ; \n } \n return y ; \n }", "idx": 1042}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_y2_mmx ( UINT8 * block , const UINT8 * pixels , int line_size , int h ) \n { \n UINT8 * p ; \n const UINT8 * pix ; \n p = block ; \n pix = pixels ; \n MOVQ_ZERO ( mm7 ) ; \n JUMPALIGN ( ) ; \n do { \n __asm __volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" = m \" ( * p ) \n : \" m \" ( * pix ) , \n \" \" ( * ( pix + line_size ) ) \n : \" \" ) ; \n pix += line_size ; \n p += line_size ; \n } while ( -- h ) ; \n }", "idx": 1065}
{"project": "FFmpeg", "commit_id": "7f6e05cdfd1242a6774e89283b6e2cefde191590", "target": 1, "func": "static inline int sym_quant ( int c , int e , int levels ) \n { \n int v = ( ( ( ( levels * c ) >> ( 24 - e ) ) + 1 ) >> 1 ) + ( levels >> 1 ) ; \n av_assert2 ( v >= 0 && v < levels ) ; \n return v ; \n }", "idx": 1090}
{"project": "FFmpeg", "commit_id": "60819e694ee5733741da91ebc237b20621de5bc3", "target": 1, "func": "void av_cold ff_ivi_free_buffers ( IVIPlaneDesc * planes ) \n { \n int p , b , t ; \n for ( p = 0 ; p < 3 ; p ++ ) { \n for ( b = 0 ; b < planes [ p ] . num_bands ; b ++ ) { \n av_freep ( & planes [ p ] . bands [ b ] . bufs [ 0 ] ) ; \n av_freep ( & planes [ p ] . bands [ b ] . bufs [ 1 ] ) ; \n av_freep ( & planes [ p ] . bands [ b ] . bufs [ 2 ] ) ; \n for ( t = 0 ; t < planes [ p ] . bands [ b ] . num_tiles ; t ++ ) \n av_freep ( & planes [ p ] . bands [ b ] . tiles [ t ] . mbs ) ; \n av_freep ( & planes [ p ] . bands [ b ] . tiles ) ; \n } \n av_freep ( & planes [ p ] . bands ) ; \n } \n }", "idx": 1132}
{"project": "FFmpeg", "commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "target": 1, "func": "static int pix_norm1_altivec ( uint8_t * pix , int line_size ) \n { \n int i , s = 0 ; \n const vector unsigned  int zero = \n ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector unsigned  int sv = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector signed  int sum ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n vector unsigned  char pixv = vec_vsx_ld ( 0 , pix ) ; \n sv = vec_msum ( pixv , pixv , sv ) ; \n pix += line_size ; \n } \n sum = vec_sums ( ( vector signed int ) sv , ( vector signed int ) zero ) ; \n sum = vec_splat ( sum , 3 ) ; \n vec_vsx_st ( sum , 0 , & s ) ; \n return s ; \n }", "idx": 1151}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_register_kernel_code ( const char * kernel_code ) \n { \n int i , ret = 0 ; \n LOCK_OPENCL ; \n if ( gpu_env . kernel_code_count >= MAX_KERNEL_CODE_NUM ) { \n av_log ( & openclutils , AV_LOG_ERROR , \n \" \\n \" , \n MAX_KERNEL_CODE_NUM ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n for ( i = 0 ; i < gpu_env . kernel_code_count ; i ++ ) { \n if ( gpu_env . kernel_code [ i ] . kernel_string == kernel_code ) { \n av_log ( & openclutils , AV_LOG_WARNING , \" \\n \" ) ; \n goto end ; \n } \n } \n gpu_env . kernel_code [ gpu_env . kernel_code_count ] . kernel_string = kernel_code ; \n gpu_env . kernel_code [ gpu_env . kernel_code_count ] . is_compiled = 0 ; \n gpu_env . kernel_code_count ++ ; \n end : \n UNLOCK_OPENCL ; \n return ret ; \n }", "idx": 1274}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "av_cold void ff_videodsp_init_x86 ( VideoDSPContext * ctx , int bpc ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_MMX ( cpu_flags ) && bpc <= 8 ) { \n ctx -> emulated_edge_mc = emulated_edge_mc_mmx ; \n } \n if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) { \n ctx -> prefetch = ff_prefetch_3dnow ; \n } \n #endif \n if ( EXTERNAL_MMXEXT ( cpu_flags ) ) { \n ctx -> prefetch = ff_prefetch_mmxext ; \n #if ARCH_X86_32  \n  \n  if ( bpc <= 8 ) \n ctx -> emulated_edge_mc = emulated_edge_mc_mmxext ; \n #endif \n } \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_SSE ( cpu_flags ) && bpc <= 8 ) { \n ctx -> emulated_edge_mc = emulated_edge_mc_sse ; \n } \n #endif \n if ( EXTERNAL_SSE2 ( cpu_flags ) && bpc <= 8 ) { \n ctx -> emulated_edge_mc = emulated_edge_mc_sse2 ; \n } \n #endif \n }", "idx": 1324}
{"project": "FFmpeg", "commit_id": "083d0f6be8a22ce936c4be6f17977104e516434f", "target": 1, "func": "static void filter_samples ( AVFilterLink * inlink , AVFilterBufferRef * samplesref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) \n ff_filter_samples ( inlink -> dst -> outputs [ i ] , \n avfilter_ref_buffer ( samplesref , ~ AV_PERM_WRITE ) ) ; \n }", "idx": 1372}
{"project": "FFmpeg", "commit_id": "9f06c1c61e876e930753da200bfe835817e30a53", "target": 1, "func": "static inline int decode_residual_inter ( AVSContext * h ) { \n int block ; \n int cbp = get_ue_golomb ( & h -> s . gb ) ; \n if ( cbp > 63 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n h -> cbp = cbp_tab [ cbp ] [ 1 ] ; \n if ( h -> cbp && ! h -> qp_fixed ) \n h -> qp = ( h -> qp + get_se_golomb ( & h -> s . gb ) ) & 63 ; \n for ( block = 0 ; block < 4 ; block ++ ) \n if ( h -> cbp & ( 1 << block ) ) \n decode_residual_block ( h , & h -> s . gb , ff_cavs_inter_dec , 0 , h -> qp , \n h -> cy + h -> luma_scan [ block ] , h -> l_stride ) ; \n decode_residual_chroma ( h ) ; \n return 0 ; \n }", "idx": 1388}
{"project": "FFmpeg", "commit_id": "87f29996415ad2c06ab00583d709fa03b5185305", "target": 1, "func": "static int gif_image_write_header ( AVFormatContext * s , int width , int height , \n int loop_count , uint32_t * palette ) \n { \n AVIOContext * pb = s -> pb ; \n AVRational sar = s -> streams [ 0 ] -> codec -> sample_aspect_ratio ; \n int i , aspect = 0 ; \n if ( sar . num > 0 && sar . den > 0 ) { \n aspect = sar . num * 64 / sar . den - 15 ; \n if ( aspect < 0 || aspect > 255 ) \n aspect = 0 ; \n } \n avio_write ( pb , \" \" , 3 ) ; \n avio_write ( pb , \" \" , 3 ) ; \n avio_wl16 ( pb , width ) ; \n avio_wl16 ( pb , height ) ; \n if ( palette ) { \n avio_w8 ( pb , 0xf7 ) ; \n avio_w8 ( pb , 0x1f ) ; \n avio_w8 ( pb , aspect ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n const uint32_t v = palette [ i ] & 0xffffff ; \n avio_wb24 ( pb , v ) ; \n } \n } else { \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , aspect ) ; \n } \n if ( loop_count >= 0 ) { \n avio_w8 ( pb , 0x21 ) ; \n avio_w8 ( pb , 0xff ) ; \n avio_w8 ( pb , 0x0b ) ; \n avio_write ( pb , \" \" , sizeof ( \" \" ) - 1 ) ; \n avio_w8 ( pb , 0x03 ) ; \n avio_w8 ( pb , 0x01 ) ; \n avio_wl16 ( pb , ( uint16_t ) loop_count ) ; \n avio_w8 ( pb , 0x00 ) ; \n } \n return 0 ; \n }", "idx": 1422}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char P [ 4 ] ; \n int flags = 0 ; \n CHECK_STREAM_PTR ( 24 ) ; \n if ( s -> stream_ptr [ 0 ] <= s -> stream_ptr [ 1 ] ) { \n CHECK_STREAM_PTR ( 32 ) ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n memcpy ( P , s -> stream_ptr , 4 ) ; \n s -> stream_ptr += 4 ; \n flags = bytestream_get_le32 ( & s -> stream_ptr ) ; \n } \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } \n } else { \n int vert = s -> stream_ptr [ 12 ] <= s -> stream_ptr [ 13 ] ; \n uint64_t flags = 0 ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n if ( ! ( y & 7 ) ) { \n memcpy ( P , s -> stream_ptr , 4 ) ; \n s -> stream_ptr += 4 ; \n flags = bytestream_get_le64 ( & s -> stream_ptr ) ; \n } \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n if ( vert ) { \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } else if ( y & 1 ) s -> pixel_ptr += s -> line_inc ; \n } \n } \n return 0 ; \n }", "idx": 1441}
{"project": "FFmpeg", "commit_id": "3ba105029279bf43e6338849f360f1ce9a2973a0", "target": 1, "func": "static void imc_get_coeffs ( AVCodecContext * avctx , \n IMCContext * q , IMCChannel * chctx ) \n { \n int i , j , cw_len , cw ; \n for ( i = 0 ; i < BANDS ; i ++ ) { \n if ( ! chctx -> sumLenArr [ i ] ) \n continue ; \n if ( chctx -> bandFlagsBuf [ i ] || chctx -> bandWidthT [ i ] ) { \n for ( j = band_tab [ i ] ; j < band_tab [ i + 1 ] ; j ++ ) { \n cw_len = chctx -> CWlengthT [ j ] ; \n cw = 0 ; \n if ( cw_len && ( ! chctx -> bandFlagsBuf [ i ] || ! chctx -> skipFlags [ j ] ) ) { \n if ( get_bits_count ( & q -> gb ) + cw_len > 512 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" , i , j , cw_len ) ; \n } \n cw = get_bits ( & q -> gb , cw_len ) ; \n } \n chctx -> codewords [ j ] = cw ; \n } \n } \n } \n }", "idx": 1459}
{"project": "FFmpeg", "commit_id": "b0a043f51b8cc3b420dc3ceaa38fe9aa344799aa", "target": 1, "func": "static int dcstr_read_header ( AVFormatContext * s ) \n { \n unsigned codec , align ; \n AVStream * st ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codecpar -> channels = avio_rl32 ( s -> pb ) ; \n st -> codecpar -> sample_rate = avio_rl32 ( s -> pb ) ; \n codec = avio_rl32 ( s -> pb ) ; \n align = avio_rl32 ( s -> pb ) ; \n avio_skip ( s -> pb , 4 ) ; \n st -> duration = avio_rl32 ( s -> pb ) ; \n st -> codecpar -> channels *= avio_rl32 ( s -> pb ) ; \n if ( ! align || align > INT_MAX / st -> codecpar -> channels ) \n return AVERROR_INVALIDDATA ; \n st -> codecpar -> block_align = align * st -> codecpar -> channels ; \n switch ( codec ) { \n case 4 : st -> codecpar -> codec_id = AV_CODEC_ID_ADPCM_AICA ; break ; \n case 16 : st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16LE_PLANAR ; break ; \n default : avpriv_request_sample ( s , \" \" , codec ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avio_skip ( s -> pb , 0x800 - avio_tell ( s -> pb ) ) ; \n avpriv_set_pts_info ( st , 64 , 1 , st -> codecpar -> sample_rate ) ; \n return 0 ; \n }", "idx": 1826}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int mjpeg_decode_dht ( MJpegDecodeContext * s ) \n { \n int len , index , i , class , n , v , code_max ; \n uint8_t bits_table [ 17 ] ; \n uint8_t val_table [ 256 ] ; \n len = get_bits ( & s -> gb , 16 ) - 2 ; \n while ( len > 0 ) { \n if ( len < 17 ) \n return -1 ; \n class = get_bits ( & s -> gb , 4 ) ; \n if ( class >= 2 ) \n return -1 ; \n index = get_bits ( & s -> gb , 4 ) ; \n if ( index >= 4 ) \n return -1 ; \n n = 0 ; \n for ( i = 1 ; i <= 16 ; i ++ ) { \n bits_table [ i ] = get_bits ( & s -> gb , 8 ) ; \n n += bits_table [ i ] ; \n } \n len -= 17 ; \n if ( len < n || n > 256 ) \n return -1 ; \n code_max = 0 ; \n for ( i = 0 ; i < n ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n if ( v > code_max ) \n code_max = v ; \n val_table [ i ] = v ; \n } \n len -= n ; \n free_vlc ( & s -> vlcs [ class ] [ index ] ) ; \n dprintf ( \" \\n \" , \n class , index , code_max + 1 ) ; \n if ( build_vlc ( & s -> vlcs [ class ] [ index ] , bits_table , val_table , code_max + 1 ) < 0 ) { \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 1872}
{"project": "FFmpeg", "commit_id": "68f8d33becbd73b4d0aa277f472a6e8e72ea6849", "target": 0, "func": "static inline int get_symbol_inline ( RangeCoder * c , uint8_t * state , int is_signed ) { \n if ( get_rac ( c , state + 0 ) ) \n return 0 ; \n else { \n int i , e , a ; \n e = 0 ; \n while ( get_rac ( c , state + 1 + e ) && e < 9 ) { \n e ++ ; \n } \n a = 1 ; \n for ( i = e - 1 ; i >= 0 ; i -- ) { \n a += a + get_rac ( c , state + 22 + i ) ; \n } \n e = - ( is_signed && get_rac ( c , state + 11 + e ) ) ; \n return ( a ^ e ) - e ; \n } \n }", "idx": 2017}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_1r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 512 ] ; \n samples [ i + 256 ] += samples [ i + 512 ] ; \n samples [ i + 512 ] = 0 ; \n } \n }", "idx": 2158}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static PayloadContext * h264_new_extradata ( void ) \n { \n PayloadContext * data = \n av_mallocz ( sizeof ( PayloadContext ) + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( data ) { \n data -> cookie = MAGIC_COOKIE ; \n } \n return data ; \n }", "idx": 2160}
{"project": "FFmpeg", "commit_id": "a06b0b1295c51d100101e0ca0434e199ad6de6b5", "target": 1, "func": "static int decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n if ( ! avctx -> internal -> is_copy ) \n return 0 ; \n memset ( h -> sps_buffers , 0 , sizeof ( h -> sps_buffers ) ) ; \n memset ( h -> pps_buffers , 0 , sizeof ( h -> pps_buffers ) ) ; \n h -> rbsp_buffer [ 0 ] = NULL ; \n h -> rbsp_buffer [ 1 ] = NULL ; \n h -> rbsp_buffer_size [ 0 ] = 0 ; \n h -> rbsp_buffer_size [ 1 ] = 0 ; \n h -> context_initialized = 0 ; \n return 0 ; \n }", "idx": 2235}
{"project": "FFmpeg", "commit_id": "c842aa378db6c9da156bd245b8f8d05d889e3d7e", "target": 1, "func": "static int dvvideo_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n DVVideoContext * s = avctx -> priv_data ; \n s -> sys = dv_frame_profile ( buf ) ; \n if ( ! s -> sys || buf_size < s -> sys -> frame_size ) \n return -1 ; \n if ( s -> picture . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> picture ) ; \n s -> picture . reference = 0 ; \n s -> picture . key_frame = 1 ; \n s -> picture . pict_type = FF_I_TYPE ; \n avctx -> pix_fmt = s -> sys -> pix_fmt ; \n avcodec_set_dimensions ( avctx , s -> sys -> width , s -> sys -> height ) ; \n if ( avctx -> get_buffer ( avctx , & s -> picture ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> picture . interlaced_frame = 1 ; \n s -> picture . top_field_first = 0 ; \n s -> buf = buf ; \n avctx -> execute ( avctx , dv_decode_mt , ( void * * ) & dv_anchor [ 0 ] , NULL , \n s -> sys -> difseg_size * 27 ) ; \n emms_c ( ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> picture ; \n return s -> sys -> frame_size ; \n }", "idx": 2238}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void mpeg_er_decode_mb ( void * opaque , int ref , int mv_dir , int mv_type , \n int ( * mv ) [ 2 ] [ 4 ] [ 2 ] , \n int mb_x , int mb_y , int mb_intra , int mb_skipped ) \n { \n MpegEncContext * s = opaque ; \n s -> mv_dir = mv_dir ; \n s -> mv_type = mv_type ; \n s -> mb_intra = mb_intra ; \n s -> mb_skipped = mb_skipped ; \n s -> mb_x = mb_x ; \n s -> mb_y = mb_y ; \n memcpy ( s -> mv , mv , sizeof ( * mv ) ) ; \n ff_init_block_index ( s ) ; \n ff_update_block_index ( s ) ; \n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ; \n s -> dest [ 0 ] = s -> current_picture . f . data [ 0 ] + ( s -> mb_y * 16 * s -> linesize ) + s -> mb_x * 16 ; \n s -> dest [ 1 ] = s -> current_picture . f . data [ 1 ] + ( s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize ) + s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n s -> dest [ 2 ] = s -> current_picture . f . data [ 2 ] + ( s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize ) + s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n assert ( ref == 0 ) ; \n ff_MPV_decode_mb ( s , s -> block ) ; \n }", "idx": 2260}
{"project": "FFmpeg", "commit_id": "90da2b50865549e086d4491cbb2bdc54af38ea4f", "target": 1, "func": "static void opt_frame_pix_fmt ( const char * arg ) \n { \n if ( strcmp ( arg , \" \" ) ) \n frame_pix_fmt = avcodec_get_pix_fmt ( arg ) ; \n else { \n list_fmts ( avcodec_pix_fmt_string , PIX_FMT_NB ) ; \n av_exit ( 0 ) ; \n } \n }", "idx": 2385}
{"project": "FFmpeg", "commit_id": "770c934fa1635f4fadf5db4fc5cc5ad15d82455a", "target": 1, "func": "void ff_mdct_calcw_c ( FFTContext * s , FFTDouble * out , const FFTSample * input ) \n { \n int i , j , n , n8 , n4 , n2 , n3 ; \n FFTDouble re , im ; \n const uint16_t * revtab = s -> revtab ; \n const FFTSample * tcos = s -> tcos ; \n const FFTSample * tsin = s -> tsin ; \n FFTComplex * x = s -> tmp_buf ; \n FFTDComplex * o = ( FFTDComplex * ) out ; \n n = 1 << s -> mdct_bits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n n8 = n >> 3 ; \n n3 = 3 * n4 ; \n for ( i = 0 ; i < n8 ; i ++ ) { \n re = RSCALE ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ; \n im = RSCALE ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ; \n j = revtab [ i ] ; \n CMUL ( x [ j ] . re , x [ j ] . im , re , im , - tcos [ i ] , tsin [ i ] ) ; \n re = RSCALE ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ; \n im = RSCALE ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ; \n j = revtab [ n8 + i ] ; \n CMUL ( x [ j ] . re , x [ j ] . im , re , im , - tcos [ n8 + i ] , tsin [ n8 + i ] ) ; \n } \n s -> fft_calc ( s , x ) ; \n for ( i = 0 ; i < n8 ; i ++ ) { \n FFTDouble r0 , i0 , r1 , i1 ; \n CMULL ( i1 , r0 , x [ n8 - i - 1 ] . re , x [ n8 - i - 1 ] . im , - tsin [ n8 - i - 1 ] , - tcos [ n8 - i - 1 ] ) ; \n CMULL ( i0 , r1 , x [ n8 + i ] . re , x [ n8 + i ] . im , - tsin [ n8 + i ] , - tcos [ n8 + i ] ) ; \n o [ n8 - i - 1 ] . re = r0 ; \n o [ n8 - i - 1 ] . im = i0 ; \n o [ n8 + i ] . re = r1 ; \n o [ n8 + i ] . im = i1 ; \n } \n }", "idx": 2450}
{"project": "FFmpeg", "commit_id": "7c7e7464e3f49e9a1fa98b06c4261e75ce71290b", "target": 1, "func": "static int mmap_read_frame ( struct video_data * s , void * frame , int64_t * ts ) \n { \n struct v4l2_buffer buf ; \n int res ; \n memset ( & buf , 0 , sizeof ( struct v4l2_buffer ) ) ; \n buf . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n buf . memory = V4L2_MEMORY_MMAP ; \n while ( ( res = ioctl ( s -> fd , VIDIOC_DQBUF , & buf ) ) < 0 && \n ( ( errno == EAGAIN ) || ( errno == EINTR ) ) ) ; \n if ( res < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , strerror ( errno ) ) ; \n return -1 ; \n } \n assert ( buf . index < s -> buffers ) ; \n assert ( buf . bytesused == s -> frame_size ) ; \n memcpy ( frame , s -> buf_start [ buf . index ] , buf . bytesused ) ; \n * ts = buf . timestamp . tv_sec * int64_t_C ( 1000000 ) + buf . timestamp . tv_usec ; \n res = ioctl ( s -> fd , VIDIOC_QBUF , & buf ) ; \n if ( res < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n return s -> buf_len [ buf . index ] ; \n }", "idx": 2496}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int read_uncompressed_sgi ( unsigned char * out_buf , uint8_t * out_end , \n const uint8_t * in_buf , const uint8_t * in_end , SgiState * s ) \n { \n int x , y , z ; \n const uint8_t * ptr ; \n unsigned int offset = s -> height * s -> width * s -> bytes_per_channel ; \n if ( offset * s -> depth > in_end - in_buf ) { \n return -1 ; \n } \n for ( y = s -> height - 1 ; y >= 0 ; y -- ) { \n out_end = out_buf + ( y * s -> linesize ) ; \n for ( x = s -> width ; x > 0 ; x -- ) { \n ptr = in_buf += s -> bytes_per_channel ; \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n memcpy ( out_end , ptr , s -> bytes_per_channel ) ; \n out_end += s -> bytes_per_channel ; \n ptr += offset ; \n } \n } \n } \n return 0 ; \n }", "idx": 2676}
{"project": "FFmpeg", "commit_id": "308429e124b97337a768839c1d5091900e974e7e", "target": 0, "func": "static void peak_write_chunk ( AVFormatContext * s ) \n { \n WAVMuxContext * wav = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int64_t peak = ff_start_tag ( s -> pb , \" \" ) ; \n int64_t now0 ; \n time_t now_secs ; \n char timestamp [ 28 ] ; \n if ( wav -> peak_block_pos ) \n peak_write_frame ( s ) ; \n memset ( timestamp , 0 , sizeof ( timestamp ) ) ; \n if ( ! ( s -> flags & AVFMT_FLAG_BITEXACT ) ) { \n struct tm tmpbuf ; \n av_log ( s , AV_LOG_INFO , \" \\n \" ) ; \n now0 = av_gettime ( ) ; \n now_secs = now0 / 1000000 ; \n strftime ( timestamp , sizeof ( timestamp ) , \" \" , localtime_r ( & now_secs , & tmpbuf ) ) ; \n av_strlcatf ( timestamp , sizeof ( timestamp ) , \" \" , ( int ) ( ( now0 / 1000 ) % 1000 ) ) ; \n } \n avio_wl32 ( pb , 1 ) ; \n avio_wl32 ( pb , wav -> peak_format ) ; \n avio_wl32 ( pb , wav -> peak_ppv ) ; \n avio_wl32 ( pb , wav -> peak_block_size ) ; \n avio_wl32 ( pb , enc -> channels ) ; \n avio_wl32 ( pb , wav -> peak_num_frames ) ; \n avio_wl32 ( pb , wav -> peak_pos_pop ) ; \n avio_wl32 ( pb , 128 ) ; \n avio_write ( pb , timestamp , 28 ) ; \n ffio_fill ( pb , 0 , 60 ) ; \n avio_write ( pb , wav -> peak_output , wav -> peak_outbuf_bytes ) ; \n ff_end_tag ( pb , peak ) ; \n if ( ! wav -> data ) \n wav -> data = peak ; \n }", "idx": 3189}
{"project": "FFmpeg", "commit_id": "6ff3f3e7cec7cd78a01d0bf76cbccfbe68dc0894", "target": 0, "func": "int ff_socket_nonblock ( int socket , int enable ) \n { \n #ifdef __MINGW32__ \n return ioctlsocket ( socket , FIONBIO , & enable ) ; \n #else \n if ( enable ) \n return fcntl ( socket , F_SETFL , fcntl ( socket , F_GETFL ) | O_NONBLOCK ) ; \n else \n return fcntl ( socket , F_SETFL , fcntl ( socket , F_GETFL ) & ~ O_NONBLOCK ) ; \n #endif \n }", "idx": 3232}
{"project": "FFmpeg", "commit_id": "ae43c10e36197000de2f3cc99ea35727ce98a796", "target": 0, "func": "static int replaygain_export ( AVStream * st , \n const uint8_t * track_gain , const uint8_t * track_peak , \n const uint8_t * album_gain , const uint8_t * album_peak ) \n { \n AVPacketSideData * sd , * tmp ; \n AVReplayGain * replaygain ; \n int32_t tg , ag ; \n uint32_t tp , ap ; \n tg = parse_value ( track_gain , INT32_MIN ) ; \n ag = parse_value ( album_gain , INT32_MIN ) ; \n tp = parse_value ( track_peak , 0 ) ; \n ap = parse_value ( album_peak , 0 ) ; \n if ( tg == INT32_MIN && ag == INT32_MIN ) \n return 0 ; \n replaygain = av_mallocz ( sizeof ( * replaygain ) ) ; \n if ( ! replaygain ) \n return AVERROR ( ENOMEM ) ; \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n av_freep ( & replaygain ) ; \n return AVERROR ( ENOMEM ) ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = AV_PKT_DATA_REPLAYGAIN ; \n sd -> data = ( uint8_t * ) replaygain ; \n sd -> size = sizeof ( * replaygain ) ; \n replaygain -> track_gain = tg ; \n replaygain -> track_peak = tp ; \n replaygain -> album_gain = ag ; \n replaygain -> album_peak = ap ; \n return 0 ; \n }", "idx": 3368}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void parse_options ( void * optctx , int argc , char * * argv , const OptionDef * options , \n void ( * parse_arg_function ) ( void * , const char * ) ) \n { \n const char * opt ; \n int optindex , handleoptions = 1 , ret ; \n prepare_app_arguments ( & argc , & argv ) ; \n optindex = 1 ; \n while ( optindex < argc ) { \n opt = argv [ optindex ++ ] ; \n if ( handleoptions && opt [ 0 ] == ' ' && opt [ 1 ] != ' \\0 ' ) { \n if ( opt [ 1 ] == ' ' && opt [ 2 ] == ' \\0 ' ) { \n handleoptions = 0 ; \n continue ; \n } \n opt ++ ; \n if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 ) \n exit ( 1 ) ; \n optindex += ret ; \n } else { \n if ( parse_arg_function ) \n parse_arg_function ( optctx , opt ) ; \n } \n } \n }", "idx": 3472}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "void av_opencl_buffer_release ( cl_mem * cl_buf ) \n { \n cl_int status = 0 ; \n if ( ! cl_buf ) \n return ; \n status = clReleaseMemObject ( * cl_buf ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n } \n memset ( cl_buf , 0 , sizeof ( * cl_buf ) ) ; \n }", "idx": 3530}
{"project": "FFmpeg", "commit_id": "774239be717150909219ad2c0696bfb6a50cf2cb", "target": 0, "func": "static int get_preset_file_2 ( const char * preset_name , const char * codec_name , AVIOContext * * s ) \n { \n int i , ret = 1 ; \n char filename [ 1000 ] ; \n const char * base [ 3 ] = { getenv ( \" \" ) , \n getenv ( \" \" ) , \n AVCONV_DATADIR , \n } ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( base ) && ret ; i ++ ) { \n if ( ! base [ i ] ) \n continue ; \n if ( codec_name ) { \n snprintf ( filename , sizeof ( filename ) , \" \" , base [ i ] , \n i != 1 ? \" \" : \" \" , codec_name , preset_name ) ; \n ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; \n } \n if ( ret ) { \n snprintf ( filename , sizeof ( filename ) , \" \" , base [ i ] , \n i != 1 ? \" \" : \" \" , preset_name ) ; \n ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; \n } \n } \n return ret ; \n }", "idx": 3566}
{"project": "FFmpeg", "commit_id": "821a5938d100458f4d09d634041b05c860554ce0", "target": 0, "func": "static int g2m_init_buffers ( G2MContext * c ) \n { \n int aligned_height ; \n if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { \n c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; \n aligned_height = FFALIGN ( c -> height , 16 ) ; \n av_free ( c -> framebuf ) ; \n c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; \n if ( ! c -> framebuf ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n c -> old_tile_w < c -> tile_width || \n c -> old_tile_h < c -> tile_height ) { \n c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; \n aligned_height = FFALIGN ( c -> tile_height , 16 ) ; \n av_free ( c -> synth_tile ) ; \n av_free ( c -> jpeg_tile ) ; \n av_free ( c -> kempf_buf ) ; \n av_free ( c -> kempf_flags ) ; \n c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height \n + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n ! c -> kempf_buf || ! c -> kempf_flags ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 3585}
{"project": "FFmpeg", "commit_id": "db9aee6ccf183508835acc325f5ad87d595eacc4", "target": 0, "func": "static int oma_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n OMAContext * oc = s -> priv_data ; \n int packet_size = s -> streams [ 0 ] -> codec -> block_align ; \n int ret = av_get_packet ( s -> pb , pkt , packet_size ) ; \n if ( ret <= 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = 0 ; \n if ( oc -> encrypted ) { \n av_des_crypt ( & oc -> av_des , pkt -> data , pkt -> data , \n ( packet_size >> 3 ) , oc -> iv , 1 ) ; \n } \n return ret ; \n }", "idx": 3620}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "rtsp_open_transport_ctx ( AVFormatContext * s , RTSPStream * rtsp_st )  \n { \n RTSPState * rt = s -> priv_data ; \n AVStream * st = NULL ; \n if ( rtsp_st -> stream_index >= 0 ) \n st = s -> streams [ rtsp_st -> stream_index ] ; \n if ( ! st ) \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n if ( rt -> transport == RTSP_TRANSPORT_RDT ) \n rtsp_st -> transport_priv = ff_rdt_parse_open ( s , st -> index , \n rtsp_st -> dynamic_protocol_context , \n rtsp_st -> dynamic_handler ) ; \n else \n rtsp_st -> transport_priv = rtp_parse_open ( s , st , rtsp_st -> rtp_handle , \n rtsp_st -> sdp_payload_type , \n & rtsp_st -> rtp_payload_data ) ; \n if ( ! rtsp_st -> transport_priv ) { \n return AVERROR ( ENOMEM ) ; \n } else if ( rt -> transport != RTSP_TRANSPORT_RDT ) { \n if ( rtsp_st -> dynamic_handler ) { \n rtp_parse_set_dynamic_protocol ( rtsp_st -> transport_priv , \n rtsp_st -> dynamic_protocol_context , \n rtsp_st -> dynamic_handler ) ; \n } \n } \n return 0 ; \n }", "idx": 3638}
{"project": "FFmpeg", "commit_id": "cb036f905f6ffa7b0dfdb9c35471a8280e00214e", "target": 1, "func": "static void alloc_picture ( void * opaque ) \n { \n VideoState * is = opaque ; \n VideoPicture * vp ; \n vp = & is -> pictq [ is -> pictq_windex ] ; \n if ( vp -> bmp ) \n SDL_FreeYUVOverlay ( vp -> bmp ) ; \n #if CONFIG_AVFILTER  \n  \n  if ( vp -> picref ) \n avfilter_unref_buffer ( vp -> picref ) ; \n vp -> picref = NULL ; \n vp -> width = is -> out_video_filter -> inputs [ 0 ] -> w ; \n vp -> height = is -> out_video_filter -> inputs [ 0 ] -> h ; \n vp -> pix_fmt = is -> out_video_filter -> inputs [ 0 ] -> format ; \n #else \n vp -> width = is -> video_st -> codec -> width ; \n vp -> height = is -> video_st -> codec -> height ; \n vp -> pix_fmt = is -> video_st -> codec -> pix_fmt ; \n #endif \n vp -> bmp = SDL_CreateYUVOverlay ( vp -> width , vp -> height , \n SDL_YV12_OVERLAY , \n screen ) ; \n SDL_LockMutex ( is -> pictq_mutex ) ; \n vp -> allocated = 1 ; \n SDL_CondSignal ( is -> pictq_cond ) ; \n SDL_UnlockMutex ( is -> pictq_mutex ) ; ", "idx": 3690}
{"project": "FFmpeg", "commit_id": "d2779ecd8b1fb9dc8a8f37a75ff8c3b077f3143e", "target": 0, "func": "static inline int vc1_i_pred_dc ( MpegEncContext * s , int overlap , int pq , int n , \n int16_t * * dc_val_ptr , int * dir_ptr ) \n { \n int a , b , c , wrap , pred , scale ; \n int16_t * dc_val ; \n static const uint16_t dcpred [ 32 ] = { \n -1 , 1024 , 512 , 341 , 256 , 205 , 171 , 146 , 128 , \n 114 , 102 , 93 , 85 , 79 , 73 , 68 , 64 , \n 60 , 57 , 54 , 51 , 49 , 47 , 45 , 43 , \n 41 , 39 , 38 , 37 , 35 , 34 , 33 \n } ; \n if ( n < 4 ) scale = s -> y_dc_scale ; \n else scale = s -> c_dc_scale ; \n wrap = s -> block_wrap [ n ] ; \n dc_val = s -> dc_val [ 0 ] + s -> block_index [ n ] ; \n c = dc_val [ - 1 ] ; \n b = dc_val [ - 1 - wrap ] ; \n a = dc_val [ - wrap ] ; \n if ( pq < 9 || ! overlap ) \n { \n if ( ! s -> mb_y && ( n != 2 && n != 3 ) ) b = a = dcpred [ scale ] ; \n if ( s -> mb_x == 0 && ( n != 1 && n != 3 ) ) b = c = dcpred [ scale ] ; \n } \n else \n { \n if ( ! s -> mb_y && ( n != 2 && n != 3 ) ) b = a = 0 ; \n if ( s -> mb_x == 0 && ( n != 1 && n != 3 ) ) b = c = 0 ; \n } \n if ( abs ( a - b ) <= abs ( b - c ) ) { \n pred = c ; \n * dir_ptr = 1 ; \n } else { \n pred = a ; \n * dir_ptr = 0 ; \n } \n * dc_val_ptr = & dc_val [ 0 ] ; \n return pred ; \n }", "idx": 3820}
{"project": "FFmpeg", "commit_id": "7d09a993d14c420ce53070312e77a224dbb4bc99", "target": 1, "func": "static void sdp_parse_fmtp_config ( AVCodecContext * codec , char * attr , char * value ) \n { \n switch ( codec -> codec_id ) { \n case CODEC_ID_MPEG4 : \n case CODEC_ID_AAC : \n if ( ! strcmp ( attr , \" \" ) ) { \n int len = hex_to_data ( NULL , value ) ; \n codec -> extradata = av_mallocz ( len + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! codec -> extradata ) \n return ; \n codec -> extradata_size = len ; \n hex_to_data ( codec -> extradata , value ) ; \n } \n break ; \n default : \n break ; \n } \n return ; \n }", "idx": 3909}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_cod ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n Jpeg2000CodingStyle tmp ; \n int compno ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n tmp . log2_prec_width = \n tmp . log2_prec_height = 15 ; \n tmp . csty = bytestream_get_byte ( & s -> buf ) ; \n tmp . prog_order = bytestream_get_byte ( & s -> buf ) ; \n tmp . nlayers = bytestream_get_be16 ( & s -> buf ) ; \n tmp . mct = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , & tmp ) ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; \n }", "idx": 3969}
{"project": "FFmpeg", "commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "target": 1, "func": "static int32_t scalarproduct_and_madd_int16_c ( int16_t * v1 , const int16_t * v2 , \n const int16_t * v3 , \n int order , int mul ) \n { \n int res = 0 ; \n while ( order -- ) { \n res += * v1 * * v2 ++ ; \n * v1 ++ += mul * * v3 ++ ; \n } \n return res ; \n }", "idx": 3974}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static int mjpeg_decode_dht ( MJpegDecodeContext * s ) \n { \n int len , index , i , class , n , v , code_max ; \n uint8_t bits_table [ 17 ] ; \n uint8_t val_table [ 256 ] ; \n len = get_bits ( & s -> gb , 16 ) - 2 ; \n while ( len > 0 ) { \n if ( len < 17 ) \n return -1 ; \n class = get_bits ( & s -> gb , 4 ) ; \n if ( class >= 2 ) \n return -1 ; \n index = get_bits ( & s -> gb , 4 ) ; \n if ( index >= 4 ) \n return -1 ; \n n = 0 ; \n for ( i = 1 ; i <= 16 ; i ++ ) { \n bits_table [ i ] = get_bits ( & s -> gb , 8 ) ; \n n += bits_table [ i ] ; \n } \n len -= 17 ; \n if ( len < n || n > 256 ) \n return -1 ; \n code_max = 0 ; \n for ( i = 0 ; i < n ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n if ( v > code_max ) \n code_max = v ; \n val_table [ i ] = v ; \n } \n len -= n ; \n free_vlc ( & s -> vlcs [ class ] [ index ] ) ; \n dprintf ( \" \\n \" , \n class , index , code_max + 1 ) ; \n build_vlc ( & s -> vlcs [ class ] [ index ] , bits_table , val_table , code_max + 1 ) ; \n } \n return 0 ; \n }", "idx": 4111}
{"project": "FFmpeg", "commit_id": "431f8af8242c41ef922f9daf791b0be26dc0bba4", "target": 0, "func": "static int normalize_bits ( int num , int width ) \n { \n int i = 0 ; \n int bits = ( width ) ? 31 : 15 ; \n int limit = 1 << ( bits - 1 ) ; \n if ( num ) { \n if ( num == -1 ) \n return bits ; \n if ( num < 0 ) \n num = ~ num ; \n for ( i = 0 ; num < limit ; i ++ ) \n num <<= 1 ; \n } \n return i ; \n }", "idx": 4239}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static const AVClass * filter_child_class_next ( const AVClass * prev ) \n { \n AVFilter * * f = NULL ; \n while ( prev && * ( f = av_filter_next ( f ) ) ) \n if ( ( * f ) -> priv_class == prev ) \n break ; \n while ( * ( f = av_filter_next ( f ) ) ) \n if ( ( * f ) -> priv_class ) \n return ( * f ) -> priv_class ; \n return NULL ; \n }", "idx": 4346}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "func": "static int encode_slice_plane ( AVCodecContext * avctx , int mb_count , \n uint8_t * src , int src_stride , uint8_t * buf , unsigned buf_size , \n int * qmat , int chroma ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n FDCTDSPContext * fdsp = & ctx -> fdsp ; \n DECLARE_ALIGNED ( 16 , int16_t , blocks ) [ DEFAULT_SLICE_MB_WIDTH << 8 ] , * block ; \n int i , blocks_per_slice ; \n PutBitContext pb ; \n block = blocks ; \n for ( i = 0 ; i < mb_count ; i ++ ) { \n fdct_get ( fdsp , src , src_stride , block + ( 0 << 6 ) ) ; \n fdct_get ( fdsp , src + 8 * src_stride , src_stride , block + ( ( 2 - chroma ) << 6 ) ) ; \n if ( ! chroma ) { \n fdct_get ( fdsp , src + 16 , src_stride , block + ( 1 << 6 ) ) ; \n fdct_get ( fdsp , src + 16 + 8 * src_stride , src_stride , block + ( 3 << 6 ) ) ; \n } \n block += ( 256 >> chroma ) ; \n src += ( 32 >> chroma ) ; \n } \n blocks_per_slice = mb_count << ( 2 - chroma ) ; \n init_put_bits ( & pb , buf , buf_size << 3 ) ; \n encode_dc_coeffs ( & pb , blocks , blocks_per_slice , qmat ) ; \n encode_ac_coeffs ( avctx , & pb , blocks , blocks_per_slice , qmat ) ; \n flush_put_bits ( & pb ) ; \n return put_bits_ptr ( & pb ) - pb . buf ; \n }", "idx": 4421}
{"project": "FFmpeg", "commit_id": "7149fce2cac0474a5fbc5b47add1158cd8bb283e", "target": 1, "func": "static inline void render_line_unrolled ( intptr_t x , intptr_t y , int x1 , \n intptr_t sy , int ady , int adx , \n float * buf ) \n { \n int err = - adx ; \n x -= x1 - 1 ; \n buf += x1 - 1 ; \n while ( ++ x < 0 ) { \n err += ady ; \n if ( err >= 0 ) { \n err += ady - adx ; \n y += sy ; \n buf [ x ++ ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n if ( x <= 0 ) { \n if ( err + ady >= 0 ) \n y += sy ; \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n }", "idx": 4424}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_trailer ( AVFormatContext * s ) \n { \n WebMDashMuxContext * w = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < w -> nb_as ; i ++ ) { \n av_freep ( & w -> as [ i ] . streams ) ; \n } \n av_freep ( & w -> as ) ; \n return 0 ; \n }", "idx": 4427}
{"project": "FFmpeg", "commit_id": "93dc1c1221856e88ac9df560a1b4f77dd5f5395d", "target": 0, "func": "void checkasm_check_fixed_dsp ( void ) \n { \n LOCAL_ALIGNED_32 ( int32_t , src0 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_32 ( int32_t , src1 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_32 ( int32_t , src2 ,  [ BUF_SIZE ] ) ; \n AVFixedDSPContext * fdsp = avpriv_alloc_fixed_dsp ( 1 ) ; \n randomize_buffers ( ) ; \n if ( check_func ( fdsp -> vector_fmul , \" \" ) ) \n check_vector_fmul ( src0 , src1 ) ; \n if ( check_func ( fdsp -> vector_fmul_add , \" \" ) ) \n check_vector_fmul_add ( src0 , src1 , src2 ) ; \n if ( check_func ( fdsp -> vector_fmul_reverse , \" \" ) ) \n check_vector_fmul ( src0 , src1 ) ; \n if ( check_func ( fdsp -> vector_fmul_window , \" \" ) ) \n check_vector_fmul_window ( src0 , src1 , src2 ) ; \n if ( check_func ( fdsp -> vector_fmul_window_scaled , \" \" ) ) \n check_vector_fmul_window_scaled ( src0 , src1 , src2 ) ; \n report ( \" \" ) ; \n if ( check_func ( fdsp -> butterflies_fixed , \" \" ) ) \n check_butterflies ( src0 , src1 ) ; \n report ( \" \" ) ; \n if ( check_func ( fdsp -> scalarproduct_fixed , \" \" ) ) \n check_scalarproduct_fixed ( src0 , src1 ) ; \n report ( \" \" ) ; \n av_freep ( & fdsp ) ; \n }", "idx": 4514}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "void ff_mpeg_flush ( AVCodecContext * avctx ) { \n int i ; \n MpegEncContext * s = avctx -> priv_data ; \n if ( s == NULL || s -> picture == NULL ) \n return ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) \n ff_mpeg_unref_picture ( s , & s -> picture [ i ] ) ; \n s -> current_picture_ptr = s -> last_picture_ptr = s -> next_picture_ptr = NULL ; \n ff_mpeg_unref_picture ( s , & s -> current_picture ) ; \n ff_mpeg_unref_picture ( s , & s -> last_picture ) ; \n ff_mpeg_unref_picture ( s , & s -> next_picture ) ; \n s -> mb_x = s -> mb_y = 0 ; \n s -> parse_context . state = -1 ; \n s -> parse_context . frame_start_found = 0 ; \n s -> parse_context . overread = 0 ; \n s -> parse_context . overread_index = 0 ; \n s -> parse_context . index = 0 ; \n s -> parse_context . last_index = 0 ; \n s -> bitstream_buffer_size = 0 ; \n s -> pp_time = 0 ; \n }", "idx": 4530}
{"project": "FFmpeg", "commit_id": "7e10145976866fc6227d3ccc697a7c9fee862a77", "target": 0, "func": "static int rwpipe_read_ppm_header ( rwpipe * rw , int * width , int * height ) \n { \n char line [ 3 ] ; \n FILE * in = rwpipe_reader ( rw ) ; \n int max ; \n fgets ( line , 3 , in ) ; \n if ( ! strncmp ( line , \" \" , 2 ) ) \n { \n * width = rwpipe_read_number ( rw ) ; \n * height = rwpipe_read_number ( rw ) ; \n max = rwpipe_read_number ( rw ) ; \n return max != 255 || * width <= 0 || * height <= 0 ; \n } \n return 1 ; \n }", "idx": 4575}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int crc_write_header ( struct AVFormatContext * s ) \n { \n CRCState * crc = s -> priv_data ; \n crc -> crcval = adler32 ( 0 , NULL , 0 ) ; \n return 0 ; \n }", "idx": 4580}
{"project": "FFmpeg", "commit_id": "5d590d87b30c59dfb853ebde6276d36f8a8bbc58", "target": 1, "func": "static int av_dict_set_fxp ( AVDictionary * * pm , const char * key , uint64_t value , unsigned int digits , \n int flags ) \n { \n char valuestr [ 44 ] ; \n snprintf ( valuestr , sizeof ( valuestr ) , \" \" PRId64 \" \" PRId64 , \n value / PRECISION , digits , ( value % PRECISION ) / ( PRECISION / uintpow ( 10 , digits ) ) ) ; \n return av_dict_set ( pm , key , valuestr , flags ) ; \n }", "idx": 4647}
{"project": "FFmpeg", "commit_id": "f077ad69c682c13ab75a72aec11a61cac53f0c91", "target": 1, "func": "int av_packet_ref ( AVPacket * dst , const AVPacket * src ) \n { \n int ret ; \n ret = av_packet_copy_props ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! src -> buf ) { \n ret = packet_alloc ( & dst -> buf , src -> size ) ; \n if ( ret < 0 ) \n goto fail ; \n memcpy ( dst -> buf -> data , src -> data , src -> size ) ; \n dst -> data = dst -> buf -> data ; \n } else { \n dst -> buf = av_buffer_ref ( src -> buf ) ; \n if ( ! dst -> buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n dst -> data = src -> data ; \n } \n dst -> size = src -> size ; \n return 0 ; \n fail : \n av_packet_free_side_data ( dst ) ; \n return ret ; \n }", "idx": 4650}
{"project": "FFmpeg", "commit_id": "b1b0baa3d6a30942b258dddfdd04b4b24c713879", "target": 0, "func": "static void kempf_restore_buf ( const uint8_t * src , int len , \n uint8_t * dst , int stride , \n const uint8_t * jpeg_tile , int tile_stride , \n int width , int height , \n const uint8_t * pal , int npal , int tidx ) \n { \n GetBitContext gb ; \n int i , j , nb , col ; \n init_get_bits8 ( & gb , src , len ) ; \n if ( npal <= 2 ) nb = 1 ; \n else if ( npal <= 4 ) nb = 2 ; \n else if ( npal <= 16 ) nb = 4 ; \n else nb = 8 ; \n for ( j = 0 ; j < height ; j ++ , dst += stride , jpeg_tile += tile_stride ) { \n if ( get_bits ( & gb , 8 ) ) \n continue ; \n for ( i = 0 ; i < width ; i ++ ) { \n col = get_bits ( & gb , nb ) ; \n if ( col != tidx ) \n memcpy ( dst + i * 3 , pal + col * 3 , 3 ) ; \n else \n memcpy ( dst + i * 3 , jpeg_tile + i * 3 , 3 ) ; \n } \n } \n }", "idx": 4679}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "static JavaVM * get_java_vm ( const char * name , void * log_ctx ) \n { \n JavaVM * vm = NULL ; \n jsize nb_vm = 0 ; \n void * handle = NULL ; \n jint ( * get_created_java_vms ) ( JavaVM * * vmBuf , jsize bufLen , jsize * nVMs ) = NULL ; \n handle = dlopen ( name , RTLD_LOCAL ) ; \n if ( ! handle ) { \n return NULL ; \n } \n get_created_java_vms = ( jint ( * ) ( JavaVM * * , jsize , jsize * ) ) dlsym ( handle , \" \" ) ; \n if ( ! get_created_java_vms ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , name ) ; \n goto done ; \n } \n if ( get_created_java_vms ( & vm , 1 , & nb_vm ) != JNI_OK ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto done ; \n } \n done : \n if ( handle ) { \n dlclose ( handle ) ; \n } \n return vm ; \n }", "idx": 4686}
{"project": "FFmpeg", "commit_id": "1bc1cfdddf7ab8ef50d0fc888808d6b609eb5d8d", "target": 1, "func": "static int compute_send_delay ( HTTPContext * c ) \n { \n int datarate = 8 * get_longterm_datarate ( & c -> datarate , c -> data_count ) ; \n if ( datarate > c -> stream -> bandwidth * 2000 ) { \n return 1000 ; \n } \n return 0 ; \n }", "idx": 4734}
{"project": "FFmpeg", "commit_id": "5e55c7e1bcb767e6af17c29f6aaebff4d6fd0703", "target": 0, "func": "void ff_hevc_hls_filter ( HEVCContext * s , int x , int y , int ctb_size ) \n { \n deblocking_filter_CTB ( s , x , y ) ; \n if ( s -> sps -> sao_enabled ) { \n int x_end = x >= s -> sps -> width - ctb_size ; \n int y_end = y >= s -> sps -> height - ctb_size ; \n if ( y && x ) \n sao_filter_CTB ( s , x - ctb_size , y - ctb_size ) ; \n if ( x && y_end ) \n sao_filter_CTB ( s , x - ctb_size , y ) ; \n if ( y && x_end ) { \n sao_filter_CTB ( s , x , y - ctb_size ) ; \n if ( s -> threads_type & FF_THREAD_FRAME ) \n ff_thread_report_progress ( & s -> ref -> tf , y - ctb_size , 0 ) ; \n } \n if ( x_end && y_end ) { \n sao_filter_CTB ( s , x , y ) ; \n if ( s -> threads_type & FF_THREAD_FRAME ) \n ff_thread_report_progress ( & s -> ref -> tf , y , 0 ) ; \n } \n } else { \n if ( y && x >= s -> sps -> width - ctb_size ) \n if ( s -> threads_type & FF_THREAD_FRAME ) \n ff_thread_report_progress ( & s -> ref -> tf , y , 0 ) ; \n } \n }", "idx": 4848}
{"project": "FFmpeg", "commit_id": "68aefbe81cb3b9dd002108782bb8d798e1c12806", "target": 1, "func": "static double get_video_clock ( VideoState * is ) \n { \n if ( is -> paused ) { \n return is -> video_current_pts ; \n } else { \n return is -> video_current_pts + ( av_gettime ( ) - is -> video_current_pts_time ) / 1000000.0 ; \n } \n }", "idx": 4876}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xC ( IpvideoContext * s ) \n { \n int x , y ; \n CHECK_STREAM_PTR ( 16 ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = * s -> stream_ptr ++ ; \n } \n s -> pixel_ptr += s -> stride * 2 ; \n } \n return 0 ; \n }", "idx": 4958}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_horizontal ) ( uint8_t * _src , int stride ) { \n int i ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = PIXEL_SPLAT_X4 ( src [ -1 + i * stride ] ) ; \n } \n }", "idx": 4991}
{"project": "FFmpeg", "commit_id": "c79d2a20bad59298188171f1316a830d563a41ee", "target": 0, "func": "static void decode_parameters ( SiprParameters * parms , GetBitContext * pgb , \n const SiprModeParam * p ) \n { \n int i , j ; \n parms -> ma_pred_switch = get_bits ( pgb , p -> ma_predictor_bits ) ; \n for ( i = 0 ; i < 5 ; i ++ ) \n parms -> vq_indexes [ i ] = get_bits ( pgb , p -> vq_indexes_bits [ i ] ) ; \n for ( i = 0 ; i < p -> subframe_count ; i ++ ) { \n parms -> pitch_delay [ i ] = get_bits ( pgb , p -> pitch_delay_bits [ i ] ) ; \n parms -> gp_index [ i ] = get_bits ( pgb , p -> gp_index_bits ) ; \n for ( j = 0 ; j < p -> number_of_fc_indexes ; j ++ ) \n parms -> fc_indexes [ i ] [ j ] = get_bits ( pgb , p -> fc_index_bits [ j ] ) ; \n parms -> gc_index [ i ] = get_bits ( pgb , p -> gc_index_bits ) ; \n } \n }", "idx": 5006}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void rgb2rgb_init_x86 ( void ) \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( cpu_flags & AV_CPU_FLAG_MMX ) \n rgb2rgb_init_MMX ( ) ; \n if ( HAVE_AMD3DNOW && cpu_flags & AV_CPU_FLAG_3DNOW ) \n rgb2rgb_init_3DNOW ( ) ; \n if ( HAVE_MMXEXT && cpu_flags & AV_CPU_FLAG_MMXEXT ) \n rgb2rgb_init_MMX2 ( ) ; \n if ( HAVE_SSE && cpu_flags & AV_CPU_FLAG_SSE2 ) \n rgb2rgb_init_SSE2 ( ) ; \n #endif \n }", "idx": 5055}
{"project": "FFmpeg", "commit_id": "eea784dab00d9f123c508d3e0c6b16e4f3123bb0", "target": 0, "func": "static int mp3_header_compress ( AVBitStreamFilterContext * bsfc , AVCodecContext * avctx , const char * args , \n uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size , int keyframe ) { \n uint32_t header ; \n int mode_extension ; \n if ( avctx -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n header = ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ; \n mode_extension = ( header >> 4 ) & 3 ; \n if ( ff_mpa_check_header ( header ) < 0 || ( header & 0x70000 ) != 0x30000 ) { \n * poutbuf = ( uint8_t * ) buf ; \n * poutbuf_size = buf_size ; \n av_log ( avctx , AV_LOG_INFO , \" \\n \" , header ) ; \n return 0 ; \n } \n * poutbuf_size = buf_size - 4 ; \n * poutbuf = av_malloc ( buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n memcpy ( * poutbuf , buf + 4 , buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( avctx -> channels == 2 ) { \n if ( ( header & ( 3 << 19 ) ) != 3 << 19 ) { \n ( * poutbuf ) [ 1 ] &= 0x3F ; \n ( * poutbuf ) [ 1 ] |= mode_extension << 6 ; \n FFSWAP ( int , ( * poutbuf ) [ 1 ] , ( * poutbuf ) [ 2 ] ) ; \n } else { \n ( * poutbuf ) [ 1 ] &= 0x8F ; \n ( * poutbuf ) [ 1 ] |= mode_extension << 4 ; \n } \n } \n return 1 ; \n }", "idx": 5066}
{"project": "FFmpeg", "commit_id": "93d336fb076a8abe33e37251af5475673e716f6d", "target": 1, "func": "static int set_segment_filename ( AVFormatContext * s ) \n { \n SegmentContext * seg = s -> priv_data ; \n AVFormatContext * oc = seg -> avf ; \n size_t size ; \n if ( seg -> segment_idx_wrap ) \n seg -> segment_idx %= seg -> segment_idx_wrap ; \n if ( seg -> use_strftime ) { \n time_t now0 ; \n struct tm * tm , tmpbuf ; \n time ( & now0 ) ; \n tm = localtime_r ( & now0 , & tmpbuf ) ; \n if ( ! strftime ( oc -> filename , sizeof ( oc -> filename ) , s -> filename , tm ) ) { \n av_log ( oc , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n } else if ( av_get_frame_filename ( oc -> filename , sizeof ( oc -> filename ) , \n s -> filename , seg -> segment_idx ) < 0 ) { \n av_log ( oc , AV_LOG_ERROR , \" \\n \" , s -> filename ) ; \n return AVERROR ( EINVAL ) ; \n } \n size = strlen ( av_basename ( oc -> filename ) ) + 1 ; \n if ( seg -> entry_prefix ) \n size += strlen ( seg -> entry_prefix ) ; \n seg -> cur_entry . filename = av_mallocz ( size ) ; \n if ( ! seg -> cur_entry . filename ) \n return AVERROR ( ENOMEM ) ; \n snprintf ( seg -> cur_entry . filename , size , \" \" , \n seg -> entry_prefix ? seg -> entry_prefix : \" \" , \n av_basename ( oc -> filename ) ) ; \n return 0 ; \n }", "idx": 5137}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_modes ( vorbis_context * vc ) { \n GetBitContext * gb = & vc -> gb ; \n uint_fast8_t i ; \n vc -> mode_count = get_bits ( gb , 6 ) + 1 ; \n vc -> modes = ( vorbis_mode * ) av_mallocz ( vc -> mode_count * sizeof ( vorbis_mode ) ) ; \n AV_DEBUG ( \" \\n \" , vc -> mode_count ) ; \n for ( i = 0 ; i < vc -> mode_count ; ++ i ) { \n vorbis_mode * mode_setup = & vc -> modes [ i ] ; \n mode_setup -> blockflag = get_bits1 ( gb ) ; \n mode_setup -> windowtype = get_bits ( gb , 16 ) ; \n mode_setup -> transformtype = get_bits ( gb , 16 ) ; \n mode_setup -> mapping = get_bits ( gb , 8 ) ; \n AV_DEBUG ( \" \\n \" , i , mode_setup -> blockflag , mode_setup -> windowtype , mode_setup -> transformtype , mode_setup -> mapping ) ; \n } \n return 0 ; \n }", "idx": 5248}
{"project": "FFmpeg", "commit_id": "f015e411d78d9e9ae179170beafe4951b778ac50", "target": 1, "func": "static int amr_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int read , size , toc , mode ; \n if ( url_feof ( & s -> pb ) ) \n { \n return AVERROR_IO ; \n } \n toc = get_byte ( & s -> pb ) ; \n mode = ( toc >> 3 ) & 0x0F ; \n if ( enc -> codec_id == CODEC_ID_AMR_NB ) \n { \n static const uint8_t packed_size [ 16 ] = { 12 , 13 , 15 , 17 , 19 , 20 , 26 , 31 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n size = packed_size [ mode ] + 1 ; \n } \n else if ( enc -> codec_id == CODEC_ID_AMR_WB ) \n { \n static uint8_t packed_size [ 16 ] = { 18 , 24 , 33 , 37 , 41 , 47 , 51 , 59 , 61 , 6 , 6 , 0 , 0 , 0 , 1 , 1 } ; \n size = packed_size [ mode ] ; \n } \n else \n { \n assert ( 0 ) ; \n } \n if ( ( size == 0 ) || av_new_packet ( pkt , size ) ) \n { \n return AVERROR_IO ; \n } \n pkt -> stream_index = 0 ; \n pkt -> pos = url_ftell ( & s -> pb ) ; \n pkt -> data [ 0 ] = toc ; \n pkt -> duration = enc -> codec_id == CODEC_ID_AMR_NB ? 160 : 320 ; \n read = get_buffer ( & s -> pb , pkt -> data + 1 , size - 1 ) ; \n if ( read != size - 1 ) \n { \n av_free_packet ( pkt ) ; \n return AVERROR_IO ; \n } \n return 0 ; \n }", "idx": 5715}
{"project": "FFmpeg", "commit_id": "575d494de561049f36f9c5492e05c7d83dd78e75", "target": 1, "func": "static void park_frame_worker_threads ( FrameThreadContext * fctx , int thread_count ) \n { \n int i ; \n for ( i = 0 ; i < thread_count ; i ++ ) { \n PerThreadContext * p = & fctx -> threads [ i ] ; \n if ( p -> state != STATE_INPUT_READY ) { \n pthread_mutex_lock ( & p -> progress_mutex ) ; \n while ( p -> state != STATE_INPUT_READY ) \n pthread_cond_wait ( & p -> output_cond , & p -> progress_mutex ) ; \n pthread_mutex_unlock ( & p -> progress_mutex ) ; \n } \n } \n }", "idx": 5729}
{"project": "FFmpeg", "commit_id": "559fd1e79524ca47efde195e28feb4499dd48761", "target": 1, "func": "static int nut_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n int i , frame_code = 0 , ret , skip ; \n int64_t ts , back_ptr ; \n for ( ; ; ) { \n int64_t pos = url_ftell ( bc ) ; \n uint64_t tmp = nut -> next_startcode ; \n nut -> next_startcode = 0 ; \n if ( url_feof ( bc ) ) \n return -1 ; \n if ( tmp ) { \n pos -= 8 ; \n } else { \n frame_code = get_byte ( bc ) ; \n if ( frame_code == ' ' ) { \n tmp = frame_code ; \n for ( i = 1 ; i < 8 ; i ++ ) \n tmp = ( tmp << 8 ) + get_byte ( bc ) ; \n } \n } \n switch ( tmp ) { \n case MAIN_STARTCODE : \n case STREAM_STARTCODE : \n case INDEX_STARTCODE : \n skip = get_packetheader ( nut , bc , 0 ) ; \n url_fseek ( bc , skip , SEEK_CUR ) ; \n break ; \n case INFO_STARTCODE : \n if ( decode_info_header ( nut ) < 0 ) \n goto resync ; \n break ; \n case SYNCPOINT_STARTCODE : \n if ( decode_syncpoint ( nut , & ts , & back_ptr ) < 0 ) \n goto resync ; \n frame_code = get_byte ( bc ) ; \n case 0 : \n ret = decode_frame ( nut , pkt , frame_code ) ; \n if ( ret == 0 ) \n return 0 ; \n else if ( ret == 1 ) \n break ; \n default : \n resync : \n av_log ( s , AV_LOG_DEBUG , \" \" PRId64 \" \\n \" , pos ) ; \n tmp = find_any_startcode ( bc , nut -> last_syncpoint_pos + 1 ) ; \n if ( tmp == 0 ) \n return -1 ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n nut -> next_startcode = tmp ; \n } \n } \n }", "idx": 5741}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb8tobgr8 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint8_t rgb ; \n rgb = src [ i ] ; \n r = ( rgb & 0x07 ) ; \n g = ( rgb & 0x38 ) >> 3 ; \n b = ( rgb & 0xC0 ) >> 6 ; \n dst [ i ] = ( ( b << 1 ) & 0x07 ) | ( ( g & 0x07 ) << 3 ) | ( ( r & 0x03 ) << 6 ) ; \n } \n }", "idx": 5757}
{"project": "FFmpeg", "commit_id": "981e99ab99986935affad7c164ebdfe28e8ea7f8", "target": 1, "func": "static void sbr_hf_g_filt_c ( int ( * Y ) [ 2 ] , const int ( * X_high ) [ 40 ] [ 2 ] , \n const SoftFloat * g_filt , int m_max , intptr_t ixh ) \n { \n int m ; \n int64_t accu ; \n for ( m = 0 ; m < m_max ; m ++ ) { \n int64_t r = 1LL << ( 22 - g_filt [ m ] . exp ) ; \n accu = ( int64_t ) X_high [ m ] [ ixh ] [ 0 ] * ( ( g_filt [ m ] . mant + 0x40 ) >> 7 ) ; \n Y [ m ] [ 0 ] = ( int ) ( ( accu + r ) >> ( 23 - g_filt [ m ] . exp ) ) ; \n accu = ( int64_t ) X_high [ m ] [ ixh ] [ 1 ] * ( ( g_filt [ m ] . mant + 0x40 ) >> 7 ) ; \n Y [ m ] [ 1 ] = ( int ) ( ( accu + r ) >> ( 23 - g_filt [ m ] . exp ) ) ; \n } \n }", "idx": 5790}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_metadata ( int count , int type , \n const char * name , const char * sep , TiffContext * s ) \n { \n switch ( type ) { \n case TIFF_DOUBLE : return add_doubles_metadata ( count , name , sep , s ) ; \n case TIFF_SHORT : return add_shorts_metadata ( count , name , sep , s ) ; \n case TIFF_STRING : return add_string_metadata ( count , name , s ) ; \n default : return AVERROR_INVALIDDATA ; \n } ; \n }", "idx": 5847}
{"project": "FFmpeg", "commit_id": "655b6dcb34b25d591e15ede17673ea6cb8074711", "target": 0, "func": "real_parse_asm_rule ( AVStream * st , const char * p , const char * end )  \n { \n do { \n #if AV_HAVE_INCOMPATIBLE_LIBAV_ABI  \n  \n  if ( sscanf ( p , \" \" , & st -> codec -> bit_rate ) == 1 ) \n #else \n if ( sscanf ( p , \" \" SCNd64 , & st -> codec -> bit_rate ) == 1 )  \n #endif \n break ; \n if ( ! ( p = strchr ( p , ' ' ) ) || p > end ) \n p = end ; \n p ++ ; \n } while ( p < end ) ; \n }", "idx": 5860}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int dxva2_vc1_end_frame ( AVCodecContext * avctx ) \n { \n VC1Context * v = avctx -> priv_data ; \n struct dxva2_picture_context * ctx_pic = v -> s . current_picture_ptr -> hwaccel_picture_private ; \n int ret ; \n if ( ctx_pic -> bitstream_size <= 0 ) \n return -1 ; \n ret = ff_dxva2_common_end_frame ( avctx , & v -> s . current_picture_ptr -> f , \n & ctx_pic -> pp , sizeof ( ctx_pic -> pp ) , \n NULL , 0 , \n commit_bitstream_and_slice_buffer ) ; \n if ( ! ret ) \n ff_mpeg_draw_horiz_band ( & v -> s , 0 , avctx -> height ) ; \n return ret ; \n }", "idx": 5910}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_metadata_obj ( AVFormatContext * s , const GUIDParseTable * g ) \n { \n ASFContext * asf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n uint64_t size = avio_rl64 ( pb ) ; \n uint16_t nb_recs = avio_rl16 ( pb ) ; \n int i , ret ; \n for ( i = 0 ; i < nb_recs ; i ++ ) { \n uint16_t name_len , buflen , type , val_len , st_num ; \n uint8_t * name = NULL ; \n avio_skip ( pb , 2 ) ; \n st_num = avio_rl16 ( pb ) ; \n name_len = avio_rl16 ( pb ) ; \n buflen = 2 * name_len + 1 ; \n if ( ! name_len ) \n break ; \n type = avio_rl16 ( pb ) ; \n val_len = avio_rl32 ( pb ) ; \n name = av_malloc ( name_len ) ; \n if ( ! name ) \n return AVERROR ( ENOMEM ) ; \n avio_get_str16le ( pb , name_len , name , \n buflen ) ; \n if ( ! strcmp ( name , \" \" ) || ! strcmp ( name , \" \" ) ) { \n asf_store_aspect_ratio ( s , st_num , name ) ; \n } else { \n if ( st_num < ASF_MAX_STREAMS ) { \n if ( ( ret = process_metadata ( s , name , name_len , val_len , type , \n & asf -> asf_sd [ st_num ] . asf_met ) ) < 0 ) \n break ; \n } else \n av_freep ( & name ) ; \n } \n } \n align_position ( pb , asf -> offset , size ) ; \n return 0 ; \n }", "idx": 5948}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char P [ 2 ] ; \n unsigned int flags ; \n CHECK_STREAM_PTR ( 2 ) ; \n P [ 0 ] = * s -> stream_ptr ++ ; \n P [ 1 ] = * s -> stream_ptr ++ ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n CHECK_STREAM_PTR ( 8 ) ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n flags = * s -> stream_ptr ++ | 0x100 ; \n for ( ; flags != 1 ; flags >>= 1 ) \n * s -> pixel_ptr ++ = P [ flags & 1 ] ; \n s -> pixel_ptr += s -> line_inc ; \n } \n } else { \n CHECK_STREAM_PTR ( 2 ) ; \n flags = bytestream_get_le16 ( & s -> stream_ptr ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 , flags >>= 1 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ; \n } \n s -> pixel_ptr += s -> stride * 2 ; \n } \n } \n return 0 ; \n }", "idx": 6059}
{"project": "FFmpeg", "commit_id": "16c91d2b233fe04697ba8f7ab6d1bad12a4ad69f", "target": 0, "func": "static void do_rematrixing ( AC3DecodeContext * s ) \n { \n int bnd , i ; \n int end , bndend ; \n int tmp0 , tmp1 ; \n end = FFMIN ( s -> end_freq [ 1 ] , s -> end_freq [ 2 ] ) ; \n for ( bnd = 0 ; bnd < s -> num_rematrixing_bands ; bnd ++ ) { \n if ( s -> rematrixing_flags [ bnd ] ) { \n bndend = FFMIN ( end , ff_ac3_rematrix_band_tab [ bnd + 1 ] ) ; \n for ( i = ff_ac3_rematrix_band_tab [ bnd ] ; i < bndend ; i ++ ) { \n tmp0 = s -> fixed_coeffs [ 1 ] [ i ] ; \n tmp1 = s -> fixed_coeffs [ 2 ] [ i ] ; \n s -> fixed_coeffs [ 1 ] [ i ] = tmp0 + tmp1 ; \n s -> fixed_coeffs [ 2 ] [ i ] = tmp0 - tmp1 ; \n } \n } \n } \n }", "idx": 6129}
{"project": "FFmpeg", "commit_id": "9d87374ec0f382c8394ad511243db6980afa42af", "target": 0, "func": "static void hb_synthesis ( AMRWBContext * ctx , int subframe , float * samples , \n const float * exc , const float * isf , const float * isf_past ) \n { \n float hb_lpc [ LP_ORDER_16k ] ; \n enum Mode mode = ctx -> fr_cur_mode ; \n if ( mode == MODE_6k60 ) { \n float e_isf [ LP_ORDER_16k ] ; \n double e_isp [ LP_ORDER_16k ] ; \n ff_weighted_vector_sumf ( e_isf , isf_past , isf , isfp_inter [ subframe ] , \n 1.0 - isfp_inter [ subframe ] , LP_ORDER ) ; \n extrapolate_isf ( e_isf , e_isf ) ; \n e_isf [ LP_ORDER_16k - 1 ] *= 2.0 ; \n ff_acelp_lsf2lspd ( e_isp , e_isf , LP_ORDER_16k ) ; \n ff_amrwb_lsp2lpc ( e_isp , hb_lpc , LP_ORDER_16k ) ; \n lpc_weighting ( hb_lpc , hb_lpc , 0.9 , LP_ORDER_16k ) ; \n } else { \n lpc_weighting ( hb_lpc , ctx -> lp_coef [ subframe ] , 0.6 , LP_ORDER ) ; \n } \n ff_celp_lp_synthesis_filterf ( samples , hb_lpc , exc , AMRWB_SFR_SIZE_16k , \n ( mode == MODE_6k60 ) ? LP_ORDER_16k : LP_ORDER ) ; \n }", "idx": 6409}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline void dv_set_class_number ( DCTELEM * blk , EncBlockInfo * bi , \n const uint8_t * zigzag_scan , int bias ) \n { \n int i , area ; \n int run ; \n int classes [ ] = { 12 , 24 , 36 , 0xffff } ; \n run = 0 ; \n bi -> mb [ 0 ] = blk [ 0 ] ; \n bi -> cno = 0 ; \n for ( area = 0 ; area < 4 ; area ++ ) { \n bi -> prev_run [ area ] = run ; \n bi -> bit_size [ area ] = 0 ; \n for ( i = mb_area_start [ area ] ; i < mb_area_start [ area + 1 ] ; i ++ ) { \n bi -> mb [ i ] = ( blk [ zigzag_scan [ i ] ] / 16 ) ; \n while ( ( bi -> mb [ i ] ^ ( bi -> mb [ i ] >> 8 ) ) > classes [ bi -> cno ] ) \n bi -> cno ++ ; \n if ( bi -> mb [ i ] ) { \n bi -> bit_size [ area ] += dv_rl2vlc_size ( run , bi -> mb [ i ] ) ; \n run = 0 ; \n } else \n ++ run ; \n } \n } \n bi -> bit_size [ 3 ] += 4 ; \n bi -> cno += bias ; \n if ( bi -> cno >= 3 ) { \n bi -> cno = 3 ; \n for ( i = 1 ; i < 64 ; i ++ ) \n bi -> mb [ i ] /= 2 ; \n } \n }", "idx": 6431}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_window ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 , const float * v3 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_window ( cdst , v1 , v2 , v3 , LEN / 2 ) ; \n fdsp -> vector_fmul_window ( odst , v1 , v2 , v3 , LEN / 2 ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , ARBITRARY_FMUL_WINDOW_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6491}
{"project": "FFmpeg", "commit_id": "14de55784dcf0b875dab35896c9e55d5792c6fd4", "target": 1, "func": "yuv2planeX_16_c_template ( const int16_t *  filter , int filterSize , \n const  int32_t * * src , uint16_t * dest , int dstW , \n int big_endian , int output_bits ) \n { \n int i ; \n int shift = 15 ; \n av_assert0 ( output_bits == 16 ) ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = 1 << ( shift - 1 ) ; \n int j ; \n val -= 0x40000000 ; \n for ( j = 0 ; j < filterSize ; j ++ ) \n val += src [ j ] [ i ] * filter [ j ] ; \n output_pixel ( & dest [ i ] , val , 0x8000 , int ) ; \n } \n }", "idx": 6515}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int generate_coupling_coordinates ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n uint8_t exp , mstrcplco ; \n int16_t mant ; \n uint32_t cplbndstrc = ( 1 << ab -> ncplsubnd ) >> 1 ; \n int ch , bnd , sbnd ; \n float cplco ; \n if ( ab -> cplcoe ) \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ab -> cplcoe & ( 1 << ch ) ) { \n mstrcplco = 3 * ab -> mstrcplco [ ch ] ; \n sbnd = ab -> cplbegf ; \n for ( bnd = 0 ; bnd < ab -> ncplbnd ; bnd ++ ) { \n exp = ab -> cplcoexp [ ch ] [ bnd ] ; \n if ( exp == 15 ) \n mant = ab -> cplcomant [ ch ] [ bnd ] <<= 14 ; \n else \n mant = ( ab -> cplcomant [ ch ] [ bnd ] | 0x10 ) << 13 ; \n cplco = to_float ( exp + mstrcplco , mant ) ; \n if ( ctx -> bsi . acmod == 0x02 && ( ab -> flags & AC3_AB_PHSFLGINU ) && ch == 1 \n && ( ab -> phsflg & ( 1 << bnd ) ) ) \n cplco = - cplco ; \n ab -> cplco [ ch ] [ sbnd ++ ] = cplco ; \n while ( cplbndstrc & ab -> cplbndstrc ) { \n cplbndstrc >>= 1 ; \n ab -> cplco [ ch ] [ sbnd ++ ] = cplco ; \n } \n cplbndstrc >>= 1 ; \n } \n } \n return 0 ; \n }", "idx": 6517}
{"project": "FFmpeg", "commit_id": "e20e9b9033b75fac32a4a3bc2cdd3fcc3cedb33a", "target": 1, "func": "static void fifo_deinit ( AVFormatContext * avf ) \n { \n FifoContext * fifo = avf -> priv_data ; \n av_dict_free ( & fifo -> format_options ) ; \n avformat_free_context ( fifo -> avf ) ; \n av_thread_message_queue_free ( & fifo -> queue ) ; \n pthread_mutex_destroy ( & fifo -> overflow_flag_lock ) ; \n }", "idx": 6523}
{"project": "FFmpeg", "commit_id": "4c5e7b27d57dd2be777780e840eef9be63242158", "target": 1, "func": "static int get_metadata_size ( const uint8_t * buf , int buf_size ) \n { \n int metadata_last , metadata_size ; \n const uint8_t * buf_end = buf + buf_size ; \n buf += 4 ; \n do { \n ff_flac_parse_block_header ( buf , & metadata_last , NULL , & metadata_size ) ; \n buf += 4 ; \n if ( buf + metadata_size > buf_end ) { \n return 0 ; \n } \n buf += metadata_size ; \n } while ( ! metadata_last ) ; \n return buf_size - ( buf_end - buf ) ; \n }", "idx": 6557}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "static av_cold int msrle_decode_init ( AVCodecContext * avctx ) \n { \n MsrleContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_coded_sample ) { \n case 1 : \n avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; \n break ; \n case 4 : \n case 8 : \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n break ; \n case 24 : \n avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avcodec_get_frame_defaults ( & s -> frame ) ; \n s -> frame . data [ 0 ] = NULL ; \n if ( avctx -> extradata_size >= AVPALETTE_SIZE ) \n for ( i = 0 ; i < AVPALETTE_SIZE / 4 ; i ++ ) \n s -> pal [ i ] = 0xFF << 24 | AV_RL32 ( avctx -> extradata + 4 * i ) ; \n return 0 ; \n }", "idx": 6569}
{"project": "FFmpeg", "commit_id": "0d4a66ee7f48c65ac67f4d91c8f8f2bfd47afa0d", "target": 0, "func": "int ffio_ensure_seekback ( AVIOContext * s , int buf_size ) \n { \n uint8_t * buffer ; \n int max_buffer_size = s -> max_packet_size ? \n s -> max_packet_size : IO_BUFFER_SIZE ; \n buf_size += s -> buf_ptr - s -> buffer + max_buffer_size ; \n if ( buf_size < s -> buffer_size || s -> seekable ) \n return 0 ; \n av_assert0 ( ! s -> write_flag ) ; \n buffer = av_malloc ( buf_size ) ; \n if ( ! buffer ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( buffer , s -> buffer , s -> buffer_size ) ; \n av_free ( s -> buffer ) ; \n s -> buf_ptr = buffer + ( s -> buf_ptr - s -> buffer ) ; \n s -> buf_end = buffer + ( s -> buf_end - s -> buffer ) ; \n s -> buffer = buffer ; \n s -> buffer_size = buf_size ; \n return 0 ; \n }", "idx": 6619}
{"project": "FFmpeg", "commit_id": "3e6b7bbce510c53b4d7962f29aaf745c9b729775", "target": 1, "func": "static int film_probe ( AVProbeData * p ) \n { \n if ( AV_RB32 ( & p -> buf [ 0 ] ) != FILM_TAG ) \n return AVPROBE_SCORE_MAX ; \n }", "idx": 6626}
{"project": "FFmpeg", "commit_id": "a8de60ba2740185c53cabbee6c00ed67a0d530e2", "target": 1, "func": "static void tqi_calculate_qtable ( TqiContext * t , int quant ) \n { \n const int qscale = ( 215 - 2 * quant ) * 5 ; \n int i ; \n t -> intra_matrix [ 0 ] = ( ff_inv_aanscales [ 0 ] * ff_mpeg1_default_intra_matrix [ 0 ] ) >> 11 ; \n for ( i = 1 ; i < 64 ; i ++ ) \n t -> intra_matrix [ i ] = ( ff_inv_aanscales [ i ] * ff_mpeg1_default_intra_matrix [ i ] * qscale + 32 ) >> 14 ; \n }", "idx": 6697}
{"project": "FFmpeg", "commit_id": "9034b0ed66c8f4a0da13947618503d575fc43957", "target": 0, "func": "static void free_input_threads ( void ) \n { \n int i ; \n if ( nb_input_files == 1 ) \n return ; \n transcoding_finished = 1 ; \n for ( i = 0 ; i < nb_input_files ; i ++ ) { \n InputFile * f = input_files [ i ] ; \n AVPacket pkt ; \n if ( f -> joined ) \n continue ; \n pthread_mutex_lock ( & f -> fifo_lock ) ; \n while ( av_fifo_size ( f -> fifo ) ) { \n av_fifo_generic_read ( f -> fifo , & pkt , sizeof ( pkt ) , NULL ) ; \n av_free_packet ( & pkt ) ; \n } \n pthread_cond_signal ( & f -> fifo_cond ) ; \n pthread_mutex_unlock ( & f -> fifo_lock ) ; \n pthread_join ( f -> thread , NULL ) ; \n f -> joined = 1 ; \n while ( av_fifo_size ( f -> fifo ) ) { \n av_fifo_generic_read ( f -> fifo , & pkt , sizeof ( pkt ) , NULL ) ; \n av_free_packet ( & pkt ) ; \n } \n av_fifo_free ( f -> fifo ) ; \n } \n }", "idx": 6706}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "int avio_open2 ( AVIOContext * * s , const char * filename , int flags , \n const AVIOInterruptCB * int_cb , AVDictionary * * options ) \n { \n AVIOInternal * internal ; \n const URLProtocol * * protocols ; \n URLContext * h ; \n int err ; \n protocols = ffurl_get_protocols ( NULL , NULL ) ; \n if ( ! protocols ) \n return AVERROR ( ENOMEM ) ; \n err = ffurl_open ( & h , filename , flags , int_cb , options , protocols ) ; \n if ( err < 0 ) { \n av_freep ( & protocols ) ; \n return err ; \n } \n err = ffio_fdopen ( s , h ) ; \n if ( err < 0 ) { \n ffurl_close ( h ) ; \n av_freep ( & protocols ) ; \n return err ; \n } \n internal = ( * s ) -> opaque ; \n internal -> protocols = protocols ; \n return 0 ; \n }", "idx": 7138}
{"project": "FFmpeg", "commit_id": "1ca7dc60d2f2cac8fce1bdb53d3d5bae195161b0", "target": 1, "func": "yuv2422_1_c_template ( SwsContext * c , const int16_t * buf0 , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf0 , uint8_t * dest , int dstW , \n int uvalpha , int y , enum PixelFormat target )  \n { \n const int16_t * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] , \n * vbuf0 = vbuf [ 0 ] , * vbuf1 = vbuf [ 1 ] ; \n int i ; \n if ( uvalpha < 2048 ) { \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = buf0 [ i * 2 ] >> 7 ; \n int Y2 = buf0 [ i * 2 + 1 ] >> 7 ; \n int U = ubuf1 [ i ] >> 7 ; \n int V = vbuf1 [ i ] >> 7 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n } else { \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = buf0 [ i * 2 ] >> 7 ; \n int Y2 = buf0 [ i * 2 + 1 ] >> 7 ; \n int U = ( ubuf0 [ i ] + ubuf1 [ i ] ) >> 8 ; \n int V = ( vbuf0 [ i ] + vbuf1 [ i ] ) >> 8 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n } \n }", "idx": 7295}
{"project": "FFmpeg", "commit_id": "838740e6420538ad45982da6b1d3aa3ae91307f5", "target": 1, "func": "static void decode_sublayer_hrd ( HEVCContext * s , int nb_cpb , \n int subpic_params_present ) \n { \n GetBitContext * gb = & s -> HEVClc . gb ; \n int i ; \n for ( i = 0 ; i < nb_cpb ; i ++ ) { \n get_ue_golomb_long ( gb ) ; \n get_ue_golomb_long ( gb ) ; \n if ( subpic_params_present ) { \n get_ue_golomb_long ( gb ) ; \n get_ue_golomb_long ( gb ) ; \n } \n skip_bits1 ( gb ) ; \n } \n }", "idx": 7352}
{"project": "FFmpeg", "commit_id": "baced9f5986a466c957456f5cf32a722d8b35512", "target": 0, "func": "static void mpeg4_encode_visual_object_header ( MpegEncContext * s ) { \n int profile_and_level_indication ; \n int vo_ver_id ; \n if ( s -> max_b_frames || s -> quarter_sample ) { \n profile_and_level_indication = 0xF1 ; \n vo_ver_id = 5 ; \n } else { \n profile_and_level_indication = 0x01 ; \n vo_ver_id = 1 ; \n } \n put_bits ( & s -> pb , 16 , 0 ) ; \n put_bits ( & s -> pb , 16 , VOS_STARTCODE ) ; \n put_bits ( & s -> pb , 8 , profile_and_level_indication ) ; \n put_bits ( & s -> pb , 16 , 0 ) ; \n put_bits ( & s -> pb , 16 , VISUAL_OBJ_STARTCODE ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 4 , vo_ver_id ) ; \n put_bits ( & s -> pb , 3 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n ff_mpeg4_stuffing ( & s -> pb ) ; \n }", "idx": 7406}
{"project": "FFmpeg", "commit_id": "3c27275c1309190f2d6ed69140b67d014215b6c9", "target": 0, "func": "static void add_entry1 ( TiffEncoderContext * s , \n enum TiffTags tag , enum TiffTypes type , int val ) \n { \n uint16_t w = val ; \n uint32_t dw = val ; \n add_entry ( s , tag , type , 1 , type == TIFF_SHORT ? ( void * ) & w : ( void * ) & dw ) ; \n }", "idx": 7434}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void yuvj444p_to_rgb24 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n uint8_t * y1_ptr , * cb_ptr , * cr_ptr , * d , * d1 ; \n int w , y , cb , cr , r_add , g_add , b_add ; \n uint8_t * cm = cropTbl + MAX_NEG_CROP ; \n unsigned int r , g , b ; \n d = dst -> data [ 0 ] ; \n y1_ptr = src -> data [ 0 ] ; \n cb_ptr = src -> data [ 1 ] ; \n cr_ptr = src -> data [ 2 ] ; \n for ( ; height > 0 ; height -- ) { \n d1 = d ; \n for ( w = width ; w > 0 ; w -- ) { \n YUV_TO_RGB1 ( cb_ptr [ 0 ] , cr_ptr [ 0 ] ) ; \n YUV_TO_RGB2 ( r , g , b , y1_ptr [ 0 ] ) ; \n RGB_OUT ( d1 , r , g , b ) ; \n d1 += BPP ; \n y1_ptr ++ ; \n cb_ptr ++ ; \n cr_ptr ++ ; \n } \n d += dst -> linesize [ 0 ] ; \n y1_ptr += src -> linesize [ 0 ] - width ; \n cb_ptr += src -> linesize [ 1 ] - width ; \n cr_ptr += src -> linesize [ 2 ] - width ; \n } \n }", "idx": 7610}
{"project": "FFmpeg", "commit_id": "c1847c932b1576e8224c38e112a5fd29fa8a6098", "target": 1, "func": "static int rtcp_parse_packet ( RTPDemuxContext * s , const unsigned char * buf , int len ) \n { \n int payload_len ; \n while ( len >= 2 ) { \n switch ( buf [ 1 ] ) { \n case RTCP_SR : \n if ( len < 16 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n payload_len = ( AV_RB16 ( buf + 2 ) + 1 ) * 4 ; \n s -> last_rtcp_ntp_time = AV_RB64 ( buf + 8 ) ; \n s -> last_rtcp_timestamp = AV_RB32 ( buf + 16 ) ; \n if ( s -> first_rtcp_ntp_time == AV_NOPTS_VALUE ) { \n s -> first_rtcp_ntp_time = s -> last_rtcp_ntp_time ; \n if ( ! s -> base_timestamp ) \n s -> base_timestamp = s -> last_rtcp_timestamp ; \n s -> rtcp_ts_offset = s -> last_rtcp_timestamp - s -> base_timestamp ; \n } \n buf += payload_len ; \n len -= payload_len ; \n break ; \n case RTCP_BYE : \n return - RTCP_BYE ; \n default : \n return -1 ; \n } \n } \n return -1 ; \n }", "idx": 7689}
{"project": "FFmpeg", "commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "target": 1, "func": "static int thread_execute ( AVCodecContext * avctx , action_func * func , void * arg , int * ret , int job_count , int job_size ) \n { \n SliceThreadContext * c = avctx -> internal -> thread_ctx ; \n if ( ! ( avctx -> active_thread_type & FF_THREAD_SLICE ) || avctx -> thread_count <= 1 ) \n return avcodec_default_execute ( avctx , func , arg , ret , job_count , job_size ) ; \n if ( job_count <= 0 ) \n return 0 ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n c -> current_job = avctx -> thread_count ; \n c -> job_count = job_count ; \n c -> job_size = job_size ; \n c -> args = arg ; \n c -> func = func ; \n c -> rets = ret ; \n c -> current_execute ++ ; \n pthread_cond_broadcast ( & c -> current_job_cond ) ; \n thread_park_workers ( c , avctx -> thread_count ) ; \n return 0 ; \n }", "idx": 7712}
{"project": "FFmpeg", "commit_id": "85e7386ae0d33ede4c575d4df4c1faae6c906338", "target": 0, "func": "static void gain_compensate ( COOKContext * q , cook_gains * gains_ptr , \n float * previous_buffer ) \n { \n const float fc = q -> pow2tab [ gains_ptr -> previous [ 0 ] + 63 ] ; \n float * buffer = q -> mono_mdct_output ; \n int i ; \n for ( i = 0 ; i < q -> samples_per_channel ; i ++ ) { \n buffer [ i ] *= fc ; \n buffer [ i ] += previous_buffer [ i ] ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n if ( gains_ptr -> now [ i ] || gains_ptr -> now [ i + 1 ] ) \n interpolate ( q , & buffer [ q -> gain_size_factor * i ] , \n gains_ptr -> now [ i ] , gains_ptr -> now [ i + 1 ] ) ; \n } \n memcpy ( previous_buffer , buffer + q -> samples_per_channel , \n sizeof ( float ) * q -> samples_per_channel ) ; \n }", "idx": 7715}
{"project": "FFmpeg", "commit_id": "8ebed703f153e979edb2156754c8bdac4d5d6266", "target": 1, "func": "static inline int l3_unscale ( int value , int exponent ) \n { \n unsigned int m ; \n int e ; \n e = table_4_3_exp [ 4 * value + ( exponent & 3 ) ] ; \n m = table_4_3_value [ 4 * value + ( exponent & 3 ) ] ; \n e -= exponent >> 2 ; \n #ifdef DEBUG \n if ( e < 1 ) \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , e ) ; \n #endif \n if ( e > ( SUINT ) 31 ) \n return 0 ; \n m = ( m + ( 1 << ( e - 1 ) ) ) >> e ; \n return m ; \n }", "idx": 7735}
{"project": "FFmpeg", "commit_id": "d5fd610dabb4c7a6f63d4479e66c93c37339b6c0", "target": 1, "func": "static int kalman_smoothen ( WMAVoiceContext * s , int pitch , \n const float * in , float * out , int size ) \n { \n int n ; \n float optimal_gain = 0 , dot ; \n const float * ptr = & in [ - FFMAX ( s -> min_pitch_val , pitch - 3 ) ] , \n * end = & in [ - FFMIN ( s -> max_pitch_val , pitch + 3 ) ] , \n * best_hist_ptr ; \n do { \n dot = ff_scalarproduct_float_c ( in , ptr , size ) ; \n if ( dot > optimal_gain ) { \n optimal_gain = dot ; \n best_hist_ptr = ptr ; \n } \n } while ( -- ptr >= end ) ; \n if ( optimal_gain <= 0 ) \n return -1 ; \n dot = ff_scalarproduct_float_c ( best_hist_ptr , best_hist_ptr , size ) ; \n if ( dot <= 0 ) \n return -1 ; \n if ( optimal_gain <= dot ) { \n dot = dot / ( dot + 0.6 * optimal_gain ) ; \n } else \n dot = 0.625 ; \n for ( n = 0 ; n < size ; n ++ ) \n out [ n ] = best_hist_ptr [ n ] + dot * ( in [ n ] - best_hist_ptr [ n ] ) ; \n return 0 ; \n }", "idx": 7894}
{"project": "FFmpeg", "commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "target": 1, "func": "static av_always_inline void thread_park_workers ( SliceThreadContext * c , int thread_count ) \n { \n while ( c -> current_job != thread_count + c -> job_count ) \n pthread_cond_wait ( & c -> last_job_cond , & c -> current_job_lock ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n }", "idx": 7905}
{"project": "FFmpeg", "commit_id": "c0170d09738c74280af78c6f64914c52a9b6e075", "target": 0, "func": "int av_image_get_linesize ( enum PixelFormat pix_fmt , int width , int plane ) \n { \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n int max_step [ 4 ] ; \n int max_step_comp [ 4 ] ; \n int s , linesize ; \n if ( ( unsigned ) pix_fmt >= PIX_FMT_NB || desc -> flags & PIX_FMT_HWACCEL ) \n return AVERROR ( EINVAL ) ; \n av_image_fill_max_pixsteps ( max_step , max_step_comp , desc ) ; \n s = ( max_step_comp [ plane ] == 1 || max_step_comp [ plane ] == 2 ) ? desc -> log2_chroma_w : 0 ; \n linesize = max_step [ plane ] * ( ( ( width + ( 1 << s ) - 1 ) ) >> s ) ; \n if ( desc -> flags & PIX_FMT_BITSTREAM ) \n linesize = ( linesize + 7 ) >> 3 ; \n return linesize ; \n }", "idx": 7906}
{"project": "FFmpeg", "commit_id": "705f5e5e155f6f280a360af220fc5b30cfcee702", "target": 0, "func": "av_cold void ff_synth_filter_init ( SynthFilterContext * c ) \n { \n c -> synth_filter_float = synth_filter_float ; \n if ( ARCH_ARM ) ff_synth_filter_init_arm ( c ) ; \n if ( ARCH_X86 ) ff_synth_filter_init_x86 ( c ) ; \n }", "idx": 8030}
{"project": "FFmpeg", "commit_id": "90527811d7db0da5d770235261c4b718b0869a99", "target": 0, "func": "int main ( int argc , char * * argv ) \n { \n FILE * f = fopen ( argv [ 1 ] , \" \" ) ; \n int count = atoi ( argv [ 2 ] ) ; \n int maxburst = atoi ( argv [ 3 ] ) ; \n int length ; \n srand ( time ( 0 ) ) ; \n fseek ( f , 0 , SEEK_END ) ; \n length = ftell ( f ) ; \n fseek ( f , 0 , SEEK_SET ) ; \n while ( count -- ) { \n int burst = 1 + random ( ) * ( uint64_t ) ( abs ( maxburst ) - 1 ) / RAND_MAX ; \n int pos = random ( ) * ( uint64_t ) length / RAND_MAX ; \n fseek ( f , pos , SEEK_SET ) ; \n if ( maxburst < 0 ) burst = - maxburst ; \n if ( pos + burst > length ) \n continue ; \n while ( burst -- ) { \n int val = random ( ) * 256ULL / RAND_MAX ; \n if ( maxburst < 0 ) val = 0 ; \n fwrite ( & val , 1 , 1 , f ) ; \n } \n } \n return 0 ; \n }", "idx": 8065}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xB ( IpvideoContext * s ) \n { \n int y ; \n CHECK_STREAM_PTR ( 64 ) ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n memcpy ( s -> pixel_ptr , s -> stream_ptr , 8 ) ; \n s -> stream_ptr += 8 ; \n s -> pixel_ptr += s -> stride ; \n } \n return 0 ; \n }", "idx": 8162}
{"project": "FFmpeg", "commit_id": "9cbb3fce5965f4e1423cace3d1dc340a7a8091f4", "target": 1, "func": "uint8_t * av_packet_new_side_data ( AVPacket * pkt , enum AVPacketSideDataType type , \n int size ) \n { \n int elems = pkt -> side_data_elems ; \n if ( ( unsigned ) elems + 1 > INT_MAX / sizeof ( * pkt -> side_data ) ) \n return NULL ; \n if ( ( unsigned ) size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE ) \n return NULL ; \n pkt -> side_data = av_realloc ( pkt -> side_data , \n ( elems + 1 ) * sizeof ( * pkt -> side_data ) ) ; \n if ( ! pkt -> side_data ) \n return NULL ; \n pkt -> side_data [ elems ] . data = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! pkt -> side_data [ elems ] . data ) \n return NULL ; \n pkt -> side_data [ elems ] . size = size ; \n pkt -> side_data [ elems ] . type = type ; \n pkt -> side_data_elems ++ ; \n return pkt -> side_data [ elems ] . data ; \n }", "idx": 8168}
{"project": "FFmpeg", "commit_id": "ed7fa39c2dd63607fd5c5ed3c607a11a8a33bbe3", "target": 0, "func": "static int mov_write_avcc_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n offset_t pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n if ( track -> vosLen > 6 ) { \n if ( AV_RB32 ( track -> vosData ) == 0x00000001 ) { \n uint8_t * buf , * end ; \n uint32_t sps_size = 0 , pps_size = 0 ; \n uint8_t * sps = 0 , * pps = 0 ; \n avc_parse_nal_units ( & track -> vosData , & track -> vosLen ) ; \n buf = track -> vosData ; \n end = track -> vosData + track -> vosLen ; \n while ( buf < end ) { \n unsigned int size ; \n uint8_t nal_type ; \n size = AV_RB32 ( buf ) ; \n nal_type = buf [ 4 ] & 0x1f ; \n if ( nal_type == 7 ) { \n sps = buf + 4 ; \n sps_size = size ; \n } else if ( nal_type == 8 ) { \n pps = buf + 4 ; \n pps_size = size ; \n } \n buf += size + 4 ; \n } \n assert ( sps ) ; \n assert ( pps ) ; \n put_byte ( pb , 1 ) ; \n put_byte ( pb , sps [ 1 ] ) ; \n put_byte ( pb , sps [ 2 ] ) ; \n put_byte ( pb , sps [ 3 ] ) ; \n put_byte ( pb , 0xff ) ; \n put_byte ( pb , 0xe1 ) ; \n put_be16 ( pb , sps_size ) ; \n put_buffer ( pb , sps , sps_size ) ; \n put_byte ( pb , 1 ) ; \n put_be16 ( pb , pps_size ) ; \n put_buffer ( pb , pps , pps_size ) ; \n } else { \n put_buffer ( pb , track -> vosData , track -> vosLen ) ; \n } \n } \n return updateSize ( pb , pos ) ; \n }", "idx": 8190}
{"project": "FFmpeg", "commit_id": "f3ad901a32c95239f302f173b866b82fb1f6cdf9", "target": 0, "func": "static inline int compress_coeffs ( int * coef , int order , int c_bits ) \n { \n int i , res = 0 ; \n const int low_idx = c_bits ? 4 : 2 ; \n const int shift_val = c_bits ? 8 : 4 ; \n const int high_idx = c_bits ? 11 : 5 ; \n for ( i = 0 ; i < order ; i ++ ) \n if ( coef [ i ] < low_idx || coef [ i ] > high_idx ) \n res ++ ; \n if ( res == order ) \n for ( i = 0 ; i < order ; i ++ ) \n coef [ i ] -= ( coef [ i ] > high_idx ) ? shift_val : 0 ; \n return res == order ; \n }", "idx": 8196}
{"project": "FFmpeg", "commit_id": "7f58eb3c2b552f232905731b5944307e72c590a0", "target": 1, "func": "static av_cold int indeo3_decode_end ( AVCodecContext * avctx ) \n { \n Indeo3DecodeContext * s = avctx -> priv_data ; \n iv_free_func ( s ) ; \n return 0 ; \n }", "idx": 8218}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "AVOpenCLExternalEnv * av_opencl_alloc_external_env ( void ) \n { \n AVOpenCLExternalEnv * ext = av_mallocz ( sizeof ( AVOpenCLExternalEnv ) ) ; \n if ( ! ext ) { \n av_log ( & openclutils , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n return ext ; \n }", "idx": 8276}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int context_init ( H264Context * h ) { \n CHECKED_ALLOCZ ( h -> top_borders [ 0 ] , h -> s . mb_width * ( 16 + 8 + 8 ) * sizeof ( uint8_t ) )  \n CHECKED_ALLOCZ ( h -> top_borders [ 1 ] , h -> s . mb_width * ( 16 + 8 + 8 ) * sizeof ( uint8_t ) )  \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 8311}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_material_package ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFPackage * package = arg ; \n switch ( tag ) { \n case 0x4403 : \n package -> tracks_count = avio_rb32 ( pb ) ; \n if ( package -> tracks_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n package -> tracks_refs = av_malloc ( package -> tracks_count * sizeof ( UID ) ) ; \n if ( ! package -> tracks_refs ) \n return -1 ; \n avio_skip ( pb , 4 ) ; \n avio_read ( pb , ( uint8_t * ) package -> tracks_refs , package -> tracks_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 8366}
{"project": "FFmpeg", "commit_id": "472ea1284e925297b08921b7189f57f6789c898c", "target": 1, "func": "static int cinepak_decode_strip ( CinepakContext * s , \n cvid_strip_t * strip , uint8_t * data , int size ) \n { \n uint8_t * eod = ( data + size ) ; \n int chunk_id , chunk_size ; \n if ( strip -> x1 >= s -> width || strip -> x2 > s -> width || \n strip -> y1 >= s -> height || strip -> y2 > s -> height || \n strip -> x1 >= strip -> x2 || strip -> y1 >= strip -> y2 ) \n while ( ( data + 4 ) <= eod ) { \n chunk_id = BE_16 ( & data [ 0 ] ) ; \n chunk_size = BE_16 ( & data [ 2 ] ) - 4 ; \n data += 4 ; \n chunk_size = ( ( data + chunk_size ) > eod ) ? ( eod - data ) : chunk_size ; \n switch ( chunk_id ) { \n case 0x2000 : \n case 0x2100 : \n case 0x2400 : \n case 0x2500 : \n cinepak_decode_codebook ( strip -> v4_codebook , chunk_id , \n chunk_size , data ) ; \n break ; \n case 0x2200 : \n case 0x2300 : \n case 0x2600 : \n case 0x2700 : \n cinepak_decode_codebook ( strip -> v1_codebook , chunk_id , \n chunk_size , data ) ; \n break ; \n case 0x3000 : \n case 0x3100 : \n case 0x3200 : \n return cinepak_decode_vectors ( s , strip , chunk_id , \n chunk_size , data ) ; \n } \n data += chunk_size ; \n } \n }", "idx": 8419}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "void * av_realloc_array ( void * ptr , size_t nmemb , size_t size ) \n { \n if ( size <= 0 || nmemb >= INT_MAX / size ) \n return NULL ; \n return av_realloc ( ptr , nmemb * size ) ; \n }", "idx": 8424}
{"project": "FFmpeg", "commit_id": "c8f9f9b91a3d3254e62f4fbcd6065a504164b06b", "target": 1, "func": "static int vmdaudio_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n VmdAudioContext * s = ( VmdAudioContext * ) avctx -> priv_data ; \n unsigned int sound_flags ; \n unsigned char * output_samples = ( unsigned char * ) data ; \n unsigned char * p = buf + 16 ; \n unsigned char * p_end = buf + buf_size ; \n if ( buf_size < 16 ) \n return buf_size ; \n if ( buf [ 6 ] == 1 ) { \n * data_size = vmdaudio_loadsound ( s , output_samples , p , 0 ) ; \n } else if ( buf [ 6 ] == 2 ) { \n sound_flags = LE_32 ( p ) ; \n p += 4 ; \n while ( p < p_end ) { \n if ( sound_flags & 0x01 ) \n * data_size += vmdaudio_loadsound ( s , output_samples , p , 1 ) ; \n else { \n * data_size += vmdaudio_loadsound ( s , output_samples , p , 0 ) ; \n p += s -> block_align ; \n } \n output_samples += ( s -> block_align * s -> bits / 8 ) ; \n sound_flags >>= 1 ; \n } \n } else if ( buf [ 6 ] == 3 ) { \n * data_size = vmdaudio_loadsound ( s , output_samples , p , 1 ) ; \n } \n return buf_size ; \n }", "idx": 8460}
{"project": "FFmpeg", "commit_id": "baf4c489e5f468a208596cd128a6f1c49e6ae35b", "target": 0, "func": "int avio_printf ( AVIOContext * s , const char * fmt , ... ) \n { \n va_list ap ; \n char buf [ 4096 ] ; \n int ret ; \n va_start ( ap , fmt ) ; \n ret = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ; \n va_end ( ap ) ; \n avio_write ( s , buf , strlen ( buf ) ) ; \n return ret ; \n }", "idx": 8573}
{"project": "FFmpeg", "commit_id": "c64b2d480b4a35d4face9928b4265a0fda3f3dd9", "target": 1, "func": "static int get_stats ( AVCodecContext * avctx , int eos ) \n { \n #ifdef TH_ENCCTL_2PASS_OUT \n TheoraContext * h = avctx -> priv_data ; \n uint8_t * buf ; \n int bytes ; \n bytes = th_encode_ctl ( h -> t_state , TH_ENCCTL_2PASS_OUT , & buf , sizeof ( buf ) ) ; \n if ( bytes < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_EXTERNAL ; \n } \n if ( ! eos ) { \n void * tmp = av_fast_realloc ( h -> stats , & h -> stats_size , \n h -> stats_offset + bytes ) ; \n if ( ! tmp ) \n h -> stats = tmp ; \n memcpy ( h -> stats + h -> stats_offset , buf , bytes ) ; \n h -> stats_offset += bytes ; \n } else { \n int b64_size = AV_BASE64_SIZE ( h -> stats_offset ) ; \n memcpy ( h -> stats , buf , bytes ) ; \n avctx -> stats_out = av_malloc ( b64_size ) ; \n av_base64_encode ( avctx -> stats_out , b64_size , h -> stats , h -> stats_offset ) ; \n } \n return 0 ; \n #else \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSUP ) ; \n #endif \n }", "idx": 8694}
{"project": "FFmpeg", "commit_id": "3920d1387834e2bc334aff9f518f4beb24e470bd", "target": 1, "func": "static int allocate_buffers ( ALACContext * alac ) \n { \n int ch ; \n int buf_size = alac -> max_samples_per_frame * sizeof ( int32_t ) ; \n for ( ch = 0 ; ch < FFMIN ( alac -> channels , 2 ) ; ch ++ ) { \n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> predict_error_buffer [ ch ] , \n buf_size , buf_alloc_fail ) ; \n alac -> direct_output = alac -> sample_size > 16 && av_sample_fmt_is_planar ( alac -> avctx -> sample_fmt ) ; \n if ( ! alac -> direct_output ) { \n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> output_samples_buffer [ ch ] , \n buf_size , buf_alloc_fail ) ; \n } \n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> extra_bits_buffer [ ch ] , \n buf_size , buf_alloc_fail ) ; \n } \n return 0 ; \n buf_alloc_fail : \n alac_decode_close ( alac -> avctx ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 8702}
{"project": "FFmpeg", "commit_id": "631c56a8e46dea41585f3e7b3ef9c52b49faa385", "target": 0, "func": "int ff_network_init ( void ) \n { \n #if HAVE_WINSOCK2_H  \n  \n  WSADATA wsaData ; \n #endif \n if ( ! ff_network_inited_globally ) \n av_log ( NULL , AV_LOG_WARNING , \" \" \n \" \" \n \" \" \n \" \\n \" ) ; \n #if HAVE_WINSOCK2_H  \n  \n  if ( WSAStartup ( MAKEWORD ( 1 , 1 ) , & wsaData ) ) \n return 0 ; \n #endif \n return 1 ; \n }", "idx": 8801}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int jacosub_probe ( AVProbeData * p ) \n { \n const char * ptr = p -> buf ; \n const char * ptr_end = p -> buf + p -> buf_size ; \n if ( AV_RB24 ( ptr ) == 0xEFBBBF ) \n ptr += 3 ; \n while ( ptr < ptr_end ) { \n while ( jss_whitespace ( * ptr ) ) \n ptr ++ ; \n if ( * ptr != ' ' && * ptr != ' \\n ' ) { \n if ( timed_line ( ptr ) ) \n return AVPROBE_SCORE_EXTENSION + 1 ; \n return 0 ; \n } \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n } \n return 0 ; \n }", "idx": 8803}
{"project": "FFmpeg", "commit_id": "990b13806d38f51201afb4e5048c61bf3e1c576e", "target": 1, "func": "static void blend_frame ( AVFilterContext * ctx , \n AVFrame * top_buf , \n AVFrame * bottom_buf , \n AVFrame * dst_buf ) \n { \n BlendContext * b = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n FilterParams * param ; \n int plane ; \n for ( plane = 0 ; dst_buf -> data [ plane ] ; plane ++ ) { \n int hsub = plane == 1 || plane == 2 ? b -> hsub : 0 ; \n int vsub = plane == 1 || plane == 2 ? b -> vsub : 0 ; \n int outw = dst_buf -> width >> hsub ; \n int outh = dst_buf -> height >> vsub ; \n uint8_t * dst = dst_buf -> data [ plane ] ; \n uint8_t * top = top_buf -> data [ plane ] ; \n uint8_t * bottom = bottom_buf -> data [ plane ] ; \n param = & b -> params [ plane ] ; \n param -> values [ VAR_N ] = inlink -> frame_count ; \n param -> values [ VAR_T ] = dst_buf -> pts == AV_NOPTS_VALUE ? NAN : dst_buf -> pts * av_q2d ( inlink -> time_base ) ; \n param -> values [ VAR_W ] = outw ; \n param -> values [ VAR_H ] = outh ; \n param -> values [ VAR_SW ] = outw / dst_buf -> width ; \n param -> values [ VAR_SH ] = outh / dst_buf -> height ; \n param -> blend ( top , top_buf -> linesize [ plane ] , \n bottom , bottom_buf -> linesize [ plane ] , \n dst , dst_buf -> linesize [ plane ] , outw , outh , param ) ; \n } \n }", "idx": 9024}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel4_mc21_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_4w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 4 , 0 ) ; \n }", "idx": 9083}
{"project": "FFmpeg", "commit_id": "57623cba1301ee7874687dd7e04c611051638e9d", "target": 0, "func": "static int vp8_lossy_decode_frame ( AVCodecContext * avctx , AVFrame * p , \n int * got_frame , uint8_t * data_start , \n unsigned int data_size ) \n { \n WebPContext * s = avctx -> priv_data ; \n AVPacket pkt ; \n int ret ; \n if ( ! s -> initialized ) { \n ff_vp8_decode_init ( avctx ) ; \n s -> initialized = 1 ; \n avctx -> get_format = webp_get_format ; \n } \n s -> lossless = 0 ; \n if ( data_size > INT_MAX ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n av_init_packet ( & pkt ) ; \n pkt . data = data_start ; \n pkt . size = data_size ; \n ret = ff_vp8_decode_frame ( avctx , p , got_frame , & pkt ) ; \n if ( s -> has_alpha ) { \n ret = vp8_lossy_decode_alpha ( avctx , p , s -> alpha_data , \n s -> alpha_data_size ) ; \n if ( ret < 0 ) \n return ret ; \n } \n return ret ; \n }", "idx": 9130}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_float ( float * p , int i0 , int i1 ) \n { \n int i ; \n if ( i1 <= i0 + 1 ) { \n if ( i0 == 1 ) \n p [ 1 ] *= F_LFTG_X ; \n else \n p [ 0 ] *= F_LFTG_K ; \n return ; \n } \n extend97_float ( p , i0 , i1 ) ; \n i0 ++ ; i1 ++ ; \n for ( i = i0 / 2 - 2 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i + 1 ] -= 1.586134 * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i ] -= 0.052980 * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i + 1 ] += 0.882911 * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) ; \n for ( i = i0 / 2 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i ] += 0.443506 * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) ; \n }", "idx": 9192}
{"project": "FFmpeg", "commit_id": "99683a307776a7638ccce236a4ce5aa3e914e77d", "target": 1, "func": "static void jpeg_put_comments ( MpegEncContext * s ) \n { \n PutBitContext * p = & s -> pb ; \n int size ; \n uint8_t * ptr ; \n if ( s -> aspect_ratio_info \n ) \n { \n put_marker ( p , APP0 ) ; \n put_bits ( p , 16 , 16 ) ; \n put_string ( p , \" \" ) ; \n put_bits ( p , 16 , 0x0201 ) ; \n put_bits ( p , 8 , 0 ) ; \n put_bits ( p , 16 , s -> avctx -> sample_aspect_ratio . num ) ; \n put_bits ( p , 16 , s -> avctx -> sample_aspect_ratio . den ) ; \n put_bits ( p , 8 , 0 ) ; \n put_bits ( p , 8 , 0 ) ; \n } \n if ( ! ( s -> flags & CODEC_FLAG_BITEXACT ) ) { \n put_marker ( p , COM ) ; \n flush_put_bits ( p ) ; \n ptr = pbBufPtr ( p ) ; \n put_bits ( p , 16 , 0 ) ; \n put_string ( p , LIBAVCODEC_IDENT ) ; \n size = strlen ( LIBAVCODEC_IDENT ) + 3 ; \n ptr [ 0 ] = size >> 8 ; \n ptr [ 1 ] = size ; \n } \n }", "idx": 9227}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "static void ff_dlog_link ( void * ctx , AVFilterLink * link , int end ) \n { \n if ( link -> type == AVMEDIA_TYPE_VIDEO ) { \n av_dlog ( ctx , \n \" \" , \n link , link -> w , link -> h , \n av_pix_fmt_descriptors [ link -> format ] . name , \n link -> src ? link -> src -> filter -> name : \" \" , \n link -> dst ? link -> dst -> filter -> name : \" \" , \n end ? \" \\n \" : \" \" ) ; \n } else { \n char buf [ 128 ] ; \n av_get_channel_layout_string ( buf , sizeof ( buf ) , -1 , link -> channel_layout ) ; \n av_dlog ( ctx , \n \" \" PRId64 \" \" , \n link , link -> sample_rate , buf , \n av_get_sample_fmt_name ( link -> format ) , \n link -> src ? link -> src -> filter -> name : \" \" , \n link -> dst ? link -> dst -> filter -> name : \" \" , \n end ? \" \\n \" : \" \" ) ; \n } \n }", "idx": 9327}
{"project": "FFmpeg", "commit_id": "af19f78f2fe2b969104d4419efd25fdee90a2814", "target": 0, "func": "void dsputil_init_mlib ( void ) \n { \n put_pixels_tab [ 0 ] [ 0 ] = put_pixels16_mlib ; \n put_pixels_tab [ 0 ] [ 1 ] = put_pixels16_x2_mlib ; \n put_pixels_tab [ 0 ] [ 2 ] = put_pixels16_y2_mlib ; \n put_pixels_tab [ 0 ] [ 3 ] = put_pixels16_xy2_mlib ; \n put_pixels_tab [ 1 ] [ 0 ] = put_pixels8_mlib ; \n put_pixels_tab [ 1 ] [ 1 ] = put_pixels8_x2_mlib ; \n put_pixels_tab [ 1 ] [ 2 ] = put_pixels8_y2_mlib ; \n put_pixels_tab [ 1 ] [ 3 ] = put_pixels8_xy2_mlib ; \n avg_pixels_tab [ 0 ] [ 0 ] = avg_pixels16_mlib ; \n avg_pixels_tab [ 0 ] [ 1 ] = avg_pixels16_x2_mlib ; \n avg_pixels_tab [ 0 ] [ 2 ] = avg_pixels16_y2_mlib ; \n avg_pixels_tab [ 0 ] [ 3 ] = avg_pixels16_xy2_mlib ; \n avg_pixels_tab [ 1 ] [ 0 ] = avg_pixels8_mlib ; \n avg_pixels_tab [ 1 ] [ 1 ] = avg_pixels8_x2_mlib ; \n avg_pixels_tab [ 1 ] [ 2 ] = avg_pixels8_y2_mlib ; \n avg_pixels_tab [ 1 ] [ 3 ] = avg_pixels8_xy2_mlib ; \n put_no_rnd_pixels_tab [ 0 ] [ 0 ] = put_pixels16_mlib ; \n put_no_rnd_pixels_tab [ 1 ] [ 0 ] = put_pixels8_mlib ; \n add_pixels_clamped = add_pixels_clamped_mlib ; \n }", "idx": 9359}
{"project": "FFmpeg", "commit_id": "42ee137a0a7d025f77964e38b438d00095e6dd11", "target": 1, "func": "static av_cold int m101_decode_init ( AVCodecContext * avctx ) \n { \n if ( avctx -> extradata_size < 6 * 4 ) \n return AVERROR_INVALIDDATA ; \n if ( avctx -> extradata [ 2 * 4 ] == 10 ) \n avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; \n else \n avctx -> pix_fmt = AV_PIX_FMT_YUYV422 ; \n return 0 ; \n }", "idx": 9408}
{"project": "FFmpeg", "commit_id": "0ce3a0f9d9523a9bcad4c6d451ca5bbd7a4f420d", "target": 1, "func": "static void restore_median ( uint8_t * src , int step , int stride , \n int width , int height , int slices , int rmode ) \n { \n int i , j , slice ; \n int A , B , C ; \n uint8_t * bsrc ; \n int slice_start , slice_height ; \n const int cmask = ~ rmode ; \n for ( slice = 0 ; slice < slices ; slice ++ ) { \n slice_start = ( ( slice * height ) / slices ) & cmask ; \n slice_height = ( ( ( ( slice + 1 ) * height ) / slices ) & cmask ) - \n slice_start ; \n bsrc = src + slice_start * stride ; \n bsrc [ 0 ] += 0x80 ; \n A = bsrc [ 0 ] ; \n for ( i = step ; i < width * step ; i += step ) { \n bsrc [ i ] += A ; \n A = bsrc [ i ] ; \n } \n bsrc += stride ; \n if ( slice_height == 1 ) \n C = bsrc [ - stride ] ; \n bsrc [ 0 ] += C ; \n A = bsrc [ 0 ] ; \n for ( i = step ; i < width * step ; i += step ) { \n B = bsrc [ i - stride ] ; \n bsrc [ i ] += mid_pred ( A , B , ( uint8_t ) ( A + B - C ) ) ; \n C = B ; \n A = bsrc [ i ] ; \n } \n bsrc += stride ; \n for ( j = 2 ; j < slice_height ; j ++ ) { \n for ( i = 0 ; i < width * step ; i += step ) { \n B = bsrc [ i - stride ] ; \n bsrc [ i ] += mid_pred ( A , B , ( uint8_t ) ( A + B - C ) ) ; \n C = B ; \n A = bsrc [ i ] ; \n } \n bsrc += stride ; \n } \n } \n }", "idx": 9466}
{"project": "FFmpeg", "commit_id": "25715064c2ef4978672a91f8c856f3e8809a7c45", "target": 0, "func": "static int decode_seq_header ( AVSContext * h ) { \n MpegEncContext * s = & h -> s ; \n int frame_rate_code ; \n h -> profile = get_bits ( & s -> gb , 8 ) ; \n h -> level = get_bits ( & s -> gb , 8 ) ; \n skip_bits1 ( & s -> gb ) ; \n s -> width = get_bits ( & s -> gb , 14 ) ; \n s -> height = get_bits ( & s -> gb , 14 ) ; \n skip_bits ( & s -> gb , 2 ) ; \n skip_bits ( & s -> gb , 3 ) ; \n h -> aspect_ratio = get_bits ( & s -> gb , 4 ) ; \n frame_rate_code = get_bits ( & s -> gb , 4 ) ; \n skip_bits ( & s -> gb , 18 ) ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits ( & s -> gb , 12 ) ; \n s -> low_delay = get_bits1 ( & s -> gb ) ; \n h -> mb_width = ( s -> width + 15 ) >> 4 ; \n h -> mb_height = ( s -> height + 15 ) >> 4 ; \n h -> s . avctx -> time_base . den = avpriv_frame_rate_tab [ frame_rate_code ] . num ; \n h -> s . avctx -> time_base . num = avpriv_frame_rate_tab [ frame_rate_code ] . den ; \n h -> s . avctx -> width = s -> width ; \n h -> s . avctx -> height = s -> height ; \n if ( ! h -> top_qp ) \n ff_cavs_init_top_lines ( h ) ; \n return 0 ; \n }", "idx": 9481}
{"project": "FFmpeg", "commit_id": "d9d9fd9446eb722fd288f56d905f0dfde661af8f", "target": 1, "func": "int ff_mpeg_er_init ( MpegEncContext * s ) \n { \n ERContext * er = & s -> er ; \n int mb_array_size = s -> mb_height * s -> mb_stride ; \n int i ; \n er -> avctx = s -> avctx ; \n er -> mb_index2xy = s -> mb_index2xy ; \n er -> mb_num = s -> mb_num ; \n er -> mb_width = s -> mb_width ; \n er -> mb_height = s -> mb_height ; \n er -> mb_stride = s -> mb_stride ; \n er -> b8_stride = s -> b8_stride ; \n er -> er_temp_buffer = av_malloc ( s -> mb_height * s -> mb_stride ) ; \n er -> error_status_table = av_mallocz ( mb_array_size ) ; \n if ( ! er -> er_temp_buffer || ! er -> error_status_table ) \n goto fail ; \n er -> mbskip_table = s -> mbskip_table ; \n er -> mbintra_table = s -> mbintra_table ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> dc_val ) ; i ++ ) \n er -> dc_val [ i ] = s -> dc_val [ i ] ; \n er -> decode_mb = mpeg_er_decode_mb ; \n er -> opaque = s ; \n return 0 ; \n fail : \n av_freep ( & er -> er_temp_buffer ) ; \n av_freep ( & er -> error_status_table ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 9483}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( bgr24ToUV_half ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int r = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n } \n assert ( src1 == src2 ) ; \n }", "idx": 9522}
{"project": "FFmpeg", "commit_id": "2e7744a6a265604600f86a85c6961dbf5df9ecdd", "target": 1, "func": "static int subviewer_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_sub_ptr , AVPacket * avpkt ) \n { \n char c ; \n AVSubtitle * sub = data ; \n const char * ptr = avpkt -> data ; \n AVBPrint buf ; \n if ( sscanf ( ptr , \" \" , & c ) == 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \" \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; \n if ( ptr && avpkt -> size > 0 && ! subviewer_event_to_ass ( & buf , ptr ) ) \n ff_ass_add_rect ( sub , buf . str , avpkt -> pts , avpkt -> duration , 0 ) ; \n * got_sub_ptr = sub -> num_rects > 0 ; \n av_bprint_finalize ( & buf , NULL ) ; \n return avpkt -> size ; \n }", "idx": 9649}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int standard_decode_picture_header ( VC9Context * v ) \n { \n int status = 0 ; \n if ( v -> finterpflag ) v -> interpfrm = get_bits ( & v -> gb , 1 ) ; \n skip_bits ( & v -> gb , 2 ) ; \n if ( v -> rangered ) v -> rangeredfrm = get_bits ( & v -> gb , 1 ) ; \n v -> pict_type = get_bits ( & v -> gb , 1 ) ; \n if ( v -> avctx -> max_b_frames && ! v -> pict_type ) \n { \n if ( get_bits ( & v -> gb , 1 ) ) v -> pict_type = I_TYPE ; \n else v -> pict_type = P_TYPE ; \n } \n else v -> pict_type ++ ; \n switch ( v -> pict_type ) \n { \n case I_TYPE : status = decode_i_picture_header ( v ) ; break ; \n case BI_TYPE : status = decode_b_picture_header ( v ) ; break ; \n case P_TYPE : status = decode_p_picture_header ( v ) ; break ; \n case B_TYPE : status = decode_b_picture_header ( v ) ; break ; \n } \n if ( status == FRAME_SKIPED ) \n { \n av_log ( v , AV_LOG_INFO , \" \\n \" ) ; \n return status ; \n } \n v -> transacfrm = get_bits ( & v -> gb , 1 ) ; \n if ( v -> transacfrm ) v -> transacfrm += get_bits ( & v -> gb , 1 ) ; \n if ( v -> pict_type == I_TYPE || v -> pict_type == BI_TYPE ) \n { \n v -> transacfrm2 = get_bits ( & v -> gb , 1 ) ; \n if ( v -> transacfrm2 ) v -> transacfrm2 += get_bits ( & v -> gb , 1 ) ; \n } \n v -> transacdctab = get_bits ( & v -> gb , 1 ) ; \n return 0 ; \n }", "idx": 9661}
{"project": "FFmpeg", "commit_id": "cc13bc8c4f0f4afa30d0b94c3f3a369ccd2aaf0b", "target": 0, "func": "static int decode_extradata_ps ( const uint8_t * data , int size , H264ParamSets * ps , \n int is_avc , void * logctx ) \n { \n H2645Packet pkt = { 0 } ; \n int i , ret = 0 ; \n ret = ff_h2645_packet_split ( & pkt , data , size , logctx , is_avc , 2 , AV_CODEC_ID_H264 ) ; \n if ( ret < 0 ) { \n ret = 0 ; \n goto fail ; \n } \n for ( i = 0 ; i < pkt . nb_nals ; i ++ ) { \n H2645NAL * nal = & pkt . nals [ i ] ; \n switch ( nal -> type ) { \n case H264_NAL_SPS : \n ret = ff_h264_decode_seq_parameter_set ( & nal -> gb , logctx , ps , 0 ) ; \n if ( ret < 0 ) \n goto fail ; \n break ; \n case H264_NAL_PPS : \n ret = ff_h264_decode_picture_parameter_set ( & nal -> gb , logctx , ps , \n nal -> size_bits ) ; \n if ( ret < 0 ) \n goto fail ; \n break ; \n default : \n av_log ( logctx , AV_LOG_VERBOSE , \" \\n \" , \n nal -> type ) ; \n break ; \n } \n } \n fail : \n ff_h2645_packet_uninit ( & pkt ) ; \n return ret ; \n }", "idx": 9759}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void start_frame_overlay ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n OverlayContext * over = ctx -> priv ; \n inpicref -> pts = av_rescale_q ( inpicref -> pts , ctx -> inputs [ OVERLAY ] -> time_base , \n ctx -> outputs [ 0 ] -> time_base ) ; \n if ( ! over -> overpicref ) over -> overpicref = inpicref ; \n else over -> overpicref_next = inpicref ; \n }", "idx": 9835}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void decode_refpass ( Jpeg2000T1Context * t1 , int width , int height , \n int bpno , int vert_causal_ctx_csty_symbol ) \n { \n int phalf , nhalf ; \n int y0 , x , y ; \n phalf = 1 << ( bpno - 1 ) ; \n nhalf = - phalf ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) == JPEG2000_T1_SIG ) { \n int flags_mask = ( vert_causal_ctx_csty_symbol && y == y0 + 3 ) ? \n ~ ( JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE | JPEG2000_T1_SGN_S ) : -1 ; \n int ctxno = ff_jpeg2000_getrefctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] & flags_mask ) ; \n int r = ff_mqc_decode ( & t1 -> mqc , \n t1 -> mqc . cx_states + ctxno ) \n ? phalf : nhalf ; \n t1 -> data [ y ] [ x ] += t1 -> data [ y ] [ x ] < 0 ? - r : r ; \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_REF ; \n } \n }", "idx": 9901}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t find_subframe_rice_params ( FlacEncodeContext * s , \n FlacSubframe * sub , int pred_order ) \n { \n int pmin = get_max_p_order ( s -> options . min_partition_order , \n s -> frame . blocksize , pred_order ) ; \n int pmax = get_max_p_order ( s -> options . max_partition_order , \n s -> frame . blocksize , pred_order ) ; \n uint32_t bits = 8 + pred_order * sub -> obits + 2 + 4 ; \n if ( sub -> type == FLAC_SUBFRAME_LPC ) \n bits += 4 + 5 + pred_order * s -> options . lpc_coeff_precision ; \n bits += calc_rice_params ( & sub -> rc , pmin , pmax , sub -> residual , \n s -> frame . blocksize , pred_order ) ; \n return bits ; \n }", "idx": 9911}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static int mmap_start ( AVFormatContext * ctx ) \n { \n struct video_data * s = ctx -> priv_data ; \n enum v4l2_buf_type type ; \n int i , res ; \n for ( i = 0 ; i < s -> buffers ; i ++ ) { \n struct v4l2_buffer buf ; \n memset ( & buf , 0 , sizeof ( struct v4l2_buffer ) ) ; \n buf . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n buf . memory = V4L2_MEMORY_MMAP ; \n buf . index = i ; \n res = ioctl ( s -> fd , VIDIOC_QBUF , & buf ) ; \n if ( res < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n strerror ( errno ) ) ; \n return AVERROR ( errno ) ; \n } \n } \n type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n res = ioctl ( s -> fd , VIDIOC_STREAMON , & type ) ; \n if ( res < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n strerror ( errno ) ) ; \n return AVERROR ( errno ) ; \n } \n return 0 ; \n }", "idx": 9919}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "int ffurl_register_protocol ( URLProtocol * protocol ) \n { \n URLProtocol * * p ; \n p = & first_protocol ; \n while ( * p != NULL ) \n p = & ( * p ) -> next ; \n * p = protocol ; \n protocol -> next = NULL ; \n return 0 ; \n }", "idx": 10060}
{"project": "FFmpeg", "commit_id": "856834a77f4145adc5951e8b08984981fed4463d", "target": 0, "func": "static av_cold int common_init ( AVCodecContext * avctx ) { \n FFV1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> flags = avctx -> flags ; \n avcodec_get_frame_defaults ( & s -> picture ) ; \n ff_dsputil_init ( & s -> dsp , avctx ) ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n assert ( s -> width && s -> height ) ; \n s -> num_h_slices = 1 ; \n s -> num_v_slices = 1 ; \n return 0 ; \n }", "idx": 10075}
{"project": "FFmpeg", "commit_id": "d05588e21e4744ae6a47192dc2da2844d6934a5d", "target": 0, "func": "AVInputFormat * av_probe_input_format3 ( AVProbeData * pd , int is_opened , \n int * score_ret ) \n { \n AVProbeData lpd = * pd ; \n AVInputFormat * fmt1 = NULL , * fmt ; \n int score , nodat = 0 , score_max = 0 ; \n const static uint8_t zerobuffer [ AVPROBE_PADDING_SIZE ] ; \n if ( ! lpd . buf ) \n lpd . buf = zerobuffer ; \n if ( lpd . buf_size > 10 && ff_id3v2_match ( lpd . buf , ID3v2_DEFAULT_MAGIC ) ) { \n int id3len = ff_id3v2_tag_len ( lpd . buf ) ; \n if ( lpd . buf_size > id3len + 16 ) { \n lpd . buf += id3len ; \n lpd . buf_size -= id3len ; \n } else \n nodat = 1 ; \n } \n fmt = NULL ; \n while ( ( fmt1 = av_iformat_next ( fmt1 ) ) ) { \n if ( ! is_opened == ! ( fmt1 -> flags & AVFMT_NOFILE ) ) \n continue ; \n score = 0 ; \n if ( fmt1 -> read_probe ) { \n score = fmt1 -> read_probe ( & lpd ) ; \n if ( fmt1 -> extensions && av_match_ext ( lpd . filename , fmt1 -> extensions ) ) \n score = FFMAX ( score , nodat ? AVPROBE_SCORE_EXTENSION / 2 - 1 : 1 ) ; \n } else if ( fmt1 -> extensions ) { \n if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) ) \n score = AVPROBE_SCORE_EXTENSION ; \n } \n if ( score > score_max ) { \n score_max = score ; \n fmt = fmt1 ; \n } else if ( score == score_max ) \n fmt = NULL ; \n } \n if ( nodat ) \n score_max = FFMIN ( AVPROBE_SCORE_EXTENSION / 2 - 1 , score_max ) ; \n * score_ret = score_max ; \n return fmt ; \n }", "idx": 10412}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int index_search_timestamp ( AVIndexEntry * entries , \n int nb_entries , int wanted_timestamp ) \n { \n int a , b , m ; \n int64_t timestamp ; \n if ( nb_entries <= 0 ) \n return -1 ; \n a = 0 ; \n b = nb_entries - 1 ; \n while ( a <= b ) { \n m = ( a + b ) >> 1 ; \n timestamp = entries [ m ] . timestamp ; \n if ( timestamp == wanted_timestamp ) \n goto found ; \n else if ( timestamp > wanted_timestamp ) { \n b = m - 1 ; \n } else { \n a = m + 1 ; \n } \n } \n m = a ; \n if ( m > 0 ) \n m -- ; \n found : \n return m ; \n }", "idx": 10471}
{"project": "FFmpeg", "commit_id": "af2ea724951b4b12b4522b462047eebbf9566b84", "target": 0, "func": "void av_aes_crypt ( AVAES * a , uint8_t * dst_ , const uint8_t * src_ , \n int count , uint8_t * iv_ , int decrypt ) \n { \n av_aes_block * dst = ( av_aes_block * ) dst_ ; \n const av_aes_block * src = ( const av_aes_block * ) src_ ; \n av_aes_block * iv = ( av_aes_block * ) iv_ ; \n while ( count -- ) { \n addkey ( & a -> state [ 1 ] , src , & a -> round_key [ a -> rounds ] ) ; \n if ( decrypt ) { \n crypt ( a , 0 , inv_sbox , dec_multbl ) ; \n if ( iv ) { \n addkey ( & a -> state [ 0 ] , & a -> state [ 0 ] , iv ) ; \n memcpy ( iv , src , 16 ) ; \n } \n addkey ( dst , & a -> state [ 0 ] , & a -> round_key [ 0 ] ) ; \n } else { \n if ( iv ) \n addkey ( & a -> state [ 1 ] , & a -> state [ 1 ] , iv ) ; \n crypt ( a , 2 , sbox , enc_multbl ) ; \n addkey ( dst , & a -> state [ 0 ] , & a -> round_key [ 0 ] ) ; \n if ( iv ) \n memcpy ( iv , dst , 16 ) ; \n } \n src ++ ; \n dst ++ ; \n } \n }", "idx": 10596}
{"project": "FFmpeg", "commit_id": "a09bb3ba5e018b81a659c199a84cd1d80c07d869", "target": 0, "func": "void avcodec_default_release_buffer ( AVCodecContext * s , AVFrame * pic ) { \n int i ; \n InternalBuffer * buf , * last ; \n AVCodecInternal * avci = s -> internal ; \n assert ( s -> codec_type == AVMEDIA_TYPE_VIDEO ) ; \n assert ( pic -> type == FF_BUFFER_TYPE_INTERNAL ) ; \n assert ( avci -> buffer_count ) ; \n if ( avci -> buffer ) { \n buf = NULL ; \n for ( i = 0 ; i < avci -> buffer_count ; i ++ ) { \n buf = & avci -> buffer [ i ] ; \n if ( buf -> data [ 0 ] == pic -> data [ 0 ] ) \n break ; \n } \n assert ( i < avci -> buffer_count ) ; \n avci -> buffer_count -- ; \n last = & avci -> buffer [ avci -> buffer_count ] ; \n FFSWAP ( InternalBuffer , * buf , * last ) ; \n } \n for ( i = 0 ; i < AV_NUM_DATA_POINTERS ; i ++ ) { \n pic -> data [ i ] = NULL ; \n } \n if ( s -> debug & FF_DEBUG_BUFFERS ) \n av_log ( s , AV_LOG_DEBUG , \" \" \n \" \\n \" , pic , avci -> buffer_count ) ; \n }", "idx": 10659}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel16_mc23_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_16w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 16 , 1 ) ; \n }", "idx": 10739}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int init_duplicate_context ( MpegEncContext * s , MpegEncContext * base ) { \n int i ; \n CHECKED_ALLOCZ ( s -> allocated_edge_emu_buffer , ( s -> width + 64 ) * 2 * 21 * 2 ) ; \n s -> edge_emu_buffer = s -> allocated_edge_emu_buffer + ( s -> width + 64 ) * 2 * 21 ; \n CHECKED_ALLOCZ ( s -> me . scratchpad , ( s -> width + 64 ) * 4 * 16 * 2 * sizeof ( uint8_t ) ) \n s -> me . temp = s -> me . scratchpad ; \n s -> rd_scratchpad = s -> me . scratchpad ; \n s -> b_scratchpad = s -> me . scratchpad ; \n s -> obmc_scratchpad = s -> me . scratchpad + 16 ; \n if ( s -> encoding ) { \n CHECKED_ALLOCZ ( s -> me . map , ME_MAP_SIZE * sizeof ( uint32_t ) )  \n CHECKED_ALLOCZ ( s -> me . score_map , ME_MAP_SIZE * sizeof ( uint32_t ) )  \n if ( s -> avctx -> noise_reduction ) { \n CHECKED_ALLOCZ ( s -> dct_error_sum , 2 * 64 * sizeof ( int ) )  \n } \n } \n CHECKED_ALLOCZ ( s -> blocks , 64 * 12 * 2 * sizeof ( DCTELEM ) ) \n s -> block = s -> blocks [ 0 ] ; \n for ( i = 0 ; i < 12 ; i ++ ) { \n s -> pblocks [ i ] = & s -> block [ i ] ; \n } \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 10751}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_4w_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 4 ) ; \n }", "idx": 10762}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "static void add_pixels_clamped_c ( const int16_t * block , uint8_t * av_restrict pixels , \n ptrdiff_t line_size ) \n { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixels [ 0 ] = av_clip_uint8 ( pixels [ 0 ] + block [ 0 ] ) ; \n pixels [ 1 ] = av_clip_uint8 ( pixels [ 1 ] + block [ 1 ] ) ; \n pixels [ 2 ] = av_clip_uint8 ( pixels [ 2 ] + block [ 2 ] ) ; \n pixels [ 3 ] = av_clip_uint8 ( pixels [ 3 ] + block [ 3 ] ) ; \n pixels [ 4 ] = av_clip_uint8 ( pixels [ 4 ] + block [ 4 ] ) ; \n pixels [ 5 ] = av_clip_uint8 ( pixels [ 5 ] + block [ 5 ] ) ; \n pixels [ 6 ] = av_clip_uint8 ( pixels [ 6 ] + block [ 6 ] ) ; \n pixels [ 7 ] = av_clip_uint8 ( pixels [ 7 ] + block [ 7 ] ) ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 10828}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "const char * avio_enum_protocols ( void * * opaque , int output ) \n { \n URLProtocol * p ; \n * opaque = ffurl_protocol_next ( * opaque ) ; \n if ( ! ( p = * opaque ) ) \n return NULL ; \n if ( ( output && p -> url_write ) || ( ! output && p -> url_read ) ) \n return p -> name ; \n return avio_enum_protocols ( opaque , output ) ; \n }", "idx": 10835}
{"project": "FFmpeg", "commit_id": "cadab5a2a74d715fc16325bd89f8b8091def1083", "target": 1, "func": "static int read_highpass ( AVCodecContext * avctx , uint8_t * ptr , int plane , AVFrame * frame ) \n { \n PixletContext * ctx = avctx -> priv_data ; \n ptrdiff_t stride = frame -> linesize [ plane ] / 2 ; \n int i , ret ; \n for ( i = 0 ; i < ctx -> levels * 3 ; i ++ ) { \n int32_t a = bytestream2_get_be32 ( & ctx -> gb ) ; \n int32_t b = bytestream2_get_be32 ( & ctx -> gb ) ; \n int32_t c = bytestream2_get_be32 ( & ctx -> gb ) ; \n int32_t d = bytestream2_get_be32 ( & ctx -> gb ) ; \n int16_t * dest = ( int16_t * ) frame -> data [ plane ] + ctx -> band [ plane ] [ i + 1 ] . x + \n stride * ctx -> band [ plane ] [ i + 1 ] . y ; \n unsigned size = ctx -> band [ plane ] [ i + 1 ] . size ; \n uint32_t magic ; \n magic = bytestream2_get_be32 ( & ctx -> gb ) ; \n if ( magic != 0xDEADBEEF ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" PRIX32 \n \" \\n \" , magic , plane , i ) ; \n } \n ret = read_high_coeffs ( avctx , ptr + bytestream2_tell ( & ctx -> gb ) , dest , size , \n c , ( b >= FFABS ( a ) ) ? b : a , d , \n ctx -> band [ plane ] [ i + 1 ] . width , stride ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , plane , i ) ; \n return ret ; \n } \n bytestream2_skip ( & ctx -> gb , ret ) ; \n } \n return 0 ; \n }", "idx": 10840}
{"project": "FFmpeg", "commit_id": "eba1ff31304e407db3cefd7532108408f364367b", "target": 1, "func": "static int decode_bytes ( const uint8_t * input , uint8_t * out , int bytes ) \n { \n int i , off ; \n uint32_t c ; \n const uint32_t * buf ; \n uint32_t * output = ( uint32_t * ) out ; \n off = ( intptr_t ) input & 3 ; \n buf = ( const uint32_t * ) ( input - off ) ; \n c = av_be2ne32 ( ( 0x537F6103 >> ( off * 8 ) ) | ( 0x537F6103 << ( 32 - ( off * 8 ) ) ) ) ; \n bytes += 3 + off ; \n for ( i = 0 ; i < bytes / 4 ; i ++ ) \n output [ i ] = c ^ buf [ i ] ; \n if ( off ) \n avpriv_request_sample ( NULL , \" \" , off ) ; \n return off ; \n }", "idx": 10862}
{"project": "FFmpeg", "commit_id": "dc6b99d6b20e832a7d353474c2d093f8b2fb17d2", "target": 0, "func": "static int mov_write_ms_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wl32 ( pb , track -> tag ) ; \n track -> enc -> codec_tag = av_bswap16 ( track -> tag >> 16 ) ; \n ff_put_wav_header ( pb , track -> enc , 0 ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 11019}
{"project": "FFmpeg", "commit_id": "d1f558b3628d3ab99fd93a98b5758ef1be45a5da", "target": 0, "func": "static int copy_to_pbr ( DCAXllDecoder * s , uint8_t * data , int size , int delay ) \n { \n if ( size > DCA_XLL_PBR_BUFFER_MAX ) \n return AVERROR ( ENOSPC ) ; \n if ( ! s -> pbr_buffer && ! ( s -> pbr_buffer = av_malloc ( DCA_XLL_PBR_BUFFER_MAX + DCA_BUFFER_PADDING_SIZE ) ) ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( s -> pbr_buffer , data , size ) ; \n s -> pbr_length = size ; \n s -> pbr_delay = delay ; \n return 0 ; \n }", "idx": 11023}
{"project": "FFmpeg", "commit_id": "89523beea45e265d985aace8be79b45e94f21e6b", "target": 0, "func": "static void sigill_handler ( int sig ) \n { \n if ( ! canjump ) { \n signal ( sig , SIG_DFL ) ; \n raise ( sig ) ; \n } \n canjump = 0 ; \n siglongjmp ( jmpbuf , 1 ) ; \n }", "idx": 11027}
{"project": "FFmpeg", "commit_id": "c33030bd7b81f7ef7d7ff9da9bfa1a3b4bfbafa1", "target": 0, "func": "static int gif_encode_frame ( AVCodecContext * avctx , unsigned char * outbuf , int buf_size , void * data ) \n { \n GIFContext * s = avctx -> priv_data ; \n AVFrame * pict = data ; \n AVFrame * const p = ( AVFrame * ) & s -> picture ; \n uint8_t * outbuf_ptr = outbuf ; \n * p = * pict ; \n p -> pict_type = FF_I_TYPE ; \n p -> key_frame = 1 ; \n gif_image_write_header ( & outbuf_ptr , avctx -> width , avctx -> height , -1 , ( uint32_t * ) pict -> data [ 1 ] ) ; \n gif_image_write_image ( & outbuf_ptr , 0 , 0 , avctx -> width , avctx -> height , pict -> data [ 0 ] , pict -> linesize [ 0 ] , PIX_FMT_PAL8 ) ; \n return outbuf_ptr - outbuf ; \n }", "idx": 11151}
{"project": "FFmpeg", "commit_id": "b76d853697a8b558e597ed4a6fc5a088b6c602c7", "target": 0, "func": "av_cold int avcodec_close ( AVCodecContext * avctx ) \n { \n int ret = ff_lock_avcodec ( avctx ) ; \n if ( ret < 0 ) \n return ret ; \n if ( avcodec_is_open ( avctx ) ) { \n FramePool * pool = avctx -> internal -> pool ; \n int i ; \n if ( HAVE_THREADS && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1 ) { \n ff_unlock_avcodec ( ) ; \n ff_frame_thread_encoder_free ( avctx ) ; \n ff_lock_avcodec ( avctx ) ; \n } \n if ( HAVE_THREADS && avctx -> thread_opaque ) \n ff_thread_free ( avctx ) ; \n if ( avctx -> codec && avctx -> codec -> close ) \n avctx -> codec -> close ( avctx ) ; \n avctx -> coded_frame = NULL ; \n avctx -> internal -> byte_buffer_size = 0 ; \n av_freep ( & avctx -> internal -> byte_buffer ) ; \n if ( ! avctx -> refcounted_frames ) \n av_frame_unref ( & avctx -> internal -> to_free ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( pool -> pools ) ; i ++ ) \n av_buffer_pool_uninit ( & pool -> pools [ i ] ) ; \n av_freep ( & avctx -> internal -> pool ) ; \n av_freep ( & avctx -> internal ) ; \n } \n if ( avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class ) \n av_opt_free ( avctx -> priv_data ) ; \n av_opt_free ( avctx ) ; \n av_freep ( & avctx -> priv_data ) ; \n if ( av_codec_is_encoder ( avctx -> codec ) ) \n av_freep ( & avctx -> extradata ) ; \n avctx -> codec = NULL ; \n avctx -> active_thread_type = 0 ; \n ff_unlock_avcodec ( ) ; \n return 0 ; \n }", "idx": 11158}
{"project": "FFmpeg", "commit_id": "4a722a5cab15d5aefbf4dd83baa8be5a046580ca", "target": 1, "func": "static int common_end ( HYuvContext * s ) \n { \n int i ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n av_freep ( & s -> temp [ i ] ) ; \n } \n return 0 ; \n }", "idx": 11248}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline int dv_rl2vlc ( int run , int l , uint32_t * vlc ) \n { \n * vlc = dv_vlc_map [ run ] [ ( ( uint16_t ) l ) & 0x1ff ] . vlc ; \n return dv_vlc_map [ run ] [ ( ( uint16_t ) l ) & 0x1ff ] . size ; \n }", "idx": 11261}
{"project": "FFmpeg", "commit_id": "295a7c0238e84b0ffa8f21ed938d45f51f54a4cd", "target": 1, "func": "static int decode_i2_frame ( FourXContext * f , const uint8_t * buf , int length ) { \n int x , y , x2 , y2 ; \n const int width = f -> avctx -> width ; \n const int height = f -> avctx -> height ; \n uint16_t * dst = ( uint16_t * ) f -> current_picture . data [ 0 ] ; \n const int stride = f -> current_picture . linesize [ 0 ] >> 1 ; \n for ( y = 0 ; y < height ; y += 16 ) { \n for ( x = 0 ; x < width ; x += 16 ) { \n unsigned int color [ 4 ] , bits ; \n memset ( color , 0 , sizeof ( color ) ) ; \n color [ 0 ] = bytestream_get_le16 ( & buf ) ; \n color [ 1 ] = bytestream_get_le16 ( & buf ) ; \n if ( color [ 0 ] & 0x8000 ) av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n if ( color [ 1 ] & 0x8000 ) av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n color [ 2 ] = mix ( color [ 0 ] , color [ 1 ] ) ; \n color [ 3 ] = mix ( color [ 1 ] , color [ 0 ] ) ; \n bits = bytestream_get_le32 ( & buf ) ; \n for ( y2 = 0 ; y2 < 16 ; y2 ++ ) { \n for ( x2 = 0 ; x2 < 16 ; x2 ++ ) { \n int index = 2 * ( x2 >> 2 ) + 8 * ( y2 >> 2 ) ; \n dst [ y2 * stride + x2 ] = color [ ( bits >> index ) & 3 ] ; \n } \n } \n dst += 16 ; \n } \n dst += 16 * stride - x ; \n } \n return 0 ; \n }", "idx": 11293}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int apc_read_header ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AVStream * st ; \n avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codecpar -> codec_id = AV_CODEC_ID_ADPCM_IMA_APC ; \n avio_rl32 ( pb ) ; \n st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; \n if ( ff_get_extradata ( s , st -> codecpar , pb , 2 * 4 ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n if ( avio_rl32 ( pb ) ) { \n st -> codecpar -> channels = 2 ; \n st -> codecpar -> channel_layout = AV_CH_LAYOUT_STEREO ; \n } else { \n st -> codecpar -> channels = 1 ; \n st -> codecpar -> channel_layout = AV_CH_LAYOUT_MONO ; \n } \n st -> codecpar -> bits_per_coded_sample = 4 ; \n st -> codecpar -> bit_rate = st -> codecpar -> bits_per_coded_sample * st -> codecpar -> channels \n * st -> codecpar -> sample_rate ; \n st -> codecpar -> block_align = 1 ; \n return 0 ; \n }", "idx": 11295}
{"project": "FFmpeg", "commit_id": "486f0b0cfc800cd38ec06635630539431d296774", "target": 1, "func": "void * ff_png_zalloc ( void * opaque , unsigned int items , unsigned int size ) \n { \n if ( items >= UINT_MAX / size ) \n return NULL ; \n return av_malloc ( items * size ) ; \n }", "idx": 11326}
{"project": "FFmpeg", "commit_id": "cd823ff950cf81d54965eceedb64569fee79ab36", "target": 0, "func": "static int alloc_frame_buffer ( MpegEncContext * s , Picture * pic ) \n { \n int r ; \n if ( s -> avctx -> hwaccel ) { \n assert ( ! pic -> hwaccel_data_private ) ; \n if ( s -> avctx -> hwaccel -> priv_data_size ) { \n pic -> hwaccel_data_private = av_malloc ( s -> avctx -> hwaccel -> priv_data_size ) ; \n if ( ! pic -> hwaccel_data_private ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n } \n } \n r = s -> avctx -> get_buffer ( s -> avctx , ( AVFrame * ) pic ) ; \n if ( r < 0 || ! pic -> age || ! pic -> type || ! pic -> data [ 0 ] ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , r , pic -> age , pic -> type , pic -> data [ 0 ] ) ; \n av_freep ( & pic -> hwaccel_data_private ) ; \n return -1 ; \n } \n if ( s -> linesize && ( s -> linesize != pic -> linesize [ 0 ] || s -> uvlinesize != pic -> linesize [ 1 ] ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n free_frame_buffer ( s , pic ) ; \n return -1 ; \n } \n if ( pic -> linesize [ 1 ] != pic -> linesize [ 2 ] ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n free_frame_buffer ( s , pic ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 11446}
{"project": "FFmpeg", "commit_id": "33dc1913ab7aaefc991b3e665d1d0b5d0b088672", "target": 1, "func": "static void reset_packet_state ( AVFormatContext * s ) \n { \n ASFContext * asf = s -> priv_data ; \n int i ; \n asf -> state = PARSE_PACKET_HEADER ; \n asf -> offset = 0 ; \n asf -> return_subpayload = 0 ; \n asf -> sub_left = 0 ; \n asf -> sub_header_offset = 0 ; \n asf -> packet_offset = asf -> first_packet_offset ; \n asf -> pad_len = 0 ; \n asf -> rep_data_len = 0 ; \n asf -> dts_delta = 0 ; \n asf -> mult_sub_len = 0 ; \n asf -> nb_mult_left = 0 ; \n asf -> nb_sub = 0 ; \n asf -> prop_flags = 0 ; \n asf -> sub_dts = 0 ; \n asf -> dts = 0 ; \n for ( i = 0 ; i < asf -> nb_streams ; i ++ ) { \n ASFPacket * pkt = & asf -> asf_st [ i ] -> pkt ; \n pkt -> size_left = 0 ; \n pkt -> data_size = 0 ; \n pkt -> duration = 0 ; \n pkt -> flags = 0 ; \n pkt -> dts = 0 ; \n pkt -> duration = 0 ; \n av_free_packet ( & pkt -> avpkt ) ; \n av_init_packet ( & pkt -> avpkt ) ; \n } \n }", "idx": 11451}
{"project": "FFmpeg", "commit_id": "0314dead4e7c058568e792842405190c06d71da5", "target": 1, "func": "AVEvalExpr * ff_parse ( const char * s , const char * const * const_name , \n double ( * * func1 ) ( void * , double ) , const char * * func1_name , \n double ( * * func2 ) ( void * , double , double ) , const char * * func2_name , \n const char * * error ) { \n Parser p ; \n AVEvalExpr * e ; \n char w [ strlen ( s ) + 1 ] , * wp = w ; \n while ( * s ) \n if ( ! isspace ( * s ++ ) ) * wp ++ = s [ -1 ] ; \n * wp ++ = 0 ; \n p . stack_index = 100 ; \n p . s = w ; \n p . const_name = const_name ; \n p . func1 = func1 ; \n p . func1_name = func1_name ; \n p . func2 = func2 ; \n p . func2_name = func2_name ; \n p . error = error ; \n e = parse_expr ( & p ) ; \n if ( ! verify_expr ( e ) ) { \n ff_eval_free ( e ) ; \n return NULL ; \n } \n return e ; \n }", "idx": 11492}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void read_packets ( WriterContext * w , AVFormatContext * fmt_ctx ) \n { \n int i , ret = 0 ; \n int64_t cur_ts = fmt_ctx -> start_time ; \n if ( read_intervals_nb == 0 ) { \n ReadInterval interval = ( ReadInterval ) { . has_start = 0 , . has_end = 0 } ; \n ret = read_interval_packets ( w , fmt_ctx , & interval , & cur_ts ) ; \n } else { \n for ( i = 0 ; i < read_intervals_nb ; i ++ ) { \n ret = read_interval_packets ( w , fmt_ctx , & read_intervals [ i ] , & cur_ts ) ; \n if ( ret < 0 ) \n break ; \n } \n } \n }", "idx": 11528}
{"project": "FFmpeg", "commit_id": "e021eeb9f06f4f4d83690d07b47cdcc4172a61e1", "target": 0, "func": "int av_opt_set_from_string ( void * ctx , const char * opts , \n const char * const * shorthand , \n const char * key_val_sep , const char * pairs_sep ) \n { \n int ret , count = 0 ; \n const char * dummy_shorthand = NULL ; \n char key_buf [ 68 ] , * value ; \n const char * key ; \n if ( ! opts ) \n return 0 ; \n if ( ! shorthand ) \n shorthand = & dummy_shorthand ; \n while ( * opts ) { \n if ( ( ret = get_key ( & opts , key_val_sep , key_buf , sizeof ( key_buf ) ) ) < 0 ) { \n if ( * shorthand ) { \n key = * ( shorthand ++ ) ; \n } else { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , opts ) ; \n return AVERROR ( EINVAL ) ; \n } \n } else { \n key = key_buf ; \n while ( * shorthand ) \n shorthand ++ ; \n } \n if ( ! ( value = av_get_token ( & opts , pairs_sep ) ) ) \n return AVERROR ( ENOMEM ) ; \n if ( * opts && strchr ( pairs_sep , * opts ) ) \n opts ++ ; \n av_log ( ctx , AV_LOG_DEBUG , \" \\n \" , key , value ) ; \n if ( ( ret = av_opt_set ( ctx , key , value , 0 ) ) < 0 ) { \n if ( ret == AVERROR_OPTION_NOT_FOUND ) \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , key ) ; \n av_free ( value ) ; \n return ret ; \n } \n av_free ( value ) ; \n count ++ ; \n } \n return count ; \n }", "idx": 11570}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int targa_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n return 0 ; \n }", "idx": 11688}
{"project": "FFmpeg", "commit_id": "3e56db892600c2fbe34782c6140f1ee832a2c344", "target": 1, "func": "static int y216_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame , AVPacket * avpkt ) \n { \n AVFrame * pic = data ; \n const uint16_t * src = ( uint16_t * ) avpkt -> data ; \n uint16_t * y , * u , * v , aligned_width = FFALIGN ( avctx -> width , 4 ) ; \n int i , j , ret ; \n if ( avpkt -> size < 4 * avctx -> height * aligned_width ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n pic -> key_frame = 1 ; \n pic -> pict_type = AV_PICTURE_TYPE_I ; \n y = ( uint16_t * ) pic -> data [ 0 ] ; \n u = ( uint16_t * ) pic -> data [ 1 ] ; \n v = ( uint16_t * ) pic -> data [ 2 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n for ( j = 0 ; j < avctx -> width >> 1 ; j ++ ) { \n u [ j ] = src [ 4 * j ] << 2 | src [ 4 * j ] >> 14 ; \n y [ 2 * j ] = src [ 4 * j + 1 ] << 2 | src [ 4 * j + 1 ] >> 14 ; \n v [ j ] = src [ 4 * j + 2 ] << 2 | src [ 4 * j + 2 ] >> 14 ; \n y [ 2 * j + 1 ] = src [ 4 * j + 3 ] << 2 | src [ 4 * j + 3 ] >> 14 ; \n } \n y += pic -> linesize [ 0 ] >> 1 ; \n u += pic -> linesize [ 1 ] >> 1 ; \n v += pic -> linesize [ 2 ] >> 1 ; \n src += aligned_width << 1 ; \n } \n * got_frame = 1 ; \n return avpkt -> size ; \n }", "idx": 11723}
{"project": "FFmpeg", "commit_id": "a930cd0d195ea1c33b6b97b3f3f60703f899e739", "target": 0, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint32_t pos , taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n pos += 44 + taglen ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 11825}
{"project": "FFmpeg", "commit_id": "e48ded8551172b58a78f30303a81dfce125344e0", "target": 0, "func": "static av_cold int asink_init ( AVFilterContext * ctx , void * opaque ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVABufferSinkParams * params = opaque ; \n if ( params && params -> sample_fmts ) { \n buf -> sample_fmts = ff_copy_int_list ( params -> sample_fmts ) ; \n if ( ! buf -> sample_fmts ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( params && params -> sample_rates ) { \n buf -> sample_rates = ff_copy_int_list ( params -> sample_rates ) ; \n if ( ! buf -> sample_rates ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( params && ( params -> channel_layouts || params -> channel_counts ) ) { \n if ( params -> all_channel_counts ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n buf -> channel_layouts = concat_channels_lists ( params -> channel_layouts , \n params -> channel_counts ) ; \n if ( ! buf -> channel_layouts ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( params ) \n buf -> all_channel_counts = params -> all_channel_counts ; \n return common_init ( ctx ) ; \n }", "idx": 11895}
{"project": "FFmpeg", "commit_id": "9a2e79116d6235c53d8e9663a8d30d1950d7431a", "target": 1, "func": "static int rv30_decode_intra_types ( RV34DecContext * r , GetBitContext * gb , int8_t * dst ) \n { \n int i , j , k ; \n for ( i = 0 ; i < 4 ; i ++ , dst += r -> intra_types_stride - 4 ) { \n for ( j = 0 ; j < 4 ; j += 2 ) { \n int code = svq3_get_ue_golomb ( gb ) << 1 ; \n if ( code >= 81 * 2 ) { \n av_log ( r -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( k = 0 ; k < 2 ; k ++ ) { \n int A = dst [ - r -> intra_types_stride ] + 1 ; \n int B = dst [ -1 ] + 1 ; \n * dst ++ = rv30_itype_from_context [ A * 90 + B * 9 + rv30_itype_code [ code + k ] ] ; \n if ( dst [ -1 ] == 9 ) { \n av_log ( r -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n } \n } \n } \n return 0 ; \n }", "idx": 11927}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "matroska_probe ( AVProbeData * p )  \n { \n uint64_t total = 0 ; \n int len_mask = 0x80 , size = 1 , n = 1 ; \n uint8_t probe_data [ ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' } ; \n if ( p -> buf_size < 5 ) \n return 0 ; \n if ( ( p -> buf [ 0 ] << 24 | p -> buf [ 1 ] << 16 | \n p -> buf [ 2 ] << 8 | p -> buf [ 3 ] ) != EBML_ID_HEADER ) \n return 0 ; \n total = p -> buf [ 4 ] ; \n while ( size <= 8 && ! ( total & len_mask ) ) { \n size ++ ; \n len_mask >>= 1 ; \n } \n if ( size > 8 ) \n return 0 ; \n total &= ( len_mask - 1 ) ; \n while ( n < size ) \n total = ( total << 8 ) | p -> buf [ 4 + n ++ ] ; \n if ( p -> buf_size < 4 + size + total ) \n return 0 ; \n for ( n = 4 + size ; n <= 4 + size + total - sizeof ( probe_data ) ; n ++ ) \n if ( ! memcmp ( & p -> buf [ n ] , probe_data , sizeof ( probe_data ) ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 12056}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void dequantization_float ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j , idx ; \n float * datap = & comp -> data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * y + x ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) \n for ( i = 0 ; i < ( cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ) ; ++ i ) { \n idx = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * j + i ; \n datap [ idx ] = ( float ) ( t1 -> data [ j ] [ i ] ) * band -> f_stepsize ; \n } \n }", "idx": 12082}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_vert_8x8_msa ( uint8_t * src , uint8_t * dst , \n int32_t dst_stride ) \n { \n uint32_t row ; \n uint32_t src_data1 , src_data2 ; \n src_data1 = LW ( src ) ; \n src_data2 = LW ( src + 4 ) ; \n for ( row = 8 ; row -- ; ) { \n SW ( src_data1 , dst ) ; \n SW ( src_data2 , ( dst + 4 ) ) ; \n dst += dst_stride ; \n } \n }", "idx": 12101}
{"project": "FFmpeg", "commit_id": "88db5551cf1ced4ea3e5e8bd5b684d2dc74b1ed2", "target": 0, "func": "static inline void check_for_slice ( AVSContext * h ) { \n GetBitContext * gb = & h -> s . gb ; \n int align ; \n if ( h -> mbx ) \n return ; \n align = ( - get_bits_count ( gb ) ) & 7 ; \n if ( ( show_bits_long ( gb , 24 + align ) & 0xFFFFFF ) == 0x000001 ) { \n skip_bits_long ( gb , 24 + align ) ; \n h -> stc = get_bits ( gb , 8 ) ; \n decode_slice_header ( h , gb ) ; \n } \n }", "idx": 12419}
{"project": "FFmpeg", "commit_id": "41fe750f4b130f08f41ce0e5126046315c891cae", "target": 1, "func": "void av_bitstream_filter_close ( AVBitStreamFilterContext * bsfc ) { \n if ( bsfc -> filter -> close ) \n bsfc -> filter -> close ( bsfc ) ; \n av_freep ( & bsfc -> priv_data ) ; \n av_parser_close ( bsfc -> parser ) ; \n av_free ( bsfc ) ; \n }", "idx": 12518}
{"project": "FFmpeg", "commit_id": "ae413a48e64274b9740c3b27398fea92108a0f0e", "target": 1, "func": "static void mov_text_cleanup_ftab ( MovTextContext * m ) \n { \n int i ; \n for ( i = 0 ; i < m -> count_f ; i ++ ) { \n av_freep ( & m -> ftab [ i ] -> font ) ; \n av_freep ( & m -> ftab [ i ] ) ; \n } \n av_freep ( & m -> ftab ) ; \n }", "idx": 12520}
{"project": "FFmpeg", "commit_id": "7b6883898ff9000b9a9e71fc1fb6e842ec850a79", "target": 0, "func": "static void frame_thread_free ( AVCodecContext * avctx , int thread_count ) \n { \n FrameThreadContext * fctx = avctx -> thread_opaque ; \n AVCodec * codec = avctx -> codec ; \n int i ; \n park_frame_worker_threads ( fctx , thread_count ) ; \n if ( fctx -> prev_thread ) \n update_context_from_thread ( fctx -> threads -> avctx , fctx -> prev_thread -> avctx , 0 ) ; \n fctx -> die = 1 ; \n for ( i = 0 ; i < thread_count ; i ++ ) { \n PerThreadContext * p = & fctx -> threads [ i ] ; \n pthread_mutex_lock ( & p -> mutex ) ; \n pthread_cond_signal ( & p -> input_cond ) ; \n pthread_mutex_unlock ( & p -> mutex ) ; \n pthread_join ( p -> thread , NULL ) ; \n if ( codec -> close ) \n codec -> close ( p -> avctx ) ; \n avctx -> codec = NULL ; \n release_delayed_buffers ( p ) ; \n } \n for ( i = 0 ; i < thread_count ; i ++ ) { \n PerThreadContext * p = & fctx -> threads [ i ] ; \n avcodec_default_free_buffers ( p -> avctx ) ; \n pthread_mutex_destroy ( & p -> mutex ) ; \n pthread_mutex_destroy ( & p -> progress_mutex ) ; \n pthread_cond_destroy ( & p -> input_cond ) ; \n pthread_cond_destroy ( & p -> progress_cond ) ; \n pthread_cond_destroy ( & p -> output_cond ) ; \n av_freep ( & p -> avpkt . data ) ; \n if ( i ) \n av_freep ( & p -> avctx -> priv_data ) ; \n av_freep ( & p -> avctx ) ; \n } \n av_freep ( & fctx -> threads ) ; \n pthread_mutex_destroy ( & fctx -> buffer_mutex ) ; \n av_freep ( & avctx -> thread_opaque ) ; \n }", "idx": 12680}
{"project": "FFmpeg", "commit_id": "041086191fc08ab162ad6117b07a5f39639d5d9d", "target": 0, "func": "static double get_video_clock ( VideoState * is ) \n { \n double delta ; \n if ( is -> paused ) { \n delta = 0 ; \n } else { \n delta = ( av_gettime ( ) - is -> video_current_pts_time ) / 1000000.0 ; \n } \n return is -> video_current_pts + delta ; \n }", "idx": 12921}
{"project": "FFmpeg", "commit_id": "d8870f120ea5f46940bac63a90424ca6a6000ad9", "target": 0, "func": "static void set_downmix_coeffs ( AC3DecodeContext * s ) \n { \n int i ; \n float cmix = gain_levels [ s -> center_mix_level ] ; \n float smix = gain_levels [ s -> surround_mix_level ] ; \n for ( i = 0 ; i < s -> fbw_channels ; i ++ ) { \n s -> downmix_coeffs [ i ] [ 0 ] = gain_levels [ ac3_default_coeffs [ s -> channel_mode ] [ i ] [ 0 ] ] ; \n s -> downmix_coeffs [ i ] [ 1 ] = gain_levels [ ac3_default_coeffs [ s -> channel_mode ] [ i ] [ 1 ] ] ; \n } \n if ( s -> channel_mode > 1 && s -> channel_mode & 1 ) { \n s -> downmix_coeffs [ 1 ] [ 0 ] = s -> downmix_coeffs [ 1 ] [ 1 ] = cmix ; \n } \n if ( s -> channel_mode == AC3_CHMODE_2F1R || s -> channel_mode == AC3_CHMODE_3F1R ) { \n int nf = s -> channel_mode - 2 ; \n s -> downmix_coeffs [ nf ] [ 0 ] = s -> downmix_coeffs [ nf ] [ 1 ] = smix * LEVEL_MINUS_3DB ; \n } \n if ( s -> channel_mode == AC3_CHMODE_2F2R || s -> channel_mode == AC3_CHMODE_3F2R ) { \n int nf = s -> channel_mode - 4 ; \n s -> downmix_coeffs [ nf ] [ 0 ] = s -> downmix_coeffs [ nf + 1 ] [ 1 ] = smix ; \n } \n s -> downmix_coeff_sum [ 0 ] = s -> downmix_coeff_sum [ 1 ] = 0.0f ; \n for ( i = 0 ; i < s -> fbw_channels ; i ++ ) { \n s -> downmix_coeff_sum [ 0 ] += s -> downmix_coeffs [ i ] [ 0 ] ; \n s -> downmix_coeff_sum [ 1 ] += s -> downmix_coeffs [ i ] [ 1 ] ; \n } \n }", "idx": 12936}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static av_cold int cinepak_encode_end ( AVCodecContext * avctx ) \n { \n CinepakEncContext * s = avctx -> priv_data ; \n int x ; \n av_free ( s -> codebook_input ) ; \n av_free ( s -> codebook_closest ) ; \n av_free ( s -> strip_buf ) ; \n av_free ( s -> frame_buf ) ; \n av_free ( s -> mb ) ; \n #ifdef CINEPAKENC_DEBUG \n av_free ( s -> best_mb ) ; \n #endif \n for ( x = 0 ; x < 3 ; x ++ ) \n av_free ( s -> pict_bufs [ x ] ) ; \n av_log ( avctx , AV_LOG_INFO , \" \\n \" , \n s -> num_v1_mode , s -> num_v4_mode , s -> num_mc_mode , s -> num_v1_encs , s -> num_v4_encs , s -> num_skips ) ; \n return 0 ; \n }", "idx": 13039}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( lumRangeFromJpeg ) ( int16_t * dst , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = ( dst [ i ] * 14071 + 33561947 ) >> 14 ; \n }", "idx": 13083}
{"project": "FFmpeg", "commit_id": "96d0494123a05fb78a0fd3f03b0b5aaefc170b1c", "target": 0, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , int width , \n int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n } \n } \n return src - start ; \n }", "idx": 13110}
{"project": "FFmpeg", "commit_id": "f3296b945464b41aa067949b24dfcfeb0db9d875", "target": 1, "func": "static int get_avc_nalsize ( H264Context * h , const uint8_t * buf , \n int buf_size , int * buf_index ) \n { \n int i , nalsize = 0 ; \n if ( * buf_index >= buf_size - h -> nal_length_size ) \n return -1 ; \n for ( i = 0 ; i < h -> nal_length_size ; i ++ ) \n nalsize = ( nalsize << 8 ) | buf [ ( * buf_index ) ++ ] ; \n if ( nalsize <= 0 || nalsize > buf_size - * buf_index ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , nalsize ) ; \n return -1 ; \n } \n return nalsize ; \n }", "idx": 13213}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr32 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 3 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 2 ] ; \n #else \n dst [ 0 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 2 ] ; \n #endif \n dst += 4 ; \n } \n }", "idx": 13225}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_intra_pred4x4_mode_emuedge ( int mode , int mb_x , int mb_y , int * copy_buf ) \n { \n switch ( mode ) { \n case VERT_PRED : \n if ( ! mb_x && mb_y ) { \n * copy_buf = 1 ; \n return mode ; \n } \n case DIAG_DOWN_LEFT_PRED : \n case VERT_LEFT_PRED : \n return ! mb_y ? DC_127_PRED : mode ; \n case HOR_PRED : \n if ( ! mb_y ) { \n * copy_buf = 1 ; \n return mode ; \n } \n case HOR_UP_PRED : \n return ! mb_x ? DC_129_PRED : mode ; \n case TM_VP8_PRED : \n return check_tm_pred4x4_mode ( mode , mb_x , mb_y ) ; \n case DC_PRED : \n case DIAG_DOWN_RIGHT_PRED : \n case VERT_RIGHT_PRED : \n case HOR_DOWN_PRED : \n if ( ! mb_y || ! mb_x ) \n * copy_buf = 1 ; \n return mode ; \n } \n return mode ; \n }", "idx": 13278}
{"project": "FFmpeg", "commit_id": "6fdbaa2b7fb56623ab2163f861952bc1408c39b3", "target": 1, "func": "void clamp_mv ( VP8Context * s , VP56mv * dst , const VP56mv * src ) \n { \n dst -> x = av_clip ( src -> x , s -> mv_min . x , s -> mv_max . x ) ; \n dst -> y = av_clip ( src -> y , s -> mv_min . y , s -> mv_max . y ) ; \n }", "idx": 13307}
{"project": "FFmpeg", "commit_id": "e9af732a1a4c28f81959f19d434c9be609cff22a", "target": 1, "func": "AVFilterBufferRef * avfilter_default_get_audio_buffer ( AVFilterLink * link , int perms , \n int nb_samples ) \n { \n AVFilterBufferRef * samplesref = NULL ; \n int linesize [ 8 ] ; \n uint8_t * data [ 8 ] ; \n int nb_channels = av_get_channel_layout_nb_channels ( link -> channel_layout ) ; \n if ( av_samples_alloc ( data , linesize , \n nb_channels , nb_samples , link -> format , \n 16 ) < 0 ) \n return NULL ; \n samplesref = \n avfilter_get_audio_buffer_ref_from_arrays ( data , linesize , perms , \n nb_samples , link -> format , \n link -> channel_layout , link -> planar ) ; \n if ( ! samplesref ) { \n av_free ( data [ 0 ] ) ; \n return NULL ; \n } \n return samplesref ; \n }", "idx": 13334}
{"project": "FFmpeg", "commit_id": "657875b145c788d29b8e3bf38f79264e657932ae", "target": 0, "func": "static int aic_decode_coeffs ( GetBitContext * gb , int16_t * dst , \n int band , int slice_width ) \n { \n int has_skips , coeff_type , coeff_bits , skip_type , skip_bits ; \n const int num_coeffs = aic_num_band_coeffs [ band ] ; \n const uint8_t * scan = aic_scan [ band ] ; \n int mb , idx , val ; \n has_skips = get_bits1 ( gb ) ; \n coeff_type = get_bits1 ( gb ) ; \n coeff_bits = get_bits ( gb , 3 ) ; \n if ( has_skips ) { \n skip_type = get_bits1 ( gb ) ; \n skip_bits = get_bits ( gb , 3 ) ; \n for ( mb = 0 ; mb < slice_width ; mb ++ ) { \n idx = -1 ; \n do { \n GET_CODE ( val , skip_type , skip_bits ) ; \n idx += val + 1 ; \n if ( idx >= num_coeffs ) \n break ; \n GET_CODE ( val , coeff_type , coeff_bits ) ; \n val ++ ; \n if ( val >= 0x10000 ) \n return AVERROR_INVALIDDATA ; \n dst [ scan [ idx ] ] = val ; \n } while ( idx < num_coeffs - 1 ) ; \n dst += num_coeffs ; \n } \n } else { \n for ( mb = 0 ; mb < slice_width ; mb ++ ) { \n for ( idx = 0 ; idx < num_coeffs ; idx ++ ) { \n GET_CODE ( val , coeff_type , coeff_bits ) ; \n if ( val >= 0x10000 ) \n return AVERROR_INVALIDDATA ; \n dst [ scan [ idx ] ] = val ; \n } \n dst += num_coeffs ; \n } \n } \n return 0 ; \n }", "idx": 13361}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int sdp_probe ( AVProbeData * p1 ) \n { \n const char * p = p1 -> buf , * p_end = p1 -> buf + p1 -> buf_size ; \n while ( p < p_end && * p != ' \\0 ' ) { \n if ( p + sizeof ( \" \" ) - 1 < p_end && av_strstart ( p , \" \" , NULL ) ) \n return AVPROBE_SCORE_MAX / 2 ; \n while ( p < p_end - 1 && * p != ' \\n ' ) p ++ ; \n if ( ++ p >= p_end ) \n break ; \n if ( * p == ' \\r ' ) \n p ++ ; \n } \n return 0 ; \n }", "idx": 13372}
{"project": "FFmpeg", "commit_id": "0c46e958d1fd3817b8e9fa048d0450d509c80378", "target": 1, "func": "static int mxf_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n KLVPacket klv ; \n while ( ! s -> pb -> eof_reached ) { \n if ( klv_read_packet ( & klv , s -> pb ) < 0 ) \n return -1 ; \n PRINT_KEY ( s , \" \" , klv . key ) ; \n av_dlog ( s , \" \" PRIu64 \" \" PRIx64 \" \\n \" , klv . length , klv . offset ) ; \n if ( IS_KLV_KEY ( klv . key , mxf_encrypted_triplet_key ) ) { \n int res = mxf_decrypt_triplet ( s , pkt , & klv ) ; \n if ( res < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n } \n if ( IS_KLV_KEY ( klv . key , mxf_essence_element_key ) ) { \n int index = mxf_get_stream_index ( s , & klv ) ; \n if ( index < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , AV_RB32 ( klv . key + 12 ) ) ; \n goto skip ; \n } \n if ( s -> streams [ index ] -> discard == AVDISCARD_ALL ) \n goto skip ; \n if ( klv . key [ 12 ] == 0x06 && klv . key [ 13 ] == 0x01 && klv . key [ 14 ] == 0x10 ) { \n if ( mxf_get_d10_aes3_packet ( s -> pb , s -> streams [ index ] , pkt , klv . length ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n } else \n av_get_packet ( s -> pb , pkt , klv . length ) ; \n pkt -> stream_index = index ; \n pkt -> pos = klv . offset ; \n return 0 ; \n } else \n skip : \n avio_skip ( s -> pb , klv . length ) ; \n } \n return AVERROR_EOF ; \n }", "idx": 13457}
{"project": "FFmpeg", "commit_id": "6d556e8327f6275c807c6da7257f617c256fe759", "target": 1, "func": "void ff_ivi_recompose_haar ( const IVIPlaneDesc * plane , uint8_t * dst , \n const int dst_pitch , const int num_bands ) \n { \n int x , y , indx , b0 , b1 , b2 , b3 , p0 , p1 , p2 , p3 ; \n const IDWTELEM * b0_ptr , * b1_ptr , * b2_ptr , * b3_ptr ; \n int32_t pitch ; \n pitch = plane -> bands [ 0 ] . pitch ; \n b0_ptr = plane -> bands [ 0 ] . buf ; \n b1_ptr = plane -> bands [ 1 ] . buf ; \n b2_ptr = plane -> bands [ 2 ] . buf ; \n b3_ptr = plane -> bands [ 3 ] . buf ; \n for ( y = 0 ; y < plane -> height ; y += 2 ) { \n for ( x = 0 , indx = 0 ; x < plane -> width ; x += 2 , indx ++ ) { \n b0 = b0_ptr [ indx ] ; \n b1 = b1_ptr [ indx ] ; \n b2 = b2_ptr [ indx ] ; \n b3 = b3_ptr [ indx ] ; \n p0 = ( b0 + b1 + b2 + b3 + 2 ) >> 2 ; \n p1 = ( b0 + b1 - b2 - b3 + 2 ) >> 2 ; \n p2 = ( b0 - b1 + b2 - b3 + 2 ) >> 2 ; \n p3 = ( b0 - b1 - b2 + b3 + 2 ) >> 2 ; \n dst [ x ] = av_clip_uint8 ( p0 + 128 ) ; \n dst [ x + 1 ] = av_clip_uint8 ( p1 + 128 ) ; \n dst [ dst_pitch + x ] = av_clip_uint8 ( p2 + 128 ) ; \n dst [ dst_pitch + x + 1 ] = av_clip_uint8 ( p3 + 128 ) ; \n } \n dst += dst_pitch << 1 ; \n b0_ptr += pitch ; \n b1_ptr += pitch ; \n b2_ptr += pitch ; \n b3_ptr += pitch ; \n } \n }", "idx": 13460}
{"project": "FFmpeg", "commit_id": "7b03b65bf0d02519c86750d2da33f413e11cf0c6", "target": 1, "func": "int av_interleaved_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , flush = 0 ; \n if ( pkt ) { \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && pkt -> size == 0 ) \n return 0 ; \n av_dlog ( s , \" \" PRId64 \" \" PRId64 \" \\n \" , \n pkt -> size , pkt -> dts , pkt -> pts ) ; \n if ( ( ret = compute_pkt_fields2 ( s , st , pkt ) ) < 0 && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) \n if ( pkt -> dts == AV_NOPTS_VALUE && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) \n return AVERROR ( EINVAL ) ; \n } else { \n av_dlog ( s , \" \\n \" ) ; \n flush = 1 ; \n } \n for ( ; ; ) { \n AVPacket opkt ; \n int ret = interleave_packet ( s , & opkt , pkt , flush ) ; \n if ( ret <= 0 ) \n ret = write_packet ( s , & opkt ) ; \n if ( ret >= 0 ) \n s -> streams [ opkt . stream_index ] -> nb_frames ++ ; \n av_free_packet ( & opkt ) ; \n pkt = NULL ; \n } \n }", "idx": 13623}
{"project": "FFmpeg", "commit_id": "be2b927a6f5311cd5dbf25bd34a029c5d376d9cd", "target": 0, "func": "static void unref_buffer ( InputStream * ist , FrameBuffer * buf ) \n { \n av_assert0 ( buf -> refcount ) ; \n buf -> refcount -- ; \n if ( ! buf -> refcount ) { \n buf -> next = ist -> buffer_pool ; \n ist -> buffer_pool = buf ; \n } \n }", "idx": 13648}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int flashsv_decode_init ( AVCodecContext * avctx ) \n { \n FlashSVContext * s = avctx -> priv_data ; \n int zret ; \n s -> avctx = avctx ; \n s -> zstream . zalloc = Z_NULL ; \n s -> zstream . zfree = Z_NULL ; \n s -> zstream . opaque = Z_NULL ; \n zret = inflateInit ( & s -> zstream ) ; \n if ( zret != Z_OK ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , zret ) ; \n return 1 ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 13673}
{"project": "FFmpeg", "commit_id": "1dd488e9559bbe411c6933fd8ff02450a4b3be7e", "target": 0, "func": "static void hl_decode_mb ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n const int mb_xy = h -> mb_xy ; \n const int mb_type = s -> current_picture . mb_type [ mb_xy ] ; \n int is_complex = h -> is_complex || IS_INTRA_PCM ( mb_type ) || s -> qscale == 0 ; \n if ( ENABLE_H264_ENCODER && ! s -> decode ) \n return ; \n if ( is_complex ) \n hl_decode_mb_complex ( h ) ; \n else hl_decode_mb_simple ( h ) ; \n }", "idx": 13833}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int query_format ( struct vf_instance * vf , unsigned int fmt ) \n { \n switch ( fmt ) { \n case IMGFMT_YV12 : \n case IMGFMT_IYUV : \n case IMGFMT_I420 : \n return ff_vf_next_query_format ( vf , IMGFMT_YV12 ) ; \n } \n return 0 ; \n }", "idx": 13836}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "void ff_jref_idct_add ( uint8_t * dest , ptrdiff_t line_size , int16_t * block ) \n { \n ff_j_rev_dct ( block ) ; \n ff_add_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 13857}
{"project": "FFmpeg", "commit_id": "5331773cc33ba26b9e26ace643d926219e46a17b", "target": 0, "func": "static void get_id3_tag ( AVFormatContext * s , int len ) \n { \n ID3v2ExtraMeta * id3v2_extra_meta = NULL ; \n ff_id3v2_read ( s , ID3v2_DEFAULT_MAGIC , & id3v2_extra_meta ) ; \n if ( id3v2_extra_meta ) \n ff_id3v2_parse_apic ( s , & id3v2_extra_meta ) ; \n ff_id3v2_free_extra_meta ( & id3v2_extra_meta ) ; \n }", "idx": 13869}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static void flush_buffer ( ByteIOContext * s ) \n { \n if ( s -> buf_ptr > s -> buffer ) { \n if ( s -> write_packet ) \n s -> write_packet ( s -> opaque , s -> buffer , s -> buf_ptr - s -> buffer ) ; \n if ( s -> checksum_ptr ) { \n s -> checksum = s -> update_checksum ( s -> checksum , s -> checksum_ptr , s -> buf_ptr - s -> checksum_ptr ) ; \n s -> checksum_ptr = s -> buffer ; \n } \n s -> pos += s -> buf_ptr - s -> buffer ; \n } \n s -> buf_ptr = s -> buffer ; \n }", "idx": 13893}
{"project": "FFmpeg", "commit_id": "679a315424e6ffaafd21ebf7a86108bd4e743793", "target": 1, "func": "static int daala_packet ( AVFormatContext * s , int idx ) \n { \n int seg , duration = 1 ; \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n if ( ( ! os -> lastpts || os -> lastpts == AV_NOPTS_VALUE ) && ! ( os -> flags & OGG_FLAG_EOS ) ) { \n for ( seg = os -> segp ; seg < os -> nsegs ; seg ++ ) \n if ( os -> segments [ seg ] < 255 ) \n duration ++ ; \n os -> lastpts = os -> lastdts = daala_gptopts ( s , idx , os -> granule , NULL ) - duration ; \n if ( s -> streams [ idx ] -> start_time == AV_NOPTS_VALUE ) { \n s -> streams [ idx ] -> start_time = os -> lastpts ; \n if ( s -> streams [ idx ] -> duration ) \n s -> streams [ idx ] -> duration -= s -> streams [ idx ] -> start_time ; \n } \n } \n if ( os -> psize > 0 ) \n os -> pduration = 1 ; \n return 0 ; \n }", "idx": 13914}
{"project": "FFmpeg", "commit_id": "1bc1cfdddf7ab8ef50d0fc888808d6b609eb5d8d", "target": 1, "func": "static void rtsp_cmd_pause ( HTTPContext * c , const char * url , RTSPHeader * h ) \n { \n HTTPContext * rtp_c ; \n rtp_c = find_rtp_session_with_url ( url , h -> session_id ) ; \n if ( ! rtp_c ) { \n rtsp_reply_error ( c , RTSP_STATUS_SESSION ) ; \n return ; \n } \n if ( rtp_c -> state != HTTPSTATE_SEND_DATA && \n rtp_c -> state != HTTPSTATE_WAIT_FEED ) { \n rtsp_reply_error ( c , RTSP_STATUS_STATE ) ; \n return ; \n } \n rtp_c -> state = HTTPSTATE_READY ; \n rtsp_reply_header ( c , RTSP_STATUS_OK ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" , rtp_c -> session_id ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n }", "idx": 14102}
{"project": "FFmpeg", "commit_id": "a717f9904227d7979473bad40c50eb40af41d01d", "target": 1, "func": "void ff_mpegts_parse_close ( MpegTSContext * ts ) \n { \n int i ; \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) \n av_free ( ts -> pids [ i ] ) ; \n av_free ( ts ) ; \n }", "idx": 14146}
{"project": "FFmpeg", "commit_id": "e8f814a907036e43f755f35e885bfadf94c4d63b", "target": 1, "func": "AVRational av_guess_frame_rate ( AVFormatContext * format , AVStream * st , AVFrame * frame ) \n { \n AVRational fr = st -> r_frame_rate ; \n AVRational codec_fr = st -> codec -> framerate ; \n AVRational avg_fr = st -> avg_frame_rate ; \n if ( avg_fr . num > 0 && avg_fr . den > 0 && fr . num > 0 && fr . den > 0 && \n av_q2d ( avg_fr ) < 70 && av_q2d ( fr ) > 210 ) { \n fr = avg_fr ; \n } \n if ( st -> codec -> ticks_per_frame > 1 ) { \n if ( codec_fr . num > 0 && codec_fr . den > 0 && av_q2d ( codec_fr ) < av_q2d ( fr ) * 0.7 \n && fabs ( 1.0 - av_q2d ( av_div_q ( avg_fr , fr ) ) ) > 0.1 ) \n fr = codec_fr ; \n } \n return fr ; \n }", "idx": 14180}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void apply_mid_side_stereo ( ChannelElement * cpe ) \n { \n int w , w2 , g , i ; \n IndividualChannelStream * ics = & cpe -> ch [ 0 ] . ics ; \n if ( ! cpe -> common_window ) \n return ; \n for ( w = 0 ; w < ics -> num_windows ; w += ics -> group_len [ w ] ) { \n for ( w2 = 0 ; w2 < ics -> group_len [ w ] ; w2 ++ ) { \n int start = ( w + w2 ) * 128 ; \n for ( g = 0 ; g < ics -> num_swb ; g ++ ) { \n if ( ! cpe -> ms_mask [ w * 16 + g ] ) { \n start += ics -> swb_sizes [ g ] ; \n continue ; \n } \n for ( i = 0 ; i < ics -> swb_sizes [ g ] ; i ++ ) { \n float L = ( cpe -> ch [ 0 ] . coeffs [ start + i ] + cpe -> ch [ 1 ] . coeffs [ start + i ] ) * 0.5f ; \n float R = L - cpe -> ch [ 1 ] . coeffs [ start + i ] ; \n cpe -> ch [ 0 ] . coeffs [ start + i ] = L ; \n cpe -> ch [ 1 ] . coeffs [ start + i ] = R ; \n } \n start += ics -> swb_sizes [ g ] ; \n } \n } \n } \n }", "idx": 14192}
{"project": "FFmpeg", "commit_id": "ab89dbd43e2898c7af99387cfb15fff608b02ab5", "target": 0, "func": "static int ea_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n EaDemuxContext * ea = s -> priv_data ; \n AVStream * st ; \n if ( ! process_ea_header ( s ) ) \n return AVERROR ( EIO ) ; \n if ( ea -> time_base . num && ea -> time_base . den ) { \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n ea -> video_stream_index = st -> index ; \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n st -> codec -> codec_id = ea -> video_codec ; \n st -> codec -> codec_tag = 0 ; \n st -> codec -> time_base = ea -> time_base ; \n } \n if ( ea -> audio_codec ) { \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n av_set_pts_info ( st , 33 , 1 , ea -> sample_rate ) ; \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = ea -> audio_codec ; \n st -> codec -> codec_tag = 0 ; \n st -> codec -> channels = ea -> num_channels ; \n st -> codec -> sample_rate = ea -> sample_rate ; \n st -> codec -> bits_per_sample = ea -> bytes * 8 ; \n st -> codec -> bit_rate = st -> codec -> channels * st -> codec -> sample_rate * \n st -> codec -> bits_per_sample / 4 ; \n st -> codec -> block_align = st -> codec -> channels * st -> codec -> bits_per_sample ; \n ea -> audio_stream_index = st -> index ; \n ea -> audio_frame_counter = 0 ; \n } \n return 1 ; \n }", "idx": 14194}
{"project": "FFmpeg", "commit_id": "c9ff32215b433d505f251c1f212b1fa0a5e17b73", "target": 0, "func": "static int set_format ( void * obj , const char * name , int fmt , int search_flags , \n enum AVOptionType type , const char * desc , int max ) \n { \n void * target_obj ; \n const AVOption * o = av_opt_find2 ( obj , name , NULL , 0 , \n search_flags , & target_obj ) ; \n if ( ! o || ! target_obj ) \n return AVERROR_OPTION_NOT_FOUND ; \n if ( o -> type != type ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \" , name , desc ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( fmt < -1 || fmt > max ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \\n \" , \n fmt , name , desc , max ) ; \n return AVERROR ( ERANGE ) ; \n } \n * ( int * ) ( ( ( uint8_t * ) target_obj ) + o -> offset ) = fmt ; \n return 0 ; \n }", "idx": 14240}
{"project": "FFmpeg", "commit_id": "a5ef7960fc96ed773acc4149104d6acf534e8a87", "target": 1, "func": "static int ape_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret ; \n int nblocks ; \n APEContext * ape = s -> priv_data ; \n uint32_t extra_size = 8 ; \n if ( url_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n if ( ape -> currentframe >= ape -> totalframes ) \n return AVERROR_EOF ; \n if ( avio_seek ( s -> pb , ape -> frames [ ape -> currentframe ] . pos , SEEK_SET ) < 0 ) \n return AVERROR ( EIO ) ; \n if ( ape -> currentframe == ( ape -> totalframes - 1 ) ) \n nblocks = ape -> finalframeblocks ; \n else \n nblocks = ape -> blocksperframe ; \n if ( ape -> frames [ ape -> currentframe ] . size <= 0 || \n ape -> frames [ ape -> currentframe ] . size > INT_MAX - extra_size ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n ape -> frames [ ape -> currentframe ] . size ) ; \n ape -> currentframe ++ ; \n return AVERROR ( EIO ) ; \n } \n if ( av_new_packet ( pkt , ape -> frames [ ape -> currentframe ] . size + extra_size ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n AV_WL32 ( pkt -> data , nblocks ) ; \n AV_WL32 ( pkt -> data + 4 , ape -> frames [ ape -> currentframe ] . skip ) ; \n ret = avio_read ( s -> pb , pkt -> data + extra_size , ape -> frames [ ape -> currentframe ] . size ) ; \n pkt -> pts = ape -> frames [ ape -> currentframe ] . pts ; \n pkt -> stream_index = 0 ; \n pkt -> size = ret + extra_size ; \n ape -> currentframe ++ ; \n return 0 ; \n }", "idx": 14254}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int64_t ftp_seek ( URLContext * h , int64_t pos , int whence ) \n { \n FTPContext * s = h -> priv_data ; \n int err ; \n int64_t new_pos , fake_pos ; \n av_dlog ( h , \" \" PRId64 \" \\n \" , pos , whence ) ; \n switch ( whence ) { \n case AVSEEK_SIZE : \n return s -> filesize ; \n case SEEK_SET : \n new_pos = pos ; \n break ; \n case SEEK_CUR : \n new_pos = s -> position + pos ; \n break ; \n case SEEK_END : \n if ( s -> filesize < 0 ) \n return AVERROR ( EIO ) ; \n new_pos = s -> filesize + pos ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n if ( h -> is_streamed ) \n return AVERROR ( EIO ) ; \n if ( new_pos < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n fake_pos = s -> filesize != -1 ? FFMIN ( new_pos , s -> filesize ) : new_pos ; \n if ( fake_pos != s -> position ) { \n if ( ( err = ftp_abort ( h ) ) < 0 ) \n return err ; \n s -> position = fake_pos ; \n } \n return new_pos ; \n }", "idx": 14405}
{"project": "FFmpeg", "commit_id": "8992029fc0a4dd9df16f8cb46cfb641c98fc9f6c", "target": 0, "func": "static int g729_parse ( AVCodecParserContext * s1 , AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n G729ParseContext * s = s1 -> priv_data ; \n ParseContext * pc = & s -> pc ; \n int next ; \n if ( ! s -> block_size ) { \n switch ( avctx -> codec_id ) { \n case AV_CODEC_ID_G729 : \n s -> block_size = ( avctx -> bit_rate < 8000 ) ? G729D_6K4_BLOCK_SIZE : G729_8K_BLOCK_SIZE ; \n s -> duration = avctx -> frame_size ; \n break ; \n default : \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return buf_size ; \n } \n } \n if ( ! s -> remaining ) \n s -> remaining = s -> block_size ; \n if ( s -> remaining <= buf_size ) { \n next = s -> remaining ; \n s -> remaining = 0 ; \n } else { \n next = END_NOT_FOUND ; \n s -> remaining -= buf_size ; \n } \n if ( ff_combine_frame ( pc , next , & buf , & buf_size ) < 0 || ! buf_size ) { \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n } \n s1 -> duration = s -> duration ; \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n return next ; \n }", "idx": 14509}
{"project": "FFmpeg", "commit_id": "179308768a8742d215eb8450f0718dc2ee8ea133", "target": 0, "func": "static int mxf_write_header_metadata_sets ( AVFormatContext * s ) \n { \n AVStream * st ; \n MXFStreamContext * sc = NULL ; \n int i ; \n mxf_write_preface ( s ) ; \n mxf_write_identification ( s ) ; \n mxf_write_content_storage ( s ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n sc = av_mallocz ( sizeof ( MXFStreamContext ) ) ; \n if ( ! sc ) \n return AVERROR ( ENOMEM ) ; \n st -> priv_data = sc ; \n if ( st -> codec -> codec_type == CODEC_TYPE_VIDEO ) \n av_set_pts_info ( st , 64 , 1 , st -> codec -> time_base . den ) ; \n else if ( st -> codec -> codec_type == CODEC_TYPE_AUDIO ) \n av_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n } \n mxf_build_structural_metadata ( s , MaterialPackage ) ; \n mxf_build_structural_metadata ( s , SourcePackage ) ; \n return 0 ; \n }", "idx": 14611}
{"project": "FFmpeg", "commit_id": "5bc223b15d064e328ff90b0241fa1191f1d2786d", "target": 1, "func": "static int r3d_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n R3DContext * r3d = s -> priv_data ; \n Atom atom ; \n int err = 0 ; \n while ( ! err ) { \n if ( read_atom ( s , & atom ) < 0 ) { \n err = -1 ; \n break ; \n } \n switch ( atom . tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( s -> streams [ 0 ] -> discard == AVDISCARD_ALL ) \n goto skip ; \n if ( ! ( err = r3d_read_redv ( s , pkt , & atom ) ) ) \n return 0 ; \n break ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( ! r3d -> audio_channels ) \n return -1 ; \n if ( s -> streams [ 1 ] -> discard == AVDISCARD_ALL ) \n goto skip ; \n if ( ! ( err = r3d_read_reda ( s , pkt , & atom ) ) ) \n return 0 ; \n break ; \n default : \n skip : \n avio_skip ( s -> pb , atom . size - 8 ) ; \n } \n } \n return err ; \n }", "idx": 14630}
{"project": "FFmpeg", "commit_id": "3518925a9127e368b6d0c7e8fd86510d34af40a1", "target": 1, "func": "static int mov_create_timecode_track ( AVFormatContext * s , int index , int src_index , const char * tcstr ) \n { \n int ret ; \n MOVMuxContext * mov = s -> priv_data ; \n MOVTrack * track = & mov -> tracks [ index ] ; \n AVStream * src_st = s -> streams [ src_index ] ; \n AVTimecode tc ; \n AVPacket pkt = { . stream_index = index , . flags = AV_PKT_FLAG_KEY , . size = 4 } ; \n AVRational rate = find_fps ( s , src_st ) ; \n ret = av_timecode_init_from_string ( & tc , rate , tcstr , s ) ; \n if ( ret < 0 ) \n return ret ; \n track -> mode = mov -> mode ; \n track -> tag = MKTAG ( ' ' , ' ' , ' ' , ' ' ) ; \n track -> src_track = src_index ; \n track -> timescale = mov -> tracks [ src_index ] . timescale ; \n if ( tc . flags & AV_TIMECODE_FLAG_DROPFRAME ) \n track -> timecode_flags |= MOV_TIMECODE_FLAG_DROPFRAME ; \n track -> st = src_st ; \n track -> enc = avcodec_alloc_context3 ( NULL ) ; \n track -> enc -> codec_type = AVMEDIA_TYPE_DATA ; \n track -> enc -> codec_tag = track -> tag ; \n track -> enc -> time_base = av_inv_q ( rate ) ; \n pkt . data = av_malloc ( pkt . size ) ; \n AV_WB32 ( pkt . data , tc . start ) ; \n ret = ff_mov_write_packet ( s , & pkt ) ; \n av_free ( pkt . data ) ; \n return ret ; \n }", "idx": 14653}
{"project": "FFmpeg", "commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "target": 1, "func": "static int rv40_decode_intra_types ( RV34DecContext * r , GetBitContext * gb , int8_t * dst ) \n { \n MpegEncContext * s = & r -> s ; \n int i , j , k , v ; \n int A , B , C ; \n int pattern ; \n int8_t * ptr ; \n for ( i = 0 ; i < 4 ; i ++ , dst += r -> intra_types_stride ) { \n if ( ! i && s -> first_slice_line ) { \n pattern = get_vlc2 ( gb , aic_top_vlc . table , AIC_TOP_BITS , 1 ) ; \n dst [ 0 ] = ( pattern >> 2 ) & 2 ; \n dst [ 1 ] = ( pattern >> 1 ) & 2 ; \n dst [ 2 ] = pattern & 2 ; \n dst [ 3 ] = ( pattern << 1 ) & 2 ; \n continue ; \n } \n ptr = dst ; \n for ( j = 0 ; j < 4 ; j ++ ) { \n A = ptr [ - r -> intra_types_stride + 1 ] ; \n B = ptr [ - r -> intra_types_stride ] ; \n C = ptr [ -1 ] ; \n pattern = A + ( B << 4 ) + ( C << 8 ) ; \n for ( k = 0 ; k < MODE2_PATTERNS_NUM ; k ++ ) \n if ( pattern == rv40_aic_table_index [ k ] ) \n break ; \n if ( j < 3 && k < MODE2_PATTERNS_NUM ) { \n v = get_vlc2 ( gb , aic_mode2_vlc [ k ] . table , AIC_MODE2_BITS , 2 ) ; \n * ptr ++ = v / 9 ; \n * ptr ++ = v % 9 ; \n j ++ ; \n } else { \n if ( B != -1 && C != -1 ) \n v = get_vlc2 ( gb , aic_mode1_vlc [ B + C * 10 ] . table , AIC_MODE1_BITS , 1 ) ; \n else { \n v = 0 ; \n switch ( C ) { \n case -1 : \n if ( B < 2 ) \n v = get_bits1 ( gb ) ^ 1 ; \n break ; \n case 0 : \n case 2 : \n v = ( get_bits1 ( gb ) ^ 1 ) << 1 ; \n break ; \n } \n } \n * ptr ++ = v ; \n } \n } \n } \n return 0 ; \n }", "idx": 14657}
{"project": "FFmpeg", "commit_id": "ef0d779706c77ca9007527bd8d41e9400682f4e4", "target": 1, "func": "static int ogg_save ( AVFormatContext * s ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_state * ost = \n av_malloc ( sizeof ( * ost ) + ( ogg -> nstreams - 1 ) * sizeof ( * ogg -> streams ) ) ; \n int i ; \n ost -> pos = avio_tell ( s -> pb ) ; \n ost -> curidx = ogg -> curidx ; \n ost -> next = ogg -> state ; \n ost -> nstreams = ogg -> nstreams ; \n memcpy ( ost -> streams , ogg -> streams , ogg -> nstreams * sizeof ( * ogg -> streams ) ) ; \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) { \n struct ogg_stream * os = ogg -> streams + i ; \n os -> buf = av_malloc ( os -> bufsize ) ; \n memset ( os -> buf , 0 , os -> bufsize ) ; \n memcpy ( os -> buf , ost -> streams [ i ] . buf , os -> bufpos ) ; \n } \n ogg -> state = ost ; \n return 0 ; \n }", "idx": 14772}
{"project": "FFmpeg", "commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "target": 1, "func": "static int dxtory_decode_v1_444 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y = pic -> data [ 0 ] ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h ++ ) { \n for ( w = 0 ; w < avctx -> width ; w ++ ) { \n Y [ w ] = * src ++ ; \n U [ w ] = * src ++ ^ 0x80 ; \n V [ w ] = * src ++ ^ 0x80 ; \n } \n Y += pic -> linesize [ 0 ] ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 14776}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h265_init ( AVCodecContext * avctx ) \n { \n return ff_vaapi_encode_init ( avctx , & vaapi_encode_type_h265 ) ; \n }", "idx": 14791}
{"project": "FFmpeg", "commit_id": "1731c3530bffb876deb9e00dfffdf9841a8412cd", "target": 1, "func": "static int read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MmDemuxContext * mm = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n unsigned char preamble [ MM_PREAMBLE_SIZE ] ; \n unsigned int type , length ; \n while ( 1 ) { \n if ( avio_read ( pb , preamble , MM_PREAMBLE_SIZE ) != MM_PREAMBLE_SIZE ) { \n return AVERROR ( EIO ) ; \n type = AV_RL16 ( & preamble [ 0 ] ) ; \n length = AV_RL16 ( & preamble [ 2 ] ) ; \n switch ( type ) { \n case MM_TYPE_PALETTE : \n case MM_TYPE_INTER : \n case MM_TYPE_INTRA : \n case MM_TYPE_INTRA_HH : \n case MM_TYPE_INTER_HH : \n case MM_TYPE_INTRA_HHV : \n case MM_TYPE_INTER_HHV : \n if ( av_new_packet ( pkt , length + MM_PREAMBLE_SIZE ) ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( pkt -> data , preamble , MM_PREAMBLE_SIZE ) ; \n if ( avio_read ( pb , pkt -> data + MM_PREAMBLE_SIZE , length ) != length ) \n return AVERROR ( EIO ) ; \n pkt -> size = length + MM_PREAMBLE_SIZE ; \n pkt -> stream_index = 0 ; \n pkt -> pts = mm -> video_pts ; \n if ( type != MM_TYPE_PALETTE ) \n mm -> video_pts ++ ; \n return 0 ; \n case MM_TYPE_AUDIO : \n if ( av_get_packet ( s -> pb , pkt , length ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n pkt -> size = length ; \n pkt -> stream_index = 1 ; \n pkt -> pts = mm -> audio_pts ++ ; \n return 0 ; \n default : \n av_log ( s , AV_LOG_INFO , \" \\n \" , type ) ;", "idx": 14947}
{"project": "FFmpeg", "commit_id": "d584533cf38141172e20bae5436629ee17c8ce50", "target": 0, "func": "static int queue_attached_pictures ( AVFormatContext * s ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n if ( s -> streams [ i ] -> disposition & AV_DISPOSITION_ATTACHED_PIC && \n s -> streams [ i ] -> discard < AVDISCARD_ALL ) { \n AVPacket copy = s -> streams [ i ] -> attached_pic ; \n copy . buf = av_buffer_ref ( copy . buf ) ; \n if ( ! copy . buf ) \n return AVERROR ( ENOMEM ) ; \n add_to_pktbuf ( & s -> internal -> raw_packet_buffer , & copy , \n & s -> internal -> raw_packet_buffer_end ) ; \n } \n return 0 ; \n }", "idx": 14988}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_top ( const char * arg ) \n { \n frame_padtop = atoi ( arg ) ; \n if ( frame_padtop < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n }", "idx": 15022}
{"project": "FFmpeg", "commit_id": "e5cf100d3daaf3fa48d44ae575af916473f85544", "target": 0, "func": "static int mpegvideo_probe ( AVProbeData * p ) \n { \n uint32_t code = -1 ; \n int pic = 0 , seq = 0 , slice = 0 , pspack = 0 , vpes = 0 , apes = 0 , res = 0 ; \n int i ; \n for ( i = 0 ; i < p -> buf_size ; i ++ ) { \n code = ( code << 8 ) + p -> buf [ i ] ; \n if ( ( code & 0xffffff00 ) == 0x100 ) { \n switch ( code ) { \n case SEQ_START_CODE : seq ++ ; break ; \n case PICTURE_START_CODE : pic ++ ; break ; \n case PACK_START_CODE : pspack ++ ; break ; \n case 0x1b6 : \n res ++ ; break ; \n } \n if ( code >= SLICE_START_CODE && code <= 0x1af ) slice ++ ; \n if ( ( code & 0x1f0 ) == VIDEO_ID ) vpes ++ ; \n else if ( ( code & 0x1e0 ) == AUDIO_ID ) apes ++ ; \n } \n } \n if ( seq && seq * 9 <= pic * 10 && pic * 9 <= slice * 10 && ! pspack && ! apes && ! res ) { \n if ( vpes ) return AVPROBE_SCORE_MAX / 8 ; \n else return pic > 1 ? AVPROBE_SCORE_MAX / 2 + 1 : AVPROBE_SCORE_MAX / 4 ; \n } \n return 0 ; \n }", "idx": 15219}
{"project": "FFmpeg", "commit_id": "fb93e61e2b7baa44ff991bc0ce96291490a0188e", "target": 0, "func": "av_cold void ff_yadif_init_x86 ( YADIFContext * yadif ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( HAVE_MMX && cpu_flags & AV_CPU_FLAG_MMX ) \n yadif -> filter_line = yadif_filter_line_mmx ; \n if ( HAVE_SSE && cpu_flags & AV_CPU_FLAG_SSE2 ) \n yadif -> filter_line = yadif_filter_line_sse2 ; \n if ( HAVE_SSSE3 && cpu_flags & AV_CPU_FLAG_SSSE3 ) \n yadif -> filter_line = yadif_filter_line_ssse3 ; \n }", "idx": 15222}
{"project": "FFmpeg", "commit_id": "feb6a94f740bccc8e369f8b74714b940490f3901", "target": 1, "func": "void av_frame_unref ( AVFrame * frame ) \n { \n int i ; \n wipe_side_data ( frame ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( frame -> buf ) ; i ++ ) \n av_buffer_unref ( & frame -> buf [ i ] ) ; \n for ( i = 0 ; i < frame -> nb_extended_buf ; i ++ ) \n av_buffer_unref ( & frame -> extended_buf [ i ] ) ; \n av_freep ( & frame -> extended_buf ) ; \n av_dict_free ( & frame -> metadata ) ; \n av_buffer_unref ( & frame -> qp_table_buf ) ; \n get_frame_defaults ( frame ) ; \n }", "idx": 15225}
{"project": "FFmpeg", "commit_id": "e1ba29c76430ce511fd901c8b7a1bd199b169dc0", "target": 1, "func": "static int decode_i_block ( FourXContext * f , DCTELEM * block ) { \n int code , i , j , level , val ; \n val = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ; \n if ( val >> 4 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( val ) \n val = get_xbits ( & f -> gb , val ) ; \n val = val * dequant_table [ 0 ] + f -> last_dc ; \n f -> last_dc = \n block [ 0 ] = val ; \n i = 1 ; \n for ( ; ; ) { \n code = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ; \n if ( code == 0 ) \n break ; \n if ( code == 0xf0 ) { \n i += 16 ; \n } else { \n level = get_xbits ( & f -> gb , code & 0xf ) ; \n i += code >> 4 ; \n if ( i >= 64 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return 0 ; \n j = ff_zigzag_direct [ i ] ; \n block [ j ] = level * dequant_table [ j ] ; \n i ++ ; \n if ( i >= 64 ) \n break ; \n return 0 ;", "idx": 15262}
{"project": "FFmpeg", "commit_id": "c617c669e9fce59905915c3ba1053f535add6a06", "target": 1, "func": "static int xv_write_trailer ( AVFormatContext * s ) \n { \n XVContext * xv = s -> priv_data ; \n XShmDetach ( xv -> display , & xv -> yuv_shminfo ) ; \n shmdt ( xv -> yuv_image -> data ) ; \n XFree ( xv -> yuv_image ) ; \n XCloseDisplay ( xv -> display ) ; \n return 0 ; \n }", "idx": 15319}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_biweight_h264_pixels16_8_msa ( uint8_t * dst , uint8_t * src , \n int stride , int height , \n int log2_denom , int weight_dst , \n int weight_src , int offset ) \n { \n avc_biwgt_16width_msa ( src , stride , \n dst , stride , \n height , log2_denom , \n weight_src , weight_dst , offset ) ; \n }", "idx": 15330}
{"project": "FFmpeg", "commit_id": "6a4832caaede15e3d918b1408ff83fe30324507b", "target": 0, "func": "void ff_put_dirac_pixels32_sse2 ( uint8_t * dst , const uint8_t * src [ 5 ] , int stride , int h ) \n { \n if ( h & 3 ) { \n ff_put_dirac_pixels32_c ( dst , src , stride , h ) ; \n } else { \n ff_put_pixels16_sse2 ( dst , src [ 0 ] , stride , h ) ; \n ff_put_pixels16_sse2 ( dst + 16 , src [ 0 ] + 16 , stride , h ) ; \n } \n }", "idx": 15403}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "int ff_h264_get_profile ( SPS * sps ) \n { \n int profile = sps -> profile_idc ; \n switch ( sps -> profile_idc ) { \n case FF_PROFILE_H264_BASELINE : \n profile |= ( sps -> constraint_set_flags & 1 << 1 ) ? FF_PROFILE_H264_CONSTRAINED : 0 ; \n break ; \n case FF_PROFILE_H264_HIGH_10 : \n case FF_PROFILE_H264_HIGH_422 : \n case FF_PROFILE_H264_HIGH_444_PREDICTIVE : \n profile |= ( sps -> constraint_set_flags & 1 << 3 ) ? FF_PROFILE_H264_INTRA : 0 ; \n break ; \n } \n return profile ; \n }", "idx": 15476}
{"project": "FFmpeg", "commit_id": "723b6baaf8db43d0872bad504c4f4c780b53516b", "target": 1, "func": "static int decode_iccp_chunk ( PNGDecContext * s , int length , AVFrame * f ) \n { \n int ret , cnt = 0 ; \n uint8_t * data , profile_name [ 82 ] ; \n AVBPrint bp ; \n AVFrameSideData * sd ; \n while ( ( profile_name [ cnt ++ ] = bytestream2_get_byte ( & s -> gb ) ) && cnt < 81 ) ; \n if ( cnt > 80 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n length = FFMAX ( length - cnt , 0 ) ; \n if ( bytestream2_get_byte ( & s -> gb ) != 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n length = FFMAX ( length - 1 , 0 ) ; \n if ( ( ret = decode_zbuf ( & bp , s -> gb . buffer , s -> gb . buffer + length ) ) < 0 ) \n return ret ; \n av_bprint_finalize ( & bp , ( char * * ) & data ) ; \n sd = av_frame_new_side_data ( f , AV_FRAME_DATA_ICC_PROFILE , bp . len ) ; \n if ( ! sd ) { \n av_free ( data ) ; \n } \n av_dict_set ( & sd -> metadata , \" \" , profile_name , 0 ) ; \n memcpy ( sd -> data , data , bp . len ) ; \n av_free ( data ) ; \n bytestream2_skip ( & s -> gb , length + 4 ) ; \n return 0 ; \n }", "idx": 15514}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int decode_buffering_period ( H264Context * h ) \n { \n unsigned int sps_id ; \n int sched_sel_idx ; \n SPS * sps ; \n sps_id = get_ue_golomb_31 ( & h -> gb ) ; \n if ( sps_id > 31 || ! h -> sps_buffers [ sps_id ] ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , sps_id ) ; \n return AVERROR_INVALIDDATA ; \n } \n sps = h -> sps_buffers [ sps_id ] ; \n if ( sps -> nal_hrd_parameters_present_flag ) { \n for ( sched_sel_idx = 0 ; sched_sel_idx < sps -> cpb_cnt ; sched_sel_idx ++ ) { \n h -> initial_cpb_removal_delay [ sched_sel_idx ] = \n get_bits ( & h -> gb , sps -> initial_cpb_removal_delay_length ) ; \n skip_bits ( & h -> gb , sps -> initial_cpb_removal_delay_length ) ; \n } \n } \n if ( sps -> vcl_hrd_parameters_present_flag ) { \n for ( sched_sel_idx = 0 ; sched_sel_idx < sps -> cpb_cnt ; sched_sel_idx ++ ) { \n h -> initial_cpb_removal_delay [ sched_sel_idx ] = \n get_bits ( & h -> gb , sps -> initial_cpb_removal_delay_length ) ; \n skip_bits ( & h -> gb , sps -> initial_cpb_removal_delay_length ) ; \n } \n } \n h -> sei_buffering_period_present = 1 ; \n return 0 ; \n }", "idx": 15567}
{"project": "FFmpeg", "commit_id": "b399816d9c3d0fc3efd742b04f269c1055cc6e2b", "target": 1, "func": "static int ism_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n SmoothStreamingContext * c = s -> priv_data ; \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n OutputStream * os = & c -> streams [ pkt -> stream_index ] ; \n int64_t end_dts = ( c -> nb_fragments + 1 ) * c -> min_frag_duration ; \n int ret ; \n if ( st -> first_dts == AV_NOPTS_VALUE ) \n st -> first_dts = pkt -> dts ; \n if ( ( ! c -> has_video || st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) && \n av_compare_ts ( pkt -> dts - st -> first_dts , st -> time_base , \n end_dts , AV_TIME_BASE_Q ) >= 0 && \n pkt -> flags & AV_PKT_FLAG_KEY && os -> packets_written ) { \n if ( ( ret = ism_flush ( s , 0 ) ) < 0 ) \n return ret ; \n c -> nb_fragments ++ ; \n } \n os -> packets_written ++ ; \n return ff_write_chained ( os -> ctx , 0 , pkt , s ) ; \n }", "idx": 15577}
{"project": "FFmpeg", "commit_id": "e938637b2ca7587c2b349458189f1f7d7da87040", "target": 0, "func": "static int truespeech_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n TSContext * c = avctx -> priv_data ; \n int i ; \n short * samples = data ; \n int consumed = 0 ; \n int16_t out_buf [ 240 ] ; \n if ( ! buf_size ) \n return 0 ; \n while ( consumed < buf_size ) { \n truespeech_read_frame ( c , buf + consumed ) ; \n consumed += 32 ; \n truespeech_correlate_filter ( c ) ; \n truespeech_filters_merge ( c ) ; \n memset ( out_buf , 0 , 240 * 2 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n truespeech_apply_twopoint_filter ( c , i ) ; \n truespeech_place_pulses ( c , out_buf + i * 60 , i ) ; \n truespeech_update_filters ( c , out_buf + i * 60 , i ) ; \n truespeech_synth ( c , out_buf + i * 60 , i ) ; \n } \n truespeech_save_prevvec ( c ) ; \n for ( i = 0 ; i < 240 ; i ++ ) \n * samples ++ = out_buf [ i ] ; \n } \n * data_size = consumed * 15 ; \n return buf_size ; \n }", "idx": 15635}
{"project": "FFmpeg", "commit_id": "a6ca08f1af31badb7fef93bc1cbfa78bffae6be7", "target": 0, "func": "static int gxf_write_trailer ( AVFormatContext * s ) \n { \n GXFContext * gxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int64_t end ; \n int i ; \n ff_audio_interleave_close ( s ) ; \n gxf_write_eos_packet ( pb ) ; \n end = avio_tell ( pb ) ; \n avio_seek ( pb , 0 , SEEK_SET ) ; \n gxf_write_map_packet ( s , 1 ) ; \n gxf_write_flt_packet ( s ) ; \n gxf_write_umf_packet ( s ) ; \n avio_flush ( pb ) ; \n for ( i = 1 ; i < gxf -> map_offsets_nb ; i ++ ) { \n avio_seek ( pb , gxf -> map_offsets [ i ] , SEEK_SET ) ; \n gxf_write_map_packet ( s , 1 ) ; \n avio_flush ( pb ) ; \n } \n avio_seek ( pb , end , SEEK_SET ) ; \n av_freep ( & gxf -> flt_entries ) ; \n av_freep ( & gxf -> map_offsets ) ; \n return 0 ; \n }", "idx": 15693}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "void in_asm_used_var_warning_killer ( ) \n { \n volatile int i = yCoeff + vrCoeff + ubCoeff + vgCoeff + ugCoeff + bF8 + bFC + w400 + w80 + w10 + \n bm00001111 + bm00000111 + bm11111000 + b16Mask + g16Mask + r16Mask + b15Mask + g15Mask + r15Mask + asm_yalpha1 + asm_uvalpha1 + \n M24A + M24B + M24C + w02 + b5Dither + g5Dither + r5Dither + g6Dither + dither4 [ 0 ] + dither8 [ 0 ] ; \n if ( i ) i = 0 ; \n }", "idx": 15748}
{"project": "FFmpeg", "commit_id": "22d13e4290c8fdba57485e1b501f6a92283a10db", "target": 0, "func": "static double setup_compress_thresh ( double threshold ) \n { \n if ( ( threshold > DBL_EPSILON ) && ( threshold < ( 1.0 - DBL_EPSILON ) ) ) { \n double current_threshold = threshold ; \n double step_size = 1.0 ; \n while ( step_size > DBL_EPSILON ) { \n while ( ( current_threshold + step_size > current_threshold ) && \n ( bound ( current_threshold + step_size , 1.0 ) <= threshold ) ) { \n current_threshold += step_size ; \n } \n step_size /= 2.0 ; \n } \n return current_threshold ; \n } else { \n return threshold ; \n } \n }", "idx": 15750}
{"project": "FFmpeg", "commit_id": "5626e812d2c1c202f749824905b70cdb8a845e7b", "target": 1, "func": "static av_always_inline int get_decoded_frame ( AVFormatContext * fmt_ctx , \n AVFrame * frame , int * got_frame , \n AVPacket * pkt ) \n { \n AVCodecContext * dec_ctx = fmt_ctx -> streams [ pkt -> stream_index ] -> codec ; \n int ret = 0 ; \n * got_frame = 0 ; \n if ( dec_ctx -> codec ) { \n switch ( dec_ctx -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n ret = avcodec_decode_video2 ( dec_ctx , frame , got_frame , pkt ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n ret = avcodec_decode_audio4 ( dec_ctx , frame , got_frame , pkt ) ; \n break ; \n return ret ;", "idx": 15754}
{"project": "FFmpeg", "commit_id": "4ba6a534dc94bd4ff44503de9c7985a456cfe503", "target": 0, "func": "static int64_t http_seek ( URLContext * h , int64_t off , int whence ) \n { \n HTTPContext * s = h -> priv_data ; \n URLContext * old_hd = s -> hd ; \n int64_t old_off = s -> off ; \n uint8_t old_buf [ BUFFER_SIZE ] ; \n int old_buf_size ; \n AVDictionary * options = NULL ; \n if ( whence == AVSEEK_SIZE ) \n return s -> filesize ; \n else if ( ( whence == SEEK_CUR && off == 0 ) || ( whence == SEEK_SET && off == s -> off ) ) \n return s -> off ; \n else if ( ( s -> filesize == -1 && whence == SEEK_END ) || h -> is_streamed ) \n return -1 ; \n old_buf_size = s -> buf_end - s -> buf_ptr ; \n memcpy ( old_buf , s -> buf_ptr , old_buf_size ) ; \n s -> hd = NULL ; \n if ( whence == SEEK_CUR ) \n off += s -> off ; \n else if ( whence == SEEK_END ) \n off += s -> filesize ; \n s -> off = off ; \n av_dict_copy ( & options , s -> chained_options , 0 ) ; \n if ( http_open_cnx ( h , & options ) < 0 ) { \n av_dict_free ( & options ) ; \n memcpy ( s -> buffer , old_buf , old_buf_size ) ; \n s -> buf_ptr = s -> buffer ; \n s -> buf_end = s -> buffer + old_buf_size ; \n s -> hd = old_hd ; \n s -> off = old_off ; \n return -1 ; \n } \n av_dict_free ( & options ) ; \n ffurl_close ( old_hd ) ; \n return off ; \n }", "idx": 15931}
{"project": "FFmpeg", "commit_id": "5b0fc078191138795e817244555741356f9d12e9", "target": 1, "func": "static int vp9_decode_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) \n { \n int i , res ; \n VP9Context * s = dst -> priv_data , * ssrc = src -> priv_data ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( s -> frames [ i ] . tf . f -> data [ 0 ] ) \n vp9_unref_frame ( dst , & s -> frames [ i ] ) ; \n if ( ssrc -> frames [ i ] . tf . f -> data [ 0 ] ) { \n if ( ( res = vp9_ref_frame ( dst , & s -> frames [ i ] , & ssrc -> frames [ i ] ) ) < 0 ) \n return res ; \n } \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n if ( s -> refs [ i ] . f -> data [ 0 ] ) \n ff_thread_release_buffer ( dst , & s -> refs [ i ] ) ; \n if ( ssrc -> next_refs [ i ] . f -> data [ 0 ] ) { \n if ( ( res = ff_thread_ref_frame ( & s -> refs [ i ] , & ssrc -> next_refs [ i ] ) ) < 0 ) \n return res ; \n } \n } \n s -> invisible = ssrc -> invisible ; \n s -> keyframe = ssrc -> keyframe ; \n s -> uses_2pass = ssrc -> uses_2pass ; \n memcpy ( & s -> prob_ctx , & ssrc -> prob_ctx , sizeof ( s -> prob_ctx ) ) ; \n memcpy ( & s -> lf_delta , & ssrc -> lf_delta , sizeof ( s -> lf_delta ) ) ; \n if ( ssrc -> segmentation . enabled ) { \n memcpy ( & s -> segmentation . feat , & ssrc -> segmentation . feat , \n sizeof ( s -> segmentation . feat ) ) ; \n } \n return 0 ; \n }", "idx": 16122}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "static int url_alloc_for_protocol ( URLContext * * puc , struct URLProtocol * up , \n const char * filename , int flags , \n const AVIOInterruptCB * int_cb ) \n { \n URLContext * uc ; \n int err ; \n #if CONFIG_NETWORK  \n  \n  if ( up -> flags & URL_PROTOCOL_FLAG_NETWORK && ! ff_network_init ( ) ) \n return AVERROR ( EIO ) ; \n #endif \n uc = av_mallocz ( sizeof ( URLContext ) + strlen ( filename ) + 1 ) ; \n if ( ! uc ) { \n err = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n uc -> av_class = & ffurl_context_class ; \n uc -> filename = ( char * ) & uc [ 1 ] ; \n strcpy ( uc -> filename , filename ) ; \n uc -> prot = up ; \n uc -> flags = flags ; \n uc -> is_streamed = 0 ; \n uc -> max_packet_size = 0 ; \n if ( up -> priv_data_size ) { \n uc -> priv_data = av_mallocz ( up -> priv_data_size ) ; \n if ( ! uc -> priv_data ) { \n err = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( up -> priv_data_class ) { \n * ( const AVClass * * ) uc -> priv_data = up -> priv_data_class ; \n av_opt_set_defaults ( uc -> priv_data ) ; \n } \n } \n if ( int_cb ) \n uc -> interrupt_callback = * int_cb ; \n * puc = uc ; \n return 0 ; \n fail : \n * puc = NULL ; \n if ( uc ) \n av_freep ( & uc -> priv_data ) ; \n av_freep ( & uc ) ; \n #if CONFIG_NETWORK  \n  \n  if ( up -> flags & URL_PROTOCOL_FLAG_NETWORK ) \n ff_network_close ( ) ; \n #endif \n return err ; \n }", "idx": 16184}
{"project": "FFmpeg", "commit_id": "ef8740d8e58dc45950887305307206d27ad413fb", "target": 1, "func": "static av_always_inline void iadst4_1d ( const dctcoef * in , ptrdiff_t stride , \n dctcoef * out , int pass ) \n { \n int t0 , t1 , t2 , t3 ; \n t0 = 5283 * IN ( 0 ) + 15212 * IN ( 2 ) + 9929 * IN ( 3 ) ; \n t1 = 9929 * IN ( 0 ) - 5283 * IN ( 2 ) - 15212 * IN ( 3 ) ; \n t2 = 13377 * ( IN ( 0 ) - IN ( 2 ) + IN ( 3 ) ) ; \n t3 = 13377 * IN ( 1 ) ; \n out [ 0 ] = ( t0 + t3 + ( 1 << 13 ) ) >> 14 ; \n out [ 1 ] = ( t1 + t3 + ( 1 << 13 ) ) >> 14 ; \n out [ 2 ] = ( t2 + ( 1 << 13 ) ) >> 14 ; \n out [ 3 ] = ( t0 + t1 - t3 + ( 1 << 13 ) ) >> 14 ; \n }", "idx": 16290}
{"project": "FFmpeg", "commit_id": "bfa0f96586fe2c257cfa574ffb991da493a54da1", "target": 1, "func": "static void vp8_decode_flush ( AVCodecContext * avctx ) \n { \n vp8_decode_flush_impl ( avctx , 0 , 0 ) ; \n }", "idx": 16358}
{"project": "FFmpeg", "commit_id": "66875798eb88be2f9e49c7d1d1b92aadac1623f6", "target": 1, "func": "static int ipvideo_decode_block_opcode_0x9 ( IpvideoContext * s , AVFrame * frame ) \n { \n int x , y ; \n unsigned char P [ 4 ] ; \n bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n if ( P [ 2 ] <= P [ 3 ] ) { \n for ( y = 0 ; y < 8 ; y ++ ) { \n int flags = bytestream2_get_le16 ( & s -> stream_ptr ) ; \n for ( x = 0 ; x < 8 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> line_inc ; \n } else  { \n uint32_t flags ; \n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 , flags >>= 2 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride * 2 ; \n } else  { \n uint64_t flags ; \n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ; \n if ( P [ 2 ] <= P [ 3 ] ) { \n for ( y = 0 ; y < 8 ; y ++ ) { \n for ( x = 0 ; x < 8 ; x += 2 , flags >>= 2 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride ; \n } else  { \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x ++ , flags >>= 2 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + s -> stride ] = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride * 2 ; \n return 0 ;", "idx": 16361}
{"project": "FFmpeg", "commit_id": "87bddba43b725d43767f2a387cdea0936ac1b549", "target": 1, "func": "float ff_amr_set_fixed_gain ( float fixed_gain_factor , float fixed_mean_energy , \n float * prediction_error , float energy_mean , \n const float * pred_table ) \n { \n float val = fixed_gain_factor * \n ff_exp10 ( 0.05 * \n ( avpriv_scalarproduct_float_c ( pred_table , prediction_error , 4 ) + \n energy_mean ) ) / \n sqrtf ( fixed_mean_energy ) ; \n memmove ( & prediction_error [ 0 ] , & prediction_error [ 1 ] , \n 3 * sizeof ( prediction_error [ 0 ] ) ) ; \n prediction_error [ 3 ] = 20.0 * log10f ( fixed_gain_factor ) ; \n return val ; \n }", "idx": 16464}
{"project": "FFmpeg", "commit_id": "1255eed533b4069db7f205601953ca54c0dc42c9", "target": 1, "func": "static void tgq_decode_mb ( TgqContext * s , int mb_y , int mb_x , const uint8_t * * bs , const uint8_t * buf_end ) { \n int mode ; \n int i ; \n int8_t dc [ 6 ] ; \n mode = bytestream_get_byte ( bs ) ; \n if ( mode > buf_end - * bs ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n if ( mode > 12 ) { \n GetBitContext gb ; \n init_get_bits ( & gb , * bs , mode * 8 ) ; \n for ( i = 0 ; i < 6 ; i ++ ) \n tgq_decode_block ( s , s -> block [ i ] , & gb ) ; \n tgq_idct_put_mb ( s , s -> block , mb_x , mb_y ) ; \n } else { \n if ( mode == 3 ) { \n memset ( dc , ( * bs ) [ 0 ] , 4 ) ; \n dc [ 4 ] = ( * bs ) [ 1 ] ; \n dc [ 5 ] = ( * bs ) [ 2 ] ; \n } else if ( mode == 6 ) { \n memcpy ( dc , * bs , 6 ) ; \n } else if ( mode == 12 ) { \n for ( i = 0 ; i < 6 ; i ++ ) \n dc [ i ] = ( * bs ) [ i * 2 ] ; \n } else { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , mode ) ; \n } \n tgq_idct_put_mb_dconly ( s , mb_x , mb_y , dc ) ; \n } \n * bs += mode ; \n }", "idx": 16659}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void ff_prores_idct ( DCTELEM * block , const int16_t * qmat ) \n { \n int i ; \n for ( i = 0 ; i < 64 ; i ++ ) \n block [ i ] *= qmat [ i ] ; \n for ( i = 0 ; i < 8 ; i ++ ) \n idctRowCondDC_10 ( block + i * 8 ) ; \n for ( i = 0 ; i < 64 ; i ++ ) \n block [ i ] >>= 2 ; \n for ( i = 0 ; i < 8 ; i ++ ) \n idctSparseCol_10 ( block + i ) ; \n }", "idx": 16660}
{"project": "FFmpeg", "commit_id": "956c901c68eff78288f40e3c8f41ee2fa081d4a8", "target": 1, "func": "static int matroska_deliver_packet ( MatroskaDemuxContext * matroska , \n AVPacket * pkt ) \n { \n if ( matroska -> num_packets > 0 ) { \n memcpy ( pkt , matroska -> packets [ 0 ] , sizeof ( AVPacket ) ) ; \n av_free ( matroska -> packets [ 0 ] ) ; \n if ( matroska -> num_packets > 1 ) { \n memmove ( & matroska -> packets [ 0 ] , & matroska -> packets [ 1 ] , \n ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ; \n matroska -> packets = \n av_realloc ( matroska -> packets , ( matroska -> num_packets - 1 ) * \n sizeof ( AVPacket * ) ) ; \n } else { \n av_freep ( & matroska -> packets ) ; \n } \n matroska -> num_packets -- ; \n return 0 ; \n } \n return -1 ; \n }", "idx": 16932}
{"project": "FFmpeg", "commit_id": "c742ab4e81bb9dcabfdab006d6b8b09a5808c4ce", "target": 0, "func": "static int vc1_parse_init ( AVCodecParserContext * s ) \n { \n VC1ParseContext * vpc = s -> priv_data ; \n vpc -> v . s . slice_context_count = 1 ; \n return 0 ; \n }", "idx": 16942}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static void json_print_chapter_header ( WriterContext * wctx , const char * chapter ) \n { \n JSONContext * json = wctx -> priv ; \n char * chapter_esc ; \n if ( wctx -> nb_chapter ) \n printf ( \" \" ) ; \n json -> multiple_entries = ! strcmp ( chapter , \" \" ) || ! strcmp ( chapter , \" \" ) ; \n chapter_esc = json_escape_str ( chapter ) ; \n printf ( \" \\n \\\" \\\" \" , chapter_esc ? chapter_esc : \" \" , \n json -> multiple_entries ? \" \" : \" \" ) ; \n av_free ( chapter_esc ) ; \n }", "idx": 16969}
{"project": "FFmpeg", "commit_id": "6a287b739f3a8660d5e4405be1302da8b3e51e88", "target": 1, "func": "static inline int range_get_symbol ( APEContext * ctx , \n const uint32_t counts [ ] , \n const uint16_t counts_diff [ ] ) \n { \n int symbol , cf ; \n cf = range_decode_culshift ( ctx , 16 ) ; \n for ( symbol = 0 ; counts [ symbol + 1 ] <= cf ; symbol ++ ) ; \n range_decode_update ( ctx , counts_diff [ symbol ] , counts [ symbol ] ) ; ", "idx": 17056}
{"project": "FFmpeg", "commit_id": "bd0a9f603d0c1d0f3be782865f72ac29ab89bc5b", "target": 1, "func": "static int find_video_stream_info ( AVFormatContext * fmt_ctx , int decode ) \n { \n int ret = 0 ; \n int i , done = 0 ; \n AVPacket pkt ; \n av_init_packet ( & pkt ) ; \n while ( ! done ) { \n AVCodecContext * codec_ctx = NULL ; \n AVStream * st ; \n if ( ( ret = av_read_frame ( fmt_ctx , & pkt ) ) < 0 ) { \n av_log ( fmt_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto end ; \n st = fmt_ctx -> streams [ pkt . stream_index ] ; \n codec_ctx = st -> codec ; \n if ( codec_ctx -> codec_type != AVMEDIA_TYPE_VIDEO || \n st -> codec_info_nb_frames ++ > 0 ) { \n av_packet_unref ( & pkt ) ; \n continue ; \n ret = try_decode_video_frame ( codec_ctx , & pkt , decode ) ; \n if ( ret < 0 ) { \n av_log ( fmt_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto end ; \n av_packet_unref ( & pkt ) ; \n done = 1 ; \n st = fmt_ctx -> streams [ i ] ; \n codec_ctx = st -> codec ; \n if ( codec_ctx -> codec_type != AVMEDIA_TYPE_VIDEO ) \n continue ; \n done &= st -> codec_info_nb_frames > 0 ; \n end : \n av_packet_unref ( & pkt ) ; \n return ret < 0 ;", "idx": 17224}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_v_loop_filter_chroma_c ( uint8_t * pix , int stride , int alpha , int beta , int8_t * tc0 ) \n { \n h264_loop_filter_chroma_c ( pix , stride , 1 , alpha , beta , tc0 ) ; \n }", "idx": 17248}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vp9_end_frame ( AVCodecContext * avctx ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n int ret = ff_nvdec_end_frame ( avctx ) ; \n ctx -> bitstream = NULL ; \n return ret ; \n }", "idx": 17259}
{"project": "FFmpeg", "commit_id": "fe573d1a9b742652f44cdc15b24fdd401eefc5e7", "target": 0, "func": "SwsVector * sws_allocVec ( int length ) \n { \n SwsVector * vec = av_malloc ( sizeof ( SwsVector ) ) ; \n if ( ! vec ) \n return NULL ; \n vec -> length = length ; \n vec -> coeff = av_malloc ( sizeof ( double ) * length ) ; \n if ( ! vec -> coeff ) \n av_freep ( & vec ) ; \n return vec ; \n }", "idx": 17289}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_log_state ( AudioFrameQueue * afq ) \n { \n AudioFrame * f ; \n av_log ( afq -> avctx , AV_LOG_DEBUG , \" \\n \" , \n afq -> remaining_delay ) ; \n av_log ( afq -> avctx , AV_LOG_DEBUG , \" \\n \" , \n afq -> remaining_samples ) ; \n av_log ( afq -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n f = afq -> frame_queue ; \n while ( f ) { \n av_log ( afq -> avctx , AV_LOG_DEBUG , \" \" PRId64 \" \\n \" , \n f -> pts , f -> duration ) ; \n f = f -> next ; \n } \n }", "idx": 17336}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_bottom ( const char * arg ) \n { \n frame_padbottom = atoi ( arg ) ; \n if ( frame_padbottom < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n }", "idx": 17358}
{"project": "FFmpeg", "commit_id": "bd6ece4609b49eb40f880252452b809bff8f13ec", "target": 1, "func": "static int query_codec ( enum CodecID id , int std_compliance ) \n { \n CodecMime * cm = ff_id3v2_mime_tags ; \n while ( cm -> id != CODEC_ID_NONE ) { \n if ( id == cm -> id ) \n return MKTAG ( ' ' , ' ' , ' ' , ' ' ) ; \n cm ++ ; \n } \n return -1 ; \n }", "idx": 17388}
{"project": "FFmpeg", "commit_id": "e4a1d87ef88d57cca21ec425120c6a370fdb0210", "target": 1, "func": "static void mkv_free ( MatroskaMuxContext * mkv ) { \n if ( mkv -> main_seekhead ) { \n av_freep ( & mkv -> main_seekhead -> entries ) ; \n av_freep ( & mkv -> main_seekhead ) ; \n if ( mkv -> cues ) { \n av_freep ( & mkv -> cues -> entries ) ; \n av_freep ( & mkv -> cues ) ; \n if ( mkv -> attachments ) { \n av_freep ( & mkv -> attachments -> entries ) ; \n av_freep ( & mkv -> attachments ) ; \n av_freep ( & mkv -> tracks ) ; \n av_freep ( & mkv -> stream_durations ) ; \n av_freep ( & mkv -> stream_duration_offsets ) ;", "idx": 17458}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int show_filters ( void * optctx , const char * opt , const char * arg ) \n { \n AVFilter av_unused (  * * filter ) = NULL ; \n printf ( \" \\n \" ) ; \n #if CONFIG_AVFILTER  \n  \n  while ( ( filter = av_filter_next ( filter ) ) && * filter ) \n printf ( \" \\n \" , ( * filter ) -> name , ( * filter ) -> description ) ; \n #endif \n return 0 ; \n }", "idx": 17492}
{"project": "FFmpeg", "commit_id": "d934de5c5d9ff1d228d0113e31e182efe2a853aa", "target": 0, "func": "static int cavs_find_frame_end ( ParseContext * pc , const uint8_t * buf , \n int buf_size ) { \n int pic_found , i ; \n uint32_t state ; \n pic_found = pc -> frame_start_found ; \n state = pc -> state ; \n i = 0 ; \n if ( ! pic_found ) { \n for ( i = 0 ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( state == PIC_I_START_CODE || state == PIC_PB_START_CODE ) { \n i ++ ; \n pic_found = 1 ; \n break ; \n } \n } \n } \n if ( pic_found ) { \n if ( buf_size == 0 ) \n return 0 ; \n for ( ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( ( state & 0xFFFFFF00 ) == 0x100 ) { \n if ( state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE ) { \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n return i - 3 ; \n } \n } \n } \n } \n pc -> frame_start_found = pic_found ; \n pc -> state = state ; \n return END_NOT_FOUND ; \n }", "idx": 17505}
{"project": "FFmpeg", "commit_id": "004564c930ef60d2f9e8798e820ed7b2a37ba0bd", "target": 0, "func": "static void bwf_write_bext_chunk ( AVFormatContext * s ) \n { \n AVDictionaryEntry * tmp_tag ; \n uint64_t time_reference = 0 ; \n int64_t bext = ff_start_tag ( s -> pb , \" \" ) ; \n bwf_write_bext_string ( s , \" \" , 256 ) ; \n bwf_write_bext_string ( s , \" \" , 32 ) ; \n bwf_write_bext_string ( s , \" \" , 32 ) ; \n bwf_write_bext_string ( s , \" \" , 10 ) ; \n bwf_write_bext_string ( s , \" \" , 8 ) ; \n if ( tmp_tag = av_dict_get ( s -> metadata , \" \" , NULL , 0 ) ) \n time_reference = strtoll ( tmp_tag -> value , NULL , 10 ) ; \n avio_wl64 ( s -> pb , time_reference ) ; \n avio_wl16 ( s -> pb , 1 ) ; \n if ( tmp_tag = av_dict_get ( s -> metadata , \" \" , NULL , 0 ) ) { \n unsigned char umidpart_str [ 17 ] = { 0 } ; \n int64_t i ; \n uint64_t umidpart ; \n size_t len = strlen ( tmp_tag -> value + 2 ) ; \n for ( i = 0 ; i < len / 16 ; i ++ ) { \n memcpy ( umidpart_str , tmp_tag -> value + 2 + ( i * 16 ) , 16 ) ; \n umidpart = strtoll ( umidpart_str , NULL , 16 ) ; \n avio_wb64 ( s -> pb , umidpart ) ; \n } \n ffio_fill ( s -> pb , 0 , 64 - i * 8 ) ; \n } else \n ffio_fill ( s -> pb , 0 , 64 ) ; \n ffio_fill ( s -> pb , 0 , 190 ) ; \n if ( tmp_tag = av_dict_get ( s -> metadata , \" \" , NULL , 0 ) ) \n avio_put_str ( s -> pb , tmp_tag -> value ) ; \n ff_end_tag ( s -> pb , bext ) ; \n }", "idx": 17539}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void free_schro_frame ( SchroFrame * frame , void * priv ) \n { \n AVFrame * p_pic = priv ; \n av_frame_free ( & p_pic ) ; \n }", "idx": 17544}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static void decode_pulses ( Pulse * pulse , GetBitContext * gb , const uint16_t * swb_offset ) { \n int i ; \n pulse -> num_pulse = get_bits ( gb , 2 ) + 1 ; \n pulse -> pos [ 0 ] = swb_offset [ get_bits ( gb , 6 ) ] ; \n pulse -> pos [ 0 ] += get_bits ( gb , 5 ) ; \n pulse -> amp [ 0 ] = get_bits ( gb , 4 ) ; \n for ( i = 1 ; i < pulse -> num_pulse ; i ++ ) { \n pulse -> pos [ i ] = get_bits ( gb , 5 ) + pulse -> pos [ i - 1 ] ; \n pulse -> amp [ i ] = get_bits ( gb , 4 ) ; \n } \n }", "idx": 17585}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int asf_probe ( AVProbeData * pd ) \n { \n if ( pd -> buf_size <= 32 ) \n return 0 ; \n if ( ! memcmp ( pd -> buf , & asf_header , sizeof ( GUID ) ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 17734}
{"project": "FFmpeg", "commit_id": "ffbd1d2b0002576ef0d976a41ff959c635373fdc", "target": 1, "func": "av_cold void ff_vp9dsp_init ( VP9DSPContext * dsp ) \n { \n vp9dsp_intrapred_init ( dsp ) ; \n vp9dsp_itxfm_init ( dsp ) ; \n vp9dsp_loopfilter_init ( dsp ) ; \n vp9dsp_mc_init ( dsp ) ; \n if ( ARCH_X86 ) \n ff_vp9dsp_init_x86 ( dsp ) ; \n }", "idx": 17825}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static void filter_edges ( void * dst1 , void * prev1 , void * cur1 , void * next1 , \n int w , int prefs , int mrefs , int parity , int mode ) \n { \n uint8_t * dst = dst1 ; \n uint8_t * prev = prev1 ; \n uint8_t * cur = cur1 ; \n uint8_t * next = next1 ; \n int x ; \n uint8_t * prev2 = parity ? prev : cur ; \n uint8_t * next2 = parity ? cur : next ; \n FILTER ( 0 , 3 , 0 )  \n dst = ( uint8_t * ) dst1 + w - 3 ; \n prev = ( uint8_t * ) prev1 + w - 3 ; \n cur = ( uint8_t * ) cur1 + w - 3 ; \n next = ( uint8_t * ) next1 + w - 3 ; \n prev2 = ( uint8_t * ) ( parity ? prev : cur ) ; \n next2 = ( uint8_t * ) ( parity ? cur : next ) ; \n FILTER ( w - 3 , w , 0 )  \n }", "idx": 17866}
{"project": "FFmpeg", "commit_id": "07339a45a04e5fa0848937090511d69a39a04740", "target": 1, "func": "int ff_packet_split_and_drop_side_data ( AVPacket * pkt ) { \n if ( ! pkt -> side_data_elems && pkt -> size > 12 && AV_RB64 ( pkt -> data + pkt -> size - 8 ) == FF_MERGE_MARKER ) { \n int i ; \n unsigned int size ; \n uint8_t * p ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 1 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n if ( size > INT_MAX - 5 || p - pkt -> data < size ) \n if ( p [ 4 ] & 128 ) \n break ; \n if ( p - pkt -> data < size + 5 ) \n p -= size + 5 ; \n } \n pkt -> size = p - pkt -> data - size ; \n av_assert0 ( pkt -> size >= 0 ) ; \n return 1 ; \n } \n }", "idx": 17925}
{"project": "FFmpeg", "commit_id": "7d204e67e8f991bfdfb6a6e91b6855b6c5a782c0", "target": 1, "func": "void ff_rm_free_rmstream ( RMStream * rms ) \n { \n av_free ( rms -> videobuf ) ; \n av_free ( rms -> audiobuf ) ; \n }", "idx": 17984}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int sol_probe ( AVProbeData * p ) \n { \n uint16_t magic ; \n if ( p -> buf_size <= 14 ) \n return 0 ; \n magic = le2me_16 ( * ( ( uint16_t * ) p -> buf ) ) ; \n if ( ( magic == 0x0B8D || magic == 0x0C0D || magic == 0x0C8D ) && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 4 ] == ' ' && p -> buf [ 5 ] == 0 ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 18064}
{"project": "FFmpeg", "commit_id": "97cfa55eea39cef30abe14682c56c1e4e7f6f10d", "target": 1, "func": "static void ff_compute_band_indexes ( MPADecodeContext * s , GranuleDef * g ) \n { \n if ( g -> block_type == 2 ) { \n if ( g -> switch_point ) { \n if ( s -> sample_rate_index <= 2 ) \n g -> long_end = 8 ; \n else \n g -> long_end = 6 ; \n g -> short_start = 2 + ( s -> sample_rate_index != 8 ) ; \n } else { \n g -> long_end = 0 ; \n g -> short_start = 0 ; \n } \n } else { \n g -> short_start = 13 ; \n g -> long_end = 22 ; \n } \n }", "idx": 18217}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_h264_init_fixed_qp ( AVCodecContext * avctx ) \n { \n VAAPIEncodeContext * ctx = avctx -> priv_data ; \n VAAPIEncodeH264Context * priv = ctx -> priv_data ; \n VAAPIEncodeH264Options * opt = ctx -> codec_options ; \n priv -> fixed_qp_p = opt -> qp ; \n if ( avctx -> i_quant_factor > 0.0 ) \n priv -> fixed_qp_idr = ( int ) ( ( priv -> fixed_qp_p * avctx -> i_quant_factor + \n avctx -> i_quant_offset ) + 0.5 ) ; \n else \n priv -> fixed_qp_idr = priv -> fixed_qp_p ; \n if ( avctx -> b_quant_factor > 0.0 ) \n priv -> fixed_qp_b = ( int ) ( ( priv -> fixed_qp_p * avctx -> b_quant_factor + \n avctx -> b_quant_offset ) + 0.5 ) ; \n else \n priv -> fixed_qp_b = priv -> fixed_qp_p ; \n av_log ( avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , \n priv -> fixed_qp_idr , priv -> fixed_qp_p , priv -> fixed_qp_b ) ; \n return 0 ; \n }", "idx": 18234}
{"project": "FFmpeg", "commit_id": "d7cabb3c7e843c2028b398cb19a40db84d40c790", "target": 0, "func": "int ff_bgmc_init ( AVCodecContext * avctx , uint8_t * * cf_lut , int * * cf_lut_status ) \n { \n * cf_lut = av_malloc ( sizeof ( * * cf_lut ) * LUT_BUFF * 16 * LUT_SIZE ) ; \n * cf_lut_status = av_malloc ( sizeof ( * * cf_lut_status ) * LUT_BUFF ) ; \n if ( ! cf_lut || ! cf_lut_status ) { \n ff_bgmc_end ( cf_lut , cf_lut_status ) ; \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } else { \n memset ( * cf_lut_status , -1 , sizeof ( * * cf_lut_status ) * LUT_BUFF ) ; \n } \n return 0 ; \n }", "idx": 18257}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void yuv_from_cqt ( ColorFloat * c , const FFTComplex * v , float gamma , int len ) \n { \n int x ; \n for ( x = 0 ; x < len ; x ++ ) { \n float r , g , b ; \n r = calculate_gamma ( FFMIN ( 1.0f , v [ x ] . re ) , gamma ) ; \n g = calculate_gamma ( FFMIN ( 1.0f , 0.5f * ( v [ x ] . re + v [ x ] . im ) ) , gamma ) ; \n b = calculate_gamma ( FFMIN ( 1.0f , v [ x ] . im ) , gamma ) ; \n c [ x ] . yuv . y = 16.0f + 65.481f * r + 128.553f * g + 24.966f * b ; \n c [ x ] . yuv . u = 128.0f - 37.797f * r - 74.203f * g + 112.0f * b ; \n c [ x ] . yuv . v = 128.0f + 112.0f * r - 93.786f * g - 18.214 * b ; \n } \n }", "idx": 18366}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int split_field_half_ref_list ( Picture * dest , int dest_len , \n Picture * src , int src_len , int parity ) { \n int same_parity = 1 ; \n int same_i = 0 ; \n int opp_i = 0 ; \n int out_i ; \n int field_output ; \n for ( out_i = 0 ; out_i < dest_len ; out_i += field_output ) { \n if ( same_parity && same_i < src_len ) { \n field_output = split_field_copy ( dest + out_i , src + same_i , \n parity , 1 ) ; \n same_parity = ! field_output ; \n same_i ++ ; \n } else if ( opp_i < src_len ) { \n field_output = split_field_copy ( dest + out_i , src + opp_i , \n PICT_FRAME - parity , 0 ) ; \n same_parity = field_output ; \n opp_i ++ ; \n } else { \n break ; \n } \n } \n return out_i ; \n }", "idx": 18419}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void count_usage ( uint8_t * src , int width , \n int height , uint32_t * counts ) \n { \n int i , j ; \n for ( j = 0 ; j < height ; j ++ ) { \n for ( i = 0 ; i < width ; i ++ ) { \n counts [ src [ i ] ] ++ ; \n } \n src += width ; \n } \n }", "idx": 18427}
{"project": "FFmpeg", "commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "target": 1, "func": "void ff_rtp_send_hevc ( AVFormatContext * ctx , const uint8_t * frame_buf , int frame_size ) \n { \n const uint8_t * next_NAL_unit ; \n const uint8_t * buf_ptr , * buf_end = frame_buf + frame_size ; \n RTPMuxContext * rtp_ctx = ctx -> priv_data ; \n rtp_ctx -> timestamp = rtp_ctx -> cur_timestamp ; \n rtp_ctx -> buf_ptr = rtp_ctx -> buf ; \n if ( rtp_ctx -> nal_length_size ) \n buf_ptr = ff_avc_mp4_find_startcode ( frame_buf , buf_end , rtp_ctx -> nal_length_size ) ? frame_buf : buf_end ; \n else \n buf_ptr = ff_avc_find_startcode ( frame_buf , buf_end ) ; \n while ( buf_ptr < buf_end ) { \n if ( rtp_ctx -> nal_length_size ) { \n next_NAL_unit = ff_avc_mp4_find_startcode ( buf_ptr , buf_end , rtp_ctx -> nal_length_size ) ; \n if ( ! next_NAL_unit ) \n next_NAL_unit = buf_end ; \n buf_ptr += rtp_ctx -> nal_length_size ; \n } else { \n while ( ! * ( buf_ptr ++ ) ) \n ; \n next_NAL_unit = ff_avc_find_startcode ( buf_ptr , buf_end ) ; \n } \n nal_send ( ctx , buf_ptr , next_NAL_unit - buf_ptr , next_NAL_unit == buf_end ) ; \n buf_ptr = next_NAL_unit ; \n } \n flush_buffered ( ctx , 1 ) ; \n }", "idx": 18451}
{"project": "FFmpeg", "commit_id": "c9454cb643f5404ca8f4f02e1384c863136f7a9e", "target": 1, "func": "int av_tempfile ( const char * prefix , char * * filename , int log_offset , void * log_ctx ) { \n FileLogContext file_log_ctx = { & file_log_ctx_class , log_offset , log_ctx } ; \n int fd = -1 ; \n #if ! HAVE_MKSTEMP  \n  \n  void * ptr = tempnam ( NULL , prefix ) ; \n if ( ! ptr ) \n ptr = tempnam ( \" \" , prefix ) ; \n * filename = av_strdup ( ptr ) ; \n #undef  free  \n  \n  free ( ptr ) ; \n #else \n size_t len = strlen ( prefix ) + 12 ; \n * filename = av_malloc ( len ) ; \n #endif \n if ( * filename == NULL ) { \n av_log ( & file_log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n #if ! HAVE_MKSTEMP  \n  \n  #   ifndef O_BINARY \n #       define O_BINARY  0  \n  \n  #   endif \n #   ifndef O_EXCL \n #       define O_EXCL  0  \n  \n  #   endif \n fd = open ( * filename , O_RDWR | O_BINARY | O_CREAT | O_EXCL , 0600 ) ; \n #else \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n #ifdef _WIN32 \n if ( fd < 0 ) { \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n } \n #endif \n #endif \n if ( fd < 0 ) { \n int err = AVERROR ( errno ) ; \n av_log ( & file_log_ctx , AV_LOG_ERROR , \" \\n \" , * filename ) ; \n return err ; \n } \n return fd ; \n }", "idx": 18472}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void print_format_entry ( const char * tag , \n const char * val ) \n { \n if ( ! fmt_entries_to_show ) { \n if ( tag ) { \n printf ( \" \\n \" , tag , val ) ; \n } else { \n printf ( \" \\n \" , val ) ; \n } \n } else if ( tag && av_dict_get ( fmt_entries_to_show , tag , NULL , 0 ) ) { \n if ( nb_fmt_entries_to_show > 1 ) \n printf ( \" \" , tag ) ; \n printf ( \" \\n \" , val ) ; \n } \n }", "idx": 18541}
{"project": "FFmpeg", "commit_id": "6f1ccca4ae3b93b6a2a820a7a0e72081ab35767c", "target": 0, "func": "static int dnxhd_decode_dct_block_8 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n return dnxhd_decode_dct_block ( ctx , row , n , 4 , 32 , 6 ) ; \n }", "idx": 18543}
{"project": "FFmpeg", "commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "target": 1, "func": "void av_register_output_format ( AVOutputFormat * format ) \n { \n AVOutputFormat * * p = last_oformat ; \n format -> next = NULL ; \n while ( * p || avpriv_atomic_ptr_cas ( ( void * volatile * ) p , NULL , format ) ) \n p = & ( * p ) -> next ; \n last_oformat = & format -> next ; \n }", "idx": 18643}
{"project": "FFmpeg", "commit_id": "171ec812235a5d22fa421242351ee2da5a96c3ba", "target": 1, "func": "static void rv34_pred_4x4_block ( RV34DecContext * r , uint8_t * dst , int stride , int itype , int up , int left , int down , int right ) \n { \n uint8_t * prev = dst - stride + 4 ; \n uint32_t topleft ; \n if ( ! up && ! left ) \n itype = DC_128_PRED ; \n else if ( ! up ) { \n if ( itype == VERT_PRED ) itype = HOR_PRED ; \n if ( itype == DC_PRED ) itype = LEFT_DC_PRED ; \n } else if ( ! left ) { \n if ( itype == HOR_PRED ) itype = VERT_PRED ; \n if ( itype == DC_PRED ) itype = TOP_DC_PRED ; \n if ( itype == DIAG_DOWN_LEFT_PRED ) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN ; \n } \n if ( ! down ) { \n if ( itype == DIAG_DOWN_LEFT_PRED ) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN ; \n if ( itype == HOR_UP_PRED ) itype = HOR_UP_PRED_RV40_NODOWN ; \n if ( itype == VERT_LEFT_PRED ) itype = VERT_LEFT_PRED_RV40_NODOWN ; \n } \n if ( ! right && up ) { \n topleft = dst [ - stride + 3 ] * 0x01010101 ; \n prev = ( uint8_t * ) & topleft ; \n } \n r -> h . pred4x4 [ itype ] ( dst , prev , stride ) ; \n }", "idx": 18753}
{"project": "FFmpeg", "commit_id": "e2959f455850143272f3455a936dfd4d89ae9e03", "target": 0, "func": "int av_strerror ( int errnum , char * errbuf , size_t errbuf_size ) \n { \n int ret = 0 ; \n const char * errstr = NULL ; \n switch ( errnum ) { \n case AVERROR_EOF : errstr = \" \" ; break ; \n case AVERROR_INVALIDDATA : errstr = \" \" ; break ; \n case AVERROR_NUMEXPECTED : errstr = \" \" ; break ; \n case AVERROR_PATCHWELCOME : errstr = \" \" ; break ; \n } \n if ( errstr ) { \n av_strlcpy ( errbuf , errstr , errbuf_size ) ; \n } else { \n #if HAVE_STRERROR_R  \n  \n  ret = strerror_r ( AVUNERROR ( errnum ) , errbuf , errbuf_size ) ; \n #endif \n if ( ! HAVE_STRERROR_R || ret < 0 ) \n snprintf ( errbuf , errbuf_size , \" \" , errnum ) ; \n } \n return ret ; \n }", "idx": 18766}
{"project": "FFmpeg", "commit_id": "fbdaebb29861d32acc93fa55fd13554a2ae32eb4", "target": 0, "func": "static int h263_decode_gob_header ( MpegEncContext * s ) \n { \n unsigned int val , gob_number ; \n int left ; \n val = show_bits ( & s -> gb , 16 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n left = get_bits_left ( & s -> gb ) ; \n for ( ; left > 13 ; left -- ) { \n if ( get_bits1 ( & s -> gb ) ) break ; \n } \n if ( left <= 13 ) \n return -1 ; \n if ( s -> h263_slice_structured ) { \n if ( get_bits1 ( & s -> gb ) == 0 ) \n return -1 ; \n ff_h263_decode_mba ( s ) ; \n if ( s -> mb_num > 1583 ) \n if ( get_bits1 ( & s -> gb ) == 0 ) \n return -1 ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n if ( get_bits1 ( & s -> gb ) == 0 ) \n return -1 ; \n skip_bits ( & s -> gb , 2 ) ; \n } else { \n gob_number = get_bits ( & s -> gb , 5 ) ; \n s -> mb_x = 0 ; \n s -> mb_y = s -> gob_index * gob_number ; \n skip_bits ( & s -> gb , 2 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n } \n if ( s -> mb_y >= s -> mb_height ) \n return -1 ; \n if ( s -> qscale == 0 ) \n return -1 ; \n return 0 ; \n }", "idx": 18806}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n const int dc = ( src [ - stride ] + src [ 1 - stride ] + src [ 2 - stride ] + src [ 3 - stride ] \n + src [ -1 + 0 * stride ] + src [ -1 + 1 * stride ] + src [ -1 + 2 * stride ] + src [ -1 + 3 * stride ] + 4 ) >> 3 ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( dc ) ; \n }", "idx": 18828}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_write ( URLContext * h , const unsigned char * buf , int size ) \n { \n int err ; \n FTPContext * s = h -> priv_data ; \n int written ; \n av_dlog ( h , \" \\n \" , size ) ; \n if ( s -> state == DISCONNECTED ) { \n if ( ( err = ftp_connect_data_connection ( h ) ) < 0 ) \n return err ; \n } \n if ( s -> state == READY ) { \n if ( ( err = ftp_store ( s ) ) < 0 ) \n return err ; \n } \n if ( s -> conn_data && s -> state == UPLOADING ) { \n written = ffurl_write ( s -> conn_data , buf , size ) ; \n if ( written > 0 ) { \n s -> position += written ; \n s -> filesize = FFMAX ( s -> filesize , s -> position ) ; \n } \n return written ; \n } \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 18898}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static int udp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n UDPContext * s = h -> priv_data ; \n int ret ; \n #if HAVE_PTHREAD_CANCEL  \n  \n  if ( s -> fifo ) { \n uint8_t tmp [ 4 ] ; \n pthread_mutex_lock ( & s -> mutex ) ; \n if ( s -> circular_buffer_error < 0 ) { \n int err = s -> circular_buffer_error ; \n s -> circular_buffer_error = 0 ; \n pthread_mutex_unlock ( & s -> mutex ) ; \n return err ; \n } \n if ( av_fifo_space ( s -> fifo ) < size + 4 ) { \n pthread_mutex_unlock ( & s -> mutex ) ; \n return AVERROR ( ENOMEM ) ; \n } \n AV_WL32 ( tmp , size ) ; \n av_fifo_generic_write ( s -> fifo , tmp , 4 , NULL ) ; \n av_fifo_generic_write ( s -> fifo , ( uint8_t * ) buf , size , NULL ) ; \n pthread_cond_signal ( & s -> cond ) ; \n pthread_mutex_unlock ( & s -> mutex ) ; \n return size ; \n } \n #endif \n if ( ! ( h -> flags & AVIO_FLAG_NONBLOCK ) ) { \n ret = ff_network_wait_fd ( s -> udp_fd , 1 ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( ! s -> is_connected ) { \n ret = sendto ( s -> udp_fd , buf , size , 0 , \n ( struct sockaddr * ) & s -> dest_addr , \n s -> dest_addr_len ) ; \n } else \n ret = send ( s -> udp_fd , buf , size , 0 ) ; \n return ret < 0 ? ff_neterrno ( ) : ret ; \n }", "idx": 18959}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "static void compute_frame_duration ( int * pnum , int * pden , AVStream * st , \n AVCodecParserContext * pc , AVPacket * pkt ) \n { \n int frame_size ; \n * pnum = 0 ; \n * pden = 0 ; \n switch ( st -> codec -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n if ( st -> r_frame_rate . num ) { \n * pnum = st -> r_frame_rate . den ; \n * pden = st -> r_frame_rate . num ; \n } else if ( st -> time_base . num * 1000LL > st -> time_base . den ) { \n * pnum = st -> time_base . num ; \n * pden = st -> time_base . den ; \n } else if ( st -> codec -> time_base . num * 1000LL > st -> codec -> time_base . den ) { \n * pnum = st -> codec -> time_base . num ; \n * pden = st -> codec -> time_base . den ; \n if ( pc && pc -> repeat_pict ) { \n * pnum = ( * pnum ) * ( 1 + pc -> repeat_pict ) ; \n } \n if ( st -> codec -> ticks_per_frame > 1 && ! pc ) { \n * pnum = * pden = 0 ; \n } \n } \n break ; \n case AVMEDIA_TYPE_AUDIO : \n frame_size = get_audio_frame_size ( st -> codec , pkt -> size , 0 ) ; \n if ( frame_size <= 0 || st -> codec -> sample_rate <= 0 ) \n break ; \n * pnum = frame_size ; \n * pden = st -> codec -> sample_rate ; \n break ; \n default : \n break ; \n } \n }", "idx": 18965}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void seg_free_context ( SegmentContext * seg ) \n { \n avio_closep ( & seg -> pb ) ; \n avformat_free_context ( seg -> avf ) ; \n seg -> avf = NULL ; \n }", "idx": 19031}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_coc ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR_INVALIDDATA ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n c += compno ; \n c -> csty = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , c ) ; \n properties [ compno ] |= HAD_COC ; \n return 0 ; \n }", "idx": 19156}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int au_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n int64_t file_size ; \n if ( s -> pb -> seekable ) { \n file_size = avio_tell ( pb ) ; \n avio_seek ( pb , 8 , SEEK_SET ) ; \n avio_wb32 ( pb , ( uint32_t ) ( file_size - 24 ) ) ; \n avio_seek ( pb , file_size , SEEK_SET ) ; \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 19282}
{"project": "FFmpeg", "commit_id": "cdfc38f43b94e8ec3a9be10de2767778946d6eb5", "target": 1, "func": "static int xa_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MaxisXADemuxContext * xa = s -> priv_data ; \n AVStream * st = s -> streams [ 0 ] ; \n ByteIOContext * pb = s -> pb ; \n unsigned int packet_size ; \n int ret ; \n if ( xa -> sent_bytes > xa -> out_size ) \n return AVERROR ( EIO ) ; \n packet_size = 15 * st -> codec -> channels ; \n ret = av_get_packet ( pb , pkt , packet_size ) ; \n if ( ret != packet_size ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = st -> index ; \n xa -> sent_bytes += packet_size ; \n pkt -> pts = xa -> audio_frame_counter ; \n xa -> audio_frame_counter += 28 * st -> codec -> channels ; \n return ret ; \n }", "idx": 19361}
{"project": "FFmpeg", "commit_id": "0a82f5275f719e6e369a807720a2c3603aa0ddd9", "target": 1, "func": "static void lag_pred_line ( LagarithContext * l , uint8_t * buf , \n int width , int stride , int line ) \n { \n int L , TL ; \n L = buf [ width - stride - 1 ] ; \n if ( ! line ) { \n L = l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , \n width - 1 , buf [ 0 ] ) ; \n return ; \n } else if ( line == 1 ) { \n TL = l -> avctx -> pix_fmt == PIX_FMT_YUV420P ? buf [ - stride ] : L ; \n } else { \n TL = buf [ width - ( 2 * stride ) - 1 ] ; \n } \n add_lag_median_prediction ( buf , buf - stride , buf , \n width , & L , & TL ) ; \n }", "idx": 19414}
{"project": "FFmpeg", "commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "target": 1, "func": "int ff_get_cpu_flags_arm ( void ) \n { \n int flags = CORE_CPU_FLAGS ; \n uint32_t hwcap ; \n if ( get_hwcap ( & hwcap ) < 0 ) \n if ( get_cpuinfo ( & hwcap ) < 0 ) \n return flags ; \n #define check_cap ( cap , flag )  do {               \\ \n if (hwcap & HWCAP_ ## cap)              \\ \n flags |= AV_CPU_FLAG_ ## flag;      \\ \n } while (0)  \n  check_cap ( EDSP , ARMV5TE ) ; \n check_cap ( TLS , ARMV6 ) ; \n check_cap ( THUMBEE , ARMV6T2 ) ; \n check_cap ( VFP , VFP ) ; \n check_cap ( VFPv3 , VFPV3 ) ; \n check_cap ( NEON , NEON ) ; \n if ( flags & ( AV_CPU_FLAG_VFPV3 | AV_CPU_FLAG_NEON ) ) \n flags |= AV_CPU_FLAG_ARMV6T2 ; \n if ( flags & AV_CPU_FLAG_ARMV6T2 ) \n flags |= AV_CPU_FLAG_ARMV6 ; \n return flags ; \n }", "idx": 19547}
{"project": "FFmpeg", "commit_id": "09d89d940635e34b0f61266d66fbb9802b18564c", "target": 0, "func": "static void decode_subband ( DiracContext * s , GetBitContext * gb , int quant , \n int slice_x , int slice_y , int bits_end , \n SubBand * b1 , SubBand * b2 ) \n { \n int left = b1 -> width * slice_x / s -> num_x ; \n int right = b1 -> width * ( slice_x + 1 ) / s -> num_x ; \n int top = b1 -> height * slice_y / s -> num_y ; \n int bottom = b1 -> height * ( slice_y + 1 ) / s -> num_y ; \n int qfactor , qoffset ; \n uint8_t * buf1 = b1 -> ibuf + top * b1 -> stride ; \n uint8_t * buf2 = b2 ? b2 -> ibuf + top * b2 -> stride : NULL ; \n int x , y ; \n if ( quant > 115 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , quant ) ; \n return ; \n } \n qfactor = ff_dirac_qscale_tab [ quant & 0x7f ] ; \n qoffset = ff_dirac_qoffset_intra_tab [ quant & 0x7f ] + 2 ; \n if ( get_bits_count ( gb ) >= bits_end ) \n return ; \n if ( s -> pshift ) { \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n PARSE_VALUES ( int32_t , x , gb , bits_end , buf1 , buf2 ) ; \n } \n buf1 += b1 -> stride ; \n if ( buf2 ) \n buf2 += b2 -> stride ; \n } \n } \n else { \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n PARSE_VALUES ( int16_t , x , gb , bits_end , buf1 , buf2 ) ; \n } \n buf1 += b1 -> stride ; \n if ( buf2 ) \n buf2 += b2 -> stride ; \n } \n } \n }", "idx": 19625}
{"project": "FFmpeg", "commit_id": "c96bd21227e594856f8fd0610fd213b002056383", "target": 0, "func": "static int mp3_read_probe ( AVProbeData * p ) \n { \n int max_frames , first_frames = 0 ; \n int fsize , frames , sample_rate ; \n uint32_t header ; \n uint8_t * buf , * buf2 , * end ; \n AVCodecContext avctx ; \n if ( id3v2_match ( p -> buf ) ) \n return AVPROBE_SCORE_MAX / 2 + 1 ; \n max_frames = 0 ; \n buf = p -> buf ; \n end = buf + p -> buf_size - sizeof ( uint32_t ) ; \n for ( ; buf < end ; buf = buf2 + 1 ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n header = AV_RB32 ( buf2 ) ; \n fsize = ff_mpa_decode_header ( & avctx , header , & sample_rate ) ; \n if ( fsize < 0 ) \n break ; \n buf2 += fsize ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == p -> buf ) \n first_frames = frames ; \n } \n if ( first_frames >= 3 ) return AVPROBE_SCORE_MAX / 2 + 1 ; \n else if ( max_frames > 500 ) return AVPROBE_SCORE_MAX / 2 ; \n else if ( max_frames >= 3 ) return AVPROBE_SCORE_MAX / 4 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 19752}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int ljpeg_encode_yuv ( AVCodecContext * avctx , PutBitContext * pb , \n const AVFrame * frame ) \n { \n const int predictor = avctx -> prediction_method + 1 ; \n LJpegEncContext * s = avctx -> priv_data ; \n const int mb_width = ( avctx -> width + s -> hsample [ 0 ] - 1 ) / s -> hsample [ 0 ] ; \n const int mb_height = ( avctx -> height + s -> vsample [ 0 ] - 1 ) / s -> vsample [ 0 ] ; \n int mb_x , mb_y ; \n for ( mb_y = 0 ; mb_y < mb_height ; mb_y ++ ) { \n if ( pb -> buf_end - pb -> buf - ( put_bits_count ( pb ) >> 3 ) < \n mb_width * 4 * 3 * s -> hsample [ 0 ] * s -> vsample [ 0 ] ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( mb_x = 0 ; mb_x < mb_width ; mb_x ++ ) \n ljpeg_encode_yuv_mb ( s , pb , frame , predictor , mb_x , mb_y ) ; \n } \n return 0 ; \n }", "idx": 19758}
{"project": "FFmpeg", "commit_id": "c3390fd56cf55259ea7665ecea6c8aeddf56e2fc", "target": 1, "func": "static av_cold int ra144_decode_init ( AVCodecContext * avctx ) \n { \n RA144Context * ractx = avctx -> priv_data ; \n ractx -> avctx = avctx ; \n ractx -> lpc_coef [ 0 ] = ractx -> lpc_tables [ 0 ] ; \n ractx -> lpc_coef [ 1 ] = ractx -> lpc_tables [ 1 ] ; \n avctx -> channels = 1 ; \n avctx -> channel_layout = AV_CH_LAYOUT_MONO ; \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n return 0 ; \n }", "idx": 19788}
{"project": "FFmpeg", "commit_id": "a3145d0335b04d143c26832c91dcc7242c758206", "target": 0, "func": "static av_cold int bmv_aud_decode_init ( AVCodecContext * avctx ) \n { \n BMVAudioDecContext * c = avctx -> priv_data ; \n if ( avctx -> channels != 2 ) { \n av_log ( avctx , AV_LOG_INFO , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n avcodec_get_frame_defaults ( & c -> frame ) ; \n avctx -> coded_frame = & c -> frame ; \n return 0 ; \n }", "idx": 19919}
{"project": "FFmpeg", "commit_id": "29208e6dcf944bbea696d37a354a8bac9b552709", "target": 0, "func": "int av_image_fill_arrays ( uint8_t * dst_data [ 4 ] , int dst_linesize [ 4 ] , \n const uint8_t * src , \n enum AVPixelFormat pix_fmt , int width , int height , int align ) \n { \n int ret , i ; \n if ( ( ret = av_image_check_size ( width , height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = av_image_fill_linesizes ( dst_linesize , pix_fmt , width ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 ; i ++ ) \n dst_linesize [ i ] = FFALIGN ( dst_linesize [ i ] , align ) ; \n if ( ( ret = av_image_fill_pointers ( dst_data , pix_fmt , width , NULL , dst_linesize ) ) < 0 ) \n return ret ; \n return av_image_fill_pointers ( dst_data , pix_fmt , height , ( uint8_t * ) src , dst_linesize ) ; \n }", "idx": 20017}
{"project": "FFmpeg", "commit_id": "271344377a3391c1a8ccc45e021721a56f237612", "target": 1, "func": "static int mov_read_extradata ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n uint64_t size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE ; \n uint8_t * buf ; \n if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX ) \n return -1 ; \n buf = av_realloc ( st -> codec -> extradata , size ) ; \n if ( ! buf ) \n return -1 ; \n st -> codec -> extradata = buf ; \n buf += st -> codec -> extradata_size ; \n st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE ; \n AV_WB32 ( buf , atom . size + 8 ) ; \n AV_WL32 ( buf + 4 , atom . type ) ; \n get_buffer ( pb , buf + 8 , atom . size ) ; \n return 0 ; \n }", "idx": 20034}
{"project": "FFmpeg", "commit_id": "9ecf7fada31aac294dee540abb9a8dcf8131d67d", "target": 1, "func": "static void av_estimate_timings ( AVFormatContext * ic ) \n { \n int64_t file_size ; \n if ( ic -> iformat -> flags & AVFMT_NOFILE ) { \n file_size = 0 ; \n } else { \n file_size = url_fsize ( & ic -> pb ) ; \n if ( file_size < 0 ) \n file_size = 0 ; \n } \n ic -> file_size = file_size ; \n if ( ( ! strcmp ( ic -> iformat -> name , \" \" ) || \n ! strcmp ( ic -> iformat -> name , \" \" ) ) && \n file_size && ! ic -> pb . is_streamed ) { \n av_estimate_timings_from_pts ( ic ) ; \n } else if ( av_has_timings ( ic ) ) { \n fill_all_stream_timings ( ic ) ; \n } else { \n av_estimate_timings_from_bit_rate ( ic ) ; \n } \n av_update_stream_timings ( ic ) ; \n #if 0  \n  \n  { \n int i ; \n AVStream * st ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n printf ( \" \\n \" , \n i , ( double ) st -> start_time / AV_TIME_BASE , \n ( double ) st -> duration / AV_TIME_BASE ) ; \n } \n printf ( \" \\n \" , \n ( double ) ic -> start_time / AV_TIME_BASE , \n ( double ) ic -> duration / AV_TIME_BASE , \n ic -> bit_rate / 1000 ) ; \n } \n #endif \n }", "idx": 20040}
{"project": "FFmpeg", "commit_id": "436f00b10c062b75c7aab276c4a7d64524bd0444", "target": 0, "func": "static int wrapped_avframe_encode ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * frame , int * got_packet ) \n { \n AVFrame * wrapped = av_frame_clone ( frame ) ; \n if ( ! wrapped ) \n return AVERROR ( ENOMEM ) ; \n pkt -> buf = av_buffer_create ( ( uint8_t * ) wrapped , sizeof ( * wrapped ) , \n wrapped_avframe_release_buffer , NULL , \n AV_BUFFER_FLAG_READONLY ) ; \n if ( ! pkt -> buf ) { \n av_frame_free ( & wrapped ) ; \n return AVERROR ( ENOMEM ) ; \n } \n pkt -> data = ( uint8_t * ) wrapped ; \n pkt -> size = sizeof ( * wrapped ) ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n * got_packet = 1 ; \n return 0 ; \n }", "idx": 20067}
{"project": "FFmpeg", "commit_id": "fefe43ff2c180928348d445abb9696cf2581d953", "target": 1, "func": "static int mov_read_hdlr ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n uint32_t type ; \n uint32_t ctype ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n ctype = get_le32 ( pb ) ; \n type = get_le32 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , * ( ( char * ) & ctype ) , ( ( char * ) & ctype ) [ 1 ] , \n ( ( char * ) & ctype ) [ 2 ] , ( ( char * ) & ctype ) [ 3 ] , ( int ) ctype ) ; \n dprintf ( c -> fc , \" \\n \" , \n * ( ( char * ) & type ) , ( ( char * ) & type ) [ 1 ] , ( ( char * ) & type ) [ 2 ] , ( ( char * ) & type ) [ 3 ] ) ; \n if ( ! ctype ) \n c -> isom = 1 ; \n if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n else if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n else if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n st -> codec -> codec_id = CODEC_ID_MP2 ; \n else if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n st -> codec -> codec_type = CODEC_TYPE_SUBTITLE ; \n } \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n if ( atom . size <= 24 ) \n return 0 ; \n url_fskip ( pb , atom . size - ( url_ftell ( pb ) - atom . offset ) ) ; \n return 0 ; \n }", "idx": 20174}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_cryptographic_context ( MXFCryptoContext * cryptocontext , ByteIOContext * pb , int tag , int size , UID uid ) \n { \n if ( size != 16 ) \n return -1 ; \n if ( IS_KLV_KEY ( uid , mxf_crypto_source_container_ul ) ) \n get_buffer ( pb , cryptocontext -> source_container_ul , 16 ) ; \n return 0 ; \n }", "idx": 20181}
{"project": "FFmpeg", "commit_id": "2b17c7685fd3ff0bffaf3b45458d4a6283f3935f", "target": 1, "func": "static void assert_file_overwrite ( const char * filename ) \n { \n if ( file_overwrite && no_file_overwrite ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit_program ( 1 ) ; \n } \n if ( ! file_overwrite && \n ( strchr ( filename , ' ' ) == NULL || filename [ 1 ] == ' ' || \n av_strstart ( filename , \" \" , NULL ) ) ) { \n if ( avio_check ( filename , 0 ) == 0 ) { \n if ( stdin_interaction && ! no_file_overwrite ) { \n fprintf ( stderr , \" \" , filename ) ; \n fflush ( stderr ) ; \n term_exit ( ) ; \n signal ( SIGINT , SIG_DFL ) ; \n if ( ! read_yesno ( ) ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n exit_program ( 1 ) ; \n } \n term_init ( ) ; \n } \n else { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , filename ) ; \n exit_program ( 1 ) ; \n } \n } \n } \n }", "idx": 20184}
{"project": "FFmpeg", "commit_id": "182d4f1f3855460ee8634ea052f33332cf9d174e", "target": 0, "func": "static av_cold int oggvorbis_init_encoder ( vorbis_info * vi , \n AVCodecContext * avctx ) \n { \n OggVorbisContext * s = avctx -> priv_data ; \n double cfreq ; \n int ret ; \n if ( avctx -> flags & CODEC_FLAG_QSCALE ) { \n float q = avctx -> global_quality / ( float ) FF_QP2LAMBDA ; \n if ( ( ret = vorbis_encode_setup_vbr ( vi , avctx -> channels , \n avctx -> sample_rate , \n q / 10.0 ) ) ) \n goto error ; \n } else { \n int minrate = avctx -> rc_min_rate > 0 ? avctx -> rc_min_rate : -1 ; \n int maxrate = avctx -> rc_min_rate > 0 ? avctx -> rc_max_rate : -1 ; \n if ( ( ret = vorbis_encode_setup_managed ( vi , avctx -> channels , \n avctx -> sample_rate , minrate , \n avctx -> bit_rate , maxrate ) ) ) \n goto error ; \n if ( minrate == -1 && maxrate == -1 ) \n if ( ( ret = vorbis_encode_ctl ( vi , OV_ECTL_RATEMANAGE2_SET , NULL ) ) ) \n goto error ; \n } \n if ( avctx -> cutoff > 0 ) { \n cfreq = avctx -> cutoff / 1000.0 ; \n if ( ( ret = vorbis_encode_ctl ( vi , OV_ECTL_LOWPASS_SET , & cfreq ) ) ) \n goto error ; \n } \n if ( s -> iblock ) { \n if ( ( ret = vorbis_encode_ctl ( vi , OV_ECTL_IBLOCK_SET , & s -> iblock ) ) ) \n goto error ; \n } \n if ( ( ret = vorbis_encode_setup_init ( vi ) ) ) \n goto error ; \n return 0 ; \n error : \n return vorbis_error_to_averror ( ret ) ; \n }", "idx": 20243}
{"project": "FFmpeg", "commit_id": "d1b284119bd5c6a52124443de2c45dbe569c25fc", "target": 0, "func": "static int read_ir ( AVFilterLink * link , AVFrame * frame ) \n { \n AVFilterContext * ctx = link -> dst ; \n AudioFIRContext * s = ctx -> priv ; \n int nb_taps , max_nb_taps ; \n av_audio_fifo_write ( s -> fifo [ 1 ] , ( void * * ) frame -> extended_data , \n frame -> nb_samples ) ; \n av_frame_free ( & frame ) ; \n nb_taps = av_audio_fifo_size ( s -> fifo [ 1 ] ) ; \n max_nb_taps = MAX_IR_DURATION * ctx -> outputs [ 0 ] -> sample_rate ; \n if ( nb_taps > max_nb_taps ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , nb_taps , max_nb_taps ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 20385}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int blah ( int32_t i ) \n { \n if ( i > 0x43c07fff ) \n return 32767 ; \n else if ( i < 0x43bf8000 ) \n return -32768 ; \n else \n return i - 0x43c00000 ; \n }", "idx": 20536}
{"project": "FFmpeg", "commit_id": "fbd91d7cad28915dd7e6061b869b22171ca84101", "target": 1, "func": "static int decode_tns ( AACContext * ac , TemporalNoiseShaping * tns , \n GetBitContext * gb , const IndividualChannelStream * ics ) { \n int w , filt , i , coef_len , coef_res , coef_compress ; \n const int is8 = ics -> window_sequence [ 0 ] == EIGHT_SHORT_SEQUENCE ; \n const int tns_max_order = is8 ? 7 : ac -> m4ac . object_type == AOT_AAC_MAIN ? 20 : 12 ; \n for ( w = 0 ; w < ics -> num_windows ; w ++ ) { \n tns -> n_filt [ w ] = get_bits ( gb , 2 - is8 ) ; \n if ( tns -> n_filt [ w ] ) \n coef_res = get_bits1 ( gb ) ; \n for ( filt = 0 ; filt < tns -> n_filt [ w ] ; filt ++ ) { \n int tmp2_idx ; \n tns -> length [ w ] [ filt ] = get_bits ( gb , 6 - 2 * is8 ) ; \n if ( ( tns -> order [ w ] [ filt ] = get_bits ( gb , 5 - 2 * is8 ) ) > tns_max_order ) { \n av_log ( ac -> avccontext , AV_LOG_ERROR , \" \" , \n tns -> order [ w ] [ filt ] , tns_max_order ) ; \n tns -> order [ w ] [ filt ] = 0 ; \n return -1 ; \n } \n tns -> direction [ w ] [ filt ] = get_bits1 ( gb ) ; \n coef_compress = get_bits1 ( gb ) ; \n coef_len = coef_res + 3 - coef_compress ; \n tmp2_idx = 2 * coef_compress + coef_res ; \n for ( i = 0 ; i < tns -> order [ w ] [ filt ] ; i ++ ) \n tns -> coef [ w ] [ filt ] [ i ] = tns_tmp2_map [ tmp2_idx ] [ get_bits ( gb , coef_len ) ] ; \n } \n } \n return 0 ; \n }", "idx": 20596}
{"project": "FFmpeg", "commit_id": "ecf79c4d3e8baaf2f303278ef81db6f8407656bc", "target": 1, "func": "void ff_vorbis_ready_floor1_list ( vorbis_floor1_entry * list , int values ) \n { \n int i ; \n list [ 0 ] . sort = 0 ; \n list [ 1 ] . sort = 1 ; \n for ( i = 2 ; i < values ; i ++ ) { \n int j ; \n list [ i ] . low = 0 ; \n list [ i ] . high = 1 ; \n list [ i ] . sort = i ; \n for ( j = 2 ; j < i ; j ++ ) { \n int tmp = list [ j ] . x ; \n if ( tmp < list [ i ] . x ) { \n if ( tmp > list [ list [ i ] . low ] . x ) \n list [ i ] . low = j ; \n } else { \n if ( tmp < list [ list [ i ] . high ] . x ) \n list [ i ] . high = j ; \n } \n } \n } \n for ( i = 0 ; i < values - 1 ; i ++ ) { \n int j ; \n for ( j = i + 1 ; j < values ; j ++ ) { \n if ( list [ list [ i ] . sort ] . x > list [ list [ j ] . sort ] . x ) { \n int tmp = list [ i ] . sort ; \n list [ i ] . sort = list [ j ] . sort ; \n list [ j ] . sort = tmp ; \n } \n } \n } \n }", "idx": 20670}
{"project": "FFmpeg", "commit_id": "8babfc033ecb6332155c1f8879e54dee41d16952", "target": 1, "func": "static av_cold void init_cavlc_level_tab ( void ) { \n int suffix_length , mask ; \n unsigned int i ; \n for ( suffix_length = 0 ; suffix_length < 7 ; suffix_length ++ ) { \n for ( i = 0 ; i < ( 1 << LEVEL_TAB_BITS ) ; i ++ ) { \n int prefix = LEVEL_TAB_BITS - av_log2 ( 2 * i ) ; \n int level_code = ( prefix << suffix_length ) + ( i >> ( LEVEL_TAB_BITS - prefix - 1 - suffix_length ) ) - ( 1 << suffix_length ) ; \n mask = - ( level_code & 1 ) ; \n level_code = ( ( ( 2 + level_code ) >> 1 ) ^ mask ) - mask ; \n if ( prefix + 1 + suffix_length <= LEVEL_TAB_BITS ) { \n cavlc_level_tab [ suffix_length ] [ i ] [ 0 ] = level_code ; \n cavlc_level_tab [ suffix_length ] [ i ] [ 1 ] = prefix + 1 + suffix_length ; \n } else if ( prefix + 1 <= LEVEL_TAB_BITS ) { \n cavlc_level_tab [ suffix_length ] [ i ] [ 0 ] = prefix + 100 ; \n cavlc_level_tab [ suffix_length ] [ i ] [ 1 ] = prefix + 1 ; \n } else { \n cavlc_level_tab [ suffix_length ] [ i ] [ 0 ] = LEVEL_TAB_BITS + 100 ; \n cavlc_level_tab [ suffix_length ] [ i ] [ 1 ] = LEVEL_TAB_BITS ; \n } \n } \n } \n }", "idx": 20712}
{"project": "FFmpeg", "commit_id": "ce7098b8f2b59c62b5abdb3d74819db75cf67698", "target": 1, "func": "static void yuv_a_to_rgba ( const uint8_t * ycbcr , const uint8_t * alpha , uint32_t * rgba , int num_values ) \n { \n const uint8_t * cm = ff_crop_tab + MAX_NEG_CROP ; \n uint8_t r , g , b ; \n int i , y , cb , cr ; \n int r_add , g_add , b_add ; \n for ( i = num_values ; i > 0 ; i -- ) { \n y = * ycbcr ++ ; \n cr = * ycbcr ++ ; \n cb = * ycbcr ++ ; \n YUV_TO_RGB1_CCIR ( cb , cr ) ; \n YUV_TO_RGB2_CCIR ( r , g , b , y ) ; \n * rgba ++ = ( * alpha ++ << 24 ) | ( r << 16 ) | ( g << 8 ) | b ; \n } \n }", "idx": 20720}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_0l0_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 = 0 ; \n uint64_t out0 , out1 ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src0 += src [ ( 4 + lp_cnt ) * stride - 1 ] ; \n } \n src0 = ( src0 + 2 ) >> 2 ; \n out0 = 0x8080808080808080 ; \n out1 = src0 * 0x0101010101010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SD ( out0 , src ) ; \n SD ( out1 , src + stride * 4 ) ; \n src += stride ; \n } \n }", "idx": 20773}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static void srt_to_ass ( AVCodecContext * avctx , AVBPrint * dst , \n const char * in , int x1 , int y1 , int x2 , int y2 ) \n { \n if ( x1 >= 0 && y1 >= 0 ) { \n if ( x2 >= 0 && y2 >= 0 && ( x2 != x1 || y2 != y1 ) && x2 >= x1 && y2 >= y1 ) { \n const int cx = x1 + ( x2 - x1 ) / 2 ; \n const int cy = y1 + ( y2 - y1 ) / 2 ; \n const int scaled_x = cx * ( int64_t ) ASS_DEFAULT_PLAYRESX / 720 ; \n const int scaled_y = cy * ( int64_t ) ASS_DEFAULT_PLAYRESY / 480 ; \n av_bprintf ( dst , \" \\\\ \\\\ \" , scaled_x , scaled_y ) ; \n } else { \n const int scaled_x = x1 * ( int64_t ) ASS_DEFAULT_PLAYRESX / 720 ; \n const int scaled_y = y1 * ( int64_t ) ASS_DEFAULT_PLAYRESY / 480 ; \n av_bprintf ( dst , \" \\\\ \\\\ \" , scaled_x , scaled_y ) ; \n } \n } \n ff_htmlmarkup_to_ass ( avctx , dst , in ) ; \n }", "idx": 20777}
{"project": "FFmpeg", "commit_id": "161ccdaa06d1d109e8f77d2535bda11ce02720f5", "target": 0, "func": "static int msvideo1_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n Msvideo1Context * s = avctx -> priv_data ; \n int ret ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) \n return ret ; \n if ( s -> mode_8bit ) { \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n if ( pal ) { \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n s -> frame -> palette_has_changed = 1 ; \n } \n } \n if ( s -> mode_8bit ) \n msvideo1_decode_8bit ( s ) ; \n else \n msvideo1_decode_16bit ( s ) ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n * got_frame = 1 ; \n return buf_size ; \n }", "idx": 20779}
{"project": "FFmpeg", "commit_id": "e24c31b656254b2516befbde78aeaca0122a6010", "target": 1, "func": "int ff_dirac_golomb_read_32bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int32_t * dst = ( int32_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res , 0 , 0 ) ; \n #define APPEND_RESIDUE ( N , M )          \\ \n  \n  N |= M >> ( N ##  _bits ) ; \n N ##  _bits += ( M ##  _bits )  \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n res_bits = res = 0 ; \n } \n memcpy ( & dst [ c_idx ] , l -> ready , LUT_BITS * sizeof ( int32_t ) ) ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 20869}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static void ssim_4x4x2_core ( const uint8_t * main , int main_stride , \n const uint8_t * ref , int ref_stride , \n int sums [ 2 ] [ 4 ] ) \n { \n int x , y , z ; \n for ( z = 0 ; z < 2 ; z ++ ) { \n uint32_t s1 = 0 , s2 = 0 , ss = 0 , s12 = 0 ; \n for ( y = 0 ; y < 4 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ ) { \n int a = main [ x + y * main_stride ] ; \n int b = ref [ x + y * ref_stride ] ; \n s1 += a ; \n s2 += b ; \n ss += a * a ; \n ss += b * b ; \n s12 += a * b ; \n } \n } \n sums [ z ] [ 0 ] = s1 ; \n sums [ z ] [ 1 ] = s2 ; \n sums [ z ] [ 2 ] = ss ; \n sums [ z ] [ 3 ] = s12 ; \n main += 4 ; \n ref += 4 ; \n } \n }", "idx": 20992}
{"project": "FFmpeg", "commit_id": "088ed4d636e3065bf4fc67ef11bfe8592bcd8c0e", "target": 1, "func": "static Picture * remove_short ( H264Context * h , int frame_num ) { \n MpegEncContext * const s = & h -> s ; \n int i ; \n if ( s -> avctx -> debug & FF_DEBUG_MMCO ) \n av_log ( h -> s . avctx , AV_LOG_DEBUG , \" \\n \" , frame_num , h -> short_ref_count ) ; \n for ( i = 0 ; i < h -> short_ref_count ; i ++ ) { \n Picture * pic = h -> short_ref [ i ] ; \n if ( s -> avctx -> debug & FF_DEBUG_MMCO ) \n av_log ( h -> s . avctx , AV_LOG_DEBUG , \" \\n \" , i , pic -> frame_num , pic ) ; \n if ( pic -> frame_num == frame_num ) { \n h -> short_ref [ i ] = NULL ; \n memmove ( & h -> short_ref [ i ] , & h -> short_ref [ i + 1 ] , ( h -> short_ref_count - i - 1 ) * sizeof ( Picture * ) ) ; \n h -> short_ref_count -- ; \n return pic ; \n } \n } \n return NULL ; \n }", "idx": 21059}
{"project": "FFmpeg", "commit_id": "f141b353e60f1081185927a1e74a9ab46cae8bef", "target": 1, "func": "static void celt_search_for_dual_stereo ( OpusPsyContext * s , CeltFrame * f ) \n { \n float td1 , td2 ; \n f -> dual_stereo = 0 ; \n bands_dist ( s , f , & td1 ) ; \n f -> dual_stereo = 1 ; \n bands_dist ( s , f , & td2 ) ; \n f -> dual_stereo = td2 < td1 ; \n s -> dual_stereo_used += td2 < td1 ; \n }", "idx": 21176}
{"project": "FFmpeg", "commit_id": "505cb8e390f275830f5f387020207aaf267be800", "target": 1, "func": "static void ogg_free ( AVFormatContext * s ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n OGGStreamContext * oggstream = st -> priv_data ; \n if ( st -> codecpar -> codec_id == AV_CODEC_ID_FLAC || \n st -> codecpar -> codec_id == AV_CODEC_ID_SPEEX || \n st -> codecpar -> codec_id == AV_CODEC_ID_OPUS || \n st -> codecpar -> codec_id == AV_CODEC_ID_VP8 ) { \n av_freep ( & oggstream -> header [ 0 ] ) ; \n } \n av_freep ( & oggstream -> header [ 1 ] ) ; \n av_freep ( & st -> priv_data ) ; \n } \n }", "idx": 21290}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_pad_color ( const char * arg ) { \n int rgb = strtol ( arg , NULL , 16 ) ; \n int r , g , b ; \n r = ( rgb >> 16 ) ; \n g = ( ( rgb >> 8 ) & 255 ) ; \n b = ( rgb & 255 ) ; \n padcolor [ 0 ] = RGB_TO_Y ( r , g , b ) ; \n padcolor [ 1 ] = RGB_TO_U ( r , g , b , 0 ) ; \n padcolor [ 2 ] = RGB_TO_V ( r , g , b , 0 ) ; \n }", "idx": 21586}
{"project": "FFmpeg", "commit_id": "52c959a2376614e4c9089145b8ee69334b663257", "target": 1, "func": "static int read_channels ( AVFilterContext * ctx , int channels , uint8_t * item_str , int * nb , double * * c , double * * cache ) \n { \n char * p , * arg , * old_str , * prev_arg = NULL , * saveptr = NULL ; \n int i , ret ; \n p = old_str = av_strdup ( item_str ) ; \n if ( ! p ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < channels ; i ++ ) { \n if ( ! ( arg = av_strtok ( p , \" \" , & saveptr ) ) ) \n arg = prev_arg ; \n p = NULL ; \n count_coefficients ( arg , & nb [ i ] ) ; \n cache [ i ] = av_calloc ( nb [ i ] , sizeof ( cache [ i ] ) ) ; \n c [ i ] = av_calloc ( nb [ i ] , sizeof ( c [ i ] ) ) ; \n if ( ! c [ i ] || ! cache [ i ] ) \n return AVERROR ( ENOMEM ) ; \n ret = read_coefficients ( ctx , arg , nb [ i ] , c [ i ] ) ; \n if ( ret < 0 ) \n return ret ; \n prev_arg = arg ; \n } \n av_freep ( & old_str ) ; \n return 0 ; \n }", "idx": 21589}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_decode_end ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n avctx -> release_buffer ( avctx , & s -> last_frame ) ; \n av_free ( s -> buffer1 ) ; \n av_free ( s -> buffer2 ) ; \n return 0 ; \n }", "idx": 21607}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int apc_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 8 ) \n return 0 ; \n if ( ! strncmp ( p -> buf , \" \" , 8 ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 21664}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static int init_er ( MpegEncContext * s ) \n { \n ERContext * er = & s -> er ; \n int mb_array_size = s -> mb_height * s -> mb_stride ; \n int i ; \n er -> avctx = s -> avctx ; \n er -> mecc = & s -> mecc ; \n er -> mb_index2xy = s -> mb_index2xy ; \n er -> mb_num = s -> mb_num ; \n er -> mb_width = s -> mb_width ; \n er -> mb_height = s -> mb_height ; \n er -> mb_stride = s -> mb_stride ; \n er -> b8_stride = s -> b8_stride ; \n er -> er_temp_buffer = av_malloc ( s -> mb_height * s -> mb_stride ) ; \n er -> error_status_table = av_mallocz ( mb_array_size ) ; \n if ( ! er -> er_temp_buffer || ! er -> error_status_table ) \n goto fail ; \n er -> mbskip_table = s -> mbskip_table ; \n er -> mbintra_table = s -> mbintra_table ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> dc_val ) ; i ++ ) \n er -> dc_val [ i ] = s -> dc_val [ i ] ; \n er -> decode_mb = mpeg_er_decode_mb ; \n er -> opaque = s ; \n return 0 ; \n fail : \n av_freep ( & er -> er_temp_buffer ) ; \n av_freep ( & er -> error_status_table ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 21760}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xbm_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 21765}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "func": "int ff_lzw_decode_init ( LZWState * p , int csize , uint8_t * buf , int buf_size , int mode ) \n { \n struct LZWState * s = ( struct LZWState * ) p ; \n if ( csize < 1 || csize > LZW_MAXBITS ) \n return -1 ; \n s -> eob_reached = 0 ; \n s -> pbuf = buf ; \n s -> ebuf = s -> pbuf + buf_size ; \n s -> bbuf = 0 ; \n s -> bbits = 0 ; \n s -> bs = 0 ; \n s -> codesize = csize ; \n s -> cursize = s -> codesize + 1 ; \n s -> curmask = mask [ s -> cursize ] ; \n s -> top_slot = 1 << s -> cursize ; \n s -> clear_code = 1 << s -> codesize ; \n s -> end_code = s -> clear_code + 1 ; \n s -> slot = s -> newcodes = s -> clear_code + 2 ; \n s -> oc = s -> fc = 0 ; \n s -> sp = s -> stack ; \n s -> mode = mode ; \n switch ( s -> mode ) { \n case FF_LZW_GIF : \n s -> extra_slot = 0 ; \n break ; \n case FF_LZW_TIFF : \n s -> extra_slot = 1 ; \n break ; \n default : \n return -1 ; \n } \n return 0 ; \n }", "idx": 21815}
{"project": "FFmpeg", "commit_id": "7dd44cde2abb156710f26a08b6cd6c8dd9a9793d", "target": 0, "func": "static void sub2video_update ( InputStream * ist , AVSubtitle * sub ) \n { \n AVFrame * frame = ist -> sub2video . frame ; \n int8_t * dst ; \n int dst_linesize ; \n int num_rects , i ; \n int64_t pts , end_pts ; \n if ( ! frame ) \n return ; \n if ( sub ) { \n pts = av_rescale_q ( sub -> pts + sub -> start_display_time * 1000LL , \n AV_TIME_BASE_Q , ist -> st -> time_base ) ; \n end_pts = av_rescale_q ( sub -> pts + sub -> end_display_time * 1000LL , \n AV_TIME_BASE_Q , ist -> st -> time_base ) ; \n num_rects = sub -> num_rects ; \n } else { \n pts = ist -> sub2video . end_pts ; \n end_pts = INT64_MAX ; \n num_rects = 0 ; \n } \n if ( sub2video_get_blank_frame ( ist ) < 0 ) { \n av_log ( ist -> dec_ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return ; \n } \n dst = frame -> data [ 0 ] ; \n dst_linesize = frame -> linesize [ 0 ] ; \n for ( i = 0 ; i < num_rects ; i ++ ) \n sub2video_copy_rect ( dst , dst_linesize , frame -> width , frame -> height , sub -> rects [ i ] ) ; \n sub2video_push_ref ( ist , pts ) ; \n ist -> sub2video . end_pts = end_pts ; \n }", "idx": 21843}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_butterflies_float ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 ) \n { \n LOCAL_ALIGNED ( 32 , float , cv1 ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , cv2 ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , ov1 ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , ov2 ,  [ LEN ] ) ; \n int ret ; \n memcpy ( cv1 , v1 , LEN * sizeof ( * v1 ) ) ; \n memcpy ( cv2 , v2 , LEN * sizeof ( * v2 ) ) ; \n memcpy ( ov1 , v1 , LEN * sizeof ( * v1 ) ) ; \n memcpy ( ov2 , v2 , LEN * sizeof ( * v2 ) ) ; \n cdsp -> butterflies_float ( cv1 , cv2 , LEN ) ; \n fdsp -> butterflies_float ( ov1 , ov2 , LEN ) ; \n if ( ( ret = compare_floats ( cv1 , ov1 , LEN , FLT_EPSILON ) ) || \n ( ret = compare_floats ( cv2 , ov2 , LEN , FLT_EPSILON ) ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 21883}
{"project": "FFmpeg", "commit_id": "5faf168940d6a9787552637c260b18329453bda3", "target": 0, "func": "static int64_t mpegps_read_dts ( AVFormatContext * s , int stream_index , \n int64_t * ppos , int64_t pos_limit ) \n { \n int len , startcode ; \n int64_t pos , pts , dts ; \n pos = * ppos ; \n #ifdef DEBUG_SEEK \n printf ( \" \" PRIx64 \" \" , pos , find_next ) ; \n #endif \n url_fseek ( s -> pb , pos , SEEK_SET ) ; \n for ( ; ; ) { \n len = mpegps_read_pes_header ( s , & pos , & startcode , & pts , & dts ) ; \n if ( len < 0 ) { \n #ifdef DEBUG_SEEK \n printf ( \" \\n \" , len ) ; \n #endif \n return AV_NOPTS_VALUE ; \n } \n if ( startcode == s -> streams [ stream_index ] -> id && \n dts != AV_NOPTS_VALUE ) { \n break ; \n } \n url_fskip ( s -> pb , len ) ; \n } \n #ifdef DEBUG_SEEK \n printf ( \" \" PRIx64 \" \" PRIx64 \" \\n \" , pos , dts , dts / 90000.0 ) ; \n #endif \n * ppos = pos ; \n return dts ; \n }", "idx": 21885}
{"project": "FFmpeg", "commit_id": "a5398aa56cfbf80acb409451cd807660402a34d4", "target": 1, "func": "static int hevc_init ( AVCodecParserContext * s ) \n { \n HEVCContext * h = & ( ( HEVCParseContext * ) s -> priv_data ) -> h ; \n h -> HEVClc = av_mallocz ( sizeof ( HEVCLocalContext ) ) ; \n h -> skipped_bytes_pos_size = INT_MAX ; \n return 0 ; \n }", "idx": 21948}
{"project": "FFmpeg", "commit_id": "ebfcf31ddf654b6e44c8cebb51bfe0ba0964b33e", "target": 1, "func": "matroska_probe ( AVProbeData * p )  \n { \n uint64_t total = 0 ; \n int len_mask = 0x80 , size = 1 , n = 1 ; \n uint8_t probe_data [ ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' } ; \n if ( p -> buf_size < 5 ) \n return 0 ; \n if ( ( p -> buf [ 0 ] << 24 | p -> buf [ 1 ] << 16 | \n p -> buf [ 2 ] << 8 | p -> buf [ 3 ] ) != EBML_ID_HEADER ) \n return 0 ; \n total = p -> buf [ 4 ] ; \n while ( size <= 8 && ! ( total & len_mask ) ) { \n size ++ ; \n len_mask >>= 1 ; \n } \n if ( size > 8 ) \n return 0 ; \n total &= ( len_mask - 1 ) ; \n while ( n < size ) \n total = ( total << 8 ) | p -> buf [ 4 + n ++ ] ; \n if ( p -> buf_size < 4 + size + total ) \n return 0 ; \n for ( n = 4 + size ; n < 4 + size + total - sizeof ( probe_data ) ; n ++ ) \n if ( ! memcmp ( & p -> buf [ n ] , probe_data , sizeof ( probe_data ) ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 21951}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred16x16_vertical ) ( uint8_t * _src , int _stride ) { \n int i ; \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n const pixel4 a = ( ( pixel4 * ) ( src - stride ) ) [ 0 ] ; \n const pixel4 b = ( ( pixel4 * ) ( src - stride ) ) [ 1 ] ; \n const pixel4 c = ( ( pixel4 * ) ( src - stride ) ) [ 2 ] ; \n const pixel4 d = ( ( pixel4 * ) ( src - stride ) ) [ 3 ] ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = a ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = b ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 2 ] = c ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 3 ] = d ; \n } \n }", "idx": 21972}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_pal8 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n const unsigned char * p ; \n unsigned char * q ; \n int r , g , b , dst_wrap , src_wrap ; \n int x , y , i ; \n static const uint8_t pal_value [ 6 ] = { 0x00 , 0x33 , 0x66 , 0x99 , 0xcc , 0xff } ; \n uint32_t * pal ; \n p = src -> data [ 0 ] ; \n src_wrap = src -> linesize [ 0 ] - 3 * width ; \n q = dst -> data [ 0 ] ; \n dst_wrap = dst -> linesize [ 0 ] - width ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n r = p [ 0 ] ; \n g = p [ 1 ] ; \n b = p [ 2 ] ; \n q [ 0 ] = gif_clut_index ( r , g , b ) ; \n q ++ ; \n p += 3 ; \n } \n p += src_wrap ; \n q += dst_wrap ; \n } \n pal = ( uint32_t * ) dst -> data [ 1 ] ; \n i = 0 ; \n for ( r = 0 ; r < 6 ; r ++ ) { \n for ( g = 0 ; g < 6 ; g ++ ) { \n for ( b = 0 ; b < 6 ; b ++ ) { \n pal [ i ++ ] = ( 0xff << 24 ) | ( pal_value [ r ] << 16 ) | \n ( pal_value [ g ] << 8 ) | pal_value [ b ] ; \n } \n } \n } \n while ( i < 256 ) \n pal [ i ++ ] = 0 ; \n }", "idx": 21974}
{"project": "FFmpeg", "commit_id": "23edd41a0d6994cb5d9983d8f035e8eef78960ad", "target": 1, "func": "static void decode ( AVCodecContext * dec_ctx , AVFrame * frame , AVPacket * pkt , \n const char * filename ) \n { \n char buf [ 1024 ] ; \n int ret ; \n ret = avcodec_send_packet ( dec_ctx , pkt ) ; \n if ( ret < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n while ( ret >= 0 ) { \n ret = avcodec_receive_frame ( dec_ctx , frame ) ; \n if ( ret == AVERROR ( EAGAIN ) || ret == AVERROR_EOF ) \n return ; \n else if ( ret < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n printf ( \" \\n \" , dec_ctx -> frame_number ) ; \n fflush ( stdout ) ; \n snprintf ( buf , sizeof ( buf ) , filename , dec_ctx -> frame_number ) ; \n pgm_save ( frame -> data [ 0 ] , frame -> linesize [ 0 ] , \n frame -> width , frame -> height , buf ) ; \n } \n }", "idx": 22043}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_header ( AVFormatContext * s ) \n { \n int i ; \n double start = 0.0 ; \n WebMDashMuxContext * w = s -> priv_data ; \n parse_adaptation_sets ( s ) ; \n write_header ( s ) ; \n avio_printf ( s -> pb , \" \\\" \\\" \" ) ; \n avio_printf ( s -> pb , \" \\\" \\\" \" , start ) ; \n if ( ! w -> is_live ) { \n avio_printf ( s -> pb , \" \\\" \\\" \" , get_duration ( s ) ) ; \n } \n avio_printf ( s -> pb , \" \\n \" ) ; \n for ( i = 0 ; i < w -> nb_as ; i ++ ) { \n if ( write_adaptation_set ( s , i ) < 0 ) return -1 ; \n } \n avio_printf ( s -> pb , \" \\n \" ) ; \n write_footer ( s ) ; \n return 0 ; \n }", "idx": 22124}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static inline int writer_print_string ( WriterContext * wctx , \n const char * key , const char * val , int opt ) \n { \n const struct section * section = wctx -> section [ wctx -> level ] ; \n int ret = 0 ; \n if ( opt && ! ( wctx -> writer -> flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS ) ) \n return 0 ; \n if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { \n wctx -> writer -> print_string ( wctx , key , val ) ; \n wctx -> nb_item [ wctx -> level ] ++ ; \n } \n return ret ; \n }", "idx": 22273}
{"project": "FFmpeg", "commit_id": "dbe29db8cb09fb39bd8dc5b25934e92279d0aa8d", "target": 1, "func": "static int skip_data_stream_element ( AACContext * ac , GetBitContext * gb ) \n { \n int byte_align = get_bits1 ( gb ) ; \n int count = get_bits ( gb , 8 ) ; \n if ( count == 255 ) \n count += get_bits ( gb , 8 ) ; \n if ( byte_align ) \n align_get_bits ( gb ) ; \n if ( get_bits_left ( gb ) < 8 * count ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , overread_err ) ; \n return -1 ; \n } \n skip_bits_long ( gb , 8 * count ) ; \n return 0 ; \n }", "idx": 22442}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * inbuf ) \n { \n AudioPhaserContext * s = inlink -> dst -> priv ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFrame * outbuf ; \n if ( av_frame_is_writable ( inbuf ) ) { \n outbuf = inbuf ; \n } else { \n outbuf = ff_get_audio_buffer ( inlink , inbuf -> nb_samples ) ; \n if ( ! outbuf ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( outbuf , inbuf ) ; \n } \n s -> phaser ( s , inbuf -> extended_data , outbuf -> extended_data , \n outbuf -> nb_samples , outbuf -> channels ) ; \n if ( inbuf != outbuf ) \n av_frame_free ( & inbuf ) ; \n return ff_filter_frame ( outlink , outbuf ) ; \n }", "idx": 22445}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int decode_i_picture_header ( VC9Context * v ) \n { \n int pqindex , status = 0 , ac_pred , condover ; \n if ( v -> profile <= PROFILE_MAIN && get_bits ( & v -> gb , 7 ) ) \n { \n av_log ( v , AV_LOG_DEBUG , \" \\n \" ) ; \n } \n pqindex = get_bits ( & v -> gb , 5 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_IMPLICIT ) \n v -> pq = pquant_table [ 0 ] [ pqindex ] ; \n else \n { \n v -> pq = pquant_table [ v -> quantizer_mode - 1 ] [ pqindex ] ; \n } \n if ( pqindex < 9 ) v -> halfpq = get_bits ( & v -> gb , 1 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_EXPLICIT ) \n v -> pquantizer = get_bits ( & v -> gb , 1 ) ; \n av_log ( v -> avctx , AV_LOG_DEBUG , \" \\n \" , \n v -> pq , v -> halfpq ) ; \n #if HAS_ADVANCED_PROFILE  \n  \n  if ( v -> profile <= PROFILE_MAIN ) \n #endif \n { \n if ( v -> extended_mv ) v -> mvrange = get_prefix ( & v -> gb , 0 , 3 ) ; \n if ( v -> multires ) v -> respic = get_bits ( & v -> gb , 2 ) ; \n } \n #if HAS_ADVANCED_PROFILE  \n  \n  else \n { \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n if ( v -> postprocflag ) v -> postproc = get_bits ( & v -> gb , 1 ) ; \n if ( v -> overlap && v -> pq < 9 ) \n { \n condover = get_bits ( & v -> gb , 1 ) ; \n if ( condover ) \n { \n condover = 2 + get_bits ( & v -> gb , 1 ) ; \n if ( condover == 3 ) \n status = bitplane_decoding ( v -> over_flags_plane , \n v -> width_mb , v -> height_mb , v ) ; \n } \n } \n } \n #endif \n return status ;  \n }", "idx": 22479}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static char * time_value_string ( char * buf , int buf_size , int64_t val , const AVRational * time_base ) \n { \n if ( val == AV_NOPTS_VALUE ) { \n snprintf ( buf , buf_size , \" \" ) ; \n } else { \n double d = val * av_q2d ( * time_base ) ; \n value_string ( buf , buf_size , ( struct unit_value ) { . val . d = d , . unit = unit_second_str } ) ; \n } \n return buf ; \n }", "idx": 22511}
{"project": "FFmpeg", "commit_id": "625b582d5a9196c582e7702b542b3e0face30ccf", "target": 0, "func": "static int read_sbr_single_channel_element ( AACContext * ac , \n SpectralBandReplication * sbr , \n GetBitContext * gb ) \n { \n int ret ; \n if ( get_bits1 ( gb ) ) \n skip_bits ( gb , 4 ) ; \n if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) \n return -1 ; \n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ; \n if ( ( ret = read_sbr_noise ( ac , sbr , gb , & sbr -> data [ 0 ] , 0 ) ) < 0 ) \n return ret ; \n if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) \n get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ; \n return 0 ; \n }", "idx": 22565}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * swscale_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 22573}
{"project": "FFmpeg", "commit_id": "a2f7314ba231cde459c4f33f1a7602ae9d9d2d28", "target": 1, "func": "static inline void RENAME ( duplicate ) ( uint8_t src [ ] , int stride ) \n { \n #if TEMPLATE_PP_MMX  \n  \n  __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( src ) \n : \" \" ( ( x86_reg ) - stride ) \n ) ; \n #else \n int i ; \n uint8_t * p = src ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n p -= stride ; \n memcpy ( p , src , 8 ) ; \n } \n #endif \n }", "idx": 22591}
{"project": "FFmpeg", "commit_id": "87ecefdab0097537c5c30014e57b19113ab05eee", "target": 1, "func": "static void evaluate_utility_inc ( elbg_data * elbg ) \n { \n int i , inc = 0 ; \n for ( i = 0 ; i < elbg -> numCB ; i ++ ) { \n if ( elbg -> numCB * elbg -> utility [ i ] > elbg -> error ) \n inc += elbg -> utility [ i ] ; \n elbg -> utility_inc [ i ] = inc ; \n } \n }", "idx": 22626}
{"project": "FFmpeg", "commit_id": "88281a5256f0034451c09acab3aff44acb43c2a3", "target": 0, "func": "static int nppscale_query_formats ( AVFilterContext * ctx ) \n { \n static const enum AVPixelFormat pixel_formats [ ] = { \n AV_PIX_FMT_CUDA , AV_PIX_FMT_NONE , \n } ; \n AVFilterFormats * pix_fmts = ff_make_format_list ( pixel_formats ) ; \n ff_set_common_formats ( ctx , pix_fmts ) ; \n return 0 ; \n }", "idx": 22697}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "static void delete_next_frame ( AudioFrameQueue * afq ) \n { \n AudioFrame * f = afq -> frame_queue ; \n if ( f ) { \n afq -> frame_queue = f -> next ; \n f -> next = NULL ; \n av_freep ( & f ) ; \n } \n }", "idx": 22699}
{"project": "FFmpeg", "commit_id": "083300bea935d125b83f60d7030f78a7ffb0f3df", "target": 1, "func": "int ff_thread_get_buffer ( AVCodecContext * avctx , ThreadFrame * f , int flags ) \n { \n f -> owner = avctx ; \n return ff_get_buffer ( avctx , f -> f , flags ) ; \n }", "idx": 22710}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_msmpeg4_encode_init ( MpegEncContext * s ) \n { \n static int init_done = 0 ; \n int i ; \n common_init ( s ) ; \n if ( s -> msmpeg4_version >= 4 ) { \n s -> min_qcoeff = -255 ; \n s -> max_qcoeff = 255 ; \n } \n if ( ! init_done ) { \n init_done = 1 ; \n init_mv_table ( & mv_tables [ 0 ] ) ; \n init_mv_table ( & mv_tables [ 1 ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) \n init_rl ( & rl_table [ i ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) { \n int level ; \n for ( level = 0 ; level <= MAX_LEVEL ; level ++ ) { \n int run ; \n for ( run = 0 ; run <= MAX_RUN ; run ++ ) { \n int last ; \n for ( last = 0 ; last < 2 ; last ++ ) { \n rl_length [ i ] [ level ] [ run ] [ last ] = get_size_of_code ( s , & rl_table [ i ] , last , run , level , 0 ) ; \n } \n } \n } \n } \n } \n }", "idx": 22811}
{"project": "FFmpeg", "commit_id": "4a6a29a7fbf023b19797c38a86099d9f81d25524", "target": 0, "func": "static int amr_nb_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AMRContext * s = avctx -> priv_data ; \n static const uint8_t block_size [ 16 ] = { 12 , 13 , 15 , 17 , 19 , 20 , 26 , 31 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n enum Mode dec_mode ; \n int packet_size ; \n av_dlog ( avctx , \" \\n \" , \n buf , buf_size , avctx -> frame_number ) ; \n dec_mode = ( buf [ 0 ] >> 3 ) & 0x000F ; \n packet_size = block_size [ dec_mode ] + 1 ; \n if ( packet_size > buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n buf_size , packet_size ) ; \n return AVERROR_INVALIDDATA ; \n } \n av_dlog ( avctx , \" \\n \" , \n packet_size , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] ) ; \n Decoder_Interface_Decode ( s -> dec_state , buf , data , 0 ) ; \n * data_size = 160 * 2 ; \n return packet_size ; \n }", "idx": 22822}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_h_loop_filter_chroma422_mbaff_msa ( uint8_t * src , \n int32_t stride , \n int32_t alpha_in , \n int32_t beta_in , \n int8_t * tc0 ) \n { \n int32_t col , tc_val ; \n int16_t out0 , out1 ; \n v16u8 alpha , beta , res ; \n alpha = ( v16u8 ) __msa_fill_b ( alpha_in ) ; \n beta = ( v16u8 ) __msa_fill_b ( beta_in ) ; \n for ( col = 0 ; col < 4 ; col ++ ) { \n tc_val = ( tc0 [ col ] - 1 ) + 1 ; \n if ( tc_val <= 0 ) { \n src += 4 * stride ; \n continue ; \n } \n AVC_LPF_H_2BYTE_CHROMA_422 ( src , stride , tc_val , alpha , beta , res ) ; \n out0 = __msa_copy_s_h ( ( v8i16 ) res , 0 ) ; \n out1 = __msa_copy_s_h ( ( v8i16 ) res , 1 ) ; \n STORE_HWORD ( ( src - 1 ) , out0 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out1 ) ; \n src += stride ; \n } \n }", "idx": 22825}
{"project": "FFmpeg", "commit_id": "a0a872d0733f60876b0c93f236bc4606f36fbf89", "target": 0, "func": "static void copy_cell ( Indeo3DecodeContext * ctx , Plane * plane , Cell * cell ) \n { \n int h , w , mv_x , mv_y , offset , offset_dst ; \n uint8_t * src , * dst ; \n offset_dst = ( cell -> ypos << 2 ) * plane -> pitch + ( cell -> xpos << 2 ) ; \n dst = plane -> pixels [ ctx -> buf_sel ] + offset_dst ; \n mv_y = cell -> mv_ptr [ 0 ] ; \n mv_x = cell -> mv_ptr [ 1 ] ; \n offset = offset_dst + mv_y * plane -> pitch + mv_x ; \n src = plane -> pixels [ ctx -> buf_sel ^ 1 ] + offset ; \n h = cell -> height << 2 ; \n for ( w = cell -> width ; w > 0 ; ) { \n if ( ! ( ( cell -> xpos << 2 ) & 15 ) && w >= 4 ) { \n for ( ; w >= 4 ; src += 16 , dst += 16 , w -= 4 ) \n ctx -> dsp . put_no_rnd_pixels_tab [ 0 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n } \n if ( ! ( ( cell -> xpos << 2 ) & 7 ) && w >= 2 ) { \n ctx -> dsp . put_no_rnd_pixels_tab [ 1 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n w -= 2 ; \n src += 8 ; \n dst += 8 ; \n } \n if ( w >= 1 ) { \n ctx -> dsp . put_no_rnd_pixels_tab [ 2 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n w -- ; \n src += 4 ; \n dst += 4 ; \n } \n } \n }", "idx": 22828}
{"project": "FFmpeg", "commit_id": "831274fba4b14c542458ce5a3d0135b49499299a", "target": 1, "func": "static void flac_lpc_16_c ( int32_t * decoded , const int coeffs [ 32 ] , \n int pred_order , int qlevel , int len ) \n { \n int i , j ; \n for ( i = pred_order ; i < len - 1 ; i += 2 , decoded += 2 ) { \n int c = coeffs [ 0 ] ; \n int d = decoded [ 0 ] ; \n int s0 = 0 , s1 = 0 ; \n for ( j = 1 ; j < pred_order ; j ++ ) { \n s0 += c * d ; \n d = decoded [ j ] ; \n s1 += c * d ; \n c = coeffs [ j ] ; \n } \n s0 += c * d ; \n d = decoded [ j ] += s0 >> qlevel ; \n s1 += c * d ; \n decoded [ j + 1 ] += s1 >> qlevel ; \n } \n if ( i < len ) { \n int sum = 0 ; \n for ( j = 0 ; j < pred_order ; j ++ ) \n sum += coeffs [ j ] * decoded [ j ] ; \n decoded [ j ] += sum >> qlevel ; \n } \n }", "idx": 22850}
{"project": "FFmpeg", "commit_id": "9d0b45ade864f3d2ccd8610149fe1fff53c4e937", "target": 1, "func": "static int rprobe ( AVFormatContext * s , uint8_t * enc_header , const uint8_t * r_val ) \n { \n OMAContext * oc = s -> priv_data ; \n unsigned int pos ; \n struct AVDES av_des ; \n if ( ! enc_header || ! r_val ) \n return -1 ; \n av_des_init ( & av_des , r_val , 192 , 1 ) ; \n av_des_crypt ( & av_des , oc -> m_val , & enc_header [ 48 ] , 1 , NULL , 1 ) ; \n av_des_init ( & av_des , oc -> m_val , 64 , 0 ) ; \n av_des_crypt ( & av_des , oc -> s_val , NULL , 1 , NULL , 0 ) ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size + oc -> e_size ; \n av_des_init ( & av_des , oc -> s_val , 64 , 0 ) ; \n av_des_mac ( & av_des , oc -> sm_val , & enc_header [ pos ] , ( oc -> i_size >> 3 ) ) ; \n pos += oc -> i_size ; \n return memcmp ( & enc_header [ pos ] , oc -> sm_val , 8 ) ? -1 : 0 ; \n }", "idx": 22895}
{"project": "FFmpeg", "commit_id": "dcbe15813ed09cf491e75a21cce0e751f5bc2b34", "target": 0, "func": "static int check_opcodes ( MMCO * mmco1 , MMCO * mmco2 , int n_mmcos ) \n { \n int i ; \n for ( i = 0 ; i < n_mmcos ; i ++ ) { \n if ( mmco1 [ i ] . opcode != mmco2 [ i ] . opcode ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 22902}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel4_mc03_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_4w_msa ( src - ( stride * 2 ) , stride , dst , stride , 4 , 1 ) ; \n }", "idx": 22937}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_header ( AVFormatContext * s1 , \n AVFormatParameters * ap ) \n { \n GifState * s = s1 -> priv_data ; \n ByteIOContext * f = s1 -> pb ; \n AVStream * st ; \n s -> f = f ; \n if ( gif_read_header1 ( s ) < 0 ) \n return -1 ; \n s -> image_linesize = s -> screen_width * 3 ; \n s -> image_buf = av_malloc ( s -> screen_height * s -> image_linesize ) ; \n if ( ! s -> image_buf ) \n return AVERROR ( ENOMEM ) ; \n s -> pix_fmt = PIX_FMT_RGB24 ; \n st = av_new_stream ( s1 , 0 ) ; \n if ( ! st ) \n return -1 ; \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n st -> codec -> codec_id = CODEC_ID_RAWVIDEO ; \n st -> codec -> time_base . den = 5 ; \n st -> codec -> time_base . num = 1 ; \n st -> codec -> width = s -> screen_width ; \n st -> codec -> height = s -> screen_height ; \n st -> codec -> pix_fmt = PIX_FMT_RGB24 ; \n return 0 ; \n }", "idx": 22978}
{"project": "FFmpeg", "commit_id": "ef4c71e8f83a46fb31a11f0a066efb90821c579f", "target": 0, "func": "static int config_props ( AVFilterLink * link ) \n { \n UnsharpContext * unsharp = link -> dst -> priv ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( link -> format ) ; \n unsharp -> hsub = desc -> log2_chroma_w ; \n unsharp -> vsub = desc -> log2_chroma_h ; \n init_filter_param ( link -> dst , & unsharp -> luma , \" \" , link -> w ) ; \n init_filter_param ( link -> dst , & unsharp -> chroma , \" \" , SHIFTUP ( link -> w , unsharp -> hsub ) ) ; \n return 0 ; \n }", "idx": 23022}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t wav_seek_tag ( AVIOContext * s , int64_t offset , int whence ) \n { \n offset += offset < INT64_MAX && offset & 1 ; \n return avio_seek ( s , offset , whence ) ; \n }", "idx": 23027}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int av_seek_frame_generic ( AVFormatContext * s , \n int stream_index , int64_t timestamp ) \n { \n int index ; \n AVStream * st ; \n AVIndexEntry * ie ; \n if ( ! s -> index_built ) { \n if ( is_raw_stream ( s ) ) { \n av_build_index_raw ( s ) ; \n } else { \n return -1 ; \n } \n s -> index_built = 1 ; \n } \n if ( stream_index < 0 ) \n stream_index = 0 ; \n st = s -> streams [ stream_index ] ; \n index = index_search_timestamp ( st -> index_entries , st -> nb_index_entries , \n timestamp ) ; \n if ( index < 0 ) \n return -1 ; \n ie = & st -> index_entries [ index ] ; \n av_read_frame_flush ( s ) ; \n url_fseek ( & s -> pb , ie -> pos , SEEK_SET ) ; \n st -> cur_dts = ie -> timestamp ; \n return 0 ; \n }", "idx": 23156}
{"project": "FFmpeg", "commit_id": "fef7b2e0bef6972d8d48df51e477af7b017d1a38", "target": 0, "func": "static int null_draw_slice ( AVFilterLink * link , int y , int h , int slice_dir ) { return 0 ; }", "idx": 23249}
{"project": "FFmpeg", "commit_id": "0953736b7e97f6e121a0587a95434bf1857a27da", "target": 1, "func": "static inline int signed_shift ( int i , int shift ) { \n if ( shift > 0 ) \n return i << shift ; \n return i >> - shift ; \n }", "idx": 23316}
{"project": "FFmpeg", "commit_id": "38beab19ab3b997bcbe2e95699d4952922f1f673", "target": 1, "func": "static int r3d_read_redv ( AVFormatContext * s , AVPacket * pkt , Atom * atom ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n int tmp , tmp2 ; \n uint64_t pos = url_ftell ( s -> pb ) ; \n unsigned dts ; \n dts = get_be32 ( s -> pb ) ; \n tmp = get_be32 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n tmp = get_byte ( s -> pb ) ; \n tmp2 = get_byte ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp , tmp2 ) ; \n tmp = get_be16 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n if ( tmp > 4 ) { \n tmp = get_be16 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n tmp = get_be16 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n tmp = get_be32 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n tmp = get_be32 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n tmp = get_be32 ( s -> pb ) ; \n dprintf ( s , \" \\n \" , tmp ) ; \n } \n tmp = atom -> size - 8 - ( url_ftell ( s -> pb ) - pos ) ; \n if ( tmp < 0 ) \n return -1 ; \n if ( av_get_packet ( s -> pb , pkt , tmp ) != tmp ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n pkt -> stream_index = 0 ; \n pkt -> dts = dts ; \n if ( st -> codec -> time_base . den ) \n pkt -> duration = ( uint64_t ) st -> time_base . den * \n st -> codec -> time_base . num / st -> codec -> time_base . den ; \n dprintf ( s , \" \\n \" , pkt -> dts , pkt -> duration ) ; \n return 0 ; \n }", "idx": 23384}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr32 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = 0 ; \n } \n }", "idx": 23431}
{"project": "FFmpeg", "commit_id": "26f2e2f3f73f0da088e6765291d0839ebb077b03", "target": 1, "func": "static void write_header ( AVFormatContext * s ) \n { \n double min_buffer_time = 1.0 ; \n avio_printf ( s -> pb , \" \\\" \\\" \\\" \\\" \\n \" ) ; \n avio_printf ( s -> pb , \" \\n \" ) ; \n avio_printf ( s -> pb , \" \\\" \n avio_printf ( s -> pb , \" \\\" \\\" \\n \" )  ; \n avio_printf ( s -> pb , \" \\\" \\\" \\n \" ) ; \n avio_printf ( s -> pb , \" \\\" \\\" \\n \" ) ; \n avio_printf ( s -> pb , \" \\\" \\\" \\n \" , \n get_duration ( s ) ) ; \n avio_printf ( s -> pb , \" \\\" \\\" \\n \" , \n min_buffer_time ) ; \n avio_printf ( s -> pb , \" \\\" \\\" \" ) ; \n avio_printf ( s -> pb , \" \\n \" ) ; \n }", "idx": 23434}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void opt_input_file ( void * optctx , const char * arg ) \n { \n if ( input_filename ) { \n fprintf ( stderr , \n \" \\n \" , \n arg , input_filename ) ; \n exit ( 1 ) ; \n } \n if ( ! strcmp ( arg , \" \" ) ) \n arg = \" \" ; \n input_filename = arg ; \n }", "idx": 23440}
{"project": "FFmpeg", "commit_id": "398f015f077c6a2406deffd9e37ff34b9c7bb3bc", "target": 0, "func": "static int transcode_subtitles ( InputStream * ist , AVPacket * pkt , int * got_output ) \n { \n AVSubtitle subtitle ; \n int i , ret = avcodec_decode_subtitle2 ( ist -> dec_ctx , \n & subtitle , got_output , pkt ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! * got_output ) \n return ret ; \n ist -> frames_decoded ++ ; \n for ( i = 0 ; i < nb_output_streams ; i ++ ) { \n OutputStream * ost = output_streams [ i ] ; \n if ( ! check_output_constraints ( ist , ost ) || ! ost -> encoding_needed ) \n continue ; \n do_subtitle_out ( output_files [ ost -> file_index ] -> ctx , ost , ist , & subtitle , pkt -> pts ) ; \n } \n avsubtitle_free ( & subtitle ) ; \n return ret ; \n }", "idx": 23471}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add4_mmx ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 4 ) { \n if ( nnzc [ scan8 [ i ] ] ) \n ff_h264_idct8_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 23488}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "static int nvdec_h264_decode_init ( AVCodecContext * avctx ) \n { \n const H264Context * h = avctx -> priv_data ; \n const SPS * sps = h -> ps . sps ; \n return ff_nvdec_decode_init ( avctx , sps -> ref_frame_count + sps -> num_reorder_frames ) ; \n }", "idx": 23575}
{"project": "FFmpeg", "commit_id": "e5755893786ecab2e6f0414d1b2983dcaa3d237e", "target": 1, "func": "static void mxf_free_metadataset ( MXFMetadataSet * * ctx , int freectx ) \n { \n MXFIndexTableSegment * seg ; \n switch ( ( * ctx ) -> type ) { \n case Descriptor : \n av_freep ( & ( ( MXFDescriptor * ) * ctx ) -> extradata ) ; \n break ; \n case MultipleDescriptor : \n av_freep ( & ( ( MXFDescriptor * ) * ctx ) -> sub_descriptors_refs ) ; \n break ; \n case Sequence : \n av_freep ( & ( ( MXFSequence * ) * ctx ) -> structural_components_refs ) ; \n break ; \n case EssenceGroup : \n av_freep ( & ( ( MXFEssenceGroup * ) * ctx ) -> structural_components_refs ) ; \n break ; \n case SourcePackage : \n case MaterialPackage : \n av_freep ( & ( ( MXFPackage * ) * ctx ) -> tracks_refs ) ; \n av_freep ( & ( ( MXFPackage * ) * ctx ) -> name ) ; \n break ; \n case TaggedValue : \n av_freep ( & ( ( MXFTaggedValue * ) * ctx ) -> name ) ; \n av_freep ( & ( ( MXFTaggedValue * ) * ctx ) -> value ) ; \n break ; \n case IndexTableSegment : \n seg = ( MXFIndexTableSegment * ) * ctx ; \n av_freep ( & seg -> temporal_offset_entries ) ; \n av_freep ( & seg -> flag_entries ) ; \n av_freep ( & seg -> stream_offset_entries ) ; \n default : \n break ; \n } \n if ( freectx ) \n av_freep ( ctx ) ; \n }", "idx": 23580}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int smc_decode_init ( AVCodecContext * avctx ) \n { \n SmcContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 23653}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_set_fixed_vector ( float * out , const AMRFixed * in , float scale , int size ) \n { \n int i ; \n for ( i = 0 ; i < in -> n ; i ++ ) { \n int x = in -> x [ i ] , repeats = ! ( ( in -> no_repeat_mask >> i ) & 1 ) ; \n float y = in -> y [ i ] * scale ; \n do { \n out [ x ] += y ; \n y *= in -> pitch_fac ; \n x += in -> pitch_lag ; \n } while ( x < size && repeats ) ; \n } \n }", "idx": 23665}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void fill_scaling_lists ( const AVCodecContext * avctx , AVDXVAContext * ctx , const H264Context * h , DXVA_Qmatrix_H264 * qm ) \n { \n unsigned i , j ; \n memset ( qm , 0 , sizeof ( * qm ) ) ; \n if ( DXVA_CONTEXT_WORKAROUND ( avctx , ctx ) & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG ) { \n for ( i = 0 ; i < 6 ; i ++ ) \n for ( j = 0 ; j < 16 ; j ++ ) \n qm -> bScalingLists4x4 [ i ] [ j ] = h -> pps . scaling_matrix4 [ i ] [ j ] ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n qm -> bScalingLists8x8 [ 0 ] [ i ] = h -> pps . scaling_matrix8 [ 0 ] [ i ] ; \n qm -> bScalingLists8x8 [ 1 ] [ i ] = h -> pps . scaling_matrix8 [ 3 ] [ i ] ; \n } \n } else { \n for ( i = 0 ; i < 6 ; i ++ ) \n for ( j = 0 ; j < 16 ; j ++ ) \n qm -> bScalingLists4x4 [ i ] [ j ] = h -> pps . scaling_matrix4 [ i ] [ ff_zigzag_scan [ j ] ] ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n qm -> bScalingLists8x8 [ 0 ] [ i ] = h -> pps . scaling_matrix8 [ 0 ] [ ff_zigzag_direct [ i ] ] ; \n qm -> bScalingLists8x8 [ 1 ] [ i ] = h -> pps . scaling_matrix8 [ 3 ] [ ff_zigzag_direct [ i ] ] ; \n } \n } \n }", "idx": 23731}
{"project": "FFmpeg", "commit_id": "8b31c086b6065084644b86a63c9171f3094cf6ad", "target": 0, "func": "static int decode_tag ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n NellyMoserDecodeContext * s = avctx -> priv_data ; \n int blocks , i ; \n int16_t * samples ; \n * data_size = 0 ; \n samples = ( int16_t * ) data ; \n if ( buf_size < avctx -> block_align ) \n return buf_size ; \n if ( buf_size % 64 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , buf_size ) ; \n return buf_size ; \n } \n blocks = buf_size / 64 ; \n for ( i = 0 ; i < blocks ; i ++ ) { \n nelly_decode_block ( s , & buf [ i * NELLY_BLOCK_LEN ] , s -> float_buf ) ; \n s -> fmt_conv . float_to_int16 ( & samples [ i * NELLY_SAMPLES ] , s -> float_buf , NELLY_SAMPLES ) ; \n * data_size += NELLY_SAMPLES * sizeof ( int16_t ) ; \n } \n return buf_size ; \n }", "idx": 23756}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int int_pow ( int i , int * exp_ptr ) \n { \n int e , er , eq , j ; \n int a , a1 ; \n a = i ; \n e = POW_FRAC_BITS ; \n while ( a < ( 1 << ( POW_FRAC_BITS - 1 ) ) ) { \n a = a << 1 ; \n e -- ; \n } \n a -= ( 1 << POW_FRAC_BITS ) ; \n a1 = 0 ; \n for ( j = DEV_ORDER - 1 ; j >= 0 ; j -- ) \n a1 = POW_MULL ( a , dev_4_3_coefs [ j ] + a1 ) ; \n a = ( 1 << POW_FRAC_BITS ) + a1 ; \n e = e * 4 ; \n er = e % 3 ; \n eq = e / 3 ; \n a = POW_MULL ( a , pow_mult3 [ er ] ) ; \n while ( a >= 2 * POW_FRAC_ONE ) { \n a = a >> 1 ; \n eq ++ ; \n } \n while ( a < POW_FRAC_ONE ) { \n a = a << 1 ; \n eq -- ; \n } \n #if ( POW_FRAC_BITS - 1 ) > FRAC_BITS  \n  \n  a = ( a + ( 1 << ( POW_FRAC_BITS - FRAC_BITS - 1 ) ) ) >> ( POW_FRAC_BITS - FRAC_BITS ) ; \n if ( a >= 2 * ( 1 << FRAC_BITS ) ) { \n a = a >> 1 ; \n eq ++ ; \n } \n #endif \n * exp_ptr = eq ; \n return a ; \n }", "idx": 23903}
{"project": "FFmpeg", "commit_id": "153b36fc62849e0e1540a43829794e0503994ebb", "target": 0, "func": "unsigned ff_dxva2_get_surface_index ( const AVCodecContext * avctx , \n const AVDXVAContext * ctx , \n const AVFrame * frame ) \n { \n void * surface = get_surface ( frame ) ; \n unsigned i ; \n for ( i = 0 ; i < DXVA_CONTEXT_COUNT ( avctx , ctx ) ; i ++ ) { \n #if CONFIG_D3D11VA  \n  \n  if ( avctx -> pix_fmt == AV_PIX_FMT_D3D11VA_VLD && ctx -> d3d11va . surface [ i ] == surface ) \n { \n D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc ; \n ID3D11VideoDecoderOutputView_GetDesc ( ctx -> d3d11va . surface [ i ] , & viewDesc ) ; \n return viewDesc . Texture2D . ArraySlice ; \n } \n #endif \n #if CONFIG_DXVA2  \n  \n  if ( avctx -> pix_fmt == AV_PIX_FMT_DXVA2_VLD && ctx -> dxva2 . surface [ i ] == surface ) \n return i ; \n #endif \n } \n assert ( 0 ) ; \n return 0 ; \n }", "idx": 23929}
{"project": "FFmpeg", "commit_id": "14bd2a9f25fc0de4fb1a2d4afaef09162c51bb35", "target": 0, "func": "static int find_optimal_param ( uint32_t sum , int n ) \n { \n int k , k_opt ; \n uint32_t nbits [ MAX_RICE_PARAM + 1 ] ; \n k_opt = 0 ; \n nbits [ 0 ] = UINT32_MAX ; \n for ( k = 0 ; k <= MAX_RICE_PARAM ; k ++ ) { \n nbits [ k ] = rice_encode_count ( sum , n , k ) ; \n if ( nbits [ k ] < nbits [ k_opt ] ) { \n k_opt = k ; \n } \n } \n return k_opt ; \n }", "idx": 24037}
{"project": "FFmpeg", "commit_id": "cd2f7ed0007f4803b6bd845366b2398abb32c355", "target": 0, "func": "static void ts_str ( char buffer [ 60 ] , int64_t ts , AVRational base ) \n { \n if ( ts == AV_NOPTS_VALUE ) { \n strcpy ( buffer , \" \" ) ; \n return ; \n } \n ts = av_rescale_q ( ts , base , ( AVRational ) { 1 , 1000000 } ) ; \n snprintf ( buffer , 60 , \" \" , ts < 0 ? ' ' : ' ' , FFABS ( ts ) / 1000000 , FFABS ( ts ) % 1000000 ) ; \n }", "idx": 24048}
{"project": "FFmpeg", "commit_id": "26fc6ffec45c954cd8ca46342ac75cd90bcc7e02", "target": 1, "func": "static inline void libopenjpeg_copy_to_packed16 ( AVFrame * picture , opj_image_t * image ) { \n uint16_t * img_ptr ; \n int index , x , y , c ; \n int adjust [ 4 ] ; \n for ( x = 0 ; x < image -> numcomps ; x ++ ) \n adjust [ x ] = FFMAX ( FFMIN ( av_pix_fmt_desc_get ( picture -> format ) -> comp [ x ] . depth_minus1 + 1 - image -> comps [ x ] . prec , 8 ) , 0 ) ; \n for ( y = 0 ; y < picture -> height ; y ++ ) { \n index = y * picture -> width ; \n img_ptr = ( uint16_t * ) ( picture -> data [ 0 ] + y * picture -> linesize [ 0 ] ) ; \n for ( x = 0 ; x < picture -> width ; x ++ , index ++ ) { \n for ( c = 0 ; c < image -> numcomps ; c ++ ) { \n * img_ptr ++ = 0x8000 * image -> comps [ c ] . sgnd + ( image -> comps [ c ] . data [ index ] << adjust [ c ] ) ; \n } \n } \n } \n }", "idx": 24221}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void vp3_draw_horiz_band ( Vp3DecodeContext * s , int y ) \n { \n int h , cy , i ; \n int offset [ AV_NUM_DATA_POINTERS ] ; \n if ( HAVE_THREADS && s -> avctx -> active_thread_type & FF_THREAD_FRAME ) { \n int y_flipped = s -> flipped_image ? s -> avctx -> height - y : y ; \n ff_thread_report_progress ( & s -> current_frame , \n y_flipped == s -> avctx -> height ? INT_MAX \n : y_flipped - 1 , \n 0 ) ; \n } \n if ( s -> avctx -> draw_horiz_band == NULL ) \n return ; \n h = y - s -> last_slice_end ; \n s -> last_slice_end = y ; \n y -= h ; \n if ( ! s -> flipped_image ) \n y = s -> avctx -> height - y - h ; \n cy = y >> s -> chroma_y_shift ; \n offset [ 0 ] = s -> current_frame . f -> linesize [ 0 ] * y ; \n offset [ 1 ] = s -> current_frame . f -> linesize [ 1 ] * cy ; \n offset [ 2 ] = s -> current_frame . f -> linesize [ 2 ] * cy ; \n for ( i = 3 ; i < AV_NUM_DATA_POINTERS ; i ++ ) \n offset [ i ] = 0 ; \n emms_c ( ) ; \n s -> avctx -> draw_horiz_band ( s -> avctx , s -> current_frame . f , offset , y , 3 , h ) ; \n }", "idx": 24226}
{"project": "FFmpeg", "commit_id": "d31e3f7ccc5d1e198b3a582f4413ce7342928d8c", "target": 0, "func": "static int gif_write_header ( AVFormatContext * s ) \n { \n GIFContext * gif = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n AVCodecContext * enc , * video_enc ; \n int i , width , height , loop_count \n ; \n gif -> time = 0 ; \n gif -> file_time = 0 ; \n video_enc = NULL ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n enc = s -> streams [ i ] -> codec ; \n if ( enc -> codec_type != AVMEDIA_TYPE_AUDIO ) \n video_enc = enc ; \n } \n if ( ! video_enc ) { \n av_free ( gif ) ; \n return -1 ; \n } else { \n width = video_enc -> width ; \n height = video_enc -> height ; \n loop_count = s -> loop_output ; \n } \n if ( video_enc -> pix_fmt != PIX_FMT_RGB24 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n } \n gif_image_write_header ( pb , width , height , loop_count , NULL ) ; \n avio_flush ( s -> pb ) ; \n return 0 ; \n }", "idx": 24227}
{"project": "FFmpeg", "commit_id": "033f1644b59abd755bb529afa5db394d18d9c30b", "target": 1, "func": "fixup_vorbis_headers ( AVFormatContext * as , struct oggvorbis_private * priv , \n uint8_t * * buf )  \n { \n int i , offset , len , buf_len ; \n unsigned char * ptr ; \n len = priv -> len [ 0 ] + priv -> len [ 1 ] + priv -> len [ 2 ] ; \n buf_len = len + len / 255 + 64 ; \n ptr = * buf = av_realloc ( NULL , buf_len ) ; \n memset ( * buf , ' \\0 ' , buf_len ) ; \n ptr [ 0 ] = 2 ; \n offset = 1 ; \n offset += av_xiphlacing ( & ptr [ offset ] , priv -> len [ 0 ] ) ; \n offset += av_xiphlacing ( & ptr [ offset ] , priv -> len [ 1 ] ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n memcpy ( & ptr [ offset ] , priv -> packet [ i ] , priv -> len [ i ] ) ; \n offset += priv -> len [ i ] ; \n av_freep ( & priv -> packet [ i ] ) ; \n } \n * buf = av_realloc ( * buf , offset + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n return offset ; \n }", "idx": 24235}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline int small_diamond_search4MV ( MpegEncContext * s , int * best , int dmin , \n UINT8 * new_pic , UINT8 * old_pic , int pic_stride , \n int pred_x , int pred_y , UINT16 * mv_penalty , int quant , \n int xmin , int ymin , int xmax , int ymax , int shift ) \n { \n int next_dir = -1 ; \n for ( ; ; ) { \n int d ; \n const int dir = next_dir ; \n const int x = best [ 0 ] ; \n const int y = best [ 1 ] ; \n next_dir = -1 ; \n if ( dir != 2 && x > xmin ) CHECK_MV4_DIR ( x - 1 , y , 0 )  \n if ( dir != 3 && y > ymin ) CHECK_MV4_DIR ( x , y - 1 , 1 )  \n if ( dir != 0 && x < xmax ) CHECK_MV4_DIR ( x + 1 , y , 2 )  \n if ( dir != 1 && y < ymax ) CHECK_MV4_DIR ( x , y + 1 , 3 )  \n if ( next_dir == -1 ) { \n return dmin ; \n } \n } \n }", "idx": 24251}
{"project": "FFmpeg", "commit_id": "e09ad5bd0de40da9ac33d86f973a85beed85cc47", "target": 0, "func": "void ff_h264_remove_all_refs ( H264Context * h ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n remove_long ( h , i , 0 ) ; \n } \n assert ( h -> long_ref_count == 0 ) ; \n ff_h264_unref_picture ( h , & h -> last_pic_for_ec ) ; \n if ( h -> short_ref_count ) \n ff_h264_ref_picture ( h , & h -> last_pic_for_ec , h -> short_ref [ 0 ] ) ; \n for ( i = 0 ; i < h -> short_ref_count ; i ++ ) { \n unreference_pic ( h , h -> short_ref [ i ] , 0 ) ; \n h -> short_ref [ i ] = NULL ; \n } \n h -> short_ref_count = 0 ; \n memset ( h -> default_ref_list , 0 , sizeof ( h -> default_ref_list ) ) ; \n memset ( h -> ref_list , 0 , sizeof ( h -> ref_list ) ) ; \n }", "idx": 24285}
{"project": "FFmpeg", "commit_id": "474176bf927870168a20413f2a9c28f09b6b1afa", "target": 0, "func": "static int get_max_p_order ( int max_porder , int n , int order ) \n { \n int porder , max_parts ; \n porder = max_porder ; \n while ( porder > 0 ) { \n max_parts = ( 1 << porder ) ; \n if ( ! ( n % max_parts ) && ( n > max_parts * order ) ) { \n break ; \n } \n porder -- ; \n } \n return porder ; \n }", "idx": 24290}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( palToY ) ( uint8_t * dst , uint8_t * src , int width , uint32_t * pal ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d = src [ i ] ; \n dst [ i ] = pal [ d ] & 0xFF ; \n } \n }", "idx": 24379}
{"project": "FFmpeg", "commit_id": "d1b284119bd5c6a52124443de2c45dbe569c25fc", "target": 0, "func": "static int filter_frame ( AVFilterLink * link , AVFrame * frame ) \n { \n AVFilterContext * ctx = link -> dst ; \n AudioFIRContext * s = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n int ret = 0 ; \n av_audio_fifo_write ( s -> fifo [ 0 ] , ( void * * ) frame -> extended_data , \n frame -> nb_samples ) ; \n if ( s -> pts == AV_NOPTS_VALUE ) \n s -> pts = frame -> pts ; \n av_frame_free ( & frame ) ; \n if ( ! s -> have_coeffs && s -> eof_coeffs ) { \n ret = convert_coeffs ( ctx ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( s -> have_coeffs ) { \n while ( av_audio_fifo_size ( s -> fifo [ 0 ] ) >= s -> part_size ) { \n ret = fir_frame ( s , outlink ) ; \n if ( ret < 0 ) \n break ; \n } \n } \n return ret ; \n }", "idx": 24430}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void revert_acfilter ( WmallDecodeCtx * s , int tile_size ) \n { \n int ich , pred , i , j ; \n int16_t * filter_coeffs = s -> acfilter_coeffs ; \n int scaling = s -> acfilter_scaling ; \n int order = s -> acfilter_order ; \n for ( ich = 0 ; ich < s -> num_channels ; ich ++ ) { \n int * prevvalues = s -> acfilter_prevvalues [ ich ] ; \n for ( i = 0 ; i < order ; i ++ ) { \n pred = 0 ; \n for ( j = 0 ; j < order ; j ++ ) { \n if ( i <= j ) \n pred += filter_coeffs [ j ] * prevvalues [ j - i ] ; \n else \n pred += s -> channel_residues [ ich ] [ i - j - 1 ] * filter_coeffs [ j ] ; \n } \n pred >>= scaling ; \n s -> channel_residues [ ich ] [ i ] += pred ; \n } \n for ( i = order ; i < tile_size ; i ++ ) { \n pred = 0 ; \n for ( j = 0 ; j < order ; j ++ ) \n pred += s -> channel_residues [ ich ] [ i - j - 1 ] * filter_coeffs [ j ] ; \n pred >>= scaling ; \n s -> channel_residues [ ich ] [ i ] += pred ; \n } \n for ( j = 0 ; j < order ; j ++ ) \n prevvalues [ j ] = s -> channel_residues [ ich ] [ tile_size - j - 1 ] ; \n } \n }", "idx": 24471}
{"project": "FFmpeg", "commit_id": "ea5366670e26b2c6c396e6a5f49827a2b71e6dd6", "target": 1, "func": "static void dwt_decode97_int ( DWTContext * s , int32_t * t ) \n { \n int lev ; \n int w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; \n int h = s -> linelen [ s -> ndeclevels - 1 ] [ 1 ] ; \n int i ; \n int32_t * line = s -> i_linebuf ; \n int32_t * data = t ; \n line += 5 ; \n for ( i = 0 ; i < w * h ; i ++ ) \n data [ i ] *= 1 << I_PRESHIFT ; \n for ( lev = 0 ; lev < s -> ndeclevels ; lev ++ ) { \n int lh = s -> linelen [ lev ] [ 0 ] , \n lv = s -> linelen [ lev ] [ 1 ] , \n mh = s -> mod [ lev ] [ 0 ] , \n mv = s -> mod [ lev ] [ 1 ] , \n lp ; \n int32_t * l ; \n l = line + mh ; \n for ( lp = 0 ; lp < lv ; lp ++ ) { \n int i , j = 0 ; \n for ( i = mh ; i < lh ; i += 2 , j ++ ) \n l [ i ] = ( ( data [ w * lp + j ] * I_LFTG_K ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) \n l [ i ] = data [ w * lp + j ] ; \n sr_1d97_int ( line , mh , mh + lh ) ; \n for ( i = 0 ; i < lh ; i ++ ) \n data [ w * lp + i ] = l [ i ] ; \n } \n l = line + mv ; \n for ( lp = 0 ; lp < lh ; lp ++ ) { \n int i , j = 0 ; \n for ( i = mv ; i < lv ; i += 2 , j ++ ) \n l [ i ] = ( ( data [ w * j + lp ] * I_LFTG_K ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) \n l [ i ] = data [ w * j + lp ] ; \n sr_1d97_int ( line , mv , mv + lv ) ; \n for ( i = 0 ; i < lv ; i ++ ) \n data [ w * i + lp ] = l [ i ] ; \n } \n } \n for ( i = 0 ; i < w * h ; i ++ ) \n data [ i ] = ( data [ i ] + ( ( 1 << I_PRESHIFT ) >> 1 ) ) >> I_PRESHIFT ; \n }", "idx": 24524}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( rgb32tobgr24 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n #if COMPILE_TEMPLATE_MMX  \n  \n  const uint8_t * mm_end ; \n #endif \n end = s + src_size ; \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 31 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n STORE_BGR24_MMX \n : \" \" ( * dest ) \n : \" \" ( * s ) \n : \" \" ) ; \n dest += 24 ; \n s += 32 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n #endif \n while ( s < end ) { \n #if HAVE_BIGENDIAN  \n  \n  \n  \n  s ++ ; \n dest [ 2 ] = * s ++ ; \n dest [ 1 ] = * s ++ ; \n dest [ 0 ] = * s ++ ; \n dest += 3 ; \n #else \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n s ++ ; \n #endif \n } \n }", "idx": 24587}
{"project": "FFmpeg", "commit_id": "d05bdba2428dd0c1c5cd3426d69c712b127f996c", "target": 1, "func": "static int rac_get_model256_sym ( RangeCoder * c , Model256 * m ) \n { \n int prob , prob2 , helper , val ; \n int start , end ; \n int ssym ; \n prob2 = c -> range ; \n c -> range >>= MODEL_SCALE ; \n helper = c -> low / c -> range ; \n ssym = helper >> MODEL256_SEC_SCALE ; \n val = m -> secondary [ ssym ] ; \n end = start = m -> secondary [ ssym + 1 ] + 1 ; \n while ( end > val + 1 ) { \n ssym = ( end + val ) >> 1 ; \n if ( m -> freqs [ ssym ] <= helper ) { \n end = start ; \n val = ssym ; \n } else { \n end = ( end + val ) >> 1 ; \n start = ssym ; \n } \n } \n prob = m -> freqs [ val ] * c -> range ; \n if ( val != 255 ) \n prob2 = m -> freqs [ val + 1 ] * c -> range ; \n c -> low -= prob ; \n c -> range = prob2 - prob ; \n if ( c -> range < RAC_BOTTOM ) \n rac_normalise ( c ) ; \n model256_update ( m , val ) ; \n return val ; \n }", "idx": 24654}
{"project": "FFmpeg", "commit_id": "ae43c10e36197000de2f3cc99ea35727ce98a796", "target": 0, "func": "int ff_replaygain_export ( AVStream * st , AVDictionary * metadata ) \n { \n const AVDictionaryEntry * tg , * tp , * ag , * ap ; \n tg = av_dict_get ( metadata , \" \" , NULL , 0 ) ; \n tp = av_dict_get ( metadata , \" \" , NULL , 0 ) ; \n ag = av_dict_get ( metadata , \" \" , NULL , 0 ) ; \n ap = av_dict_get ( metadata , \" \" , NULL , 0 ) ; \n return replaygain_export ( st , \n tg ? tg -> value : NULL , \n tp ? tp -> value : NULL , \n ag ? ag -> value : NULL , \n ap ? ap -> value : NULL ) ; \n }", "idx": 24659}
{"project": "FFmpeg", "commit_id": "34a8dcd031d637273cdea021e5a79cf720c4c51c", "target": 0, "func": "static int decode_end ( AVCodecContext * avctx ) \n { \n KmvcContext * const c = ( KmvcContext * ) avctx -> priv_data ; \n if ( c -> frm0 ) \n av_free ( c -> frm0 ) ; \n if ( c -> frm1 ) \n av_free ( c -> frm1 ) ; \n if ( c -> pic . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & c -> pic ) ; \n return 0 ; \n }", "idx": 24673}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16_mmx2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n int nnz = nnzc [ scan8 [ i ] ] ; \n if ( nnz ) { \n if ( nnz == 1 && block [ i * 16 ] ) ff_h264_idct_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n } \n }", "idx": 24688}
{"project": "FFmpeg", "commit_id": "99982524f93a5fc5f8eadd3e8f9b4e3af446cdaa", "target": 0, "func": "static void check_cpu_flag ( const char * name , int flag ) \n { \n int old_cpu_flag = state . cpu_flag ; \n flag |= old_cpu_flag ; \n av_set_cpu_flags_mask ( flag ) ; \n state . cpu_flag = av_get_cpu_flags ( ) ; \n if ( ! flag || state . cpu_flag != old_cpu_flag ) { \n int i ; \n state . cpu_flag_name = name ; \n for ( i = 0 ; tests [ i ] . func ; i ++ ) { \n state . current_test_name = tests [ i ] . name ; \n tests [ i ] . func ( ) ; \n } \n } \n }", "idx": 24699}
{"project": "FFmpeg", "commit_id": "853a97530e0aabfd1474b1679e3dc8be978e5ef8", "target": 0, "func": "static void mp3_parse_vbr_tags ( AVFormatContext * s , AVStream * st , int64_t base ) \n { \n uint32_t v , spf ; \n int frames = -1 ; \n const int64_t xing_offtbl [ 2 ] [ 2 ] = { { 32 , 17 } , { 17 , 9 } } ; \n MPADecodeContext c ; \n v = get_be32 ( s -> pb ) ; \n if ( ff_mpa_check_header ( v ) < 0 ) \n return ; \n ff_mpegaudio_decode_header ( & c , v ) ; \n if ( c . layer != 3 ) \n return ; \n url_fseek ( s -> pb , xing_offtbl [ c . lsf == 1 ] [ c . nb_channels == 1 ] , SEEK_CUR ) ; \n v = get_be32 ( s -> pb ) ; \n if ( v == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) || v == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n v = get_be32 ( s -> pb ) ; \n if ( v & 0x1 ) \n frames = get_be32 ( s -> pb ) ; \n } \n url_fseek ( s -> pb , base + 4 + 32 , SEEK_SET ) ; \n v = get_be32 ( s -> pb ) ; \n if ( v == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n if ( get_be16 ( s -> pb ) == 1 ) { \n url_fseek ( s -> pb , 8 , SEEK_CUR ) ; \n frames = get_be32 ( s -> pb ) ; \n } \n } \n if ( frames < 0 ) \n return ; \n spf = c . lsf ? 576 : 1152 ; \n st -> duration = av_rescale_q ( frames , ( AVRational ) { spf , c . sample_rate } , \n st -> time_base ) ; \n }", "idx": 24827}
{"project": "FFmpeg", "commit_id": "9d8533368f55e1f6a0ea30d6492b26399b030066", "target": 0, "func": "static void mdct512 ( int32_t * out , int16_t * in ) \n { \n int i , re , im , re1 , im1 ; \n int16_t rot [ MDCT_SAMPLES ] ; \n IComplex x [ MDCT_SAMPLES / 4 ] ; \n for ( i = 0 ; i < MDCT_SAMPLES / 4 ; i ++ ) \n rot [ i ] = - in [ i + 3 * MDCT_SAMPLES / 4 ] ; \n for ( ; i < MDCT_SAMPLES ; i ++ ) \n rot [ i ] = in [ i - MDCT_SAMPLES / 4 ] ; \n for ( i = 0 ; i < MDCT_SAMPLES / 4 ; i ++ ) { \n re = ( ( int ) rot [ 2 * i ] - ( int ) rot [ MDCT_SAMPLES - 1 - 2 * i ] ) >> 1 ; \n im = - ( ( int ) rot [ MDCT_SAMPLES / 2 + 2 * i ] - ( int ) rot [ MDCT_SAMPLES / 2 - 1 - 2 * i ] ) >> 1 ; \n CMUL ( x [ i ] . re , x [ i ] . im , re , im , - xcos1 [ i ] , xsin1 [ i ] ) ; \n } \n fft ( x , MDCT_NBITS - 2 ) ; \n for ( i = 0 ; i < MDCT_SAMPLES / 4 ; i ++ ) { \n re = x [ i ] . re ; \n im = x [ i ] . im ; \n CMUL ( re1 , im1 , re , im , xsin1 [ i ] , xcos1 [ i ] ) ; \n out [ 2 * i ] = im1 ; \n out [ MDCT_SAMPLES / 2 - 1 - 2 * i ] = re1 ; \n } \n }", "idx": 24859}
{"project": "FFmpeg", "commit_id": "c084a975aa13eb1d0161f36a06051a9b2d4abb83", "target": 1, "func": "AVFrame * avcodec_alloc_frame ( void ) \n { \n AVFrame * frame = av_malloc ( sizeof ( AVFrame ) ) ; \n if ( frame == NULL ) \n return NULL ; \n avcodec_get_frame_defaults ( frame ) ; \n return frame ; \n }", "idx": 24953}
{"project": "FFmpeg", "commit_id": "985688b8e597b616246746a16649653db6dcf023", "target": 1, "func": "static int mov_write_hdlr_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n const char * descr , * hdlr , * hdlr_type ; \n int64_t pos = url_ftell ( pb ) ; \n if ( ! track ) { \n hdlr = \" \" ; \n hdlr_type = \" \" ; \n descr = \" \" ; \n } else { \n hdlr = ( track -> mode == MODE_MOV ) ? \" \" : \" \\0 \\0 \\0 \\0 \" ; \n if ( track -> enc -> codec_type == CODEC_TYPE_VIDEO ) { \n hdlr_type = \" \" ; \n descr = \" \" ; \n } else if ( track -> enc -> codec_type == CODEC_TYPE_AUDIO ) { \n hdlr_type = \" \" ; \n descr = \" \" ; \n } else if ( track -> enc -> codec_type == CODEC_TYPE_SUBTITLE ) { \n if ( track -> mode == MODE_IPOD ) hdlr_type = \" \" ; \n else hdlr_type = \" \" ; \n descr = \" \" ; \n } \n } \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n put_be32 ( pb , 0 ) ; \n put_buffer ( pb , hdlr , 4 ) ; \n put_tag ( pb , hdlr_type ) ; \n put_be32 ( pb , 0 ) ; \n put_be32 ( pb , 0 ) ; \n put_be32 ( pb , 0 ) ; \n put_byte ( pb , strlen ( descr ) ) ; \n put_buffer ( pb , descr , strlen ( descr ) ) ; \n return updateSize ( pb , pos ) ; \n }", "idx": 24966}
{"project": "FFmpeg", "commit_id": "db85d11d9d880c932b13d37b5f1ca2bc9e3a253b", "target": 1, "func": "static int ftp_features ( FTPContext * s ) \n { \n static const char * feat_command = \" \\r \\n \" ; \n static const char * enable_utf8_command = \" \\r \\n \" ; \n static const int feat_codes [ ] = { 211 , 0 } ; \n static const int opts_codes [ ] = { 200 , 451 } ; \n char * feat ; \n if ( ftp_send_command ( s , feat_command , feat_codes , & feat ) == 211 ) { \n if ( av_stristr ( feat , \" \" ) ) \n ftp_send_command ( s , enable_utf8_command , opts_codes , NULL ) ; \n } \n return 0 ; \n }", "idx": 24985}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "void ffv1_clear_slice_state ( FFV1Context * f , FFV1Context * fs ) \n { \n int i , j ; \n for ( i = 0 ; i < f -> plane_count ; i ++ ) { \n PlaneContext * p = & fs -> plane [ i ] ; \n p -> interlace_bit_state [ 0 ] = 128 ; \n p -> interlace_bit_state [ 1 ] = 128 ; \n if ( fs -> ac ) { \n if ( f -> initial_states [ p -> quant_table_index ] ) { \n memcpy ( p -> state , f -> initial_states [ p -> quant_table_index ] , \n CONTEXT_SIZE * p -> context_count ) ; \n } else \n memset ( p -> state , 128 , CONTEXT_SIZE * p -> context_count ) ; \n } else { \n for ( j = 0 ; j < p -> context_count ; j ++ ) { \n p -> vlc_state [ j ] . drift = 0 ; \n p -> vlc_state [ j ] . error_sum = 4 ; \n p -> vlc_state [ j ] . bias = 0 ; \n p -> vlc_state [ j ] . count = 1 ; \n } \n } \n } \n }", "idx": 25071}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "static int av_buffersrc_add_frame_internal ( AVFilterContext * ctx , \n AVFrame * frame , int flags ) \n { \n BufferSourceContext * s = ctx -> priv ; \n AVFrame * copy ; \n int ret ; \n if ( ! frame ) { \n s -> eof = 1 ; \n return 0 ; \n } else if ( s -> eof ) \n return AVERROR ( EINVAL ) ; \n if ( ! ( flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT ) ) { \n switch ( ctx -> outputs [ 0 ] -> type ) { \n case AVMEDIA_TYPE_VIDEO : \n CHECK_VIDEO_PARAM_CHANGE ( ctx , s , frame -> width , frame -> height , \n frame -> format ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n CHECK_AUDIO_PARAM_CHANGE ( ctx , s , frame -> sample_rate , frame -> channel_layout , \n frame -> format ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n } \n if ( ! av_fifo_space ( s -> fifo ) && \n ( ret = av_fifo_realloc2 ( s -> fifo , av_fifo_size ( s -> fifo ) + \n sizeof ( copy ) ) ) < 0 ) \n return ret ; \n if ( ! ( copy = av_frame_alloc ( ) ) ) \n return AVERROR ( ENOMEM ) ; \n av_frame_move_ref ( copy , frame ) ; \n if ( ( ret = av_fifo_generic_write ( s -> fifo , & copy , sizeof ( copy ) , NULL ) ) < 0 ) { \n av_frame_move_ref ( frame , copy ) ; \n av_frame_free ( & copy ) ; \n return ret ; \n } \n if ( ( flags & AV_BUFFERSRC_FLAG_PUSH ) ) \n if ( ( ret = ctx -> output_pads [ 0 ] . request_frame ( ctx -> outputs [ 0 ] ) ) < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 25077}
{"project": "FFmpeg", "commit_id": "ac1d489320f476c18d6a8125f73389aecb73f3d3", "target": 0, "func": "static int asf_read_seek ( AVFormatContext * s , int stream_index , int64_t pts , int flags ) \n { \n ASFContext * asf = s -> priv_data ; \n AVStream * st = s -> streams [ stream_index ] ; \n int64_t pos ; \n int index ; \n if ( s -> packet_size <= 0 ) \n return -1 ; \n if ( s -> pb ) { \n int ret = avio_seek_time ( s -> pb , stream_index , pts , flags ) ; \n if ( ret >= 0 ) \n asf_reset_header ( s ) ; \n if ( ret != AVERROR ( ENOSYS ) ) \n return ret ; \n } \n if ( ! asf -> index_read ) \n asf_build_simple_index ( s , stream_index ) ; \n if ( ( asf -> index_read && st -> index_entries ) ) { \n index = av_index_search_timestamp ( st , pts , flags ) ; \n if ( index >= 0 ) { \n pos = st -> index_entries [ index ] . pos ; \n av_log ( s , AV_LOG_DEBUG , \" \" PRId64 \" \\n \" , pos ) ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n asf_reset_header ( s ) ; \n return 0 ; \n } \n } \n if ( av_seek_frame_binary ( s , stream_index , pts , flags ) < 0 ) \n return -1 ; \n asf_reset_header ( s ) ; \n return 0 ; \n }", "idx": 25089}
{"project": "FFmpeg", "commit_id": "e3751aa6ec8147ab7ca2649d4daadf8d4dce27d5", "target": 0, "func": "static void decode ( RA288Context * ractx , float gain , int cb_coef ) \n { \n int i , j ; \n double sumsum ; \n float sum , buffer [ 5 ] ; \n memmove ( ractx -> sp_block + 5 , ractx -> sp_block , 36 * sizeof ( * ractx -> sp_block ) ) ; \n for ( i = 4 ; i >= 0 ; i -- ) \n ractx -> sp_block [ i ] = - scalar_product_float ( ractx -> sp_block + i + 1 , \n ractx -> sp_lpc , 36 ) ; \n sum = 32. - scalar_product_float ( ractx -> gain_lpc , ractx -> gain_block , 10 ) ; \n sum = av_clipf ( sum , 0 , 60 ) ; \n sumsum = exp ( sum * 0.1151292546497 ) * gain ; \n for ( i = 0 ; i < 5 ; i ++ ) \n buffer [ i ] = codetable [ cb_coef ] [ i ] * sumsum ; \n sum = scalar_product_float ( buffer , buffer , 5 ) / 5 ; \n sum = FFMAX ( sum , 1 ) ; \n memmove ( ractx -> gain_block , ractx -> gain_block - 1 , \n 10 * sizeof ( * ractx -> gain_block ) ) ; \n * ractx -> gain_block = 10 * log10 ( sum ) - 32 ; \n for ( i = 1 ; i < 5 ; i ++ ) \n for ( j = i - 1 ; j >= 0 ; j -- ) \n buffer [ i ] -= ractx -> sp_lpc [ i - j - 1 ] * buffer [ j ] ; \n for ( i = 0 ; i < 5 ; i ++ ) \n ractx -> sp_block [ 4 - i ] = \n av_clipf ( ractx -> sp_block [ 4 - i ] + buffer [ i ] , -4095 , 4095 ) ; \n }", "idx": 25090}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_4x4_dc_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n int dc = block [ 0 ] ; \n const uint8_t * cm ; \n dc = ( 17 * dc + 4 ) >> 3 ; \n dc = ( 17 * dc + 64 ) >> 7 ; \n cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest += linesize ; \n } \n }", "idx": 25194}
{"project": "FFmpeg", "commit_id": "6950cca97fed890ec56259a2f868f37b65513d92", "target": 0, "func": "int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , \n uint8_t * ptr , const int linesizes [ 4 ] ) \n { \n int i , total_size , size [ 4 ] , has_plane [ 4 ] ; \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ; \n memset ( size , 0 , sizeof ( size ) ) ; \n memset ( has_plane , 0 , sizeof ( has_plane ) ) ; \n if ( desc -> flags & PIX_FMT_HWACCEL ) \n return AVERROR ( EINVAL ) ; \n data [ 0 ] = ptr ; \n size [ 0 ] = linesizes [ 0 ] * height ; \n if ( desc -> flags & PIX_FMT_PAL ) { \n size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ; \n data [ 1 ] = ptr + size [ 0 ] ; \n return size [ 0 ] + 256 * 4 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) \n has_plane [ desc -> comp [ i ] . plane ] = 1 ; \n total_size = size [ 0 ] ; \n for ( i = 1 ; has_plane [ i ] && i < 4 ; i ++ ) { \n int h , s = ( i == 1 || i == 2 ) ? desc -> log2_chroma_h : 0 ; \n data [ i ] = data [ i - 1 ] + size [ i - 1 ] ; \n h = ( height + ( 1 << s ) - 1 ) >> s ; \n size [ i ] = h * linesizes [ i ] ; \n total_size += size [ i ] ; \n } \n return total_size ; \n }", "idx": 25266}
{"project": "FFmpeg", "commit_id": "15c41cb6adc4d6720d51c21f8baebebce923b213", "target": 1, "func": "void ff_thread_await_progress ( ThreadFrame * f , int n , int field ) \n { \n PerThreadContext * p ; \n atomic_int * progress = f -> progress ? ( atomic_int * ) f -> progress -> data : NULL ; \n if ( ! progress || \n atomic_load_explicit ( & progress [ field ] , memory_order_acquire ) >= n ) \n return ; \n p = f -> owner [ field ] -> internal -> thread_ctx ; \n pthread_mutex_lock ( & p -> progress_mutex ) ; \n if ( f -> owner [ field ] -> debug & FF_DEBUG_THREADS ) \n av_log ( f -> owner [ field ] , AV_LOG_DEBUG , \n \" \\n \" , n , field , progress ) ; \n while ( atomic_load_explicit ( & progress [ field ] , memory_order_relaxed ) < n ) \n pthread_cond_wait ( & p -> progress_cond , & p -> progress_mutex ) ; \n pthread_mutex_unlock ( & p -> progress_mutex ) ; \n }", "idx": 25306}
{"project": "FFmpeg", "commit_id": "f0ff20a197dd98d2c0ecef3d183185a5c45c7196", "target": 0, "func": "AVResampleContext * av_resample_init ( int out_rate , int in_rate , int filter_size , int phase_shift , int linear , double cutoff ) { \n AVResampleContext * c = av_mallocz ( sizeof ( AVResampleContext ) ) ; \n double factor = FFMIN ( out_rate * cutoff / in_rate , 1.0 ) ; \n int phase_count = 1 << phase_shift ; \n c -> phase_shift = phase_shift ; \n c -> phase_mask = phase_count - 1 ; \n c -> linear = linear ; \n c -> filter_length = FFMAX ( ceil ( filter_size / factor ) , 1 ) ; \n c -> filter_bank = av_mallocz ( c -> filter_length * ( phase_count + 1 ) * sizeof ( FELEM ) ) ; \n av_build_filter ( c -> filter_bank , factor , c -> filter_length , phase_count , 1 << FILTER_SHIFT , 1 ) ; \n memcpy ( & c -> filter_bank [ c -> filter_length * phase_count + 1 ] , c -> filter_bank , ( c -> filter_length - 1 ) * sizeof ( FELEM ) ) ; \n c -> filter_bank [ c -> filter_length * phase_count ] = c -> filter_bank [ c -> filter_length - 1 ] ; \n c -> src_incr = out_rate ; \n c -> ideal_dst_incr = c -> dst_incr = in_rate * phase_count ; \n c -> index = - phase_count * ( ( c -> filter_length - 1 ) / 2 ) ; \n return c ; \n }", "idx": 25347}
{"project": "FFmpeg", "commit_id": "baf2ffd3297b707dbb5794ec568c61091acf5c0c", "target": 0, "func": "static int mov_read_elst ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n MOVStreamContext * sc = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] -> priv_data ; \n int i , edit_count ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n edit_count = sc -> edit_count = get_be32 ( pb ) ; \n for ( i = 0 ; i < edit_count ; i ++ ) { \n int time ; \n get_be32 ( pb ) ; \n time = get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n if ( time != 0 ) \n av_log ( c -> fc , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n } \n dprintf ( c -> fc , \" \\n \" , c -> fc -> nb_streams - 1 , sc -> edit_count ) ; \n return 0 ; \n }", "idx": 25348}
{"project": "FFmpeg", "commit_id": "53e0d5d7247548743e13c59c35e59fc2161e9582", "target": 1, "func": "static int io_open_default ( AVFormatContext * s , AVIOContext * * pb , \n const char * url , int flags , AVDictionary * * options ) \n { \n #if FF_API_OLD_OPEN_CALLBACKS  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( s -> open_cb )  \n return s -> open_cb ( s , pb , url , flags , & s -> interrupt_callback , options ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n return ffio_open_whitelist ( pb , url , flags , & s -> interrupt_callback , options , s -> protocol_whitelist , s -> protocol_blacklist ) ; \n }", "idx": 25466}
{"project": "FFmpeg", "commit_id": "f4ae3cce64bd46b1d539bdeac39753f83015f114", "target": 1, "func": "static void rstrip_spaces_buf ( AVBPrint * buf ) \n { \n while ( buf -> len > 0 && buf -> str [ buf -> len - 1 ] == ' ' ) \n buf -> str [ -- buf -> len ] = 0 ; \n }", "idx": 25477}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( rgb24ToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToY_mmx ) ( dst , src , width , PIX_FMT_RGB24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int b = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n #endif \n }", "idx": 25481}
{"project": "FFmpeg", "commit_id": "6c23a85000fd5956a2820495b2a081f65d03b962", "target": 1, "func": "static int compand_drain ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n CompandContext * s = ctx -> priv ; \n const int channels = outlink -> channels ; \n AVFrame * frame = NULL ; \n int chan , i , dindex ; \n frame = ff_get_audio_buffer ( outlink , FFMIN ( 2048 , s -> delay_count ) ) ; \n if ( ! frame ) \n return AVERROR ( ENOMEM ) ; \n frame -> pts = s -> pts ; \n s -> pts += av_rescale_q ( frame -> nb_samples , \n ( AVRational ) { 1 , outlink -> sample_rate } , outlink -> time_base ) ; \n for ( chan = 0 ; chan < channels ; chan ++ ) { \n AVFrame * delay_frame = s -> delay_frame ; \n double * dbuf = ( double * ) delay_frame -> extended_data [ chan ] ; \n double * dst = ( double * ) frame -> extended_data [ chan ] ; \n ChanParam * cp = & s -> channels [ chan ] ; \n dindex = s -> delay_index ; \n for ( i = 0 ; i < frame -> nb_samples ; i ++ ) { \n dst [ i ] = av_clipd ( dbuf [ dindex ] * get_volume ( s , cp -> volume ) , \n -1 , 1 ) ; \n dindex = MOD ( dindex + 1 , s -> delay_samples ) ; \n } \n } \n s -> delay_count -= frame -> nb_samples ; \n s -> delay_index = dindex ; \n return ff_filter_frame ( outlink , frame ) ; \n }", "idx": 25489}
{"project": "FFmpeg", "commit_id": "74ef8b434d8d8ef02bee6a5394da849136ed1bf1", "target": 1, "func": "static int rtsp_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPStream * rtsp_st ; \n int ret , len ; \n uint8_t buf [ RTP_MAX_PACKET_LENGTH ] ; \n if ( rt -> cur_rtp ) { \n ret = rtp_parse_packet ( rt -> cur_rtp , pkt , NULL , 0 ) ; \n if ( ret == 0 ) { \n rt -> cur_rtp = NULL ; \n return 0 ; \n } else if ( ret == 1 ) { \n return 0 ; \n } else { \n rt -> cur_rtp = NULL ; \n } \n } \n redo : \n switch ( rt -> protocol ) { \n default : \n case RTSP_PROTOCOL_RTP_TCP : \n len = tcp_read_packet ( s , & rtsp_st , buf , sizeof ( buf ) ) ; \n break ; \n case RTSP_PROTOCOL_RTP_UDP : \n case RTSP_PROTOCOL_RTP_UDP_MULTICAST : \n len = udp_read_packet ( s , & rtsp_st , buf , sizeof ( buf ) ) ; \n if ( rtsp_st -> rtp_ctx ) \n rtp_check_and_send_back_rr ( rtsp_st -> rtp_ctx , len ) ; \n break ; \n } \n if ( len < 0 ) \n return AVERROR_IO ; \n ret = rtp_parse_packet ( rtsp_st -> rtp_ctx , pkt , buf , len ) ; \n if ( ret < 0 ) \n goto redo ; \n if ( ret == 1 ) { \n rt -> cur_rtp = rtsp_st -> rtp_ctx ; \n } \n return 0 ; \n }", "idx": 25500}
{"project": "FFmpeg", "commit_id": "d371c3c2e2830d9783465ecfe1ab7d93351083b7", "target": 1, "func": "static int source_config_props ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n Frei0rContext * s = ctx -> priv ; \n if ( av_image_check_size ( s -> w , s -> h , 0 , ctx ) < 0 ) \n return AVERROR ( EINVAL ) ; \n outlink -> w = s -> w ; \n outlink -> h = s -> h ; \n outlink -> time_base = s -> time_base ; \n if ( ! ( s -> instance = s -> construct ( outlink -> w , outlink -> h ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n return set_params ( ctx , s -> params ) ; \n }", "idx": 25528}
{"project": "FFmpeg", "commit_id": "51b0694bc051cda2bfed048a35e694d1047c6ef0", "target": 0, "func": "const DVprofile * ff_dv_frame_profile2 ( AVCodecContext * codec , const DVprofile * sys , \n const uint8_t * frame , unsigned buf_size ) \n { \n int i ; \n int dsf = ( frame [ 3 ] & 0x80 ) >> 7 ; \n int stype = frame [ 80 * 5 + 48 + 3 ] & 0x1f ; \n if ( dsf == 1 && stype == 0 && frame [ 4 ] & 0x07 \n ) { \n return & dv_profiles [ 2 ] ; \n } \n if ( codec && codec -> codec_tag == AV_RL32 ( \" \" ) && codec -> width == 720 && codec -> height == 576 ) \n return & dv_profiles [ 1 ] ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( dv_profiles ) ; i ++ ) \n if ( dsf == dv_profiles [ i ] . dsf && stype == dv_profiles [ i ] . video_stype ) \n return & dv_profiles [ i ] ; \n if ( sys && buf_size == sys -> frame_size ) \n return sys ; \n return NULL ; \n }", "idx": 25577}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x8l_vertical_add ) ( uint8_t * _pix , const int16_t * _block , \n ptrdiff_t stride ) \n { \n int i ; \n pixel * pix = ( pixel * ) _pix ; \n const dctcoef * block = ( const dctcoef * ) _block ; \n stride >>= sizeof ( pixel ) - 1 ; \n pix -= stride ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixel v = pix [ 0 ] ; \n pix [ 1 * stride ] = v += block [ 0 ] ; \n pix [ 2 * stride ] = v += block [ 8 ] ; \n pix [ 3 * stride ] = v += block [ 16 ] ; \n pix [ 4 * stride ] = v += block [ 24 ] ; \n pix [ 5 * stride ] = v += block [ 32 ] ; \n pix [ 6 * stride ] = v += block [ 40 ] ; \n pix [ 7 * stride ] = v += block [ 48 ] ; \n pix [ 8 * stride ] = v + block [ 56 ] ; \n pix ++ ; \n block ++ ; \n } \n }", "idx": 25777}
{"project": "FFmpeg", "commit_id": "c37de519202ac2e5f20141673081b0e6b57ab983", "target": 1, "func": "int ff_vorbis_len2vlc ( uint8_t * bits , uint32_t * codes , unsigned num ) \n { \n uint32_t exit_at_level [ 33 ] = { 404 } ; \n unsigned i , j , p , code ; \n for ( p = 0 ; ( bits [ p ] == 0 ) && ( p < num ) ; ++ p ) \n ; \n if ( p == num ) \n return 0 ; \n codes [ p ] = 0 ; \n if ( bits [ p ] > 32 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < bits [ p ] ; ++ i ) \n exit_at_level [ i + 1 ] = 1 << i ; \n ++ p ; \n for ( i = p ; ( bits [ i ] == 0 ) && ( i < num ) ; ++ i ) \n ; \n if ( i == num ) \n return 0 ; \n for ( ; p < num ; ++ p ) { \n if ( bits [ p ] > 32 ) \n return AVERROR_INVALIDDATA ; \n if ( bits [ p ] == 0 ) \n continue ; \n for ( i = bits [ p ] ; i > 0 ; -- i ) \n if ( exit_at_level [ i ] ) \n break ; \n if ( ! i ) \n return AVERROR_INVALIDDATA ; \n code = exit_at_level [ i ] ; \n exit_at_level [ i ] = 0 ; \n for ( j = i + 1 ; j <= bits [ p ] ; ++ j ) \n exit_at_level [ j ] = code + ( 1 << ( j - 1 ) ) ; \n codes [ p ] = code ; \n } \n for ( p = 1 ; p < 33 ; p ++ ) \n if ( exit_at_level [ p ] ) \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 25782}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_cdlms ( WmallDecodeCtx * s ) \n { \n int c , i ; \n int cdlms_send_coef = get_bits1 ( & s -> gb ) ; \n for ( c = 0 ; c < s -> num_channels ; c ++ ) { \n s -> cdlms_ttl [ c ] = get_bits ( & s -> gb , 3 ) + 1 ; \n for ( i = 0 ; i < s -> cdlms_ttl [ c ] ; i ++ ) { \n s -> cdlms [ c ] [ i ] . order = ( get_bits ( & s -> gb , 7 ) + 1 ) * 8 ; \n } \n for ( i = 0 ; i < s -> cdlms_ttl [ c ] ; i ++ ) { \n s -> cdlms [ c ] [ i ] . scaling = get_bits ( & s -> gb , 4 ) ; \n } \n if ( cdlms_send_coef ) { \n for ( i = 0 ; i < s -> cdlms_ttl [ c ] ; i ++ ) { \n int cbits , shift_l , shift_r , j ; \n cbits = av_log2 ( s -> cdlms [ c ] [ i ] . order ) ; \n if ( 1 << cbits < s -> cdlms [ c ] [ i ] . order ) \n cbits ++ ; \n s -> cdlms [ c ] [ i ] . coefsend = get_bits ( & s -> gb , cbits ) + 1 ; \n cbits = av_log2 ( s -> cdlms [ c ] [ i ] . scaling + 1 ) ; \n if ( 1 << cbits < s -> cdlms [ c ] [ i ] . scaling + 1 ) \n cbits ++ ; \n s -> cdlms [ c ] [ i ] . bitsend = get_bits ( & s -> gb , cbits ) + 2 ; \n shift_l = 32 - s -> cdlms [ c ] [ i ] . bitsend ; \n shift_r = 32 - 2 - s -> cdlms [ c ] [ i ] . scaling ; \n for ( j = 0 ; j < s -> cdlms [ c ] [ i ] . coefsend ; j ++ ) { \n s -> cdlms [ c ] [ i ] . coefs [ j ] = \n ( get_bits ( & s -> gb , s -> cdlms [ c ] [ i ] . bitsend ) << shift_l ) >> shift_r ; \n } \n } \n } \n } \n }", "idx": 25856}
{"project": "FFmpeg", "commit_id": "44f1698a3824836d32708ae93e78ac1f2310a07e", "target": 1, "func": "static void imdct12 ( int * out , int * in ) \n { \n int in0 , in1 , in2 , in3 , in4 , in5 , t1 , t2 ; \n in0 = in [ 0 * 3 ] << 5 ; \n in1 = ( in [ 1 * 3 ] + in [ 0 * 3 ] ) << 5 ; \n in2 = ( in [ 2 * 3 ] + in [ 1 * 3 ] ) << 5 ; \n in3 = ( in [ 3 * 3 ] + in [ 2 * 3 ] ) << 5 ; \n in4 = ( in [ 4 * 3 ] + in [ 3 * 3 ] ) << 5 ; \n in5 = ( in [ 5 * 3 ] + in [ 4 * 3 ] ) << 5 ; \n in5 += in3 ; \n in3 += in1 ; \n in2 = MULH ( 2 * in2 , C3 ) ; \n in3 = MULH ( 2 * in3 , C3 ) ; \n t1 = in0 - in4 ; \n t2 = MULL ( in1 - in5 , icos36 [ 4 ] ) ; \n out [ 7 ] = \n out [ 10 ] = t1 + t2 ; \n out [ 1 ] = \n out [ 4 ] = t1 - t2 ; \n in0 += in4 >> 1 ; \n in4 = in0 + in2 ; \n in1 += in5 >> 1 ; \n in5 = MULL ( in1 + in3 , icos36 [ 1 ] ) ; \n out [ 8 ] = \n out [ 9 ] = in4 + in5 ; \n out [ 2 ] = \n out [ 3 ] = in4 - in5 ; \n in0 -= in2 ; \n in1 = MULL ( in1 - in3 , icos36 [ 7 ] ) ; \n out [ 0 ] = \n out [ 5 ] = in0 - in1 ; \n out [ 6 ] = \n out [ 11 ] = in0 + in1 ; \n }", "idx": 25889}
{"project": "FFmpeg", "commit_id": "d0d8a9b1384ba3cd465d6ef3439f3979d4518b4b", "target": 1, "func": "void ff_mov_close_hinting ( MOVTrack * track ) { \n AVFormatContext * rtp_ctx = track -> rtp_ctx ; \n uint8_t * ptr ; \n av_freep ( & track -> enc ) ; \n sample_queue_free ( & track -> sample_queue ) ; \n if ( ! rtp_ctx ) \n return ; \n if ( rtp_ctx -> pb ) { \n av_write_trailer ( rtp_ctx ) ; \n url_close_dyn_buf ( rtp_ctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } \n av_metadata_free ( & rtp_ctx -> streams [ 0 ] -> metadata ) ; \n av_metadata_free ( & rtp_ctx -> metadata ) ; \n av_free ( rtp_ctx -> streams [ 0 ] ) ; \n av_freep ( & rtp_ctx ) ; \n }", "idx": 26037}
{"project": "FFmpeg", "commit_id": "a4d70941cd4a82f7db9fbaa2148d60ce550e7611", "target": 1, "func": "static void start_children ( FFStream * feed ) \n { \n if ( no_launch ) \n return ; \n for ( ; feed ; feed = feed -> next ) { \n if ( feed -> child_argv && ! feed -> pid ) { \n feed -> pid_start = time ( 0 ) ; \n feed -> pid = fork ( ) ; \n if ( feed -> pid < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( ! feed -> pid ) { \n char pathname [ 1024 ] ; \n char * slash ; \n int i ; \n for ( i = 3 ; i < 256 ; i ++ ) { \n close ( i ) ; \n } \n if ( ! ffserver_debug ) { \n i = open ( \" \" , O_RDWR ) ; \n if ( i ) \n dup2 ( i , 0 ) ; \n dup2 ( i , 1 ) ; \n dup2 ( i , 2 ) ; \n if ( i ) \n close ( i ) ; \n } \n pstrcpy ( pathname , sizeof ( pathname ) , my_program_name ) ; \n slash = strrchr ( pathname , ' ' ) ; \n if ( ! slash ) { \n slash = pathname ; \n } else { \n slash ++ ; \n } \n strcpy ( slash , \" \" ) ; \n chdir ( my_program_dir ) ; \n execvp ( pathname , feed -> child_argv ) ; \n _exit ( 1 ) ; \n } \n } \n } \n }", "idx": 26174}
{"project": "FFmpeg", "commit_id": "a4fd95b5d511384ed3ce388d8d20a16b1c4c0530", "target": 0, "func": "int ff_h264_check_intra_pred_mode ( H264Context * h , int mode ) { \n MpegEncContext * const s = & h -> s ; \n static const int8_t top [ 7 ] = { LEFT_DC_PRED8x8 , 1 , -1 , -1 } ; \n static const int8_t left [ 7 ] = { TOP_DC_PRED8x8 , -1 , 2 , -1 , DC_128_PRED8x8 } ; \n if ( mode > 6U ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n if ( ! ( h -> top_samples_available & 0x8000 ) ) { \n mode = top [ mode ] ; \n if ( mode < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n } \n if ( ( h -> left_samples_available & 0x8080 ) != 0x8080 ) { \n mode = left [ mode ] ; \n if ( h -> left_samples_available & 0x8080 ) { \n mode = ALZHEIMER_DC_L0T_PRED8x8 + ( ! ( h -> left_samples_available & 0x8000 ) ) + 2 * ( mode == DC_128_PRED8x8 ) ; \n } \n if ( mode < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n } \n return mode ; \n }", "idx": 26180}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static av_cold int v4l2_encode_init ( AVCodecContext * avctx ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n V4L2Context * capture = & s -> capture ; \n V4L2Context * output = & s -> output ; \n int ret ; \n output -> height = capture -> height = avctx -> height ; \n output -> width = capture -> width = avctx -> width ; \n output -> av_codec_id = AV_CODEC_ID_RAWVIDEO ; \n output -> av_pix_fmt = avctx -> pix_fmt ; \n capture -> av_codec_id = avctx -> codec_id ; \n capture -> av_pix_fmt = AV_PIX_FMT_NONE ; \n ret = ff_v4l2_m2m_codec_init ( avctx ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n return v4l2_prepare_encoder ( s ) ; \n }", "idx": 26414}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vp9_decode_slice ( AVCodecContext * avctx , const uint8_t * buffer , uint32_t size ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n void * tmp ; \n tmp = av_fast_realloc ( ctx -> slice_offsets , & ctx -> slice_offsets_allocated , \n ( ctx -> nb_slices + 1 ) * sizeof ( * ctx -> slice_offsets ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n ctx -> slice_offsets = tmp ; \n if ( ! ctx -> bitstream ) \n ctx -> bitstream = ( uint8_t * ) buffer ; \n ctx -> slice_offsets [ ctx -> nb_slices ] = buffer - ctx -> bitstream ; \n ctx -> bitstream_len += size ; \n ctx -> nb_slices ++ ; \n return 0 ; \n }", "idx": 26423}
{"project": "FFmpeg", "commit_id": "4cb6964244fd6c099383d8b7e99731e72cc844b9", "target": 0, "func": "static void int8x8_fmul_int32_c ( float * dst , const int8_t * src , int scale ) \n { \n float fscale = scale / 16.0 ; \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = src [ i ] * fscale ; \n }", "idx": 26459}
{"project": "FFmpeg", "commit_id": "697400eac07c0614f6b9f2e7615563982dbcbe4a", "target": 0, "func": "static int mov_read_chap ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n c -> chapter_track = avio_rb32 ( pb ) ; \n return 0 ; \n }", "idx": 26521}
{"project": "FFmpeg", "commit_id": "f863bee841670384fc46f4f99f511b27eb89a216", "target": 0, "func": "static void final ( Real144_internal * glob , short * i1 , short * i2 , void * out , \n int * statbuf , int len ) \n { \n int x , sum ; \n int buffer [ 10 ] ; \n short * ptr ; \n short * ptr2 ; \n memcpy ( glob -> work , statbuf , 20 ) ; \n memcpy ( glob -> work + 10 , i2 , len * 2 ) ; \n buffer [ 9 ] = i1 [ 0 ] ; \n buffer [ 8 ] = i1 [ 1 ] ; \n buffer [ 7 ] = i1 [ 2 ] ; \n buffer [ 6 ] = i1 [ 3 ] ; \n buffer [ 5 ] = i1 [ 4 ] ; \n buffer [ 4 ] = i1 [ 5 ] ; \n buffer [ 3 ] = i1 [ 6 ] ; \n buffer [ 2 ] = i1 [ 7 ] ; \n buffer [ 1 ] = i1 [ 8 ] ; \n buffer [ 0 ] = i1 [ 9 ] ; \n ptr2 = ( ptr = glob -> work ) + len ; \n while ( ptr < ptr2 ) { \n for ( sum = 0 , x = 0 ; x <= 9 ; x ++ ) \n sum += buffer [ x ] * ( ptr [ x ] ) ; \n sum = sum >> 12 ; \n x = ptr [ 10 ] - sum ; \n if ( x < -32768 || x > 32767 ) { \n memset ( out , 0 , len * 2 ) ; \n memset ( statbuf , 0 , 20 ) ; \n return ; \n } \n ptr [ 10 ] = x ; \n ptr ++ ; \n } \n memcpy ( out , ptr + 10 - len , len * 2 ) ; \n memcpy ( statbuf , ptr , 20 ) ; \n }", "idx": 26525}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static AVBufferRef * vaapi_encode_alloc_output_buffer ( void * opaque , \n int size ) \n { \n AVCodecContext * avctx = opaque ; \n VAAPIEncodeContext * ctx = avctx -> priv_data ; \n VABufferID buffer_id ; \n VAStatus vas ; \n AVBufferRef * ref ; \n vas = vaCreateBuffer ( ctx -> hwctx -> display , ctx -> va_context , \n VAEncCodedBufferType , \n 3 * ctx -> aligned_width * ctx -> aligned_height + \n ( 1 << 16 ) , 1 , 0 , & buffer_id ) ; \n if ( vas != VA_STATUS_SUCCESS ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" , vas , vaErrorStr ( vas ) ) ; \n return NULL ; \n } \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , buffer_id ) ; \n ref = av_buffer_create ( ( uint8_t * ) ( uintptr_t ) buffer_id , \n sizeof ( buffer_id ) , \n & vaapi_encode_free_output_buffer , \n avctx , AV_BUFFER_FLAG_READONLY ) ; \n if ( ! ref ) { \n vaDestroyBuffer ( ctx -> hwctx -> display , buffer_id ) ; \n return NULL ; \n } \n return ref ; \n }", "idx": 26537}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "static void init_multbl2 ( uint8_t tbl [ 1024 ] , const int c [ 4 ] , \n const uint8_t * log8 , const uint8_t * alog8 , \n const uint8_t * sbox ) \n { \n int i , j ; \n for ( i = 0 ; i < 1024 ; i ++ ) { \n int x = sbox [ i >> 2 ] ; \n if ( x ) \n tbl [ i ] = alog8 [ log8 [ x ] + log8 [ c [ i & 3 ] ] ] ; \n } \n #if ! CONFIG_SMALL  \n  \n  for ( j = 256 ; j < 1024 ; j ++ ) \n for ( i = 0 ; i < 4 ; i ++ ) \n tbl [ 4 * j + i ] = tbl [ 4 * j + ( ( i - 1 ) & 3 ) - 1024 ] ; \n #endif \n }", "idx": 26584}
{"project": "FFmpeg", "commit_id": "bd737b5178f361a9b592691848f29a7a79603a7e", "target": 0, "func": "static int decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n int ret ; \n if ( ! avctx -> internal -> is_copy ) \n return 0 ; \n memset ( h -> sps_buffers , 0 , sizeof ( h -> sps_buffers ) ) ; \n memset ( h -> pps_buffers , 0 , sizeof ( h -> pps_buffers ) ) ; \n ret = h264_init_context ( avctx , h ) ; \n if ( ret < 0 ) \n return ret ; \n h -> context_initialized = 0 ; \n return 0 ; \n }", "idx": 26629}
{"project": "FFmpeg", "commit_id": "240fd8c96f59ebe9dcfc4152a1086cd3f63400c0", "target": 0, "func": "int av_packet_split_side_data ( AVPacket * pkt ) { \n if ( ! pkt -> side_data_elems && pkt -> size > 12 && AV_RB64 ( pkt -> data + pkt -> size - 8 ) == FF_MERGE_MARKER ) { \n int i ; \n unsigned int size , orig_pktsize = pkt -> size ; \n uint8_t * p ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 1 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n if ( size > INT_MAX || p - pkt -> data < size ) \n return 0 ; \n if ( p [ 4 ] & 128 ) \n break ; \n p -= size + 5 ; \n } \n pkt -> side_data = av_malloc ( i * sizeof ( * pkt -> side_data ) ) ; \n if ( ! pkt -> side_data ) \n return AVERROR ( ENOMEM ) ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 0 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n av_assert0 ( size <= INT_MAX && p - pkt -> data >= size ) ; \n pkt -> side_data [ i ] . data = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n pkt -> side_data [ i ] . size = size ; \n pkt -> side_data [ i ] . type = p [ 4 ] & 127 ; \n if ( ! pkt -> side_data [ i ] . data ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( pkt -> side_data [ i ] . data , p - size , size ) ; \n pkt -> size -= size + 5 ; \n if ( p [ 4 ] & 128 ) \n break ; \n p -= size + 5 ; \n } \n pkt -> size -= 8 ; \n memset ( pkt -> data + pkt -> size , 0 , \n FFMIN ( orig_pktsize - pkt -> size , FF_INPUT_BUFFER_PADDING_SIZE ) ) ; \n pkt -> side_data_elems = i + 1 ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 26818}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgech ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 26870}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "AVBufferRef * av_buffer_pool_get ( AVBufferPool * pool ) \n { \n AVBufferRef * ret ; \n BufferPoolEntry * buf ; \n buf = get_pool ( pool ) ; \n if ( ! buf ) \n return pool_alloc_buffer ( pool ) ; \n add_to_pool ( buf -> next ) ; \n buf -> next = NULL ; \n ret = av_buffer_create ( buf -> data , pool -> size , pool_release_buffer , \n buf , 0 ) ; \n if ( ! ret ) { \n add_to_pool ( buf ) ; \n return NULL ; \n } \n avpriv_atomic_int_add_and_fetch ( & pool -> refcount , 1 ) ; \n return ret ; \n }", "idx": 26983}
{"project": "FFmpeg", "commit_id": "20035fa24103da9199de3515ca75ba1f6bb275aa", "target": 1, "func": "static int scale_vector ( int16_t * dst , const int16_t * vector , int length ) \n { \n int bits , max = 0 ; \n int i ; \n for ( i = 0 ; i < length ; i ++ ) \n max |= FFABS ( vector [ i ] ) ; \n bits = normalize_bits ( max , 15 ) ; \n if ( bits == 15 ) \n for ( i = 0 ; i < length ; i ++ ) \n dst [ i ] = vector [ i ] * 0x7fff >> 3 ; \n else \n for ( i = 0 ; i < length ; i ++ ) \n dst [ i ] = vector [ i ] << bits >> 3 ; \n return bits - 3 ; \n }", "idx": 26997}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static void handle_char ( CCaptionSubContext * ctx , char hi , char lo , int64_t pts ) \n { \n struct Screen * screen = get_writing_screen ( ctx ) ; \n char * row = screen -> characters [ ctx -> cursor_row ] ; \n int ret ; \n SET_FLAG ( screen -> row_used , ctx -> cursor_row ) ; \n ret = write_char ( ctx , row , ctx -> cursor_column , hi ) ; \n if ( ret == 0 ) \n ctx -> cursor_column ++ ; \n if ( lo ) { \n ret = write_char ( ctx , row , ctx -> cursor_column , lo ) ; \n if ( ret == 0 ) \n ctx -> cursor_column ++ ; \n } \n write_char ( ctx , row , ctx -> cursor_column , 0 ) ; \n ctx -> prev_cmd [ 0 ] = 0 ; \n ctx -> prev_cmd [ 1 ] = 0 ; \n if ( lo ) \n av_dlog ( ctx , \" \\n \" , hi , lo ) ; \n else \n av_dlog ( ctx , \" \\n \" , hi ) ; \n }", "idx": 27067}
{"project": "FFmpeg", "commit_id": "ffa1de8a3b93139097214bc600d356ab62bfdf05", "target": 1, "func": "static void dequantization_int_97 ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j ; \n int w = cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) { \n int32_t * datap = & comp -> i_data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( y + j ) + x ] ; \n int * src = t1 -> data [ j ] ; \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = ( src [ i ] * band -> i_stepsize + ( 1 << 14 ) ) >> 15 ; \n } \n }", "idx": 27135}
{"project": "FFmpeg", "commit_id": "38c48be213b86baa04e64762622afefbba1afa70", "target": 0, "func": "static int mpegts_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MpegTSContext * ts = s -> priv_data ; \n if ( ! ts -> mpeg2ts_raw ) { \n ts -> pkt = pkt ; \n return handle_packets ( ts , 0 ) ; \n } else { \n return mpegts_raw_read_packet ( s , pkt ) ; \n } \n }", "idx": 27183}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int start_frame ( AVFilterLink * link , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = link -> dst ; \n YADIFContext * yadif = ctx -> priv ; \n if ( yadif -> frame_pending ) \n return_frame ( ctx , 1 ) ; \n if ( yadif -> prev ) \n avfilter_unref_buffer ( yadif -> prev ) ; \n yadif -> prev = yadif -> cur ; \n yadif -> cur = yadif -> next ; \n yadif -> next = picref ; \n if ( ! yadif -> cur ) \n return 0 ; \n if ( yadif -> auto_enable && ! yadif -> cur -> video -> interlaced ) { \n yadif -> out = avfilter_ref_buffer ( yadif -> cur , AV_PERM_READ ) ; \n avfilter_unref_bufferp ( & yadif -> prev ) ; \n if ( yadif -> out -> pts != AV_NOPTS_VALUE ) \n yadif -> out -> pts *= 2 ; \n return ff_start_frame ( ctx -> outputs [ 0 ] , yadif -> out ) ; \n } \n if ( ! yadif -> prev ) \n yadif -> prev = avfilter_ref_buffer ( yadif -> cur , AV_PERM_READ ) ; \n yadif -> out = ff_get_video_buffer ( ctx -> outputs [ 0 ] , AV_PERM_WRITE | AV_PERM_PRESERVE | \n AV_PERM_REUSE , link -> w , link -> h ) ; \n avfilter_copy_buffer_ref_props ( yadif -> out , yadif -> cur ) ; \n yadif -> out -> video -> interlaced = 0 ; \n if ( yadif -> out -> pts != AV_NOPTS_VALUE ) \n yadif -> out -> pts *= 2 ; \n return ff_start_frame ( ctx -> outputs [ 0 ] , yadif -> out ) ; \n }", "idx": 27194}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgeh ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_v_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 27199}
{"project": "FFmpeg", "commit_id": "ca203e9985cd2dcf42a0c0853940850d3a8edf3a", "target": 1, "func": "static void calc_thr_3gpp ( const FFPsyWindowInfo * wi , const int num_bands , AacPsyChannel * pch , \n const uint8_t * band_sizes , const float * coefs ) \n { \n int i , w , g ; \n int start = 0 ; \n for ( w = 0 ; w < wi -> num_windows * 16 ; w += 16 ) { \n for ( g = 0 ; g < num_bands ; g ++ ) { \n AacPsyBand * band = & pch -> band [ w + g ] ; \n float form_factor = 0.0f ; \n float Temp ; \n band -> energy = 0.0f ; \n for ( i = 0 ; i < band_sizes [ g ] ; i ++ ) { \n band -> energy += coefs [ start + i ] * coefs [ start + i ] ; \n form_factor += sqrtf ( fabs ( coefs [ start + i ] ) ) ; \n } \n Temp = band -> energy > 0 ? sqrtf ( ( float ) band_sizes [ g ] / band -> energy ) : 0 ; \n band -> thr = band -> energy * 0.001258925f ; \n band -> nz_lines = form_factor * sqrtf ( Temp ) ; \n start += band_sizes [ g ] ; \n } \n } \n }", "idx": 27216}
