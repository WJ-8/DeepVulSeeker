{"project": "FFmpeg", "commit_id": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8", "target": 0, "func": "static void v4l2_free_buffer ( void * opaque , uint8_t * unused ) \n { \n V4L2Buffer * avbuf = opaque ; \n V4L2m2mContext * s = buf_to_m2mctx ( avbuf ) ; \n if ( atomic_fetch_sub ( & avbuf -> context_refcount , 1 ) == 1 ) { \n atomic_fetch_sub_explicit ( & s -> refcount , 1 , memory_order_acq_rel ) ; \n if ( s -> reinit ) { \n if ( ! atomic_load ( & s -> refcount ) ) \n sem_post ( & s -> refsync ) ; \n } else if ( avbuf -> context -> streamon ) \n ff_v4l2_buffer_enqueue ( avbuf ) ; \n av_buffer_unref ( & avbuf -> context_ref ) ; \n } \n }", "idx": 2}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_write ( cl_mem dst_cl_buf , uint8_t * src_buf , size_t buf_size ) \n { \n cl_int status ; \n void * mapped = clEnqueueMapBuffer ( gpu_env . command_queue , dst_cl_buf , \n CL_TRUE , CL_MAP_WRITE , 0 , sizeof ( uint8_t ) * buf_size , \n 0 , NULL , NULL , & status ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n memcpy ( mapped , src_buf , buf_size ) ; \n status = clEnqueueUnmapMemObject ( gpu_env . command_queue , dst_cl_buf , mapped , 0 , NULL , NULL ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n return 0 ; \n }", "idx": 4}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "static int r3d_read_rdvo ( AVFormatContext * s , Atom * atom ) \n { \n R3DContext * r3d = s -> priv_data ; \n AVStream * st = s -> streams [ 0 ] ; \n int i ; \n r3d -> video_offsets_count = ( atom -> size - 8 ) / 4 ; \n r3d -> video_offsets = av_malloc ( atom -> size ) ; \n if ( ! r3d -> video_offsets ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < r3d -> video_offsets_count ; i ++ ) { \n r3d -> video_offsets [ i ] = avio_rb32 ( s -> pb ) ; \n if ( ! r3d -> video_offsets [ i ] ) { \n r3d -> video_offsets_count = i ; \n break ; \n } \n av_dlog ( s , \" \\n \" , i , r3d -> video_offsets [ i ] ) ; \n } \n if ( st -> r_frame_rate . num ) \n st -> duration = av_rescale_q ( r3d -> video_offsets_count , \n ( AVRational ) { st -> r_frame_rate . den , \n st -> r_frame_rate . num } , \n st -> time_base ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , st -> duration ) ; \n return 0 ; \n }", "idx": 5}
{"project": "FFmpeg", "commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "target": 1, "func": "static void check_lowpass_line ( int depth ) { \n LOCAL_ALIGNED_32 ( uint8_t , src ,  [ SRC_SIZE ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , dst_ref ,  [ WIDTH_PADDED ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , dst_new ,  [ WIDTH_PADDED ] ) ; \n int w = WIDTH ; \n int mref = WIDTH_PADDED * -1 ; \n int pref = WIDTH_PADDED ; \n int i , depth_byte ; \n InterlaceContext s ; \n declare_func ( void , uint8_t * dstp , ptrdiff_t linesize , const uint8_t * srcp , \n ptrdiff_t mref , ptrdiff_t pref , int clip_max ) ; \n s . lowpass = 1 ; \n s . lowpass = VLPF_LIN ; \n depth_byte = depth >> 3 ; \n w /= depth_byte ; \n memset ( src , 0 , SRC_SIZE ) ; \n memset ( dst_ref , 0 , WIDTH_PADDED ) ; \n memset ( dst_new , 0 , WIDTH_PADDED ) ; \n randomize_buffers ( src , SRC_SIZE ) ; \n ff_interlace_init ( & s , depth ) ; \n if ( check_func ( s . lowpass_line , \" \" , depth ) ) { \n for ( i = 0 ; i < 32 ; i ++ ) { \n call_ref ( dst_ref , w , src + WIDTH_PADDED , mref - i * depth_byte , pref , 0 ) ; \n call_new ( dst_new , w , src + WIDTH_PADDED , mref - i * depth_byte , pref , 0 ) ; \n if ( memcmp ( dst_ref , dst_new , WIDTH - i ) ) \n fail ( ) ; \n } \n bench_new ( dst_new , w , src + WIDTH_PADDED , mref , pref , 0 ) ; \n } \n }", "idx": 7}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void assert_avoptions ( AVDictionary * m ) \n { \n AVDictionaryEntry * t ; \n if ( ( t = av_dict_get ( m , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , t -> key ) ; \n exit ( 1 ) ; \n } \n }", "idx": 11}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "av_cold void ff_af_queue_init ( AVCodecContext * avctx , AudioFrameQueue * afq ) \n { \n afq -> avctx = avctx ; \n afq -> next_pts = AV_NOPTS_VALUE ; \n afq -> remaining_delay = avctx -> delay ; \n afq -> remaining_samples = avctx -> delay ; \n afq -> frame_queue = NULL ; \n }", "idx": 19}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void quantize_mantissas ( AC3EncodeContext * s ) \n { \n int blk , ch ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n s -> mant1_cnt = s -> mant2_cnt = s -> mant4_cnt = 0 ; \n s -> qmant1_ptr = s -> qmant2_ptr = s -> qmant4_ptr = NULL ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n quantize_mantissas_blk_ch ( s , block -> fixed_coef [ ch ] , block -> exp_shift [ ch ] , \n block -> exp [ ch ] , block -> bap [ ch ] , \n block -> qmant [ ch ] , s -> nb_coefs [ ch ] ) ; \n } \n } \n }", "idx": 21}
{"project": "FFmpeg", "commit_id": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea", "target": 0, "func": "static int mov_write_minf_tag ( AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n int ret ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) \n mov_write_vmhd_tag ( pb ) ; \n else if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO ) \n mov_write_smhd_tag ( pb ) ; \n else if ( track -> enc -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { \n if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) || is_clcp_track ( track ) ) { \n mov_write_gmhd_tag ( pb , track ) ; \n } else { \n mov_write_nmhd_tag ( pb ) ; \n } \n } else if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n mov_write_hmhd_tag ( pb ) ; \n } else if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n mov_write_gmhd_tag ( pb , track ) ; \n } \n if ( track -> mode == MODE_MOV ) \n mov_write_hdlr_tag ( pb , NULL ) ; \n mov_write_dinf_tag ( pb ) ; \n if ( ( ret = mov_write_stbl_tag ( pb , mov , track ) ) < 0 ) \n return ret ; \n return update_size ( pb , pos ) ; \n }", "idx": 27}
{"project": "FFmpeg", "commit_id": "fe0f4e56577a2dbd373bb50b0ae2d49e69d822fc", "target": 0, "func": "int av_packet_ref ( AVPacket * dst , AVPacket * src ) \n { \n int ret ; \n ret = av_packet_copy_props ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! src -> buf ) { \n ret = packet_alloc ( & dst -> buf , src -> size ) ; \n if ( ret < 0 ) \n goto fail ; \n memcpy ( dst -> buf -> data , src -> data , src -> size ) ; \n } else \n dst -> buf = av_buffer_ref ( src -> buf ) ; \n dst -> size = src -> size ; \n dst -> data = dst -> buf -> data ; \n return 0 ; \n fail : \n av_packet_free_side_data ( dst ) ; \n return ret ; \n }", "idx": 28}
{"project": "FFmpeg", "commit_id": "f61bece684d9685b07895508e6c1c733b5564ccf", "target": 0, "func": "av_cold void ff_float_dsp_init_ppc ( AVFloatDSPContext * fdsp , int bit_exact ) \n { \n #if HAVE_ALTIVEC  \n  \n  if ( ! ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) ) \n return ; \n fdsp -> vector_fmul = ff_vector_fmul_altivec ; \n fdsp -> vector_fmul_add = ff_vector_fmul_add_altivec ; \n fdsp -> vector_fmul_reverse = ff_vector_fmul_reverse_altivec ; \n if ( ! bit_exact ) { \n fdsp -> vector_fmul_window = ff_vector_fmul_window_altivec ; \n } \n #endif \n }", "idx": 29}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int rpza_decode_init ( AVCodecContext * avctx ) \n { \n RpzaContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 31}
{"project": "FFmpeg", "commit_id": "f6d49a0dc84aade2adf150c25afb66cbda1d5528", "target": 1, "func": "static void d3d11va_device_uninit ( AVHWDeviceContext * hwdev ) \n { \n AVD3D11VADeviceContext * device_hwctx = hwdev -> hwctx ; \n if ( device_hwctx -> device ) \n ID3D11Device_Release ( device_hwctx -> device ) ; \n if ( device_hwctx -> device_context ) \n ID3D11DeviceContext_Release ( device_hwctx -> device_context ) ; \n if ( device_hwctx -> video_device ) \n ID3D11VideoDevice_Release ( device_hwctx -> video_device ) ; \n if ( device_hwctx -> video_context ) \n ID3D11VideoContext_Release ( device_hwctx -> video_context ) ; \n if ( device_hwctx -> lock == d3d11va_default_lock ) \n CloseHandle ( device_hwctx -> lock_ctx ) ; \n }", "idx": 36}
{"project": "FFmpeg", "commit_id": "5e706a2afb09009bad49c4b12aaa997acf4491b1", "target": 1, "func": "static av_cold int split_init ( AVFilterContext * ctx ) \n { \n SplitContext * s = ctx -> priv ; \n int i ; \n for ( i = 0 ; i < s -> nb_outputs ; i ++ ) { \n char name [ 32 ] ; \n AVFilterPad pad = { 0 } ; \n snprintf ( name , sizeof ( name ) , \" \" , i ) ; \n pad . type = ctx -> filter -> inputs [ 0 ] . type ; \n pad . name = av_strdup ( name ) ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_outpad ( ctx , i , & pad ) ; \n } \n return 0 ; \n }", "idx": 42}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int copy_moof ( AVFormatContext * s , const char * infile , const char * outfile , int64_t size ) \n { \n AVIOContext * in , * out ; \n int ret = 0 ; \n if ( ( ret = avio_open2 ( & in , infile , AVIO_FLAG_READ , & s -> interrupt_callback , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = avio_open2 ( & out , outfile , AVIO_FLAG_WRITE , & s -> interrupt_callback , NULL ) ) < 0 ) { \n avio_close ( in ) ; \n return ret ; \n } \n while ( size > 0 ) { \n uint8_t buf [ 8192 ] ; \n int n = FFMIN ( size , sizeof ( buf ) ) ; \n n = avio_read ( in , buf , n ) ; \n if ( n <= 0 ) { \n ret = AVERROR ( EIO ) ; \n break ; \n } \n avio_write ( out , buf , n ) ; \n size -= n ; \n } \n avio_flush ( out ) ; \n avio_close ( out ) ; \n avio_close ( in ) ; \n return ret ; \n }", "idx": 49}
{"project": "FFmpeg", "commit_id": "595cf1a1aa09f6214eed57bd9eb6493456918efe", "target": 0, "func": "static int truespeech_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n TSContext * c = avctx -> priv_data ; \n int i , j ; \n short * samples = data ; \n int consumed = 0 ; \n int16_t out_buf [ 240 ] ; \n int iterations ; \n if ( ! buf_size ) \n return 0 ; \n if ( buf_size < 32 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , buf_size ) ; \n return -1 ; \n } \n iterations = FFMIN ( buf_size / 32 , * data_size / 480 ) ; \n for ( j = 0 ; j < iterations ; j ++ ) { \n truespeech_read_frame ( c , buf + consumed ) ; \n consumed += 32 ; \n truespeech_correlate_filter ( c ) ; \n truespeech_filters_merge ( c ) ; \n memset ( out_buf , 0 , 240 * 2 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n truespeech_apply_twopoint_filter ( c , i ) ; \n truespeech_place_pulses ( c , out_buf + i * 60 , i ) ; \n truespeech_update_filters ( c , out_buf + i * 60 , i ) ; \n truespeech_synth ( c , out_buf + i * 60 , i ) ; \n } \n truespeech_save_prevvec ( c ) ; \n for ( i = 0 ; i < 240 ; i ++ ) \n * samples ++ = out_buf [ i ] ; \n } \n * data_size = consumed * 15 ; \n return consumed ; \n }", "idx": 61}
{"project": "FFmpeg", "commit_id": "f73f76fd202b310e8e1d0215b2e0cf038cd18c4a", "target": 1, "func": "SwsContext * sws_alloc_context ( void ) \n { \n SwsContext * c = av_mallocz ( sizeof ( SwsContext ) ) ; \n c -> av_class = & sws_context_class ; \n av_opt_set_defaults ( c ) ; \n return c ; \n }", "idx": 78}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( rgb24ToUV_half ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int b = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n } \n }", "idx": 87}
{"project": "FFmpeg", "commit_id": "967d2ae616a1fc6ffc2c00810e09c232dfdb7911", "target": 1, "func": "void ff_xvmc_init_block ( MpegEncContext * s ) \n { \n struct xvmc_render_state * render = ( struct xvmc_render_state * ) s -> current_picture . data [ 2 ] ; \n assert ( render ) ; \n if ( ! render || render -> magic != AV_XVMC_RENDER_MAGIC ) { \n assert ( 0 ) ; \n return ; \n } \n s -> block = ( DCTELEM * ) ( render -> data_blocks + render -> next_free_data_block_num * 64 ) ; \n }", "idx": 90}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mp_decode_frame ( MPADecodeContext * s , \n short * samples ) \n { \n int i , nb_frames , ch ; \n short * samples_ptr ; \n init_get_bits ( & s -> gb , s -> inbuf + HEADER_SIZE , \n s -> inbuf_ptr - s -> inbuf - HEADER_SIZE ) ; \n if ( s -> error_protection ) \n get_bits ( & s -> gb , 16 ) ; \n dprintf ( \" \\n \" , s -> frame_count ) ; \n switch ( s -> layer ) { \n case 1 : \n nb_frames = mp_decode_layer1 ( s ) ; \n break ; \n case 2 : \n nb_frames = mp_decode_layer2 ( s ) ; \n break ; \n case 3 : \n default : \n nb_frames = mp_decode_layer3 ( s ) ; \n break ; \n } \n #if defined ( DEBUG )  \n  \n  for ( i = 0 ; i < nb_frames ; i ++ ) { \n for ( ch = 0 ; ch < s -> nb_channels ; ch ++ ) { \n int j ; \n printf ( \" \" , i , ch ) ; \n for ( j = 0 ; j < SBLIMIT ; j ++ ) \n printf ( \" \" , ( double ) s -> sb_samples [ ch ] [ i ] [ j ] / FRAC_ONE ) ; \n printf ( \" \\n \" ) ; \n } \n } \n #endif \n for ( ch = 0 ; ch < s -> nb_channels ; ch ++ ) { \n samples_ptr = samples + ch ; \n for ( i = 0 ; i < nb_frames ; i ++ ) { \n synth_filter ( s , ch , samples_ptr , s -> nb_channels , \n s -> sb_samples [ ch ] [ i ] ) ; \n samples_ptr += 32 * s -> nb_channels ; \n } \n } \n #ifdef DEBUG \n s -> frame_count ++ ; \n #endif \n return nb_frames * 32 * sizeof ( short ) * s -> nb_channels ; \n }", "idx": 94}
{"project": "FFmpeg", "commit_id": "269fc8e04906ffd965aa19425ca90980b23c6508", "target": 0, "func": "static int write_trailer ( AVFormatContext * s ) \n { \n WVMuxContext * wc = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n ff_ape_write ( s ) ; \n if ( pb -> seekable ) { \n avio_seek ( pb , 12 , SEEK_SET ) ; \n avio_wl32 ( pb , wc -> duration ) ; \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 96}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuyv422_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n }", "idx": 109}
{"project": "FFmpeg", "commit_id": "fd542b6f2026f1aa163882ee0283958598a97c31", "target": 0, "func": "int ff_lock_avcodec ( AVCodecContext * log_ctx , const AVCodec * codec ) \n { \n _Bool exp = 0 ; \n if ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || ! codec -> init ) \n return 0 ; \n if ( lockmgr_cb ) { \n if ( ( * lockmgr_cb ) ( & codec_mutex , AV_LOCK_OBTAIN ) ) \n return -1 ; \n } \n if ( atomic_fetch_add ( & entangled_thread_counter , 1 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n atomic_load ( & entangled_thread_counter ) ) ; \n if ( ! lockmgr_cb ) \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n atomic_store ( & ff_avcodec_locked , 1 ) ; \n ff_unlock_avcodec ( codec ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_assert0 ( atomic_compare_exchange_strong ( & ff_avcodec_locked , & exp , 1 ) ) ; \n return 0 ; \n }", "idx": 118}
{"project": "FFmpeg", "commit_id": "4ea7744859dc3d214ef13e920f5d07b070920e3f", "target": 1, "func": "void FUNCC ( ff_h264_idct_add ) ( uint8_t * _dst , int16_t * _block , int stride ) \n { \n int i ; \n pixel * dst = ( pixel * ) _dst ; \n dctcoef * block = ( dctcoef * ) _block ; \n stride >>= sizeof ( pixel ) - 1 ; \n block [ 0 ] += 1 << 5 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ; \n const int z1 = block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ; \n const int z2 = ( block [ i + 4 * 1 ] >> 1 ) - block [ i + 4 * 3 ] ; \n const int z3 = block [ i + 4 * 1 ] + ( block [ i + 4 * 3 ] >> 1 ) ; \n block [ i + 4 * 0 ] = z0 + z3 ; \n block [ i + 4 * 1 ] = z1 + z2 ; \n block [ i + 4 * 2 ] = z1 - z2 ; \n block [ i + 4 * 3 ] = z0 - z3 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = block [ 0 + 4 * i ] + block [ 2 + 4 * i ] ; \n const int z1 = block [ 0 + 4 * i ] - block [ 2 + 4 * i ] ; \n const int z2 = ( block [ 1 + 4 * i ] >> 1 ) - block [ 3 + 4 * i ] ; \n const int z3 = block [ 1 + 4 * i ] + ( block [ 3 + 4 * i ] >> 1 ) ; \n dst [ i + 0 * stride ] = av_clip_pixel ( dst [ i + 0 * stride ] + ( ( z0 + z3 ) >> 6 ) ) ; \n dst [ i + 1 * stride ] = av_clip_pixel ( dst [ i + 1 * stride ] + ( ( z1 + z2 ) >> 6 ) ) ; \n dst [ i + 2 * stride ] = av_clip_pixel ( dst [ i + 2 * stride ] + ( ( z1 - z2 ) >> 6 ) ) ; \n dst [ i + 3 * stride ] = av_clip_pixel ( dst [ i + 3 * stride ] + ( ( z0 - z3 ) >> 6 ) ) ; \n } \n memset ( block , 0 , 16 * sizeof ( dctcoef ) ) ; \n }", "idx": 119}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static void put_swf_matrix ( ByteIOContext * pb , \n int a , int b , int c , int d , int tx , int ty ) \n { \n PutBitContext p ; \n uint8_t buf [ 256 ] ; \n init_put_bits ( & p , buf , sizeof ( buf ) ) ; \n put_bits ( & p , 1 , 1 ) ; \n put_bits ( & p , 5 , 20 ) ; \n put_bits ( & p , 20 , a ) ; \n put_bits ( & p , 20 , d ) ; \n put_bits ( & p , 1 , 1 ) ; \n put_bits ( & p , 5 , 20 ) ; \n put_bits ( & p , 20 , c ) ; \n put_bits ( & p , 20 , b ) ; \n put_bits ( & p , 5 , 20 ) ; \n put_bits ( & p , 20 , tx ) ; \n put_bits ( & p , 20 , ty ) ; \n flush_put_bits ( & p ) ; \n put_buffer ( pb , buf , pbBufPtr ( & p ) - p . buf ) ; \n }", "idx": 124}
{"project": "FFmpeg", "commit_id": "8bcf5840ea2a6a92c75ab3219f89fe0b8a53cf50", "target": 0, "func": "int ff_nvdec_start_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n FrameDecodeData * fdd = ( FrameDecodeData * ) frame -> private_ref -> data ; \n NVDECFrame * cf = NULL ; \n int ret ; \n ctx -> bitstream_len = 0 ; \n ctx -> nb_slices = 0 ; \n if ( fdd -> hwaccel_priv ) \n return 0 ; \n cf = av_mallocz ( sizeof ( * cf ) ) ; \n if ( ! cf ) \n return AVERROR ( ENOMEM ) ; \n cf -> decoder_ref = av_buffer_ref ( ctx -> decoder_ref ) ; \n if ( ! cf -> decoder_ref ) \n goto fail ; \n cf -> idx_ref = av_buffer_pool_get ( ctx -> decoder_pool ) ; \n if ( ! cf -> idx_ref ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n cf -> idx = * ( unsigned int * ) cf -> idx_ref -> data ; \n fdd -> hwaccel_priv = cf ; \n fdd -> hwaccel_priv_free = nvdec_fdd_priv_free ; \n fdd -> post_process = nvdec_retrieve_data ; \n return 0 ; \n fail : \n nvdec_fdd_priv_free ( cf ) ; \n return ret ; \n }", "idx": 126}
{"project": "FFmpeg", "commit_id": "b1e309865f6b4f67841c811faa5022e492095906", "target": 1, "func": "static int xan_huffman_decode ( unsigned char * dest , const unsigned char * src , \n int dest_len ) \n { \n unsigned char byte = * src ++ ; \n unsigned char ival = byte + 0x16 ; \n const unsigned char * ptr = src + byte * 2 ; \n unsigned char val = ival ; \n unsigned char * dest_end = dest + dest_len ; \n GetBitContext gb ; \n init_get_bits ( & gb , ptr , 0 ) ; \n while ( val != 0x16 ) { \n val = src [ val - 0x17 + get_bits1 ( & gb ) * byte ] ; \n if ( val < 0x16 ) { \n if ( dest + 1 > dest_end ) \n return 0 ; \n * dest ++ = val ; \n val = ival ; \n } \n } \n return 0 ; \n }", "idx": 139}
{"project": "FFmpeg", "commit_id": "01dbbd0a9af53237cf7aac210370892208bfb957", "target": 1, "func": "void MPV_common_end ( MpegEncContext * s ) \n { \n int i ; \n if ( s -> motion_val ) \n free ( s -> motion_val ) ; \n if ( s -> h263_pred ) { \n free ( s -> dc_val [ 0 ] ) ; \n free ( s -> ac_val [ 0 ] ) ; \n free ( s -> coded_block ) ; \n free ( s -> mbintra_table ) ; \n } \n if ( s -> mbskip_table ) \n free ( s -> mbskip_table ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n free ( s -> last_picture_base [ i ] ) ; \n free ( s -> next_picture_base [ i ] ) ; \n if ( s -> has_b_frames ) \n free ( s -> aux_picture_base [ i ] ) ; \n } \n s -> context_initialized = 0 ; \n }", "idx": 141}
{"project": "FFmpeg", "commit_id": "babf4fe01a808327d53977ba319c113a930180b1", "target": 1, "func": "static void idr ( H264Context * h ) { \n int i ; \n ff_h264_remove_all_refs ( h ) ; \n h -> prev_frame_num = 0 ; \n h -> prev_frame_num_offset = 0 ; \n h -> prev_poc_msb = \n h -> prev_poc_lsb = 0 ; \n for ( i = 0 ; i < MAX_DELAYED_PIC_COUNT ; i ++ ) \n h -> last_pocs [ i ] = INT_MIN ; \n }", "idx": 153}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void parse_context_init ( SchroParseUnitContext * parse_ctx , \n const uint8_t * buf , int buf_size ) \n { \n parse_ctx -> buf = buf ; \n parse_ctx -> buf_size = buf_size ; \n }", "idx": 157}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static void libopus_write_header ( AVCodecContext * avctx , int stream_count , \n int coupled_stream_count , \n const uint8_t * channel_mapping ) \n { \n uint8_t * p = avctx -> extradata ; \n int channels = avctx -> channels ; \n bytestream_put_buffer ( & p , \" \" , 8 ) ; \n bytestream_put_byte ( & p , 1 ) ; \n bytestream_put_byte ( & p , channels ) ; \n bytestream_put_le16 ( & p , avctx -> delay ) ; \n bytestream_put_le32 ( & p , avctx -> sample_rate ) ; \n bytestream_put_le16 ( & p , 0 ) ; \n if ( channels > 2 ) { \n bytestream_put_byte ( & p , channels <= 8 ? 1 : 255 ) ; \n bytestream_put_byte ( & p , stream_count ) ; \n bytestream_put_byte ( & p , coupled_stream_count ) ; \n bytestream_put_buffer ( & p , channel_mapping , channels ) ; \n } else { \n bytestream_put_byte ( & p , 0 ) ; \n } \n }", "idx": 189}
{"project": "FFmpeg", "commit_id": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea", "target": 0, "func": "static int mov_write_tmcd_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n #if 1  \n  \n  int frame_duration = av_rescale ( track -> timescale , track -> enc -> time_base . num , track -> enc -> time_base . den ) ; \n int nb_frames = ROUNDED_DIV ( track -> enc -> time_base . den , track -> enc -> time_base . num ) ; \n AVDictionaryEntry * t = NULL ; \n if ( nb_frames > 255 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , nb_frames ) ; \n return AVERROR ( EINVAL ) ; \n } \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 1 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , track -> timecode_flags ) ; \n avio_wb32 ( pb , track -> timescale ) ; \n avio_wb32 ( pb , frame_duration ) ; \n avio_w8 ( pb , nb_frames ) ; \n avio_w8 ( pb , 0 ) ; \n if ( track -> st ) \n t = av_dict_get ( track -> st -> metadata , \" \" , NULL , 0 ) ; \n if ( t && utf8len ( t -> value ) ) \n mov_write_source_reference_tag ( pb , track , t -> value ) ; \n else \n avio_wb16 ( pb , 0 ) ; \n #else \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 1 ) ; \n if ( track -> enc -> extradata_size ) \n avio_write ( pb , track -> enc -> extradata , track -> enc -> extradata_size ) ; \n #endif \n return update_size ( pb , pos ) ; \n }", "idx": 190}
{"project": "FFmpeg", "commit_id": "a050cf0c451bdf1c1bd512c4fce6b6f8a5e85102", "target": 0, "func": "static int expand_rle_row16 ( SgiState * s , uint16_t * out_buf , \n int len , int pixelstride ) \n { \n unsigned short pixel ; \n unsigned char count ; \n unsigned short * orig = out_buf ; \n uint16_t * out_end = out_buf + len ; \n while ( out_buf < out_end ) { \n if ( bytestream2_get_bytes_left ( & s -> g ) < 2 ) \n return AVERROR_INVALIDDATA ; \n pixel = bytestream2_get_be16u ( & s -> g ) ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) \n break ; \n if ( pixelstride * ( count - 1 ) >= len ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n pixel = bytestream2_get_ne16 ( & s -> g ) ; \n AV_WN16A ( out_buf , pixel ) ; \n out_buf += pixelstride ; \n } \n } else { \n pixel = bytestream2_get_ne16 ( & s -> g ) ; \n while ( count -- ) { \n AV_WN16A ( out_buf , pixel ) ; \n out_buf += pixelstride ; \n } \n } \n } \n return ( out_buf - orig ) / pixelstride ; \n }", "idx": 192}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "func": "int av_buffersink_get_frame ( AVFilterContext * ctx , AVFrame * frame ) \n { \n BufferSinkContext * s = ctx -> priv ; \n AVFilterLink * link = ctx -> inputs [ 0 ] ; \n int ret ; \n if ( ( ret = ff_request_frame ( link ) ) < 0 ) \n return ret ; \n if ( ! s -> cur_frame ) \n return AVERROR ( EINVAL ) ; \n av_frame_move_ref ( frame , s -> cur_frame ) ; \n av_frame_free ( & s -> cur_frame ) ; \n return 0 ; \n }", "idx": 197}
{"project": "FFmpeg", "commit_id": "26f6b8c571bcff7b325c7d6cc226c625dd465f8e", "target": 1, "func": "int ffurl_read_complete ( URLContext * h , unsigned char * buf , int size ) \n { \n if ( h -> flags & AVIO_FLAG_WRITE ) \n return AVERROR ( EIO ) ; \n return retry_transfer_wrapper ( h , buf , size , size , h -> prot -> url_read ) ; \n }", "idx": 209}
{"project": "FFmpeg", "commit_id": "2fa6d21124bd2fc0b186290f5313179263bfcfb7", "target": 0, "func": "static int on2avc_decode_band_scales ( On2AVCContext * c , GetBitContext * gb ) \n { \n int w , w2 , b , scale , first = 1 ; \n int band_off = 0 ; \n for ( w = 0 ; w < c -> num_windows ; w ++ ) { \n if ( ! c -> grouping [ w ] ) { \n memcpy ( c -> band_scales + band_off , \n c -> band_scales + band_off - c -> num_bands , \n c -> num_bands * sizeof ( * c -> band_scales ) ) ; \n band_off += c -> num_bands ; \n continue ; \n } \n for ( b = 0 ; b < c -> num_bands ; b ++ ) { \n if ( ! c -> band_type [ band_off ] ) { \n int all_zero = 1 ; \n for ( w2 = w + 1 ; w2 < c -> num_windows ; w2 ++ ) { \n if ( c -> grouping [ w2 ] ) \n break ; \n if ( c -> band_type [ w2 * c -> num_bands + b ] ) { \n all_zero = 0 ; \n break ; \n } \n } \n if ( all_zero ) { \n c -> band_scales [ band_off ++ ] = 0 ; \n continue ; \n } \n } \n if ( first ) { \n scale = get_bits ( gb , 7 ) ; \n first = 0 ; \n } else { \n scale += get_vlc2 ( gb , c -> scale_diff . table , 9 , 3 ) - 60 ; \n } \n if ( scale < 0 || scale > 128 ) { \n av_log ( c -> avctx , AV_LOG_ERROR , \" \\n \" , \n scale ) ; \n return AVERROR_INVALIDDATA ; \n } \n c -> band_scales [ band_off ++ ] = c -> scale_tab [ scale ] ; \n } \n } \n return 0 ; \n }", "idx": 216}
{"project": "FFmpeg", "commit_id": "4b370d6126ab74c6112e2c1edfad3f48ebcf08ad", "target": 0, "func": "static inline void writer_print_rational ( WriterContext * wctx , \n const char * key , AVRational q , char sep ) \n { \n AVBPrint buf ; \n av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; \n av_bprintf ( & buf , \" \" , q . num , sep , q . den ) ; \n wctx -> writer -> print_string ( wctx , key , buf . str ) ; \n wctx -> nb_item ++ ; \n }", "idx": 217}
{"project": "FFmpeg", "commit_id": "a9493601638b048c44751956d2360f215918800c", "target": 0, "func": "void * av_realloc ( void * ptr , unsigned int size ) \n { \n #ifdef MEMALIGN_HACK \n int diff ; \n #endif \n if ( size > INT_MAX ) \n return NULL ; \n #ifdef MEMALIGN_HACK \n if ( ! ptr ) return av_malloc ( size ) ; \n diff = ( ( char * ) ptr ) [ -1 ] ; \n return realloc ( ptr - diff , size + diff ) + diff ; \n #else \n return realloc ( ptr , size ) ; \n #endif \n }", "idx": 237}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int mmf_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 32 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 8 ] == ' ' && p -> buf [ 9 ] == ' ' && \n p -> buf [ 10 ] == ' ' && p -> buf [ 11 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 238}
{"project": "FFmpeg", "commit_id": "f1d8763a02b5fce9a7d9789e049d74a45b15e1e8", "target": 1, "func": "static void clone_slice ( H264Context * dst , H264Context * src ) \n { \n memcpy ( dst -> block_offset , src -> block_offset , sizeof ( dst -> block_offset ) ) ; \n dst -> s . current_picture_ptr = src -> s . current_picture_ptr ; \n dst -> s . current_picture = src -> s . current_picture ; \n dst -> s . linesize = src -> s . linesize ; \n dst -> s . uvlinesize = src -> s . uvlinesize ; \n dst -> s . first_field = src -> s . first_field ; \n dst -> prev_poc_msb = src -> prev_poc_msb ; \n dst -> prev_poc_lsb = src -> prev_poc_lsb ; \n dst -> prev_frame_num_offset = src -> prev_frame_num_offset ; \n dst -> prev_frame_num = src -> prev_frame_num ; \n dst -> short_ref_count = src -> short_ref_count ; \n memcpy ( dst -> short_ref , src -> short_ref , sizeof ( dst -> short_ref ) ) ; \n memcpy ( dst -> long_ref , src -> long_ref , sizeof ( dst -> long_ref ) ) ; \n memcpy ( dst -> default_ref_list , src -> default_ref_list , sizeof ( dst -> default_ref_list ) ) ; \n memcpy ( dst -> ref_list , src -> ref_list , sizeof ( dst -> ref_list ) ) ; \n memcpy ( dst -> dequant4_coeff , src -> dequant4_coeff , sizeof ( src -> dequant4_coeff ) ) ; \n memcpy ( dst -> dequant8_coeff , src -> dequant8_coeff , sizeof ( src -> dequant8_coeff ) ) ; \n }", "idx": 247}
{"project": "FFmpeg", "commit_id": "9123950be0dbbfceacb38c0a9b09fdb01ae5b111", "target": 1, "func": "static void mxf_packet_timestamps ( MXFContext * mxf , AVPacket * pkt ) \n { \n int64_t last_ofs = -1 , next_ofs ; \n MXFIndexTable * t = & mxf -> index_tables [ 0 ] ; \n if ( mxf -> nb_index_tables <= 0 ) \n return ; \n for ( ; ; ) { \n if ( mxf_edit_unit_absolute_offset ( mxf , t , mxf -> current_edit_unit + 1 , NULL , & next_ofs , 0 ) < 0 ) \n break ; \n if ( next_ofs <= last_ofs ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \n \" \\n \" ) ; \n return ; \n } \n if ( next_ofs > pkt -> pos ) \n break ; \n last_ofs = next_ofs ; \n mxf -> current_edit_unit ++ ; \n } \n if ( mxf -> current_edit_unit >= t -> nb_ptses ) \n return ; \n pkt -> dts = mxf -> current_edit_unit + t -> first_dts ; \n pkt -> pts = t -> ptses [ mxf -> current_edit_unit ] ; \n }", "idx": 250}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16intra_mmx ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] || block [ i * 16 ] ) \n ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 251}
{"project": "FFmpeg", "commit_id": "cece491daa9f4c7c908e016f4e285a49d37cb17c", "target": 0, "func": "static void process_subpacket_9 ( QDM2Context * q , QDM2SubPNode * node ) \n { \n GetBitContext gb ; \n int i , j , k , n , ch , run , level , diff ; \n init_get_bits ( & gb , node -> packet -> data , node -> packet -> size * 8 ) ; \n n = coeff_per_sb_for_avg [ q -> coeff_per_sb_select ] [ QDM2_SB_USED ( q -> sub_sampling ) - 1 ] + 1 ; \n for ( i = 1 ; i < n ; i ++ ) \n for ( ch = 0 ; ch < q -> nb_channels ; ch ++ ) { \n level = qdm2_get_vlc ( & gb , & vlc_tab_level , 0 , 2 ) ; \n q -> quantized_coeffs [ ch ] [ i ] [ 0 ] = level ; \n for ( j = 0 ; j < ( 8 - 1 ) ; ) { \n run = qdm2_get_vlc ( & gb , & vlc_tab_run , 0 , 1 ) + 1 ; \n diff = qdm2_get_se_vlc ( & vlc_tab_diff , & gb , 2 ) ; \n for ( k = 1 ; k <= run ; k ++ ) \n q -> quantized_coeffs [ ch ] [ i ] [ j + k ] = ( level + ( ( k * diff ) / run ) ) ; \n level += diff ; \n j += run ; \n } \n } \n for ( ch = 0 ; ch < q -> nb_channels ; ch ++ ) \n for ( i = 0 ; i < 8 ; i ++ ) \n q -> quantized_coeffs [ ch ] [ 0 ] [ i ] = 0 ; \n }", "idx": 252}
{"project": "FFmpeg", "commit_id": "3f50965b28d0c4ef10dde0bf2f7a9f78fa36b378", "target": 0, "func": "static inline void h264_loop_filter_chroma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int8_t * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int tc = tc0 [ i ] ; \n if ( tc <= 0 ) { \n pix += 2 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 2 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n int delta = av_clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = av_clip_uint8 ( p0 + delta ) ; \n pix [ 0 ] = av_clip_uint8 ( q0 - delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 254}
{"project": "FFmpeg", "commit_id": "100a54da5264436202daeedd68ed5e4a8be41459", "target": 1, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , const uint8_t * src_end , \n int width , int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * src_start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n if ( end - dst < count ) { \n av_log ( l -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n if ( i + 2 >= src_end - src ) \n return AVERROR_INVALIDDATA ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n dst += i ; \n } \n } \n return src - src_start ; \n }", "idx": 256}
{"project": "FFmpeg", "commit_id": "2779d33ed99898675e0b3884fabe1ce6839f36d1", "target": 1, "func": "static int adts_aac_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , fsize ; \n ret = av_get_packet ( s -> pb , pkt , ADTS_HEADER_SIZE ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ret < ADTS_HEADER_SIZE ) { \n av_packet_unref ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n if ( ( AV_RB16 ( pkt -> data ) >> 4 ) != 0xfff ) { \n av_packet_unref ( pkt ) ; \n return AVERROR_INVALIDDATA ; \n } \n fsize = ( AV_RB32 ( pkt -> data + 3 ) >> 13 ) & 0x1FFF ; \n if ( fsize < ADTS_HEADER_SIZE ) { \n av_packet_unref ( pkt ) ; \n return AVERROR_INVALIDDATA ; \n } \n return av_append_packet ( s -> pb , pkt , fsize - ADTS_HEADER_SIZE ) ; \n }", "idx": 261}
{"project": "FFmpeg", "commit_id": "a37fd7f9578d2dfbe20a109aae91e5f0a4b58874", "target": 1, "func": "static int bgr24ToYv12Wrapper ( SwsContext * c , const uint8_t * src [ ] , \n int srcStride [ ] , int srcSliceY , int srcSliceH , \n uint8_t * dst [ ] , int dstStride [ ] ) \n { \n rgb24toyv12 ( \n src [ 0 ] , \n dst [ 0 ] + srcSliceY * dstStride [ 0 ] , \n dst [ 1 ] + ( srcSliceY >> 1 ) * dstStride [ 1 ] , \n dst [ 2 ] + ( srcSliceY >> 1 ) * dstStride [ 2 ] , \n c -> srcW , srcSliceH , \n dstStride [ 0 ] , dstStride [ 1 ] , srcStride [ 0 ] ) ; \n if ( dst [ 3 ] ) \n fillPlane ( dst [ 3 ] , dstStride [ 3 ] , c -> srcW , srcSliceH , srcSliceY , 255 ) ; \n return srcSliceH ; \n }", "idx": 263}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr32 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = 0 ; \n } \n }", "idx": 264}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp5_parse_header ( VP56Context * s , const uint8_t * buf , int buf_size ) \n { \n VP56RangeCoder * c = & s -> c ; \n int rows , cols ; \n ff_vp56_init_range_decoder ( & s -> c , buf , buf_size ) ; \n s -> frames [ VP56_FRAME_CURRENT ] -> key_frame = ! vp56_rac_get ( c ) ; \n vp56_rac_get ( c ) ; \n ff_vp56_init_dequant ( s , vp56_rac_gets ( c , 6 ) ) ; \n if ( s -> frames [ VP56_FRAME_CURRENT ] -> key_frame ) \n { \n vp56_rac_gets ( c , 8 ) ; \n if ( vp56_rac_gets ( c , 5 ) > 5 ) \n return AVERROR_INVALIDDATA ; \n vp56_rac_gets ( c , 2 ) ; \n if ( vp56_rac_get ( c ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n rows = vp56_rac_gets ( c , 8 ) ; \n cols = vp56_rac_gets ( c , 8 ) ; \n if ( ! rows || ! cols ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n cols << 4 , rows << 4 ) ; \n return AVERROR_INVALIDDATA ; \n } \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 2 ) ; \n if ( ! s -> macroblocks || \n 16 * cols != s -> avctx -> coded_width || \n 16 * rows != s -> avctx -> coded_height ) { \n int ret = ff_set_dimensions ( s -> avctx , 16 * cols , 16 * rows ) ; \n if ( ret < 0 ) \n return ret ; \n return VP56_SIZE_CHANGE ; \n } \n } else if ( ! s -> macroblocks ) \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 266}
{"project": "FFmpeg", "commit_id": "92da23093c784b1d9f0db4db51d28ea80a59e759", "target": 1, "func": "static inline int coeff_unpack_golomb ( GetBitContext * gb , int qfactor , int qoffset ) \n { \n int coeff = dirac_get_se_golomb ( gb ) ; \n const int sign = FFSIGN ( coeff ) ; \n if ( coeff ) \n coeff = sign * ( ( sign * coeff * qfactor + qoffset ) >> 2 ) ; \n return coeff ; \n }", "idx": 267}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_ac_filter ( WmallDecodeCtx * s ) \n { \n int i ; \n s -> acfilter_order = get_bits ( & s -> gb , 4 ) + 1 ; \n s -> acfilter_scaling = get_bits ( & s -> gb , 4 ) ; \n for ( i = 0 ; i < s -> acfilter_order ; i ++ ) { \n s -> acfilter_coeffs [ i ] = get_bits ( & s -> gb , s -> acfilter_scaling ) + 1 ; \n } \n }", "idx": 275}
{"project": "FFmpeg", "commit_id": "56c182c4d716b8b72156ff57a0c8d72087db8549", "target": 1, "func": "static int nut_write_trailer ( AVFormatContext * s ) \n { \n NUTContext * nut = s -> priv_data ; \n AVIOContext * bc = s -> pb , * dyn_bc ; \n int i , ret ; \n while ( nut -> header_count < 3 ) \n write_headers ( s , bc ) ; \n ret = avio_open_dyn_buf ( & dyn_bc ) ; \n if ( ret >= 0 && nut -> sp_count ) { \n av_assert1 ( nut -> write_index ) ; \n write_index ( nut , dyn_bc ) ; \n put_packet ( nut , bc , dyn_bc , 1 , INDEX_STARTCODE ) ; \n } \n ff_nut_free_sp ( nut ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n av_freep ( & nut -> stream [ i ] . keyframe_pts ) ; \n av_freep ( & nut -> stream ) ; \n av_freep ( & nut -> chapter ) ; \n av_freep ( & nut -> time_base ) ; \n return 0 ; \n }", "idx": 282}
{"project": "FFmpeg", "commit_id": "4b90c35d74880b07c50b3392a338f0f00d10302f", "target": 0, "func": "static void group_exponents ( AC3EncodeContext * s ) \n { \n int blk , ch , i ; \n int group_size , nb_groups , bit_count ; \n uint8_t * p ; \n int delta0 , delta1 , delta2 ; \n int exp0 , exp1 ; \n bit_count = 0 ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n if ( s -> exp_strategy [ ch ] [ blk ] == EXP_REUSE ) \n continue ; \n group_size = s -> exp_strategy [ ch ] [ blk ] + ( s -> exp_strategy [ ch ] [ blk ] == EXP_D45 ) ; \n nb_groups = exponent_group_tab [ s -> exp_strategy [ ch ] [ blk ] - 1 ] [ s -> nb_coefs [ ch ] ] ; \n bit_count += 4 + ( nb_groups * 7 ) ; \n p = block -> exp [ ch ] ; \n exp1 = * p ++ ; \n block -> grouped_exp [ ch ] [ 0 ] = exp1 ; \n for ( i = 1 ; i <= nb_groups ; i ++ ) { \n exp0 = exp1 ; \n exp1 = p [ 0 ] ; \n p += group_size ; \n delta0 = exp1 - exp0 + 2 ; \n exp0 = exp1 ; \n exp1 = p [ 0 ] ; \n p += group_size ; \n delta1 = exp1 - exp0 + 2 ; \n exp0 = exp1 ; \n exp1 = p [ 0 ] ; \n p += group_size ; \n delta2 = exp1 - exp0 + 2 ; \n block -> grouped_exp [ ch ] [ i ] = ( ( delta0 * 5 + delta1 ) * 5 ) + delta2 ; \n } \n } \n } \n s -> exponent_bits = bit_count ; \n }", "idx": 288}
{"project": "FFmpeg", "commit_id": "4b0e0f31bf0f618a634dcfdca45e72cdfb0b48b5", "target": 1, "func": "av_cold int ff_lpc_init ( LPCContext * s , int blocksize , int max_order , \n enum FFLPCType lpc_type ) \n { \n s -> blocksize = blocksize ; \n s -> max_order = max_order ; \n s -> lpc_type = lpc_type ; \n if ( lpc_type == FF_LPC_TYPE_LEVINSON ) { \n s -> windowed_samples = av_mallocz ( ( blocksize + max_order + 2 ) * \n sizeof ( * s -> windowed_samples ) ) ; \n if ( ! s -> windowed_samples ) \n return AVERROR ( ENOMEM ) ; \n } else { \n s -> windowed_samples = NULL ; \n } \n s -> lpc_apply_welch_window = lpc_apply_welch_window_c ; \n s -> lpc_compute_autocorr = lpc_compute_autocorr_c ; \n if ( HAVE_MMX ) \n ff_lpc_init_x86 ( s ) ; \n return 0 ; \n }", "idx": 303}
{"project": "FFmpeg", "commit_id": "44ca80df3445a59bc065924d8c6110fa10367d01", "target": 0, "func": "static void filter_mb_mbaff_edgecv ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 7 ] , int bsi , int qp ) { \n int index_a = qp + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 327}
{"project": "FFmpeg", "commit_id": "ff2c222c379645cb7825b8ddc222142dcaea1677", "target": 1, "func": "ebml_read_ascii ( MatroskaDemuxContext * matroska , \n uint32_t * id , \n char * * str )  \n { \n ByteIOContext * pb = matroska -> ctx -> pb ; \n int size , res ; \n uint64_t rlength ; \n if ( ( res = ebml_read_element_id ( matroska , id , NULL ) ) < 0 || \n ( res = ebml_read_element_length ( matroska , & rlength ) ) < 0 ) \n return res ; \n size = rlength ; \n if ( size < 0 || ! ( * str = av_malloc ( size + 1 ) ) ) { \n av_log ( matroska -> ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( get_buffer ( pb , ( uint8_t * ) * str , size ) != size ) { \n offset_t pos = url_ftell ( pb ) ; \n av_log ( matroska -> ctx , AV_LOG_ERROR , \n \" \" PRIu64 \" \" PRIx64 \" \\n \" , pos , pos ) ; \n return AVERROR ( EIO ) ; \n } \n ( * str ) [ size ] = ' \\0 ' ; \n return 0 ; \n }", "idx": 343}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "RGB_FUNCTIONS ( rgba32 )  \n #undef  RGB_IN  \n  \n  #undef  RGB_OUT  \n  \n  #undef  BPP  \n  \n  \n  \n  \n  \n  static void rgb24_to_rgb565 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n const unsigned char * p ; \n unsigned char * q ; \n int r , g , b , dst_wrap , src_wrap ; \n int x , y ; \n p = src -> data [ 0 ] ; \n src_wrap = src -> linesize [ 0 ] - 3 * width ; \n q = dst -> data [ 0 ] ; \n dst_wrap = dst -> linesize [ 0 ] - 2 * width ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n r = p [ 0 ] ; \n g = p [ 1 ] ; \n b = p [ 2 ] ; \n ( ( unsigned short * ) q ) [ 0 ] = \n ( ( r >> 3 ) << 11 ) | ( ( g >> 2 ) << 5 ) | ( b >> 3 ) ; \n q += 2 ; \n p += 3 ; \n } \n p += src_wrap ; \n q += dst_wrap ; \n } \n }", "idx": 347}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_mid_and_aver_dst_16x16_msa ( const uint8_t * src , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride ) \n { \n avc_luma_mid_and_aver_dst_8w_msa ( src , src_stride , dst , dst_stride , 16 ) ; \n avc_luma_mid_and_aver_dst_8w_msa ( src + 8 , src_stride , dst + 8 , dst_stride , \n 16 ) ; \n }", "idx": 348}
{"project": "FFmpeg", "commit_id": "594026277250fecf0ba34c9e1498921936c6bfed", "target": 0, "func": "void MPV_common_init_armv4l ( MpegEncContext * s ) \n { \n int i ; \n const int idct_algo = s -> avctx -> idct_algo ; \n ff_put_pixels_clamped = s -> avctx -> dsp . put_pixels_clamped ; \n ff_add_pixels_clamped = s -> avctx -> dsp . put_pixels_clamped ; \n if ( idct_algo == FF_IDCT_AUTO || idct_algo == FF_IDCT_ARM ) { \n s -> idct_put = arm_idct_put ; \n s -> idct_add = arm_idct_add ; \n s -> idct_permutation_type = FF_NO_IDCT_PERM ; \n } \n }", "idx": 349}
{"project": "FFmpeg", "commit_id": "c2340831b8e9032716acb0aab4893d3cc500213a", "target": 0, "func": "static int sbr_hf_calc_npatches ( AACContext * ac , SpectralBandReplication * sbr ) \n { \n int i , k , sb = 0 ; \n int msb = sbr -> k [ 0 ] ; \n int usb = sbr -> kx [ 1 ] ; \n int goal_sb = ( ( 1000 << 11 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ; \n sbr -> num_patches = 0 ; \n if ( goal_sb < sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) { \n for ( k = 0 ; sbr -> f_master [ k ] < goal_sb ; k ++ ) ; \n } else \n k = sbr -> n_master ; \n do { \n int odd = 0 ; \n for ( i = k ; i == k || sb > ( sbr -> k [ 0 ] - 1 + msb - odd ) ; i -- ) { \n sb = sbr -> f_master [ i ] ; \n odd = ( sb + sbr -> k [ 0 ] ) & 1 ; \n } \n if ( sbr -> num_patches > 5 ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , \" \\n \" , sbr -> num_patches ) ; \n return -1 ; \n } \n sbr -> patch_num_subbands [ sbr -> num_patches ] = FFMAX ( sb - usb , 0 ) ; \n sbr -> patch_start_subband [ sbr -> num_patches ] = sbr -> k [ 0 ] - odd - sbr -> patch_num_subbands [ sbr -> num_patches ] ; \n if ( sbr -> patch_num_subbands [ sbr -> num_patches ] > 0 ) { \n usb = sb ; \n msb = sb ; \n sbr -> num_patches ++ ; \n } else \n msb = sbr -> kx [ 1 ] ; \n if ( sbr -> f_master [ k ] - sb < 3 ) \n k = sbr -> n_master ; \n } while ( sb != sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) ; \n if ( sbr -> patch_num_subbands [ sbr -> num_patches - 1 ] < 3 && sbr -> num_patches > 1 ) \n sbr -> num_patches -- ; \n return 0 ; \n }", "idx": 350}
{"project": "FFmpeg", "commit_id": "34056cbba55f0131e8d2698717ab9e86e2da5178", "target": 1, "func": "void ff_rtp_send_h263 ( AVFormatContext * s1 , const uint8_t * buf1 , int size ) \n { \n RTPMuxContext * s = s1 -> priv_data ; \n int len , max_packet_size ; \n uint8_t * q ; \n max_packet_size = s -> max_payload_size ; \n while ( size > 0 ) { \n q = s -> buf ; \n if ( ( buf1 [ 0 ] == 0 ) && ( buf1 [ 1 ] == 0 ) ) { \n * q ++ = 0x04 ; \n buf1 += 2 ; \n size -= 2 ; \n } else { \n * q ++ = 0 ; \n } \n * q ++ = 0 ; \n len = FFMIN ( max_packet_size - 2 , size ) ; \n if ( len < size ) { \n const uint8_t * end = find_resync_marker_reverse ( buf1 , buf1 + len ) ; \n len = end - buf1 ; \n } \n memcpy ( q , buf1 , len ) ; \n q += len ; \n s -> timestamp = s -> cur_timestamp ; \n ff_rtp_send_data ( s1 , s -> buf , q - s -> buf , ( len == size ) ) ; \n buf1 += len ; \n size -= len ; \n } \n }", "idx": 352}
{"project": "FFmpeg", "commit_id": "4733a12dd17a91d606e0079ff9bb48b9f419cbef", "target": 0, "func": "int ff_wms_parse_sdp_a_line ( AVFormatContext * s , const char * p ) \n { \n int ret = 0 ; \n if ( av_strstart ( p , \" \" , & p ) ) { \n AVIOContext pb ; \n RTSPState * rt = s -> priv_data ; \n AVDictionary * opts = NULL ; \n int len = strlen ( p ) * 6 / 8 ; \n char * buf = av_mallocz ( len ) ; \n av_base64_decode ( buf , p , len ) ; \n if ( rtp_asf_fix_header ( buf , len ) < 0 ) \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n init_packetizer ( & pb , buf , len ) ; \n if ( rt -> asf_ctx ) { \n avformat_close_input ( & rt -> asf_ctx ) ; \n } \n if ( ! ( rt -> asf_ctx = avformat_alloc_context ( ) ) ) \n return AVERROR ( ENOMEM ) ; \n rt -> asf_ctx -> pb = & pb ; \n av_dict_set ( & opts , \" \" , \" \" , 0 ) ; \n ret = avformat_open_input ( & rt -> asf_ctx , \" \" , & ff_asf_demuxer , & opts ) ; \n av_dict_free ( & opts ) ; \n if ( ret < 0 ) \n return ret ; \n av_dict_copy ( & s -> metadata , rt -> asf_ctx -> metadata , 0 ) ; \n rt -> asf_pb_pos = avio_tell ( & pb ) ; \n av_free ( buf ) ; \n rt -> asf_ctx -> pb = NULL ; \n } \n return ret ; \n }", "idx": 366}
{"project": "FFmpeg", "commit_id": "f73d6d2af7a2b30a647d945b590962a2ab54ff3b", "target": 0, "func": "static void alloc_picture ( VideoState * is ) \n { \n VideoPicture * vp ; \n int64_t bufferdiff ; \n vp = & is -> pictq [ is -> pictq_windex ] ; \n if ( vp -> bmp ) \n SDL_FreeYUVOverlay ( vp -> bmp ) ; \n video_open ( is , 0 , vp ) ; \n vp -> bmp = SDL_CreateYUVOverlay ( vp -> width , vp -> height , \n SDL_YV12_OVERLAY , \n screen ) ; \n bufferdiff = vp -> bmp ? FFMAX ( vp -> bmp -> pixels [ 0 ] , vp -> bmp -> pixels [ 1 ] ) - FFMIN ( vp -> bmp -> pixels [ 0 ] , vp -> bmp -> pixels [ 1 ] ) : 0 ; \n if ( ! vp -> bmp || vp -> bmp -> pitches [ 0 ] < vp -> width || bufferdiff < vp -> height * vp -> bmp -> pitches [ 0 ] ) { \n av_log ( NULL , AV_LOG_FATAL , \n \" \\n \" \n \" \\\" \\\" \\n \" \n \" \\n \" , vp -> width , vp -> height ) ; \n do_exit ( is ) ; \n } \n SDL_LockMutex ( is -> pictq_mutex ) ; \n vp -> allocated = 1 ; \n SDL_CondSignal ( is -> pictq_cond ) ; \n SDL_UnlockMutex ( is -> pictq_mutex ) ; \n }", "idx": 367}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "static AVFilterBufferRef * copy_buffer_ref ( AVFilterContext * ctx , \n AVFilterBufferRef * ref ) \n { \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFilterBufferRef * buf ; \n int channels , data_size , i ; \n switch ( outlink -> type ) { \n case AVMEDIA_TYPE_VIDEO : \n buf = avfilter_get_video_buffer ( outlink , AV_PERM_WRITE , \n ref -> video -> w , ref -> video -> h ) ; \n av_image_copy ( buf -> data , buf -> linesize , \n ( void * ) ref -> data , ref -> linesize , \n ref -> format , ref -> video -> w , ref -> video -> h ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n buf = ff_get_audio_buffer ( outlink , AV_PERM_WRITE , \n ref -> audio -> nb_samples ) ; \n channels = av_get_channel_layout_nb_channels ( ref -> audio -> channel_layout ) ; \n av_samples_copy ( buf -> extended_data , ref -> buf -> extended_data , \n 0 , 0 , ref -> audio -> nb_samples , \n channels , \n ref -> format ) ; \n break ; \n default : \n } \n avfilter_copy_buffer_ref_props ( buf , ref ) ; \n return buf ; \n }", "idx": 384}
{"project": "FFmpeg", "commit_id": "843e72ea5542845a0a9fed743517c14a92279885", "target": 0, "func": "static int mkv_check_tag ( AVDictionary * m ) \n { \n AVDictionaryEntry * t = NULL ; \n while ( ( t = av_dict_get ( m , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) \n if ( av_strcasecmp ( t -> key , \" \" ) && av_strcasecmp ( t -> key , \" \" ) ) \n return 1 ; \n return 0 ; \n }", "idx": 386}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "av_cold int ff_ivi_decode_close ( AVCodecContext * avctx ) \n { \n IVI45DecContext * ctx = avctx -> priv_data ; \n ivi_free_buffers ( & ctx -> planes [ 0 ] ) ; \n if ( ctx -> mb_vlc . cust_tab . table ) \n ff_free_vlc ( & ctx -> mb_vlc . cust_tab ) ; \n #if IVI4_STREAM_ANALYSER  \n  \n  if ( ctx -> is_indeo4 ) { \n if ( ctx -> is_scalable ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> uses_tiling ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> has_b_frames ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> has_transp ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> uses_haar ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ctx -> uses_fullpel ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n #endif \n av_frame_free ( & ctx -> p_frame ) ; \n return 0 ; \n }", "idx": 421}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int cinepak_decode_init ( AVCodecContext * avctx ) \n { \n CinepakContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = ( avctx -> width + 3 ) & ~ 3 ; \n s -> height = ( avctx -> height + 3 ) & ~ 3 ; \n s -> sega_film_skip_bytes = -1 ; \n if ( avctx -> bits_per_coded_sample != 8 ) { \n s -> palette_video = 0 ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n } else { \n s -> palette_video = 1 ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 422}
{"project": "FFmpeg", "commit_id": "a4d18a3f54e5b0277234d8fcff65dff8516417a0", "target": 1, "func": "static int process_frame ( FFFrameSync * fs ) \n { \n AVFilterContext * ctx = fs -> parent ; \n LUT2Context * s = fs -> opaque ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFrame * out , * srcx , * srcy ; \n int ret ; \n if ( ( ret = ff_framesync2_get_frame ( & s -> fs , 0 , & srcx , 0 ) ) < 0 || \n ( ret = ff_framesync2_get_frame ( & s -> fs , 1 , & srcy , 0 ) ) < 0 ) \n return ret ; \n if ( ctx -> is_disabled ) { \n out = av_frame_clone ( srcx ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n } else { \n out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( out , srcx ) ; \n s -> lut2 ( s , out , srcx , srcy ) ; \n } \n out -> pts = av_rescale_q ( s -> fs . pts , s -> fs . time_base , outlink -> time_base ) ; \n return ff_filter_frame ( outlink , out ) ; \n }", "idx": 435}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int decode_exponents ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int i ; \n uint8_t * exps ; \n uint8_t * dexps ; \n if ( ab -> flags & AC3_AB_CPLINU && ab -> cplexpstr != AC3_EXPSTR_REUSE ) \n if ( _decode_exponents ( ab -> cplexpstr , ab -> ncplgrps , ab -> cplabsexp , \n ab -> cplexps , ab -> dcplexps + ab -> cplstrtmant ) ) \n return -1 ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n if ( ab -> chexpstr [ i ] != AC3_EXPSTR_REUSE ) { \n exps = ab -> exps [ i ] ; \n dexps = ab -> dexps [ i ] ; \n if ( _decode_exponents ( ab -> chexpstr [ i ] , ab -> nchgrps [ i ] , exps [ 0 ] , exps + 1 , dexps + 1 ) ) \n return -1 ; \n } \n if ( ctx -> bsi . flags & AC3_BSI_LFEON && ab -> lfeexpstr != AC3_EXPSTR_REUSE ) \n if ( _decode_exponents ( ab -> lfeexpstr , 2 , ab -> lfeexps [ 0 ] , ab -> lfeexps + 1 , ab -> dlfeexps ) ) \n return -1 ; \n return 0 ; \n }", "idx": 440}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static int udp_close ( URLContext * h ) \n { \n UDPContext * s = h -> priv_data ; \n if ( s -> is_multicast && ( h -> flags & AVIO_FLAG_READ ) ) \n udp_leave_multicast_group ( s -> udp_fd , ( struct sockaddr * ) & s -> dest_addr , ( struct sockaddr * ) & s -> local_addr_storage ) ; \n closesocket ( s -> udp_fd ) ; \n #if HAVE_PTHREAD_CANCEL  \n  \n  if ( s -> thread_started ) { \n int ret ; \n pthread_cancel ( s -> circular_buffer_thread ) ; \n ret = pthread_join ( s -> circular_buffer_thread , NULL ) ; \n if ( ret != 0 ) \n av_log ( h , AV_LOG_ERROR , \" \\n \" , strerror ( ret ) ) ; \n pthread_mutex_destroy ( & s -> mutex ) ; \n pthread_cond_destroy ( & s -> cond ) ; \n } \n #endif \n av_fifo_freep ( & s -> fifo ) ; \n return 0 ; \n }", "idx": 445}
{"project": "FFmpeg", "commit_id": "919f3554387e043bdfe10c6369356d1104882183", "target": 1, "func": "void ff_decode_dxt1 ( const uint8_t * s , uint8_t * dst , \n const unsigned int w , const unsigned int h , \n const unsigned int stride ) { \n unsigned int bx , by , qstride = stride / 4 ; \n uint32_t * d = ( uint32_t * ) dst ; \n for ( by = 0 ; by < h / 4 ; by ++ , d += stride - w ) \n for ( bx = 0 ; bx < w / 4 ; bx ++ , s += 8 , d += 4 ) \n dxt1_decode_pixels ( s , d , qstride , 0 , 0LL ) ; \n }", "idx": 448}
{"project": "FFmpeg", "commit_id": "6a4d1c9063174234ca439244cf8f5f534afa1c28", "target": 0, "func": "static const HWAccel * get_hwaccel ( enum AVPixelFormat pix_fmt ) \n { \n int i ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) \n if ( hwaccels [ i ] . pix_fmt == pix_fmt ) \n return & hwaccels [ i ] ; \n return NULL ; \n }", "idx": 450}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static enum AVHWDeviceType hw_device_match_type_in_name ( const char * codec_name ) \n { \n const char * type_name ; \n enum AVHWDeviceType type ; \n for ( type = av_hwdevice_iterate_types ( AV_HWDEVICE_TYPE_NONE ) ; \n type != AV_HWDEVICE_TYPE_NONE ; \n type = av_hwdevice_iterate_types ( type ) ) { \n type_name = av_hwdevice_get_type_name ( type ) ; \n if ( strstr ( codec_name , type_name ) ) \n return type ; \n } \n return AV_HWDEVICE_TYPE_NONE ; \n }", "idx": 455}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close ( AVCodecContext * avc_context ) \n { \n TheoraContext * h = avc_context -> priv_data ; \n th_encode_free ( h -> t_state ) ; \n av_freep ( & h -> stats ) ; \n av_freep ( & avc_context -> coded_frame ) ; \n av_freep ( & avc_context -> stats_out ) ; \n av_freep ( & avc_context -> extradata ) ; \n avc_context -> extradata_size = 0 ; \n return 0 ; \n }", "idx": 456}
{"project": "FFmpeg", "commit_id": "70205f1799252c3363a5bb5ea7ea5df090f2c88f", "target": 0, "func": "void check_values ( eq2_param_t * par ) \n { \n if ( ( par -> c == 1.0 ) && ( par -> b == 0.0 ) && ( par -> g == 1.0 ) ) { \n par -> adjust = NULL ; \n } \n #if HAVE_MMX && HAVE_6REGS  \n  \n  else if ( par -> g == 1.0 && ff_gCpuCaps . hasMMX ) { \n par -> adjust = & affine_1d_MMX ; \n } \n #endif \n else  { \n par -> adjust = & apply_lut ; \n } \n }", "idx": 487}
{"project": "FFmpeg", "commit_id": "dcfb0cad687ec89d3c7fe21a014c58f283050283", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x2 ( IpvideoContext * s ) \n { \n unsigned char B ; \n int x , y ; \n CHECK_STREAM_PTR ( s -> stream_ptr , s -> stream_end , 1 ) ; \n B = * s -> stream_ptr ++ ; \n if ( B < 56 ) { \n x = 8 + ( B % 7 ) ; \n y = B / 7 ; \n } else { \n x = -14 + ( ( B - 56 ) % 29 ) ; \n y = 8 + ( ( B - 56 ) / 29 ) ; \n } \n debug_interplay ( \" \\n \" , B , x , y ) ; \n return copy_from ( s , & s -> second_last_frame , x , y ) ; \n }", "idx": 488}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "static void copy_context_after_encode ( MpegEncContext * d , MpegEncContext * s , int type ) { \n int i ; \n memcpy ( d -> mv , s -> mv , 2 * 4 * 2 * sizeof ( int ) ) ; \n memcpy ( d -> last_mv , s -> last_mv , 2 * 2 * 2 * sizeof ( int ) ) ; \n d -> mb_incr = s -> mb_incr ; \n for ( i = 0 ; i < 3 ; i ++ ) \n d -> last_dc [ i ] = s -> last_dc [ i ] ; \n d -> mv_bits = s -> mv_bits ; \n d -> i_tex_bits = s -> i_tex_bits ; \n d -> p_tex_bits = s -> p_tex_bits ; \n d -> i_count = s -> i_count ; \n d -> p_count = s -> p_count ; \n d -> skip_count = s -> skip_count ; \n d -> misc_bits = s -> misc_bits ; \n d -> mb_intra = s -> mb_intra ; \n d -> mb_skiped = s -> mb_skiped ; \n d -> mv_type = s -> mv_type ; \n d -> mv_dir = s -> mv_dir ; \n d -> pb = s -> pb ; \n d -> block = s -> block ; \n for ( i = 0 ; i < 6 ; i ++ ) \n d -> block_last_index [ i ] = s -> block_last_index [ i ] ; \n }", "idx": 503}
{"project": "FFmpeg", "commit_id": "fccd85b9f30525f88692f53134eba41f1f2d90db", "target": 1, "func": "static int ac3_sync ( uint64_t state , AACAC3ParseContext * hdr_info , \n int * need_next_header , int * new_frame_start ) \n { \n int err ; \n union { \n uint64_t u64 ; \n uint8_t u8 [ 8 ] ; \n } tmp = { av_be2ne64 ( state ) } ; \n AC3HeaderInfo hdr , * phdr = & hdr ; \n GetBitContext gbc ; \n init_get_bits ( & gbc , tmp . u8 + 8 - AC3_HEADER_SIZE , 54 ) ; \n err = avpriv_ac3_parse_header2 ( & gbc , & phdr ) ; \n if ( err < 0 ) \n return 0 ; \n hdr_info -> sample_rate = hdr . sample_rate ; \n hdr_info -> bit_rate = hdr . bit_rate ; \n hdr_info -> channels = hdr . channels ; \n hdr_info -> channel_layout = hdr . channel_layout ; \n hdr_info -> samples = hdr . num_blocks * 256 ; \n hdr_info -> service_type = hdr . bitstream_mode ; \n if ( hdr . bitstream_mode == 0x7 && hdr . channels > 1 ) \n hdr_info -> service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE ; \n if ( hdr . bitstream_id > 10 ) \n hdr_info -> codec_id = AV_CODEC_ID_EAC3 ; \n else if ( hdr_info -> codec_id == AV_CODEC_ID_NONE ) \n hdr_info -> codec_id = AV_CODEC_ID_AC3 ; \n * need_next_header = ( hdr . frame_type != EAC3_FRAME_TYPE_AC3_CONVERT ) ; \n * new_frame_start = ( hdr . frame_type != EAC3_FRAME_TYPE_DEPENDENT ) ; \n return hdr . frame_size ; \n }", "idx": 519}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static uint32_t add_weights ( uint32_t w1 , uint32_t w2 ) \n { \n uint32_t max = ( w1 & 0xFF ) > ( w2 & 0xFF ) ? ( w1 & 0xFF ) : ( w2 & 0xFF ) ; \n return ( ( w1 & 0xFFFFFF00 ) + ( w2 & 0xFFFFFF00 ) ) | ( 1 + max ) ; \n }", "idx": 528}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "int hw_device_setup_for_encode ( OutputStream * ost ) \n { \n enum AVHWDeviceType type ; \n HWDevice * dev ; \n type = hw_device_match_type_in_name ( ost -> enc -> name ) ; \n if ( type != AV_HWDEVICE_TYPE_NONE ) { \n dev = hw_device_get_by_type ( type ) ; \n if ( ! dev ) { \n av_log ( ost -> enc_ctx , AV_LOG_WARNING , \" \" \n \" \\n \" , \n av_hwdevice_get_type_name ( type ) , ost -> enc -> name ) ; \n return 0 ; \n } \n ost -> enc_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; \n if ( ! ost -> enc_ctx -> hw_device_ctx ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n } else { \n return 0 ; \n } \n }", "idx": 533}
{"project": "FFmpeg", "commit_id": "158f0545d81b2aca1c936490f80d13988616910e", "target": 1, "func": "ASSStyle * ff_ass_style_get ( ASSSplitContext * ctx , const char * style ) \n { \n ASS * ass = & ctx -> ass ; \n int i ; \n if ( ! style || ! * style ) \n style = \" \" ; \n for ( i = 0 ; i < ass -> styles_count ; i ++ ) \n if ( ! strcmp ( ass -> styles [ i ] . name , style ) ) \n return ass -> styles + i ; \n return NULL ; \n }", "idx": 537}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( c -> flags & SWS_ACCURATE_RND ) { \n if ( uDest ) { \n YSCALEYUV2YV12X_ACCURATE ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X_ACCURATE ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X_ACCURATE ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } else { \n if ( uDest ) { \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 540}
{"project": "FFmpeg", "commit_id": "0e0f8859ba0af33e1145a4c4022e964011e2d75b", "target": 0, "func": "static int hdcd_envelope ( int32_t * samples , int count , int stride , int gain , int target_gain , int extend ) \n { \n int i ; \n int32_t * samples_end = samples + stride * count ; \n if ( extend ) { \n for ( i = 0 ; i < count ; i ++ ) { \n int32_t sample = samples [ i * stride ] ; \n int32_t asample = abs ( sample ) - 0x5981 ; \n if ( asample >= 0 ) \n sample = sample >= 0 ? peaktab [ asample ] : - peaktab [ asample ] ; \n else \n sample <<= 15 ; \n samples [ i * stride ] = sample ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) \n samples [ i * stride ] <<= 15 ; \n } \n if ( gain <= target_gain ) { \n int len = FFMIN ( count , target_gain - gain ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n ++ gain ; \n APPLY_GAIN ( * samples , gain ) ; \n samples += stride ; \n } \n count -= len ; \n } else { \n int len = FFMIN ( count , ( gain - target_gain ) >> 3 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n gain -= 8 ; \n APPLY_GAIN ( * samples , gain ) ; \n samples += stride ; \n } \n if ( gain - 8 < target_gain ) \n gain = target_gain ; \n count -= len ; \n } \n if ( gain == 0 ) { \n if ( count > 0 ) \n samples += count * stride ; \n } else { \n while ( -- count >= 0 ) { \n APPLY_GAIN ( * samples , gain ) ; \n samples += stride ; \n } \n } \n av_assert0 ( samples == samples_end ) ; \n return gain ; \n }", "idx": 544}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_recovery_point ( H264Context * h ) \n { \n h -> sei_recovery_frame_cnt = get_ue_golomb ( & h -> gb ) ; \n skip_bits ( & h -> gb , 4 ) ; \n if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) \n av_log ( h -> avctx , AV_LOG_DEBUG , \" \\n \" , h -> sei_recovery_frame_cnt ) ; \n h -> has_recovery_point = 1 ; \n return 0 ; \n }", "idx": 567}
{"project": "FFmpeg", "commit_id": "b6671787db5b5d53e065f88e52a35d94cb50504c", "target": 1, "func": "static int flashsv2_prime ( FlashSVContext * s , uint8_t * src , int size ) \n { \n z_stream zs ; \n int zret ; \n zs . zalloc = NULL ; \n zs . zfree = NULL ; \n zs . opaque = NULL ; \n s -> zstream . next_in = src ; \n s -> zstream . avail_in = size ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n if ( deflateInit ( & zs , 0 ) != Z_OK ) \n return -1 ; \n zs . next_in = s -> tmpblock ; \n zs . avail_in = s -> block_size * 3 - s -> zstream . avail_out ; \n zs . next_out = s -> deflate_block ; \n zs . avail_out = s -> deflate_block_size ; \n deflate ( & zs , Z_SYNC_FLUSH ) ; \n deflateEnd ( & zs ) ; \n if ( ( zret = inflateReset ( & s -> zstream ) ) != Z_OK ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , zret ) ; \n return AVERROR_UNKNOWN ; \n } \n s -> zstream . next_in = s -> deflate_block ; \n s -> zstream . avail_in = s -> deflate_block_size - zs . avail_out ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n return 0 ; \n }", "idx": 580}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int vid_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 || AV_RL32 ( p -> buf ) != MKTAG ( ' ' , ' ' , ' ' , 0 ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 582}
{"project": "FFmpeg", "commit_id": "5fbd97fc756a827f62f556c66272f851cc3c7f90", "target": 1, "func": "static void decode_subband ( DiracContext * s , GetBitContext * gb , int quant , \n int slice_x , int slice_y , int bits_end , \n SubBand * b1 , SubBand * b2 ) \n { \n int left = b1 -> width * slice_x / s -> num_x ; \n int right = b1 -> width * ( slice_x + 1 ) / s -> num_x ; \n int top = b1 -> height * slice_y / s -> num_y ; \n int bottom = b1 -> height * ( slice_y + 1 ) / s -> num_y ; \n int qfactor = qscale_tab [ quant & 0x7f ] ; \n int qoffset = qoffset_intra_tab [ quant & 0x7f ] + 2 ; \n uint8_t * buf1 = b1 -> ibuf + top * b1 -> stride ; \n uint8_t * buf2 = b2 ? b2 -> ibuf + top * b2 -> stride : NULL ; \n int x , y ; \n if ( get_bits_count ( gb ) >= bits_end ) \n return ; \n if ( s -> pshift ) { \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n PARSE_VALUES ( int32_t , x , gb , bits_end , buf1 , buf2 ) ; \n } \n buf1 += b1 -> stride ; \n if ( buf2 ) \n buf2 += b2 -> stride ; \n } \n } \n else { \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n PARSE_VALUES ( int16_t , x , gb , bits_end , buf1 , buf2 ) ; \n } \n buf1 += b1 -> stride ; \n if ( buf2 ) \n buf2 += b2 -> stride ; \n } \n } \n }", "idx": 592}
{"project": "FFmpeg", "commit_id": "fe7a37c36febd71576cbefc385d995a8d6e444e7", "target": 0, "func": "int ff_ivi_dec_huff_desc ( GetBitContext * gb , int desc_coded , int which_tab , \n IVIHuffTab * huff_tab , AVCodecContext * avctx ) \n { \n int i , result ; \n IVIHuffDesc new_huff ; \n if ( ! desc_coded ) { \n huff_tab -> tab = ( which_tab ) ? & ff_ivi_blk_vlc_tabs [ 7 ] \n : & ff_ivi_mb_vlc_tabs [ 7 ] ; \n } else { \n huff_tab -> tab_sel = get_bits ( gb , 3 ) ; \n if ( huff_tab -> tab_sel == 7 ) { \n new_huff . num_rows = get_bits ( gb , 4 ) ; \n for ( i = 0 ; i < new_huff . num_rows ; i ++ ) \n new_huff . xbits [ i ] = get_bits ( gb , 4 ) ; \n if ( ff_ivi_huff_desc_cmp ( & new_huff , & huff_tab -> cust_desc ) ) { \n ff_ivi_huff_desc_copy ( & huff_tab -> cust_desc , & new_huff ) ; \n if ( huff_tab -> cust_tab . table ) \n ff_free_vlc ( & huff_tab -> cust_tab ) ; \n result = ff_ivi_create_huff_from_desc ( & huff_tab -> cust_desc , \n & huff_tab -> cust_tab , 0 ) ; \n if ( result ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n } \n huff_tab -> tab = & huff_tab -> cust_tab ; \n } else { \n huff_tab -> tab = ( which_tab ) ? & ff_ivi_blk_vlc_tabs [ huff_tab -> tab_sel ] \n : & ff_ivi_mb_vlc_tabs [ huff_tab -> tab_sel ] ; \n } \n } \n return 0 ; \n }", "idx": 603}
{"project": "FFmpeg", "commit_id": "5675a11f9277b5c7b1c9ad45da893e9ef9a42f03", "target": 0, "func": "static int decode_block_refinement ( MJpegDecodeContext * s , DCTELEM * block , uint8_t * last_nnz , \n int ac_index , int16_t * quant_matrix , \n int ss , int se , int Al , int * EOBRUN ) \n { \n int code , i = ss , j , sign , val , run ; \n int last = FFMIN ( se , * last_nnz ) ; \n OPEN_READER ( re , & s -> gb ) ; \n if ( * EOBRUN ) \n ( * EOBRUN ) -- ; \n else { \n for ( ; ; i ++ ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 )  \n code -= 16 ; \n if ( code & 0xF ) { \n run = ( ( unsigned ) code ) >> 4 ; \n UPDATE_CACHE ( re , & s -> gb ) ; \n val = SHOW_UBITS ( re , & s -> gb , 1 ) ; \n LAST_SKIP_BITS ( re , & s -> gb , 1 ) ; \n ZERO_RUN ; \n j = s -> scantable . permutated [ i ] ; \n val -- ; \n block [ j ] = ( ( quant_matrix [ j ] ^ val ) - val ) << Al ; \n if ( i == se ) { \n if ( i > * last_nnz ) \n * last_nnz = i ; \n CLOSE_READER ( re , & s -> gb )  \n return 0 ; \n } \n } else { \n run = ( ( unsigned ) code ) >> 4 ; \n if ( run == 0xF ) { \n ZERO_RUN ; \n } else { \n val = run ; \n run = ( 1 << run ) ; \n if ( val ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n run += SHOW_UBITS ( re , & s -> gb , val ) ; \n LAST_SKIP_BITS ( re , & s -> gb , val ) ; \n } \n * EOBRUN = run - 1 ; \n break ; \n } \n } \n } \n if ( i > * last_nnz ) \n * last_nnz = i ; \n } \n for ( ; i <= last ; i ++ ) { \n j = s -> scantable . permutated [ i ] ; \n if ( block [ j ] ) \n REFINE_BIT ( j )  \n } \n CLOSE_READER ( re , & s -> gb ) ; \n return 0 ; \n }", "idx": 614}
{"project": "FFmpeg", "commit_id": "39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4", "target": 1, "func": "static void destroy_buffers ( SANMVideoContext * ctx ) \n { \n av_freep ( & ctx -> frm0 ) ; \n av_freep ( & ctx -> frm1 ) ; \n av_freep ( & ctx -> frm2 ) ; \n av_freep ( & ctx -> stored_frame ) ; \n av_freep ( & ctx -> rle_buf ) ; \n ctx -> frm0_size = \n ctx -> frm1_size = \n ctx -> frm2_size = 0 ; \n }", "idx": 615}
{"project": "FFmpeg", "commit_id": "51f64552853e16d72644308db53abee870aecfb9", "target": 1, "func": "int av_image_alloc ( uint8_t * pointers [ 4 ] , int linesizes [ 4 ] , \n int w , int h , enum AVPixelFormat pix_fmt , int align ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n int i , ret ; \n uint8_t * buf ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( w , h , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = av_image_fill_linesizes ( linesizes , pix_fmt , align > 7 ? FFALIGN ( w , 8 ) : w ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 ; i ++ ) \n linesizes [ i ] = FFALIGN ( linesizes [ i ] , align ) ; \n if ( ( ret = av_image_fill_pointers ( pointers , pix_fmt , h , NULL , linesizes ) ) < 0 ) \n return ret ; \n buf = av_malloc ( ret + align ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ( ret = av_image_fill_pointers ( pointers , pix_fmt , h , buf , linesizes ) ) < 0 ) { \n av_free ( buf ) ; \n return ret ; \n if ( desc -> flags & AV_PIX_FMT_FLAG_PAL || desc -> flags & AV_PIX_FMT_FLAG_PSEUDOPAL ) \n avpriv_set_systematic_pal2 ( ( uint32_t * ) pointers [ 1 ] , pix_fmt ) ; \n return ret ;", "idx": 618}
{"project": "FFmpeg", "commit_id": "90f03441654f85a1402a65c3dcaa3f634a24c27e", "target": 0, "func": "static uint32_t calc_optimal_rice_params ( RiceContext * rc , int porder , \n uint32_t * sums , int n , int pred_order ) \n { \n int i ; \n int k , cnt , part ; \n uint32_t all_bits ; \n part = ( 1 << porder ) ; \n all_bits = 0 ; \n cnt = ( n >> porder ) - pred_order ; \n for ( i = 0 ; i < part ; i ++ ) { \n if ( i == 1 ) cnt = ( n >> porder ) ; \n k = find_optimal_param ( sums [ i ] , cnt ) ; \n rc -> params [ i ] = k ; \n all_bits += rice_encode_count ( sums [ i ] , cnt , k ) ; \n } \n all_bits += ( 4 * part ) ; \n rc -> porder = porder ; \n return all_bits ; \n }", "idx": 626}
{"project": "FFmpeg", "commit_id": "da8242e2d6f85d95239082efd0e5e2345e685a2c", "target": 0, "func": "static void raw_decode ( uint8_t * dst , const int8_t * src , int src_size ) \n { \n while ( src_size -- ) \n * dst ++ = * src ++ + 128 ; \n }", "idx": 627}
{"project": "FFmpeg", "commit_id": "76b6f4b7d91901929177cc61d9810dcca0bb40c1", "target": 0, "func": "static int dxtory_decode_v1_410 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * Y3 , * Y4 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 9LL / 8 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n Y3 = pic -> data [ 0 ] + pic -> linesize [ 0 ] * 2 ; \n Y4 = pic -> data [ 0 ] + pic -> linesize [ 0 ] * 3 ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 4 ) { \n for ( w = 0 ; w < avctx -> width ; w += 4 ) { \n AV_COPY32U ( Y1 + w , src ) ; \n AV_COPY32U ( Y2 + w , src + 4 ) ; \n AV_COPY32U ( Y3 + w , src + 8 ) ; \n AV_COPY32U ( Y4 + w , src + 12 ) ; \n U [ w >> 2 ] = src [ 16 ] + 0x80 ; \n V [ w >> 2 ] = src [ 17 ] + 0x80 ; \n src += 18 ; \n } \n Y1 += pic -> linesize [ 0 ] << 2 ; \n Y2 += pic -> linesize [ 0 ] << 2 ; \n Y3 += pic -> linesize [ 0 ] << 2 ; \n Y4 += pic -> linesize [ 0 ] << 2 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 628}
{"project": "FFmpeg", "commit_id": "171c407621b7ff52a0cf128b31651ca927c2dd49", "target": 1, "func": "static inline void direct_ref_list_init ( H264Context * const h ) { \n MpegEncContext * const s = & h -> s ; \n Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ; \n Picture * const cur = s -> current_picture_ptr ; \n int list , i , j ; \n if ( cur -> pict_type == I_TYPE ) \n cur -> ref_count [ 0 ] = 0 ; \n if ( cur -> pict_type != B_TYPE ) \n cur -> ref_count [ 1 ] = 0 ; \n for ( list = 0 ; list < 2 ; list ++ ) { \n cur -> ref_count [ list ] = h -> ref_count [ list ] ; \n for ( j = 0 ; j < h -> ref_count [ list ] ; j ++ ) \n cur -> ref_poc [ list ] [ j ] = h -> ref_list [ list ] [ j ] . poc ; \n } \n if ( cur -> pict_type != B_TYPE || h -> direct_spatial_mv_pred ) \n return ; \n for ( list = 0 ; list < 2 ; list ++ ) { \n for ( i = 0 ; i < ref1 -> ref_count [ list ] ; i ++ ) { \n const int poc = ref1 -> ref_poc [ list ] [ i ] ; \n h -> map_col_to_list0 [ list ] [ i ] = PART_NOT_AVAILABLE ; \n for ( j = 0 ; j < h -> ref_count [ list ] ; j ++ ) \n if ( h -> ref_list [ list ] [ j ] . poc == poc ) { \n h -> map_col_to_list0 [ list ] [ i ] = j ; \n break ; \n } \n } \n } \n }", "idx": 632}
{"project": "FFmpeg", "commit_id": "2217a2249dd78c3719f865569b661b8adcda4962", "target": 1, "func": "static void encode_rgb48_10bit ( AVCodecContext * avctx , const AVPicture * pic , uint8_t * dst ) \n { \n DPXContext * s = avctx -> priv_data ; \n const uint8_t * src = pic -> data [ 0 ] ; \n int x , y ; \n for ( y = 0 ; y < avctx -> height ; y ++ ) { \n for ( x = 0 ; x < avctx -> width ; x ++ ) { \n int value ; \n if ( s -> big_endian ) { \n value = ( ( AV_RB16 ( src + 6 * x + 4 ) & 0xFFC0 ) >> 4 ) \n | ( ( AV_RB16 ( src + 6 * x + 2 ) & 0xFFC0 ) << 6 ) \n | ( ( AV_RB16 ( src + 6 * x + 0 ) & 0xFFC0 ) << 16 ) ; \n } else { \n value = ( ( AV_RL16 ( src + 6 * x + 4 ) & 0xFFC0 ) >> 4 ) \n | ( ( AV_RL16 ( src + 6 * x + 2 ) & 0xFFC0 ) << 6 ) \n | ( ( AV_RL16 ( src + 6 * x + 0 ) & 0xFFC0 ) << 16 ) ; \n } \n write32 ( dst , value ) ; \n dst += 4 ; \n } \n src += pic -> linesize [ 0 ] ; \n } \n }", "idx": 633}
{"project": "FFmpeg", "commit_id": "a9f9b7f5c70e80245983e67b8ed23212d9637645", "target": 1, "func": "static int mov_text_decode_close ( AVCodecContext * avctx ) \n { \n MovTextContext * m = avctx -> priv_data ; \n mov_text_cleanup_ftab ( m ) ; \n return 0 ; \n }", "idx": 639}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static void flush ( AVCodecContext * avctx ) \n { \n WmallDecodeCtx * s = avctx -> priv_data ; \n s -> packet_loss = 1 ; \n s -> packet_done = 0 ; \n s -> num_saved_bits = 0 ; \n s -> frame_offset = 0 ; \n s -> next_packet_start = 0 ; \n s -> cdlms [ 0 ] [ 0 ] . order = 0 ; \n s -> frame . nb_samples = 0 ; \n init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ; \n }", "idx": 643}
{"project": "FFmpeg", "commit_id": "dc9f52602f6493b33d1ac0d729ffb188e6a676fa", "target": 1, "func": "static int decode_end ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n MpegEncContext * s = & h -> s ; \n free_tables ( h ) ; \n MPV_common_end ( s ) ; \n return 0 ; \n }", "idx": 650}
{"project": "FFmpeg", "commit_id": "99ca4f73f0a2085d8b3c7636f4734825894c42dc", "target": 0, "func": "static av_cold int validate_options ( AVCodecContext * avctx , AC3EncodeContext * s ) \n { \n int i , j ; \n if ( ! avctx -> channel_layout ) { \n av_log ( avctx , AV_LOG_WARNING , \" \" \n \" \" \n \" \\n \" ) ; \n } \n if ( set_channel_info ( s , avctx -> channels , & avctx -> channel_layout ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ ) \n if ( ( ff_ac3_sample_rate_tab [ j ] >> i ) == avctx -> sample_rate ) \n goto found ; \n } \n return -1 ; \n found : \n s -> sample_rate = avctx -> sample_rate ; \n s -> bit_alloc . sr_shift = i ; \n s -> bit_alloc . sr_code = j ; \n s -> bitstream_id = 8 + s -> bit_alloc . sr_shift ; \n s -> bitstream_mode = 0 ; \n for ( i = 0 ; i < 19 ; i ++ ) { \n if ( ( ff_ac3_bitrate_tab [ i ] >> s -> bit_alloc . sr_shift ) * 1000 == avctx -> bit_rate ) \n break ; \n } \n if ( i == 19 ) \n return -1 ; \n s -> bit_rate = avctx -> bit_rate ; \n s -> frame_size_code = i << 1 ; \n return 0 ; \n }", "idx": 651}
{"project": "FFmpeg", "commit_id": "8de3458a07376b0a96772e586b6dba5e93432f52", "target": 0, "func": "static NvencSurface * get_free_frame ( NvencContext * ctx ) \n { \n int i ; \n for ( i = 0 ; i < ctx -> nb_surfaces ; i ++ ) { \n if ( ! ctx -> surfaces [ i ] . lockCount ) { \n ctx -> surfaces [ i ] . lockCount = 1 ; \n return & ctx -> surfaces [ i ] ; \n } \n } \n return NULL ; \n }", "idx": 652}
{"project": "FFmpeg", "commit_id": "ae100046ca32b0b83031a60d0c3cdfc5ceb9f874", "target": 0, "func": "static int exif_decode_tag ( void * logctx , GetByteContext * gbytes , int le , \n int depth , AVDictionary * * metadata ) \n { \n int ret , cur_pos ; \n unsigned id , count ; \n enum TiffTypes type ; \n if ( depth > 2 ) { \n return 0 ; \n } \n ff_tread_tag ( gbytes , le , & id , & type , & count , & cur_pos ) ; \n if ( ! bytestream2_tell ( gbytes ) ) { \n bytestream2_seek ( gbytes , cur_pos , SEEK_SET ) ; \n return 0 ; \n } \n ret = ff_tis_ifd ( id ) ; \n if ( ret ) { \n ret = avpriv_exif_decode_ifd ( logctx , gbytes , le , depth + 1 , metadata ) ; \n } else { \n const char * name = exif_get_tag_name ( id ) ; \n char * use_name = ( char * ) name ; \n if ( ! use_name ) { \n use_name = av_malloc ( 7 ) ; \n if ( ! use_name ) { \n return AVERROR ( ENOMEM ) ; \n } \n snprintf ( use_name , 7 , \" \" , id ) ; \n } \n ret = exif_add_metadata ( logctx , count , type , use_name , NULL , \n gbytes , le , metadata ) ; \n if ( ! name ) { \n av_freep ( & use_name ) ; \n } \n } \n bytestream2_seek ( gbytes , cur_pos , SEEK_SET ) ; \n return ret ; \n }", "idx": 655}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "static const AVClass * urlcontext_child_class_next ( const AVClass * prev ) \n { \n URLProtocol * p = NULL ; \n while ( prev && ( p = ffurl_protocol_next ( p ) ) ) \n if ( p -> priv_data_class == prev ) \n break ; \n while ( p = ffurl_protocol_next ( p ) ) \n if ( p -> priv_data_class ) \n return p -> priv_data_class ; \n return NULL ; \n }", "idx": 658}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline void cvtyuvtoRGB ( SwsContext * c , \n vector signed short Y , vector signed short U , vector signed short V , \n vector signed short * R , vector signed short * G , vector signed short * B ) \n { \n vector signed  short vx , ux , uvx ; \n Y = vec_mradds ( Y , c -> CY , c -> OY ) ; \n U = vec_sub ( U , ( vector signed short ) \n vec_splat ( ( vector signed short ) AVV ( 128 ) , 0 ) ) ; \n V = vec_sub ( V , ( vector signed short ) \n vec_splat ( ( vector signed short ) AVV ( 128 ) , 0 ) ) ; \n ux = vec_sl ( U , c -> CSHIFT ) ; \n * B = vec_mradds ( ux , c -> CBU , Y ) ; \n vx = vec_sl ( V , c -> CSHIFT ) ; \n * R = vec_mradds ( vx , c -> CRV , Y ) ; \n uvx = vec_mradds ( U , c -> CGU , Y ) ; \n * G = vec_mradds ( V , c -> CGV , uvx ) ; \n }", "idx": 661}
{"project": "FFmpeg", "commit_id": "0a90b6a43e76aec8031b6c8a46bba2bf6cd25fa7", "target": 0, "func": "static int64_t mpegts_get_pcr ( AVFormatContext * s , int stream_index , \n int64_t * ppos , int64_t pos_limit ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int64_t pos , timestamp ; \n uint8_t buf [ TS_PACKET_SIZE ] ; \n int pcr_l , pcr_pid = ( ( PESContext * ) s -> streams [ stream_index ] -> priv_data ) -> pcr_pid ; \n pos = ( ( * ppos + ts -> raw_packet_size - 1 - ts -> pos47 ) / ts -> raw_packet_size ) * ts -> raw_packet_size + ts -> pos47 ; \n while ( pos < pos_limit ) { \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n if ( avio_read ( s -> pb , buf , TS_PACKET_SIZE ) != TS_PACKET_SIZE ) \n return AV_NOPTS_VALUE ; \n if ( ( pcr_pid < 0 || ( AV_RB16 ( buf + 1 ) & 0x1fff ) == pcr_pid ) && \n parse_pcr ( & timestamp , & pcr_l , buf ) == 0 ) { \n * ppos = pos ; \n return timestamp ; \n } \n pos += ts -> raw_packet_size ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 665}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static void seqvideo_decode ( SeqVideoContext * seq , const unsigned char * data , int data_size ) \n { \n GetBitContext gb ; \n int flags , i , j , x , y , op ; \n unsigned char c [ 3 ] ; \n unsigned char * dst ; \n uint32_t * palette ; \n flags = * data ++ ; \n if ( flags & 1 ) { \n palette = ( uint32_t * ) seq -> frame . data [ 1 ] ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ , data ++ ) \n c [ j ] = ( * data << 2 ) | ( * data >> 4 ) ; \n palette [ i ] = AV_RB24 ( c ) ; \n } \n seq -> frame . palette_has_changed = 1 ; \n } \n if ( flags & 2 ) { \n init_get_bits ( & gb , data , 128 * 8 ) ; data += 128 ; \n for ( y = 0 ; y < 128 ; y += 8 ) \n for ( x = 0 ; x < 256 ; x += 8 ) { \n dst = & seq -> frame . data [ 0 ] [ y * seq -> frame . linesize [ 0 ] + x ] ; \n op = get_bits ( & gb , 2 ) ; \n switch ( op ) { \n case 1 : \n data = seq_decode_op1 ( seq , data , dst ) ; \n break ; \n case 2 : \n data = seq_decode_op2 ( seq , data , dst ) ; \n break ; \n case 3 : \n data = seq_decode_op3 ( seq , data , dst ) ; \n break ; \n } \n } \n } \n }", "idx": 675}
{"project": "FFmpeg", "commit_id": "1ad542f11f4717a9dee19d46f4da5ce3f6beb449", "target": 1, "func": "static int get_video_buffer ( AVFrame * frame , int align ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n int ret , i ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( frame -> width , frame -> height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ! frame -> linesize [ 0 ] ) { \n ret = av_image_fill_linesizes ( frame -> linesize , frame -> format , \n frame -> width ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) \n frame -> linesize [ i ] = FFALIGN ( frame -> linesize [ i ] , align ) ; \n } \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) { \n int h = frame -> height ; \n if ( i == 1 || i == 2 ) \n h = - ( ( - h ) >> desc -> log2_chroma_h ) ; \n frame -> buf [ i ] = av_buffer_alloc ( frame -> linesize [ i ] * h ) ; \n if ( ! frame -> buf [ i ] ) \n goto fail ; \n frame -> data [ i ] = frame -> buf [ i ] -> data ; \n } \n if ( desc -> flags & PIX_FMT_PAL || desc -> flags & PIX_FMT_PSEUDOPAL ) { \n av_buffer_unref ( & frame -> buf [ 1 ] ) ; \n frame -> buf [ 1 ] = av_buffer_alloc ( 1024 ) ; \n if ( ! frame -> buf [ 1 ] ) \n goto fail ; \n frame -> data [ 1 ] = frame -> buf [ 1 ] -> data ; \n } \n frame -> extended_data = frame -> data ; \n return 0 ; \n fail : \n av_frame_unref ( frame ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 676}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_luma_intra_c ( uint8_t * pix , int stride , int alpha , int beta ) \n { \n h264_loop_filter_luma_intra_c ( pix , 1 , stride , alpha , beta ) ; \n }", "idx": 679}
{"project": "FFmpeg", "commit_id": "3b6516f7e7bb33b7aef9fa25adbf45f3de6c0560", "target": 0, "func": "static inline void do_imdct ( AC3DecodeContext * s , int channels ) \n { \n int ch ; \n for ( ch = 1 ; ch <= channels ; ch ++ ) { \n if ( s -> block_switch [ ch ] ) { \n int i ; \n float * x = s -> tmp_output + 128 ; \n for ( i = 0 ; i < 128 ; i ++ ) \n x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i ] ; \n ff_imdct_half ( & s -> imdct_256 , s -> tmp_output , x ) ; \n s -> dsp . vector_fmul_window ( s -> output [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , s -> add_bias , 128 ) ; \n for ( i = 0 ; i < 128 ; i ++ ) \n x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i + 1 ] ; \n ff_imdct_half ( & s -> imdct_256 , s -> delay [ ch - 1 ] , x ) ; \n } else { \n ff_imdct_half ( & s -> imdct_512 , s -> tmp_output , s -> transform_coeffs [ ch ] ) ; \n s -> dsp . vector_fmul_window ( s -> output [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , s -> add_bias , 128 ) ; \n memcpy ( s -> delay [ ch - 1 ] , s -> tmp_output + 128 , 128 * sizeof ( float ) ) ; \n } \n } \n }", "idx": 680}
{"project": "FFmpeg", "commit_id": "a6e14edde01bafbbe54f6f451efa718a48975b47", "target": 1, "func": "static int http_send_data ( HTTPContext * c ) \n { \n int len , ret ; \n while ( c -> buffer_ptr >= c -> buffer_end ) { \n ret = http_prepare_data ( c ) ; \n if ( ret < 0 ) \n return -1 ; \n else if ( ret == 0 ) { \n break ; \n } else { \n return 0 ; \n } \n } \n if ( c -> buffer_end > c -> buffer_ptr ) { \n len = write ( c -> fd , c -> buffer_ptr , c -> buffer_end - c -> buffer_ptr ) ; \n if ( len < 0 ) { \n if ( errno != EAGAIN && errno != EINTR ) { \n return -1 ; \n } \n } else { \n c -> buffer_ptr += len ; \n c -> data_count += len ; \n } \n } \n return 0 ; \n }", "idx": 685}
{"project": "FFmpeg", "commit_id": "a6c49f18abacb9bf52d4d808a2a56561a5b5445c", "target": 1, "func": "static void windowing_and_mdct_ltp ( AACContext * ac , float * out , \n float * in , IndividualChannelStream * ics ) \n { \n const float * lwindow = ics -> use_kb_window [ 0 ] ? ff_aac_kbd_long_1024 : ff_sine_1024 ; \n const float * swindow = ics -> use_kb_window [ 0 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n const float * lwindow_prev = ics -> use_kb_window [ 1 ] ? ff_aac_kbd_long_1024 : ff_sine_1024 ; \n const float * swindow_prev = ics -> use_kb_window [ 1 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n if ( ics -> window_sequence [ 0 ] != LONG_STOP_SEQUENCE ) { \n ac -> dsp . vector_fmul ( in , in , lwindow_prev , 1024 ) ; \n } else { \n memset ( in , 0 , 448 * sizeof ( float ) ) ; \n ac -> dsp . vector_fmul ( in + 448 , in + 448 , swindow_prev , 128 ) ; \n memcpy ( in + 576 , in + 576 , 448 * sizeof ( float ) ) ; \n } \n if ( ics -> window_sequence [ 0 ] != LONG_START_SEQUENCE ) { \n ac -> dsp . vector_fmul_reverse ( in + 1024 , in + 1024 , lwindow , 1024 ) ; \n } else { \n memcpy ( in + 1024 , in + 1024 , 448 * sizeof ( float ) ) ; \n ac -> dsp . vector_fmul_reverse ( in + 1024 + 448 , in + 1024 + 448 , swindow , 128 ) ; \n memset ( in + 1024 + 576 , 0 , 448 * sizeof ( float ) ) ; \n } \n ac -> mdct_ltp . mdct_calc ( & ac -> mdct_ltp , out , in ) ; \n }", "idx": 689}
{"project": "FFmpeg", "commit_id": "0f13cc732b3752828890b8dff507615cfd454336", "target": 1, "func": "static void decode_component ( DiracContext * s , int comp ) \n { \n AVCodecContext * avctx = s -> avctx ; \n SubBand * bands [ 3 * MAX_DWT_LEVELS + 1 ] ; \n enum dirac_subband orientation ; \n int level , num_bands = 0 ; \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { \n SubBand * b = & s -> plane [ comp ] . band [ level ] [ orientation ] ; \n bands [ num_bands ++ ] = b ; \n align_get_bits ( & s -> gb ) ; \n b -> length = svq3_get_ue_golomb ( & s -> gb ) ; \n if ( b -> length ) { \n b -> quant = svq3_get_ue_golomb ( & s -> gb ) ; \n align_get_bits ( & s -> gb ) ; \n b -> coeff_data = s -> gb . buffer + get_bits_count ( & s -> gb ) / 8 ; \n b -> length = FFMIN ( b -> length , get_bits_left ( & s -> gb ) / 8 ) ; \n skip_bits_long ( & s -> gb , b -> length * 8 ) ; \n } \n } \n if ( s -> is_arith ) \n avctx -> execute ( avctx , decode_subband_arith , & s -> plane [ comp ] . band [ level ] [ ! ! level ] , \n NULL , 4 - ! ! level , sizeof ( SubBand ) ) ; \n } \n if ( ! s -> is_arith ) \n avctx -> execute ( avctx , decode_subband_golomb , bands , NULL , num_bands , sizeof ( SubBand * ) ) ; \n }", "idx": 697}
{"project": "FFmpeg", "commit_id": "ef0c6d9b01de773e5a1177de5fcbb981aac44d65", "target": 1, "func": "static void free_device_list ( AVOpenCLDeviceList * device_list ) \n { \n int i , j ; \n if ( ! device_list ) \n return ; \n for ( i = 0 ; i < device_list -> platform_num ; i ++ ) { \n if ( ! device_list -> platform_node [ i ] ) \n continue ; \n for ( j = 0 ; j < device_list -> platform_node [ i ] -> device_num ; j ++ ) { \n av_freep ( & ( device_list -> platform_node [ i ] -> device_node [ j ] -> device_name ) ) ; \n av_freep ( & ( device_list -> platform_node [ i ] -> device_node [ j ] ) ) ; \n } \n av_freep ( & device_list -> platform_node [ i ] -> device_node ) ; \n av_freep ( & ( device_list -> platform_node [ i ] -> platform_name ) ) ; \n av_freep ( & device_list -> platform_node [ i ] ) ; \n } \n av_freep ( & device_list -> platform_node ) ; \n device_list -> platform_num = 0 ; \n }", "idx": 700}
{"project": "FFmpeg", "commit_id": "947cbeca16c7a30322e02feea440e1e67801ab9a", "target": 1, "func": "static void choose_sample_rate ( AVStream * st , AVCodec * codec ) \n { \n if ( codec && codec -> supported_samplerates ) { \n const int * p = codec -> supported_samplerates ; \n int best ; \n int best_dist = INT_MAX ; \n for ( ; * p ; p ++ ) { \n int dist = abs ( st -> codec -> sample_rate - * p ) ; \n if ( dist < best_dist ) { \n best_dist = dist ; \n best = * p ; \n } \n } \n if ( best_dist ) { \n av_log ( st -> codec , AV_LOG_WARNING , \" \\n \" , best ) ; \n } \n st -> codec -> sample_rate = best ; \n } \n }", "idx": 703}
{"project": "FFmpeg", "commit_id": "4ced5d7780fea2ea49444d6686d26f26b3a2160f", "target": 1, "func": "void ff_hevc_set_qPy ( HEVCContext * s , int xC , int yC , \n int xBase , int yBase , int log2_cb_size ) \n { \n int qp_y = get_qPy_pred ( s , xC , yC , xBase , yBase , log2_cb_size ) ; \n if ( s -> HEVClc -> tu . cu_qp_delta != 0 ) { \n int off = s -> sps -> qp_bd_offset ; \n s -> HEVClc -> qp_y = ( ( qp_y + s -> HEVClc -> tu . cu_qp_delta + 52 + 2 * off ) % \n ( 52 + off ) ) - off ; \n } else \n s -> HEVClc -> qp_y = qp_y ; \n }", "idx": 717}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_string_metadata ( int count , const char * name , \n TiffContext * s ) \n { \n char * value ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count || count < 0 ) \n return AVERROR_INVALIDDATA ; \n value = av_malloc ( count + 1 ) ; \n if ( ! value ) \n return AVERROR ( ENOMEM ) ; \n bytestream2_get_bufferu ( & s -> gb , value , count ) ; \n value [ count ] = 0 ; \n av_dict_set ( avpriv_frame_get_metadatap ( & s -> picture ) , name , value , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 730}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_l0t_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 , src1 , src2 = 0 ; \n uint32_t out0 , out1 , out2 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( src_top , src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n src0 = __msa_copy_u_w ( ( v4i32 ) sum , 0 ) ; \n src1 = __msa_copy_u_w ( ( v4i32 ) sum , 1 ) ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src2 += src [ lp_cnt * stride - 1 ] ; \n } \n src2 = ( src0 + src2 + 4 ) >> 3 ; \n src0 = ( src0 + 2 ) >> 2 ; \n src1 = ( src1 + 2 ) >> 2 ; \n out0 = src0 * 0x01010101 ; \n out1 = src1 * 0x01010101 ; \n out2 = src2 * 0x01010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SW ( out2 , src ) ; \n SW ( out1 , src + 4 ) ; \n SW ( out0 , src + stride * 4 ) ; \n SW ( out1 , src + stride * 4 + 4 ) ; \n src += stride ; \n } \n }", "idx": 733}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "SYNTH_FILTER_FUNC ( sse2 ) \n SYNTH_FILTER_FUNC ( avx )  \n SYNTH_FILTER_FUNC ( fma3 ) \n #endif \n av_cold  void ff_synth_filter_init_x86 ( SynthFilterContext * s ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_SSE ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_sse ; \n } \n #endif \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_avx ; \n } \n if ( EXTERNAL_FMA3 ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_fma3 ; \n } \n #endif \n }", "idx": 736}
{"project": "FFmpeg", "commit_id": "3a6ded7cfcb33e06ade98c5791eae06453f65668", "target": 1, "func": "AVVDPAUContext * av_vdpau_alloc_context ( void ) \n { \n return av_mallocz ( sizeof ( AVVDPAUContext ) ) ; \n }", "idx": 743}
{"project": "FFmpeg", "commit_id": "cea3a63ba3d89d8403eef008f7a7c54d645cff70", "target": 1, "func": "static AVBufferRef * pool_alloc_buffer ( AVBufferPool * pool ) \n { \n BufferPoolEntry * buf ; \n AVBufferRef * ret ; \n ret = pool -> alloc ( pool -> size ) ; \n if ( ! ret ) \n return NULL ; \n buf = av_mallocz ( sizeof ( * buf ) ) ; \n if ( ! buf ) { \n av_buffer_unref ( & ret ) ; \n return NULL ; \n } \n buf -> data = ret -> buffer -> data ; \n buf -> opaque = ret -> buffer -> opaque ; \n buf -> free = ret -> buffer -> free ; \n buf -> pool = pool ; \n ret -> buffer -> opaque = buf ; \n ret -> buffer -> free = pool_release_buffer ; \n avpriv_atomic_int_add_and_fetch ( & pool -> refcount , 1 ) ; \n return ret ; \n }", "idx": 744}
{"project": "FFmpeg", "commit_id": "1677155df8ee2dbf6c99738b289e27c2237506bd", "target": 1, "func": "static void compute_frame_duration ( int * pnum , int * pden , AVStream * st , \n AVCodecParserContext * pc , AVPacket * pkt ) \n { \n int frame_size ; \n * pnum = 0 ; \n * pden = 0 ; \n switch ( st -> codec . codec_type ) { \n case CODEC_TYPE_VIDEO : \n if ( st -> time_base . num * 1000 > st -> time_base . den ) { \n * pnum = st -> time_base . num ; \n * pden = st -> time_base . den ; \n } else if ( st -> codec . time_base . num * 1000 > st -> codec . time_base . den ) { \n * pnum = st -> codec . time_base . num ; \n * pden = st -> codec . time_base . den ; \n if ( pc && pc -> repeat_pict ) { \n * pden *= 2 ; \n * pnum = ( * pnum ) * ( 2 + pc -> repeat_pict ) ; \n } \n } \n break ; \n case CODEC_TYPE_AUDIO : \n frame_size = get_audio_frame_size ( & st -> codec , pkt -> size ) ; \n if ( frame_size < 0 ) \n break ; \n * pnum = frame_size ; \n * pden = st -> codec . sample_rate ; \n break ; \n default : \n break ; \n } \n }", "idx": 745}
{"project": "FFmpeg", "commit_id": "631fa0432be8968e0fd372595749b918224946df", "target": 1, "func": "static int load_apply_palette ( FFFrameSync * fs ) \n { \n AVFilterContext * ctx = fs -> parent ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n PaletteUseContext * s = ctx -> priv ; \n AVFrame * master , * second , * out = NULL ; \n int ret ; \n ret = ff_framesync_dualinput_get_writable ( fs , & master , & second ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! master || ! second ) { \n ret = AVERROR_BUG ; \n goto error ; \n } \n if ( ! s -> palette_loaded ) { \n load_palette ( s , second ) ; \n } \n ret = apply_palette ( inlink , master , & out ) ; \n if ( ret < 0 ) \n goto error ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out ) ; \n error : \n av_frame_free ( & master ) ; \n av_frame_free ( & second ) ; \n return ret ; \n }", "idx": 753}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "void avfilter_uninit ( void ) \n { \n memset ( registered_avfilters , 0 , sizeof ( registered_avfilters ) ) ; \n next_registered_avfilter_idx = 0 ; \n }", "idx": 755}
{"project": "FFmpeg", "commit_id": "d701934bef6ff6868c0a2179b7b9105c7a49b41f", "target": 0, "func": "int pcm_read_seek ( AVFormatContext * s , \n int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st ; \n int block_align , byte_rate ; \n int64_t pos ; \n st = s -> streams [ 0 ] ; \n block_align = st -> codec -> block_align ? st -> codec -> block_align : \n ( av_get_bits_per_sample ( st -> codec -> codec_id ) * st -> codec -> channels ) >> 3 ; \n byte_rate = st -> codec -> bit_rate ? st -> codec -> bit_rate >> 3 : \n block_align * st -> codec -> sample_rate ; \n if ( block_align <= 0 || byte_rate <= 0 ) \n return -1 ; \n pos = av_rescale_rnd ( timestamp * byte_rate , \n st -> time_base . num , \n st -> time_base . den * ( int64_t ) block_align , \n ( flags & AVSEEK_FLAG_BACKWARD ) ? AV_ROUND_DOWN : AV_ROUND_UP ) ; \n pos *= block_align ; \n st -> cur_dts = av_rescale ( pos , st -> time_base . den , byte_rate * ( int64_t ) st -> time_base . num ) ; \n url_fseek ( s -> pb , pos + s -> data_offset , SEEK_SET ) ; \n return 0 ; \n }", "idx": 756}
{"project": "FFmpeg", "commit_id": "9cb5c760d73e08bcd5d441d261abe67d472e98ee", "target": 0, "func": "void show_pix_fmts ( void ) \n { \n list_fmts ( avcodec_pix_fmt_string , PIX_FMT_NB ) ; \n }", "idx": 758}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int seqvideo_decode_init ( AVCodecContext * avctx ) \n { \n SeqVideoContext * seq = avctx -> priv_data ; \n seq -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n seq -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 760}
{"project": "FFmpeg", "commit_id": "d319064465e148b8adb53d1ea5d38c09f987056e", "target": 0, "func": "void set_context_opts ( void * ctx , void * opts_ctx , int flags , AVCodec * codec ) \n { \n int i ; \n void * priv_ctx = NULL ; \n if ( ! strcmp ( \" \" , ( * ( AVClass * * ) ctx ) -> class_name ) ) { \n AVCodecContext * avctx = ctx ; \n if ( codec && codec -> priv_class && avctx -> priv_data ) { \n priv_ctx = avctx -> priv_data ; \n } \n } else if ( ! strcmp ( \" \" , ( * ( AVClass * * ) ctx ) -> class_name ) ) { \n AVFormatContext * avctx = ctx ; \n if ( avctx -> oformat && avctx -> oformat -> priv_class ) { \n priv_ctx = avctx -> priv_data ; \n } \n } \n for ( i = 0 ; i < opt_name_count ; i ++ ) { \n char buf [ 256 ] ; \n const AVOption * opt ; \n const char * str = av_get_string ( opts_ctx , opt_names [ i ] , & opt , buf , sizeof ( buf ) ) ; \n if ( str && ( ( opt -> flags & flags ) == flags ) ) \n av_set_string3 ( ctx , opt_names [ i ] , str , 1 , NULL ) ; \n if ( ! str && priv_ctx ) { \n if ( av_find_opt ( priv_ctx , opt_names [ i ] , NULL , flags , flags ) ) \n av_set_string3 ( priv_ctx , opt_names [ i ] , opt_values [ i ] , 0 , NULL ) ; \n } \n } \n }", "idx": 761}
{"project": "FFmpeg", "commit_id": "7bf9e3391fa21d90ff283fc03a12287fe73db9e8", "target": 0, "func": "int av_vsrc_buffer_add_frame ( AVFilterContext * buffer_filter , AVFrame * frame , \n int64_t pts , AVRational pixel_aspect ) \n { \n BufferSourceContext * c = buffer_filter -> priv ; \n AVFilterBufferRef * buf ; \n int ret ; \n if ( ! buf ) { \n c -> eof = 1 ; \n return 0 ; \n } else if ( c -> eof ) \n return AVERROR ( EINVAL ) ; \n if ( ! av_fifo_space ( c -> fifo ) && \n ( ret = av_fifo_realloc2 ( c -> fifo , av_fifo_size ( c -> fifo ) + \n sizeof ( buf ) ) ) < 0 ) \n return ret ; \n CHECK_PARAM_CHANGE ( buffer_filter , c , frame -> width , frame -> height , frame -> format ) ; \n buf = avfilter_get_video_buffer ( buffer_filter -> outputs [ 0 ] , AV_PERM_WRITE , \n c -> w , c -> h ) ; \n av_image_copy ( buf -> data , buf -> linesize , frame -> data , frame -> linesize , \n c -> pix_fmt , c -> w , c -> h ) ; \n avfilter_copy_frame_props ( buf , frame ) ; \n buf -> pts = pts ; \n buf -> video -> pixel_aspect = pixel_aspect ; \n if ( ( ret = av_fifo_generic_write ( c -> fifo , & buf , sizeof ( buf ) , NULL ) ) < 0 ) { \n avfilter_unref_buffer ( buf ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 762}
{"project": "FFmpeg", "commit_id": "4843227b2ca6876d07caddddd62e58e52d67e94f", "target": 1, "func": "static int decode_byterun ( uint8_t * dst , int dst_size , \n const uint8_t * buf , const uint8_t * const buf_end ) \n { \n const uint8_t * const buf_start = buf ; \n unsigned x ; \n for ( x = 0 ; x < dst_size && buf < buf_end ; ) { \n unsigned length ; \n const int8_t value = * buf ++ ; \n if ( value >= 0 ) { \n length = value + 1 ; \n memcpy ( dst + x , buf , FFMIN3 ( length , dst_size - x , buf_end - buf ) ) ; \n buf += length ; \n } else if ( value > -128 ) { \n length = - value + 1 ; \n memset ( dst + x , * buf ++ , FFMIN ( length , dst_size - x ) ) ; \n } else { \n continue ; \n } \n x += length ; \n } \n if ( x < dst_size ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n memset ( dst + x , 0 , dst_size - x ) ; \n } \n return buf - buf_start ; \n }", "idx": 763}
{"project": "FFmpeg", "commit_id": "14e4e26559697cfdea584767be4e68474a0a9c7f", "target": 1, "func": "static int t15 ( InterplayACMContext * s , unsigned ind , unsigned col ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned i , b ; \n int n1 , n2 , n3 ; \n for ( i = 0 ; i < s -> rows ; i ++ ) { \n b = get_bits ( gb , 5 ) ; \n n1 = ( mul_3x3 [ b ] & 0x0F ) - 1 ; \n n2 = ( ( mul_3x3 [ b ] >> 4 ) & 0x0F ) - 1 ; \n n3 = ( ( mul_3x3 [ b ] >> 8 ) & 0x0F ) - 1 ; \n set_pos ( s , i ++ , col , n1 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i ++ , col , n2 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i , col , n3 ) ; \n return 0 ;", "idx": 770}
{"project": "FFmpeg", "commit_id": "15861962a7a9e64fbe75f5cc0dc7d1c032db8dd5", "target": 1, "func": "static void close ( AVCodecParserContext * s ) \n { \n H264Context * h = s -> priv_data ; \n ParseContext * pc = & h -> s . parse_context ; \n av_free ( pc -> buffer ) ; \n }", "idx": 777}
{"project": "FFmpeg", "commit_id": "258dfff8394d383beaa639d19912b3f068f67e16", "target": 1, "func": "static void format_line ( void * ptr , int level , const char * fmt , va_list vl , \n char part [ 3 ] [ 512 ] , int part_size , int * print_prefix , int type [ 2 ] ) \n { \n AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; \n part [ 0 ] [ 0 ] = part [ 1 ] [ 0 ] = part [ 2 ] [ 0 ] = 0 ; \n if ( type ) type [ 0 ] = type [ 1 ] = AV_CLASS_CATEGORY_NA + 16 ; \n if ( * print_prefix && avc ) { \n if ( avc -> parent_log_context_offset ) { \n AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + \n avc -> parent_log_context_offset ) ; \n if ( parent && * parent ) { \n snprintf ( part [ 0 ] , part_size , \" \" , \n ( * parent ) -> item_name ( parent ) , parent ) ; \n if ( type ) type [ 0 ] = get_category ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; \n } \n } \n snprintf ( part [ 1 ] , part_size , \" \" , \n avc -> item_name ( ptr ) , ptr ) ; \n if ( type ) type [ 1 ] = get_category ( ptr ) ; \n } \n vsnprintf ( part [ 2 ] , part_size , fmt , vl ) ; \n * print_prefix = strlen ( part [ 2 ] ) && part [ 2 ] [ strlen ( part [ 2 ] ) - 1 ] == ' \\n ' ; \n }", "idx": 828}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int h263_decode_init ( AVCodecContext * avctx ) \n { \n MpegEncContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> out_format = FMT_H263 ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_H263 : \n s -> gob_number = 0 ; \n s -> first_gob_line = 0 ; \n break ; \n case CODEC_ID_MPEG4 : \n s -> time_increment_bits = 4 ; \n s -> h263_pred = 1 ; \n s -> has_b_frames = 1 ; \n break ; \n case CODEC_ID_MSMPEG4V1 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 1 ; \n break ; \n case CODEC_ID_MSMPEG4V2 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 2 ; \n break ; \n case CODEC_ID_MSMPEG4V3 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 3 ; \n break ; \n case CODEC_ID_WMV1 : \n s -> h263_msmpeg4 = 1 ; \n s -> h263_pred = 1 ; \n s -> msmpeg4_version = 4 ; \n break ; \n case CODEC_ID_H263I : \n s -> h263_intel = 1 ; \n break ; \n default : \n return -1 ; \n } \n if ( avctx -> codec -> id != CODEC_ID_H263 && avctx -> codec -> id != CODEC_ID_MPEG4 ) \n if ( MPV_common_init ( s ) < 0 ) \n return -1 ; \n for ( i = 0 ; i < 64 ; i ++ ) \n s -> non_intra_matrix [ i ] = default_non_intra_matrix [ i ] ; \n if ( s -> h263_msmpeg4 ) \n msmpeg4_decode_init_vlc ( s ) ; \n else \n h263_decode_init_vlc ( s ) ; \n return 0 ; \n }", "idx": 831}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_sbrdsp_init_x86 ( SBRDSPContext * s ) \n { \n if ( HAVE_YASM ) { \n int mm_flags = av_get_cpu_flags ( ) ; \n if ( mm_flags & AV_CPU_FLAG_SSE ) { \n s -> sum_square = ff_sbr_sum_square_sse ; \n s -> hf_g_filt = ff_sbr_hf_g_filt_sse ; \n } \n } \n }", "idx": 835}
{"project": "FFmpeg", "commit_id": "48d6556dd46d4f4fac10d0f4a819e314887cd50e", "target": 1, "func": "static int cin_read_frame_header ( CinDemuxContext * cin , AVIOContext * pb ) { \n CinFrameHeader * hdr = & cin -> frame_header ; \n hdr -> video_frame_type = avio_r8 ( pb ) ; \n hdr -> audio_frame_type = avio_r8 ( pb ) ; \n hdr -> pal_colors_count = avio_rl16 ( pb ) ; \n hdr -> video_frame_size = avio_rl32 ( pb ) ; \n hdr -> audio_frame_size = avio_rl32 ( pb ) ; \n if ( pb -> eof_reached || pb -> error ) \n return AVERROR ( EIO ) ; \n if ( avio_rl32 ( pb ) != 0xAA55AA55 ) \n return 0 ; \n }", "idx": 847}
{"project": "FFmpeg", "commit_id": "210461c0a83a5625560fa1d92229200dc7fb869b", "target": 0, "func": "int avpicture_deinterlace ( AVPicture * dst , const AVPicture * src , \n enum AVPixelFormat pix_fmt , int width , int height ) \n { \n int i ; \n if ( pix_fmt != AV_PIX_FMT_YUV420P && \n pix_fmt != AV_PIX_FMT_YUVJ420P && \n pix_fmt != AV_PIX_FMT_YUV422P && \n pix_fmt != AV_PIX_FMT_YUVJ422P && \n pix_fmt != AV_PIX_FMT_YUV444P && \n pix_fmt != AV_PIX_FMT_YUV411P && \n pix_fmt != AV_PIX_FMT_GRAY8 ) \n return -1 ; \n if ( ( width & 3 ) != 0 || ( height & 3 ) != 0 ) \n return -1 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( i == 1 ) { \n switch ( pix_fmt ) { \n case AV_PIX_FMT_YUVJ420P : \n case AV_PIX_FMT_YUV420P : \n width >>= 1 ; \n height >>= 1 ; \n break ; \n case AV_PIX_FMT_YUV422P : \n case AV_PIX_FMT_YUVJ422P : \n width >>= 1 ; \n break ; \n case AV_PIX_FMT_YUV411P : \n width >>= 2 ; \n break ; \n default : \n break ; \n } \n if ( pix_fmt == AV_PIX_FMT_GRAY8 ) { \n break ; \n } \n } \n if ( src == dst ) { \n deinterlace_bottom_field_inplace ( dst -> data [ i ] , dst -> linesize [ i ] , \n width , height ) ; \n } else { \n deinterlace_bottom_field ( dst -> data [ i ] , dst -> linesize [ i ] , \n src -> data [ i ] , src -> linesize [ i ] , \n width , height ) ; \n } \n } \n emms_c ( ) ; \n return 0 ; \n }", "idx": 851}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int rpza_decode_init ( AVCodecContext * avctx ) \n { \n RpzaContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_RGB555 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 878}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuyv422_1 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * ubuf0 , const uint16_t * ubuf1 , \n const uint16_t * vbuf0 , const uint16_t * vbuf1 , \n const uint16_t * abuf0 , uint8_t * dest , \n int dstW , int uvalpha , enum PixelFormat dstFormat , \n int flags , int y ) \n { \n const uint16_t * buf1 = buf0 ; \n if ( uvalpha < 2048 ) { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED1 ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n } else { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED1b ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n } \n }", "idx": 889}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2gray16_1_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * ubuf0 , const uint16_t * ubuf1 , \n const uint16_t * vbuf0 , const uint16_t * vbuf1 , \n const uint16_t * abuf0 , uint8_t * dest , int dstW , \n int uvalpha , enum PixelFormat dstFormat , \n int flags , int y , enum PixelFormat target )  \n { \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n const int i2 = 2 * i ; \n int Y1 = buf0 [ i2 ] << 1 ; \n int Y2 = buf0 [ i2 + 1 ] << 1 ; \n output_pixel ( & dest [ 2 * i2 + 0 ] , Y1 ) ; \n output_pixel ( & dest [ 2 * i2 + 2 ] , Y2 ) ; \n } \n }", "idx": 890}
{"project": "FFmpeg", "commit_id": "65afa65e7393e7745427e267d6c6ca814c7c8b45", "target": 0, "func": "av_cold int ff_h264_decode_init ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n int ret ; \n ret = h264_init_context ( avctx , h ) ; \n if ( ret < 0 ) \n return ret ; \n memset ( h -> pps . scaling_matrix4 , 16 , 6 * 16 * sizeof ( uint8_t ) ) ; \n memset ( h -> pps . scaling_matrix8 , 16 , 2 * 64 * sizeof ( uint8_t ) ) ; \n if ( ! avctx -> has_b_frames ) \n h -> low_delay = 1 ; \n ff_h264_decode_init_vlc ( ) ; \n ff_init_cabac_states ( ) ; \n if ( avctx -> codec_id == AV_CODEC_ID_H264 ) { \n if ( avctx -> ticks_per_frame == 1 ) \n h -> avctx -> framerate . num *= 2 ; \n avctx -> ticks_per_frame = 2 ; \n } \n if ( avctx -> extradata_size > 0 && avctx -> extradata ) { \n ret = ff_h264_decode_extradata ( h ) ; \n if ( ret < 0 ) { \n ff_h264_free_context ( h ) ; \n return ret ; \n } \n } \n if ( h -> sps . bitstream_restriction_flag && \n h -> avctx -> has_b_frames < h -> sps . num_reorder_frames ) { \n h -> avctx -> has_b_frames = h -> sps . num_reorder_frames ; \n h -> low_delay = 0 ; \n } \n avctx -> internal -> allocate_progress = 1 ; \n if ( h -> enable_er ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" ) ; \n } \n return 0 ; \n }", "idx": 905}
{"project": "FFmpeg", "commit_id": "862c1d2f0573c81ed0929b685c55959906b4300c", "target": 0, "func": "void avcodec_get_channel_layout_string ( char * buf , int buf_size , int nb_channels , int64_t channel_layout ) \n { \n int i ; \n if ( channel_layout == 0 ) \n channel_layout = avcodec_guess_channel_layout ( nb_channels , CODEC_ID_NONE , NULL ) ; \n for ( i = 0 ; channel_layout_map [ i ] . name ; i ++ ) \n if ( nb_channels == channel_layout_map [ i ] . nb_channels && \n channel_layout == channel_layout_map [ i ] . layout ) { \n snprintf ( buf , buf_size , channel_layout_map [ i ] . name ) ; \n return ; \n } \n snprintf ( buf , buf_size , \" \" , nb_channels ) ; \n if ( channel_layout ) { \n int i , ch ; \n av_strlcat ( buf , \" \" , buf_size ) ; \n for ( i = 0 , ch = 0 ; i < 64 ; i ++ ) { \n if ( ( channel_layout & ( 1L << i ) ) ) { \n const char * name = get_channel_name ( i ) ; \n if ( name ) { \n if ( ch > 0 ) av_strlcat ( buf , \" \" , buf_size ) ; \n av_strlcat ( buf , name , buf_size ) ; \n } \n ch ++ ; \n } \n } \n av_strlcat ( buf , \" \" , buf_size ) ; \n } \n }", "idx": 917}
{"project": "FFmpeg", "commit_id": "ec849f637e8548ec6c9b6329334944c7c81df443", "target": 1, "func": "void FUNCC ( ff_h264_chroma422_dc_dequant_idct ) ( int16_t * _block , int qmul ) { \n const int stride = 16 * 2 ; \n const int xStride = 16 ; \n int i ; \n int temp [ 8 ] ; \n static const uint8_t x_offset [ 2 ] = { 0 , 16 } ; \n dctcoef * block = ( dctcoef * ) _block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n temp [ 2 * i + 0 ] = block [ stride * i + xStride * 0 ] + block [ stride * i + xStride * 1 ] ; \n temp [ 2 * i + 1 ] = block [ stride * i + xStride * 0 ] - block [ stride * i + xStride * 1 ] ; \n } \n for ( i = 0 ; i < 2 ; i ++ ) { \n const int offset = x_offset [ i ] ; \n const int z0 = temp [ 2 * 0 + i ] + temp [ 2 * 2 + i ] ; \n const int z1 = temp [ 2 * 0 + i ] - temp [ 2 * 2 + i ] ; \n const int z2 = temp [ 2 * 1 + i ] - temp [ 2 * 3 + i ] ; \n const int z3 = temp [ 2 * 1 + i ] + temp [ 2 * 3 + i ] ; \n block [ stride * 0 + offset ] = ( ( z0 + z3 ) * qmul + 128 ) >> 8 ; \n block [ stride * 1 + offset ] = ( ( z1 + z2 ) * qmul + 128 ) >> 8 ; \n block [ stride * 2 + offset ] = ( ( z1 - z2 ) * qmul + 128 ) >> 8 ; \n block [ stride * 3 + offset ] = ( ( z0 - z3 ) * qmul + 128 ) >> 8 ; \n } \n }", "idx": 919}
{"project": "FFmpeg", "commit_id": "47f0beadba9003391d8bfef59b15aa21a5b2d293", "target": 1, "func": "static void cin_decode_rle ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) \n { \n int len , code ; \n unsigned char * dst_end = dst + dst_size ; \n const unsigned char * src_end = src + src_size ; \n while ( src < src_end && dst < dst_end ) { \n code = * src ++ ; \n if ( code & 0x80 ) { \n len = code - 0x7F ; \n memset ( dst , * src ++ , FFMIN ( len , dst_end - dst ) ) ; \n } else { \n len = code + 1 ; \n memcpy ( dst , src , FFMIN ( len , dst_end - dst ) ) ; \n src += len ; \n } \n dst += len ; \n } \n }", "idx": 922}
{"project": "FFmpeg", "commit_id": "8425d693eefbedbb41f91735614d41067695aa37", "target": 1, "func": "static int flac_probe ( AVProbeData * p ) \n { \n uint8_t * bufptr = p -> buf ; \n uint8_t * end = p -> buf + p -> buf_size ; \n if ( bufptr > end - 4 || memcmp ( bufptr , \" \" , 4 ) ) return 0 ; \n else return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 931}
{"project": "FFmpeg", "commit_id": "55fa898969d10e2d47bba0613175bf57a86c5a41", "target": 1, "func": "static int get_qcd ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q , \n uint8_t * properties ) \n { \n Jpeg2000QuantStyle tmp ; \n int compno , ret ; \n if ( ( ret = get_qcx ( s , n , & tmp ) ) < 0 ) \n return ret ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_QCC ) ) \n memcpy ( q + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; \n }", "idx": 932}
{"project": "FFmpeg", "commit_id": "a39c5c4c6baafcef0c6ec7c6f59bc3fee81b2599", "target": 1, "func": "void ff_dv_offset_reset ( DVDemuxContext * c , int64_t frame_offset ) \n { \n c -> frames = frame_offset ; \n if ( c -> ach ) \n c -> abytes = av_rescale_q ( c -> frames , c -> sys -> time_base , \n ( AVRational ) { 8 , c -> ast [ 0 ] -> codec -> bit_rate } ) ; \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n }", "idx": 940}
{"project": "FFmpeg", "commit_id": "364889cf9c1f3c5e816a30d30d714a84765cfc29", "target": 1, "func": "int sws_getColorspaceDetails ( SwsContext * c , int * * inv_table , int * srcRange , int * * table , int * dstRange , int * brightness , int * contrast , int * saturation ) \n { \n if ( isYUV ( c -> dstFormat ) || isGray ( c -> dstFormat ) ) return -1 ; \n * inv_table = c -> srcColorspaceTable ; \n * table = c -> dstColorspaceTable ; \n * srcRange = c -> srcRange ; \n * dstRange = c -> dstRange ; \n * brightness = c -> brightness ; \n * contrast = c -> contrast ; \n * saturation = c -> saturation ; \n return 0 ; \n }", "idx": 947}
{"project": "FFmpeg", "commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "target": 1, "func": "static void free_field_queue ( PullupField * head , PullupField * * last ) \n { \n PullupField * f = head ; \n while ( f ) { \n av_free ( f -> diffs ) ; \n av_free ( f -> combs ) ; \n av_free ( f -> vars ) ; \n if ( f == * last ) { \n av_freep ( last ) ; \n break ; \n } \n f = f -> next ; \n av_freep ( & f -> prev ) ; \n } ; \n }", "idx": 952}
{"project": "FFmpeg", "commit_id": "4b20b21b8dabc74d676404dea94d43569a54a6b1", "target": 1, "func": "static char * doubles2str ( double * dp , int count , const char * sep ) \n { \n int i ; \n char * ap , * ap0 ; \n int component_len = 15 + strlen ( sep ) ; \n if ( ! sep ) sep = \" \" ; \n ap = av_malloc ( component_len * count ) ; \n if ( ! ap ) \n return NULL ; \n ap0 = ap ; \n ap [ 0 ] = ' \\0 ' ; \n for ( i = 0 ; i < count ; i ++ ) { \n unsigned l = snprintf ( ap , component_len , \" \" , dp [ i ] , sep ) ; \n if ( l >= component_len ) \n return NULL ; \n ap += l ; \n } \n ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = ' \\0 ' ; \n return ap0 ; \n }", "idx": 954}
{"project": "FFmpeg", "commit_id": "7ebdffc353f3f0827864e8e3461fdc00cc243b14", "target": 1, "func": "static int dxv_decompress_dxt1 ( AVCodecContext * avctx ) \n { \n DXVContext * ctx = avctx -> priv_data ; \n GetByteContext * gbc = & ctx -> gbc ; \n uint32_t value , prev , op ; \n int idx = 0 , state = 0 ; \n int pos = 2 ; \n AV_WL32 ( ctx -> tex_data , bytestream2_get_le32 ( gbc ) ) ; \n AV_WL32 ( ctx -> tex_data + 4 , bytestream2_get_le32 ( gbc ) ) ; \n while ( pos < ctx -> tex_size / 4 ) { \n CHECKPOINT ( 2 ) ; \n if ( op ) { \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n } else { \n CHECKPOINT ( 2 ) ; \n if ( op ) \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n else \n prev = bytestream2_get_le32 ( gbc ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n CHECKPOINT ( 2 ) ; \n if ( op ) \n prev = AV_RL32 ( ctx -> tex_data + 4 * ( pos - idx ) ) ; \n else \n prev = bytestream2_get_le32 ( gbc ) ; \n AV_WL32 ( ctx -> tex_data + 4 * pos , prev ) ; \n pos ++ ; \n } \n } \n return 0 ; \n }", "idx": 962}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int asv_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 965}
{"project": "FFmpeg", "commit_id": "709746b6affb5c87aee0c3b8ddb0a078453c6162", "target": 1, "func": "static int compand_nodelay ( AVFilterContext * ctx , AVFrame * frame ) \n { \n CompandContext * s = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n const int channels = inlink -> channels ; \n const int nb_samples = frame -> nb_samples ; \n AVFrame * out_frame ; \n int chan , i ; \n if ( av_frame_is_writable ( frame ) ) { \n out_frame = frame ; \n } else { \n out_frame = ff_get_audio_buffer ( inlink , nb_samples ) ; \n if ( ! out_frame ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( out_frame , frame ) ; \n } \n for ( chan = 0 ; chan < channels ; chan ++ ) { \n const double * src = ( double * ) frame -> extended_data [ chan ] ; \n double * dst = ( double * ) out_frame -> extended_data [ chan ] ; \n ChanParam * cp = & s -> channels [ chan ] ; \n for ( i = 0 ; i < nb_samples ; i ++ ) { \n update_volume ( cp , fabs ( src [ i ] ) ) ; \n dst [ i ] = av_clipd ( src [ i ] * get_volume ( s , cp -> volume ) , -1 , 1 ) ; \n } \n } \n if ( frame != out_frame ) \n av_frame_free ( & frame ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; \n }", "idx": 970}
{"project": "FFmpeg", "commit_id": "fd8b90f5f63de12c1ee1ec1cbe99791c5629c582", "target": 1, "func": "av_cold void ff_vp9dsp_init ( VP9DSPContext * dsp , int bpp ) \n { \n if ( bpp == 8 ) { \n ff_vp9dsp_init_8 ( dsp ) ; \n } else if ( bpp == 10 ) { \n ff_vp9dsp_init_10 ( dsp ) ; \n } else { \n av_assert0 ( bpp == 12 ) ; \n ff_vp9dsp_init_12 ( dsp ) ; \n } \n if ( ARCH_X86 ) ff_vp9dsp_init_x86 ( dsp , bpp ) ; \n if ( ARCH_MIPS ) ff_vp9dsp_init_mips ( dsp , bpp ) ; \n }", "idx": 973}
{"project": "FFmpeg", "commit_id": "fd6e513ee1dc13174256de8adaeeb2c2691eee95", "target": 1, "func": "static int mov_read_mdhd ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; \n get_byte ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n c -> streams [ c -> total_streams ] -> time_scale = get_be32 ( pb ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , c -> fc -> nb_streams - 1 , c -> streams [ c -> total_streams ] -> time_scale ) ; \n #endif \n get_be32 ( pb ) ; \n get_be16 ( pb ) ; \n get_be16 ( pb ) ; \n return 0 ; \n }", "idx": 974}
{"project": "FFmpeg", "commit_id": "9835abb6d63fb07613994ae90e72fef758149408", "target": 0, "func": "int ff_listen_connect ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout , URLContext * h ) \n { \n struct pollfd p = { fd , POLLOUT , 0 } ; \n int ret ; \n socklen_t optlen ; \n ff_socket_nonblock ( fd , 1 ) ; \n while ( ( ret = connect ( fd , addr , addrlen ) ) ) { \n ret = ff_neterrno ( ) ; \n switch ( ret ) { \n case AVERROR ( EINTR ) : \n if ( ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n continue ; \n case AVERROR ( EINPROGRESS ) : \n case AVERROR ( EAGAIN ) : \n while ( timeout -- ) { \n if ( ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n ret = poll ( & p , 1 , 100 ) ; \n if ( ret > 0 ) \n break ; \n } \n if ( ret <= 0 ) \n return AVERROR ( ETIMEDOUT ) ; \n optlen = sizeof ( ret ) ; \n if ( getsockopt ( fd , SOL_SOCKET , SO_ERROR , & ret , & optlen ) ) \n ret = AVUNERROR ( ff_neterrno ( ) ) ; \n if ( ret != 0 ) { \n char errbuf [ 100 ] ; \n ret = AVERROR ( ret ) ; \n av_strerror ( ret , errbuf , sizeof ( errbuf ) ) ; \n av_log ( h , AV_LOG_ERROR , \n \" \\n \" , \n h -> filename , errbuf ) ; \n } \n default : \n return ret ; \n } \n } \n return ret ; \n }", "idx": 998}
{"project": "FFmpeg", "commit_id": "58b1cba0c9173741cf769117a735b429356d83c0", "target": 1, "func": "static void read_sbr_single_channel_element ( AACContext * ac , \n SpectralBandReplication * sbr , \n GetBitContext * gb ) \n { \n if ( get_bits1 ( gb ) ) \n skip_bits ( gb , 4 ) ; \n read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ; \n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ; \n read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ; \n if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) \n get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ; \n }", "idx": 1002}
{"project": "FFmpeg", "commit_id": "0b247953c8c63baba1da93e555baff177cdf2137", "target": 1, "func": "static void put_ebml_uint ( ByteIOContext * pb , unsigned int elementid , uint64_t val ) \n { \n int i , bytes = 1 ; \n while ( val >> bytes * 8 && bytes < 8 ) bytes ++ ; \n put_ebml_id ( pb , elementid ) ; \n put_ebml_num ( pb , bytes , 0 ) ; \n for ( i = bytes - 1 ; i >= 0 ; i -- ) \n put_byte ( pb , val >> i * 8 ) ; \n }", "idx": 1006}
{"project": "FFmpeg", "commit_id": "5279141c1d7a72c467b7e0666fc2275cbcec4668", "target": 1, "func": "static void xan_unpack ( unsigned char * dest , const unsigned char * src , int dest_len ) \n { \n unsigned char opcode ; \n int size ; \n unsigned char * dest_end = dest + dest_len ; \n while ( dest < dest_end ) { \n opcode = * src ++ ; \n if ( opcode < 0xe0 ) { \n int size2 , back ; \n if ( ( opcode & 0x80 ) == 0 ) { \n size = opcode & 3 ; \n back = ( ( opcode & 0x60 ) << 3 ) + * src ++ + 1 ; \n size2 = ( ( opcode & 0x1c ) >> 2 ) + 3 ; \n } else if ( ( opcode & 0x40 ) == 0 ) { \n size = * src >> 6 ; \n back = ( bytestream_get_be16 ( & src ) & 0x3fff ) + 1 ; \n size2 = ( opcode & 0x3f ) + 4 ; \n } else { \n size = opcode & 3 ; \n back = ( ( opcode & 0x10 ) << 12 ) + bytestream_get_be16 ( & src ) + 1 ; \n size2 = ( ( opcode & 0x0c ) << 6 ) + * src ++ + 5 ; \n if ( size + size2 > dest_end - dest ) \n return ; \n } \n memcpy ( dest , src , size ) ; dest += size ; src += size ; \n av_memcpy_backptr ( dest , back , size2 ) ; \n dest += size2 ; \n } else { \n int finish = opcode >= 0xfc ; \n size = finish ? opcode & 3 : ( ( opcode & 0x1f ) << 2 ) + 4 ; \n memcpy ( dest , src , size ) ; dest += size ; src += size ; \n if ( finish ) \n return ; \n } \n } \n }", "idx": 1008}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr15ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x03E07C1F ) ; \n int dh = ( ( d0 >> 5 ) & 0x03E0F81F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int b = d & 0x7F ; \n int r = ( d >> 10 ) & 0x7F ; \n int g = d >> 21 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 - 3 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 - 3 ) ) + 128 ; \n } \n }", "idx": 1010}
{"project": "FFmpeg", "commit_id": "a726d7fd4e0b112b276678ea9da9c9b3097e8b8f", "target": 0, "func": "const AVOption * av_opt_find ( void * obj , const char * name , const char * unit , \n int opt_flags , int search_flags ) \n { \n AVClass * c = * ( AVClass * * ) obj ; \n const AVOption * o = NULL ; \n if ( c -> opt_find && search_flags & AV_OPT_SEARCH_CHILDREN && \n ( o = c -> opt_find ( obj , name , unit , opt_flags , search_flags ) ) ) \n return o ; \n while ( o = av_next_option ( obj , o ) ) { \n if ( ! strcmp ( o -> name , name ) && ( ! unit || ( o -> unit && ! strcmp ( o -> unit , unit ) ) ) && \n ( o -> flags & opt_flags ) == opt_flags ) \n return o ; \n } \n return NULL ; \n }", "idx": 1013}
{"project": "FFmpeg", "commit_id": "7fd1c85e51958050180b37a1bf4ce833d44f91e8", "target": 0, "func": "static char * mpjpeg_get_boundary ( AVIOContext * pb ) \n { \n uint8_t * mime_type = NULL ; \n const char * start ; \n const char * end ; \n uint8_t * res = NULL ; \n int len ; \n av_opt_get ( pb , \" \" , AV_OPT_SEARCH_CHILDREN , & mime_type ) ; \n start = mime_type ; \n while ( start != NULL && * start != ' \\0 ' ) { \n start = strchr ( start , ' ' ) ; \n if ( start ) \n start = start + 1 ; \n while ( av_isspace ( * start ) ) \n start ++ ; \n if ( ! av_stristart ( start , \" \" , & start ) ) { \n end = strchr ( start , ' ' ) ; \n if ( end ) \n len = end - start - 1 ; \n else \n len = strlen ( start ) ; \n res = av_strndup ( start , len ) ; \n break ; \n } \n } \n av_freep ( & mime_type ) ; \n return res ; \n }", "idx": 1016}
{"project": "FFmpeg", "commit_id": "9daa4ceaa3661bc7f994d2864e5599934e9282ce", "target": 1, "func": "int init_put_byte ( ByteIOContext * s , \n unsigned char * buffer , \n int buffer_size , \n int write_flag , \n void * opaque , \n int ( * read_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int ( * write_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int64_t ( * seek ) ( void * opaque , int64_t offset , int whence ) ) \n { \n s -> buffer = buffer ; \n s -> buffer_size = buffer_size ; \n s -> buf_ptr = buffer ; \n url_resetbuf ( s , write_flag ? URL_WRONLY : URL_RDONLY ) ; \n s -> opaque = opaque ; \n s -> write_packet = write_packet ; \n s -> read_packet = read_packet ; \n s -> seek = seek ; \n s -> pos = 0 ; \n s -> must_flush = 0 ; \n s -> eof_reached = 0 ; \n s -> error = 0 ; \n s -> is_streamed = 0 ; \n s -> max_packet_size = 0 ; \n s -> update_checksum = NULL ; \n if ( ! read_packet && ! write_flag ) { \n s -> pos = buffer_size ; \n s -> buf_end = s -> buffer + buffer_size ; \n } \n s -> read_pause = NULL ; \n s -> read_seek = NULL ; \n return 0 ; \n }", "idx": 1019}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_decode_skip_blocks ( VC1Context * v ) \n { \n MpegEncContext * s = & v -> s ; \n if ( ! v -> s . last_picture . f . data [ 0 ] ) \n return ; \n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y , s -> mb_width - 1 , s -> end_mb_y - 1 , ER_MB_END ) ; \n s -> first_slice_line = 1 ; \n for ( s -> mb_y = s -> start_mb_y ; s -> mb_y < s -> end_mb_y ; s -> mb_y ++ ) { \n s -> mb_x = 0 ; \n init_block_index ( v ) ; \n ff_update_block_index ( s ) ; \n memcpy ( s -> dest [ 0 ] , s -> last_picture . f . data [ 0 ] + s -> mb_y * 16 * s -> linesize , s -> linesize * 16 ) ; \n memcpy ( s -> dest [ 1 ] , s -> last_picture . f . data [ 1 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ; \n memcpy ( s -> dest [ 2 ] , s -> last_picture . f . data [ 2 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ; \n ff_mpeg_draw_horiz_band ( s , s -> mb_y * 16 , 16 ) ; \n s -> first_slice_line = 0 ; \n } \n s -> pict_type = AV_PICTURE_TYPE_P ; \n }", "idx": 1020}
{"project": "FFmpeg", "commit_id": "ca616b0f72c65b0ef5f9e1e6125698b15f50a26e", "target": 1, "func": "static av_cold int init_buffers ( SANMVideoContext * ctx ) \n { \n av_fast_padded_malloc ( & ctx -> frm0 , & ctx -> frm0_size , ctx -> buf_size ) ; \n av_fast_padded_malloc ( & ctx -> frm1 , & ctx -> frm1_size , ctx -> buf_size ) ; \n av_fast_padded_malloc ( & ctx -> frm2 , & ctx -> frm2_size , ctx -> buf_size ) ; \n if ( ! ctx -> version ) \n av_fast_padded_malloc ( & ctx -> stored_frame , \n & ctx -> stored_frame_size , ctx -> buf_size ) ; \n if ( ! ctx -> frm0 || ! ctx -> frm1 || ! ctx -> frm2 || \n ( ! ctx -> stored_frame && ! ctx -> version ) ) { \n destroy_buffers ( ctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 1032}
{"project": "FFmpeg", "commit_id": "5eafc8b46644764f8aef1b7b2ecae53ee8034822", "target": 1, "func": "static void release_delayed_buffers ( PerThreadContext * p ) \n { \n FrameThreadContext * fctx = p -> parent ; \n while ( p -> num_released_buffers > 0 ) { \n AVFrame * f = & p -> released_buffers [ -- p -> num_released_buffers ] ; \n pthread_mutex_lock ( & fctx -> buffer_mutex ) ; \n free_progress ( f ) ; \n f -> thread_opaque = NULL ; \n f -> owner -> release_buffer ( f -> owner , f ) ; \n pthread_mutex_unlock ( & fctx -> buffer_mutex ) ; \n } \n }", "idx": 1039}
{"project": "FFmpeg", "commit_id": "66edd8656b851a0c85ba25ec293cc66192c363ae", "target": 1, "func": "double ff_lpc_calc_ref_coefs_f ( LPCContext * s , const float * samples , int len , \n int order , double * ref ) \n { \n int i ; \n double signal = 0.0f , avg_err = 0.0f ; \n double autoc [ MAX_LPC_ORDER + 1 ] = { 0 } , error [ MAX_LPC_ORDER + 1 ] = { 0 } ; \n const double a = 0.5f , b = 1.0f - a ; \n for ( i = 0 ; i < len ; i ++ ) { \n double weight = a - b * cos ( ( 2 * M_PI * i ) / ( len - 1 ) ) ; \n s -> windowed_samples [ i ] = weight * samples [ i ] ; \n } \n s -> lpc_compute_autocorr ( s -> windowed_samples , len , order , autoc ) ; \n signal = autoc [ 0 ] ; \n compute_ref_coefs ( autoc , order , ref , error ) ; \n for ( i = 0 ; i < order ; i ++ ) \n avg_err = ( avg_err + error [ i ] ) / 2.0f ; \n return signal / avg_err ; \n }", "idx": 1041}
{"project": "FFmpeg", "commit_id": "c2cb01d418dd18e1cf997c038d37378d773121be", "target": 1, "func": "int av_write_trailer ( AVFormatContext * s ) \n { \n int ret , i ; \n for ( ; ; ) { \n AVPacket pkt ; \n ret = interleave_packet ( s , & pkt , NULL , 1 ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( ! ret ) \n break ; \n ret = s -> oformat -> write_packet ( s , & pkt ) ; \n if ( ret >= 0 ) \n s -> streams [ pkt . stream_index ] -> nb_frames ++ ; \n av_free_packet ( & pkt ) ; \n if ( ret < 0 ) \n goto fail ; \n } \n if ( s -> oformat -> write_trailer ) \n ret = s -> oformat -> write_trailer ( s ) ; \n if ( ! ( s -> oformat -> flags & AVFMT_NOFILE ) ) \n avio_flush ( s -> pb ) ; \n fail : \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n av_freep ( & s -> streams [ i ] -> priv_data ) ; \n av_freep ( & s -> streams [ i ] -> index_entries ) ; \n } \n if ( s -> oformat -> priv_class ) \n av_opt_free ( s -> priv_data ) ; \n av_freep ( & s -> priv_data ) ; \n return ret ; \n }", "idx": 1043}
{"project": "FFmpeg", "commit_id": "1619274fb393f55a365cc10f88faa173c9a8e772", "target": 1, "func": "int av_dict_set ( AVDictionary * * pm , const char * key , const char * value , \n int flags ) \n { \n AVDictionary * m = * pm ; \n AVDictionaryEntry * tag = av_dict_get ( m , key , NULL , flags ) ; \n char * oldval = NULL ; \n if ( ! m ) \n m = * pm = av_mallocz ( sizeof ( * m ) ) ; \n if ( tag ) { \n if ( flags & AV_DICT_DONT_OVERWRITE ) \n return 0 ; \n if ( flags & AV_DICT_APPEND ) \n oldval = tag -> value ; \n else \n av_free ( tag -> value ) ; \n av_free ( tag -> key ) ; \n * tag = m -> elems [ -- m -> count ] ; \n } else { \n AVDictionaryEntry * tmp = av_realloc ( m -> elems , \n ( m -> count + 1 ) * sizeof ( * m -> elems ) ) ; \n if ( tmp ) \n m -> elems = tmp ; \n else \n return AVERROR ( ENOMEM ) ; \n } \n if ( value ) { \n if ( flags & AV_DICT_DONT_STRDUP_KEY ) \n m -> elems [ m -> count ] . key = key ; \n else \n m -> elems [ m -> count ] . key = av_strdup ( key ) ; \n if ( flags & AV_DICT_DONT_STRDUP_VAL ) { \n m -> elems [ m -> count ] . value = value ; \n } else if ( oldval && flags & AV_DICT_APPEND ) { \n int len = strlen ( oldval ) + strlen ( value ) + 1 ; \n if ( ! ( oldval = av_realloc ( oldval , len ) ) ) \n return AVERROR ( ENOMEM ) ; \n av_strlcat ( oldval , value , len ) ; \n m -> elems [ m -> count ] . value = oldval ; \n } else \n m -> elems [ m -> count ] . value = av_strdup ( value ) ; \n m -> count ++ ; \n } \n if ( ! m -> count ) { \n av_free ( m -> elems ) ; \n av_freep ( pm ) ; \n } \n return 0 ; \n }", "idx": 1044}
{"project": "FFmpeg", "commit_id": "c535436cbeeab89be64e9f3fd652bc736f2f3245", "target": 1, "func": "static inline int read_huff_channels ( MLPDecodeContext * m , GetBitContext * gbp , \n unsigned int substr , unsigned int pos ) \n { \n SubStream * s = & m -> substream [ substr ] ; \n unsigned int mat , channel ; \n for ( mat = 0 ; mat < s -> num_primitive_matrices ; mat ++ ) \n if ( s -> lsb_bypass [ mat ] ) \n m -> bypassed_lsbs [ pos + s -> blockpos ] [ mat ] = get_bits1 ( gbp ) ; \n for ( channel = s -> min_channel ; channel <= s -> max_channel ; channel ++ ) { \n ChannelParams * cp = & s -> channel_params [ channel ] ; \n int codebook = cp -> codebook ; \n int quant_step_size = s -> quant_step_size [ channel ] ; \n int lsb_bits = cp -> huff_lsbs - quant_step_size ; \n int result = 0 ; \n if ( codebook > 0 ) \n result = get_vlc2 ( gbp , huff_vlc [ codebook - 1 ] . table , \n VLC_BITS , ( 9 + VLC_BITS - 1 ) / VLC_BITS ) ; \n if ( result < 0 ) \n return AVERROR_INVALIDDATA ; \n if ( lsb_bits > 0 ) \n result = ( result << lsb_bits ) + get_bits ( gbp , lsb_bits ) ; \n result += cp -> sign_huff_offset ; \n result <<= quant_step_size ; \n m -> sample_buffer [ pos + s -> blockpos ] [ channel ] = result ; \n } \n return 0 ; \n }", "idx": 1049}
{"project": "FFmpeg", "commit_id": "04c99c8042c8bfae817c722d90aa0f1a40db861e", "target": 1, "func": "void FUNCC ( ff_h264_luma_dc_dequant_idct ) ( int16_t * _output , int16_t * _input , int qmul ) { \n #define stride  16  \n  \n  int i ; \n int temp [ 16 ] ; \n static const uint8_t x_offset [ 4 ] = { 0 , 2 * stride , 8 * stride , 10 * stride } ; \n dctcoef * input = ( dctcoef * ) _input ; \n dctcoef * output = ( dctcoef * ) _output ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = input [ 4 * i + 0 ] + input [ 4 * i + 1 ] ; \n const int z1 = input [ 4 * i + 0 ] - input [ 4 * i + 1 ] ; \n const int z2 = input [ 4 * i + 2 ] - input [ 4 * i + 3 ] ; \n const int z3 = input [ 4 * i + 2 ] + input [ 4 * i + 3 ] ; \n temp [ 4 * i + 0 ] = z0 + z3 ; \n temp [ 4 * i + 1 ] = z0 - z3 ; \n temp [ 4 * i + 2 ] = z1 - z2 ; \n temp [ 4 * i + 3 ] = z1 + z2 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int offset = x_offset [ i ] ; \n const int z0 = temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ; \n const int z1 = temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ; \n const int z2 = temp [ 4 * 1 + i ] - temp [ 4 * 3 + i ] ; \n const int z3 = temp [ 4 * 1 + i ] + temp [ 4 * 3 + i ] ; \n output [ stride * 0 + offset ] = ( ( ( ( z0 + z3 ) * qmul + 128 ) >> 8 ) ) ; \n output [ stride * 1 + offset ] = ( ( ( ( z1 + z2 ) * qmul + 128 ) >> 8 ) ) ; \n output [ stride * 4 + offset ] = ( ( ( ( z1 - z2 ) * qmul + 128 ) >> 8 ) ) ; \n output [ stride * 5 + offset ] = ( ( ( ( z0 - z3 ) * qmul + 128 ) >> 8 ) ) ; \n } \n #undef  stride  \n  \n  }", "idx": 1092}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_ydt24_entry ( int p1 , int p2 , int16_t * ydt ) \n { \n int lo , hi ; \n lo = ydt [ p1 ] ; \n hi = ydt [ p2 ] ; \n return ( lo + ( hi << 8 ) + ( hi << 16 ) ) << 1 ; \n }", "idx": 1128}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void * grow_array ( void * array , int elem_size , int * size , int new_size ) \n { \n if ( new_size >= INT_MAX / elem_size ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( * size < new_size ) { \n uint8_t * tmp = av_realloc ( array , new_size * elem_size ) ; \n if ( ! tmp ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n memset ( tmp + * size * elem_size , 0 , ( new_size - * size ) * elem_size ) ; \n * size = new_size ; \n return tmp ; \n } \n return array ; \n }", "idx": 1135}
{"project": "FFmpeg", "commit_id": "1cadab602343c4f577d2710a43bc66fde5a0d20b", "target": 0, "func": "static int select_input_file ( uint8_t * no_packet ) \n { \n int64_t ipts_min = INT64_MAX ; \n int i , file_index = -1 ; \n for ( i = 0 ; i < nb_input_streams ; i ++ ) { \n InputStream * ist = input_streams [ i ] ; \n int64_t ipts = ist -> pts ; \n if ( ist -> discard || no_packet [ ist -> file_index ] ) \n continue ; \n if ( ! input_files [ ist -> file_index ] -> eof_reached ) { \n if ( ipts < ipts_min ) { \n ipts_min = ipts ; \n file_index = ist -> file_index ; \n } \n } \n } \n return file_index ; \n }", "idx": 1139}
{"project": "FFmpeg", "commit_id": "0393cf15dbe3b136647b81676a105815924eebcd", "target": 1, "func": "AVCodecParserContext * av_parser_init ( int codec_id ) \n { \n AVCodecParserContext * s = NULL ; \n AVCodecParser * parser ; \n int ret ; \n if ( codec_id == AV_CODEC_ID_NONE ) \n return NULL ; \n for ( parser = av_first_parser ; parser != NULL ; parser = parser -> next ) { \n if ( parser -> codec_ids [ 0 ] == codec_id || \n parser -> codec_ids [ 1 ] == codec_id || \n parser -> codec_ids [ 2 ] == codec_id || \n parser -> codec_ids [ 3 ] == codec_id || \n parser -> codec_ids [ 4 ] == codec_id ) \n goto found ; \n } \n return NULL ; \n found : \n s = av_mallocz ( sizeof ( AVCodecParserContext ) ) ; \n if ( ! s ) \n goto err_out ; \n s -> parser = parser ; \n s -> priv_data = av_mallocz ( parser -> priv_data_size ) ; \n if ( ! s -> priv_data ) \n goto err_out ; \n s -> fetch_timestamp = 1 ; \n s -> pict_type = AV_PICTURE_TYPE_I ; \n if ( parser -> parser_init ) { \n if ( ff_lock_avcodec ( NULL ) < 0 ) \n goto err_out ; \n ret = parser -> parser_init ( s ) ; \n ff_unlock_avcodec ( ) ; \n if ( ret != 0 ) \n goto err_out ; \n } \n s -> key_frame = -1 ; \n s -> convergence_duration = 0 ; \n s -> dts_sync_point = INT_MIN ; \n s -> dts_ref_dts_delta = INT_MIN ; \n s -> pts_dts_delta = INT_MIN ; \n return s ; \n err_out : \n if ( s ) \n av_freep ( & s -> priv_data ) ; \n av_free ( s ) ; \n return NULL ; \n }", "idx": 1149}
{"project": "FFmpeg", "commit_id": "445f0a8b666a34e6402f6ae96c6804c8bc024baa", "target": 0, "func": "int avcodec_check_dimensions ( void * av_log_ctx , unsigned int w , unsigned int h ) { \n if ( ( int ) w > 0 && ( int ) h > 0 && ( w + 128 ) * ( uint64_t ) ( h + 128 ) < INT_MAX / 4 ) \n return 0 ; \n av_log ( av_log_ctx , AV_LOG_ERROR , \" \\n \" , w , h ) ; \n return -1 ; \n }", "idx": 1153}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static int find_unused_picture ( MpegEncContext * s , int shared ) \n { \n int i ; \n if ( shared ) { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . f . data [ 0 ] == NULL ) \n return i ; \n } \n } else { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( pic_is_unused ( s , & s -> picture [ i ] ) ) \n return i ; \n } \n } \n return AVERROR_INVALIDDATA ; \n }", "idx": 1154}
{"project": "FFmpeg", "commit_id": "2ea38a946dbd7c4528f5729f494758cfad491fa8", "target": 0, "func": "static int av_always_inline mlp_thd_probe ( AVProbeData * p , uint32_t sync ) \n { \n const uint8_t * buf , * last_buf = p -> buf , * end = p -> buf + p -> buf_size ; \n int frames = 0 , valid = 0 , size = 0 ; \n for ( buf = p -> buf ; buf + 8 <= end ; buf ++ ) { \n if ( AV_RB32 ( buf + 4 ) == sync ) { \n frames ++ ; \n if ( last_buf + size == buf ) { \n valid ++ ; \n } \n last_buf = buf ; \n size = ( AV_RB16 ( buf ) & 0xfff ) * 2 ; \n } else if ( buf - last_buf == size ) { \n size += ( AV_RB16 ( buf ) & 0xfff ) * 2 ; \n } \n } \n if ( valid >= 100 ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 1155}
{"project": "FFmpeg", "commit_id": "18b101ff595c7f18e9571d26f8840f556b24ec03", "target": 0, "func": "intptr_t ( * checkasm_check_func ( intptr_t ( * func ) ( ) , const char * name , ... ) ) ( ) \n { \n char name_buf [ 256 ] ; \n intptr_t ( * ref ) ( ) = func ; \n CheckasmFuncVersion * v ; \n int name_length ; \n va_list arg ; \n va_start ( arg , name ) ; \n name_length = vsnprintf ( name_buf , sizeof ( name_buf ) , name , arg ) ; \n va_end ( arg ) ; \n if ( ! func || name_length <= 0 || name_length >= sizeof ( name_buf ) ) \n return NULL ; \n state . current_func = get_func ( name_buf , name_length ) ; \n v = & state . current_func -> versions ; \n if ( v -> func ) { \n CheckasmFuncVersion * prev ; \n do { \n if ( v -> func == func ) \n return NULL ; \n if ( v -> ok ) \n ref = v -> func ; \n prev = v ; \n } while ( ( v = v -> next ) ) ; \n v = prev -> next = checkasm_malloc ( sizeof ( CheckasmFuncVersion ) ) ; \n } \n v -> func = func ; \n v -> ok = 1 ; \n v -> cpu = state . cpu_flag ; \n state . current_func_ver = v ; \n if ( state . cpu_flag ) \n state . num_checked ++ ; \n return ref ; \n }", "idx": 1190}
{"project": "FFmpeg", "commit_id": "85e7386ae0d33ede4c575d4df4c1faae6c906338", "target": 0, "func": "mlt_compensate_output ( COOKContext * q , float * decode_buffer , \n cook_gains * gains , float * previous_buffer , \n int16_t * out , int chan )  \n { \n int j ; \n cook_imlt ( q , decode_buffer , q -> mono_mdct_output ) ; \n gain_compensate ( q , gains , previous_buffer ) ; \n for ( j = 0 ; j < q -> samples_per_channel ; j ++ ) { \n out [ chan + q -> nb_channels * j ] = \n av_clip ( lrintf ( q -> mono_mdct_output [ j ] ) , -32768 , 32767 ) ; \n } \n }", "idx": 1206}
{"project": "FFmpeg", "commit_id": "1fb46858c2498c67ae2d6775f7da29732e88fb8a", "target": 0, "func": "static inline void scale_mv ( AVSContext * h , int * d_x , int * d_y , \n cavs_vector * src , int distp ) \n { \n int den = h -> scale_den [ src -> ref ] ; \n * d_x = ( src -> x * distp * den + 256 + ( src -> x >> 31 ) ) >> 9 ; \n * d_y = ( src -> y * distp * den + 256 + ( src -> y >> 31 ) ) >> 9 ; \n }", "idx": 1237}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "int ff_af_queue_add ( AudioFrameQueue * afq , const AVFrame * f ) \n { \n AudioFrame * new_frame ; \n AudioFrame * queue_end = afq -> frame_queue ; \n while ( queue_end && queue_end -> next ) \n queue_end = queue_end -> next ; \n if ( ! ( new_frame = av_malloc ( sizeof ( * new_frame ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n new_frame -> next = NULL ; \n new_frame -> duration = f -> nb_samples ; \n if ( f -> pts != AV_NOPTS_VALUE ) { \n new_frame -> pts = av_rescale_q ( f -> pts , \n afq -> avctx -> time_base , \n ( AVRational ) { 1 , afq -> avctx -> sample_rate } ) ; \n afq -> next_pts = new_frame -> pts + new_frame -> duration ; \n } else { \n new_frame -> pts = AV_NOPTS_VALUE ; \n afq -> next_pts = AV_NOPTS_VALUE ; \n } \n if ( ! queue_end ) \n afq -> frame_queue = new_frame ; \n else \n queue_end -> next = new_frame ; \n afq -> remaining_samples += f -> nb_samples ; \n #ifdef DEBUG \n ff_af_queue_log_state ( afq ) ; \n #endif \n return 0 ; \n }", "idx": 1240}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add8_mmx2 ( uint8_t * * dest , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 16 ; i < 16 + 8 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] ) \n ff_h264_idct_add_mmx ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] ) \n ff_h264_idct_dc_add_mmx2 ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 1270}
{"project": "FFmpeg", "commit_id": "6c643e070584ba7af251d3907e277d2170537b1f", "target": 0, "func": "int ff_isom_write_avcc ( AVIOContext * pb , const uint8_t * data , int len ) \n { \n if ( len > 6 ) { \n if ( AV_RB32 ( data ) == 0x00000001 || \n AV_RB24 ( data ) == 0x000001 ) { \n uint8_t * buf = NULL , * end , * start ; \n uint32_t sps_size = 0 , pps_size = 0 ; \n uint8_t * sps = 0 , * pps = 0 ; \n int ret = ff_avc_parse_nal_units_buf ( data , & buf , & len ) ; \n if ( ret < 0 ) \n return ret ; \n start = buf ; \n end = buf + len ; \n while ( buf < end ) { \n unsigned int size ; \n uint8_t nal_type ; \n size = AV_RB32 ( buf ) ; \n nal_type = buf [ 4 ] & 0x1f ; \n if ( nal_type == 7 ) { \n sps = buf + 4 ; \n sps_size = size ; \n } else if ( nal_type == 8 ) { \n pps = buf + 4 ; \n pps_size = size ; \n } \n buf += size + 4 ; \n } \n assert ( sps ) ; \n assert ( pps ) ; \n avio_w8 ( pb , 1 ) ; \n avio_w8 ( pb , sps [ 1 ] ) ; \n avio_w8 ( pb , sps [ 2 ] ) ; \n avio_w8 ( pb , sps [ 3 ] ) ; \n avio_w8 ( pb , 0xff ) ; \n avio_w8 ( pb , 0xe1 ) ; \n avio_wb16 ( pb , sps_size ) ; \n avio_write ( pb , sps , sps_size ) ; \n avio_w8 ( pb , 1 ) ; \n avio_wb16 ( pb , pps_size ) ; \n avio_write ( pb , pps , pps_size ) ; \n av_free ( start ) ; \n } else { \n avio_write ( pb , data , len ) ; \n } \n } \n return 0 ; \n }", "idx": 1271}
{"project": "FFmpeg", "commit_id": "04001767728fd4ed8b4f9d2ebbb9f9a8c9a7be0d", "target": 0, "func": "static void uninit ( struct vf_instance * vf ) \n { \n free ( vf -> priv ) ; \n }", "idx": 1272}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void float_to_int ( float * _f , int16_t * s16 , int samples ) \n { \n int32_t * f = ( int32_t * ) _f ; \n int i ; \n for ( i = 0 ; i < samples ; i ++ ) { \n s16 [ i ] = blah ( f [ i ] ) ; \n } \n }", "idx": 1296}
{"project": "FFmpeg", "commit_id": "ba3517aa6f573d280d80866e776885be7f01de77", "target": 1, "func": "void uninit_opts ( void ) \n { \n int i ; \n for ( i = 0 ; i < AVMEDIA_TYPE_NB ; i ++ ) \n av_freep ( & avcodec_opts [ i ] ) ; \n av_freep ( & avformat_opts -> key ) ; \n av_freep ( & avformat_opts ) ; \n #if CONFIG_SWSCALE  \n  \n  av_freep ( & sws_opts ) ; \n #endif \n }", "idx": 1310}
{"project": "FFmpeg", "commit_id": "085ca7dcdbf9ab6c23e3a5397b1f6d4aa23f763d", "target": 1, "func": "static int teletext_close_decoder ( AVCodecContext * avctx ) \n { \n TeletextContext * ctx = avctx -> priv_data ; \n av_dlog ( avctx , \" \\n \" , ctx -> lines_processed ) ; \n while ( ctx -> nb_pages ) \n subtitle_rect_free ( & ctx -> pages [ -- ctx -> nb_pages ] . sub_rect ) ; \n av_freep ( & ctx -> pages ) ; \n vbi_dvb_demux_delete ( ctx -> dx ) ; \n vbi_decoder_delete ( ctx -> vbi ) ; \n ctx -> dx = NULL ; \n ctx -> vbi = NULL ; \n ctx -> pts = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 1315}
{"project": "FFmpeg", "commit_id": "95116bf35f1bbc15a41be67f70f31b8de6075b8f", "target": 1, "func": "static OSStatus ffat_decode_callback ( AudioConverterRef converter , UInt32 * nb_packets , \n AudioBufferList * data , \n AudioStreamPacketDescription * * packets , \n void * inctx ) \n { \n AVCodecContext * avctx = inctx ; \n ATDecodeContext * at = avctx -> priv_data ; \n if ( at -> eof ) { \n * nb_packets = 0 ; \n if ( packets ) { \n * packets = & at -> pkt_desc ; \n at -> pkt_desc . mDataByteSize = 0 ; \n } \n return 0 ; \n } \n av_packet_move_ref ( & at -> in_pkt , & at -> new_in_pkt ) ; \n at -> new_in_pkt . data = 0 ; \n at -> new_in_pkt . size = 0 ; \n if ( ! at -> in_pkt . data ) { \n * nb_packets = 0 ; \n return 1 ; \n } \n data -> mNumberBuffers = 1 ; \n data -> mBuffers [ 0 ] . mNumberChannels = 0 ; \n data -> mBuffers [ 0 ] . mDataByteSize = at -> in_pkt . size ; \n data -> mBuffers [ 0 ] . mData = at -> in_pkt . data ; \n * nb_packets = 1 ; \n if ( packets ) { \n * packets = & at -> pkt_desc ; \n at -> pkt_desc . mDataByteSize = at -> in_pkt . size ; \n } \n return 0 ; \n }", "idx": 1317}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "func": "static int sse8_altivec ( void * v , uint8_t * pix1 , uint8_t * pix2 , int line_size , int h ) \n { \n int i ; \n int s ; \n const vector unsigned  int zero = ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n const vector unsigned  char permclear = ( vector unsigned char ) { 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n vector unsigned  char perm1 = vec_lvsl ( 0 , pix1 ) ; \n vector unsigned  char perm2 = vec_lvsl ( 0 , pix2 ) ; \n vector unsigned  char t1 , t2 , t3 , t4 , t5 ; \n vector unsigned  int sum ; \n vector signed  int sumsqr ; \n sum = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n vector unsigned  char pix1l = vec_ld ( 0 , pix1 ) ; \n vector unsigned  char pix1r = vec_ld ( 15 , pix1 ) ; \n vector unsigned  char pix2l = vec_ld ( 0 , pix2 ) ; \n vector unsigned  char pix2r = vec_ld ( 15 , pix2 ) ; \n t1 = vec_and ( vec_perm ( pix1l , pix1r , perm1 ) , permclear ) ; \n t2 = vec_and ( vec_perm ( pix2l , pix2r , perm2 ) , permclear ) ; \n t3 = vec_max ( t1 , t2 ) ; \n t4 = vec_min ( t1 , t2 ) ; \n t5 = vec_sub ( t3 , t4 ) ; \n sum = vec_msum ( t5 , t5 , sum ) ; \n pix1 += line_size ; \n pix2 += line_size ; \n } \n sumsqr = vec_sums ( ( vector signed int ) sum , ( vector signed int ) zero ) ; \n sumsqr = vec_splat ( sumsqr , 3 ) ; \n vec_ste ( sumsqr , 0 , & s ) ; \n return s ; \n }", "idx": 1319}
{"project": "FFmpeg", "commit_id": "56e2cd9c042e05255aa28487694c29aaec023263", "target": 1, "func": "static int probe ( AVProbeData * p ) \n { \n unsigned i , frames , checked = 0 ; \n if ( p -> buf_size < 22 || AV_RL16 ( p -> buf ) || AV_RL16 ( p -> buf + 2 ) != 1 ) \n return 0 ; \n frames = AV_RL16 ( p -> buf + 4 ) ; \n if ( ! frames ) \n return 0 ; \n for ( i = 0 ; i < frames && i * 16 + 22 <= p -> buf_size ; i ++ ) { \n unsigned offset ; \n if ( AV_RL16 ( p -> buf + 10 + i * 16 ) & ~ 1 ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n if ( p -> buf [ 13 + i * 16 ] ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n if ( AV_RL32 ( p -> buf + 14 + i * 16 ) < 40 ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n offset = AV_RL32 ( p -> buf + 18 + i * 16 ) ; \n if ( offset < 22 ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n if ( offset + 8 > p -> buf_size ) \n continue ; \n if ( p -> buf [ offset ] != 40 && AV_RB64 ( p -> buf + offset ) != PNGSIG ) \n return FFMIN ( i , AVPROBE_SCORE_MAX / 4 ) ; \n checked ++ ; \n } \n if ( checked < frames ) \n return AVPROBE_SCORE_MAX / 4 + FFMIN ( checked , 1 ) ; \n return AVPROBE_SCORE_MAX / 2 + 1 ; \n }", "idx": 1322}
{"project": "FFmpeg", "commit_id": "4956d0e5a6a555d31345c913485bcc4e0a53481e", "target": 0, "func": "int64_t av_add_stable ( AVRational ts_tb , int64_t ts , AVRational inc_tb , int64_t inc ) \n { \n inc_tb = av_mul_q ( inc_tb , ( AVRational ) { inc , 1 } ) ; \n if ( av_cmp_q ( inc_tb , ts_tb ) < 0 ) { \n return ts ; \n } else { \n int64_t old = av_rescale_q ( ts , ts_tb , inc_tb ) ; \n int64_t old_ts = av_rescale_q ( old , inc_tb , ts_tb ) ; \n return av_rescale_q ( old + 1 , inc_tb , ts_tb ) + ( ts - old_ts ) ; \n } \n }", "idx": 1323}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_8w_msa ( src - 2 , src - ( stride * 2 ) , stride , dst , stride , 8 ) ; \n }", "idx": 1325}
{"project": "FFmpeg", "commit_id": "ad47ac20ae3e8ac52fa23f6fa520a3124cc515cd", "target": 1, "func": "static int parse_times ( void * log_ctx , int64_t * * times , int * nb_times , \n const char * times_str ) \n { \n char * p ; \n int i , ret = 0 ; \n char * times_str1 = av_strdup ( times_str ) ; \n char * saveptr = NULL ; \n if ( ! times_str1 ) \n return AVERROR ( ENOMEM ) ; \n #define FAIL ( err )  ret = err; goto end  \n  \n  \n  \n  * nb_times = 1 ; \n for ( p = times_str1 ; * p ; p ++ ) \n if ( * p == ' ' ) \n ( * nb_times ) ++ ; \n * times = av_malloc ( sizeof ( * * times ) * * nb_times ) ; \n if ( ! * times ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n FAIL ( AVERROR ( ENOMEM ) ) ; \n } \n p = times_str1 ; \n for ( i = 0 ; i < * nb_times ; i ++ ) { \n int64_t t ; \n char * tstr = av_strtok ( p , \" \" , & saveptr ) ; \n av_assert0 ( tstr ) ; \n p = NULL ; \n ret = av_parse_time ( & t , tstr , 1 ) ; \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , p ) ; \n FAIL ( AVERROR ( EINVAL ) ) ; \n } \n ( * times ) [ i ] = t ; \n if ( i && ( * times ) [ i - 1 ] > ( * times ) [ i ] ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , \n ( float ) ( ( * times ) [ i ] ) / 1000000 , ( float ) ( ( * times ) [ i - 1 ] ) / 1000000 ) ; \n FAIL ( AVERROR ( EINVAL ) ) ; \n } \n } \n end : \n av_free ( times_str1 ) ; \n return ret ; \n }", "idx": 1327}
{"project": "FFmpeg", "commit_id": "90a09b69d7f5d4fc5622c6aec69d5ceef1a72c04", "target": 1, "func": "static void floor_fit ( venc_context_t * venc , floor_t * fc , float * coeffs , int * posts , int samples ) { \n int range = 255 / fc -> multiplier + 1 ; \n int i ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n int position = fc -> list [ fc -> list [ i ] . sort ] . x ; \n int begin = fc -> list [ fc -> list [ FFMAX ( i - 1 , 0 ) ] . sort ] . x ; \n int end = fc -> list [ fc -> list [ FFMIN ( i + 1 , fc -> values - 1 ) ] . sort ] . x ; \n int j ; \n float average = 0 ; \n begin = ( position + begin ) / 2 ; \n end = ( position + end ) / 2 ; \n assert ( end <= samples ) ; \n for ( j = begin ; j < end ; j ++ ) average += fabs ( coeffs [ j ] ) ; \n average /= end - begin ; \n average /= 32 ; \n for ( j = 0 ; j < range ; j ++ ) if ( floor1_inverse_db_table [ j * fc -> multiplier ] > average ) break ; \n posts [ fc -> list [ i ] . sort ] = j ; \n } \n }", "idx": 1328}
{"project": "FFmpeg", "commit_id": "af19f78f2fe2b969104d4419efd25fdee90a2814", "target": 0, "func": "void dsputil_init_ppc ( void ) \n { \n #if HAVE_ALTIVEC  \n  \n  if ( has_altivec ( ) ) { \n pix_abs16x16 = pix_abs16x16_altivec ; \n pix_abs8x8 = pix_abs8x8_altivec ; \n pix_sum = pix_sum_altivec ; \n diff_pixels = diff_pixels_altivec ; \n get_pixels = get_pixels_altivec ; \n } else \n #endif \n { \n } \n }", "idx": 1336}
{"project": "FFmpeg", "commit_id": "65c14801527068fcaf729eeffc142ffd4682a21a", "target": 0, "func": "void checkasm_report ( const char * name , ... ) \n { \n static int prev_checked , prev_failed , max_length ; \n if ( state . num_checked > prev_checked ) { \n print_cpu_name ( ) ; \n if ( * name ) { \n int pad_length = max_length ; \n va_list arg ; \n fprintf ( stderr , \" \" ) ; \n va_start ( arg , name ) ; \n pad_length -= vfprintf ( stderr , name , arg ) ; \n va_end ( arg ) ; \n fprintf ( stderr , \" \" , FFMAX ( pad_length , 0 ) + 2 , ' ' ) ; \n } else \n fprintf ( stderr , \" \" , max_length , state . current_func -> name ) ; \n if ( state . num_failed == prev_failed ) \n color_printf ( COLOR_GREEN , \" \" ) ; \n else \n color_printf ( COLOR_RED , \" \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n prev_checked = state . num_checked ; \n prev_failed = state . num_failed ; \n } else if ( ! state . cpu_flag ) { \n int length ; \n if ( * name ) { \n va_list arg ; \n va_start ( arg , name ) ; \n length = vsnprintf ( NULL , 0 , name , arg ) ; \n va_end ( arg ) ; \n } else \n length = strlen ( state . current_func -> name ) ; \n if ( length > max_length ) \n max_length = length ; \n } \n }", "idx": 1354}
{"project": "FFmpeg", "commit_id": "7daabccb5d36e9bf649d157ab14ccb2a016f1c53", "target": 0, "func": "void put_signed_pixels_clamped_mmx ( const DCTELEM * block , uint8_t * pixels , int line_size ) \n { \n int i ; \n unsigned char __align8 vector128 [ 8 ] = \n { 0x80 , 0x80 , 0x80 , 0x80 , 0x80 , 0x80 , 0x80 , 0x80 } ; \n movq_m2r ( * vector128 , mm1 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n movq_m2r ( * ( block ) , mm0 ) ; \n packsswb_m2r ( * ( block + 4 ) , mm0 ) ; \n block += 8 ; \n paddb_r2r ( mm1 , mm0 ) ; \n movq_r2m ( mm0 , * pixels ) ; \n pixels += line_size ; \n } \n }", "idx": 1367}
{"project": "FFmpeg", "commit_id": "72732f2dddabae1d943ce617e0a27e32d13416fb", "target": 0, "func": "static int to_integer ( char * p , int len ) \n { \n int ret ; \n char * q = av_malloc ( sizeof ( char ) * len ) ; \n if ( ! q ) return -1 ; \n strncpy ( q , p , len ) ; \n ret = atoi ( q ) ; \n av_free ( q ) ; \n return ret ; \n }", "idx": 1370}
{"project": "FFmpeg", "commit_id": "464a631c34967f4c326b2de8b3cf4903d3e5b01c", "target": 0, "func": "static void opt_video_rc_override_string ( char * arg ) \n { \n video_rc_override_string = arg ; \n }", "idx": 1378}
{"project": "FFmpeg", "commit_id": "b45411e24a7566a1191f9526a4adea0f76e9cb86", "target": 1, "func": "static int eval_refl ( const int16_t * coefs , int * refl , RA144Context * ractx ) \n { \n int retval = 0 ; \n int b , c , i ; \n unsigned int u ; \n int buffer1 [ 10 ] ; \n int buffer2 [ 10 ] ; \n int * bp1 = buffer1 ; \n int * bp2 = buffer2 ; \n for ( i = 0 ; i < 10 ; i ++ ) \n buffer2 [ i ] = coefs [ i ] ; \n u = refl [ 9 ] = bp2 [ 9 ] ; \n if ( u + 0x1000 > 0x1fff ) { \n av_log ( ractx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n for ( c = 8 ; c >= 0 ; c -- ) { \n if ( u == 0x1000 ) \n u ++ ; \n if ( u == 0xfffff000 ) \n u -- ; \n b = 0x1000 - ( ( u * u ) >> 12 ) ; \n if ( b == 0 ) \n b ++ ; \n for ( u = 0 ; u <= c ; u ++ ) \n bp1 [ u ] = ( ( bp2 [ u ] - ( ( refl [ c + 1 ] * bp2 [ c - u ] ) >> 12 ) ) * ( 0x1000000 / b ) ) >> 12 ; \n refl [ c ] = u = bp1 [ c ] ; \n if ( ( u + 0x1000 ) > 0x1fff ) \n retval = 1 ; \n FFSWAP ( int * , bp1 , bp2 ) ; \n } \n return retval ; \n }", "idx": 1391}
{"project": "FFmpeg", "commit_id": "cf48b006400e34e1177d0ca22d1cdb5c900a199a", "target": 1, "func": "static inline int get_ue_code ( GetBitContext * gb , int order ) \n { \n if ( order ) { \n int ret = get_ue_golomb ( gb ) << order ; \n return ret + get_bits ( gb , order ) ; \n } \n return get_ue_golomb ( gb ) ; \n }", "idx": 1393}
{"project": "FFmpeg", "commit_id": "61c6eef5456f2bc8b1dc49a0a759c975551cea29", "target": 1, "func": "int ff_h264_decode_extradata ( H264Context * h ) \n { \n AVCodecContext * avctx = h -> s . avctx ; \n if ( avctx -> extradata [ 0 ] == 1 ) { \n int i , cnt , nalsize ; \n unsigned char * p = avctx -> extradata ; \n h -> is_avc = 1 ; \n if ( avctx -> extradata_size < 7 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n h -> nal_length_size = 2 ; \n cnt = * ( p + 5 ) & 0x1f ; \n p += 6 ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( p - avctx -> extradata + nalsize > avctx -> extradata_size ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n cnt = * ( p ++ ) ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( p - avctx -> extradata + nalsize > avctx -> extradata_size ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n h -> nal_length_size = ( avctx -> extradata [ 4 ] & 0x03 ) + 1 ; \n } else { \n h -> is_avc = 0 ; \n if ( decode_nal_units ( h , avctx -> extradata , avctx -> extradata_size ) < 0 ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 1395}
{"project": "FFmpeg", "commit_id": "709628aa71f24520553eb10b0cf6d56784e6c3ec", "target": 1, "func": "static void process_frame ( AVFilterLink * inlink , AVFilterBufferRef * buf ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ConcatContext * cat = ctx -> priv ; \n unsigned in_no = FF_INLINK_IDX ( inlink ) ; \n if ( in_no < cat -> cur_idx ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n ctx -> input_pads [ in_no ] . name ) ; \n avfilter_unref_buffer ( buf ) ; \n } if ( in_no >= cat -> cur_idx + ctx -> nb_outputs ) { \n ff_bufqueue_add ( ctx , & cat -> in [ in_no ] . queue , buf ) ; \n } else { \n push_frame ( ctx , in_no , buf ) ; \n } \n }", "idx": 1406}
{"project": "FFmpeg", "commit_id": "e45226adc46e513a1bb39ec2b09fb7c77515ab14", "target": 1, "func": "static int make_ydt15_entry ( int p2 , int p1 , int16_t * ydt ) \n #else \n static int make_ydt15_entry ( int p1 , int p2 , int16_t * ydt ) \n #endif \n { \n int lo , hi ; \n lo = ydt [ p1 ] ; \n lo += ( lo * 32 ) + ( lo * 1024 ) ; \n hi = ydt [ p2 ] ; \n hi += ( hi * 32 ) + ( hi * 1024 ) ; \n return ( lo + ( hi * ( 1 << 16 ) ) ) * 2 ; \n }", "idx": 1408}
{"project": "FFmpeg", "commit_id": "38152d9368beb080b4acd6cd9e5ccc89b3f733bf", "target": 1, "func": "static void dss_sp_scale_vector ( int32_t * vec , int bits , int size ) \n { \n int i ; \n if ( bits < 0 ) \n for ( i = 0 ; i < size ; i ++ ) \n vec [ i ] = vec [ i ] >> - bits ; \n else \n for ( i = 0 ; i < size ; i ++ ) \n vec [ i ] = vec [ i ] << bits ; \n }", "idx": 1414}
{"project": "FFmpeg", "commit_id": "b926cc7834d5bc998775528097831c0fbcf3730a", "target": 1, "func": "static void rac_normalise ( RangeCoder * c ) \n { \n for ( ; ; ) { \n c -> range <<= 8 ; \n c -> low <<= 8 ; \n if ( c -> src < c -> src_end ) { \n c -> low |= * c -> src ++ ; \n } else if ( ! c -> low ) { \n c -> got_error = 1 ; \n return ; \n } \n if ( c -> range >= RAC_BOTTOM ) \n return ; \n } \n }", "idx": 1417}
{"project": "FFmpeg", "commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "target": 1, "func": "static int64_t scene_sad16 ( FrameRateContext * s , const uint16_t * p1 , int p1_linesize , const uint16_t * p2 , int p2_linesize , int height ) \n { \n int64_t sad ; \n int x , y ; \n for ( sad = y = 0 ; y < height ; y += 8 ) { \n for ( x = 0 ; x < p1_linesize ; x += 8 ) { \n sad += sad_8x8_16 ( p1 + y * p1_linesize + x , \n p1_linesize , \n p2 + y * p2_linesize + x , \n p2_linesize ) ; \n } \n } \n return sad ; \n }", "idx": 1419}
{"project": "FFmpeg", "commit_id": "417927af3c99bc17819995aa57ae05685deeace8", "target": 1, "func": "static int hds_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n HDSContext * c = s -> priv_data ; \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n OutputStream * os = & c -> streams [ s -> streams [ pkt -> stream_index ] -> id ] ; \n int64_t end_dts = ( os -> fragment_index ) * c -> min_frag_duration ; \n int ret ; \n if ( st -> first_dts == AV_NOPTS_VALUE ) \n st -> first_dts = pkt -> dts ; \n if ( ( ! os -> has_video || st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) && \n av_compare_ts ( pkt -> dts - st -> first_dts , st -> time_base , \n end_dts , AV_TIME_BASE_Q ) >= 0 && \n pkt -> flags & AV_PKT_FLAG_KEY && os -> packets_written ) { \n if ( ( ret = hds_flush ( s , os , 0 , pkt -> dts ) ) < 0 ) \n return ret ; \n } \n if ( ! os -> packets_written ) \n os -> frag_start_ts = pkt -> dts ; \n os -> last_ts = pkt -> dts ; \n os -> packets_written ++ ; \n return ff_write_chained ( os -> ctx , pkt -> stream_index - os -> first_stream , pkt , s ) ; \n }", "idx": 1421}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target , int hasAlpha )  \n { \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n int A1 , A2 ; \n const void * r = c -> table_rV [ V ] , \n * g = ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = c -> table_bU [ U ] ; \n if ( hasAlpha ) { \n A1 = ( abuf0 [ i * 2 ] * yalpha1 + abuf1 [ i * 2 ] * yalpha ) >> 19 ; \n A2 = ( abuf0 [ i * 2 + 1 ] * yalpha1 + abuf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n } \n yuv2rgb_write ( dest , i , Y1 , Y2 , U , V , hasAlpha ? A1 : 0 , hasAlpha ? A2 : 0 , \n r , g , b , y , target , hasAlpha ) ; \n } \n }", "idx": 1424}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += output [ 2 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 3 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 1425}
{"project": "FFmpeg", "commit_id": "dc73c7adc0284871af34100a6062378c07a63569", "target": 0, "func": "static void decode_sigpass ( Jpeg2000T1Context * t1 , int width , int height , \n int bpno , int bandno , int bpass_csty_symbol , \n int vert_causal_ctx_csty_symbol ) \n { \n int mask = 3 << ( bpno - 1 ) , y0 , x , y ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) { \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG_NB ) \n && ! ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) ) { \n int flags_mask = -1 ; \n if ( vert_causal_ctx_csty_symbol && y == y0 + 3 ) \n flags_mask &= ~ ( JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE ) ; \n if ( ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ff_jpeg2000_getsigctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] & flags_mask , bandno ) ) ) { \n int xorbit , ctxno = ff_jpeg2000_getsgnctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , & xorbit ) ; \n if ( bpass_csty_symbol ) \n t1 -> data [ y ] [ x ] = ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno ) ? - mask : mask ; \n else \n t1 -> data [ y ] [ x ] = ( ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno ) ^ xorbit ) ? \n - mask : mask ; \n ff_jpeg2000_set_significance ( t1 , x , y , \n t1 -> data [ y ] [ x ] < 0 ) ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_VIS ; \n } \n } \n }", "idx": 1427}
{"project": "FFmpeg", "commit_id": "d9cdb7d8d6d828bb5497ea3f0fd7edd2f3f6cc30", "target": 0, "func": "static av_cold int pcm_dvd_decode_init ( AVCodecContext * avctx ) \n { \n PCMDVDContext * s = avctx -> priv_data ; \n s -> last_header = -1 ; \n if ( ! ( s -> extra_samples = av_malloc ( 8 * 3 * 4 ) ) ) \n return AVERROR ( ENOMEM ) ; \n s -> extra_sample_count = 0 ; \n return 0 ; \n }", "idx": 1429}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_v_lpf_chroma_inter_msa ( uint8_t * data , int img_width , \n int alpha , int beta , int8_t * tc ) \n { \n uint8_t bs0 = 1 ; \n uint8_t bs1 = 1 ; \n uint8_t bs2 = 1 ; \n uint8_t bs3 = 1 ; \n if ( tc [ 0 ] < 0 ) \n bs0 = 0 ; \n if ( tc [ 1 ] < 0 ) \n bs1 = 0 ; \n if ( tc [ 2 ] < 0 ) \n bs2 = 0 ; \n if ( tc [ 3 ] < 0 ) \n bs3 = 0 ; \n avc_loopfilter_cb_or_cr_inter_edge_hor_msa ( data , \n bs0 , bs1 , bs2 , bs3 , \n tc [ 0 ] , tc [ 1 ] , tc [ 2 ] , tc [ 3 ] , \n alpha , beta , \n img_width ) ; \n }", "idx": 1430}
{"project": "FFmpeg", "commit_id": "b2bbe8298ba5416f26ffadb43f9e75997ec02f7f", "target": 1, "func": "static int dss_read_metadata_date ( AVFormatContext * s , unsigned int offset , \n const char * key ) \n { \n AVIOContext * pb = s -> pb ; \n char datetime [ 64 ] , string [ DSS_TIME_SIZE + 1 ] = { 0 } ; \n int y , month , d , h , minute , sec ; \n int ret ; \n avio_seek ( pb , offset , SEEK_SET ) ; \n ret = avio_read ( s -> pb , string , DSS_TIME_SIZE ) ; \n if ( ret < DSS_TIME_SIZE ) \n return ret < 0 ? ret : AVERROR_EOF ; \n sscanf ( string , \" \" , & y , & month , & d , & h , & minute , & sec ) ; \n snprintf ( datetime , sizeof ( datetime ) , \" \" , \n y + 2000 , month , d , h , minute , sec ) ; \n return av_dict_set ( & s -> metadata , key , datetime , 0 ) ; \n }", "idx": 1433}
{"project": "FFmpeg", "commit_id": "d2bf42895ac30d228491a8a95a5908351dc32783", "target": 0, "func": "static void FUNCC ( pred8x8l_horizontal ) ( uint8_t * _src , int has_topleft , int has_topright , int _stride ) \n { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n PREDICT_8x8_LOAD_LEFT ; \n #define ROW ( y )  ((pixel4*)(src+y*stride))[0] =\\ \n   \n  ( ( pixel4 * ) ( src + y * stride ) ) [ 1 ] = PIXEL_SPLAT_X4 ( l # #y )  \n ROW ( 0 ) ; ROW ( 1 ) ; ROW ( 2 ) ; ROW ( 3 ) ; ROW ( 4 ) ; ROW ( 5 ) ; ROW ( 6 ) ; ROW ( 7 ) ; \n #undef  ROW  \n  \n  }", "idx": 1442}
{"project": "FFmpeg", "commit_id": "eb5b0422b595d488f5c2f2a37a62cd46dfbb6aa7", "target": 0, "func": "static int g726_init ( AVCodecContext * avctx ) \n { \n AVG726Context * c = ( AVG726Context * ) avctx -> priv_data ; \n if ( avctx -> sample_rate != 8000 || avctx -> channels != 1 || \n ( avctx -> bit_rate != 16000 && avctx -> bit_rate != 24000 && \n avctx -> bit_rate != 32000 && avctx -> bit_rate != 40000 ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n g726_reset ( & c -> c , avctx -> bit_rate ) ; \n c -> code_size = c -> c . tbls -> bits ; \n c -> bit_buffer = 0 ; \n c -> bits_left = 0 ; \n return 0 ; \n }", "idx": 1443}
{"project": "FFmpeg", "commit_id": "ded5957d75def70d2f1fc1c1eae079230004974b", "target": 0, "func": "static int film_read_close ( AVFormatContext * s ) \n { \n FilmDemuxContext * film = s -> priv_data ; \n av_freep ( & film -> sample_table ) ; \n av_freep ( & film -> stereo_buffer ) ; \n return 0 ; \n }", "idx": 1449}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int png_enc_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 1450}
{"project": "FFmpeg", "commit_id": "f1cd9b03f3fa875eb5e394281b4b688cec611658", "target": 1, "func": "static av_cold int omx_try_load ( OMXContext * s , void * logctx , \n const char * libname , const char * prefix ) \n { \n s -> lib = dlopen ( libname , RTLD_NOW | RTLD_GLOBAL ) ; \n if ( ! s -> lib ) { \n av_log ( logctx , AV_LOG_WARNING , \" \\n \" , libname ) ; \n return AVERROR_ENCODER_NOT_FOUND ; \n } \n s -> ptr_Init = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_Deinit = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_ComponentNameEnum = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_GetHandle = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_FreeHandle = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_GetComponentsOfRole = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n s -> ptr_GetRolesOfComponent = dlsym_prefixed ( s -> lib , \" \" , prefix ) ; \n if ( ! s -> ptr_Init || ! s -> ptr_Deinit || ! s -> ptr_ComponentNameEnum || \n ! s -> ptr_GetHandle || ! s -> ptr_FreeHandle || \n ! s -> ptr_GetComponentsOfRole || ! s -> ptr_GetRolesOfComponent ) { \n av_log ( logctx , AV_LOG_WARNING , \" \\n \" , libname ) ; \n dlclose ( s -> lib ) ; \n s -> lib = NULL ; \n return AVERROR_ENCODER_NOT_FOUND ; \n } \n return 0 ; \n }", "idx": 1458}
{"project": "FFmpeg", "commit_id": "24fee95321c1463360ba7042d026dae021854360", "target": 1, "func": "static int handle_metadata ( RTMPContext * rt , RTMPPacket * pkt ) \n { \n int ret , old_flv_size , type ; \n const uint8_t * next ; \n uint8_t * p ; \n uint32_t size ; \n uint32_t ts , cts , pts = 0 ; \n old_flv_size = update_offset ( rt , pkt -> size ) ; \n if ( ( ret = av_reallocp ( & rt -> flv_data , rt -> flv_size ) ) < 0 ) { \n rt -> flv_size = rt -> flv_off = 0 ; \n return ret ; \n } \n next = pkt -> data ; \n p = rt -> flv_data + old_flv_size ; \n ts = pkt -> timestamp ; \n while ( next - pkt -> data < pkt -> size - RTMP_HEADER ) { \n type = bytestream_get_byte ( & next ) ; \n size = bytestream_get_be24 ( & next ) ; \n cts = bytestream_get_be24 ( & next ) ; \n cts |= bytestream_get_byte ( & next ) << 24 ; \n if ( ! pts ) \n pts = cts ; \n ts += cts - pts ; \n pts = cts ; \n bytestream_put_byte ( & p , type ) ; \n bytestream_put_be24 ( & p , size ) ; \n bytestream_put_be24 ( & p , ts ) ; \n bytestream_put_byte ( & p , ts >> 24 ) ; \n memcpy ( p , next , size + 3 + 4 ) ; \n next += size + 3 + 4 ; \n p += size + 3 + 4 ; \n } \n memcpy ( p , next , RTMP_HEADER ) ; \n return 0 ; \n }", "idx": 1467}
{"project": "FFmpeg", "commit_id": "783b350b2e49d06030b30ee9b7e1aa5825e4a5a5", "target": 1, "func": "static av_cold int decode_close_mp3on4 ( AVCodecContext * avctx ) \n { \n MP3On4DecodeContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> frames ; i ++ ) \n av_freep ( & s -> mp3decctx [ i ] ) ; \n return 0 ; \n }", "idx": 1475}
{"project": "FFmpeg", "commit_id": "6d9e74cd4179f42a8fa860f2e08d370c7c36325f", "target": 1, "func": "static inline void encode_vlc_codeword ( PutBitContext * pb , unsigned codebook , int val ) \n { \n unsigned int rice_order , exp_order , switch_bits , switch_val ; \n int exponent ; \n switch_bits = ( codebook & 3 ) + 1 ; \n rice_order = codebook >> 5 ; \n exp_order = ( codebook >> 2 ) & 7 ; \n switch_val = switch_bits << rice_order ; \n if ( val >= switch_val ) { \n val -= switch_val - ( 1 << exp_order ) ; \n exponent = av_log2 ( val ) ; \n put_bits ( pb , exponent - exp_order + switch_bits , 0 ) ; \n put_bits ( pb , 1 , 1 ) ; \n put_bits ( pb , exponent , val ) ; \n } else { \n exponent = val >> rice_order ; \n if ( exponent ) \n put_bits ( pb , exponent , 0 ) ; \n put_bits ( pb , 1 , 1 ) ; \n if ( rice_order ) \n put_sbits ( pb , rice_order , val ) ; \n } \n }", "idx": 1477}
{"project": "FFmpeg", "commit_id": "e2ad0b66fa273c5c823978e8f601f2c0d9ee42f8", "target": 0, "func": "int avpicture_get_size ( enum AVPixelFormat pix_fmt , int width , int height ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n AVPicture dummy_pict ; \n int ret ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( width , height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( desc -> flags & AV_PIX_FMT_FLAG_PSEUDOPAL ) \n return width * height ; \n return avpicture_fill ( & dummy_pict , NULL , pix_fmt , width , height ) ; \n }", "idx": 1495}
{"project": "FFmpeg", "commit_id": "6086731299e4d249ddc459e406b2ebb0cb71f6f4", "target": 1, "func": "static int unpack_block_qpis ( Vp3DecodeContext * s , GetBitContext * gb ) \n { \n int qpi , i , j , bit , run_length , blocks_decoded , num_blocks_at_qpi ; \n int num_blocks = s -> total_num_coded_frags ; \n for ( qpi = 0 ; qpi < s -> nqps - 1 && num_blocks > 0 ; qpi ++ ) { \n i = blocks_decoded = num_blocks_at_qpi = 0 ; \n bit = get_bits1 ( gb ) ; \n do { \n run_length = get_vlc2 ( gb , s -> superblock_run_length_vlc . table , 6 , 2 ) + 1 ; \n if ( run_length == 34 ) \n run_length += get_bits ( gb , 12 ) ; \n blocks_decoded += run_length ; \n if ( ! bit ) \n num_blocks_at_qpi += run_length ; \n for ( j = 0 ; j < run_length ; i ++ ) { \n if ( i >= s -> total_num_coded_frags ) \n return -1 ; \n if ( s -> all_fragments [ s -> coded_fragment_list [ 0 ] [ i ] ] . qpi == qpi ) { \n s -> all_fragments [ s -> coded_fragment_list [ 0 ] [ i ] ] . qpi += bit ; \n j ++ ; \n } \n } \n if ( run_length == MAXIMUM_LONG_BIT_RUN ) \n bit = get_bits1 ( gb ) ; \n else \n bit ^= 1 ; \n } while ( blocks_decoded < num_blocks ) ; \n num_blocks -= num_blocks_at_qpi ; \n } \n return 0 ; \n }", "idx": 1506}
{"project": "FFmpeg", "commit_id": "aa06658248a49f6ebf381894b9426cdfb377cd32", "target": 1, "func": "static int dvvideo_encode_frame ( AVCodecContext * c , uint8_t * buf , int buf_size , \n void * data ) \n { \n DVVideoContext * s = c -> priv_data ; \n s -> sys = dv_codec_profile ( c ) ; \n if ( ! s -> sys ) \n return -1 ; \n if ( buf_size < s -> sys -> frame_size ) \n return -1 ; \n c -> pix_fmt = s -> sys -> pix_fmt ; \n s -> picture = * ( ( AVFrame * ) data ) ; \n s -> picture . key_frame = 1 ; \n s -> picture . pict_type = FF_I_TYPE ; \n s -> buf = buf ; \n c -> execute ( c , dv_encode_mt , ( void * * ) & s -> dv_anchor [ 0 ] , NULL , \n s -> sys -> difseg_size * 27 ) ; \n emms_c ( ) ; \n return s -> sys -> frame_size ; \n }", "idx": 1514}
{"project": "FFmpeg", "commit_id": "852859ff7cd29a926a9a7e811d77192b61a6956e", "target": 1, "func": "static int mov_read_esds ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n int tag , len ; \n get_be32 ( pb ) ; \n len = mp4_read_descr ( c , pb , & tag ) ; \n if ( tag == MP4ESDescrTag ) { \n get_be16 ( pb ) ; \n get_byte ( pb ) ; \n } else \n get_be16 ( pb ) ; \n len = mp4_read_descr ( c , pb , & tag ) ; \n if ( tag == MP4DecConfigDescrTag ) { \n int object_type_id = get_byte ( pb ) ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n st -> codec -> codec_id = codec_get_id ( ff_mp4_obj_type , object_type_id ) ; \n dprintf ( c -> fc , \" \\n \" , object_type_id ) ; \n len = mp4_read_descr ( c , pb , & tag ) ; \n if ( tag == MP4DecSpecificDescrTag ) { \n dprintf ( c -> fc , \" \\n \" , len ) ; \n st -> codec -> extradata = av_mallocz ( len + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n get_buffer ( pb , st -> codec -> extradata , len ) ; \n st -> codec -> extradata_size = len ; \n if ( ( * st -> codec -> extradata >> 3 ) == 29 ) { \n st -> codec -> codec_id = CODEC_ID_MP3ON4 ; \n } \n } \n } \n return 0 ; \n }", "idx": 1515}
{"project": "FFmpeg", "commit_id": "5d31f03a0264cac24434c8108daef4ccba6d28f9", "target": 1, "func": "static void decode_lpc ( int32_t * coeffs , int mode , int length ) \n { \n int i ; \n if ( length < 2 ) \n return ; \n if ( mode == 1 ) { \n unsigned a1 = * coeffs ++ ; \n for ( i = 0 ; i < length - 1 >> 1 ; i ++ ) { \n * coeffs += a1 ; \n coeffs [ 1 ] += * coeffs ; \n a1 = coeffs [ 1 ] ; \n coeffs += 2 ; \n } \n if ( length - 1 & 1 ) \n * coeffs += a1 ; \n } else if ( mode == 2 ) { \n unsigned a1 = coeffs [ 1 ] ; \n unsigned a2 = a1 + * coeffs ; \n coeffs [ 1 ] = a2 ; \n if ( length > 2 ) { \n coeffs += 2 ; \n for ( i = 0 ; i < length - 2 >> 1 ; i ++ ) { \n unsigned a3 = * coeffs + a1 ; \n unsigned a4 = a3 + a2 ; \n * coeffs = a4 ; \n a1 = coeffs [ 1 ] + a3 ; \n a2 = a1 + a4 ; \n coeffs [ 1 ] = a2 ; \n coeffs += 2 ; \n } \n if ( length & 1 ) \n * coeffs += a1 + a2 ; \n } \n } else if ( mode == 3 ) { \n unsigned a1 = coeffs [ 1 ] ; \n unsigned a2 = a1 + * coeffs ; \n coeffs [ 1 ] = a2 ; \n if ( length > 2 ) { \n unsigned a3 = coeffs [ 2 ] ; \n unsigned a4 = a3 + a1 ; \n unsigned a5 = a4 + a2 ; \n coeffs [ 2 ] = a5 ; \n coeffs += 3 ; \n for ( i = 0 ; i < length - 3 ; i ++ ) { \n a3 += * coeffs ; \n a4 += a3 ; \n a5 += a4 ; \n * coeffs = a5 ; \n coeffs ++ ; \n } \n } \n } \n }", "idx": 1520}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_init ( void ) \n { \n #ifndef __MINGW32__ \n struct termios tty ; \n tcgetattr ( 0 , & tty ) ; \n oldtty = tty ; \n tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP \n | INLCR | IGNCR | ICRNL | IXON ) ; \n tty . c_oflag |= OPOST ; \n tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; \n tty . c_cflag &= ~ ( CSIZE | PARENB ) ; \n tty . c_cflag |= CS8 ; \n tty . c_cc [ VMIN ] = 1 ; \n tty . c_cc [ VTIME ] = 0 ; \n tcsetattr ( 0 , TCSANOW , & tty ) ; \n signal ( SIGQUIT , sigterm_handler ) ; \n #endif \n signal ( SIGINT , sigterm_handler ) ; \n signal ( SIGTERM , sigterm_handler ) ; \n atexit ( term_exit ) ; \n #ifdef CONFIG_BEOS_NETSERVER \n fcntl ( 0 , F_SETFL , fcntl ( 0 , F_GETFL ) | O_NONBLOCK ) ; \n #endif \n }", "idx": 1521}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To19_c ( SwsContext * c , int16_t * _dst , int dstW , const uint8_t * src , \n const int16_t * filter , const int16_t * filterPos , \n int filterSize ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> 3 , ( 1 << 19 ) - 1 ) ; \n } \n }", "idx": 1527}
{"project": "FFmpeg", "commit_id": "5ef19590802f000299e418143fc2301e3f43affe", "target": 1, "func": "int show_bsfs ( void * optctx , const char * opt , const char * arg ) \n { \n AVBitStreamFilter * bsf = NULL ; \n printf ( \" \\n \" ) ; \n while ( ( bsf = av_bitstream_filter_next ( bsf ) ) ) \n printf ( \" \\n \" , bsf -> name ) ; \n printf ( \" \\n \" ) ; \n return 0 ; \n }", "idx": 1530}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char * seq_decode_op2 ( SeqVideoContext * seq , const unsigned char * src , unsigned char * dst ) \n { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n memcpy ( dst , src , 8 ) ; \n src += 8 ; \n dst += seq -> frame . linesize [ 0 ] ; \n } \n return src ; \n }", "idx": 1535}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel8_mc20_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_8w_msa ( src - 2 , stride , dst , stride , 8 ) ; \n }", "idx": 1538}
{"project": "FFmpeg", "commit_id": "aeb23fc4549a25ef32ff085d2a76227f90caf403", "target": 0, "func": "static void ini_print_object_header ( const char * name ) \n { \n int i ; \n PrintElement * el = octx . prefix + octx . level - 1 ; \n if ( el -> nb_elems ) \n avio_printf ( probe_out , \" \\n \" ) ; \n avio_printf ( probe_out , \" \" ) ; \n for ( i = 1 ; i < octx . level ; i ++ ) { \n el = octx . prefix + i ; \n avio_printf ( probe_out , \" \" , el -> name ) ; \n if ( el -> index >= 0 ) \n avio_printf ( probe_out , \" \" PRId64 \" \" , el -> index ) ; \n } \n avio_printf ( probe_out , \" \" , name ) ; \n if ( el && el -> type == ARRAY ) \n avio_printf ( probe_out , \" \" PRId64 \" \" , el -> nb_elems ) ; \n avio_printf ( probe_out , \" \\n \" ) ; \n }", "idx": 1539}
{"project": "FFmpeg", "commit_id": "0f87b42b44f8da7234e8e43b27d1dc5e4dce7582", "target": 0, "func": "int avformat_queue_attached_pictures ( AVFormatContext * s ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n if ( s -> streams [ i ] -> disposition & AV_DISPOSITION_ATTACHED_PIC && \n s -> streams [ i ] -> discard < AVDISCARD_ALL ) { \n AVPacket copy = s -> streams [ i ] -> attached_pic ; \n if ( copy . size <= 0 ) \n return AVERROR ( EINVAL ) ; \n copy . buf = av_buffer_ref ( copy . buf ) ; \n if ( ! copy . buf ) \n return AVERROR ( ENOMEM ) ; \n add_to_pktbuf ( & s -> raw_packet_buffer , & copy , \n & s -> raw_packet_buffer_end ) ; \n } \n return 0 ; \n }", "idx": 1541}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_dualmono_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += output [ 2 ] [ i ] ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n }", "idx": 1542}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src + stride - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 1549}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "static int64_t truehd_layout ( int chanmap ) \n { \n int layout = 0 , i ; \n for ( i = 0 ; i < 13 ; i ++ ) \n layout |= thd_layout [ i ] * ( ( chanmap >> i ) & 1 ) ; \n return layout ; \n }", "idx": 1580}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "static int check_jni_invocation ( void * log_ctx ) \n { \n int ret = AVERROR_EXTERNAL ; \n void * handle = NULL ; \n void * * jni_invocation = NULL ; \n handle = dlopen ( NULL , RTLD_LOCAL ) ; \n if ( ! handle ) { \n goto done ; \n } \n jni_invocation = ( void * * ) dlsym ( handle , \" \" ) ; \n if ( ! jni_invocation ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto done ; \n } \n ret = ! ( jni_invocation != NULL && * jni_invocation != NULL ) ; \n done : \n if ( handle ) { \n dlclose ( handle ) ; \n } \n return ret ; \n }", "idx": 1583}
{"project": "FFmpeg", "commit_id": "c33030bd7b81f7ef7d7ff9da9bfa1a3b4bfbafa1", "target": 0, "func": "static int gif_image_write_header ( uint8_t * * bytestream , \n int width , int height , int loop_count , \n uint32_t * palette ) \n { \n int i ; \n unsigned int v ; \n bytestream_put_buffer ( bytestream , \" \" , 3 ) ; \n bytestream_put_buffer ( bytestream , \" \" , 3 ) ; \n bytestream_put_le16 ( bytestream , width ) ; \n bytestream_put_le16 ( bytestream , height ) ; \n bytestream_put_byte ( bytestream , 0xf7 ) ; \n bytestream_put_byte ( bytestream , 0x1f ) ; \n bytestream_put_byte ( bytestream , 0 ) ; \n if ( ! palette ) { \n bytestream_put_buffer ( bytestream , ( const unsigned char * ) gif_clut , 216 * 3 ) ; \n for ( i = 0 ; i < ( ( 256 - 216 ) * 3 ) ; i ++ ) \n bytestream_put_byte ( bytestream , 0 ) ; \n } else { \n for ( i = 0 ; i < 256 ; i ++ ) { \n v = palette [ i ] ; \n bytestream_put_be24 ( bytestream , v ) ; \n } \n } \n #ifdef GIF_ADD_APP_HEADER \n if ( loop_count >= 0 && loop_count <= 65535 ) { \n bytestream_put_byte ( bytestream , 0x21 ) ; \n bytestream_put_byte ( bytestream , 0xff ) ; \n bytestream_put_byte ( bytestream , 0x0b ) ; \n bytestream_put_buffer ( bytestream , \" \" , 11 ) ; \n bytestream_put_byte ( bytestream , 0x03 ) ; \n bytestream_put_byte ( bytestream , 0x01 ) ; \n bytestream_put_le16 ( bytestream , ( uint16_t ) loop_count ) ; \n bytestream_put_byte ( bytestream , 0x00 ) ; \n } \n #endif \n return 0 ; \n }", "idx": 1584}
{"project": "FFmpeg", "commit_id": "11ca3416f92744f376c08e5f31bcbe5d9b44acb2", "target": 1, "func": "static int v410_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , AVPacket * avpkt ) \n { \n AVFrame * pic = avctx -> coded_frame ; \n uint8_t * src = avpkt -> data ; \n uint16_t * y , * u , * v ; \n uint32_t val ; \n int i , j ; \n if ( pic -> data [ 0 ] ) \n avctx -> release_buffer ( avctx , pic ) ; \n pic -> reference = 0 ; \n if ( avctx -> get_buffer ( avctx , pic ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n pic -> key_frame = 1 ; \n pic -> pict_type = FF_I_TYPE ; \n y = ( uint16_t * ) pic -> data [ 0 ] ; \n u = ( uint16_t * ) pic -> data [ 1 ] ; \n v = ( uint16_t * ) pic -> data [ 2 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n for ( j = 0 ; j < avctx -> width ; j ++ ) { \n val = AV_RL32 ( src ) ; \n u [ j ] = ( val >> 2 ) & 0x3FF ; \n y [ j ] = ( val >> 12 ) & 0x3FF ; \n v [ j ] = ( val >> 22 ) ; \n src += 4 ; \n y += pic -> linesize [ 0 ] >> 1 ; \n u += pic -> linesize [ 1 ] >> 1 ; \n v += pic -> linesize [ 2 ] >> 1 ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = * pic ; \n return avpkt -> size ;", "idx": 1590}
{"project": "FFmpeg", "commit_id": "33d7f822f8ed2d1870babc1d04d4d48cf8b6f240", "target": 1, "func": "static void adaptive_gain_control ( float * out , const float * in , \n const float * speech_synth , \n int size , float alpha , float * gain_mem ) \n { \n int i ; \n float speech_energy = 0.0 , postfilter_energy = 0.0 , gain_scale_factor ; \n float mem = * gain_mem ; \n for ( i = 0 ; i < size ; i ++ ) { \n speech_energy += fabsf ( speech_synth [ i ] ) ; \n postfilter_energy += fabsf ( in [ i ] ) ; \n } \n gain_scale_factor = ( 1.0 - alpha ) * speech_energy / postfilter_energy ; \n for ( i = 0 ; i < size ; i ++ ) { \n mem = alpha * mem + gain_scale_factor ; \n out [ i ] = in [ i ] * mem ; \n } \n * gain_mem = mem ; \n }", "idx": 1592}
{"project": "FFmpeg", "commit_id": "0181b202cc42133eacd74bad33745cf1ba699e6b", "target": 1, "func": "static void ps_add_squares_c ( INTFLOAT * dst , const INTFLOAT ( * src ) [ 2 ] , int n ) \n { \n int i ; \n for ( i = 0 ; i < n ; i ++ ) \n dst [ i ] += AAC_MADD28 ( src [ i ] [ 0 ] , src [ i ] [ 0 ] , src [ i ] [ 1 ] , src [ i ] [ 1 ] ) ; \n }", "idx": 1594}
{"project": "FFmpeg", "commit_id": "3b77e48f0a4b6d660cd7eb14cd56f93fcb426ae2", "target": 0, "func": "static int h264_parse ( AVCodecParserContext * s , \n AVCodecContext * avctx , \n uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n H264Context * h = s -> priv_data ; \n ParseContext * pc = & h -> s . parse_context ; \n int next ; \n if ( s -> flags & PARSER_FLAG_COMPLETE_FRAMES ) { \n next = buf_size ; \n } else { \n next = find_frame_end ( h , buf , buf_size ) ; \n if ( ff_combine_frame ( pc , next , ( uint8_t * * ) & buf , & buf_size ) < 0 ) { \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n } \n if ( next < 0 ) { \n find_frame_end ( h , & pc -> buffer [ pc -> last_index + next ] , - next ) ; \n } \n } \n * poutbuf = ( uint8_t * ) buf ; \n * poutbuf_size = buf_size ; \n return next ; \n }", "idx": 1631}
{"project": "FFmpeg", "commit_id": "6ad45600313f0df1abf31abdd28f4339dbdc7ca0", "target": 1, "func": "static int decode_pivot ( MSS1Context * ctx , ArithCoder * acoder , int base ) \n { \n int val , inv ; \n inv = arith_get_model_sym ( acoder , & ctx -> edge_mode ) ; \n val = arith_get_model_sym ( acoder , & ctx -> pivot ) + 1 ; \n if ( val > 2 ) { \n if ( ( base + 1 ) / 2 - 2 <= 0 ) { \n ctx -> corrupted = 1 ; \n return 0 ; \n } \n val = arith_get_number ( acoder , ( base + 1 ) / 2 - 2 ) + 3 ; \n } \n if ( val == base ) { \n ctx -> corrupted = 1 ; \n return 0 ; \n } \n return inv ? base - val : val ; \n }", "idx": 1636}
{"project": "FFmpeg", "commit_id": "ebcf7c3227906382205141beb2d0467f245472d1", "target": 1, "func": "int ff_cmap_read_palette ( AVCodecContext * avctx , uint32_t * pal ) \n { \n int count , i ; \n if ( avctx -> bits_per_coded_sample > 8 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n count = 1 << avctx -> bits_per_coded_sample ; \n if ( avctx -> extradata_size < count * 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < count ; i ++ ) { \n pal [ i ] = 0xFF000000 | AV_RB24 ( avctx -> extradata + i * 3 ) ; \n } \n return 0 ; \n }", "idx": 1645}
{"project": "FFmpeg", "commit_id": "5a8311513091ea7277578fbaf189e460dd1d4c7d", "target": 1, "func": "av_cold int ffv1_init_slice_contexts ( FFV1Context * f ) \n { \n int i ; \n f -> slice_count = f -> num_h_slices * f -> num_v_slices ; \n av_assert0 ( f -> slice_count > 0 ) ; \n for ( i = 0 ; i < f -> slice_count ; i ++ ) { \n FFV1Context * fs = av_mallocz ( sizeof ( * fs ) ) ; \n int sx = i % f -> num_h_slices ; \n int sy = i / f -> num_h_slices ; \n int sxs = f -> avctx -> width * sx / f -> num_h_slices ; \n int sxe = f -> avctx -> width * ( sx + 1 ) / f -> num_h_slices ; \n int sys = f -> avctx -> height * sy / f -> num_v_slices ; \n int sye = f -> avctx -> height * ( sy + 1 ) / f -> num_v_slices ; \n f -> slice_context [ i ] = fs ; \n memcpy ( fs , f , sizeof ( * fs ) ) ; \n memset ( fs -> rc_stat2 , 0 , sizeof ( fs -> rc_stat2 ) ) ; \n fs -> slice_width = sxe - sxs ; \n fs -> slice_height = sye - sys ; \n fs -> slice_x = sxs ; \n fs -> slice_y = sys ; \n fs -> sample_buffer = av_malloc ( 3 * MAX_PLANES * ( fs -> width + 6 ) * \n sizeof ( * fs -> sample_buffer ) ) ; \n if ( ! fs -> sample_buffer )  \n } \n return 0 ; \n }", "idx": 1650}
{"project": "FFmpeg", "commit_id": "06bb1de1c78a3653e197ff3434d550499b556e72", "target": 1, "func": "static int vqf_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n VqfContext * c = s -> priv_data ; \n int ret ; \n int size = ( c -> frame_bit_len - c -> remaining_bits + 7 ) >> 3 ; \n if ( av_new_packet ( pkt , size + 2 ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> pos = avio_tell ( s -> pb ) ; \n pkt -> stream_index = 0 ; \n pkt -> duration = 1 ; \n pkt -> data [ 0 ] = 8 - c -> remaining_bits ; \n pkt -> data [ 1 ] = c -> last_frame_bits ; \n ret = avio_read ( s -> pb , pkt -> data + 2 , size ) ; \n if ( ret <= 0 ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n c -> last_frame_bits = pkt -> data [ size + 1 ] ; \n c -> remaining_bits = ( size << 3 ) - c -> frame_bit_len + c -> remaining_bits ; \n return size + 2 ; \n }", "idx": 1652}
{"project": "FFmpeg", "commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "target": 1, "func": "av_cold void ff_fmt_convert_init_arm ( FmtConvertContext * c , AVCodecContext * avctx ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_vfp ( cpu_flags ) ) { \n if ( ! have_vfpv3 ( cpu_flags ) ) { \n c -> int32_to_float_fmul_scalar = ff_int32_to_float_fmul_scalar_vfp ; \n c -> int32_to_float_fmul_array8 = ff_int32_to_float_fmul_array8_vfp ; \n } \n } \n if ( have_neon ( cpu_flags ) ) { \n c -> int32_to_float_fmul_scalar = ff_int32_to_float_fmul_scalar_neon ; \n } \n }", "idx": 1654}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( hyscale ) ( SwsContext * c , uint16_t * dst , long dstWidth , const uint8_t * src , int srcW , int xInc , \n const int16_t * hLumFilter , \n const int16_t * hLumFilterPos , int hLumFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal , int isAlpha ) \n { \n void ( * toYV12 ) ( uint8_t * , const uint8_t * , long , uint32_t * ) = isAlpha ? c -> alpToYV12 : c -> lumToYV12 ; \n void ( * convertRange ) ( int16_t * , int ) = isAlpha ? NULL : c -> lumConvertRange ; \n src += isAlpha ? c -> alpSrcOffset : c -> lumSrcOffset ; \n if ( toYV12 ) { \n toYV12 ( formatConvBuffer , src , srcW , pal ) ; \n src = formatConvBuffer ; \n } \n if ( c -> hScale16 ) { \n c -> hScale16 ( dst , dstWidth , ( uint16_t * ) src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; \n } else if ( ! c -> hyscale_fast ) { \n c -> hScale ( dst , dstWidth , src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize ) ; \n } else { \n c -> hyscale_fast ( c , dst , dstWidth , src , srcW , xInc ) ; \n } \n if ( convertRange ) \n convertRange ( dst , dstWidth ) ; \n }", "idx": 1655}
{"project": "FFmpeg", "commit_id": "5c3383e5b5c7e3e3c1ba86a58d3e0a1ebf521aa7", "target": 0, "func": "int opt_default ( const char * opt , const char * arg ) { \n int type ; \n const AVOption * o = NULL ; \n int opt_types [ ] = { AV_OPT_FLAG_VIDEO_PARAM , AV_OPT_FLAG_AUDIO_PARAM , 0 , AV_OPT_FLAG_SUBTITLE_PARAM , 0 } ; \n for ( type = 0 ; type < CODEC_TYPE_NB ; type ++ ) { \n const AVOption * o2 = av_find_opt ( avctx_opts [ 0 ] , opt , NULL , opt_types [ type ] , opt_types [ type ] ) ; \n if ( o2 ) \n o = av_set_string2 ( avctx_opts [ type ] , opt , arg , 1 ) ; \n } \n if ( ! o ) \n o = av_set_string2 ( avformat_opts , opt , arg , 1 ) ; \n if ( ! o ) \n o = av_set_string2 ( sws_opts , opt , arg , 1 ) ; \n if ( ! o ) { \n if ( opt [ 0 ] == ' ' ) \n o = av_set_string2 ( avctx_opts [ CODEC_TYPE_AUDIO ] , opt + 1 , arg , 1 ) ; \n else if ( opt [ 0 ] == ' ' ) \n o = av_set_string2 ( avctx_opts [ CODEC_TYPE_VIDEO ] , opt + 1 , arg , 1 ) ; \n else if ( opt [ 0 ] == ' ' ) \n o = av_set_string2 ( avctx_opts [ CODEC_TYPE_SUBTITLE ] , opt + 1 , arg , 1 ) ; \n } \n if ( ! o ) \n return -1 ; \n opt_names = av_realloc ( opt_names , sizeof ( void * ) * ( opt_name_count + 1 ) ) ; \n opt_names [ opt_name_count ++ ] = o -> name ; \n if ( avctx_opts [ 0 ] -> debug || avformat_opts -> debug ) \n av_log_set_level ( AV_LOG_DEBUG ) ; \n return 0 ; \n }", "idx": 1658}
{"project": "FFmpeg", "commit_id": "6ed3565f08abf3b1c2a1d2d7fac768b18753530c", "target": 1, "func": "static av_cold int v410_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = PIX_FMT_YUV444P10 ; \n avctx -> bits_per_raw_sample = 10 ; \n if ( avctx -> width & 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n if ( ! avctx -> coded_frame ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 1663}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_dvc1 ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n uint8_t profile_level ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( atom . size >= ( 1 << 28 ) || atom . size < 7 ) \n return AVERROR_INVALIDDATA ; \n profile_level = avio_r8 ( pb ) ; \n if ( ( profile_level & 0xf0 ) != 0xc0 ) \n return 0 ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size - 7 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size - 7 ; \n avio_seek ( pb , 6 , SEEK_CUR ) ; \n avio_read ( pb , st -> codec -> extradata , st -> codec -> extradata_size ) ; \n return 0 ; \n }", "idx": 1666}
{"project": "FFmpeg", "commit_id": "f0f2babca23a3d099bcd5a1e18cf5d0eae2f4ef3", "target": 0, "func": "static void zero_remaining ( unsigned int b , unsigned int b_max , \n const unsigned int * div_blocks , int32_t * buf ) \n { \n unsigned int count = 0 ; \n while ( b < b_max ) \n count += div_blocks [ b ] ; \n if ( count ) \n memset ( buf , 0 , sizeof ( * buf ) * count ) ; \n }", "idx": 1667}
{"project": "FFmpeg", "commit_id": "645f7c1ce547f247af56990e6306d08d3d6a6286", "target": 1, "func": "static int push_samples ( AVFilterContext * ctx , int nb_samples ) \n { \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n LoopContext * s = ctx -> priv ; \n AVFrame * out ; \n int ret , i = 0 ; \n while ( s -> loop != 0 && i < nb_samples ) { \n out = ff_get_audio_buffer ( outlink , FFMIN ( nb_samples , s -> nb_samples - s -> current_sample ) ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n ret = av_audio_fifo_peek_at ( s -> fifo , ( void * * ) out -> extended_data , out -> nb_samples , s -> current_sample ) ; \n if ( ret < 0 ) \n return ret ; \n out -> pts = s -> pts ; \n out -> nb_samples = ret ; \n s -> pts += out -> nb_samples ; \n i += out -> nb_samples ; \n s -> current_sample += out -> nb_samples ; \n ret = ff_filter_frame ( outlink , out ) ; \n if ( ret < 0 ) \n return ret ; \n if ( s -> current_sample >= s -> nb_samples ) { \n s -> current_sample = 0 ; \n if ( s -> loop > 0 ) \n s -> loop -- ; \n } \n } \n return ret ; \n }", "idx": 1668}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "func": "static int img_set_parameters ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n VideoData * img = s -> priv_data ; \n AVStream * st ; \n AVImageFormat * img_fmt ; \n int i ; \n if ( ap && ap -> image_format ) { \n img_fmt = ap -> image_format ; \n } else { \n img_fmt = guess_image_format ( s -> filename ) ; \n } \n if ( ! img_fmt ) \n return -1 ; \n if ( s -> nb_streams != 1 ) \n return -1 ; \n st = s -> streams [ 0 ] ; \n for ( i = 0 ; i < PIX_FMT_NB ; i ++ ) { \n if ( img_fmt -> supported_pixel_formats & ( 1 << i ) ) \n break ; \n } \n if ( i >= PIX_FMT_NB ) \n return -1 ; \n img -> img_fmt = img_fmt ; \n img -> pix_fmt = i ; \n st -> codec -> pix_fmt = img -> pix_fmt ; \n return 0 ; \n }", "idx": 1674}
{"project": "FFmpeg", "commit_id": "a62242678ff96eade59960d1bbf65e4f3f03344f", "target": 1, "func": "static int opt_sameq ( void * optctx , const char * opt , const char * arg ) \n { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , opt ) ; \n return 0 ; \n }", "idx": 1681}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2nv12XinC ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , int dstFormat ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( uDest == NULL ) \n return ; \n if ( dstFormat == PIX_FMT_NV12 ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( u >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( v >> 19 ) ; \n } \n else \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( v >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( u >> 19 ) ; \n } \n }", "idx": 1682}
{"project": "FFmpeg", "commit_id": "a7f6bfdc185a04a703bedd712ee306435372af12", "target": 0, "func": "static void lowpass_line_complex_c ( uint8_t * dstp , ptrdiff_t width , const uint8_t * srcp , \n ptrdiff_t mref , ptrdiff_t pref ) \n { \n const uint8_t * srcp_above = srcp + mref ; \n const uint8_t * srcp_below = srcp + pref ; \n const uint8_t * srcp_above2 = srcp + mref * 2 ; \n const uint8_t * srcp_below2 = srcp + pref * 2 ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n dstp [ i ] = av_clip_uint8 ( ( 4 + ( srcp [ i ] << 2 ) \n + ( ( srcp [ i ] + srcp_above [ i ] + srcp_below [ i ] ) << 1 ) \n - srcp_above2 [ i ] - srcp_below2 [ i ] ) >> 3 ) ; \n } \n }", "idx": 1684}
{"project": "FFmpeg", "commit_id": "ebba2b3e2a551ce638d17332761431ba748f178f", "target": 0, "func": "static int udp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n UDPContext * s = h -> priv_data ; \n int ret ; \n for ( ; ; ) { \n if ( ! s -> is_connected ) { \n ret = sendto ( s -> udp_fd , buf , size , 0 , \n ( struct sockaddr * ) & s -> dest_addr , \n s -> dest_addr_len ) ; \n } else \n ret = send ( s -> udp_fd , buf , size , 0 ) ; \n if ( ret < 0 ) { \n if ( ff_neterrno ( ) != AVERROR ( EINTR ) && \n ff_neterrno ( ) != AVERROR ( EAGAIN ) ) \n return ff_neterrno ( ) ; \n } else { \n break ; \n } \n } \n return size ; \n }", "idx": 1695}
{"project": "FFmpeg", "commit_id": "03dab49a1267630375c4fc15dec1136814b1f117", "target": 0, "func": "av_cold int ff_vp56_init_context ( AVCodecContext * avctx , VP56Context * s , \n int flip , int has_alpha ) \n { \n int i ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P ; \n if ( avctx -> skip_alpha ) avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n ff_h264chroma_init ( & s -> h264chroma , 8 ) ; \n ff_hpeldsp_init ( & s -> hdsp , avctx -> flags ) ; \n ff_videodsp_init ( & s -> vdsp , 8 ) ; \n ff_vp3dsp_init ( & s -> vp3dsp , avctx -> flags ) ; \n ff_vp56dsp_init ( & s -> vp56dsp , avctx -> codec -> id ) ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n #define TRANSPOSE ( x )  (x >> 3) | ((x & 7) << 3)  \n  \n  s -> idct_scantable [ i ] = TRANSPOSE ( ff_zigzag_direct [ i ] ) ; \n #undef  TRANSPOSE  \n  \n  } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> frames ) ; i ++ ) { \n s -> frames [ i ] = av_frame_alloc ( ) ; \n if ( ! s -> frames [ i ] ) { \n ff_vp56_free ( avctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n } \n s -> edge_emu_buffer_alloc = NULL ; \n s -> above_blocks = NULL ; \n s -> macroblocks = NULL ; \n s -> quantizer = -1 ; \n s -> deblock_filtering = 1 ; \n s -> golden_frame = 0 ; \n s -> filter = NULL ; \n s -> has_alpha = has_alpha ; \n s -> modelp = & s -> model ; \n if ( flip ) { \n s -> flip = -1 ; \n s -> frbi = 2 ; \n s -> srbi = 0 ; \n } else { \n s -> flip = 1 ; \n s -> frbi = 0 ; \n s -> srbi = 2 ; \n } \n return 0 ; \n }", "idx": 1714}
{"project": "FFmpeg", "commit_id": "246d3bf0ec93dd21069f9352ed4909aec334cd4d", "target": 0, "func": "static av_always_inline void dist_scale ( HEVCContext * s , Mv * mv , \n int min_pu_width , int x , int y , \n int elist , int ref_idx_curr , int ref_idx ) \n { \n RefPicList * refPicList = s -> ref -> refPicList ; \n MvField * tab_mvf = s -> ref -> tab_mvf ; \n int ref_pic_elist = refPicList [ elist ] . list [ TAB_MVF ( x , y ) . ref_idx [ elist ] ] ; \n int ref_pic_curr = refPicList [ ref_idx_curr ] . list [ ref_idx ] ; \n if ( ref_pic_elist != ref_pic_curr ) \n mv_scale ( mv , mv , s -> poc - ref_pic_elist , s -> poc - ref_pic_curr ) ; \n }", "idx": 1715}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static int rm_write_video ( AVFormatContext * s , const uint8_t * buf , int size ) \n { \n RMContext * rm = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n StreamInfo * stream = rm -> video_stream ; \n int key_frame = stream -> enc -> coded_frame -> key_frame ; \n #if 1  \n  \n  write_packet_header ( s , stream , size + 7 , key_frame ) ; \n put_byte ( pb , 0x81 ) ; \n if ( key_frame ) { \n put_byte ( pb , 0x81 ) ; \n } else { \n put_byte ( pb , 0x01 ) ; \n } \n put_be16 ( pb , 0x4000 | ( size ) ) ; \n put_be16 ( pb , 0x4000 | ( size ) ) ; \n #else \n write_packet_header ( s , size + 6 ) ; \n put_byte ( pb , 0xc0 ) ; \n put_be16 ( pb , 0x4000 | size ) ; \n put_be16 ( pb , 0x4000 + packet_number * 126 ) ; \n #endif \n put_byte ( pb , stream -> nb_frames & 0xff ) ; \n put_buffer ( pb , buf , size ) ; \n put_flush_packet ( pb ) ; \n stream -> nb_frames ++ ; \n return 0 ; \n }", "idx": 1716}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "void av_get_channel_layout_string ( char * buf , int buf_size , \n int nb_channels , int64_t channel_layout ) \n { \n int i ; \n if ( nb_channels <= 0 ) \n nb_channels = av_get_channel_layout_nb_channels ( channel_layout ) ; \n for ( i = 0 ; channel_layout_map [ i ] . name ; i ++ ) \n if ( nb_channels == channel_layout_map [ i ] . nb_channels && \n channel_layout == channel_layout_map [ i ] . layout ) { \n av_strlcpy ( buf , channel_layout_map [ i ] . name , buf_size ) ; \n return ; \n } \n snprintf ( buf , buf_size , \" \" , nb_channels ) ; \n if ( channel_layout ) { \n int i , ch ; \n av_strlcat ( buf , \" \" , buf_size ) ; \n for ( i = 0 , ch = 0 ; i < 64 ; i ++ ) { \n if ( ( channel_layout & ( 1L << i ) ) ) { \n const char * name = get_channel_name ( i ) ; \n if ( name ) { \n if ( ch > 0 ) \n av_strlcat ( buf , \" \" , buf_size ) ; \n av_strlcat ( buf , name , buf_size ) ; \n } \n ch ++ ; \n } \n } \n av_strlcat ( buf , \" \" , buf_size ) ; \n } \n }", "idx": 1717}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( uyvyToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n #if defined ( HAVE_MMX2 ) || defined ( HAVE_3DNOW )  \n  \n  asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm4 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGB ( % % mm2 , % % mm0 ) \n PAVGB ( % % mm3 , % % mm1 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( long ) - width ) , \" \" ( src1 + width * 4 ) , \" \" ( src2 + width * 4 ) , \" \" ( dstU + width ) , \" \" ( dstV + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = ( src1 [ 4 * i + 0 ] + src2 [ 4 * i + 0 ] ) >> 1 ; \n dstV [ i ] = ( src1 [ 4 * i + 2 ] + src2 [ 4 * i + 2 ] ) >> 1 ; \n } \n #endif \n }", "idx": 1719}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static void default_show_tags ( WriterContext * wctx , AVDictionary * dict ) \n { \n AVDictionaryEntry * tag = NULL ; \n while ( ( tag = av_dict_get ( dict , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) { \n printf ( \" \" ) ; \n writer_print_string ( wctx , tag -> key , tag -> value ) ; \n } \n }", "idx": 1720}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_block ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n unsigned int smp ; \n if ( * bd -> const_block ) \n decode_const_block_data ( ctx , bd ) ; \n else if ( decode_var_block_data ( ctx , bd ) ) \n return -1 ; \n if ( * bd -> shift_lsbs ) \n for ( smp = 0 ; smp < bd -> block_length ; smp ++ ) \n bd -> raw_samples [ smp ] <<= * bd -> shift_lsbs ; \n return 0 ; \n }", "idx": 1722}
{"project": "FFmpeg", "commit_id": "91be2ad756d658acc24fec5bc46c1775158d28b0", "target": 1, "func": "static void hdcd_reset ( hdcd_state * state , unsigned rate , unsigned cdt_ms ) \n { \n int i ; \n state -> window = 0 ; \n state -> readahead = 32 ; \n state -> arg = 0 ; \n state -> control = 0 ; \n state -> running_gain = 0 ; \n state -> sustain = 0 ; \n state -> sustain_reset = cdt_ms * rate / 1000 ; \n state -> code_counterA = 0 ; \n state -> code_counterA_almost = 0 ; \n state -> code_counterB = 0 ; \n state -> code_counterB_checkfails = 0 ; \n state -> code_counterC = 0 ; \n state -> code_counterC_unmatched = 0 ; \n state -> count_peak_extend = 0 ; \n state -> count_transient_filter = 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) state -> gain_counts [ i ] = 0 ; \n state -> max_gain = 0 ; \n state -> count_sustain_expired = -1 ; \n state -> _ana_snb = 0 ; \n }", "idx": 1723}
{"project": "FFmpeg", "commit_id": "31c3a4dc7e15f993b0076c7231f80249a55ea146", "target": 1, "func": "static int avcodec_find_best_pix_fmt1 ( int64_t pix_fmt_mask , \n int src_pix_fmt , \n int has_alpha , \n int loss_mask ) \n { \n int dist , i , loss , min_dist , dst_pix_fmt ; \n dst_pix_fmt = -1 ; \n min_dist = 0x7fffffff ; \n for ( i = 0 ; i < PIX_FMT_NB ; i ++ ) { \n if ( pix_fmt_mask & ( 1 << i ) ) { \n loss = avcodec_get_pix_fmt_loss ( i , src_pix_fmt , has_alpha ) & loss_mask ; \n if ( loss == 0 ) { \n dist = avg_bits_per_pixel ( i ) ; \n if ( dist < min_dist ) { \n min_dist = dist ; \n dst_pix_fmt = i ; \n } \n } \n } \n } \n return dst_pix_fmt ; \n }", "idx": 1728}
{"project": "FFmpeg", "commit_id": "88ad79415c3821e5c4f3cb4d5b289d772fcac621", "target": 1, "func": "static int mpc8_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n MPCContext * c = s -> priv_data ; \n int index = av_index_search_timestamp ( st , timestamp , flags ) ; \n if ( index < 0 ) return -1 ; \n avio_seek ( s -> pb , st -> index_entries [ index ] . pos , SEEK_SET ) ; \n c -> frame = st -> index_entries [ index ] . timestamp ; \n return 0 ; \n }", "idx": 1730}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_left_dc_rv40_c ( uint8_t * src , int stride ) { \n int i ; \n int dc0 ; \n dc0 = 0 ; \n for ( i = 0 ; i < 8 ; i ++ ) \n dc0 += src [ -1 + i * stride ] ; \n dc0 = 0x01010101 * ( ( dc0 + 4 ) >> 3 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( uint32_t * ) ( src + i * stride ) ) [ 0 ] = \n ( ( uint32_t * ) ( src + i * stride ) ) [ 1 ] = dc0 ; \n } \n }", "idx": 1731}
{"project": "FFmpeg", "commit_id": "42da8ea8e848e65611f0c606cd2c96d3a70c041d", "target": 1, "func": "static int latm_decode_frame ( AVCodecContext * avctx , void * out , int * out_size , \n AVPacket * avpkt ) \n { \n struct LATMContext * latmctx = avctx -> priv_data ; \n int muxlength , err ; \n GetBitContext gb ; \n if ( avpkt -> size == 0 ) \n return 0 ; \n init_get_bits ( & gb , avpkt -> data , avpkt -> size * 8 ) ; \n if ( get_bits ( & gb , 11 ) != LOAS_SYNC_WORD ) \n return AVERROR_INVALIDDATA ; \n muxlength = get_bits ( & gb , 13 ) + 3 ; \n if ( muxlength > avpkt -> size ) \n return AVERROR_INVALIDDATA ; \n if ( ( err = read_audio_mux_element ( latmctx , & gb ) ) < 0 ) \n return err ; \n if ( ! latmctx -> initialized ) { \n if ( ! avctx -> extradata ) { \n * out_size = 0 ; \n return avpkt -> size ; \n } else { \n if ( ( err = aac_decode_init ( avctx ) ) < 0 ) \n return err ; \n latmctx -> initialized = 1 ; \n } \n } \n if ( show_bits ( & gb , 12 ) == 0xfff ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ( err = aac_decode_frame_int ( avctx , out , out_size , & gb ) ) < 0 ) \n return err ; \n return muxlength ; \n }", "idx": 1733}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_mips ( struct AACEncContext * s , PutBitContext * pb , \n const float * in , float * out , int size , int scale_idx , \n int cb , const float lambda , int rtz ) \n { \n quantize_and_encode_band_cost ( s , pb , in , out , NULL , size , scale_idx , cb , lambda , \n INFINITY , NULL , ( rtz ) ? ROUND_TO_ZERO : ROUND_STANDARD ) ; \n }", "idx": 1734}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "func": "static int lzw_get_code ( struct LZWState * s ) \n { \n int c ; \n if ( s -> mode == FF_LZW_GIF ) { \n while ( s -> bbits < s -> cursize ) { \n if ( ! s -> bs ) { \n s -> bs = * s -> pbuf ++ ; \n if ( ! s -> bs ) { \n s -> eob_reached = 1 ; \n break ; \n } \n } \n s -> bbuf |= ( * s -> pbuf ++ ) << s -> bbits ; \n s -> bbits += 8 ; \n s -> bs -- ; \n } \n c = s -> bbuf & s -> curmask ; \n s -> bbuf >>= s -> cursize ; \n } else { \n while ( s -> bbits < s -> cursize ) { \n if ( s -> pbuf >= s -> ebuf ) { \n s -> eob_reached = 1 ; \n } \n s -> bbuf = ( s -> bbuf << 8 ) | ( * s -> pbuf ++ ) ; \n s -> bbits += 8 ; \n } \n c = ( s -> bbuf >> ( s -> bbits - s -> cursize ) ) & s -> curmask ; \n } \n s -> bbits -= s -> cursize ; \n return c ; \n }", "idx": 1738}
{"project": "FFmpeg", "commit_id": "77a4c8b959fa9bc6bcaa42b40a0b046cdf3fec38", "target": 1, "func": "static av_cold int yop_decode_init ( AVCodecContext * avctx ) \n { \n YopDecContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( avctx -> width & 1 || avctx -> height & 1 || \n av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n avcodec_get_frame_defaults ( & s -> frame ) ; \n s -> num_pal_colors = avctx -> extradata [ 0 ] ; \n s -> first_color [ 0 ] = avctx -> extradata [ 1 ] ; \n s -> first_color [ 1 ] = avctx -> extradata [ 2 ] ; \n if ( s -> num_pal_colors + s -> first_color [ 0 ] > 256 || \n s -> num_pal_colors + s -> first_color [ 1 ] > 256 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return 0 ;", "idx": 1739}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static void init_quantization ( Jpeg2000EncoderContext * s ) \n { \n int compno , reslevelno , bandno ; \n Jpeg2000QuantStyle * qntsty = & s -> qntsty ; \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n int gbandno = 0 ; \n for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { \n int nbands , lev = codsty -> nreslevels - reslevelno - 1 ; \n nbands = reslevelno ? 3 : 1 ; \n for ( bandno = 0 ; bandno < nbands ; bandno ++ , gbandno ++ ) { \n int expn , mant ; \n if ( codsty -> transform == FF_DWT97 ) { \n int bandpos = bandno + ( reslevelno > 0 ) , \n ss = 81920000 / dwt_norms [ 0 ] [ bandpos ] [ lev ] , \n log = av_log2 ( ss ) ; \n mant = ( 11 - log < 0 ? ss >> log - 11 : ss << 11 - log ) & 0x7ff ; \n expn = s -> cbps [ compno ] - log + 13 ; \n } else \n expn = ( ( bandno & 2 ) >> 1 ) + ( reslevelno > 0 ) + s -> cbps [ compno ] ; \n qntsty -> expn [ gbandno ] = expn ; \n qntsty -> mant [ gbandno ] = mant ; \n } \n } \n } \n }", "idx": 1757}
{"project": "FFmpeg", "commit_id": "a8475bbdb64e638bd8161df9647876fd23f8a29a", "target": 0, "func": "static int sap_fetch_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n struct SAPState * sap = s -> priv_data ; \n int fd = url_get_file_handle ( sap -> ann_fd ) ; \n int n , ret ; \n fd_set rfds ; \n struct timeval tv ; \n uint8_t recvbuf [ 1500 ] ; \n if ( sap -> eof ) \n return AVERROR_EOF ; \n while ( 1 ) { \n FD_ZERO ( & rfds ) ; \n FD_SET ( fd , & rfds ) ; \n tv . tv_sec = tv . tv_usec = 0 ; \n n = select ( fd + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n <= 0 || ! FD_ISSET ( fd , & rfds ) ) \n break ; \n ret = url_read ( sap -> ann_fd , recvbuf , sizeof ( recvbuf ) ) ; \n if ( ret >= 8 ) { \n uint16_t hash = AV_RB16 ( & recvbuf [ 2 ] ) ; \n if ( recvbuf [ 0 ] & 0x04 && hash == sap -> hash ) { \n sap -> eof = 1 ; \n return AVERROR_EOF ; \n } \n } \n } \n ret = av_read_frame ( sap -> sdp_ctx , pkt ) ; \n if ( ret < 0 ) \n return ret ; \n if ( s -> ctx_flags & AVFMTCTX_NOHEADER ) { \n while ( sap -> sdp_ctx -> nb_streams > s -> nb_streams ) { \n int i = s -> nb_streams ; \n AVStream * st = av_new_stream ( s , i ) ; \n if ( ! st ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avcodec_copy_context ( st -> codec , sap -> sdp_ctx -> streams [ i ] -> codec ) ; \n st -> time_base = sap -> sdp_ctx -> streams [ i ] -> time_base ; \n } \n } \n return ret ; \n }", "idx": 1768}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "int get_partial_buffer ( ByteIOContext * s , unsigned char * buf , int size ) \n { \n int len ; \n len = s -> buf_end - s -> buf_ptr ; \n if ( len == 0 ) { \n fill_buffer ( s ) ; \n len = s -> buf_end - s -> buf_ptr ; \n } \n if ( len > size ) \n len = size ; \n memcpy ( buf , s -> buf_ptr , len ) ; \n s -> buf_ptr += len ; \n return len ; \n }", "idx": 1778}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb16tobgr15 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x1F ) << 5 ) | ( ( r & 0x1F ) << 10 ) ; \n } \n }", "idx": 1782}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libx265_encode_close ( AVCodecContext * avctx ) \n { \n libx265Context * ctx = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n ctx -> api -> param_free ( ctx -> params ) ; \n if ( ctx -> encoder ) \n ctx -> api -> encoder_close ( ctx -> encoder ) ; \n return 0 ; \n }", "idx": 1788}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void assert_file_overwrite ( const char * filename ) \n { \n if ( file_overwrite && file_skip ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit_program ( 1 ) ; \n } \n if ( ! file_overwrite && \n ( strchr ( filename , ' ' ) == NULL || filename [ 1 ] == ' ' || \n av_strstart ( filename , \" \" , NULL ) ) ) { \n if ( avio_check ( filename , 0 ) == 0 ) { \n if ( ! using_stdin && ! file_skip ) { \n fprintf ( stderr , \" \" , filename ) ; \n fflush ( stderr ) ; \n if ( ! read_yesno ( ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit_program ( 1 ) ; \n } \n } \n else { \n fprintf ( stderr , \" \\n \" , filename ) ; \n exit_program ( 1 ) ; \n } \n } \n } \n }", "idx": 1790}
{"project": "FFmpeg", "commit_id": "d466d82faaf6e0e57a3a4be5e38e3902ef251ac3", "target": 1, "func": "static av_cold int dvdsub_init ( AVCodecContext * avctx ) \n { \n DVDSubContext * ctx = avctx -> priv_data ; \n char * data , * cur ; \n if ( ! avctx -> extradata || ! avctx -> extradata_size ) \n return 0 ; \n data = av_malloc ( avctx -> extradata_size + 1 ) ; \n if ( ! data ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( data , avctx -> extradata , avctx -> extradata_size ) ; \n data [ avctx -> extradata_size ] = ' \\0 ' ; \n cur = data ; \n while ( * cur ) { \n if ( strncmp ( \" \" , cur , 8 ) == 0 ) { \n int i ; \n char * p = cur + 8 ; \n ctx -> has_palette = 1 ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n ctx -> palette [ i ] = strtoul ( p , & p , 16 ) ; \n while ( * p == ' ' || av_isspace ( * p ) ) \n p ++ ; \n } \n } else if ( ! strncmp ( \" \" , cur , 5 ) ) { \n int w , h ; \n if ( sscanf ( cur + 5 , \" \" , & w , & h ) == 2 ) { \n int ret = ff_set_dimensions ( avctx , w , h ) ; \n if ( ret < 0 ) \n return ret ; \n } \n } \n cur += strcspn ( cur , \" \\n \\r \" ) ; \n cur += strspn ( cur , \" \\n \\r \" ) ; \n } \n av_free ( data ) ; \n return 0 ; \n }", "idx": 1796}
{"project": "FFmpeg", "commit_id": "7df3b426bbfbd7efd9a0f56393e3cc78413b0869", "target": 1, "func": "static void mxf_write_random_index_pack ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n uint64_t pos = avio_tell ( pb ) ; \n int i ; \n avio_write ( pb , random_index_pack_key , 16 ) ; \n klv_encode_ber_length ( pb , 28 + 12 * mxf -> body_partitions_count ) ; \n if ( mxf -> edit_unit_byte_count ) \n avio_wb32 ( pb , 1 ) ; \n else \n avio_wb32 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n for ( i = 0 ; i < mxf -> body_partitions_count ; i ++ ) { \n avio_wb32 ( pb , 1 ) ; \n avio_wb64 ( pb , mxf -> body_partition_offset [ i ] ) ; \n } \n avio_wb32 ( pb , 0 ) ; \n avio_wb64 ( pb , mxf -> footer_partition_offset ) ; \n avio_wb32 ( pb , avio_tell ( pb ) - pos + 4 ) ; \n }", "idx": 1797}
{"project": "FFmpeg", "commit_id": "4ea7c179325f61736040f2ff22c2f27c702727d4", "target": 1, "func": "static int config_props ( AVFilterLink * link ) \n { \n YADIFContext * yadif = link -> src -> priv ; \n link -> time_base . num = link -> src -> inputs [ 0 ] -> time_base . num ; \n link -> time_base . den = link -> src -> inputs [ 0 ] -> time_base . den * 2 ; \n link -> w = link -> src -> inputs [ 0 ] -> w ; \n link -> h = link -> src -> inputs [ 0 ] -> h ; \n if ( yadif -> mode & 1 ) \n link -> frame_rate = av_mul_q ( link -> src -> inputs [ 0 ] -> frame_rate , ( AVRational ) { 2 , 1 } ) ; \n return 0 ; \n }", "idx": 1801}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int alloc_table ( VLC * vlc , int size ) \n { \n int index ; \n index = vlc -> table_size ; \n vlc -> table_size += size ; \n if ( vlc -> table_size > vlc -> table_allocated ) { \n vlc -> table_allocated += ( 1 << vlc -> bits ) ; \n vlc -> table = av_realloc ( vlc -> table , \n sizeof ( VLC_TYPE ) * 2 * vlc -> table_allocated ) ; \n if ( ! vlc -> table ) \n return -1 ; \n } \n return index ; \n }", "idx": 1805}
{"project": "FFmpeg", "commit_id": "02cb7d4c9c3adfae84ef0d5646c2de944176f849", "target": 1, "func": "static av_cold int smvjpeg_decode_init ( AVCodecContext * avctx ) \n { \n SMVJpegDecodeContext * s = avctx -> priv_data ; \n AVCodec * codec ; \n AVDictionary * thread_opt = NULL ; \n int ret = 0 ; \n s -> frames_per_jpeg = 0 ; \n s -> picture [ 0 ] = av_frame_alloc ( ) ; \n if ( ! s -> picture [ 0 ] ) \n return AVERROR ( ENOMEM ) ; \n s -> picture [ 1 ] = av_frame_alloc ( ) ; \n if ( ! s -> picture [ 1 ] ) \n return AVERROR ( ENOMEM ) ; \n s -> jpg . picture_ptr = s -> picture [ 0 ] ; \n if ( avctx -> extradata_size >= 4 ) \n s -> frames_per_jpeg = AV_RL32 ( avctx -> extradata ) ; \n if ( s -> frames_per_jpeg <= 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = -1 ; \n } \n codec = avcodec_find_decoder ( AV_CODEC_ID_MJPEG ) ; \n if ( ! codec ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = -1 ; \n } \n s -> avctx = avcodec_alloc_context3 ( codec ) ; \n av_dict_set ( & thread_opt , \" \" , \" \" , 0 ) ; \n s -> avctx -> refcounted_frames = 1 ; \n s -> avctx -> flags = avctx -> flags ; \n s -> avctx -> idct_algo = avctx -> idct_algo ; \n if ( ff_codec_open2_recursive ( s -> avctx , codec , & thread_opt ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ret = -1 ; \n } \n av_dict_free ( & thread_opt ) ; \n return ret ; \n }", "idx": 1808}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_avg_h264_qpel8_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avg_width8_msa ( src , stride , dst , stride , 8 ) ; \n }", "idx": 1812}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_key ( DBEContext * s ) \n { \n int key = 0 ; \n if ( s -> key_present && s -> input_size > 0 ) \n key = AV_RB24 ( s -> input ) >> 24 - s -> word_bits ; \n skip_input ( s , s -> key_present ) ; \n return key ; \n }", "idx": 1814}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( rgb24to32 ) ( const uint8_t * src , uint8_t * dst , unsigned src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n #ifdef HAVE_MMX \n const uint8_t * mm_end ; \n #endif \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 23 ; \n __asm __volatile ( \" \" :: \" \" ( mask32 ) : \" \" ) ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * dest ) \n : \" m \" ( * s ) \n : \" memory \" ) ; \n dest += 32 ; \n s += 24 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n while ( s < end ) \n { \n #ifdef WORDS_BIGENDIAN \n * dest ++ = 0 ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n #else \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = 0 ; \n #endif \n } \n }", "idx": 1819}
{"project": "FFmpeg", "commit_id": "dd3b73f3905c61c99f1d3fb58bc7ee380eb8aa2e", "target": 1, "func": "int av_base64_decode ( uint8_t * out , const char * in , int out_size ) \n { \n int i , v ; \n uint8_t * dst = out ; \n v = 0 ; \n for ( i = 0 ; in [ i ] && in [ i ] != ' ' ; i ++ ) { \n unsigned int index = in [ i ] - 43 ; \n if ( index >= FF_ARRAY_ELEMS ( map2 ) || map2 [ index ] == 0xff ) \n return -1 ; \n v = ( v << 6 ) + map2 [ index ] ; \n if ( i & 3 ) { \n if ( dst - out < out_size ) { \n * dst ++ = v >> ( 6 - 2 * ( i & 3 ) ) ; \n } \n } \n } \n return dst - out ; \n }", "idx": 1827}
{"project": "FFmpeg", "commit_id": "ee26abf2a4884bb56959bac8215758195776c553", "target": 0, "func": "static void roq_encode_video ( RoqContext * enc ) \n { \n RoqTempdata * tempData = enc -> tmpData ; \n int i ; \n memset ( tempData , 0 , sizeof ( * tempData ) ) ; \n create_cel_evals ( enc , tempData ) ; \n generate_new_codebooks ( enc , tempData ) ; \n if ( enc -> framesSinceKeyframe >= 1 ) { \n motion_search ( enc , 8 ) ; \n motion_search ( enc , 4 ) ; \n } \n retry_encode : \n for ( i = 0 ; i < enc -> width * enc -> height / 64 ; i ++ ) \n gather_data_for_cel ( tempData -> cel_evals + i , enc , tempData ) ; \n if ( tempData -> mainChunkSize / 8 > 65536 ) { \n enc -> lambda *= .8 ; \n goto retry_encode ; \n } \n remap_codebooks ( enc , tempData ) ; \n write_codebooks ( enc , tempData ) ; \n reconstruct_and_encode_image ( enc , tempData , enc -> width , enc -> height , \n enc -> width * enc -> height / 64 ) ; \n enc -> avctx -> coded_frame = enc -> current_frame ; \n FFSWAP ( AVFrame * , enc -> current_frame , enc -> last_frame ) ; \n FFSWAP ( motion_vect * , enc -> last_motion4 , enc -> this_motion4 ) ; \n FFSWAP ( motion_vect * , enc -> last_motion8 , enc -> this_motion8 ) ; \n av_free ( tempData -> cel_evals ) ; \n av_free ( tempData -> closest_cb2 ) ; \n enc -> framesSinceKeyframe ++ ; \n }", "idx": 1831}
{"project": "FFmpeg", "commit_id": "da3c3c446cb434be9d0025f519e00c2385135c85", "target": 1, "func": "static int packet_alloc ( AVBufferRef * * buf , int size ) \n { \n int ret ; \n if ( ( unsigned ) size >= ( unsigned ) size + AV_INPUT_BUFFER_PADDING_SIZE ) \n return AVERROR ( EINVAL ) ; \n ret = av_buffer_realloc ( buf , size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ret < 0 ) \n return ret ; \n memset ( ( * buf ) -> data + size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; \n return 0 ; \n }", "idx": 1832}
{"project": "FFmpeg", "commit_id": "eae2d89bf715bc3edff478174b43e1f388e768bf", "target": 0, "func": "static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , \n AVDictionary * opts , AVDictionary * opts2 ) \n { \n HLSContext * c = s -> priv_data ; \n AVDictionary * tmp = NULL ; \n const char * proto_name = avio_find_protocol_name ( url ) ; \n int ret ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n av_dict_copy ( & tmp , opts2 , 0 ) ; \n if ( ! proto_name ) \n return AVERROR_INVALIDDATA ; \n if ( ! av_strstart ( proto_name , \" \" , NULL ) && ! av_strstart ( proto_name , \" \" , NULL ) ) \n return AVERROR_INVALIDDATA ; \n if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ' ' ) \n ; \n else if ( strcmp ( proto_name , \" \" ) || ! strncmp ( url , \" \" , 5 ) ) \n return AVERROR_INVALIDDATA ; \n ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp ) ; \n if ( ret >= 0 ) { \n void * u = ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ? NULL : s -> pb ; \n update_options ( & c -> cookies , \" \" , u ) ; \n av_dict_set ( & opts , \" \" , c -> cookies , 0 ) ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 1835}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_mpeg12_end_frame ( AVCodecContext * avctx ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n int ret = ff_nvdec_end_frame ( avctx ) ; \n ctx -> bitstream = NULL ; \n return ret ; \n }", "idx": 1837}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int vp8_free ( AVCodecContext * avctx ) \n { \n VP8Context * ctx = avctx -> priv_data ; \n vpx_codec_destroy ( & ctx -> encoder ) ; \n av_freep ( & ctx -> twopass_stats . buf ) ; \n av_freep ( & avctx -> coded_frame ) ; \n av_freep ( & avctx -> stats_out ) ; \n free_frame_list ( ctx -> coded_frame_list ) ; \n return 0 ; \n }", "idx": 1841}
{"project": "FFmpeg", "commit_id": "000836c2a98e1c6a2867dd9db0371c137609acf0", "target": 0, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * insamples ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ASNSContext * asns = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n int ret ; \n int nb_samples = insamples -> nb_samples ; \n if ( av_audio_fifo_space ( asns -> fifo ) < nb_samples ) { \n av_log ( ctx , AV_LOG_DEBUG , \" \\n \" , nb_samples ) ; \n ret = av_audio_fifo_realloc ( asns -> fifo , av_audio_fifo_size ( asns -> fifo ) + nb_samples ) ; \n if ( ret < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , nb_samples ) ; \n return -1 ; \n } \n } \n av_audio_fifo_write ( asns -> fifo , ( void * * ) insamples -> extended_data , nb_samples ) ; \n if ( asns -> next_out_pts == AV_NOPTS_VALUE ) \n asns -> next_out_pts = insamples -> pts ; \n av_frame_free ( & insamples ) ; \n while ( av_audio_fifo_size ( asns -> fifo ) >= asns -> nb_out_samples ) \n push_samples ( outlink ) ; \n return 0 ; \n }", "idx": 1852}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void * ff_schro_queue_pop ( FFSchroQueue * queue ) \n { \n FFSchroQueueElement * top = queue -> p_head ; \n if ( top ) { \n void * data = top -> data ; \n queue -> p_head = queue -> p_head -> next ; \n -- queue -> size ; \n av_freep ( & top ) ; \n return data ; \n } \n return NULL ; \n }", "idx": 1866}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int _do_rematrixing ( AC3DecodeContext * ctx , int start , int end ) \n { \n float tmp0 , tmp1 ; \n while ( start < end ) { \n tmp0 = ctx -> samples [ start ] ; \n tmp1 = ( ctx -> samples + 256 ) [ start ] ; \n ctx -> samples [ start ] = tmp0 + tmp1 ; \n ( ctx -> samples + 256 ) [ start ] = tmp0 - tmp1 ; \n start ++ ; \n } \n return 0 ; \n }", "idx": 1869}
{"project": "FFmpeg", "commit_id": "e97efecec82ca8458a9bbd75a91ebf556abde362", "target": 0, "func": "const DVprofile * avpriv_dv_frame_profile ( const DVprofile * sys , \n const uint8_t * frame , unsigned buf_size ) \n { \n int i ; \n int dsf = ( frame [ 3 ] & 0x80 ) >> 7 ; \n int stype = frame [ 80 * 5 + 48 + 3 ] & 0x1f ; \n if ( dsf == 1 && stype == 0 && frame [ 4 ] & 0x07 \n ) { \n return & dv_profiles [ 2 ] ; \n } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( dv_profiles ) ; i ++ ) \n if ( dsf == dv_profiles [ i ] . dsf && stype == dv_profiles [ i ] . video_stype ) \n return & dv_profiles [ i ] ; \n if ( sys && buf_size == sys -> frame_size ) \n return sys ; \n return NULL ; \n }", "idx": 1870}
{"project": "FFmpeg", "commit_id": "e371f031b942d73e02c090170975561fabd5c264", "target": 1, "func": "static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , \n const uint8_t * data_end ) \n { \n z_stream zstream ; \n unsigned char * buf ; \n unsigned buf_size ; \n int ret ; \n zstream . zalloc = ff_png_zalloc ; \n zstream . zfree = ff_png_zfree ; \n zstream . opaque = NULL ; \n if ( inflateInit ( & zstream ) != Z_OK ) \n return AVERROR_EXTERNAL ; \n zstream . next_in = ( unsigned char * ) data ; \n zstream . avail_in = data_end - data ; \n av_bprint_init ( bp , 0 , -1 ) ; \n while ( zstream . avail_in > 0 ) { \n av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; \n if ( ! buf_size ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n zstream . next_out = buf ; \n zstream . avail_out = buf_size ; \n ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; \n if ( ret != Z_OK && ret != Z_STREAM_END ) { \n ret = AVERROR_EXTERNAL ; \n goto fail ; \n } \n bp -> len += zstream . next_out - buf ; \n if ( ret == Z_STREAM_END ) \n break ; \n } \n inflateEnd ( & zstream ) ; \n bp -> str [ bp -> len ] = 0 ; \n return 0 ; \n fail : \n inflateEnd ( & zstream ) ; \n av_bprint_finalize ( bp , NULL ) ; \n return ret ; \n }", "idx": 1875}
{"project": "FFmpeg", "commit_id": "d003a0cd2e587a47627fd328f9fc5a484adc29f2", "target": 1, "func": "static int mp3_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MP3Context * mp3 = s -> priv_data ; \n if ( pkt -> stream_index == mp3 -> audio_stream_idx ) { \n if ( mp3 -> pics_to_write ) { \n AVPacketList * pktl = av_mallocz ( sizeof ( * pktl ) ) ; \n if ( ! pktl ) \n return AVERROR ( ENOMEM ) ; \n pktl -> pkt = * pkt ; \n pktl -> pkt . buf = av_buffer_ref ( pkt -> buf ) ; \n if ( ! pktl -> pkt . buf ) { \n av_freep ( & pktl ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( mp3 -> queue_end ) \n mp3 -> queue_end -> next = pktl ; \n else \n mp3 -> queue = pktl ; \n mp3 -> queue_end = pktl ; \n } else \n return mp3_write_audio_packet ( s , pkt ) ; \n } else { \n int ret ; \n if ( s -> streams [ pkt -> stream_index ] -> nb_frames == 1 ) { \n av_log ( s , AV_LOG_WARNING , \" \" \n \" \\n \" , pkt -> stream_index ) ; \n } \n if ( ! mp3 -> pics_to_write || s -> streams [ pkt -> stream_index ] -> nb_frames >= 1 ) \n return 0 ; \n if ( ( ret = ff_id3v2_write_apic ( s , & mp3 -> id3 , pkt ) ) < 0 ) \n return ret ; \n mp3 -> pics_to_write -- ; \n if ( ! mp3 -> pics_to_write && \n ( ret = mp3_queue_flush ( s ) ) < 0 ) \n return ret ; \n } \n return 0 ; \n }", "idx": 1885}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void update_sono_yuv ( AVFrame * sono , const ColorFloat * c , int idx ) \n { \n int x , fmt = sono -> format , w = sono -> width ; \n uint8_t * lpy = sono -> data [ 0 ] + idx * sono -> linesize [ 0 ] ; \n uint8_t * lpu = sono -> data [ 1 ] + idx * sono -> linesize [ 1 ] ; \n uint8_t * lpv = sono -> data [ 2 ] + idx * sono -> linesize [ 2 ] ; \n for ( x = 0 ; x < w ; x += 2 ) { \n * lpy ++ = c [ x ] . yuv . y + 0.5f ; \n * lpu ++ = c [ x ] . yuv . u + 0.5f ; \n * lpv ++ = c [ x ] . yuv . v + 0.5f ; \n * lpy ++ = c [ x + 1 ] . yuv . y + 0.5f ; \n if ( fmt == AV_PIX_FMT_YUV444P ) { \n * lpu ++ = c [ x + 1 ] . yuv . u + 0.5f ; \n * lpv ++ = c [ x + 1 ] . yuv . v + 0.5f ; \n } \n } \n }", "idx": 1919}
{"project": "FFmpeg", "commit_id": "72ec043af4510723c53c729a67be482a14b7c7f3", "target": 1, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint32_t pos , taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n pos += 44 + taglen ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 1928}
{"project": "FFmpeg", "commit_id": "a67cb012e6947fb238193afc0f18114f6e20818c", "target": 1, "func": "AVResampleContext * av_resample_init ( int out_rate , int in_rate , int filter_size , int phase_shift , int linear , double cutoff ) { \n AVResampleContext * c = av_mallocz ( sizeof ( AVResampleContext ) ) ; \n double factor = FFMIN ( out_rate * cutoff / in_rate , 1.0 ) ; \n int phase_count = 1 << phase_shift ; \n if ( ! c ) \n return NULL ; \n c -> phase_shift = phase_shift ; \n c -> phase_mask = phase_count - 1 ; \n c -> linear = linear ; \n c -> filter_length = FFMAX ( ( int ) ceil ( filter_size / factor ) , 1 ) ; \n c -> filter_bank = av_mallocz ( c -> filter_length * ( phase_count + 1 ) * sizeof ( FELEM ) ) ; \n if ( ! c -> filter_bank ) \n goto error ; \n if ( build_filter ( c -> filter_bank , factor , c -> filter_length , phase_count , 1 << FILTER_SHIFT , WINDOW_TYPE ) ) \n goto error ; \n memcpy ( & c -> filter_bank [ c -> filter_length * phase_count + 1 ] , c -> filter_bank , ( c -> filter_length - 1 ) * sizeof ( FELEM ) ) ; \n c -> filter_bank [ c -> filter_length * phase_count ] = c -> filter_bank [ c -> filter_length - 1 ] ; \n c -> src_incr = out_rate ; \n c -> ideal_dst_incr = c -> dst_incr = in_rate * phase_count ; \n c -> index = - phase_count * ( ( c -> filter_length - 1 ) / 2 ) ; \n return c ; \n error : \n av_free ( c -> filter_bank ) ; \n av_free ( c ) ; \n return NULL ; \n }", "idx": 1932}
{"project": "FFmpeg", "commit_id": "46ff7a5f4ae05e5e4da33b700604dae2c37bebcb", "target": 1, "func": "static int udp_read_packet ( AVFormatContext * s , RTSPStream * * prtsp_st , \n uint8_t * buf , int buf_size ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPStream * rtsp_st ; \n fd_set rfds ; \n int fd , fd_max , n , i , ret , tcp_fd ; \n struct timeval tv ; \n for ( ; ; ) { \n if ( url_interrupt_cb ( ) ) \n return AVERROR ( EINTR ) ; \n FD_ZERO ( & rfds ) ; \n tcp_fd = fd_max = url_get_file_handle ( rt -> rtsp_hd ) ; \n FD_SET ( tcp_fd , & rfds ) ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st -> rtp_handle ) { \n fd = url_get_file_handle ( rtsp_st -> rtp_handle ) ; \n if ( fd > fd_max ) \n fd_max = fd ; \n FD_SET ( fd , & rfds ) ; \n } \n } \n tv . tv_sec = 0 ; \n tv . tv_usec = 100 * 1000 ; \n n = select ( fd_max + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n > 0 ) { \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st -> rtp_handle ) { \n fd = url_get_file_handle ( rtsp_st -> rtp_handle ) ; \n if ( FD_ISSET ( fd , & rfds ) ) { \n ret = url_read ( rtsp_st -> rtp_handle , buf , buf_size ) ; \n if ( ret > 0 ) { \n * prtsp_st = rtsp_st ; \n return ret ; \n } \n } \n } \n } \n if ( FD_ISSET ( tcp_fd , & rfds ) ) { \n RTSPMessageHeader reply ; \n rtsp_read_reply ( s , & reply , NULL , 0 ) ; \n } \n } \n } \n }", "idx": 1936}
{"project": "FFmpeg", "commit_id": "34c52005605d68f7cd1957b169b6732c7d2447d9", "target": 1, "func": "static float * * alloc_audio_arrays ( int channels , int frame_size ) \n { \n float * * audio = av_mallocz_array ( channels , sizeof ( float * ) ) ; \n if ( ! audio ) \n return NULL ; \n for ( int ch = 0 ; ch < channels ; ch ++ ) { \n audio [ ch ] = av_mallocz_array ( frame_size , sizeof ( float ) ) ; \n if ( ! audio [ ch ] ) { \n for ( ch -- ; ch >= 0 ; ch -- ) \n av_free ( audio [ ch ] ) ; \n av_free ( audio ) ; \n return NULL ; \n } \n } \n return audio ; \n }", "idx": 1938}
{"project": "FFmpeg", "commit_id": "3caffb7d80f20c66d7d582ca3d23f80ad373ba0a", "target": 1, "func": "static int common_end ( AVCodecContext * avctx ) { \n FFV1Context * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> plane_count ; i ++ ) { \n PlaneContext * p = & s -> plane [ i ] ; \n av_freep ( & p -> state ) ; \n } \n return 0 ; \n }", "idx": 1941}
{"project": "FFmpeg", "commit_id": "0ffea3565700c9b3093ead285f729bb319a2163e", "target": 1, "func": "int av_stream_add_side_data ( AVStream * st , enum AVPacketSideDataType type , \n uint8_t * data , size_t size ) \n { \n AVPacketSideData * sd , * tmp ; \n int i ; \n for ( i = 0 ; i < st -> nb_side_data ; i ++ ) { \n sd = & st -> side_data [ i ] ; \n if ( sd -> type == type ) { \n av_freep ( & sd -> data ) ; \n sd -> data = data ; \n sd -> size = size ; \n return 0 ; \n } \n } \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n return AVERROR ( ENOMEM ) ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = type ; \n sd -> data = data ; \n sd -> size = size ; \n return 0 ; \n }", "idx": 1944}
{"project": "FFmpeg", "commit_id": "7c845450d2daa0d066045cf94ab51cb496f1b824", "target": 1, "func": "int ff_eval_refl ( int * refl , const int16_t * coefs , AVCodecContext * avctx ) \n { \n int b , i , j ; \n int buffer1 [ LPC_ORDER ] ; \n int buffer2 [ LPC_ORDER ] ; \n int * bp1 = buffer1 ; \n int * bp2 = buffer2 ; \n for ( i = 0 ; i < LPC_ORDER ; i ++ ) \n buffer2 [ i ] = coefs [ i ] ; \n refl [ LPC_ORDER - 1 ] = bp2 [ LPC_ORDER - 1 ] ; \n if ( ( unsigned ) bp2 [ LPC_ORDER - 1 ] + 0x1000 > 0x1fff ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 1 ; \n } \n for ( i = LPC_ORDER - 2 ; i >= 0 ; i -- ) { \n b = 0x1000 - ( ( bp2 [ i + 1 ] * bp2 [ i + 1 ] ) >> 12 ) ; \n if ( ! b ) \n b = -2 ; \n b = 0x1000000 / b ; \n for ( j = 0 ; j <= i ; j ++ ) { \n #if CONFIG_FTRAPV  \n  \n  int a = bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) >> 12 ) ; \n if ( ( int ) ( a * ( unsigned ) b ) != a * ( int64_t ) b ) \n return 1 ; \n #endif \n bp1 [ j ] = ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) >> 12 ) ) * b ) >> 12 ; \n } \n if ( ( unsigned ) bp1 [ i ] + 0x1000 > 0x1fff ) \n return 1 ; \n refl [ i ] = bp1 [ i ] ; \n FFSWAP ( int * , bp1 , bp2 ) ; \n } \n return 0 ; \n }", "idx": 1953}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n #ifdef HAVE_MMXFIXME \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 1961}
{"project": "FFmpeg", "commit_id": "de0587739011b7636743251a86d48bcd10ab7c22", "target": 0, "func": "static av_cold int source_init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n Frei0rContext * frei0r = ctx -> priv ; \n char dl_name [ 1024 ] , c ; \n char frame_size [ 128 ] = \" \" ; \n char frame_rate [ 128 ] = \" \" ; \n AVRational frame_rate_q ; \n memset ( frei0r -> params , 0 , sizeof ( frei0r -> params ) ) ; \n if ( args ) \n sscanf ( args , \" \" , \n frame_size , frame_rate , dl_name , & c , frei0r -> params ) ; \n if ( av_parse_video_size ( & frei0r -> w , & frei0r -> h , frame_size ) < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , frame_size ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( av_parse_video_rate ( & frame_rate_q , frame_rate ) < 0 || \n frame_rate_q . den <= 0 || frame_rate_q . num <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , frame_rate ) ; \n return AVERROR ( EINVAL ) ; \n } \n frei0r -> time_base . num = frame_rate_q . den ; \n frei0r -> time_base . den = frame_rate_q . num ; \n return frei0r_init ( ctx , dl_name , F0R_PLUGIN_TYPE_SOURCE ) ; \n }", "idx": 1962}
{"project": "FFmpeg", "commit_id": "0df9d0f4cbcb18006f9fde0502671f9ef293e2f2", "target": 1, "func": "static void dash_free ( AVFormatContext * s ) \n { \n DASHContext * c = s -> priv_data ; \n int i , j ; \n if ( c -> as ) { \n for ( i = 0 ; i < c -> nb_as ; i ++ ) \n av_dict_free ( & c -> as [ i ] . metadata ) ; \n av_freep ( & c -> as ) ; \n c -> nb_as = 0 ; \n } \n if ( ! c -> streams ) \n return ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n OutputStream * os = & c -> streams [ i ] ; \n if ( os -> ctx && os -> ctx_inited ) \n av_write_trailer ( os -> ctx ) ; \n if ( os -> ctx && os -> ctx -> pb ) \n ffio_free_dyn_buf ( & os -> ctx -> pb ) ; \n ff_format_io_close ( s , & os -> out ) ; \n if ( os -> ctx ) \n avformat_free_context ( os -> ctx ) ; \n for ( j = 0 ; j < os -> nb_segments ; j ++ ) \n av_free ( os -> segments [ j ] ) ; \n av_free ( os -> segments ) ; \n } \n av_freep ( & c -> streams ) ; \n }", "idx": 1964}
{"project": "FFmpeg", "commit_id": "0fca8d24ee00284652eecedaa1f922641cdc59b1", "target": 1, "func": "void ff_wms_parse_sdp_a_line ( AVFormatContext * s , const char * p ) \n { \n if ( av_strstart ( p , \" \" , & p ) ) { \n ByteIOContext pb ; \n RTSPState * rt = s -> priv_data ; \n int len = strlen ( p ) * 6 / 8 ; \n char * buf = av_mallocz ( len ) ; \n av_base64_decode ( buf , p , len ) ; \n if ( rtp_asf_fix_header ( buf , len ) < 0 ) \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n init_packetizer ( & pb , buf , len ) ; \n if ( rt -> asf_ctx ) { \n av_close_input_stream ( rt -> asf_ctx ) ; \n rt -> asf_ctx = NULL ; \n } \n av_open_input_stream ( & rt -> asf_ctx , & pb , \" \" , & asf_demuxer , NULL ) ; \n rt -> asf_pb_pos = url_ftell ( & pb ) ; \n av_free ( buf ) ; \n rt -> asf_ctx -> pb = NULL ; \n } \n }", "idx": 1966}
{"project": "FFmpeg", "commit_id": "fd7a7e11b94b12259c6f1e375da15298cbc37e83", "target": 1, "func": "static int vsink_query_formats ( AVFilterContext * ctx ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterFormats * formats = NULL ; \n unsigned i ; \n int ret ; \n CHECK_LIST_SIZE ( pixel_fmts ) \n if ( buf -> pixel_fmts_size ) { \n for ( i = 0 ; i < NB_ITEMS ( buf -> pixel_fmts ) ; i ++ ) \n if ( ( ret = ff_add_format ( & formats , buf -> pixel_fmts [ i ] ) ) < 0 ) \n return ret ; \n ff_set_common_formats ( ctx , formats ) ; \n } else  { \n ff_default_query_formats ( ctx ) ; \n } \n return 0 ; \n }", "idx": 1968}
{"project": "FFmpeg", "commit_id": "dbe94539469b6d5113b37ea45eaf69ddbe34154e", "target": 0, "func": "static void opt_qscale ( const char * arg ) \n { \n video_qscale = atof ( arg ) ; \n if ( video_qscale <= 0 || \n video_qscale > 255 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n }", "idx": 1984}
{"project": "FFmpeg", "commit_id": "2b0112d42d4dfc8976be20b4d9729c0e077146c6", "target": 0, "func": "static int multiple_resample ( ResampleContext * c , AudioData * dst , int dst_size , AudioData * src , int src_size , int * consumed ) { \n int i , ret = -1 ; \n int av_unused mm_flags = av_get_cpu_flags ( ) ; \n int need_emms = c -> format == AV_SAMPLE_FMT_S16P && ARCH_X86_32 && \n ( mm_flags & ( AV_CPU_FLAG_MMX2 | AV_CPU_FLAG_SSE2 ) ) == AV_CPU_FLAG_MMX2 ; \n int64_t max_src_size = ( INT64_MAX / 2 / c -> phase_count ) / c -> src_incr ; \n if ( c -> compensation_distance ) \n dst_size = FFMIN ( dst_size , c -> compensation_distance ) ; \n src_size = FFMIN ( src_size , max_src_size ) ; \n for ( i = 0 ; i < dst -> ch_count ; i ++ ) { \n ret = swri_resample ( c , dst -> ch [ i ] , src -> ch [ i ] , \n consumed , src_size , dst_size , i + 1 == dst -> ch_count ) ; \n } \n if ( need_emms ) \n emms_c ( ) ; \n if ( c -> compensation_distance ) { \n c -> compensation_distance -= ret ; \n if ( ! c -> compensation_distance ) { \n c -> dst_incr = c -> ideal_dst_incr ; \n c -> dst_incr_div = c -> dst_incr / c -> src_incr ; \n c -> dst_incr_mod = c -> dst_incr % c -> src_incr ; \n } \n } \n return ret ; \n }", "idx": 1985}
{"project": "FFmpeg", "commit_id": "1bd280f73076b7a58371585b95b08379f2445332", "target": 1, "func": "static int try_decode_frame ( AVStream * st , AVPacket * avpkt ) \n { \n int16_t * samples ; \n AVCodec * codec ; \n int got_picture , data_size , ret = 0 ; \n AVFrame picture ; \n if ( ! st -> codec -> codec ) { \n codec = avcodec_find_decoder ( st -> codec -> codec_id ) ; \n if ( ! codec ) \n return -1 ; \n ret = avcodec_open ( st -> codec , codec ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( ! has_codec_parameters ( st -> codec ) ) { \n switch ( st -> codec -> codec_type ) { \n case CODEC_TYPE_VIDEO : \n ret = avcodec_decode_video2 ( st -> codec , & picture , \n & got_picture , avpkt ) ; \n break ; \n case CODEC_TYPE_AUDIO : \n data_size = FFMAX ( avpkt -> size , AVCODEC_MAX_AUDIO_FRAME_SIZE ) ; \n samples = av_malloc ( data_size ) ; \n if ( ! samples ) \n goto fail ; \n ret = avcodec_decode_audio3 ( st -> codec , samples , \n & data_size , avpkt ) ; \n av_free ( samples ) ; \n break ; \n default : \n break ; \n } \n } \n fail : \n return ret ; \n }", "idx": 1995}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static void IMLT ( float * pInput , float * pOutput , int odd_band ) \n { \n int i ; \n if ( odd_band ) { \n for ( i = 0 ; i < 128 ; i ++ ) \n FFSWAP ( float , pInput [ i ] , pInput [ 255 - i ] ) ; \n } \n ff_imdct_calc ( & mdct_ctx , pOutput , pInput ) ; \n dsp . vector_fmul ( pOutput , mdct_window , 512 ) ; \n }", "idx": 2001}
{"project": "FFmpeg", "commit_id": "3eae34d50fc52ff7b8367f9ade1cd189bfc1a221", "target": 1, "func": "static void mxf_write_generic_sound_common ( AVFormatContext * s , AVStream * st , const UID key , unsigned size ) \n { \n AVIOContext * pb = s -> pb ; \n mxf_write_generic_desc ( s , st , key , size + 5 + 12 + 8 + 8 ) ; \n mxf_write_local_tag ( pb , 1 , 0x3D02 ) ; \n avio_w8 ( pb , 1 ) ; \n mxf_write_local_tag ( pb , 8 , 0x3D03 ) ; \n avio_wb32 ( pb , st -> codec -> sample_rate ) ; \n avio_wb32 ( pb , 1 ) ; \n mxf_write_local_tag ( pb , 4 , 0x3D07 ) ; \n avio_wb32 ( pb , st -> codec -> channels ) ; \n mxf_write_local_tag ( pb , 4 , 0x3D01 ) ; \n avio_wb32 ( pb , av_get_bits_per_sample ( st -> codec -> codec_id ) ) ; \n }", "idx": 2003}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static void mpeg_decode_quant_matrix_extension ( MpegEncContext * s ) \n { \n int i , v , j ; \n dprintf ( \" \\n \" ) ; \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> intra_matrix [ j ] = v ; \n s -> chroma_intra_matrix [ j ] = v ; \n } \n } \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> non_intra_matrix [ j ] = v ; \n s -> chroma_non_intra_matrix [ j ] = v ; \n } \n } \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> chroma_intra_matrix [ j ] = v ; \n } \n } \n if ( get_bits1 ( & s -> gb ) ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n v = get_bits ( & s -> gb , 8 ) ; \n j = zigzag_direct [ i ] ; \n s -> chroma_non_intra_matrix [ j ] = v ; \n } \n } \n }", "idx": 2004}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgev ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 2008}
{"project": "FFmpeg", "commit_id": "919c320f7226bf873a9148e1db8994745f9d425d", "target": 1, "func": "static void ogg_write_pages ( AVFormatContext * s , int flush ) \n { \n OGGContext * ogg = s -> priv_data ; \n OGGPageList * next , * p ; \n if ( ! ogg -> page_list ) \n return ; \n for ( p = ogg -> page_list ; p ; ) { \n OGGStreamContext * oggstream = \n s -> streams [ p -> page . stream_index ] -> priv_data ; \n if ( oggstream -> page_count < 2 && ! flush ) \n break ; \n ogg_write_page ( s , & p -> page , \n flush && oggstream -> page_count == 1 ? 4 : 0 ) ; \n next = p -> next ; \n av_freep ( & p ) ; \n p = next ; \n } \n ogg -> page_list = p ; \n }", "idx": 2025}
{"project": "FFmpeg", "commit_id": "8cd8c8331730fbaac5066bfd66e15b39a85ce537", "target": 1, "func": "static void get_lag ( float * buf , const float * new , LongTermPrediction * ltp ) \n { \n int i , j , lag , max_corr = 0 ; \n float max_ratio ; \n for ( i = 0 ; i < 2048 ; i ++ ) { \n float corr , s0 = 0.0f , s1 = 0.0f ; \n const int start = FFMAX ( 0 , i - 1024 ) ; \n for ( j = start ; j < 2048 ; j ++ ) { \n const int idx = j - i + 1024 ; \n s0 += new [ j ] * buf [ idx ] ; \n s1 += buf [ idx ] * buf [ idx ] ; \n } \n corr = s1 > 0.0f ? s0 / sqrt ( s1 ) : 0.0f ; \n if ( corr > max_corr ) { \n max_corr = corr ; \n lag = i ; \n max_ratio = corr / ( 2048 - start ) ; \n } \n } \n ltp -> lag = FFMAX ( av_clip_uintp2 ( lag , 11 ) , 0 ) ; \n ltp -> coef_idx = quant_array_idx ( max_ratio , ltp_coef , 8 ) ; \n ltp -> coef = ltp_coef [ ltp -> coef_idx ] ; \n }", "idx": 2026}
{"project": "FFmpeg", "commit_id": "67fa02ed794f9505bd9c3584c14bfb61c895f5bc", "target": 0, "func": "static inline uint32_t celt_icwrsi ( uint32_t N , const int * y ) \n { \n int i , idx = 0 , sum = 0 ; \n for ( i = N - 1 ; i >= 0 ; i -- ) { \n const uint32_t i_s = CELT_PVQ_U ( N - i , sum + FFABS ( y [ i ] ) + 1 ) ; \n idx += CELT_PVQ_U ( N - i , sum ) + ( y [ i ] < 0 ) * i_s ; \n sum += FFABS ( y [ i ] ) ; \n } \n return idx ; \n }", "idx": 2038}
{"project": "FFmpeg", "commit_id": "b615dbb319fc1748af6ea0ac95b5f89e03c5de0e", "target": 0, "func": "static void dump_metadata ( void * ctx , AVDictionary * m , const char * indent ) \n { \n if ( m && ! ( m -> count == 1 && av_dict_get ( m , \" \" , NULL , 0 ) ) ) { \n AVDictionaryEntry * tag = NULL ; \n av_log ( ctx , AV_LOG_INFO , \" \\n \" , indent ) ; \n while ( ( tag = av_dict_get ( m , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) { \n if ( strcmp ( \" \" , tag -> key ) ) { \n const char * p = tag -> value ; \n av_log ( ctx , AV_LOG_INFO , \" \" , indent , tag -> key ) ; \n while ( * p ) { \n char tmp [ 256 ] ; \n size_t len = strcspn ( p , \" x d x a \" ) ; \n av_strlcpy ( tmp , p , FFMIN ( sizeof ( tmp ) , len + 1 ) ) ; \n av_log ( ctx , AV_LOG_INFO , \" \" , tmp ) ; \n p += len ; \n if ( * p == 0xd ) av_log ( ctx , AV_LOG_INFO , \" \" ) ; \n if ( * p == 0xa ) av_log ( ctx , AV_LOG_INFO , \" \\n \" , indent , \" \" ) ; \n if ( * p ) p ++ ; \n } \n av_log ( ctx , AV_LOG_INFO , \" \\n \" ) ; \n } \n } \n } \n }", "idx": 2071}
{"project": "FFmpeg", "commit_id": "d4ec07dfe7dbc86e8f6403781c511b9463a526d2", "target": 0, "func": "int av_utf8_decode ( int32_t * codep , const uint8_t * * bufp , const uint8_t * buf_end , \n unsigned int flags ) \n { \n const uint8_t * p = * bufp ; \n uint32_t top ; \n uint64_t code ; \n int ret = 0 ; \n if ( p >= buf_end ) \n return 0 ; \n code = * p ++ ; \n if ( ( code & 0xc0 ) == 0x80 || code >= 0xFE ) { \n ret = AVERROR ( EILSEQ ) ; \n goto end ; \n } \n top = ( code & 128 ) >> 1 ; \n while ( code & top ) { \n int tmp ; \n if ( p >= buf_end ) { \n ( * bufp ) ++ ; \n return AVERROR ( EILSEQ ) ; \n } \n tmp = * p ++ - 128 ; \n if ( tmp >> 6 ) { \n ( * bufp ) ++ ; \n return AVERROR ( EILSEQ ) ; \n } \n code = ( code << 6 ) + tmp ; \n top <<= 5 ; \n } \n code &= ( top << 1 ) - 1 ; \n if ( code >= 1 << 31 ) { \n ret = AVERROR ( EILSEQ ) ; \n goto end ; \n } \n * codep = code ; \n if ( code > 0x10FFFF && \n ! ( flags & AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES ) ) \n ret = AVERROR ( EILSEQ ) ; \n if ( code < 0x20 && code != 0x9 && code != 0xA && code != 0xD && \n flags & AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES ) \n ret = AVERROR ( EILSEQ ) ; \n if ( code >= 0xD800 && code <= 0xDFFF && \n ! ( flags & AV_UTF8_FLAG_ACCEPT_SURROGATES ) ) \n ret = AVERROR ( EILSEQ ) ; \n if ( ( code == 0xFFFE || code == 0xFFFF ) && \n ! ( flags & AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS ) ) \n ret = AVERROR ( EILSEQ ) ; \n end : \n * bufp = p ; \n return ret ; \n }", "idx": 2090}
{"project": "FFmpeg", "commit_id": "7e240f95818310ed721321e62130aa1c69f9cbe6", "target": 1, "func": "static MatroskaLevel1Element * matroska_find_level1_elem ( MatroskaDemuxContext * matroska , \n uint32_t id ) \n { \n int i ; \n MatroskaLevel1Element * elem ; \n if ( id == MATROSKA_ID_CLUSTER ) \n if ( id != MATROSKA_ID_SEEKHEAD ) { \n for ( i = 0 ; i < matroska -> num_level1_elems ; i ++ ) { \n if ( matroska -> level1_elems [ i ] . id == id ) \n return & matroska -> level1_elems [ i ] ; \n } \n } \n if ( matroska -> num_level1_elems >= FF_ARRAY_ELEMS ( matroska -> level1_elems ) ) { \n av_log ( matroska -> ctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n elem = & matroska -> level1_elems [ matroska -> num_level1_elems ++ ] ; \n * elem = ( MatroskaLevel1Element ) { . id = id } ; \n return elem ; \n }", "idx": 2099}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_phys_chunk ( AVCodecContext * avctx , PNGDecContext * s ) \n { \n if ( s -> state & PNG_IDAT ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> sample_aspect_ratio . num = bytestream2_get_be32 ( & s -> gb ) ; \n avctx -> sample_aspect_ratio . den = bytestream2_get_be32 ( & s -> gb ) ; \n if ( avctx -> sample_aspect_ratio . num < 0 || avctx -> sample_aspect_ratio . den < 0 ) \n avctx -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n bytestream2_skip ( & s -> gb , 1 ) ; \n bytestream2_skip ( & s -> gb , 4 ) ; \n return 0 ; \n }", "idx": 2103}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static av_cold int dct_init ( MpegEncContext * s ) \n { \n ff_blockdsp_init ( & s -> bdsp , s -> avctx ) ; \n ff_hpeldsp_init ( & s -> hdsp , s -> avctx -> flags ) ; \n ff_me_cmp_init ( & s -> mecc , s -> avctx ) ; \n ff_mpegvideodsp_init ( & s -> mdsp ) ; \n ff_videodsp_init ( & s -> vdsp , s -> avctx -> bits_per_raw_sample ) ; \n s -> dct_unquantize_h263_intra = dct_unquantize_h263_intra_c ; \n s -> dct_unquantize_h263_inter = dct_unquantize_h263_inter_c ; \n s -> dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_c ; \n s -> dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_c ; \n s -> dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_c ; \n if ( s -> flags & CODEC_FLAG_BITEXACT ) \n s -> dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_bitexact ; \n s -> dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_c ; \n if ( HAVE_INTRINSICS_NEON ) \n ff_mpv_common_init_neon ( s ) ; \n if ( ARCH_ARM ) \n ff_mpv_common_init_arm ( s ) ; \n if ( ARCH_PPC ) \n ff_mpv_common_init_ppc ( s ) ; \n if ( ARCH_X86 ) \n ff_mpv_common_init_x86 ( s ) ; \n return 0 ; \n }", "idx": 2106}
{"project": "FFmpeg", "commit_id": "f41e37b84f3d57c29d4a2a21f9337159135b981d", "target": 0, "func": "int ff_dirac_golomb_read_32bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int32_t * dst = ( int32_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res ) ; \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n SET_RESIDUE ( res , 0 , 0 ) ; \n } \n memcpy ( & dst [ c_idx ] , l -> ready , LUT_BITS * sizeof ( int32_t ) ) ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 2109}
{"project": "FFmpeg", "commit_id": "cbf09545f250a4bd12c50c3a96fe481098ab2d49", "target": 0, "func": "static void imc_get_coeffs ( AVCodecContext * avctx , \n IMCContext * q , IMCChannel * chctx ) \n { \n int i , j , cw_len , cw ; \n for ( i = 0 ; i < BANDS ; i ++ ) { \n if ( ! chctx -> sumLenArr [ i ] ) \n continue ; \n if ( chctx -> bandFlagsBuf [ i ] || chctx -> bandWidthT [ i ] ) { \n for ( j = band_tab [ i ] ; j < band_tab [ i + 1 ] ; j ++ ) { \n cw_len = chctx -> CWlengthT [ j ] ; \n cw = 0 ; \n if ( get_bits_count ( & q -> gb ) + cw_len > 512 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" , i , j , cw_len ) ; \n } \n if ( cw_len && ( ! chctx -> bandFlagsBuf [ i ] || ! chctx -> skipFlags [ j ] ) ) \n cw = get_bits ( & q -> gb , cw_len ) ; \n chctx -> codewords [ j ] = cw ; \n } \n } \n } \n }", "idx": 2119}
{"project": "FFmpeg", "commit_id": "ea382767ad2191acbe97e90624059723e15f0e4b", "target": 0, "func": "void ff_generate_sliding_window_mmcos ( H264Context * h , int first_slice ) \n { \n MpegEncContext * const s = & h -> s ; \n MMCO mmco_temp [ MAX_MMCO_COUNT ] , * mmco = first_slice ? h -> mmco : mmco_temp ; \n int mmco_index = 0 , i ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n if ( h -> short_ref_count && \n h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE && ! s -> first_field && \n s -> current_picture_ptr -> f . reference ) ) { \n mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n mmco_index = 1 ; \n if ( FIELD_PICTURE ) { \n mmco [ 0 ] . short_pic_num *= 2 ; \n mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 1 ] . short_pic_num = mmco [ 0 ] . short_pic_num + 1 ; \n mmco_index = 2 ; \n } \n } \n if ( first_slice ) { \n h -> mmco_index = mmco_index ; \n } else if ( ! first_slice && mmco_index >= 0 && \n ( mmco_index != h -> mmco_index || \n ( i = check_opcodes ( h -> mmco , mmco_temp , mmco_index ) ) ) ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \n \" \\n \" , \n mmco_index , h -> mmco_index , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 2121}
{"project": "FFmpeg", "commit_id": "745f4bcc2c1deaa562cce01fa52e38b0220aed31", "target": 0, "func": "static void draw_bar ( TestSourceContext * test , const uint8_t color [ 4 ] , \n int x , int y , int w , int h , \n AVFrame * frame ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n uint8_t * p , * p0 ; \n int plane ; \n x = FFMIN ( x , test -> w - 1 ) ; \n y = FFMIN ( y , test -> h - 1 ) ; \n w = FFMIN ( w , test -> w - x ) ; \n h = FFMIN ( h , test -> h - y ) ; \n av_assert0 ( x + w <= test -> w ) ; \n av_assert0 ( y + h <= test -> h ) ; \n for ( plane = 0 ; frame -> data [ plane ] ; plane ++ ) { \n const int c = color [ plane ] ; \n const int linesize = frame -> linesize [ plane ] ; \n int i , px , py , pw , ph ; \n if ( plane == 1 || plane == 2 ) { \n px = x >> desc -> log2_chroma_w ; \n pw = AV_CEIL_RSHIFT ( w , desc -> log2_chroma_w ) ; \n py = y >> desc -> log2_chroma_h ; \n ph = AV_CEIL_RSHIFT ( h , desc -> log2_chroma_h ) ; \n } else { \n px = x ; \n pw = w ; \n py = y ; \n ph = h ; \n } \n p0 = p = frame -> data [ plane ] + py * linesize + px ; \n memset ( p , c , pw ) ; \n p += linesize ; \n for ( i = 1 ; i < ph ; i ++ , p += linesize ) \n memcpy ( p , p0 , pw ) ; \n } \n }", "idx": 2159}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_cabac_states ( const H264Context * h , H264SliceContext * sl ) \n { \n int i ; \n const int8_t ( * tab ) [ 2 ] ; \n const int slice_qp = av_clip ( sl -> qscale - 6 * ( h -> sps . bit_depth_luma - 8 ) , 0 , 51 ) ; \n if ( sl -> slice_type_nos == AV_PICTURE_TYPE_I ) tab = cabac_context_init_I ; \n else tab = cabac_context_init_PB [ sl -> cabac_init_idc ] ; \n for ( i = 0 ; i < 1024 ; i ++ ) { \n int pre = 2 * ( ( ( tab [ i ] [ 0 ] * slice_qp ) >> 4 ) + tab [ i ] [ 1 ] ) - 127 ; \n pre ^= pre >> 31 ; \n if ( pre > 124 ) \n pre = 124 + ( pre & 1 ) ; \n sl -> cabac_state [ i ] = pre ; \n } \n }", "idx": 2176}
{"project": "FFmpeg", "commit_id": "4e240985d8b856e62e4e0377283138cf51cc398e", "target": 0, "func": "static int mov_read_udta ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n uint64_t end = url_ftell ( pb ) + atom . size ; \n while ( url_ftell ( pb ) + 8 < end ) { \n uint32_t tag_size = get_be32 ( pb ) ; \n uint32_t tag = get_le32 ( pb ) ; \n uint64_t next = url_ftell ( pb ) + tag_size - 8 ; \n if ( next > end ) \n break ; \n switch ( tag ) { \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> title , sizeof ( c -> fc -> title ) ) ; \n break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> author , sizeof ( c -> fc -> author ) ) ; \n break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> copyright , sizeof ( c -> fc -> copyright ) ) ; \n break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n mov_parse_udta_string ( pb , c -> fc -> comment , sizeof ( c -> fc -> comment ) ) ; \n break ; \n default : \n break ; \n } \n url_fseek ( pb , next , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 2177}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int MPA_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n MpegAudioContext * s = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n short smr [ MPA_MAX_CHANNELS ] [ SBLIMIT ] ; \n unsigned char bit_alloc [ MPA_MAX_CHANNELS ] [ SBLIMIT ] ; \n int padding , i , ret ; \n for ( i = 0 ; i < s -> nb_channels ; i ++ ) { \n filter ( s , i , samples + i , s -> nb_channels ) ; \n } \n for ( i = 0 ; i < s -> nb_channels ; i ++ ) { \n compute_scale_factors ( s , s -> scale_code [ i ] , s -> scale_factors [ i ] , \n s -> sb_samples [ i ] , s -> sblimit ) ; \n } \n for ( i = 0 ; i < s -> nb_channels ; i ++ ) { \n psycho_acoustic_model ( s , smr [ i ] ) ; \n } \n compute_bit_allocation ( s , smr , bit_alloc , & padding ) ; \n if ( ( ret = ff_alloc_packet ( avpkt , MPA_MAX_CODED_FRAME_SIZE ) ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n init_put_bits ( & s -> pb , avpkt -> data , avpkt -> size ) ; \n encode_frame ( s , bit_alloc , padding ) ; \n if ( frame -> pts != AV_NOPTS_VALUE ) \n avpkt -> pts = frame -> pts - ff_samples_to_time_base ( avctx , avctx -> delay ) ; \n avpkt -> size = put_bits_count ( & s -> pb ) / 8 ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 2198}
{"project": "FFmpeg", "commit_id": "dddc9b7a8ec3a03e48c69991ca7f20f10dd6f022", "target": 0, "func": "static int parse_ptl ( HEVCContext * s , PTL * ptl , int max_num_sub_layers ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n decode_profile_tier_level ( s , & ptl -> general_PTL ) ; \n ptl -> general_PTL . level_idc = get_bits ( gb , 8 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n ptl -> sub_layer_profile_present_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> sub_layer_level_present_flag [ i ] = get_bits1 ( gb ) ; \n } \n if ( max_num_sub_layers - 1 > 0 ) \n for ( i = max_num_sub_layers - 1 ; i < 8 ; i ++ ) \n skip_bits ( gb , 2 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n if ( ptl -> sub_layer_profile_present_flag [ i ] ) \n decode_profile_tier_level ( s , & ptl -> sub_layer_PTL [ i ] ) ; \n if ( ptl -> sub_layer_level_present_flag [ i ] ) \n ptl -> sub_layer_PTL [ i ] . level_idc = get_bits ( gb , 8 ) ; \n } \n return 0 ; \n }", "idx": 2200}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add4_mmx2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 4 ) { \n int nnz = nnzc [ scan8 [ i ] ] ; \n if ( nnz ) { \n if ( nnz == 1 && block [ i * 16 ] ) ff_h264_idct8_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else ff_h264_idct8_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n } \n }", "idx": 2202}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static void update ( Real288_internal * glob ) \n { \n float buffer1 [ 40 ] , temp1 [ 37 ] ; \n float buffer2 [ 8 ] , temp2 [ 11 ] ; \n memcpy ( buffer1 , glob -> output + 20 , 20 * sizeof ( * buffer1 ) ) ; \n memcpy ( buffer1 + 20 , glob -> output , 20 * sizeof ( * buffer1 ) ) ; \n do_hybrid_window ( 36 , 40 , 35 , buffer1 , temp1 , glob -> st1a , glob -> st1b , \n syn_window ) ; \n if ( eval_lpc_coeffs ( temp1 , glob -> st1 , 36 ) ) \n colmult ( glob -> pr1 , glob -> st1 , table1a , 36 ) ; \n memcpy ( buffer2 , glob -> history + 4 , 4 * sizeof ( * buffer2 ) ) ; \n memcpy ( buffer2 + 4 , glob -> history , 4 * sizeof ( * buffer2 ) ) ; \n do_hybrid_window ( 10 , 8 , 20 , buffer2 , temp2 , glob -> st2a , glob -> st2b , \n gain_window ) ; \n if ( eval_lpc_coeffs ( temp2 , glob -> st2 , 10 ) ) \n colmult ( glob -> pr2 , glob -> st2 , table2a , 10 ) ; \n }", "idx": 2204}
{"project": "FFmpeg", "commit_id": "c661cb6672af5ebcb900ec8766b24761bd2ab011", "target": 0, "func": "int avconv_parse_options ( int argc , char * * argv ) \n { \n OptionParseContext octx ; \n uint8_t error [ 128 ] ; \n int ret ; \n memset ( & octx , 0 , sizeof ( octx ) ) ; \n ret = split_commandline ( & octx , argc , argv , options , groups ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n ret = parse_optgroup ( NULL , & octx . global_opts ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n ret = open_files ( & octx . groups [ GROUP_INFILE ] , \" \" , open_input_file ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n ret = open_files ( & octx . groups [ GROUP_OUTFILE ] , \" \" , open_output_file ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" ) ; \n goto fail ; \n } \n fail : \n uninit_parse_context ( & octx ) ; \n if ( ret < 0 ) { \n av_strerror ( ret , error , sizeof ( error ) ) ; \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , error ) ; \n } \n return ret ; \n }", "idx": 2210}
{"project": "FFmpeg", "commit_id": "1e6ee86d9254e8fd2158cc9a31d3be96b0809411", "target": 1, "func": "static inline void scale_mv ( AVSContext * h , int * d_x , int * d_y , \n cavs_vector * src , int distp ) \n { \n int den = h -> scale_den [ FFMAX ( src -> ref , 0 ) ] ; \n * d_x = ( src -> x * distp * den + 256 + FF_SIGNBIT ( src -> x ) ) >> 9 ; \n * d_y = ( src -> y * distp * den + 256 + FF_SIGNBIT ( src -> y ) ) >> 9 ; \n }", "idx": 2212}
{"project": "FFmpeg", "commit_id": "f8a9cf77040e1b2ed83206269ead11aa30afb98d", "target": 1, "func": "static int lvf_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return AVPROBE_SCORE_EXTENSION ; \n return 0 ; \n }", "idx": 2220}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static unsigned int get_video_format_idx ( AVCodecContext * avctx ) \n { \n unsigned int ret_idx = 0 ; \n unsigned int idx ; \n unsigned int num_formats = sizeof ( ff_schro_video_format_info ) / \n sizeof ( ff_schro_video_format_info [ 0 ] ) ; \n for ( idx = 1 ; idx < num_formats ; ++ idx ) { \n const SchroVideoFormatInfo * vf = & ff_schro_video_format_info [ idx ] ; \n if ( avctx -> width == vf -> width && \n avctx -> height == vf -> height ) { \n ret_idx = idx ; \n if ( avctx -> time_base . den == vf -> frame_rate_num && \n avctx -> time_base . num == vf -> frame_rate_denom ) \n return idx ; \n } \n } \n return ret_idx ; \n }", "idx": 2228}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_pts_dts ( AVStream * st , int64_t * ppts , int64_t * pdts , \n int64_t timestamp ) \n { \n int frame_delay ; \n int64_t pts , dts ; \n if ( st -> codec . codec_type == CODEC_TYPE_VIDEO && \n st -> codec . max_b_frames != 0 ) { \n frame_delay = ( st -> codec . frame_rate_base * 90000LL ) / \n st -> codec . frame_rate ; \n if ( timestamp == 0 ) { \n pts = timestamp ; \n dts = timestamp - frame_delay ; \n } else { \n timestamp -= frame_delay ; \n if ( st -> codec . coded_frame -> pict_type == FF_B_TYPE ) { \n pts = timestamp ; \n dts = timestamp ; \n } else { \n dts = timestamp ; \n pts = timestamp + ( st -> codec . max_b_frames + 1 ) * frame_delay ; \n } \n } \n #if 1  \n  \n  av_log ( & st -> codec , AV_LOG_DEBUG , \" \\n \" , \n pts / 90000.0 , dts / 90000.0 , \n av_get_pict_type_char ( st -> codec . coded_frame -> pict_type ) ) ; \n #endif \n } else { \n pts = timestamp ; \n dts = timestamp ; \n } \n * ppts = pts & ( ( 1LL << 33 ) - 1 ) ; \n * pdts = dts & ( ( 1LL << 33 ) - 1 ) ; \n }", "idx": 2230}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) \n { \n if ( pic -> f . buf [ 0 ] == NULL ) \n return 1 ; \n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) \n return 1 ; \n return 0 ; \n }", "idx": 2240}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgev ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 2249}
{"project": "FFmpeg", "commit_id": "ef363ebd596da18f889a7d4845023a23dfac84c9", "target": 0, "func": "static void mp3_update_xing ( AVFormatContext * s ) \n { \n MP3Context * mp3 = s -> priv_data ; \n int i ; \n if ( ! mp3 -> has_variable_bitrate ) { \n avio_seek ( s -> pb , mp3 -> xing_offset , SEEK_SET ) ; \n ffio_wfourcc ( s -> pb , \" \" ) ; \n } \n avio_seek ( s -> pb , mp3 -> xing_offset + 8 , SEEK_SET ) ; \n avio_wb32 ( s -> pb , mp3 -> frames ) ; \n avio_wb32 ( s -> pb , mp3 -> size ) ; \n avio_w8 ( s -> pb , 0 ) ; \n for ( i = 1 ; i < XING_TOC_SIZE ; ++ i ) { \n int j = i * mp3 -> pos / XING_TOC_SIZE ; \n int seek_point = 256LL * mp3 -> bag [ j ] / mp3 -> size ; \n avio_w8 ( s -> pb , FFMIN ( seek_point , 255 ) ) ; \n } \n avio_seek ( s -> pb , 0 , SEEK_END ) ; \n }", "idx": 2251}
{"project": "FFmpeg", "commit_id": "1cb0edb40b8e94e1a50ad40c40d43e34ed8435fe", "target": 1, "func": "static void mpeg_decode_sequence_extension ( MpegEncContext * s ) \n { \n int horiz_size_ext , vert_size_ext ; \n int bit_rate_ext , vbv_buf_ext , low_delay ; \n int frame_rate_ext_n , frame_rate_ext_d ; \n skip_bits ( & s -> gb , 8 ) ; \n skip_bits ( & s -> gb , 1 ) ; \n skip_bits ( & s -> gb , 2 ) ; \n horiz_size_ext = get_bits ( & s -> gb , 2 ) ; \n vert_size_ext = get_bits ( & s -> gb , 2 ) ; \n s -> width |= ( horiz_size_ext << 12 ) ; \n s -> height |= ( vert_size_ext << 12 ) ; \n bit_rate_ext = get_bits ( & s -> gb , 12 ) ; \n s -> bit_rate = ( ( s -> bit_rate / 400 ) | ( bit_rate_ext << 12 ) ) * 400 ; \n skip_bits1 ( & s -> gb ) ; \n vbv_buf_ext = get_bits ( & s -> gb , 8 ) ; \n low_delay = get_bits1 ( & s -> gb ) ; \n frame_rate_ext_n = get_bits ( & s -> gb , 2 ) ; \n frame_rate_ext_d = get_bits ( & s -> gb , 5 ) ; \n if ( frame_rate_ext_d >= 1 ) \n s -> frame_rate = ( s -> frame_rate * frame_rate_ext_n ) / frame_rate_ext_d ; \n dprintf ( \" \\n \" ) ; \n s -> mpeg2 = 1 ; \n }", "idx": 2256}
{"project": "FFmpeg", "commit_id": "6f4e2b5a9564d012c05ba361020768c925dda5e1", "target": 1, "func": "static int vp3_decode_end ( AVCodecContext * avctx ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n int i ; \n av_free ( s -> superblock_coding ) ; \n av_free ( s -> all_fragments ) ; \n av_free ( s -> coeffs ) ; \n av_free ( s -> coded_fragment_list ) ; \n av_free ( s -> superblock_fragments ) ; \n av_free ( s -> superblock_macroblocks ) ; \n av_free ( s -> macroblock_fragments ) ; \n av_free ( s -> macroblock_coding ) ; \n if ( s -> golden_frame . data [ 0 ] && s -> golden_frame . data [ 0 ] != s -> last_frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> golden_frame ) ; \n if ( s -> last_frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> last_frame ) ; \n return 0 ; ", "idx": 2261}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int advanced_decode_i_mbs ( VC9Context * v ) \n { \n int i , x , y , cbpcy , mqdiff , absmq , mquant , ac_pred , condover , \n current_mb = 0 , over_flags_mb = 0 ; \n for ( y = 0 ; y < v -> height_mb ; y ++ ) \n { \n for ( x = 0 ; x < v -> width_mb ; x ++ ) \n { \n if ( v -> ac_pred_plane [ i ] ) \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n if ( condover == 3 && v -> over_flags_plane ) \n over_flags_mb = get_bits ( & v -> gb , 1 ) ; \n GET_MQUANT ( ) ; \n } \n current_mb ++ ; \n } \n return 0 ; \n }", "idx": 2282}
{"project": "FFmpeg", "commit_id": "6eed92a2b7977b7aa91554e9911106462681d242", "target": 0, "func": "static int delta_decode ( int8_t * dst , const uint8_t * src , int src_size , \n int8_t val , const int8_t * table ) \n { \n int n = src_size ; \n int8_t * dst0 = dst ; \n while ( n -- ) { \n uint8_t d = * src ++ ; \n val = av_clip ( val + table [ d & 0x0f ] , -127 , 128 ) ; \n * dst ++ = val ; \n val = av_clip ( val + table [ d >> 4 ] , -127 , 128 ) ; \n * dst ++ = val ; \n } \n return dst - dst0 ; \n }", "idx": 2299}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "void ff_jref_idct_put ( uint8_t * dest , ptrdiff_t line_size , int16_t * block ) \n { \n ff_j_rev_dct ( block ) ; \n ff_put_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 2304}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb16 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 2307}
{"project": "FFmpeg", "commit_id": "08b098169be079c4f124a351fda6764fbcd10e79", "target": 1, "func": "static av_cold void compute_alpha_vlcs ( void ) \n { \n uint16_t run_code [ 129 ] , level_code [ 256 ] ; \n uint8_t run_bits [ 129 ] , level_bits [ 256 ] ; \n int run , level ; \n for ( run = 0 ; run < 128 ; run ++ ) { \n if ( ! run ) { \n run_code [ run ] = 0 ; \n run_bits [ run ] = 1 ; \n } else if ( run <= 4 ) { \n run_code [ run ] = ( ( run - 1 ) << 2 ) | 1 ; \n run_bits [ run ] = 4 ; \n } else { \n run_code [ run ] = ( run << 3 ) | 7 ; \n run_bits [ run ] = 10 ; \n } \n } \n run_code [ 128 ] = 3 ; \n run_bits [ 128 ] = 3 ; \n INIT_LE_VLC_STATIC ( & ff_dc_alpha_run_vlc_le , ALPHA_VLC_BITS , 129 , \n run_bits , 1 , 1 , \n run_code , 2 , 2 , 160 ) ; \n for ( level = 0 ; level < 256 ; level ++ ) { \n int8_t signed_level = ( int8_t ) level ; \n int abs_signed_level = abs ( signed_level ) ; \n int sign = ( signed_level < 0 ) ? 1 : 0 ; \n if ( abs_signed_level == 1 ) { \n level_code [ level ] = ( sign << 1 ) | 1 ; \n level_bits [ level ] = 2 ; \n } else if ( abs_signed_level >= 2 && abs_signed_level <= 5 ) { \n level_code [ level ] = ( ( abs_signed_level - 2 ) << 3 ) | ( sign << 2 ) | 2 ; \n level_bits [ level ] = 5 ; \n } else { \n level_code [ level ] = level << 2 ; \n level_bits [ level ] = 10 ; \n } \n } \n INIT_LE_VLC_STATIC ( & ff_dc_alpha_level_vlc_le , ALPHA_VLC_BITS , 256 , \n level_bits , 1 , 1 , \n level_code , 2 , 2 , 288 ) ; \n }", "idx": 2322}
{"project": "FFmpeg", "commit_id": "5edea431d0616737e5a5f58cefc07ba5b2e0875f", "target": 1, "func": "int av_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret ; \n compute_pkt_fields2 ( s -> streams [ pkt -> stream_index ] , pkt ) ; \n truncate_ts ( s -> streams [ pkt -> stream_index ] , pkt ) ; \n ret = s -> oformat -> write_packet ( s , pkt ) ; \n if ( ! ret ) \n ret = url_ferror ( & s -> pb ) ; \n return ret ; \n }", "idx": 2324}
{"project": "FFmpeg", "commit_id": "6cf31ef263d36f6b89d9b64f15ca81cef4f24901", "target": 1, "func": "static void revert_cdlms ( WmallDecodeCtx * s , int tile_size ) \n { \n int icoef , ich ; \n int32_t pred , channel_coeff ; \n int ilms , num_lms ; \n for ( ich = 0 ; ich < s -> num_channels ; ich ++ ) { \n if ( ! s -> is_channel_coded [ ich ] ) \n continue ; \n for ( icoef = 0 ; icoef < tile_size ; icoef ++ ) { \n num_lms = s -> cdlms_ttl [ ich ] ; \n channel_coeff = s -> channel_residues [ ich ] [ icoef ] ; \n if ( icoef == s -> transient_pos [ ich ] ) { \n s -> transient [ ich ] = 1 ; \n use_high_update_speed ( s , ich ) ; \n } \n for ( ilms = num_lms ; ilms >= 0 ; ilms -- ) { \n pred = lms_predict ( s , ich , ilms ) ; \n channel_coeff += pred ; \n lms_update ( s , ich , ilms , channel_coeff , pred ) ; \n } \n if ( s -> transient [ ich ] ) { \n -- s -> channel [ ich ] . transient_counter ; \n if ( ! s -> channel [ ich ] . transient_counter ) \n use_normal_update_speed ( s , ich ) ; \n } \n s -> channel_coeffs [ ich ] [ icoef ] = channel_coeff ; \n } \n } \n }", "idx": 2327}
{"project": "FFmpeg", "commit_id": "89135716fd4c2963e01e0155547c47bf709f1aa3", "target": 1, "func": "av_cold void ff_mlpdsp_init_arm ( MLPDSPContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_armv5te ( cpu_flags ) ) { \n c -> mlp_filter_channel = ff_mlp_filter_channel_arm ; \n } \n }", "idx": 2347}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "SwsFunc yuv2rgb_init_mlib ( SwsContext * c ) \n { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB24 : return mlib_YUV2RGB420_24 ; \n case PIX_FMT_BGR32 : return mlib_YUV2ARGB420_32 ; \n case PIX_FMT_RGB32 : return mlib_YUV2ABGR420_32 ; \n default : return NULL ; \n } \n }", "idx": 2353}
{"project": "FFmpeg", "commit_id": "dc87758775e2ce8be84e4fe598e12416e83d2845", "target": 1, "func": "int ffio_ensure_seekback ( AVIOContext * s , int64_t buf_size ) \n { \n uint8_t * buffer ; \n int max_buffer_size = s -> max_packet_size ? \n s -> max_packet_size : IO_BUFFER_SIZE ; \n int filled = s -> buf_end - s -> buffer ; \n ptrdiff_t checksum_ptr_offset = s -> checksum_ptr ? s -> checksum_ptr - s -> buffer : -1 ; \n buf_size += s -> buf_ptr - s -> buffer + max_buffer_size ; \n if ( buf_size < filled || s -> seekable || ! s -> read_packet ) \n return 0 ; \n av_assert0 ( ! s -> write_flag ) ; \n buffer = av_malloc ( buf_size ) ; \n if ( ! buffer ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( buffer , s -> buffer , filled ) ; \n av_free ( s -> buffer ) ; \n s -> buf_ptr = buffer + ( s -> buf_ptr - s -> buffer ) ; \n s -> buf_end = buffer + ( s -> buf_end - s -> buffer ) ; \n s -> buffer = buffer ; \n s -> buffer_size = buf_size ; \n return 0 ; \n }", "idx": 2354}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv34_idct_dc_add_c ( uint8_t * dst , int stride , int dc ) \n { \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i , j ; \n cm += ( 13 * 13 * dc + 0x200 ) >> 10 ; \n for ( i = 0 ; i < 4 ; i ++ ) \n { \n for ( j = 0 ; j < 4 ; j ++ ) \n dst [ j ] = cm [ dst [ j ] ] ; \n dst += stride ; \n } \n }", "idx": 2357}
{"project": "FFmpeg", "commit_id": "4257b804e2354db07e66ebfd966d7d13f49c7895", "target": 0, "func": "static void pre_process_video_frame ( InputStream * ist , AVPicture * picture , void * * bufp ) \n { \n AVCodecContext * dec ; \n AVPicture * picture2 ; \n AVPicture picture_tmp ; \n uint8_t * buf = 0 ; \n dec = ist -> st -> codec ; \n if ( FF_API_DEINTERLACE && do_deinterlace ) { \n int size ; \n size = avpicture_get_size ( dec -> pix_fmt , dec -> width , dec -> height ) ; \n if ( size < 0 ) \n return ; \n buf = av_malloc ( size ) ; \n if ( ! buf ) \n return ; \n picture2 = & picture_tmp ; \n avpicture_fill ( picture2 , buf , dec -> pix_fmt , dec -> width , dec -> height ) ; \n if ( avpicture_deinterlace ( picture2 , picture , \n dec -> pix_fmt , dec -> width , dec -> height ) < 0 ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n av_free ( buf ) ; \n buf = NULL ; \n picture2 = picture ; \n } \n } else { \n picture2 = picture ; \n } \n if ( picture != picture2 ) \n * picture = * picture2 ; \n * bufp = buf ; \n }", "idx": 2364}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static uint8_t get_tlm ( Jpeg2000DecoderContext * s , int n ) \n { \n uint8_t Stlm , ST , SP , tile_tlm , i ; \n bytestream_get_byte ( & s -> buf ) ; \n Stlm = bytestream_get_byte ( & s -> buf ) ; \n ST = ( Stlm >> 4 ) & 0x03 ; \n SP = ( Stlm >> 6 ) & 0x01 ; \n tile_tlm = ( n - 4 ) / ( ( SP + 1 ) * 2 + ST ) ; \n for ( i = 0 ; i < tile_tlm ; i ++ ) { \n switch ( ST ) { \n case 0 : \n break ; \n case 1 : \n bytestream_get_byte ( & s -> buf ) ; \n break ; \n case 2 : \n bytestream_get_be16 ( & s -> buf ) ; \n break ; \n case 3 : \n bytestream_get_be32 ( & s -> buf ) ; \n break ; \n } \n if ( SP == 0 ) { \n bytestream_get_be16 ( & s -> buf ) ; \n } else { \n bytestream_get_be32 ( & s -> buf ) ; \n } \n } \n return 0 ; \n }", "idx": 2372}
{"project": "FFmpeg", "commit_id": "f9505923a344a56c3ff36925adb7f0c3c9a3996c", "target": 1, "func": "static int decode_seq_header ( AVSContext * h ) { \n MpegEncContext * s = & h -> s ; \n int frame_rate_code ; \n int width , height ; \n h -> profile = get_bits ( & s -> gb , 8 ) ; \n h -> level = get_bits ( & s -> gb , 8 ) ; \n skip_bits1 ( & s -> gb ) ; \n width = get_bits ( & s -> gb , 14 ) ; \n height = get_bits ( & s -> gb , 14 ) ; \n if ( ( s -> width || s -> height ) && ( s -> width != width || s -> height != height ) ) { \n av_log_missing_feature ( s , \" \" , 0 ) ; \n return -1 ; \n s -> width = width ; \n s -> height = height ; \n skip_bits ( & s -> gb , 2 ) ; \n skip_bits ( & s -> gb , 3 ) ; \n h -> aspect_ratio = get_bits ( & s -> gb , 4 ) ; \n frame_rate_code = get_bits ( & s -> gb , 4 ) ; \n skip_bits ( & s -> gb , 18 ) ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits ( & s -> gb , 12 ) ; \n s -> low_delay = get_bits1 ( & s -> gb ) ; \n h -> mb_width = ( s -> width + 15 ) >> 4 ; \n h -> mb_height = ( s -> height + 15 ) >> 4 ; \n h -> s . avctx -> time_base . den = avpriv_frame_rate_tab [ frame_rate_code ] . num ; \n h -> s . avctx -> time_base . num = avpriv_frame_rate_tab [ frame_rate_code ] . den ; \n h -> s . avctx -> width = s -> width ; \n h -> s . avctx -> height = s -> height ; \n if ( ! h -> top_qp ) \n ff_cavs_init_top_lines ( h ) ; \n return 0 ;", "idx": 2373}
{"project": "FFmpeg", "commit_id": "fe026ba960790a004adfcff33f44f96b05538e5c", "target": 0, "func": "static int draw_glyphs ( DrawTextContext * s , AVFrame * frame , \n int width , int height , \n const uint8_t rgbcolor [ 4 ] , const uint8_t yuvcolor [ 4 ] , \n int x , int y ) \n { \n char * text = HAVE_LOCALTIME_R ? s -> expanded_text : s -> text ; \n uint32_t code = 0 ; \n int i ; \n uint8_t * p ; \n Glyph * glyph = NULL ; \n for ( i = 0 , p = text ; * p ; i ++ ) { \n Glyph dummy = { 0 } ; \n GET_UTF8 ( code , * p ++ , continue ; ) ; \n if ( code == ' \\n ' || code == ' \\r ' || code == ' \\t ' ) \n continue ; \n dummy . code = code ; \n glyph = av_tree_find ( s -> glyphs , & dummy , ( void * ) glyph_cmp , NULL ) ; \n if ( glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_MONO && \n glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_GRAY ) \n return AVERROR ( EINVAL ) ; \n if ( s -> is_packed_rgb ) { \n draw_glyph_rgb ( frame , & glyph -> bitmap , \n s -> positions [ i ] . x + x , s -> positions [ i ] . y + y , width , height , \n s -> pixel_step [ 0 ] , rgbcolor , s -> rgba_map , s -> alpha ) ; \n } else { \n draw_glyph_yuv ( frame , & glyph -> bitmap , \n s -> positions [ i ] . x + x , s -> positions [ i ] . y + y , width , height , \n yuvcolor , s -> hsub , s -> vsub , s -> alpha ) ; \n } \n } \n return 0 ; \n }", "idx": 2382}
{"project": "FFmpeg", "commit_id": "6bd79ba59f46a8b3133f28faae53b75540469803", "target": 1, "func": "static void decode_pitch_lag_low ( int * lag_int , int * lag_frac , int pitch_index , \n uint8_t * base_lag_int , int subframe , enum Mode mode ) \n { \n if ( subframe == 0 || ( subframe == 2 && mode != MODE_6k60 ) ) { \n if ( pitch_index < 116 ) { \n * lag_int = ( pitch_index + 69 ) >> 1 ; \n * lag_frac = ( pitch_index - ( * lag_int << 1 ) + 68 ) << 1 ; \n } else { \n * lag_int = pitch_index - 24 ; \n * lag_frac = 0 ; \n } \n * base_lag_int = av_clip ( * lag_int - 8 - ( * lag_frac < 0 ) , \n AMRWB_P_DELAY_MIN , AMRWB_P_DELAY_MAX - 15 ) ; \n } else { \n * lag_int = ( pitch_index + 1 ) >> 1 ; \n * lag_frac = ( pitch_index - ( * lag_int << 1 ) ) << 1 ; \n * lag_int += * base_lag_int ; \n } \n }", "idx": 2384}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_open ( URLContext * * puc , const char * filename , int flags , \n const AVIOInterruptCB * int_cb , AVDictionary * * options ) \n { \n int ret = ffurl_alloc ( puc , filename , flags , int_cb ) ; \n if ( ret < 0 ) \n return ret ; \n if ( options && ( * puc ) -> prot -> priv_data_class && \n ( ret = av_opt_set_dict ( ( * puc ) -> priv_data , options ) ) < 0 ) \n goto fail ; \n if ( ( ret = av_opt_set_dict ( * puc , options ) ) < 0 ) \n goto fail ; \n ret = ffurl_connect ( * puc , options ) ; \n if ( ! ret ) \n return 0 ; \n fail : \n ffurl_close ( * puc ) ; \n * puc = NULL ; \n return ret ; \n }", "idx": 2388}
{"project": "FFmpeg", "commit_id": "7e2b15c094bb41ede9ce2a208982a20e4dfa26a6", "target": 0, "func": "int avfilter_link ( AVFilterContext * src , unsigned srcpad , \n AVFilterContext * dst , unsigned dstpad ) \n { \n AVFilterLink * link ; \n if ( src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || \n src -> outputs [ srcpad ] || dst -> inputs [ dstpad ] ) \n return -1 ; \n if ( src -> output_pads [ srcpad ] . type != dst -> input_pads [ dstpad ] . type ) { \n av_log ( src , AV_LOG_ERROR , \n \" \\n \" , \n src -> name , srcpad , dst -> name , dstpad ) ; \n return AVERROR ( EINVAL ) ; \n } \n src -> outputs [ srcpad ] = \n dst -> inputs [ dstpad ] = link = av_mallocz ( sizeof ( AVFilterLink ) ) ; \n link -> src = src ; \n link -> dst = dst ; \n link -> srcpad = & src -> output_pads [ srcpad ] ; \n link -> dstpad = & dst -> input_pads [ dstpad ] ; \n link -> type = src -> output_pads [ srcpad ] . type ; \n assert ( AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1 ) ; \n link -> format = -1 ; \n return 0 ; \n }", "idx": 2390}
{"project": "FFmpeg", "commit_id": "9767ec6b865c35f68cb6642fefeacc009f17e638", "target": 0, "func": "static void usage ( void ) \n { \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n }", "idx": 2391}
{"project": "FFmpeg", "commit_id": "2898bc522da6adebda5cbbd9036defe22e3b9bcf", "target": 1, "func": "void FUNCC ( ff_h264_chroma_dc_dequant_idct ) ( int16_t * _block , int qmul ) { \n const int stride = 16 * 2 ; \n const int xStride = 16 ; \n int a , b , c , d , e ; \n dctcoef * block = ( dctcoef * ) _block ; \n a = block [ stride * 0 + xStride * 0 ] ; \n b = block [ stride * 0 + xStride * 1 ] ; \n c = block [ stride * 1 + xStride * 0 ] ; \n d = block [ stride * 1 + xStride * 1 ] ; \n e = a - b ; \n a = a + b ; \n b = c - d ; \n c = c + d ; \n block [ stride * 0 + xStride * 0 ] = ( ( a + c ) * qmul ) >> 7 ; \n block [ stride * 0 + xStride * 1 ] = ( ( e + b ) * qmul ) >> 7 ; \n block [ stride * 1 + xStride * 0 ] = ( ( a - c ) * qmul ) >> 7 ; \n block [ stride * 1 + xStride * 1 ] = ( ( e - b ) * qmul ) >> 7 ; \n }", "idx": 2398}
{"project": "FFmpeg", "commit_id": "24ae353dfbe61019a86093a9c5cd15476aabef49", "target": 1, "func": "static av_cold int xan_decode_init ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> frame_size = 0 ; \n if ( ( avctx -> codec -> id == CODEC_ID_XAN_WC3 ) && \n ( s -> avctx -> palctrl == NULL ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n s -> buffer1_size = avctx -> width * avctx -> height ; \n s -> buffer1 = av_malloc ( s -> buffer1_size ) ; \n if ( ! s -> buffer1 ) \n return AVERROR ( ENOMEM ) ; \n s -> buffer2_size = avctx -> width * avctx -> height ; \n s -> buffer2 = av_malloc ( s -> buffer2_size + 130 ) ; \n if ( ! s -> buffer2 ) { \n av_freep ( & s -> buffer1 ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 2405}
{"project": "FFmpeg", "commit_id": "7c5dfc174be59afa671a98ec85fe208c528ab64f", "target": 1, "func": "static void init_uni_ac_vlc ( RLTable * rl , uint8_t * uni_ac_vlc_len ) { \n int i ; \n for ( i = 0 ; i < 128 ; i ++ ) { \n int level = i - 64 ; \n int run ; \n for ( run = 0 ; run < 64 ; run ++ ) { \n int len , bits , code ; \n int alevel = FFABS ( level ) ; \n int sign = ( level >> 31 ) & 1 ; \n if ( alevel > rl -> max_level [ 0 ] [ run ] ) \n code = 111 ; \n else \n code = rl -> index_run [ 0 ] [ run ] + alevel - 1 ; \n if ( code < 111 \n ) { \n len = rl -> table_vlc [ code ] [ 1 ] + 1 ; \n bits = ( rl -> table_vlc [ code ] [ 0 ] << 1 ) + sign ; \n } else { \n len = rl -> table_vlc [ 111 \n ] [ 1 ] + 6 ; \n bits = rl -> table_vlc [ 111 \n ] [ 0 ] << 6 ; \n bits |= run ; \n if ( alevel < 128 ) { \n bits <<= 8 ; len += 8 ; \n bits |= level & 0xff ; \n } else { \n bits <<= 16 ; len += 16 ; \n bits |= level & 0xff ; \n if ( level < 0 ) { \n bits |= 0x8001 + level + 255 ; \n } else { \n bits |= level & 0xffff ; \n } \n } \n } \n uni_ac_vlc_len [ UNI_AC_ENC_INDEX ( run , i ) ] = len ; \n } \n } \n }", "idx": 2406}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static inline void render_line_unrolled ( intptr_t x , uint8_t y , int x1 , \n intptr_t sy , int ady , int adx , \n float * buf ) \n { \n int err = - adx ; \n x -= x1 - 1 ; \n buf += x1 - 1 ; \n while ( ++ x < 0 ) { \n err += ady ; \n if ( err >= 0 ) { \n err += ady - adx ; \n y += sy ; \n buf [ x ++ ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n if ( x <= 0 ) { \n if ( err + ady >= 0 ) \n y += sy ; \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n }", "idx": 2418}
{"project": "FFmpeg", "commit_id": "f55df62998681c7702f008ce7c12a00b15e33f53", "target": 1, "func": "static inline void s_zero ( int cur_diff , struct G722Band * band ) \n { \n int s_zero = 0 ; \n #define ACCUM ( k , x , d )  do { \\ \n   \n  int tmp = x ; \n band -> zero_mem [ k ] = ( ( band -> zero_mem [ k ] * 255 ) >> 8 ) + \n d * ( ( band -> diff_mem [ k ] ^ cur_diff ) < 0 ? -128 : 128 ) ; \n band -> diff_mem [ k ] = tmp ; \n s_zero += ( tmp * band -> zero_mem [ k ] ) >> 15 ; \n } while ( 0 ) \n if ( cur_diff ) { \n ACCUM ( 5 , band -> diff_mem [ 4 ] , 1 ) ; \n ACCUM ( 4 , band -> diff_mem [ 3 ] , 1 ) ; \n ACCUM ( 3 , band -> diff_mem [ 2 ] , 1 ) ; \n ACCUM ( 2 , band -> diff_mem [ 1 ] , 1 ) ; \n ACCUM ( 1 , band -> diff_mem [ 0 ] , 1 ) ; \n ACCUM ( 0 , cur_diff << 1 , 1 ) ; \n } else { \n ACCUM ( 5 , band -> diff_mem [ 4 ] , 0 ) ; \n ACCUM ( 4 , band -> diff_mem [ 3 ] , 0 ) ; \n ACCUM ( 3 , band -> diff_mem [ 2 ] , 0 ) ; \n ACCUM ( 2 , band -> diff_mem [ 1 ] , 0 ) ; \n ACCUM ( 1 , band -> diff_mem [ 0 ] , 0 ) ; \n ACCUM ( 0 , cur_diff << 1 , 0 ) ; \n } \n #undef  ACCUM  \n  \n  band -> s_zero = s_zero ; \n }", "idx": 2420}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int decode_init ( AVCodecContext * avctx ) \n { \n KmvcContext * const c = avctx -> priv_data ; \n int i ; \n c -> avctx = avctx ; \n if ( avctx -> width > 320 || avctx -> height > 200 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n c -> frm0 = av_mallocz ( 320 * 200 ) ; \n c -> frm1 = av_mallocz ( 320 * 200 ) ; \n c -> cur = c -> frm0 ; \n c -> prev = c -> frm1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n c -> pal [ i ] = 0xFF << 24 | i * 0x10101 ; \n } \n if ( avctx -> extradata_size < 12 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \\n \" ) ; \n c -> palsize = 127 ; \n } else { \n c -> palsize = AV_RL16 ( avctx -> extradata + 10 ) ; \n if ( c -> palsize >= ( unsigned ) MAX_PALSIZE ) { \n c -> palsize = 127 ; \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n if ( avctx -> extradata_size == 1036 ) { \n uint8_t * src = avctx -> extradata + 12 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n c -> pal [ i ] = AV_RL32 ( src ) ; \n src += 4 ; \n } \n c -> setpal = 1 ; \n } \n avcodec_get_frame_defaults ( & c -> pic ) ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n return 0 ; \n }", "idx": 2422}
{"project": "FFmpeg", "commit_id": "ddb2dd7edbccc5596d8e3c039133be8444cb1d02", "target": 1, "func": "static uint8_t lag_calc_zero_run ( int8_t x ) \n { \n return ( x << 1 ) ^ ( x >> 7 ) ; \n }", "idx": 2423}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int nut_write_trailer ( AVFormatContext * s ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n update_packetheader ( nut , bc , 0 ) ; \n #if 0  \n  \n  int i ; \n for ( i = 0 ; s -> nb_streams ; i ++ ) \n { \n put_be64 ( bc , INDEX_STARTCODE ) ; \n put_packetheader ( nut , bc , 64 ) ; \n put_v ( bc , s -> streams [ i ] -> id ) ; \n put_v ( bc , ... ) ; \n put_be32 ( bc , 0 ) ; \n update_packetheader ( nut , bc , 0 ) ; \n } \n #endif \n put_flush_packet ( bc ) ; \n av_freep ( & nut -> stream ) ; \n return 0 ; \n }", "idx": 2426}
{"project": "FFmpeg", "commit_id": "f8f42f48218138d37956407ebf10227eb86d4a2d", "target": 0, "func": "static void noise ( uint8_t * dst , const uint8_t * src , \n int dst_linesize , int src_linesize , \n int width , int start , int end , NoiseContext * n , int comp ) \n { \n FilterParams * p = & n -> param [ comp ] ; \n int8_t * noise = p -> noise ; \n const int flags = p -> flags ; \n AVLFG * lfg = & p -> lfg ; \n int shift , y ; \n if ( ! noise ) { \n if ( dst != src ) \n av_image_copy_plane ( dst , dst_linesize , src , src_linesize , width , end - start ) ; \n return ; \n } \n for ( y = start ; y < end ; y ++ ) { \n if ( flags & NOISE_TEMPORAL ) \n shift = av_lfg_get ( lfg ) & ( MAX_SHIFT - 1 ) ; \n else \n shift = n -> rand_shift [ y ] ; \n if ( flags & NOISE_AVERAGED ) { \n n -> line_noise_avg ( dst , src , width , p -> prev_shift [ y ] ) ; \n p -> prev_shift [ y ] [ shift & 3 ] = noise + shift ; \n } else { \n n -> line_noise ( dst , src , noise , width , shift ) ; \n } \n dst += dst_linesize ; \n src += src_linesize ; \n } \n }", "idx": 2427}
{"project": "FFmpeg", "commit_id": "7ac85f4be840361d55db302ac476ced28297a061", "target": 0, "func": "void ff_generate_sliding_window_mmcos ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n h -> mmco_index = 0 ; \n if ( h -> short_ref_count && h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE && ! s -> first_field && s -> current_picture_ptr -> reference ) ) { \n h -> mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n h -> mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n h -> mmco_index = 1 ; \n if ( FIELD_PICTURE ) { \n h -> mmco [ 0 ] . short_pic_num *= 2 ; \n h -> mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n h -> mmco [ 1 ] . short_pic_num = h -> mmco [ 0 ] . short_pic_num + 1 ; \n h -> mmco_index = 2 ; \n } \n } \n }", "idx": 2428}
{"project": "FFmpeg", "commit_id": "6260ab60a80fd8baebf79f9ce9299b0db72333b5", "target": 0, "func": "static void blend_image_rgba_pm ( AVFilterContext * ctx , AVFrame * dst , const AVFrame * src , int x , int y ) \n { \n blend_image_packed_rgb ( ctx , dst , src , 1 , x , y , 1 ) ; \n }", "idx": 2432}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 13 ) \n return 0 ; \n if ( p -> buf [ 0 ] == 0x01 && p -> buf [ 1 ] == 0x00 && \n p -> buf [ 4 ] == 0x01 + p -> buf [ 2 ] && \n p -> buf [ 8 ] == p -> buf [ 4 ] + p -> buf [ 6 ] && \n p -> buf [ 12 ] == p -> buf [ 8 ] + p -> buf [ 10 ] ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 2434}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_weight_h264_pixels8_8_msa ( uint8_t * src , int stride , \n int height , int log2_denom , \n int weight_src , int offset ) \n { \n avc_wgt_8width_msa ( src , stride , \n height , log2_denom , weight_src , offset ) ; \n }", "idx": 2435}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "void ff_fetch_timestamp ( AVCodecParserContext * s , int off , int remove ) { \n int i ; \n s -> dts = s -> pts = AV_NOPTS_VALUE ; \n s -> offset = 0 ; \n for ( i = 0 ; i < AV_PARSER_PTS_NB ; i ++ ) { \n if ( s -> next_frame_offset + off >= s -> cur_frame_offset [ i ] \n && ( s -> frame_offset < s -> cur_frame_offset [ i ] || ! s -> frame_offset ) \n && \n s -> cur_frame_end [ i ] ) { \n s -> dts = s -> cur_frame_dts [ i ] ; \n s -> pts = s -> cur_frame_pts [ i ] ; \n s -> offset = s -> next_frame_offset - s -> cur_frame_offset [ i ] ; \n if ( remove ) \n s -> cur_frame_offset [ i ] = INT64_MAX ; \n } \n } \n }", "idx": 2436}
{"project": "FFmpeg", "commit_id": "e5c32d6da7836c7c9bb8393cb4de7e0997a4363b", "target": 0, "func": "static int opt_debug ( void * optctx , const char * opt , const char * arg ) \n { \n av_log_set_level ( 99 ) ; \n debug = parse_number_or_die ( opt , arg , OPT_INT64 , 0 , INT_MAX ) ; \n return 0 ; \n }", "idx": 2438}
{"project": "FFmpeg", "commit_id": "879b4a9d3ec89f587f9442fd4c7f1f36d5bd39c3", "target": 0, "func": "static int pulse_set_volume ( PulseData * s , double volume ) \n { \n pa_operation * op ; \n pa_cvolume cvol ; \n pa_volume_t vol ; \n const pa_sample_spec * ss = pa_stream_get_sample_spec ( s -> stream ) ; \n vol = pa_sw_volume_multiply ( lround ( volume * PA_VOLUME_NORM ) , s -> base_volume ) ; \n pa_cvolume_set ( & cvol , ss -> channels , PA_VOLUME_NORM ) ; \n pa_sw_cvolume_multiply_scalar ( & cvol , & cvol , vol ) ; \n pa_threaded_mainloop_lock ( s -> mainloop ) ; \n op = pa_context_set_sink_input_volume ( s -> ctx , pa_stream_get_index ( s -> stream ) , \n & cvol , pulse_context_result , s ) ; \n return pulse_finish_context_operation ( s , op , \" \" ) ; \n }", "idx": 2439}
{"project": "FFmpeg", "commit_id": "0a41faa9a77dc83d8d933e99f1ba902ecd146e79", "target": 1, "func": "static void vp6_build_huff_tree ( VP56Context * s , uint8_t coeff_model [ ] , \n const uint8_t * map , unsigned size , VLC * vlc ) \n { \n Node nodes [ 2 * size ] , * tmp = & nodes [ size ] ; \n int a , b , i ; \n tmp [ 0 ] . count = 256 ; \n for ( i = 0 ; i < size - 1 ; i ++ ) { \n a = tmp [ i ] . count * coeff_model [ i ] >> 8 ; \n b = tmp [ i ] . count * ( 255 - coeff_model [ i ] ) >> 8 ; \n nodes [ map [ 2 * i ] ] . count = a + ! a ; \n nodes [ map [ 2 * i + 1 ] ] . count = b + ! b ; \n } \n ff_huff_build_tree ( s -> avctx , vlc , size , nodes , vp6_huff_cmp , \n FF_HUFFMAN_FLAG_HNODE_FIRST ) ; \n }", "idx": 2441}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void adx_encode ( unsigned char * adx , const short * wav , PREV * prev ) \n { \n int scale ; \n int i ; \n int s0 , s1 , s2 , d ; \n int max = 0 ; \n int min = 0 ; \n int data [ 32 ] ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n s0 = wav [ i ] ; \n d = ( ( s0 << 14 ) - SCALE1 * s1 + SCALE2 * s2 ) / BASEVOL ; \n data [ i ] = d ; \n if ( max < d ) max = d ; \n if ( min > d ) min = d ; \n s2 = s1 ; \n s1 = s0 ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n if ( max == 0 && min == 0 ) { \n memset ( adx , 0 , 18 ) ; \n return ; \n } \n if ( max / 7 > - min / 8 ) scale = max / 7 ; \n else scale = - min / 8 ; \n if ( scale == 0 ) scale = 1 ; \n adx [ 0 ] = scale >> 8 ; \n adx [ 1 ] = scale ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n adx [ i + 2 ] = ( ( data [ i * 2 ] / scale ) << 4 ) | ( ( data [ i * 2 + 1 ] / scale ) & 0xf ) ; \n } \n }", "idx": 2448}
{"project": "FFmpeg", "commit_id": "f86f66562311f38b6b7864c19720727916fb0d19", "target": 1, "func": "void rtsp_close_streams ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n RTSPStream * rtsp_st ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st ) { \n if ( rtsp_st -> transport_priv ) { \n if ( s -> oformat ) { \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n av_write_trailer ( rtpctx ) ; \n url_fclose ( rtpctx -> pb ) ; \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n } else if ( rt -> transport == RTSP_TRANSPORT_RDT ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else \n rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n if ( rtsp_st -> rtp_handle ) \n url_close ( rtsp_st -> rtp_handle ) ; \n if ( rtsp_st -> dynamic_handler && rtsp_st -> dynamic_protocol_context ) \n rtsp_st -> dynamic_handler -> close ( \n rtsp_st -> dynamic_protocol_context ) ; \n } \n } \n av_free ( rt -> rtsp_streams ) ; \n if ( rt -> asf_ctx ) { \n av_close_input_stream ( rt -> asf_ctx ) ; \n rt -> asf_ctx = NULL ; \n } \n av_freep ( & rt -> auth_b64 ) ; \n }", "idx": 2452}
{"project": "FFmpeg", "commit_id": "dee7943819042f310d7995671d3e39f4dd31d770", "target": 0, "func": "static int qdraw_probe ( AVProbeData * p ) \n { \n const uint8_t * b = p -> buf ; \n if ( ! b [ 10 ] && AV_RB32 ( b + 11 ) == 0x1102ff0c && ! b [ 15 ] || \n p -> buf_size >= 528 && ! b [ 522 ] && AV_RB32 ( b + 523 ) == 0x1102ff0c && ! b [ 527 ] ) \n return AVPROBE_SCORE_EXTENSION + 1 ; \n return 0 ; \n }", "idx": 2463}
{"project": "FFmpeg", "commit_id": "0c1d62ab9d757d546fafca366d776524e7bb9893", "target": 0, "func": "static int theora_packet ( AVFormatContext * s , int idx ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n int duration ; \n if ( ( ! os -> lastpts || os -> lastpts == AV_NOPTS_VALUE ) && ! ( os -> flags & OGG_FLAG_EOS ) ) { \n int seg ; \n duration = 1 ; \n for ( seg = os -> segp ; seg < os -> nsegs ; seg ++ ) { \n if ( os -> segments [ seg ] < 255 ) \n duration ++ ; \n } \n os -> lastpts = os -> lastdts = theora_gptopts ( s , idx , os -> granule , NULL ) - duration ; \n if ( s -> streams [ idx ] -> start_time == AV_NOPTS_VALUE ) { \n s -> streams [ idx ] -> start_time = os -> lastpts ; \n if ( s -> streams [ idx ] -> duration ) \n s -> streams [ idx ] -> duration -= s -> streams [ idx ] -> start_time ; \n } \n } \n if ( os -> psize > 0 ) { \n os -> pduration = 1 ; \n } \n return 0 ; \n }", "idx": 2467}
{"project": "FFmpeg", "commit_id": "dc6b99d6b20e832a7d353474c2d093f8b2fb17d2", "target": 0, "func": "static int mov_write_wfex_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ff_put_wav_header ( pb , track -> enc , FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 2468}
{"project": "FFmpeg", "commit_id": "22b985d59c007c4422aefe3ef3fca0aa0daafa9f", "target": 0, "func": "static void denoise_depth ( HQDN3DContext * s , \n uint8_t * src , uint8_t * dst , \n uint16_t * line_ant , uint16_t * * frame_ant_ptr , \n int w , int h , int sstride , int dstride , \n int16_t * spatial , int16_t * temporal , int depth ) \n { \n long x , y ; \n uint16_t * frame_ant = * frame_ant_ptr ; \n if ( ! frame_ant ) { \n uint8_t * frame_src = src ; \n * frame_ant_ptr = frame_ant = av_malloc ( w * h * sizeof ( uint16_t ) ) ; \n for ( y = 0 ; y < h ; y ++ , src += sstride , frame_ant += w ) \n for ( x = 0 ; x < w ; x ++ ) \n frame_ant [ x ] = LOAD ( x ) ; \n src = frame_src ; \n frame_ant = * frame_ant_ptr ; \n } \n if ( spatial [ 0 ] ) \n denoise_spatial ( s , src , dst , line_ant , frame_ant , \n w , h , sstride , dstride , spatial , temporal , depth ) ; \n else \n denoise_temporal ( src , dst , frame_ant , \n w , h , sstride , dstride , temporal , depth ) ; \n emms_c ( ) ; \n }", "idx": 2469}
{"project": "FFmpeg", "commit_id": "a246d06fe0dc6c2ea65e95327624b4537ff9bd0d", "target": 0, "func": "static void FUNC ( transquant_bypass8x8 ) ( uint8_t * _dst , int16_t * coeffs , \n ptrdiff_t stride ) \n { \n int x , y ; \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n for ( x = 0 ; x < 8 ; x ++ ) { \n dst [ x ] += * coeffs ; \n coeffs ++ ; \n } \n dst += stride ; \n } \n }", "idx": 2470}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void img_copy ( uint8_t * dst , int dst_wrap , \n uint8_t * src , int src_wrap , \n int width , int height ) \n { \n for ( ; height > 0 ; height -- ) { \n memcpy ( dst , src , width ) ; \n dst += dst_wrap ; \n src += src_wrap ; \n } \n }", "idx": 2479}
{"project": "FFmpeg", "commit_id": "7292b0477ac8a864af9bf97b63362c40062ab805", "target": 0, "func": "static void DEF ( avg , pixels16_x2 ) ( uint8_t * block , const uint8_t * pixels , ptrdiff_t line_size , int h ) \n { \n MOVQ_BFE ( mm6 ) ; \n JUMPALIGN ( ) ; \n do { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGB ( % % mm0 , % % mm1 , % % mm2 , % % mm6 ) \n PAVGB_MMX ( % % mm3 , % % mm2 , % % mm0 , % % mm6 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGB ( % % mm0 , % % mm1 , % % mm2 , % % mm6 ) \n PAVGB_MMX ( % % mm3 , % % mm2 , % % mm0 , % % mm6 ) \n \" \\n \\t \" \n : \" \" ( * block ) \n : \" \" ( * pixels ) \n : \" \" ) ; \n pixels += line_size ; \n block += line_size ; \n } while ( -- h ) ; \n }", "idx": 2500}
{"project": "FFmpeg", "commit_id": "2c3d93648768cf2c00ea1731e096f698c0fae7f6", "target": 0, "func": "static int config_output ( AVFilterLink * outlink ) { \n static const char hdcd_baduse [ ] = \n \" \" ; \n AVFilterContext * ctx = outlink -> src ; \n HDCDContext * s = ctx -> priv ; \n AVFilterLink * lk = outlink ; \n while ( lk != NULL ) { \n AVFilterContext * nextf = lk -> dst ; \n if ( lk -> type == AVMEDIA_TYPE_AUDIO ) { \n if ( lk -> format == AV_SAMPLE_FMT_S16 || lk -> format == AV_SAMPLE_FMT_U8 ) { \n av_log ( ctx , AV_LOG_WARNING , \" \\n \" , \n av_get_sample_fmt_name ( lk -> format ) , \n ( nextf -> name ) ? nextf -> name : \" \" \n ) ; \n s -> bad_config = 1 ; \n break ; \n } \n } \n lk = ( nextf -> outputs ) ? nextf -> outputs [ 0 ] : NULL ; \n } \n if ( s -> bad_config ) \n av_log ( ctx , AV_LOG_WARNING , \" \\n \" , hdcd_baduse ) ; \n return 0 ; \n }", "idx": 2501}
{"project": "FFmpeg", "commit_id": "5064357588a187672ca64c169dc6e6e406777629", "target": 1, "func": "static void conv411 ( uint8_t * dst , int dst_wrap , \n uint8_t * src , int src_wrap , \n int width , int height ) \n { \n int w , c ; \n uint8_t * s1 , * s2 , * d ; \n for ( ; height > 0 ; height -- ) { \n s1 = src ; \n s2 = src + src_wrap ; \n d = dst ; \n for ( w = width ; w > 0 ; w -- ) { \n c = ( s1 [ 0 ] + s2 [ 0 ] ) >> 1 ; \n d [ 0 ] = c ; \n d [ 1 ] = c ; \n s1 ++ ; \n s2 ++ ; \n d += 2 ; \n } \n src += src_wrap * 2 ; \n dst += dst_wrap ; \n } \n }", "idx": 2526}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "int ff_generate_sliding_window_mmcos ( H264Context * h , int first_slice ) \n { \n MMCO mmco_temp [ MAX_MMCO_COUNT ] , * mmco = first_slice ? h -> mmco : mmco_temp ; \n int mmco_index = 0 , i = 0 ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n if ( h -> short_ref_count && \n h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE ( h ) && ! h -> first_field && h -> cur_pic_ptr -> reference ) ) { \n mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n mmco_index = 1 ; \n if ( FIELD_PICTURE ( h ) ) { \n mmco [ 0 ] . short_pic_num *= 2 ; \n mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 1 ] . short_pic_num = mmco [ 0 ] . short_pic_num + 1 ; \n mmco_index = 2 ; \n } \n } \n if ( first_slice ) { \n h -> mmco_index = mmco_index ; \n } else if ( ! first_slice && mmco_index >= 0 && \n ( mmco_index != h -> mmco_index || \n ( i = check_opcodes ( h -> mmco , mmco_temp , mmco_index ) ) ) ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n mmco_index , h -> mmco_index , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n return 0 ; \n }", "idx": 2545}
{"project": "FFmpeg", "commit_id": "0aed5e9fb895a31c43ff6ab4edfecb5be372f704", "target": 0, "func": "void ff_flac_compute_autocorr ( const int32_t * data , int len , int lag , \n double * autoc ) \n { \n int i , j ; \n double tmp [ len + lag + 1 ] ; \n double * data1 = tmp + lag ; \n apply_welch_window ( data , len , data1 ) ; \n for ( j = 0 ; j < lag ; j ++ ) \n data1 [ j - lag ] = 0.0 ; \n data1 [ len ] = 0.0 ; \n for ( j = 0 ; j < lag ; j += 2 ) { \n double sum0 = 1.0 , sum1 = 1.0 ; \n for ( i = 0 ; i < len ; i ++ ) { \n sum0 += data1 [ i ] * data1 [ i - j ] ; \n sum1 += data1 [ i ] * data1 [ i - j - 1 ] ; \n } \n autoc [ j ] = sum0 ; \n autoc [ j + 1 ] = sum1 ; \n } \n if ( j == lag ) { \n double sum = 1.0 ; \n for ( i = 0 ; i < len ; i += 2 ) { \n sum += data1 [ i ] * data1 [ i - j ] \n + data1 [ i + 1 ] * data1 [ i - j + 1 ] ; \n } \n autoc [ j ] = sum ; \n } \n }", "idx": 2569}
{"project": "FFmpeg", "commit_id": "b0068d75ebdb388c90b9d2c9833f17d12f323717", "target": 0, "func": "static unsigned int rms ( const int * data ) \n { \n int x ; \n unsigned int res = 0x10000 ; \n int b = 0 ; \n for ( x = 0 ; x < 10 ; x ++ ) { \n res = ( ( ( 0x1000000 - ( * data ) * ( * data ) ) >> 12 ) * res ) >> 12 ; \n if ( res == 0 ) \n return 0 ; \n while ( res <= 0x3fff ) { \n b ++ ; \n res <<= 2 ; \n } \n data ++ ; \n } \n if ( res > 0 ) \n res = t_sqrt ( res ) ; \n res >>= ( b + 10 ) ; \n return res ; \n }", "idx": 2570}
{"project": "FFmpeg", "commit_id": "94e58e5770d2a2295a13240f51ddba583e6d5360", "target": 1, "func": "static void mm_decode_inter ( MmContext * s , int half_horiz , int half_vert , const uint8_t * buf , int buf_size ) \n { \n const int data_ptr = 2 + AV_RL16 ( & buf [ 0 ] ) ; \n int d , r , y ; \n d = data_ptr ; r = 2 ; y = 0 ; \n while ( r < data_ptr ) { \n int i , j ; \n int length = buf [ r ] & 0x7f ; \n int x = buf [ r + 1 ] + ( ( buf [ r ] & 0x80 ) << 1 ) ; \n r += 2 ; \n if ( length == 0 ) { \n y += x ; \n continue ; \n } \n for ( i = 0 ; i < length ; i ++ ) { \n for ( j = 0 ; j < 8 ; j ++ ) { \n int replace = ( buf [ r + i ] >> ( 7 - j ) ) & 1 ; \n if ( replace ) { \n int color = buf [ d ] ; \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n if ( half_vert ) { \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n } \n d ++ ; \n } \n x += 1 + half_horiz ; \n } \n } \n r += length ; \n y += 1 + half_vert ; \n } \n }", "idx": 2572}
{"project": "FFmpeg", "commit_id": "141f03541b39e131a5e8aa776a88abe77b70618e", "target": 1, "func": "int av_set_options_string ( void * ctx , const char * opts , \n const char * key_val_sep , const char * pairs_sep ) \n { \n int ret , count = 0 ; \n while ( * opts ) { \n if ( ( ret = parse_key_value_pair ( ctx , & opts , key_val_sep , pairs_sep ) ) < 0 ) \n return ret ; \n count ++ ; \n if ( * opts ) \n opts ++ ; \n } \n return count ; \n }", "idx": 2576}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_4x4_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 2613}
{"project": "FFmpeg", "commit_id": "71434945f20c6d340b4c942de7746e6ea46ec74b", "target": 1, "func": "static int mpeg1_decode_picture ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n int ref , f_code , vbv_delay ; \n if ( mpeg_decode_postinit ( s -> avctx ) < 0 ) \n return -2 ; \n init_get_bits ( & s -> gb , buf , buf_size * 8 ) ; \n ref = get_bits ( & s -> gb , 10 ) ; \n s -> pict_type = get_bits ( & s -> gb , 3 ) ; \n vbv_delay = get_bits ( & s -> gb , 16 ) ; \n if ( s -> pict_type == P_TYPE || s -> pict_type == B_TYPE ) { \n s -> full_pel [ 0 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 0 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 0 ] [ 1 ] = f_code ; \n } \n if ( s -> pict_type == B_TYPE ) { \n s -> full_pel [ 1 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 1 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 1 ] [ 1 ] = f_code ; \n } \n s -> current_picture . pict_type = s -> pict_type ; \n s -> current_picture . key_frame = s -> pict_type == I_TYPE ; \n s -> y_dc_scale = 8 ; \n s -> c_dc_scale = 8 ; \n s -> first_slice = 1 ; \n return 0 ; \n }", "idx": 2614}
{"project": "FFmpeg", "commit_id": "542f725964e52201000ec34e2f23229cf534ad3a", "target": 1, "func": "static int ogg_read_header ( AVFormatContext * s ) \n { \n struct ogg * ogg = s -> priv_data ; \n int ret , i ; \n ogg -> curidx = -1 ; \n do { \n ret = ogg_packet ( s , NULL , NULL , NULL , NULL ) ; \n if ( ret < 0 ) { \n ogg_read_close ( s ) ; \n return ret ; \n } \n } while ( ! ogg -> headers ) ; \n av_log ( s , AV_LOG_TRACE , \" \\n \" ) ; \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) { \n struct ogg_stream * os = ogg -> streams + i ; \n if ( ogg -> streams [ i ] . header < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , i ) ; \n ogg -> streams [ i ] . codec = NULL ; \n } else if ( os -> codec && os -> nb_header < os -> codec -> nb_header ) { \n av_log ( s , AV_LOG_WARNING , \n \" \" \n \" \\n \" , \n i , os -> codec -> nb_header , os -> nb_header ) ; \n if ( s -> error_recognition & AV_EF_EXPLODE ) \n return AVERROR_INVALIDDATA ; \n } \n if ( os -> start_granule != OGG_NOGRANULE_VALUE ) \n os -> lastpts = s -> streams [ i ] -> start_time = \n ogg_gptopts ( s , i , os -> start_granule , NULL ) ; \n } \n ret = ogg_get_length ( s ) ; \n if ( ret < 0 ) { \n ogg_read_close ( s ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 2619}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "AVRational av_get_q ( void * obj , const char * name , const AVOption * * o_out ) \n { \n int64_t intnum = 1 ; \n double num = 1 ; \n int den = 1 ; \n av_get_number ( obj , name , o_out , & num , & den , & intnum ) ; \n if ( num == 1.0 && ( int ) intnum == intnum ) \n return ( AVRational ) { intnum , den } ; \n else \n return av_d2q ( num * intnum / den , 1 << 24 ) ; \n }", "idx": 2625}
{"project": "FFmpeg", "commit_id": "44ca80df3445a59bc065924d8c6110fa10367d01", "target": 0, "func": "static void filter_mb_mbaff_edgev ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 7 ] , int bsi , int qp ) { \n int index_a = qp + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 2633}
{"project": "FFmpeg", "commit_id": "05d00e953f4cc08273fbb5f795f4fdc307140108", "target": 0, "func": "static int file_open ( URLContext * h , const char * filename , int flags ) \n { \n int access ; \n int fd ; \n av_strstart ( filename , \" \" , & filename ) ; \n if ( flags & URL_RDWR ) { \n access = O_CREAT | O_TRUNC | O_RDWR ; \n } else if ( flags & URL_WRONLY ) { \n access = O_CREAT | O_TRUNC | O_WRONLY ; \n } else { \n access = O_RDONLY ; \n } \n #if defined ( __MINGW32__ ) || defined ( CONFIG_OS2 ) || defined ( __CYGWIN__ )  \n  \n  access |= O_BINARY ; \n #endif \n fd = open ( filename , access , 0666 ) ; \n if ( fd < 0 ) \n return AVERROR ( ENOENT ) ; \n h -> priv_data = ( void * ) ( size_t ) fd ; \n return 0 ; \n }", "idx": 2644}
{"project": "FFmpeg", "commit_id": "05af8608c2dc8ed95e3afa3840308212f3df589e", "target": 1, "func": "int ff_ass_add_rect ( AVSubtitle * sub , const char * dialog , \n int ts_start , int duration , int raw ) \n { \n AVBPrint buf ; \n int ret , dlen ; \n AVSubtitleRect * * rects ; \n av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; \n if ( ( ret = ff_ass_bprint_dialog ( & buf , dialog , ts_start , duration , raw ) ) < 0 ) \n goto err ; \n dlen = ret ; \n if ( ! av_bprint_is_complete ( & buf ) ) \n rects = av_realloc_array ( sub -> rects , ( sub -> num_rects + 1 ) , sizeof ( * sub -> rects ) ) ; \n if ( ! rects ) \n sub -> rects = rects ; \n sub -> end_display_time = FFMAX ( sub -> end_display_time , 10 * duration ) ; \n rects [ sub -> num_rects ] = av_mallocz ( sizeof ( * rects [ 0 ] ) ) ; \n rects [ sub -> num_rects ] -> type = SUBTITLE_ASS ; \n ret = av_bprint_finalize ( & buf , & rects [ sub -> num_rects ] -> ass ) ; \n if ( ret < 0 ) \n goto err ; \n sub -> num_rects ++ ; \n return dlen ; \n errnomem : \n ret = AVERROR ( ENOMEM ) ; \n err : \n av_bprint_finalize ( & buf , NULL ) ; \n return ret ; \n }", "idx": 2653}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_plane_bitstream ( HYuvContext * s , int count , int plane ) \n { \n int i ; \n count /= 2 ; \n if ( s -> bps <= 8 ) { \n OPEN_READER ( re , & s -> gb ) ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , plane , OP8bits ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , plane , OP8bits ) ; \n } \n } \n CLOSE_READER ( re , & s -> gb ) ; \n } else if ( s -> bps <= 14 ) { \n OPEN_READER ( re , & s -> gb ) ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane , OP14bits ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX_PLANE ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane , OP14bits ) ; \n } \n } \n CLOSE_READER ( re , & s -> gb ) ; \n } else { \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX_PLANE16 ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX_PLANE16 ( s -> temp16 [ 0 ] [ 2 * i ] , s -> temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ; \n } \n } \n } \n }", "idx": 2655}
{"project": "FFmpeg", "commit_id": "30c3d976f12665d5d13971172aab062a97cb1bce", "target": 1, "func": "static int mov_read_stts ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned int i , entries ; \n int64_t duration = 0 ; \n int64_t total_sample_count = 0 ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n av_dlog ( c -> fc , \" \\n \" , \n c -> fc -> nb_streams - 1 , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stts_data ) ) \n return -1 ; \n sc -> stts_data = av_malloc ( entries * sizeof ( * sc -> stts_data ) ) ; \n if ( ! sc -> stts_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stts_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n int sample_duration ; \n int sample_count ; \n sample_count = avio_rb32 ( pb ) ; \n sample_duration = avio_rb32 ( pb ) ; \n sc -> stts_data [ i ] . count = sample_count ; \n sc -> stts_data [ i ] . duration = sample_duration ; \n av_dlog ( c -> fc , \" \\n \" , \n sample_count , sample_duration ) ; \n duration += ( int64_t ) sample_duration * sample_count ; \n total_sample_count += sample_count ; \n } \n st -> nb_frames = total_sample_count ; \n if ( duration ) \n st -> duration = duration ; \n return 0 ; \n }", "idx": 2664}
{"project": "FFmpeg", "commit_id": "ac1d489320f476c18d6a8125f73389aecb73f3d3", "target": 0, "func": "static int64_t asf_read_pts ( AVFormatContext * s , int stream_index , int64_t * ppos , int64_t pos_limit ) \n { \n AVPacket pkt1 , * pkt = & pkt1 ; \n ASFStream * asf_st ; \n int64_t pts ; \n int64_t pos = * ppos ; \n int i ; \n int64_t start_pos [ ASF_MAX_STREAMS ] ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n start_pos [ i ] = pos ; \n } \n if ( s -> packet_size > 0 ) \n pos = ( pos + s -> packet_size - 1 - s -> data_offset ) / s -> packet_size * s -> packet_size + s -> data_offset ; \n * ppos = pos ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n asf_reset_header ( s ) ; \n for ( ; ; ) { \n if ( av_read_frame ( s , pkt ) < 0 ) { \n av_log ( s , AV_LOG_INFO , \" \\n \" ) ; \n return AV_NOPTS_VALUE ; \n } \n pts = pkt -> pts ; \n av_free_packet ( pkt ) ; \n if ( pkt -> flags & AV_PKT_FLAG_KEY ) { \n i = pkt -> stream_index ; \n asf_st = s -> streams [ i ] -> priv_data ; \n pos = asf_st -> packet_pos ; \n av_add_index_entry ( s -> streams [ i ] , pos , pts , pkt -> size , pos - start_pos [ i ] + 1 , AVINDEX_KEYFRAME ) ; \n start_pos [ i ] = asf_st -> packet_pos + 1 ; \n if ( pkt -> stream_index == stream_index ) \n break ; \n } \n } \n * ppos = pos ; \n return pts ; \n }", "idx": 2666}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int_97 ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j ; \n int w = cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) { \n int32_t * datap = & comp -> i_data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( y + j ) + x ] ; \n int * src = t1 -> data [ j ] ; \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = ( src [ i ] * ( int64_t ) band -> i_stepsize + ( 1 << 14 ) ) >> 15 ; \n } \n }", "idx": 2667}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_local_tags ( MXFContext * mxf , KLVPacket * klv , int ( * read_child ) ( ) , int ctx_size , enum MXFMetadataSetType type ) \n { \n ByteIOContext * pb = mxf -> fc -> pb ; \n MXFMetadataSet * ctx = ctx_size ? av_mallocz ( ctx_size ) : mxf ; \n uint64_t klv_end = url_ftell ( pb ) + klv -> length ; \n if ( ! ctx ) \n return -1 ; \n while ( url_ftell ( pb ) + 4 < klv_end ) { \n int tag = get_be16 ( pb ) ; \n int size = get_be16 ( pb ) ; \n uint64_t next = url_ftell ( pb ) + size ; \n UID uid = { 0 } ; \n dprintf ( mxf -> fc , \" \\n \" , tag , size ) ; \n if ( ! size ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \" \\n \" , tag ) ; \n continue ; \n } \n if ( tag > 0x7FFF ) { \n int i ; \n for ( i = 0 ; i < mxf -> local_tags_count ; i ++ ) { \n int local_tag = AV_RB16 ( mxf -> local_tags + i * 18 ) ; \n if ( local_tag == tag ) { \n memcpy ( uid , mxf -> local_tags + i * 18 + 2 , 16 ) ; \n dprintf ( mxf -> fc , \" \\n \" , local_tag ) ; \n PRINT_KEY ( mxf -> fc , \" \" , uid ) ; \n } \n } \n } \n if ( ctx_size && tag == 0x3C0A ) \n get_buffer ( pb , ctx -> uid , 16 ) ; \n else if ( read_child ( ctx , pb , tag , size , uid ) < 0 ) \n return -1 ; \n url_fseek ( pb , next , SEEK_SET ) ; \n } \n if ( ctx_size ) ctx -> type = type ; \n return ctx_size ? mxf_add_metadata_set ( mxf , ctx ) : 0 ; \n }", "idx": 2674}
{"project": "FFmpeg", "commit_id": "1eda55510ae5d15ce3df9f496002508580899045", "target": 1, "func": "static int decode_rle ( AVCodecContext * avctx , AVFrame * p , GetByteContext * gbc , \n int step ) \n { \n int i , j ; \n int offset = avctx -> width * step ; \n uint8_t * outdata = p -> data [ 0 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n int size , left , code , pix ; \n uint8_t * out = outdata ; \n int pos = 0 ; \n size = left = bytestream2_get_be16 ( gbc ) ; \n if ( bytestream2_get_bytes_left ( gbc ) < size ) \n while ( left > 0 ) { \n code = bytestream2_get_byte ( gbc ) ; \n if ( code & 0x80 ) { \n pix = bytestream2_get_byte ( gbc ) ; \n for ( j = 0 ; j < 257 - code ; j ++ ) { \n out [ pos ] = pix ; \n pos += step ; \n if ( pos >= offset ) { \n pos -= offset ; \n pos ++ ; \n } \n } \n left -= 2 ; \n } else { \n for ( j = 0 ; j < code + 1 ; j ++ ) { \n out [ pos ] = bytestream2_get_byte ( gbc ) ; \n pos += step ; \n if ( pos >= offset ) { \n pos -= offset ; \n pos ++ ; \n } \n } \n left -= 2 + code ; \n } \n } \n outdata += p -> linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 2688}
{"project": "FFmpeg", "commit_id": "be8a0d26dbeec72b8e254e00724f170c28644c98", "target": 1, "func": "static void reset_codec ( WmallDecodeCtx * s ) \n { \n int ich , ilms ; \n s -> mclms_recent = s -> mclms_order * s -> num_channels ; \n for ( ich = 0 ; ich < s -> num_channels ; ich ++ ) { \n for ( ilms = 0 ; ilms < s -> cdlms_ttl [ ich ] ; ilms ++ ) \n s -> cdlms [ ich ] [ ilms ] . recent = s -> cdlms [ ich ] [ ilms ] . order ; \n s -> channel [ ich ] . transient_counter = s -> samples_per_frame ; \n s -> transient [ ich ] = 1 ; \n } \n }", "idx": 2695}
{"project": "FFmpeg", "commit_id": "c5a738ca4e9789b4678b10240777d931e7dc24c9", "target": 1, "func": "static int flv_set_video_codec ( AVFormatContext * s , AVStream * vstream , int flv_codecid , int read ) { \n AVCodecContext * vcodec = vstream -> codec ; \n switch ( flv_codecid ) { \n case FLV_CODECID_H263 : vcodec -> codec_id = AV_CODEC_ID_FLV1 ; break ; \n case FLV_CODECID_SCREEN : vcodec -> codec_id = AV_CODEC_ID_FLASHSV ; break ; \n case FLV_CODECID_SCREEN2 : vcodec -> codec_id = AV_CODEC_ID_FLASHSV2 ; break ; \n case FLV_CODECID_VP6 : vcodec -> codec_id = AV_CODEC_ID_VP6F ; \n case FLV_CODECID_VP6A : \n if ( flv_codecid == FLV_CODECID_VP6A ) \n vcodec -> codec_id = AV_CODEC_ID_VP6A ; \n if ( read ) { \n if ( vcodec -> extradata_size != 1 ) { \n vcodec -> extradata_size = 1 ; \n vcodec -> extradata = av_malloc ( 1 ) ; \n } \n vcodec -> extradata [ 0 ] = avio_r8 ( s -> pb ) ; \n } \n return 1 ; \n case FLV_CODECID_H264 : \n vcodec -> codec_id = AV_CODEC_ID_H264 ; \n return 3 ; \n default : \n av_log ( s , AV_LOG_INFO , \" \\n \" , flv_codecid ) ; \n vcodec -> codec_tag = flv_codecid ; \n } \n return 0 ; \n }", "idx": 2696}
{"project": "FFmpeg", "commit_id": "ebd1c505d22ad96e044880755ed9f4cf7cab4f78", "target": 1, "func": "void ff_h264_direct_dist_scale_factor ( H264Context * const h ) { \n const int poc = h -> cur_pic_ptr -> field_poc [ h -> picture_structure == PICT_BOTTOM_FIELD ] ; \n const int poc1 = h -> ref_list [ 1 ] [ 0 ] . poc ; \n int i , field ; \n if ( FRAME_MBAFF ( h ) ) \n for ( field = 0 ; field < 2 ; field ++ ) { \n const int poc = h -> cur_pic_ptr -> field_poc [ field ] ; \n const int poc1 = h -> ref_list [ 1 ] [ 0 ] . field_poc [ field ] ; \n for ( i = 0 ; i < 2 * h -> ref_count [ 0 ] ; i ++ ) \n h -> dist_scale_factor_field [ field ] [ i ^ field ] = \n get_scale_factor ( h , poc , poc1 , i + 16 ) ; \n } \n for ( i = 0 ; i < h -> ref_count [ 0 ] ; i ++ ) { \n h -> dist_scale_factor [ i ] = get_scale_factor ( h , poc , poc1 , i ) ; \n } \n }", "idx": 2701}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int crc_write_packet ( struct AVFormatContext * s , \n int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n CRCState * crc = s -> priv_data ; \n crc -> crcval = adler32 ( crc -> crcval , buf , size ) ; \n return 0 ; \n }", "idx": 2708}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct512 ( AC3MDCTContext * mdct , float * out , float * in ) \n { \n mdct -> fft . mdct_calc ( & mdct -> fft , out , in ) ; \n }", "idx": 2730}
{"project": "FFmpeg", "commit_id": "daa1ea049a9445b7bed03963cb789497065dd1eb", "target": 0, "func": "void ff_vp3_h_loop_filter_mmx ( uint8_t * src , int stride , int * bounding_values ) \n { \n x86_reg tmp ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n TRANSPOSE8x4 ( % % mm6 , % % mm0 , % % mm1 , % % mm4 , -2 ( % 2 ) , -2 ( % 2 , % 3 ) , -2 ( % 2 , % 3 , 2 ) , -2 ( % 2 , % 4 ) , % % mm2 ) \n VP3_LOOP_FILTER ( % 5 ) \n SBUTTERFLY ( % % mm4 , % % mm3 , % % mm5 , bw , q ) \n STORE_4_WORDS ( ( % 1 ) , ( % 1 , % 3 ) , ( % 1 , % 3 , 2 ) , ( % 1 , % 4 ) , % % mm4 ) \n STORE_4_WORDS ( ( % 2 ) , ( % 2 , % 3 ) , ( % 2 , % 3 , 2 ) , ( % 2 , % 4 ) , % % mm5 ) \n : \" \" ( tmp ) \n : \" \" ( src ) , \" \" ( src + 4 * stride ) , \" \" ( ( x86_reg ) stride ) , \" \" ( ( x86_reg ) 3 * stride ) , \n \" \" ( * ( uint64_t * ) ( bounding_values + 129 ) ) \n : \" \" \n ) ; \n }", "idx": 2741}
{"project": "FFmpeg", "commit_id": "ee5b34d56e7fa9c1eb1a2aeb2bf7b55516c99c8a", "target": 0, "func": "static uint16_t mlp_checksum16 ( const uint8_t * buf , unsigned int buf_size ) \n { \n uint16_t crc ; \n if ( ! crc_init ) { \n av_crc_init ( crc_2D , 0 , 16 , 0x002D , sizeof ( crc_2D ) ) ; \n crc_init = 1 ; \n } \n crc = av_crc ( crc_2D , 0 , buf , buf_size - 2 ) ; \n crc ^= AV_RL16 ( buf + buf_size - 2 ) ; \n return crc ; \n }", "idx": 2759}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "int ff_mpeg_ref_picture ( MpegEncContext * s , Picture * dst , Picture * src ) \n { \n int ret ; \n av_assert0 ( ! dst -> f . buf [ 0 ] ) ; \n av_assert0 ( src -> f . buf [ 0 ] ) ; \n src -> tf . f = & src -> f ; \n dst -> tf . f = & dst -> f ; \n ret = ff_thread_ref_frame ( & dst -> tf , & src -> tf ) ; \n if ( ret < 0 ) \n goto fail ; \n ret = update_picture_tables ( dst , src ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( src -> hwaccel_picture_private ) { \n dst -> hwaccel_priv_buf = av_buffer_ref ( src -> hwaccel_priv_buf ) ; \n if ( ! dst -> hwaccel_priv_buf ) \n goto fail ; \n dst -> hwaccel_picture_private = dst -> hwaccel_priv_buf -> data ; \n } \n dst -> field_picture = src -> field_picture ; \n dst -> mb_var_sum = src -> mb_var_sum ; \n dst -> mc_mb_var_sum = src -> mc_mb_var_sum ; \n dst -> b_frame_score = src -> b_frame_score ; \n dst -> needs_realloc = src -> needs_realloc ; \n dst -> reference = src -> reference ; \n dst -> shared = src -> shared ; \n return 0 ; \n fail : \n ff_mpeg_unref_picture ( s , dst ) ; \n return ret ; \n }", "idx": 2768}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "int64_t parse_time_or_die ( const char * context , const char * timestr , \n int is_duration ) \n { \n int64_t us ; \n if ( av_parse_time ( & us , timestr , is_duration ) < 0 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , \n is_duration ? \" \" : \" \" , context , timestr ) ; \n exit ( 1 ) ; \n } \n return us ; \n }", "idx": 2770}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "int av_get_packet ( AVIOContext * s , AVPacket * pkt , int size ) \n { \n int ret ; \n size = ffio_limit ( s , size ) ; \n ret = av_new_packet ( pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pos = avio_tell ( s ) ; \n ret = avio_read ( s , pkt -> data , size ) ; \n if ( ret <= 0 ) \n av_free_packet ( pkt ) ; \n else \n av_shrink_packet ( pkt , ret ) ; \n if ( pkt -> size < orig_size ) \n pkt -> flags |= AV_PKT_FLAG_CORRUPT ; \n return ret ; \n }", "idx": 2774}
{"project": "FFmpeg", "commit_id": "62b9fc1571b1354cf596a280b5fe55a9593a7a2f", "target": 1, "func": "int av_reduce ( int * dst_nom , int * dst_den , int64_t nom , int64_t den , int64_t max ) { \n AVRational a0 = { 0 , 1 } , a1 = { 1 , 0 } ; \n int sign = ( nom < 0 ) ^ ( den < 0 ) ; \n int64_t gcd = ff_gcd ( FFABS ( nom ) , FFABS ( den ) ) ; \n nom = FFABS ( nom ) / gcd ; \n den = FFABS ( den ) / gcd ; \n if ( nom <= max && den <= max ) { \n a1 = ( AVRational ) { nom , den } ; \n den = 0 ; \n } \n while ( den ) { \n int64_t x = nom / den ; \n int64_t next_den = nom - den * x ; \n int64_t a2n = x * a1 . num + a0 . num ; \n int64_t a2d = x * a1 . den + a0 . den ; \n if ( a2n > max || a2d > max ) { \n if ( a1 . num ) x = ( max - a0 . num ) / a1 . num ; \n if ( a1 . den ) x = FFMIN ( x , ( max - a0 . den ) / a1 . den ) ; \n if ( den * ( 2 * x * a1 . den + a0 . den ) > nom * a1 . den ) \n a1 = ( AVRational ) { x * a1 . num + a0 . num , x * a1 . den + a0 . den } ; \n break ; \n } \n a0 = a1 ; \n a1 = ( AVRational ) { a2n , a2d } ; \n nom = den ; \n den = next_den ; \n } \n assert ( ff_gcd ( a1 . num , a1 . den ) == 1 ) ; \n * dst_nom = sign ? - a1 . num : a1 . num ; \n * dst_den = a1 . den ; \n return den == 0 ; \n }", "idx": 2780}
{"project": "FFmpeg", "commit_id": "2f7e8dcf45f11df94f47acbe6825cc93514ea59b", "target": 0, "func": "static void filter ( AVFilterContext * ctx , AVFilterBufferRef * dstpic , \n int parity , int tff ) \n { \n YADIFContext * yadif = ctx -> priv ; \n int y , i ; \n for ( i = 0 ; i < yadif -> csp -> nb_components ; i ++ ) { \n int w = dstpic -> video -> w ; \n int h = dstpic -> video -> h ; \n int refs = yadif -> cur -> linesize [ i ] ; \n int df = ( yadif -> csp -> comp [ i ] . depth_minus1 + 8 ) / 8 ; \n if ( i == 1 || i == 2 ) { \n w >>= yadif -> csp -> log2_chroma_w ; \n h >>= yadif -> csp -> log2_chroma_h ; \n } \n for ( y = 0 ; y < h ; y ++ ) { \n if ( ( y ^ parity ) & 1 ) { \n uint8_t * prev = & yadif -> prev -> data [ i ] [ y * refs ] ; \n uint8_t * cur = & yadif -> cur -> data [ i ] [ y * refs ] ; \n uint8_t * next = & yadif -> next -> data [ i ] [ y * refs ] ; \n uint8_t * dst = & dstpic -> data [ i ] [ y * dstpic -> linesize [ i ] ] ; \n int mode = y == 1 || y + 2 == h ? 2 : yadif -> mode ; \n yadif -> filter_line ( dst , prev , cur , next , w , y + 1 < h ? refs : - refs , y ? - refs : refs , parity ^ tff , mode ) ; \n } else { \n memcpy ( & dstpic -> data [ i ] [ y * dstpic -> linesize [ i ] ] , \n & yadif -> cur -> data [ i ] [ y * refs ] , w * df ) ; \n } \n } \n } \n emms_c ( ) ; \n }", "idx": 2785}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static void vorbis_free_extradata ( PayloadContext * data ) \n { \n av_free ( data ) ; \n }", "idx": 2786}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int amr_nb_encode_init ( AVCodecContext * avctx ) \n { \n AMRContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 8000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n avctx -> frame_size = 160 ; \n avctx -> initial_padding = 50 ; \n ff_af_queue_init ( avctx , & s -> afq ) ; \n s -> enc_state = Encoder_Interface_init ( s -> enc_dtx ) ; \n if ( ! s -> enc_state ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n av_freep ( & avctx -> coded_frame ) ; \n return -1 ; \n } \n s -> enc_mode = get_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> enc_bitrate = avctx -> bit_rate ; \n return 0 ; \n }", "idx": 2788}
{"project": "FFmpeg", "commit_id": "6c643e070584ba7af251d3907e277d2170537b1f", "target": 0, "func": "int ff_avc_parse_nal_units ( AVIOContext * pb , const uint8_t * buf_in , int size ) \n { \n const uint8_t * p = buf_in ; \n const uint8_t * end = p + size ; \n const uint8_t * nal_start , * nal_end ; \n size = 0 ; \n nal_start = ff_avc_find_startcode ( p , end ) ; \n while ( nal_start < end ) { \n while ( ! * ( nal_start ++ ) ) ; \n nal_end = ff_avc_find_startcode ( nal_start , end ) ; \n avio_wb32 ( pb , nal_end - nal_start ) ; \n avio_write ( pb , nal_start , nal_end - nal_start ) ; \n size += 4 + nal_end - nal_start ; \n nal_start = nal_end ; \n } \n return size ; \n }", "idx": 2792}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static inline void RENAME ( yuy2ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n #ifdef HAVE_MMXFIXME \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = ( src1 [ 4 * i + 1 ] + src2 [ 4 * i + 1 ] ) >> 1 ; \n dstV [ i ] = ( src1 [ 4 * i + 3 ] + src2 [ 4 * i + 3 ] ) >> 1 ; \n } \n #endif \n }", "idx": 2801}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static inline void bit_copy ( PutBitContext * pb , GetBitContext * gb ) \n { \n int bits_left = get_bits_left ( gb ) ; \n while ( bits_left >= 16 ) { \n put_bits ( pb , 16 , get_bits ( gb , 16 ) ) ; \n bits_left -= 16 ; \n } \n if ( bits_left > 0 ) { \n put_bits ( pb , bits_left , get_bits ( gb , bits_left ) ) ; \n } \n }", "idx": 2813}
{"project": "FFmpeg", "commit_id": "7439475e69f333541c3647f6b9eb5b5af073cb64", "target": 0, "func": "int ff_listen_bind ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout , URLContext * h ) \n { \n int ret ; \n int reuse = 1 ; \n struct pollfd lp = { fd , POLLIN , 0 } ; \n if ( setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & reuse , sizeof ( reuse ) ) ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n } \n ret = bind ( fd , addr , addrlen ) ; \n if ( ret ) \n return ff_neterrno ( ) ; \n ret = listen ( fd , 1 ) ; \n if ( ret ) \n return ff_neterrno ( ) ; \n ret = ff_poll_interrupt ( & lp , 1 , timeout , & h -> interrupt_callback ) ; \n if ( ret < 0 ) \n return ret ; \n ret = accept ( fd , NULL , NULL ) ; \n if ( ret < 0 ) \n return ff_neterrno ( ) ; \n closesocket ( fd ) ; \n ff_socket_nonblock ( ret , 1 ) ; \n return ret ; \n }", "idx": 2824}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int skip_check ( MpegEncContext * s , Picture * p , Picture * ref ) \n { \n int x , y , plane ; \n int score = 0 ; \n int64_t score64 = 0 ; \n for ( plane = 0 ; plane < 3 ; plane ++ ) { \n const int stride = p -> f . linesize [ plane ] ; \n const int bw = plane ? 1 : 2 ; \n for ( y = 0 ; y < s -> mb_height * bw ; y ++ ) { \n for ( x = 0 ; x < s -> mb_width * bw ; x ++ ) { \n int off = p -> shared ? 0 : 16 ; \n uint8_t * dptr = p -> f . data [ plane ] + 8 * ( x + y * stride ) + off ; \n uint8_t * rptr = ref -> f . data [ plane ] + 8 * ( x + y * stride ) ; \n int v = s -> dsp . frame_skip_cmp [ 1 ] ( s , dptr , rptr , stride , 8 ) ; \n switch ( s -> avctx -> frame_skip_exp ) { \n case 0 : score = FFMAX ( score , v ) ; break ; \n case 1 : score += FFABS ( v ) ; break ; \n case 2 : score += v * v ; break ; \n case 3 : score64 += FFABS ( v * v * ( int64_t ) v ) ; break ; \n case 4 : score64 += v * v * ( int64_t ) ( v * v ) ; break ; \n } \n } \n } \n } \n if ( score ) \n score64 = score ; \n if ( score64 < s -> avctx -> frame_skip_threshold ) \n return 1 ; \n if ( score64 < ( ( s -> avctx -> frame_skip_factor * ( int64_t ) s -> lambda ) >> 8 ) ) \n return 1 ; \n return 0 ; \n }", "idx": 2831}
{"project": "FFmpeg", "commit_id": "c96bd21227e594856f8fd0610fd213b002056383", "target": 0, "func": "int ff_mpa_decode_header ( AVCodecContext * avctx , uint32_t head , int * sample_rate ) \n { \n MPADecodeContext s1 , * s = & s1 ; \n s1 . avctx = avctx ; \n if ( ff_mpa_check_header ( head ) != 0 ) \n return -1 ; \n if ( ff_mpegaudio_decode_header ( s , head ) != 0 ) { \n return -1 ; \n } \n switch ( s -> layer ) { \n case 1 : \n avctx -> frame_size = 384 ; \n break ; \n case 2 : \n avctx -> frame_size = 1152 ; \n break ; \n default : \n case 3 : \n if ( s -> lsf ) \n avctx -> frame_size = 576 ; \n else \n avctx -> frame_size = 1152 ; \n break ; \n } \n * sample_rate = s -> sample_rate ; \n avctx -> channels = s -> nb_channels ; \n avctx -> bit_rate = s -> bit_rate ; \n avctx -> sub_id = s -> layer ; \n return s -> frame_size ; \n }", "idx": 2834}
{"project": "FFmpeg", "commit_id": "990450c5bf17afc31a81d6225afaac86d0dca5dd", "target": 1, "func": "static int alloc_buffer ( FrameBuffer * * pool , AVCodecContext * s , FrameBuffer * * pbuf ) \n { \n FrameBuffer * buf = av_mallocz ( sizeof ( * buf ) ) ; \n int i , ret ; \n const int pixel_size = av_pix_fmt_descriptors [ s -> pix_fmt ] . comp [ 0 ] . step_minus1 + 1 ; \n int h_chroma_shift , v_chroma_shift ; \n int edge = 32 ; \n int w = s -> width , h = s -> height ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ! ( s -> flags & CODEC_FLAG_EMU_EDGE ) ) { \n w += 2 * edge ; \n h += 2 * edge ; \n } \n avcodec_align_dimensions ( s , & w , & h ) ; \n if ( ( ret = av_image_alloc ( buf -> base , buf -> linesize , w , h , \n s -> pix_fmt , 32 ) ) < 0 ) { \n av_freep ( & buf ) ; \n return ret ; \n } \n memset ( buf -> base [ 0 ] , 128 , ret ) ; \n avcodec_get_chroma_sub_sample ( s -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n const int h_shift = i == 0 ? 0 : h_chroma_shift ; \n const int v_shift = i == 0 ? 0 : v_chroma_shift ; \n if ( s -> flags & CODEC_FLAG_EMU_EDGE ) \n buf -> data [ i ] = buf -> base [ i ] ; \n else \n buf -> data [ i ] = buf -> base [ i ] + \n FFALIGN ( ( buf -> linesize [ i ] * edge >> v_shift ) + \n ( pixel_size * edge >> h_shift ) , 32 ) ; \n } \n buf -> w = s -> width ; \n buf -> h = s -> height ; \n buf -> pix_fmt = s -> pix_fmt ; \n buf -> pool = pool ; \n * pbuf = buf ; \n return 0 ; \n }", "idx": 2837}
{"project": "FFmpeg", "commit_id": "e5e422bcc3e6deee8c5c5bf8f5aeca2c051542f5", "target": 1, "func": "static int mxf_set_audio_pts ( MXFContext * mxf , AVCodecContext * codec , AVPacket * pkt ) \n { \n MXFTrack * track = mxf -> fc -> streams [ pkt -> stream_index ] -> priv_data ; \n pkt -> pts = track -> sample_count ; \n if ( codec -> channels <= 0 || av_get_bits_per_sample ( codec -> codec_id ) <= 0 ) \n return AVERROR ( EINVAL ) ; \n track -> sample_count += pkt -> size / ( codec -> channels * av_get_bits_per_sample ( codec -> codec_id ) / 8 ) ; \n return 0 ; \n }", "idx": 2838}
{"project": "FFmpeg", "commit_id": "212c6a1d70df011b6f2a2aa02f7677503287bd00", "target": 1, "func": "static void build_basic_mjpeg_vlc ( MJpegDecodeContext * s ) \n { \n build_vlc ( & s -> vlcs [ 0 ] [ 0 ] , avpriv_mjpeg_bits_dc_luminance , \n avpriv_mjpeg_val_dc , 12 , 0 , 0 ) ; \n build_vlc ( & s -> vlcs [ 0 ] [ 1 ] , avpriv_mjpeg_bits_dc_chrominance , \n avpriv_mjpeg_val_dc , 12 , 0 , 0 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 0 ] , avpriv_mjpeg_bits_ac_luminance , \n avpriv_mjpeg_val_ac_luminance , 251 , 0 , 1 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 1 ] , avpriv_mjpeg_bits_ac_chrominance , \n avpriv_mjpeg_val_ac_chrominance , 251 , 0 , 1 ) ; \n build_vlc ( & s -> vlcs [ 2 ] [ 0 ] , avpriv_mjpeg_bits_ac_luminance , \n avpriv_mjpeg_val_ac_luminance , 251 , 0 , 0 ) ; \n build_vlc ( & s -> vlcs [ 2 ] [ 1 ] , avpriv_mjpeg_bits_ac_chrominance , \n avpriv_mjpeg_val_ac_chrominance , 251 , 0 , 0 ) ; \n }", "idx": 2840}
{"project": "FFmpeg", "commit_id": "29638d4db90d5e3fc107c1beb40808f53cc7acaa", "target": 1, "func": "static void filter0 ( int32_t * dst , const int32_t * src , int32_t coeff , ptrdiff_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) \n dst [ i ] -= mul22 ( src [ i ] , coeff ) ; \n }", "idx": 2843}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n int i , k , channel ; \n DCAContext * c = avctx -> priv_data ; \n const int16_t * samples ; \n int ret , real_channel = 0 ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , DCA_MAX_FRAME_SIZE + DCA_HEADER_SIZE ) ) ) \n return ret ; \n samples = ( const int16_t * ) frame -> data [ 0 ] ; \n for ( i = 0 ; i < PCM_SAMPLES ; i ++ ) { \n for ( channel = 0 ; channel < c -> prim_channels + 1 ; channel ++ ) { \n real_channel = c -> channel_order_tab [ channel ] ; \n if ( real_channel >= 0 ) { \n for ( k = 0 ; k < 32 ; k ++ ) { \n c -> pcm [ k ] = samples [ avctx -> channels * ( 32 * i + k ) + channel ] << 16 ; \n } \n qmf_decompose ( c , c -> pcm , & c -> subband [ i ] [ real_channel ] [ 0 ] , real_channel ) ; \n } \n } \n } \n if ( c -> lfe_channel ) { \n for ( i = 0 ; i < PCM_SAMPLES / 2 ; i ++ ) { \n for ( k = 0 ; k < LFE_INTERPOLATION ; k ++ ) \n c -> pcm [ k ] = samples [ avctx -> channels * ( LFE_INTERPOLATION * i + k ) + c -> lfe_offset ] << 16 ; \n c -> lfe_data [ i ] = lfe_downsample ( c , c -> pcm ) ; \n } \n } \n put_frame ( c , c -> subband , avpkt -> data ) ; \n avpkt -> size = c -> frame_size ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 2845}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuv2nv12X ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , int dstFormat ) \n { \n yuv2nv12XinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , dstW , chrDstW , dstFormat ) ; \n }", "idx": 2847}
{"project": "FFmpeg", "commit_id": "58af48f1c3cc98afc1f25d494f197148801cf210", "target": 1, "func": "static int upload_texture ( SDL_Texture * tex , AVFrame * frame , struct SwsContext * * img_convert_ctx ) { \n int ret = 0 ; \n switch ( frame -> format ) { \n case AV_PIX_FMT_YUV420P : \n ret = SDL_UpdateYUVTexture ( tex , NULL , frame -> data [ 0 ] , frame -> linesize [ 0 ] , \n frame -> data [ 1 ] , frame -> linesize [ 1 ] , \n frame -> data [ 2 ] , frame -> linesize [ 2 ] ) ; \n break ; \n case AV_PIX_FMT_BGRA : \n ret = SDL_UpdateTexture ( tex , NULL , frame -> data [ 0 ] , frame -> linesize [ 0 ] ) ; \n break ; \n default : \n * img_convert_ctx = sws_getCachedContext ( * img_convert_ctx , \n frame -> width , frame -> height , frame -> format , frame -> width , frame -> height , \n AV_PIX_FMT_BGRA , sws_flags , NULL , NULL , NULL ) ; \n if ( * img_convert_ctx != NULL ) { \n uint8_t * pixels ; \n int pitch ; \n if ( ! SDL_LockTexture ( tex , NULL , ( void * * ) & pixels , & pitch ) ) { \n sws_scale ( * img_convert_ctx , ( const uint8_t * const * ) frame -> data , frame -> linesize , \n 0 , frame -> height , & pixels , & pitch ) ; \n SDL_UnlockTexture ( tex ) ; \n } \n } else { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n ret = -1 ; \n } \n break ; \n } \n return ret ; \n }", "idx": 2850}
{"project": "FFmpeg", "commit_id": "5a9dd3de63db95704708350bc1c5abb74944cda2", "target": 1, "func": "void avfilter_start_frame ( AVFilterLink * link , AVFilterBufferRef * picref ) \n { \n void ( * start_frame ) ( AVFilterLink * , AVFilterBufferRef * ) ; \n AVFilterPad * dst = & link_dpad ( link ) ; \n FF_DPRINTF_START ( NULL , start_frame ) ; ff_dprintf_link ( NULL , link , 0 ) ; dprintf ( NULL , \" \" ) ; ff_dprintf_ref ( NULL , picref , 1 ) ; \n if ( ! ( start_frame = dst -> start_frame ) ) \n start_frame = avfilter_default_start_frame ; \n if ( ( dst -> min_perms & picref -> perms ) != dst -> min_perms || \n dst -> rej_perms & picref -> perms ) { \n av_log ( link -> dst , AV_LOG_DEBUG , \n \" \\n \" , \n picref -> perms , \n link_dpad ( link ) . min_perms , link_dpad ( link ) . rej_perms ) ; \n link -> cur_buf = avfilter_default_get_video_buffer ( link , dst -> min_perms , link -> w , link -> h ) ; \n link -> src_buf = picref ; \n avfilter_copy_buffer_ref_props ( link -> cur_buf , link -> src_buf ) ; \n } \n else \n link -> cur_buf = picref ; \n start_frame ( link , link -> cur_buf ) ; \n }", "idx": 2852}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void put_pixels_clamped4_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n pixels [ 0 ] = cm [ block [ 0 ] ] ; \n pixels [ 1 ] = cm [ block [ 1 ] ] ; \n pixels [ 2 ] = cm [ block [ 2 ] ] ; \n pixels [ 3 ] = cm [ block [ 3 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 2856}
{"project": "FFmpeg", "commit_id": "515b69f8f8e9a24cfaee95d8c1f63f265d8582fe", "target": 0, "func": "static void check_pred4x4 ( H264PredContext * h , uint8_t * buf0 , uint8_t * buf1 , \n int codec , int chroma_format , int bit_depth ) \n { \n if ( chroma_format == 1 ) { \n uint8_t * topright = buf0 + 2 * 16 ; \n int pred_mode ; \n for ( pred_mode = 0 ; pred_mode < 15 ; pred_mode ++ ) { \n if ( check_pred_func ( h -> pred4x4 [ pred_mode ] , \" \" , pred4x4_modes [ codec ] [ pred_mode ] ) ) { \n randomize_buffers ( ) ; \n call_ref ( src0 , topright , ( ptrdiff_t ) 12 * SIZEOF_PIXEL ) ; \n call_new ( src1 , topright , ( ptrdiff_t ) 12 * SIZEOF_PIXEL ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( src1 , topright , ( ptrdiff_t ) 12 * SIZEOF_PIXEL ) ; \n } \n } \n } \n }", "idx": 2858}
{"project": "FFmpeg", "commit_id": "2904fd398f26f0a2db99dcec54cd009826344c61", "target": 0, "func": "int ff_mov_iso639_to_lang ( const char * lang , int mp4 ) \n { \n int i , code = 0 ; \n for ( i = 0 ; ! mp4 && i < FF_ARRAY_ELEMS ( mov_mdhd_language_map ) ; i ++ ) { \n if ( mov_mdhd_language_map [ i ] && ! strcmp ( lang , mov_mdhd_language_map [ i ] ) ) \n return i ; \n } \n if ( ! mp4 ) \n return 0 ; \n if ( lang [ 0 ] == ' \\0 ' ) \n lang = \" \" ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n unsigned char c = ( unsigned char ) lang [ i ] ; \n if ( c < 0x60 ) \n return 0 ; \n if ( c > 0x60 + 0x1f ) \n return 0 ; \n code <<= 5 ; \n code |= ( c - 0x60 ) ; \n } \n return code ; \n }", "idx": 2859}
{"project": "FFmpeg", "commit_id": "77742c75c5503c848447814a96f16abc6b9aa5f4", "target": 0, "func": "static int dxva2_vp9_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const VP9SharedContext * h = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct vp9_dxva2_picture_context * ctx_pic = h -> frames [ CUR_FRAME ] . hwaccel_picture_private ; \n if ( DXVA_CONTEXT_DECODER ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_CFG ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_COUNT ( avctx , ctx ) <= 0 ) \n return -1 ; \n av_assert0 ( ctx_pic ) ; \n if ( fill_picture_parameters ( avctx , ctx , h , & ctx_pic -> pp ) < 0 ) \n return -1 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 2860}
{"project": "FFmpeg", "commit_id": "dd84efe3c76a5ebf3db254b02870edd193d1a1e7", "target": 1, "func": "static int ass_get_duration ( const uint8_t * p ) \n { \n int sh , sm , ss , sc , eh , em , es , ec ; \n uint64_t start , end ; \n if ( sscanf ( p , \" \" , \n & sh , & sm , & ss , & sc , & eh , & em , & es , & ec ) != 8 ) \n return 0 ; \n start = 3600000 * sh + 60000 * sm + 1000 * ss + 10 * sc ; \n end = 3600000 * eh + 60000 * em + 1000 * es + 10 * ec ; \n return end - start ; \n }", "idx": 2863}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static av_cold int png_enc_init ( AVCodecContext * avctx ) \n { \n PNGEncContext * s = avctx -> priv_data ; \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n ff_huffyuvencdsp_init ( & s -> hdsp ) ; \n s -> filter_type = av_clip ( avctx -> prediction_method , \n PNG_FILTER_VALUE_NONE , \n PNG_FILTER_VALUE_MIXED ) ; \n if ( avctx -> pix_fmt == AV_PIX_FMT_MONOBLACK ) \n s -> filter_type = PNG_FILTER_VALUE_NONE ; \n return 0 ; \n }", "idx": 2866}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int mpegts_probe ( AVProbeData * p ) \n { \n const int size = p -> buf_size ; \n int maxscore = 0 ; \n int sumscore = 0 ; \n int i ; \n int check_count = size / TS_FEC_PACKET_SIZE ; \n #define CHECK_COUNT  10  \n  \n  #define CHECK_BLOCK  100  \n  \n  \n  \n  if ( check_count < CHECK_COUNT ) \n return 0 ; \n for ( i = 0 ; i < check_count ; i += CHECK_BLOCK ) { \n int left = FFMIN ( check_count - i , CHECK_BLOCK ) ; \n int score = analyze ( p -> buf + TS_PACKET_SIZE * i , TS_PACKET_SIZE * left , TS_PACKET_SIZE , NULL , 1 ) ; \n int dvhs_score = analyze ( p -> buf + TS_DVHS_PACKET_SIZE * i , TS_DVHS_PACKET_SIZE * left , TS_DVHS_PACKET_SIZE , NULL , 1 ) ; \n int fec_score = analyze ( p -> buf + TS_FEC_PACKET_SIZE * i , TS_FEC_PACKET_SIZE * left , TS_FEC_PACKET_SIZE , NULL , 1 ) ; \n score = FFMAX3 ( score , dvhs_score , fec_score ) ; \n sumscore += score ; \n maxscore = FFMAX ( maxscore , score ) ; \n } \n sumscore = sumscore * CHECK_COUNT / check_count ; \n maxscore = maxscore * CHECK_COUNT / CHECK_BLOCK ; \n av_dlog ( 0 , \" \\n \" , sumscore , maxscore ) ; \n if ( sumscore > 6 ) return AVPROBE_SCORE_MAX + sumscore - CHECK_COUNT ; \n else if ( maxscore > 6 ) return AVPROBE_SCORE_MAX / 2 + sumscore - CHECK_COUNT ; \n else \n return 0 ; \n }", "idx": 2878}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int ea_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( AV_RL32 ( & p -> buf [ 0 ] ) != SCHl_TAG ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 2890}
{"project": "FFmpeg", "commit_id": "4cb6964244fd6c099383d8b7e99731e72cc844b9", "target": 0, "func": "static inline void int8x8_fmul_int32 ( DCADSPContext * dsp , float * dst , \n const int8_t * src , int scale ) \n { \n dsp -> int8x8_fmul_int32 ( dst , src , scale ) ; \n }", "idx": 2901}
{"project": "FFmpeg", "commit_id": "29638d4db90d5e3fc107c1beb40808f53cc7acaa", "target": 1, "func": "static void filter1 ( int32_t * dst , const int32_t * src , int32_t coeff , ptrdiff_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) \n dst [ i ] -= mul23 ( src [ i ] , coeff ) ; \n }", "idx": 2926}
{"project": "FFmpeg", "commit_id": "0044a8f80df366643bcfaf74011e41a2658c88f8", "target": 1, "func": "static int mpegts_write_end ( AVFormatContext * s ) \n { \n MpegTSWrite * ts = s -> priv_data ; \n MpegTSWriteStream * ts_st ; \n MpegTSService * service ; \n AVStream * st ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n ts_st = st -> priv_data ; \n if ( ts_st -> payload_index > 0 ) { \n mpegts_write_pes ( s , st , ts_st -> payload , ts_st -> payload_index , \n ts_st -> payload_pts ) ; \n } \n } \n put_flush_packet ( & s -> pb ) ; \n for ( i = 0 ; i < ts -> nb_services ; i ++ ) { \n service = ts -> services [ i ] ; \n av_freep ( & service -> provider_name ) ; \n av_freep ( & service -> name ) ; \n av_free ( service ) ; \n } \n av_free ( ts -> services ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n av_free ( st -> priv_data ) ; \n } \n return 0 ; \n }", "idx": 2927}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int microdvd_probe ( AVProbeData * p ) \n { \n unsigned char c ; \n const uint8_t * ptr = p -> buf ; \n int i ; \n if ( AV_RB24 ( ptr ) == 0xEFBBBF ) \n ptr += 3 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( sscanf ( ptr , \" \" , & c ) != 1 && \n sscanf ( ptr , \" \" , & c ) != 1 && \n sscanf ( ptr , \" \" , & c ) != 1 ) \n return 0 ; \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n } \n return AVPROBE_SCORE_MAX ; \n }", "idx": 2928}
{"project": "FFmpeg", "commit_id": "6021615bbe393381f23b34a7cd0dcfd1a42687ba", "target": 0, "func": "static void draw_char ( AVCodecContext * avctx , int c ) \n { \n AnsiContext * s = avctx -> priv_data ; \n int fg = s -> fg ; \n int bg = s -> bg ; \n if ( ( s -> attributes & ATTR_BOLD ) ) \n fg += 8 ; \n if ( ( s -> attributes & ATTR_BLINK ) ) \n bg += 8 ; \n if ( ( s -> attributes & ATTR_REVERSE ) ) \n FFSWAP ( int , fg , bg ) ; \n if ( ( s -> attributes & ATTR_CONCEALED ) ) \n fg = bg ; \n ff_draw_pc_font ( s -> frame -> data [ 0 ] + s -> y * s -> frame -> linesize [ 0 ] + s -> x , \n s -> frame -> linesize [ 0 ] , s -> font , s -> font_height , c , fg , bg ) ; \n s -> x += FONT_WIDTH ; \n if ( s -> x >= avctx -> width ) { \n s -> x = 0 ; \n hscroll ( avctx ) ; \n } \n }", "idx": 2930}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static int init_quantization_noise ( DCAEncContext * c , int noise ) \n { \n int ch , band , ret = 0 ; \n c -> consumed_bits = 132 + 493 * c -> fullband_channels ; \n if ( c -> lfe_channel ) \n c -> consumed_bits += 72 ; \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n for ( band = 0 ; band < 32 ; band ++ ) { \n int snr_cb = c -> peak_cb [ band ] [ ch ] - c -> band_masking_cb [ band ] - noise ; \n if ( snr_cb >= 1312 ) { \n c -> abits [ band ] [ ch ] = 26 ; \n ret |= USED_26ABITS ; \n } else if ( snr_cb >= 222 ) { \n c -> abits [ band ] [ ch ] = 8 + mul32 ( snr_cb - 222 , 69000000 ) ; \n ret |= USED_NABITS ; \n } else if ( snr_cb >= 0 ) { \n c -> abits [ band ] [ ch ] = 2 + mul32 ( snr_cb , 106000000 ) ; \n ret |= USED_NABITS ; \n } else { \n c -> abits [ band ] [ ch ] = 1 ; \n ret |= USED_1ABITS ; \n } \n } \n } \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n c -> consumed_bits += bit_consumption [ c -> abits [ band ] [ ch ] ] ; \n } \n return ret ; \n }", "idx": 2932}
{"project": "FFmpeg", "commit_id": "b77e26b28525f366c5f978214b230a5324bedf81", "target": 0, "func": "static void hevc_await_progress ( HEVCContext * s , HEVCFrame * ref , \n const Mv * mv , int y0 , int height ) \n { \n int y = FFMAX ( 0 , ( mv -> y >> 2 ) + y0 + height + 9 ) ; \n if ( s -> threads_type == FF_THREAD_FRAME ) \n ff_thread_await_progress ( & ref -> tf , y , 0 ) ; \n }", "idx": 2933}
{"project": "FFmpeg", "commit_id": "324ff59444ff5470bb325ff1e2be7c4b054fc944", "target": 0, "func": "void ff_interleave_add_packet ( AVFormatContext * s , AVPacket * pkt , \n int ( * compare ) ( AVFormatContext * , AVPacket * , AVPacket * ) ) \n { \n AVPacketList * * next_point , * this_pktl ; \n this_pktl = av_mallocz ( sizeof ( AVPacketList ) ) ; \n this_pktl -> pkt = * pkt ; \n #if FF_API_DESTRUCT_PACKET  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n pkt -> destruct = NULL ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n pkt -> buf = NULL ; \n av_dup_packet ( & this_pktl -> pkt ) ; \n if ( s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer ) { \n next_point = & ( s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer -> next ) ; \n } else \n next_point = & s -> packet_buffer ; \n if ( * next_point ) { \n if ( compare ( s , & s -> packet_buffer_end -> pkt , pkt ) ) { \n while ( ! compare ( s , & ( * next_point ) -> pkt , pkt ) ) \n next_point = & ( * next_point ) -> next ; \n goto next_non_null ; \n } else { \n next_point = & ( s -> packet_buffer_end -> next ) ; \n } \n } \n assert ( ! * next_point ) ; \n s -> packet_buffer_end = this_pktl ; \n next_non_null : \n this_pktl -> next = * next_point ; \n s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer = \n * next_point = this_pktl ; \n }", "idx": 2935}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s , AVFrame * frame ) \n { \n int x , y ; \n unsigned char P [ 2 ] ; \n unsigned int flags ; \n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n for ( y = 0 ; y < 8 ; y ++ ) { \n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ; \n for ( ; flags != 1 ; flags >>= 1 ) \n * s -> pixel_ptr ++ = P [ flags & 1 ] ; \n s -> pixel_ptr += s -> line_inc ; \n } else { \n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ; \n for ( y = 0 ; y < 8 ; y += 2 ) { \n for ( x = 0 ; x < 8 ; x += 2 , flags >>= 1 ) { \n s -> pixel_ptr [ x ] = \n s -> pixel_ptr [ x + 1 ] = \n s -> pixel_ptr [ x + s -> stride ] = \n s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ; \n s -> pixel_ptr += s -> stride * 2 ; \n return 0 ;", "idx": 2937}
{"project": "FFmpeg", "commit_id": "d371c3c2e2830d9783465ecfe1ab7d93351083b7", "target": 1, "func": "static int config_input_props ( AVFilterLink * inlink ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n Frei0rContext * s = ctx -> priv ; \n if ( ! ( s -> instance = s -> construct ( inlink -> w , inlink -> h ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n return set_params ( ctx , s -> params ) ; \n }", "idx": 2944}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb32ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n const int a = ( ( uint32_t * ) src1 ) [ 2 * i + 0 ] ; \n const int e = ( ( uint32_t * ) src1 ) [ 2 * i + 1 ] ; \n const int l = ( a & 0xFF00FF ) + ( e & 0xFF00FF ) ; \n const int h = ( a & 0x00FF00 ) + ( e & 0x00FF00 ) ; \n const int r = l & 0x3FF ; \n const int g = h >> 8 ; \n const int b = l >> 16 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n } \n }", "idx": 2947}
{"project": "FFmpeg", "commit_id": "acb2c79c2102026747468dcafa6780ab1094b3c5", "target": 1, "func": "static av_cold void init_vlcs ( FourXContext * f ) \n { \n static VLC_TYPE table [ 8 ] [ 32 ] [ 2 ] ; \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n block_type_vlc [ 0 ] [ i ] . table = table [ i ] ; \n block_type_vlc [ 0 ] [ i ] . table_allocated = 32 ; \n init_vlc ( & block_type_vlc [ 0 ] [ i ] , BLOCK_TYPE_VLC_BITS , 7 , \n & block_type_tab [ 0 ] [ i ] [ 0 ] [ 1 ] , 2 , 1 , \n & block_type_tab [ 0 ] [ i ] [ 0 ] [ 0 ] , 2 , 1 , INIT_VLC_USE_NEW_STATIC ) ; \n } \n }", "idx": 2949}
{"project": "FFmpeg", "commit_id": "dadc43eee4d9036aa532665a04720238cc15e922", "target": 1, "func": "PCA * ff_pca_init ( int n ) { \n PCA * pca ; \n if ( n <= 0 ) \n pca = av_mallocz ( sizeof ( * pca ) ) ; \n pca -> n = n ; \n pca -> z = av_malloc_array ( n , sizeof ( * pca -> z ) ) ; \n pca -> count = 0 ; \n pca -> covariance = av_calloc ( n * n , sizeof ( double ) ) ; \n pca -> mean = av_calloc ( n , sizeof ( double ) ) ; \n return pca ; ", "idx": 2955}
{"project": "FFmpeg", "commit_id": "83b707613181c01fd4e9d25dda6787af439d2e41", "target": 1, "func": "static void floor_fit ( vorbis_enc_context * venc , vorbis_enc_floor * fc , \n float * coeffs , uint_fast16_t * posts , int samples ) \n { \n int range = 255 / fc -> multiplier + 1 ; \n int i ; \n float tot_average = 0. ; \n float averages [ fc -> values ] ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n averages [ i ] = get_floor_average ( fc , coeffs , i ) ; \n tot_average += averages [ i ] ; \n } \n tot_average /= fc -> values ; \n tot_average /= venc -> quality ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n int position = fc -> list [ fc -> list [ i ] . sort ] . x ; \n float average = averages [ i ] ; \n int j ; \n average *= pow ( tot_average / average , 0.5 ) * pow ( 1.25 , position / 200. ) ; \n for ( j = 0 ; j < range - 1 ; j ++ ) \n if ( ff_vorbis_floor1_inverse_db_table [ j * fc -> multiplier ] > average ) \n break ; \n posts [ fc -> list [ i ] . sort ] = j ; \n } \n }", "idx": 2959}
{"project": "FFmpeg", "commit_id": "c4ba5198ea48f8f648d85a853ea46e29001c12c8", "target": 1, "func": "void av_destruct_packet ( AVPacket * pkt ) \n { \n int i ; \n av_free ( pkt -> data ) ; \n pkt -> data = NULL ; pkt -> size = 0 ; \n for ( i = 0 ; i < pkt -> side_data_elems ; i ++ ) \n av_free ( pkt -> side_data [ i ] . data ) ; \n av_freep ( & pkt -> side_data ) ; \n pkt -> side_data_elems = 0 ; \n }", "idx": 2960}
{"project": "FFmpeg", "commit_id": "0e4b185a8df12c7b42642699a8df45e0de48de07", "target": 1, "func": "static int rtp_parse_mp4_au ( RTPDemuxContext * s , const uint8_t * buf ) \n { \n int au_headers_length , au_header_size , i ; \n GetBitContext getbitcontext ; \n RTPPayloadData * infos ; \n infos = s -> rtp_payload_data ; \n if ( infos == NULL ) \n return -1 ; \n au_headers_length = AV_RB16 ( buf ) ; \n if ( au_headers_length > RTP_MAX_PACKET_LENGTH ) \n return -1 ; \n infos -> au_headers_length_bytes = ( au_headers_length + 7 ) / 8 ; \n buf += 2 ; \n init_get_bits ( & getbitcontext , buf , infos -> au_headers_length_bytes * 8 ) ; \n au_header_size = infos -> sizelength + infos -> indexlength ; \n if ( au_header_size <= 0 || ( au_headers_length % au_header_size != 0 ) ) \n return -1 ; \n infos -> nb_au_headers = au_headers_length / au_header_size ; \n infos -> au_headers = av_malloc ( sizeof ( struct AUHeaders ) * infos -> nb_au_headers ) ; \n infos -> au_headers [ 0 ] . size = 0 ; \n infos -> au_headers [ 0 ] . index = 0 ; \n for ( i = 0 ; i < infos -> nb_au_headers ; ++ i ) { \n infos -> au_headers [ 0 ] . size += get_bits_long ( & getbitcontext , infos -> sizelength ) ; \n infos -> au_headers [ 0 ] . index = get_bits_long ( & getbitcontext , infos -> indexlength ) ; \n infos -> nb_au_headers = 1 ; \n return 0 ;", "idx": 2962}
{"project": "FFmpeg", "commit_id": "b4800b8b7dfba22117d8edd02164b00c83ae3753", "target": 1, "func": "static int mxf_add_metadata_set ( MXFContext * mxf , void * metadata_set ) \n { \n mxf -> metadata_sets = av_realloc ( mxf -> metadata_sets , ( mxf -> metadata_sets_count + 1 ) * sizeof ( * mxf -> metadata_sets ) ) ; \n if ( ! mxf -> metadata_sets ) \n return -1 ; \n mxf -> metadata_sets [ mxf -> metadata_sets_count ] = metadata_set ; \n mxf -> metadata_sets_count ++ ; \n return 0 ; \n }", "idx": 2971}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_type ( FTPContext * s ) \n { \n const char * command = \" \\r \\n \" ; \n const int type_codes [ ] = { 200 , 0 } ; \n if ( ! ftp_send_command ( s , command , type_codes , NULL ) ) \n return AVERROR ( EIO ) ; \n return 0 ; \n }", "idx": 2974}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold int indeo3_decode_init ( AVCodecContext * avctx ) \n { \n Indeo3DecodeContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n avctx -> pix_fmt = PIX_FMT_YUV410P ; \n build_modpred ( s ) ; \n iv_alloc_frames ( s ) ; \n return 0 ; \n }", "idx": 2986}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void avcodec_set_dimensions ( AVCodecContext * s , int width , int height ) { \n s -> coded_width = width ; \n s -> coded_height = height ; \n s -> width = width ; \n s -> height = height ; \n }", "idx": 2999}
{"project": "FFmpeg", "commit_id": "aac46e088d67a390489af686b846dea4987d8ffb", "target": 0, "func": "static void sbr_qmf_analysis ( DSPContext * dsp , FFTContext * mdct , const float * in , float * x , \n float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] ) \n { \n int i , k ; \n memcpy ( W [ 0 ] , W [ 1 ] , sizeof ( W [ 0 ] ) ) ; \n memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ; \n memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ; \n for ( k = 0 ; k < 64 ; k ++ ) { \n float f = z [ k ] + z [ k + 64 ] + z [ k + 128 ] + z [ k + 192 ] + z [ k + 256 ] ; \n z [ k ] = f ; \n } \n z [ 64 ] = z [ 0 ] ; \n for ( k = 1 ; k < 32 ; k ++ ) { \n z [ 64 + 2 * k - 1 ] = z [ k ] ; \n z [ 64 + 2 * k ] = - z [ 64 - k ] ; \n } \n z [ 64 + 63 ] = z [ 32 ] ; \n mdct -> imdct_half ( mdct , z , z + 64 ) ; \n for ( k = 0 ; k < 32 ; k ++ ) { \n W [ 1 ] [ i ] [ k ] [ 0 ] = - z [ 63 - k ] ; \n W [ 1 ] [ i ] [ k ] [ 1 ] = z [ k ] ; \n } \n x += 32 ; \n } \n }", "idx": 3012}
{"project": "FFmpeg", "commit_id": "6ac9afd16e385fc450c58b8a3fb44baa99ea4af9", "target": 0, "func": "audio_get_output_timestamp ( AVFormatContext * s1 , int stream , \n int64_t * dts , int64_t * wall )  \n { \n AlsaData * s = s1 -> priv_data ; \n snd_pcm_sframes_t delay = 0 ; \n * wall = av_gettime ( ) ; \n snd_pcm_delay ( s -> h , & delay ) ; \n * dts = s1 -> streams [ 0 ] -> cur_dts - delay ; \n }", "idx": 3023}
{"project": "FFmpeg", "commit_id": "79eff9132581af69fbbd2674337b75fad29aa306", "target": 0, "func": "void avcodec_get_context_defaults2 ( AVCodecContext * s , enum AVMediaType codec_type ) { \n int flags = 0 ; \n memset ( s , 0 , sizeof ( AVCodecContext ) ) ; \n s -> av_class = & av_codec_context_class ; \n s -> codec_type = codec_type ; \n if ( codec_type == AVMEDIA_TYPE_AUDIO ) \n flags = AV_OPT_FLAG_AUDIO_PARAM ; \n else if ( codec_type == AVMEDIA_TYPE_VIDEO ) \n flags = AV_OPT_FLAG_VIDEO_PARAM ; \n else if ( codec_type == AVMEDIA_TYPE_SUBTITLE ) \n flags = AV_OPT_FLAG_SUBTITLE_PARAM ; \n av_opt_set_defaults2 ( s , flags , flags ) ; \n s -> time_base = ( AVRational ) { 0 , 1 } ; \n s -> get_buffer = avcodec_default_get_buffer ; \n s -> release_buffer = avcodec_default_release_buffer ; \n s -> get_format = avcodec_default_get_format ; \n s -> execute = avcodec_default_execute ; \n s -> execute2 = avcodec_default_execute2 ; \n s -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> pix_fmt = PIX_FMT_NONE ; \n s -> sample_fmt = AV_SAMPLE_FMT_NONE ; \n s -> palctrl = NULL ; \n s -> reget_buffer = avcodec_default_reget_buffer ; \n s -> reordered_opaque = AV_NOPTS_VALUE ; \n }", "idx": 3034}
{"project": "FFmpeg", "commit_id": "ed1f8915daf6b84a940463dfe83c7b970f82383d", "target": 0, "func": "static int ffserver_opt_preset ( const char * arg , \n AVCodecContext * avctx , int type , \n enum AVCodecID * audio_id , enum AVCodecID * video_id ) \n { \n FILE * f = NULL ; \n char filename [ 1000 ] , tmp [ 1000 ] , tmp2 [ 1000 ] , line [ 1000 ] ; \n int ret = 0 ; \n AVCodec * codec = avcodec_find_encoder ( avctx -> codec_id ) ; \n if ( ! ( f = get_preset_file ( filename , sizeof ( filename ) , arg , 0 , \n codec ? codec -> name : NULL ) ) ) { \n fprintf ( stderr , \" \\n \" , arg ) ; \n return 1 ; \n } \n while ( ! feof ( f ) ) { \n int e = fscanf ( f , \" \\n \\n \" , line ) - 1 ; \n if ( line [ 0 ] == ' ' && ! e ) \n continue ; \n e |= sscanf ( line , \" \\n \\n \" , tmp , tmp2 ) - 2 ; \n if ( e ) { \n fprintf ( stderr , \" \\n \" , filename , line ) ; \n ret = 1 ; \n break ; \n } \n if ( ! strcmp ( tmp , \" \" ) ) { \n * audio_id = opt_codec ( tmp2 , AVMEDIA_TYPE_AUDIO ) ; \n } else if ( ! strcmp ( tmp , \" \" ) ) { \n * video_id = opt_codec ( tmp2 , AVMEDIA_TYPE_VIDEO ) ; \n } else if ( ! strcmp ( tmp , \" \" ) ) { \n } else if ( ffserver_opt_default ( tmp , tmp2 , avctx , type ) < 0 ) { \n fprintf ( stderr , \" \\n \" , filename , line , tmp , tmp2 ) ; \n ret = 1 ; \n break ; \n } \n } \n fclose ( f ) ; \n return ret ; \n }", "idx": 3043}
{"project": "FFmpeg", "commit_id": "f141b353e60f1081185927a1e74a9ab46cae8bef", "target": 1, "func": "static void celt_search_for_intensity ( OpusPsyContext * s , CeltFrame * f ) \n { \n int i , best_band = CELT_MAX_BANDS - 1 ; \n float dist , best_dist = FLT_MAX ; \n float end_band = 0 ; \n for ( i = f -> end_band ; i >= end_band ; i -- ) { \n f -> intensity_stereo = i ; \n bands_dist ( s , f , & dist ) ; \n if ( best_dist > dist ) { \n best_dist = dist ; \n best_band = i ; \n } \n } \n f -> intensity_stereo = best_band ; \n s -> avg_is_band = ( s -> avg_is_band + f -> intensity_stereo ) / 2.0f ; \n }", "idx": 3072}
{"project": "FFmpeg", "commit_id": "2d216336f80b294af056a8b1ee8c7306f4d543f3", "target": 1, "func": "static int usage ( int ret ) \n { \n fprintf ( stderr , \" \\n \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n return ret ; \n }", "idx": 3074}
{"project": "FFmpeg", "commit_id": "1b3a7e1f42c3d89253e9837ada98e6bfb0cbab2f", "target": 1, "func": "static av_noinline void emulated_edge_mc_sse ( uint8_t * buf , ptrdiff_t buf_stride , \n const uint8_t * src , ptrdiff_t src_stride , \n int block_w , int block_h , \n int src_x , int src_y , int w , int h ) \n { \n emulated_edge_mc ( buf , buf_stride , src , src_stride , block_w , block_h , src_x , \n src_y , w , h , vfixtbl_sse , & ff_emu_edge_vvar_sse , hfixtbl_sse , \n #if ARCH_X86_64 \n & ff_emu_edge_hvar_sse \n #else \n & ff_emu_edge_hvar_mmx \n #endif \n ) ; \n }", "idx": 3077}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 512 ] ) ; \n samples [ i + 256 ] = samples [ i + 512 ] = 0 ; \n } \n }", "idx": 3086}
{"project": "FFmpeg", "commit_id": "530eb6acf8ee867bf00728bf7efaf505da107e17", "target": 1, "func": "static int hls_write_trailer ( struct AVFormatContext * s ) \n { \n HLSContext * hls = s -> priv_data ; \n AVFormatContext * oc = hls -> avf ; \n av_write_trailer ( oc ) ; \n hls -> size = avio_tell ( hls -> avf -> pb ) - hls -> start_pos ; \n avio_closep ( & oc -> pb ) ; \n avformat_free_context ( oc ) ; \n av_free ( hls -> basename ) ; \n hls_append_segment ( hls , hls -> duration , hls -> start_pos , hls -> size ) ; \n hls_window ( s , 1 ) ; \n hls_free_segments ( hls ) ; \n avio_close ( hls -> pb ) ; \n return 0 ; \n }", "idx": 3090}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "static int compat_read ( AVFilterContext * ctx , AVFilterBufferRef * * pbuf , int nb_samples , int flags ) \n { \n AVFilterBufferRef * buf ; \n AVFrame * frame ; \n int ret ; \n if ( ! pbuf ) \n return ff_poll_frame ( ctx -> inputs [ 0 ] ) ; \n frame = av_frame_alloc ( ) ; \n if ( ! frame ) \n return AVERROR ( ENOMEM ) ; \n if ( ! nb_samples ) \n ret = av_buffersink_get_frame_flags ( ctx , frame , flags ) ; \n else \n ret = av_buffersink_get_samples ( ctx , frame , nb_samples ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( ctx -> inputs [ 0 ] -> type == AVMEDIA_TYPE_VIDEO ) { \n buf = avfilter_get_video_buffer_ref_from_arrays ( frame -> data , frame -> linesize , \n AV_PERM_READ , \n frame -> width , frame -> height , \n frame -> format ) ; \n } else { \n buf = avfilter_get_audio_buffer_ref_from_arrays ( frame -> extended_data , \n frame -> linesize [ 0 ] , AV_PERM_READ , \n frame -> nb_samples , \n frame -> format , \n frame -> channel_layout ) ; \n } \n if ( ! buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n avfilter_copy_frame_props ( buf , frame ) ; \n buf -> buf -> priv = frame ; \n buf -> buf -> free = compat_free_buffer ; \n * pbuf = buf ; \n return 0 ; \n fail : \n av_frame_free ( & frame ) ; \n return ret ; \n }", "idx": 3097}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 3111}
{"project": "FFmpeg", "commit_id": "57d24225595af78b0fd836d4d145f5d181e320a2", "target": 0, "func": "static int check_recording_time ( OutputStream * ost ) \n { \n OutputFile * of = output_files [ ost -> file_index ] ; \n if ( of -> recording_time != INT64_MAX && \n av_compare_ts ( ost -> sync_opts - ost -> first_pts , ost -> st -> codec -> time_base , of -> recording_time , \n AV_TIME_BASE_Q ) >= 0 ) { \n ost -> is_past_recording_time = 1 ; \n return 0 ; \n } \n return 1 ; \n }", "idx": 3112}
{"project": "FFmpeg", "commit_id": "0393cf15dbe3b136647b81676a105815924eebcd", "target": 1, "func": "void av_parser_close ( AVCodecParserContext * s ) \n { \n if ( s ) { \n if ( s -> parser -> parser_close ) { \n ff_lock_avcodec ( NULL ) ; \n s -> parser -> parser_close ( s ) ; \n ff_unlock_avcodec ( ) ; \n } \n av_free ( s -> priv_data ) ; \n av_free ( s ) ; \n } \n }", "idx": 3120}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 3 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 3125}
{"project": "FFmpeg", "commit_id": "80e103d04cf938fc1f479347d0ab2f8c6e688b61", "target": 0, "func": "void mjpeg_picture_header ( MpegEncContext * s ) \n { \n put_marker ( & s -> pb , SOI ) ; \n jpeg_table_header ( s ) ; \n put_marker ( & s -> pb , SOF0 ) ; \n put_bits ( & s -> pb , 16 , 17 ) ; \n put_bits ( & s -> pb , 8 , 8 ) ; \n put_bits ( & s -> pb , 16 , s -> height ) ; \n put_bits ( & s -> pb , 16 , s -> width ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 8 , 1 ) ; \n put_bits ( & s -> pb , 4 , 2 ) ; \n put_bits ( & s -> pb , 4 , 2 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_bits ( & s -> pb , 8 , 2 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_marker ( & s -> pb , SOS ) ; \n put_bits ( & s -> pb , 16 , 12 ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 8 , 1 ) ; \n put_bits ( & s -> pb , 4 , 0 ) ; \n put_bits ( & s -> pb , 4 , 0 ) ; \n put_bits ( & s -> pb , 8 , 2 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 3 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 4 , 1 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n put_bits ( & s -> pb , 8 , 63 ) ; \n put_bits ( & s -> pb , 8 , 0 ) ; \n }", "idx": 3126}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_glbl ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return AVERROR_INVALIDDATA ; \n if ( atom . size >= 10 ) { \n unsigned size = avio_rb32 ( pb ) ; \n unsigned type = avio_rl32 ( pb ) ; \n avio_seek ( pb , -8 , SEEK_CUR ) ; \n if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && size == atom . size ) \n return mov_read_default ( c , pb , atom ) ; \n } \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size ; \n avio_read ( pb , st -> codec -> extradata , atom . size ) ; \n return 0 ; \n }", "idx": 3137}
{"project": "FFmpeg", "commit_id": "0fbc9bbbbb39b9a6f62d57f237052b64eefac578", "target": 1, "func": "static int nppscale_resize ( AVFilterContext * ctx , NPPScaleStageContext * stage , \n AVFrame * out , AVFrame * in ) \n { \n NPPScaleContext * s = ctx -> priv ; \n NppStatus err ; \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( in -> data ) && in -> data [ i ] ; i ++ ) { \n int iw = stage -> planes_in [ i ] . width ; \n int ih = stage -> planes_in [ i ] . height ; \n int ow = stage -> planes_out [ i ] . width ; \n int oh = stage -> planes_out [ i ] . height ; \n err = nppiResizeSqrPixel_8u_C1R ( in -> data [ i ] , ( NppiSize ) { iw , ih } , \n in -> linesize [ i ] , ( NppiRect ) { 0 , 0 , iw , ih } , \n out -> data [ i ] , out -> linesize [ i ] , \n ( NppiRect ) { 0 , 0 , ow , oh } , \n ( double ) ow / iw , ( double ) oh / ih , \n 0.0 , 0.0 , s -> interp_algo ) ; \n if ( err != NPP_SUCCESS ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , err ) ; \n return AVERROR_UNKNOWN ; \n } \n } \n return 0 ; \n }", "idx": 3139}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr16 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x3E0 ) >> 5 ; \n b = ( rgb & 0x7C00 ) >> 10 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x3F ) << 5 ) | ( ( r & 0x1F ) << 11 ) ; \n } \n }", "idx": 3142}
{"project": "FFmpeg", "commit_id": "9b01a8ad5ecf88aa0a8e52c2b70816e03ef59162", "target": 0, "func": "void avformat_close_input ( AVFormatContext * * ps ) \n { \n AVFormatContext * s = * ps ; \n AVIOContext * pb = ( s -> iformat -> flags & AVFMT_NOFILE ) || ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ? \n NULL : s -> pb ; \n flush_packet_queue ( s ) ; \n if ( s -> iformat -> read_close ) \n s -> iformat -> read_close ( s ) ; \n avformat_free_context ( s ) ; \n * ps = NULL ; \n if ( pb ) \n avio_close ( pb ) ; \n }", "idx": 3145}
{"project": "FFmpeg", "commit_id": "1c088632e98af96f9cbe8129c5d7eb7274f8d4ed", "target": 0, "func": "static int hevc_parse_slice_header ( AVCodecParserContext * s , H2645NAL * nal , \n AVCodecContext * avctx ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n GetBitContext * gb = & nal -> gb ; \n HEVCPPS * pps ; \n HEVCSPS * sps ; \n unsigned int pps_id ; \n get_bits1 ( gb ) ; \n if ( IS_IRAP_NAL ( nal ) ) \n get_bits1 ( gb ) ; \n pps_id = get_ue_golomb_long ( gb ) ; \n if ( pps_id >= HEVC_MAX_PPS_COUNT || ! ctx -> ps . pps_list [ pps_id ] ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , pps_id ) ; \n return AVERROR_INVALIDDATA ; \n } \n pps = ( HEVCPPS * ) ctx -> ps . pps_list [ pps_id ] -> data ; \n sps = ( HEVCSPS * ) ctx -> ps . sps_list [ pps -> sps_id ] -> data ; \n s -> coded_width = sps -> width ; \n s -> coded_height = sps -> height ; \n s -> width = sps -> output_width ; \n s -> height = sps -> output_height ; \n s -> format = sps -> pix_fmt ; \n avctx -> profile = sps -> ptl . general_ptl . profile_idc ; \n avctx -> level = sps -> ptl . general_ptl . level_idc ; \n return 0 ; \n }", "idx": 3149}
{"project": "FFmpeg", "commit_id": "82b9e4a286e904dd402ddf6c914756963b2e2c4d", "target": 1, "func": "static int64_t asf_read_pts ( AVFormatContext * s , int64_t * ppos , int stream_index ) \n { \n ASFContext * asf = s -> priv_data ; \n AVPacket pkt1 , * pkt = & pkt1 ; \n int64_t pos = * ppos ; \n int64_t pts ; \n assert ( pos % asf -> packet_size == 0 ) ; \n url_fseek ( & s -> pb , pos + s -> data_offset , SEEK_SET ) ; \n do { \n pos = url_ftell ( & s -> pb ) - s -> data_offset ; \n asf_reset_header ( s ) ; \n if ( av_read_frame ( s , pkt ) < 0 ) \n return AV_NOPTS_VALUE ; \n pts = pkt -> pts ; \n av_free_packet ( pkt ) ; \n } while ( pkt -> stream_index != stream_index ) ; \n * ppos = pos ; \n return pts ; \n }", "idx": 3156}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int qtrle_decode_init ( AVCodecContext * avctx ) \n { \n QtrleContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_coded_sample ) { \n case 1 : \n case 33 : \n avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; \n break ; \n case 2 : \n case 4 : \n case 8 : \n case 34 : \n case 36 : \n case 40 : \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n break ; \n case 16 : \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n break ; \n case 24 : \n avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; \n break ; \n case 32 : \n avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> bits_per_coded_sample ) ; \n return AVERROR_INVALIDDATA ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 3164}
{"project": "FFmpeg", "commit_id": "c3c96deb5f8cbbdb700ba97920ceedddacb5dcb9", "target": 0, "func": "static void fft_ref_init ( int nbits , int inverse ) \n { \n int i , n = 1 << nbits ; \n exptab = av_malloc ( ( n / 2 ) * sizeof ( * exptab ) ) ; \n for ( i = 0 ; i < ( n / 2 ) ; i ++ ) { \n double alpha = 2 * M_PI * ( float ) i / ( float ) n ; \n double c1 = cos ( alpha ) , s1 = sin ( alpha ) ; \n if ( ! inverse ) \n s1 = - s1 ; \n exptab [ i ] . re = c1 ; \n exptab [ i ] . im = s1 ; \n } \n }", "idx": 3165}
{"project": "FFmpeg", "commit_id": "8a2e2fc34aaeb0c092a9fd08d18bd5af7d240f1d", "target": 0, "func": "inline static int push_frame ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n ShowWavesContext * showwaves = outlink -> src -> priv ; \n int nb_channels = inlink -> channels ; \n int ret , i ; \n if ( ( ret = ff_filter_frame ( outlink , showwaves -> outpicref ) ) >= 0 ) \n showwaves -> req_fullfilled = 1 ; \n showwaves -> outpicref = NULL ; \n showwaves -> buf_idx = 0 ; \n for ( i = 0 ; i < nb_channels ; i ++ ) \n showwaves -> buf_idy [ i ] = 0 ; \n return ret ; \n }", "idx": 3166}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "void av_image_copy ( uint8_t * dst_data [ 4 ] , int dst_linesizes [ 4 ] , \n const uint8_t * src_data [ 4 ] , const int src_linesizes [ 4 ] , \n enum PixelFormat pix_fmt , int width , int height ) \n { \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n if ( desc -> flags & PIX_FMT_HWACCEL ) \n return ; \n if ( desc -> flags & PIX_FMT_PAL ) { \n av_image_copy_plane ( dst_data [ 0 ] , dst_linesizes [ 0 ] , \n src_data [ 0 ] , src_linesizes [ 0 ] , \n width , height ) ; \n memcpy ( dst_data [ 1 ] , src_data [ 1 ] , 4 * 256 ) ; \n } else { \n int i , planes_nb = 0 ; \n for ( i = 0 ; i < desc -> nb_components ; i ++ ) \n planes_nb = FFMAX ( planes_nb , desc -> comp [ i ] . plane + 1 ) ; \n for ( i = 0 ; i < planes_nb ; i ++ ) { \n int h = height ; \n int bwidth = av_image_get_linesize ( pix_fmt , width , i ) ; \n if ( i == 1 || i == 2 ) { \n h = - ( ( - height ) >> desc -> log2_chroma_h ) ; \n } \n av_image_copy_plane ( dst_data [ i ] , dst_linesizes [ i ] , \n src_data [ i ] , src_linesizes [ i ] , \n bwidth , h ) ; \n } \n } \n }", "idx": 3171}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int bmp_encode_init ( AVCodecContext * avctx ) { \n switch ( avctx -> pix_fmt ) { \n case AV_PIX_FMT_BGR24 : \n avctx -> bits_per_coded_sample = 24 ; \n break ; \n case AV_PIX_FMT_RGB555 : \n case AV_PIX_FMT_RGB565 : \n case AV_PIX_FMT_RGB444 : \n avctx -> bits_per_coded_sample = 16 ; \n break ; \n case AV_PIX_FMT_RGB8 : \n case AV_PIX_FMT_BGR8 : \n case AV_PIX_FMT_RGB4_BYTE : \n case AV_PIX_FMT_BGR4_BYTE : \n case AV_PIX_FMT_GRAY8 : \n case AV_PIX_FMT_PAL8 : \n avctx -> bits_per_coded_sample = 8 ; \n break ; \n case AV_PIX_FMT_MONOBLACK : \n avctx -> bits_per_coded_sample = 1 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_INFO , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 3186}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void ERROR ( const char * str ) \n { \n fprintf ( stderr , \" \\n \" , str ) ; \n exit ( 1 ) ; \n }", "idx": 3194}
{"project": "FFmpeg", "commit_id": "fb7a2bf6956173eda6f9caceef8599fa4f83500d", "target": 0, "func": "static unsigned int codec_get_asf_tag ( const CodecTag * tags , unsigned int id ) \n { \n while ( tags -> id != 0 ) { \n if ( ! tags -> invalid_asf && tags -> id == id ) \n return tags -> tag ; \n tags ++ ; \n } \n return 0 ; \n }", "idx": 3198}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( yuyvtoyuv420 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n long width , long height , \n long lumStride , long chromStride , long srcStride ) \n { \n long y ; \n const long chromWidth = - ( ( - width ) >> 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src , ydst , width ) ; \n if ( y & 1 ) { \n RENAME ( extract_odd2avg ) ( src - srcStride , src , udst , vdst , chromWidth ) ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n src += srcStride ; \n ydst += lumStride ; \n } \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n #endif \n }", "idx": 3206}
{"project": "FFmpeg", "commit_id": "8176bd1a4689ff08b0e85984563ad8288110f1a7", "target": 1, "func": "static uint64_t log16 ( uint64_t a ) { \n int i ; \n int out = 0 ; \n assert ( a >= ( 1 << 16 ) ) ; \n a <<= 16 ; \n for ( i = 19 ; i >= 0 ; i -- ) { \n if ( a < ( exp16_table [ i ] << 16 ) ) continue ; \n out |= 1 << i ; \n a = ( ( a << 16 ) + exp16_table [ i ] / 2 ) / exp16_table [ i ] ; \n } \n return out ; \n }", "idx": 3208}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_track ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFTrack * track = arg ; \n switch ( tag ) { \n case 0x4801 : \n track -> track_id = avio_rb32 ( pb ) ; \n break ; \n case 0x4804 : \n avio_read ( pb , track -> track_number , 4 ) ; \n break ; \n case 0x4B01 : \n track -> edit_rate . den = avio_rb32 ( pb ) ; \n track -> edit_rate . num = avio_rb32 ( pb ) ; \n break ; \n case 0x4803 : \n avio_read ( pb , track -> sequence_ref , 16 ) ; \n break ; \n } \n return 0 ; \n }", "idx": 3209}
{"project": "FFmpeg", "commit_id": "03d83ba34b2070878909eae18dfac0f519503777", "target": 0, "func": "static av_cold int gif_encode_init ( AVCodecContext * avctx ) \n { \n GIFContext * s = avctx -> priv_data ; \n if ( avctx -> width > 65535 || avctx -> height > 65535 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n s -> transparent_index = -1 ; \n s -> lzw = av_mallocz ( ff_lzw_encode_state_size ) ; \n s -> buf = av_malloc ( avctx -> width * avctx -> height * 2 ) ; \n s -> tmpl = av_malloc ( avctx -> width ) ; \n if ( ! s -> tmpl || ! s -> buf || ! s -> lzw ) \n return AVERROR ( ENOMEM ) ; \n if ( avpriv_set_systematic_pal2 ( s -> palette , avctx -> pix_fmt ) < 0 ) \n av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) ; \n return 0 ; \n }", "idx": 3222}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_h264_init ( AVCodecContext * avctx ) \n { \n return ff_vaapi_encode_init ( avctx , & vaapi_encode_type_h264 ) ; \n }", "idx": 3231}
{"project": "FFmpeg", "commit_id": "a48b890392aa22033f182421ba9e3f3b3256461d", "target": 1, "func": "static void decode_channel_map ( uint8_t layout_map [ ] [ 3 ] , \n enum ChannelPosition type , \n GetBitContext * gb , int n ) \n { \n while ( n -- ) { \n enum RawDataBlockType syn_ele ; \n switch ( type ) { \n case AAC_CHANNEL_FRONT : \n case AAC_CHANNEL_BACK : \n case AAC_CHANNEL_SIDE : \n syn_ele = get_bits1 ( gb ) ; \n break ; \n case AAC_CHANNEL_CC : \n skip_bits1 ( gb ) ; \n syn_ele = TYPE_CCE ; \n break ; \n case AAC_CHANNEL_LFE : \n syn_ele = TYPE_LFE ; \n break ; \n } \n layout_map [ 0 ] [ 0 ] = syn_ele ; \n layout_map [ 0 ] [ 1 ] = get_bits ( gb , 4 ) ; \n layout_map [ 0 ] [ 2 ] = type ; \n layout_map ++ ; \n } \n }", "idx": 3239}
{"project": "FFmpeg", "commit_id": "5a7bd28335d502d90c727f69a50e6f251c305e72", "target": 0, "func": "void align_get_bits ( GetBitContext * s ) \n { \n int n = ( - get_bits_count ( s ) ) & 7 ; \n if ( n ) skip_bits ( s , n ) ; \n }", "idx": 3242}
{"project": "FFmpeg", "commit_id": "c5fd57f483d2ad8e34551b78509f1e14136f73c0", "target": 1, "func": "static int vp8_packet ( AVFormatContext * s , int idx ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n uint8_t * p = os -> buf + os -> pstart ; \n if ( ( ! os -> lastpts || os -> lastpts == AV_NOPTS_VALUE ) && \n ! ( os -> flags & OGG_FLAG_EOS ) ) { \n int seg ; \n int duration ; \n uint8_t * last_pkt = p ; \n uint8_t * next_pkt ; \n seg = os -> segp ; \n duration = ( last_pkt [ 0 ] >> 4 ) & 1 ; \n next_pkt = last_pkt += os -> psize ; \n for ( ; seg < os -> nsegs ; seg ++ ) { \n if ( os -> segments [ seg ] < 255 ) { \n duration += ( last_pkt [ 0 ] >> 4 ) & 1 ; \n last_pkt = next_pkt + os -> segments [ seg ] ; \n } \n next_pkt += os -> segments [ seg ] ; \n } \n os -> lastpts = \n os -> lastdts = vp8_gptopts ( s , idx , os -> granule , NULL ) - duration ; \n if ( s -> streams [ idx ] -> start_time == AV_NOPTS_VALUE ) { \n s -> streams [ idx ] -> start_time = os -> lastpts ; \n if ( s -> streams [ idx ] -> duration ) \n s -> streams [ idx ] -> duration -= s -> streams [ idx ] -> start_time ; \n } \n } \n if ( os -> psize > 0 ) \n os -> pduration = ( p [ 0 ] >> 4 ) & 1 ; \n return 0 ; \n }", "idx": 3247}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_vert_dc_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t out0 = 0 , out1 = 0 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n v4i32 res0 , res1 ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( src_top , src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n sum = ( v4u32 ) __msa_srari_w ( ( v4i32 ) sum , 2 ) ; \n res0 = ( v4i32 ) __msa_splati_b ( ( v16i8 ) sum , 0 ) ; \n res1 = ( v4i32 ) __msa_splati_b ( ( v16i8 ) sum , 4 ) ; \n out0 = __msa_copy_u_w ( res0 , 0 ) ; \n out1 = __msa_copy_u_w ( res1 , 0 ) ; \n for ( lp_cnt = 8 ; lp_cnt -- ; ) { \n SW ( out0 , src ) ; \n SW ( out1 , src + 4 ) ; \n src += stride ; \n } \n }", "idx": 3252}
{"project": "FFmpeg", "commit_id": "dcd3418a35aab7ef283b68ed9997ce4ac204094e", "target": 0, "func": "static int get_cv_transfer_function ( AVCodecContext * avctx , \n CFStringRef * transfer_fnc , \n CFNumberRef * gamma_level ) \n { \n enum AVColorTransferCharacteristic trc = avctx -> color_trc ; \n Float32 gamma ; \n * gamma_level = NULL ; \n switch ( trc ) { \n case AVCOL_TRC_UNSPECIFIED : \n * transfer_fnc = NULL ; \n break ; \n case AVCOL_TRC_BT709 : \n * transfer_fnc = kCVImageBufferTransferFunction_ITU_R_709_2 ; \n break ; \n case AVCOL_TRC_SMPTE240M : \n * transfer_fnc = kCVImageBufferTransferFunction_SMPTE_240M_1995 ; \n break ; \n case AVCOL_TRC_GAMMA22 : \n gamma = 2.2 ; \n * transfer_fnc = kCVImageBufferTransferFunction_UseGamma ; \n * gamma_level = CFNumberCreate ( NULL , kCFNumberFloat32Type , & gamma ) ; \n break ; \n case AVCOL_TRC_GAMMA28 : \n gamma = 2.8 ; \n * transfer_fnc = kCVImageBufferTransferFunction_UseGamma ; \n * gamma_level = CFNumberCreate ( NULL , kCFNumberFloat32Type , & gamma ) ; \n break ; \n case AVCOL_TRC_BT2020_10 : \n case AVCOL_TRC_BT2020_12 : \n * transfer_fnc = kCVImageBufferTransferFunction_ITU_R_2020 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , av_color_transfer_name ( trc ) ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 3263}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr24 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n } \n }", "idx": 3282}
{"project": "FFmpeg", "commit_id": "6bc03a695bc4c1ecd212263c4a3c9cf638d025e0", "target": 1, "func": "static int dyn_buf_write ( void * opaque , uint8_t * buf , int buf_size ) \n { \n DynBuffer * d = opaque ; \n int new_size , new_allocated_size ; \n new_size = d -> pos + buf_size ; \n new_allocated_size = d -> allocated_size ; \n if ( new_size < d -> pos || new_size > INT_MAX / 2 ) \n return -1 ; \n while ( new_size > new_allocated_size ) { \n if ( ! new_allocated_size ) \n new_allocated_size = new_size ; \n else \n new_allocated_size += new_allocated_size / 2 + 1 ; \n } \n if ( new_allocated_size > d -> allocated_size ) { \n d -> buffer = av_realloc ( d -> buffer , new_allocated_size ) ; \n if ( d -> buffer == NULL ) \n return -1234 ; \n d -> allocated_size = new_allocated_size ; \n } \n memcpy ( d -> buffer + d -> pos , buf , buf_size ) ; \n d -> pos = new_size ; \n if ( d -> pos > d -> size ) \n d -> size = d -> pos ; \n return buf_size ; \n }", "idx": 3283}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static void uncouple_channels ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int ch , sbnd , bin ; \n int index ; \n int16_t mantissa ; \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ab -> chincpl & ( 1 << ch ) ) \n for ( sbnd = ab -> cplbegf ; sbnd < 3 + ab -> cplendf ; sbnd ++ ) \n for ( bin = 0 ; bin < 12 ; bin ++ ) { \n index = sbnd * 12 + bin + 37 ; \n ab -> transform_coeffs [ ch + 1 ] [ index ] = ab -> cplcoeffs [ index ] * ab -> cplco [ ch ] [ sbnd ] * ab -> chcoeffs [ ch ] ; \n if ( ! ab -> bap [ ch ] [ index ] && ( ab -> chincpl & ( 1 << ch ) ) && ( ab -> dithflag & ( 1 << ch ) ) ) { \n mantissa = dither_int16 ( & ctx -> state ) ; \n ab -> transform_coeffs [ ch + 1 ] [ index ] = to_float ( ab -> dexps [ ch ] [ index ] , mantissa ) * ab -> chcoeffs [ ch ] ; \n } \n } \n }", "idx": 3289}
{"project": "FFmpeg", "commit_id": "3c29f68b4db316c5d2b126619220cfa4255eacd6", "target": 1, "func": "static int convert_zp2tf ( AVFilterContext * ctx , int channels ) \n { \n AudioIIRContext * s = ctx -> priv ; \n int ch , i , j , ret ; \n for ( ch = 0 ; ch < channels ; ch ++ ) { \n IIRChannel * iir = & s -> iir [ ch ] ; \n double * topc , * botc ; \n topc = av_calloc ( ( iir -> nb_ab [ 0 ] + 1 ) * 2 , sizeof ( * topc ) ) ; \n botc = av_calloc ( ( iir -> nb_ab [ 1 ] + 1 ) * 2 , sizeof ( * botc ) ) ; \n if ( ! topc || ! botc ) \n return AVERROR ( ENOMEM ) ; \n ret = expand ( ctx , iir -> ab [ 0 ] , iir -> nb_ab [ 0 ] , botc ) ; \n if ( ret < 0 ) { \n av_free ( topc ) ; \n av_free ( botc ) ; \n return ret ; \n } \n ret = expand ( ctx , iir -> ab [ 1 ] , iir -> nb_ab [ 1 ] , topc ) ; \n if ( ret < 0 ) { \n av_free ( topc ) ; \n av_free ( botc ) ; \n return ret ; \n } \n for ( j = 0 , i = iir -> nb_ab [ 1 ] ; i >= 0 ; j ++ , i -- ) { \n iir -> ab [ 1 ] [ j ] = topc [ 2 * i ] ; \n } \n iir -> nb_ab [ 1 ] ++ ; \n for ( j = 0 , i = iir -> nb_ab [ 0 ] ; i >= 0 ; j ++ , i -- ) { \n iir -> ab [ 0 ] [ j ] = botc [ 2 * i ] ; \n } \n iir -> nb_ab [ 0 ] ++ ; \n av_free ( topc ) ; \n av_free ( botc ) ; \n } \n return 0 ; \n }", "idx": 3294}
{"project": "FFmpeg", "commit_id": "a33c7dd21362a694692d0dc30fdbffae5a5d837e", "target": 1, "func": "static int decode_hybrid ( const uint8_t * sptr , uint8_t * dptr , int dx , int dy , \n int h , int w , int stride , const uint32_t * pal ) \n { \n int x , y ; \n const uint8_t * orig_src = sptr ; \n for ( y = dx + h ; y > dx ; y -- ) { \n uint8_t * dst = dptr + ( y * stride ) + dy * 3 ; \n for ( x = 0 ; x < w ; x ++ ) { \n if ( * sptr & 0x80 ) { \n unsigned c = AV_RB16 ( sptr ) & ~ 0x8000 ; \n unsigned b = c & 0x1F ; \n unsigned g = ( c >> 5 ) & 0x1F ; \n unsigned r = c >> 10 ; \n * dst ++ = ( b << 3 ) | ( b >> 2 ) ; \n * dst ++ = ( g << 3 ) | ( g >> 2 ) ; \n * dst ++ = ( r << 3 ) | ( r >> 2 ) ; \n sptr += 2 ; \n } else { \n uint32_t c = pal [ * sptr ++ ] ; \n bytestream_put_le24 ( & dst , c ) ; \n } \n } \n } \n return sptr - orig_src ; \n }", "idx": 3295}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_flush_control_input ( FTPContext * s ) \n { \n char buf [ CONTROL_BUFFER_SIZE ] ; \n int err , ori_block_flag = s -> conn_control_block_flag ; \n s -> conn_control_block_flag = 1 ; \n do { \n err = ftp_get_line ( s , buf , sizeof ( buf ) ) ; \n } while ( ! err ) ; \n s -> conn_control_block_flag = ori_block_flag ; \n if ( err < 0 && err != AVERROR_EXIT ) \n return err ; \n return 0 ; \n }", "idx": 3315}
{"project": "FFmpeg", "commit_id": "971d12b7f9d7be3ca8eb98e6c04ed521f83cbd3c", "target": 1, "func": "int64_t av_gcd ( int64_t a , int64_t b ) \n { \n if ( b ) \n return av_gcd ( b , a % b ) ; \n else \n return a ; \n }", "idx": 3323}
{"project": "FFmpeg", "commit_id": "ebfe154bd52204a4da19d26d8d5ae0f8003558ac", "target": 1, "func": "static inline int ape_decode_value_3900 ( APEContext * ctx , APERice * rice ) \n { \n unsigned int x , overflow ; \n int tmpk ; \n overflow = range_get_symbol ( ctx , counts_3970 , counts_diff_3970 ) ; \n if ( overflow == ( MODEL_ELEMENTS - 1 ) ) { \n tmpk = range_decode_bits ( ctx , 5 ) ; \n overflow = 0 ; \n } else \n tmpk = ( rice -> k < 1 ) ? 0 : rice -> k - 1 ; \n if ( tmpk <= 16 || ctx -> fileversion < 3910 ) { \n if ( tmpk > 23 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , tmpk ) ; \n return AVERROR_INVALIDDATA ; \n } \n x = range_decode_bits ( ctx , tmpk ) ; \n } else if ( tmpk <= 32 ) { \n x = range_decode_bits ( ctx , 16 ) ; \n x |= ( range_decode_bits ( ctx , tmpk - 16 ) << 16 ) ; \n } else { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , tmpk ) ; \n return AVERROR_INVALIDDATA ; \n } \n x += overflow << tmpk ; \n update_rice ( rice , x ) ; \n if ( x & 1 ) \n return ( x >> 1 ) + 1 ; \n else \n return - ( x >> 1 ) ; \n }", "idx": 3324}
{"project": "FFmpeg", "commit_id": "1cb0edb40b8e94e1a50ad40c40d43e34ed8435fe", "target": 1, "func": "int avcodec_decode_video ( AVCodecContext * avctx , AVPicture * picture , \n int * got_picture_ptr , \n UINT8 * buf , int buf_size ) \n { \n int ret ; \n ret = avctx -> codec -> decode ( avctx , picture , got_picture_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n return ret ; \n }", "idx": 3325}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static void do_bit_allocation ( AC3DecodeContext * ctx , int flags ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int i , snroffst = 0 ; \n if ( ! flags ) \n return ; \n if ( ab -> flags & AC3_AB_SNROFFSTE ) { \n snroffst += ab -> csnroffst ; \n if ( ab -> flags & AC3_AB_CPLINU ) \n snroffst += ab -> cplfsnroffst ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n snroffst += ab -> fsnroffst [ i ] ; \n if ( ctx -> bsi . flags & AC3_BSI_LFEON ) \n snroffst += ab -> lfefsnroffst ; \n if ( ! snroffst ) { \n memset ( ab -> cplbap , 0 , sizeof ( ab -> cplbap ) ) ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n memset ( ab -> bap [ i ] , 0 , sizeof ( ab -> bap [ i ] ) ) ; \n memset ( ab -> lfebap , 0 , sizeof ( ab -> lfebap ) ) ; \n return ; \n } \n } \n if ( ( ab -> flags & AC3_AB_CPLINU ) && ( flags & 64 ) ) \n do_bit_allocation1 ( ctx , 5 ) ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n if ( flags & ( 1 << i ) ) \n do_bit_allocation1 ( ctx , i ) ; \n if ( ( ctx -> bsi . flags & AC3_BSI_LFEON ) && ( flags & 32 ) ) \n do_bit_allocation1 ( ctx , 6 ) ; \n }", "idx": 3329}
{"project": "FFmpeg", "commit_id": "e2d1eace00a80c4b53998397d38ea4e08c5d47f0", "target": 0, "func": "static int adx_decode_header ( AVCodecContext * avctx , const uint8_t * buf , \n int bufsize ) \n { \n int offset ; \n if ( buf [ 0 ] != 0x80 ) \n return 0 ; \n offset = ( AV_RB32 ( buf ) ^ 0x80000000 ) + 4 ; \n if ( bufsize < offset || memcmp ( buf + offset - 6 , \" \" , 6 ) ) \n return 0 ; \n avctx -> channels = buf [ 7 ] ; \n avctx -> sample_rate = AV_RB32 ( buf + 8 ) ; \n avctx -> bit_rate = avctx -> sample_rate * avctx -> channels * 18 * 8 / 32 ; \n return offset ; \n }", "idx": 3331}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_dualmono_to_stereo ( float * samples ) \n { \n int i ; \n float tmp ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n tmp = samples [ i ] + samples [ i + 256 ] ; \n samples [ i ] = samples [ i + 256 ] = tmp ; \n } \n }", "idx": 3369}
{"project": "FFmpeg", "commit_id": "8af4ac5272e8eaff90c3102b9473bb09cc6f4201", "target": 0, "func": "static int64_t mmsh_read_seek ( URLContext * h , int stream_index , \n int64_t timestamp , int flags ) \n { \n MMSHContext * mmsh = h -> priv_data ; \n MMSContext * mms = & mmsh -> mms ; \n int ret ; \n ret = mmsh_open_internal ( h , mmsh -> location , 0 , timestamp , 0 ) ; \n if ( ret >= 0 ) { \n if ( mms -> mms_hd ) \n ffurl_close ( mms -> mms_hd ) ; \n av_freep ( & mms -> streams ) ; \n av_freep ( & mms -> asf_header ) ; \n av_free ( mmsh ) ; \n mmsh = h -> priv_data ; \n mms = & mmsh -> mms ; \n mms -> asf_header_read_size = mms -> asf_header_size ; \n } else \n h -> priv_data = mmsh ; \n return ret ; \n }", "idx": 3370}
{"project": "FFmpeg", "commit_id": "f67a0d115254461649470452058fa3c28c0df294", "target": 0, "func": "static int read_huffman_tables ( HYuvContext * s , const uint8_t * src , int length ) \n { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , src , length * 8 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( read_len_table ( s -> len [ i ] , & gb ) < 0 ) \n return -1 ; \n if ( ff_huffyuv_generate_bits_table ( s -> bits [ i ] , s -> len [ i ] ) < 0 ) { \n return -1 ; \n } \n ff_free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , \n s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return ( get_bits_count ( & gb ) + 7 ) / 8 ; \n }", "idx": 3382}
{"project": "FFmpeg", "commit_id": "ce1ebb31a9a0e556a89cd7681082af19fbc1cced", "target": 0, "func": "static unsigned tget_long ( GetByteContext * gb , int le ) \n { \n unsigned v = le ? bytestream2_get_le32u ( gb ) : bytestream2_get_be32u ( gb ) ; \n return v ; \n }", "idx": 3385}
{"project": "FFmpeg", "commit_id": "159fb8ff7e4038edf13e91d3c08bc7b8abc369b9", "target": 1, "func": "static int ir2_decode_plane ( Ir2Context * ctx , int width , int height , uint8_t * dst , \n int pitch , const uint8_t * table ) \n { \n int i ; \n int j ; \n int out = 0 ; \n if ( width & 1 ) \n return AVERROR_INVALIDDATA ; \n while ( out < width ) { \n int c = ir2_get_code ( & ctx -> gb ) ; \n if ( c >= 0x80 ) { \n c -= 0x7F ; \n if ( out + c * 2 > width ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < c * 2 ; i ++ ) \n dst [ out ++ ] = 0x80 ; \n } else { \n dst [ out ++ ] = table [ c * 2 ] ; \n dst [ out ++ ] = table [ ( c * 2 ) + 1 ] ; \n } \n } \n dst += pitch ; \n for ( j = 1 ; j < height ; j ++ ) { \n out = 0 ; \n if ( get_bits_left ( & ctx -> gb ) <= 0 ) \n return AVERROR_INVALIDDATA ; \n while ( out < width ) { \n int c = ir2_get_code ( & ctx -> gb ) ; \n if ( c >= 0x80 ) { \n c -= 0x7F ; \n if ( out + c * 2 > width ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < c * 2 ; i ++ ) { \n dst [ out ] = dst [ out - pitch ] ; \n out ++ ; \n } \n } else { \n int t = dst [ out - pitch ] + ( table [ c * 2 ] - 128 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n t = dst [ out - pitch ] + ( table [ ( c * 2 ) + 1 ] - 128 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n } \n } \n dst += pitch ; \n } \n return 0 ; \n }", "idx": 3386}
{"project": "FFmpeg", "commit_id": "e7b95918fca1c3d057d35f77ba58ee2d00d03151", "target": 1, "func": "static int codec_reinit ( AVCodecContext * avctx , int width , int height , int quality ) { \n NuvContext * c = avctx -> priv_data ; \n width = ( width + 1 ) & ~ 1 ; \n height = ( height + 1 ) & ~ 1 ; \n if ( quality >= 0 ) \n get_quant_quality ( c , quality ) ; \n if ( width != c -> width || height != c -> height ) { \n if ( av_image_check_size ( height , width , 0 , avctx ) < 0 ) \n return 0 ; \n avctx -> width = c -> width = width ; \n avctx -> height = c -> height = height ; \n c -> decomp_size = c -> height * c -> width * 3 / 2 ; \n c -> decomp_buf = av_realloc ( c -> decomp_buf , c -> decomp_size + AV_LZO_OUTPUT_PADDING ) ; \n if ( ! c -> decomp_buf ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n rtjpeg_decode_init ( & c -> rtj , & c -> dsp , c -> width , c -> height , c -> lq , c -> cq ) ; \n } else if ( quality != c -> quality ) \n rtjpeg_decode_init ( & c -> rtj , & c -> dsp , c -> width , c -> height , c -> lq , c -> cq ) ; \n return 1 ; \n }", "idx": 3389}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "void ff_get_wav_header ( AVIOContext * pb , AVCodecContext * codec , int size ) \n { \n int id ; \n id = avio_rl16 ( pb ) ; \n codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n codec -> codec_tag = id ; \n codec -> channels = avio_rl16 ( pb ) ; \n codec -> sample_rate = avio_rl32 ( pb ) ; \n codec -> bit_rate = avio_rl32 ( pb ) * 8 ; \n codec -> block_align = avio_rl16 ( pb ) ; \n if ( size == 14 ) { \n codec -> bits_per_coded_sample = 8 ; \n } else \n codec -> bits_per_coded_sample = avio_rl16 ( pb ) ; \n if ( size >= 18 ) { \n int cbSize = avio_rl16 ( pb ) ; \n size -= 18 ; \n cbSize = FFMIN ( size , cbSize ) ; \n if ( cbSize >= 22 && id == 0xfffe ) { \n codec -> bits_per_coded_sample = avio_rl16 ( pb ) ; \n codec -> channel_layout = avio_rl32 ( pb ) ; \n id = avio_rl32 ( pb ) ; \n avio_skip ( pb , 12 ) ; \n cbSize -= 22 ; \n size -= 22 ; \n } \n codec -> extradata_size = cbSize ; \n if ( cbSize > 0 ) { \n codec -> extradata = av_mallocz ( codec -> extradata_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n avio_read ( pb , codec -> extradata , codec -> extradata_size ) ; \n size -= cbSize ; \n } \n if ( size > 0 ) \n avio_skip ( pb , size ) ; \n } \n codec -> codec_id = ff_wav_codec_get_id ( id , codec -> bits_per_coded_sample ) ; \n if ( codec -> codec_id == CODEC_ID_AAC_LATM ) { \n codec -> channels = 0 ; \n codec -> sample_rate = 0 ; \n } \n }", "idx": 3393}
{"project": "FFmpeg", "commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "target": 1, "func": "static int dxtory_decode_v1_420 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 3 / 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 2 ) { \n for ( w = 0 ; w < avctx -> width ; w += 2 ) { \n AV_COPY16 ( Y1 + w , src ) ; \n AV_COPY16 ( Y2 + w , src + 2 ) ; \n U [ w >> 1 ] = src [ 4 ] + 0x80 ; \n V [ w >> 1 ] = src [ 5 ] + 0x80 ; \n src += 6 ; \n } \n Y1 += pic -> linesize [ 0 ] << 1 ; \n Y2 += pic -> linesize [ 0 ] << 1 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 3403}
{"project": "FFmpeg", "commit_id": "ab28108a361196134704071b7b34c42fc7d747c7", "target": 0, "func": "static int dxva2_hevc_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const HEVCContext * h = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct hevc_dxva2_picture_context * ctx_pic = h -> ref -> hwaccel_picture_private ; \n if ( ! DXVA_CONTEXT_VALID ( avctx , ctx ) ) \n return -1 ; \n av_assert0 ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , h , & ctx_pic -> pp ) ; \n fill_scaling_lists ( ctx , h , & ctx_pic -> qm ) ; \n ctx_pic -> slice_count = 0 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 3405}
{"project": "FFmpeg", "commit_id": "0db5b2b9f8a96298eeba7988d43c4eb44220fab3", "target": 0, "func": "static uint8_t * ogg_write_vorbiscomment ( int offset , int bitexact , \n int * header_len , AVDictionary * * m , int framing_bit ) \n { \n const char * vendor = bitexact ? \" \" : LIBAVFORMAT_IDENT ; \n int size ; \n uint8_t * p , * p0 ; \n ff_metadata_conv ( m , ff_vorbiscomment_metadata_conv , NULL ) ; \n size = offset + ff_vorbiscomment_length ( * m , vendor ) + framing_bit ; \n p = av_mallocz ( size ) ; \n if ( ! p ) \n return NULL ; \n p0 = p ; \n p += offset ; \n ff_vorbiscomment_write ( & p , m , vendor ) ; \n if ( framing_bit ) \n bytestream_put_byte ( & p , 1 ) ; \n * header_len = size ; \n return p0 ; \n }", "idx": 3406}
{"project": "FFmpeg", "commit_id": "b9fa32082c71013e90eab9e9997967d2939cf4a6", "target": 1, "func": "void ff_imdct_calc ( MDCTContext * s , FFTSample * output , \n const FFTSample * input , FFTSample * tmp ) \n { \n int k , n8 , n4 , n2 , n , j ; \n const uint16_t * revtab = s -> fft . revtab ; \n const FFTSample * tcos = s -> tcos ; \n const FFTSample * tsin = s -> tsin ; \n const FFTSample * in1 , * in2 ; \n FFTComplex * z = ( FFTComplex * ) tmp ; \n n = 1 << s -> nbits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n n8 = n >> 3 ; \n in1 = input ; \n in2 = input + n2 - 1 ; \n for ( k = 0 ; k < n4 ; k ++ ) { \n j = revtab [ k ] ; \n CMUL ( z [ j ] . re , z [ j ] . im , * in2 , * in1 , tcos [ k ] , tsin [ k ] ) ; \n in1 += 2 ; \n in2 -= 2 ; \n } \n ff_fft_calc ( & s -> fft , z ) ; \n for ( k = 0 ; k < n4 ; k ++ ) { \n CMUL ( z [ k ] . re , z [ k ] . im , z [ k ] . re , z [ k ] . im , tcos [ k ] , tsin [ k ] ) ; \n } \n for ( k = 0 ; k < n8 ; k ++ ) { \n output [ 2 * k ] = - z [ n8 + k ] . im ; \n output [ n2 - 1 - 2 * k ] = z [ n8 + k ] . im ; \n output [ 2 * k + 1 ] = z [ n8 - 1 - k ] . re ; \n output [ n2 - 1 - 2 * k - 1 ] = - z [ n8 - 1 - k ] . re ; \n output [ n2 + 2 * k ] = - z [ k + n8 ] . re ; \n output [ n - 1 - 2 * k ] = - z [ k + n8 ] . re ; \n output [ n2 + 2 * k + 1 ] = z [ n8 - k - 1 ] . im ; \n output [ n - 2 - 2 * k ] = z [ n8 - k - 1 ] . im ; \n } \n }", "idx": 3410}
{"project": "FFmpeg", "commit_id": "6f20921deec135a68f78cb327472ea6cf28644a5", "target": 1, "func": "static int applehttp_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n AppleHTTPContext * c = s -> priv_data ; \n int i , j , ret ; \n if ( ( flags & AVSEEK_FLAG_BYTE ) || ! c -> variants [ 0 ] -> finished ) \n return AVERROR ( ENOSYS ) ; \n timestamp = av_rescale_rnd ( timestamp , 1 , stream_index >= 0 ? \n s -> streams [ stream_index ] -> time_base . den : \n AV_TIME_BASE , flags & AVSEEK_FLAG_BACKWARD ? \n AV_ROUND_DOWN : AV_ROUND_UP ) ; \n ret = AVERROR ( EIO ) ; \n for ( i = 0 ; i < c -> n_variants ; i ++ ) { \n struct variant * var = c -> variants [ i ] ; \n int64_t pos = 0 ; \n if ( var -> input ) { \n ffurl_close ( var -> input ) ; \n var -> input = NULL ; \n } \n av_free_packet ( & var -> pkt ) ; \n reset_packet ( & var -> pkt ) ; \n var -> pb . eof_reached = 0 ; \n for ( j = 0 ; j < var -> n_segments ; j ++ ) { \n if ( timestamp >= pos && \n timestamp < pos + var -> segments [ j ] -> duration ) { \n var -> cur_seq_no = var -> start_seq_no + j ; \n ret = 0 ; \n break ; \n } \n pos += var -> segments [ j ] -> duration ; \n } \n } \n return ret ; \n }", "idx": 3412}
{"project": "FFmpeg", "commit_id": "8e90c7285d1cbf62a9c9a5f9e6efda998dc0d454", "target": 1, "func": "static int get_metadata ( AVFormatContext * s , \n const char * const tag , \n const unsigned data_size ) \n { \n uint8_t * buf = ( ( data_size + 1 ) == 0 ) ? NULL : av_malloc ( data_size + 1 ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( avio_read ( s -> pb , buf , data_size ) < 0 ) { \n av_free ( buf ) ; \n return AVERROR ( EIO ) ; \n } \n buf [ data_size ] = 0 ; \n av_dict_set ( & s -> metadata , tag , buf , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 3415}
{"project": "FFmpeg", "commit_id": "3cffbe090a5168dcfe580de8d662a32e7ad1d911", "target": 1, "func": "void avcodec_get_context_defaults2 ( AVCodecContext * s , enum CodecType codec_type ) { \n int flags = 0 ; \n memset ( s , 0 , sizeof ( AVCodecContext ) ) ; \n s -> av_class = & av_codec_context_class ; \n s -> codec_type = codec_type ; \n if ( codec_type == CODEC_TYPE_AUDIO ) \n flags = AV_OPT_FLAG_AUDIO_PARAM ; \n else if ( codec_type == CODEC_TYPE_VIDEO ) \n flags = AV_OPT_FLAG_VIDEO_PARAM ; \n else if ( codec_type == CODEC_TYPE_SUBTITLE ) \n flags = AV_OPT_FLAG_SUBTITLE_PARAM ; \n av_opt_set_defaults2 ( s , flags , flags ) ; \n s -> rc_eq = av_strdup ( \" \" ) ; \n s -> time_base = ( AVRational ) { 0 , 1 } ; \n s -> get_buffer = avcodec_default_get_buffer ; \n s -> release_buffer = avcodec_default_release_buffer ; \n s -> get_format = avcodec_default_get_format ; \n s -> execute = avcodec_default_execute ; \n s -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> pix_fmt = PIX_FMT_NONE ; \n s -> sample_fmt = SAMPLE_FMT_S16 ; \n s -> palctrl = NULL ; \n s -> reget_buffer = avcodec_default_reget_buffer ; \n }", "idx": 3421}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void encode_quant_matrix ( VC2EncContext * s ) \n { \n int level , custom_quant_matrix = 0 ; \n if ( s -> wavelet_depth > 4 || s -> quant_matrix != VC2_QM_DEF ) \n custom_quant_matrix = 1 ; \n put_bits ( & s -> pb , 1 , custom_quant_matrix ) ; \n if ( custom_quant_matrix ) { \n init_custom_qm ( s ) ; \n put_vc2_ue_uint ( & s -> pb , s -> quant [ 0 ] [ 0 ] ) ; \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 1 ] ) ; \n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 2 ] ) ; \n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 3 ] ) ; \n } \n } else { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n s -> quant [ level ] [ 0 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 0 ] ; \n s -> quant [ level ] [ 1 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 1 ] ; \n s -> quant [ level ] [ 2 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 2 ] ; \n s -> quant [ level ] [ 3 ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ 3 ] ; \n } \n } \n }", "idx": 3424}
{"project": "FFmpeg", "commit_id": "f42b3195d3f2692a4dfc0a8668bb4ac35301f2ed", "target": 1, "func": "static void fix_bitshift ( ShortenContext * s , int32_t * buffer ) \n { \n int i ; \n if ( s -> bitshift != 0 ) \n for ( i = 0 ; i < s -> blocksize ; i ++ ) \n buffer [ s -> nwrap + i ] <<= s -> bitshift ; \n }", "idx": 3425}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vc1_decode_slice ( AVCodecContext * avctx , const uint8_t * buffer , uint32_t size ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n void * tmp ; \n tmp = av_fast_realloc ( ctx -> slice_offsets , & ctx -> slice_offsets_allocated , \n ( ctx -> nb_slices + 1 ) * sizeof ( * ctx -> slice_offsets ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n ctx -> slice_offsets = tmp ; \n if ( ! ctx -> bitstream ) \n ctx -> bitstream = ( uint8_t * ) buffer ; \n ctx -> slice_offsets [ ctx -> nb_slices ] = buffer - ctx -> bitstream ; \n ctx -> bitstream_len += size ; \n ctx -> nb_slices ++ ; \n return 0 ; \n }", "idx": 3430}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "static void predict_plane ( SnowContext * s , DWTELEM * buf , int plane_index , int add ) { \n Plane * p = & s -> plane [ plane_index ] ; \n const int mb_w = s -> mb_band . width ; \n const int mb_h = s -> mb_band . height ; \n const int mb_stride = s -> mb_band . stride ; \n int x , y , mb_x , mb_y ; \n int scale = plane_index ? s -> mv_scale : 2 * s -> mv_scale ; \n int block_w = plane_index ? 8 : 16 ; \n uint8_t * obmc = plane_index ? obmc16 : obmc32 ; \n int obmc_stride = plane_index ? 16 : 32 ; \n int ref_stride = s -> last_picture . linesize [ plane_index ] ; \n uint8_t * ref = s -> last_picture . data [ plane_index ] ; \n int w = p -> width ; \n int h = p -> height ; \n if ( s -> avctx -> debug & 512 ) { \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n if ( add ) buf [ x + y * w ] += 128 * 256 ; \n else buf [ x + y * w ] -= 128 * 256 ; \n } \n } \n return ; \n } \n for ( mb_y = -1 ; mb_y <= mb_h ; mb_y ++ ) { \n for ( mb_x = -1 ; mb_x <= mb_w ; mb_x ++ ) { \n int index = clip ( mb_x , 0 , mb_w - 1 ) + clip ( mb_y , 0 , mb_h - 1 ) * mb_stride ; \n add_xblock ( buf , ref , obmc , \n block_w * mb_x - block_w / 2 , \n block_w * mb_y - block_w / 2 , \n 2 * block_w , 2 * block_w , \n s -> mv_band [ 0 ] . buf [ index ] * scale , s -> mv_band [ 1 ] . buf [ index ] * scale , \n w , h , \n w , ref_stride , obmc_stride , \n s -> mb_band . buf [ index ] , add ) ; \n } \n } \n }", "idx": 3453}
{"project": "FFmpeg", "commit_id": "fdc94db37e89165964fdf34f1cd7632e44108bd0", "target": 1, "func": "static void sbr_qmf_analysis ( AVFixedDSPContext * dsp , FFTContext * mdct , \n #else \n static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , \n #endif \n SBRDSPContext * sbrdsp , const INTFLOAT * in , INTFLOAT * x , \n INTFLOAT z [ 320 ] , INTFLOAT W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx )  \n { \n int i ; \n int j ; \n memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ; \n memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ; \n sbrdsp -> sum64x5 ( z ) ; \n sbrdsp -> qmf_pre_shuffle ( z ) ; \n mdct -> imdct_half ( mdct , z , z + 64 ) ; \n sbrdsp -> qmf_post_shuffle ( W [ buf_idx ] [ i ] , z ) ; \n x += 32 ;", "idx": 3459}
{"project": "FFmpeg", "commit_id": "7cbb32e461cdbe8b745d560c1700c711ba5933cc", "target": 1, "func": "static void find_block_motion ( DeshakeContext * deshake , uint8_t * src1 , \n uint8_t * src2 , int cx , int cy , int stride , \n MotionVector * mv ) \n { \n int x , y ; \n int diff ; \n int smallest = INT_MAX ; \n int tmp , tmp2 ; \n #define CMP ( i , j )  deshake->c.sad[0](deshake, src1 + cy * stride + cx, \\ \n   \n  src2 + ( j ) * stride + ( i ) , stride , \n deshake -> blocksize ) \n if ( deshake -> search == EXHAUSTIVE ) { \n for ( y = - deshake -> ry ; y <= deshake -> ry ; y ++ ) { \n for ( x = - deshake -> rx ; x <= deshake -> rx ; x ++ ) { \n diff = CMP ( cx - x , cy - y ) ; \n if ( diff < smallest ) { \n smallest = diff ; \n mv -> x = x ; \n mv -> y = y ; \n } \n } \n } \n } else if ( deshake -> search == SMART_EXHAUSTIVE ) { \n for ( y = - deshake -> ry + 1 ; y < deshake -> ry - 2 ; y += 2 ) { \n for ( x = - deshake -> rx + 1 ; x < deshake -> rx - 2 ; x += 2 ) { \n diff = CMP ( cx - x , cy - y ) ; \n if ( diff < smallest ) { \n smallest = diff ; \n mv -> x = x ; \n mv -> y = y ; \n } \n } \n } \n tmp = mv -> x ; \n tmp2 = mv -> y ; \n for ( y = tmp2 - 1 ; y <= tmp2 + 1 ; y ++ ) { \n for ( x = tmp - 1 ; x <= tmp + 1 ; x ++ ) { \n if ( x == tmp && y == tmp2 ) \n continue ; \n diff = CMP ( cx - x , cy - y ) ; \n if ( diff < smallest ) { \n smallest = diff ; \n mv -> x = x ; \n mv -> y = y ; \n } \n } \n } \n } \n if ( smallest > 512 ) { \n mv -> x = -1 ; \n mv -> y = -1 ; \n } \n emms_c ( ) ; \n }", "idx": 3463}
{"project": "FFmpeg", "commit_id": "7bcd81299a83b28ee8266079646470dd3e02f2ef", "target": 1, "func": "static int read_seek ( AVFormatContext * s , int stream_index , \n int64_t ts , int flags ) \n { \n WtvContext * wtv = s -> priv_data ; \n AVIOContext * pb = wtv -> pb ; \n AVStream * st = s -> streams [ 0 ] ; \n int64_t ts_relative ; \n int i ; \n if ( ( flags & AVSEEK_FLAG_FRAME ) || ( flags & AVSEEK_FLAG_BYTE ) ) \n return AVERROR ( ENOSYS ) ; \n ts_relative = ts ; \n if ( wtv -> epoch != AV_NOPTS_VALUE ) \n ts_relative -= wtv -> epoch ; \n i = ff_index_search_timestamp ( wtv -> index_entries , wtv -> nb_index_entries , ts_relative , flags ) ; \n if ( i < 0 ) { \n if ( wtv -> last_valid_pts == AV_NOPTS_VALUE || ts < wtv -> last_valid_pts ) \n avio_seek ( pb , 0 , SEEK_SET ) ; \n else if ( st -> duration != AV_NOPTS_VALUE && ts_relative > st -> duration && wtv -> nb_index_entries ) \n avio_seek ( pb , wtv -> index_entries [ wtv -> nb_index_entries - 1 ] . pos , SEEK_SET ) ; \n if ( parse_chunks ( s , SEEK_TO_PTS , ts , 0 ) < 0 ) \n return AVERROR ( ERANGE ) ; \n return 0 ; \n } \n wtv -> pts = wtv -> index_entries [ i ] . timestamp ; \n if ( wtv -> epoch != AV_NOPTS_VALUE ) \n wtv -> pts += wtv -> epoch ; \n wtv -> last_valid_pts = wtv -> pts ; \n avio_seek ( pb , wtv -> index_entries [ i ] . pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 3475}
{"project": "FFmpeg", "commit_id": "f95c81ce104554b6860d94724a681a1bac0c4fbd", "target": 1, "func": "static av_cold int mov_text_encode_init ( AVCodecContext * avctx ) \n { \n static const uint8_t text_sample_entry [ ] = { \n 0x00 , 0x00 , 0x00 , 0x00 , \n 0x01 , \n 0xFF , \n 0x00 , 0x00 , 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x00 , \n 0x00 , 0x01 , \n 0x00 , \n 0x12 , \n 0xFF , 0xFF , 0xFF , 0xFF , \n 0x00 , 0x00 , 0x00 , 0x12 , \n ' ' , ' ' , ' ' , ' ' , \n 0x00 , 0x01 , \n 0x00 , 0x01 , \n 0x05 , \n ' ' , ' ' , ' ' , ' ' , ' ' , \n } ; \n MovTextContext * s = avctx -> priv_data ; \n avctx -> extradata_size = sizeof text_sample_entry ; \n avctx -> extradata = av_mallocz ( avctx -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! avctx -> extradata ) \n return AVERROR ( ENOMEM ) ; \n av_bprint_init ( & s -> buffer , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; \n memcpy ( avctx -> extradata , text_sample_entry , avctx -> extradata_size ) ; \n s -> ass_ctx = ff_ass_split ( avctx -> subtitle_header ) ; \n return s -> ass_ctx ? 0 : AVERROR_INVALIDDATA ; \n }", "idx": 3486}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static void fill_float_array ( AVLFG * lfg , float * a , int len ) \n { \n int i ; \n double bmg [ 2 ] , stddev = 10.0 , mean = 0.0 ; \n for ( i = 0 ; i < len ; i += 2 ) { \n av_bmg_get ( lfg , bmg ) ; \n a [ i ] = bmg [ 0 ] * stddev + mean ; \n a [ i + 1 ] = bmg [ 1 ] * stddev + mean ; \n } \n }", "idx": 3492}
{"project": "FFmpeg", "commit_id": "771c86c13d7133035e53f7aeb14407ae5dca6453", "target": 1, "func": "av_cold void ff_psy_preprocess_end ( struct FFPsyPreprocessContext * ctx ) \n { \n int i ; \n ff_iir_filter_free_coeffs ( ctx -> fcoeffs ) ; \n if ( ctx -> fstate ) \n for ( i = 0 ; i < ctx -> avctx -> channels ; i ++ ) \n ff_iir_filter_free_state ( ctx -> fstate [ i ] ) ; \n av_freep ( & ctx -> fstate ) ; \n }", "idx": 3503}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_put_altivec ( uint8_t * dst , int stride , DCTELEM block [ 64 ] ) \n { \n vec_u8 t ; \n IDCT_START \n vec_s16 v2048 = vec_sl ( vec_splat_s16 ( 1 ) , vec_splat_u16 ( 11 ) ) ; \n eight = vec_add ( eight , v2048 ) ; \n IDCT_1D ( NOP , NOP )  \n TRANSPOSE8 ( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 ) ; \n IDCT_1D ( ADD8 , SHIFT4 )  \n #define PUT ( a ) \\ \n  \n  t = vec_packsu ( a , a ) ; \n vec_ste ( ( vec_u32 ) t , 0 , ( unsigned int * ) dst ) ; \n vec_ste ( ( vec_u32 ) t , 4 , ( unsigned int * ) dst ) ; \n PUT ( b0 ) dst += stride ; \n PUT ( b1 ) dst += stride ; \n PUT ( b2 ) dst += stride ; \n PUT ( b3 ) dst += stride ; \n PUT ( b4 ) dst += stride ; \n PUT ( b5 ) dst += stride ; \n PUT ( b6 ) dst += stride ; \n PUT ( b7 )  \n }", "idx": 3505}
{"project": "FFmpeg", "commit_id": "6fcd4f3c7255014eeb883385d32abc7442426314", "target": 0, "func": "static av_cold int dfa_decode_init ( AVCodecContext * avctx ) \n { \n DfaContext * s = avctx -> priv_data ; \n int ret ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) ) < 0 ) \n return ret ; \n s -> frame_buf = av_mallocz ( avctx -> width * avctx -> height + AV_LZO_OUTPUT_PADDING ) ; \n if ( ! s -> frame_buf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 3525}
{"project": "FFmpeg", "commit_id": "9e494ab77cdf519eb5de8056c00469c78bf8a7e8", "target": 0, "func": "static int mpeg_field_start ( MpegEncContext * s ) { \n AVCodecContext * avctx = s -> avctx ; \n Mpeg1Context * s1 = ( Mpeg1Context * ) s ; \n if ( s -> first_field || s -> picture_structure == PICT_FRAME ) { \n if ( MPV_frame_start ( s , avctx ) < 0 ) \n return -1 ; \n ff_er_frame_start ( s ) ; \n s -> current_picture_ptr -> repeat_pict = 0 ; \n if ( s -> repeat_first_field ) { \n if ( s -> progressive_sequence ) { \n if ( s -> top_field_first ) \n s -> current_picture_ptr -> repeat_pict = 4 ; \n else \n s -> current_picture_ptr -> repeat_pict = 2 ; \n } else if ( s -> progressive_frame ) { \n s -> current_picture_ptr -> repeat_pict = 1 ; \n } \n } \n * s -> current_picture_ptr -> pan_scan = s1 -> pan_scan ; \n } else { \n int i ; \n if ( ! s -> current_picture_ptr ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n s -> current_picture . data [ i ] = s -> current_picture_ptr -> data [ i ] ; \n if ( s -> picture_structure == PICT_BOTTOM_FIELD ) { \n s -> current_picture . data [ i ] += s -> current_picture_ptr -> linesize [ i ] ; \n } \n } \n } \n #if CONFIG_MPEG_XVMC_DECODER  \n  \n  \n  \n  if ( s -> avctx -> xvmc_acceleration ) \n ff_xvmc_field_start ( s , avctx ) ; \n #endif \n return 0 ; \n }", "idx": 3527}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( bgr24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 3 * i + 0 ] ; \n int g = src1 [ 3 * i + 1 ] ; \n int r = src1 [ 3 * i + 2 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n } \n #endif \n assert ( src1 == src2 ) ; \n }", "idx": 3529}
{"project": "FFmpeg", "commit_id": "f44d50a94c120135faeba6b4a1e5551b4397810f", "target": 1, "func": "static void hScale16_c ( SwsContext * c , int16_t * _dst , int dstW , const uint8_t * _src , \n const int16_t * filter , \n const int16_t * filterPos , int filterSize ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n const uint16_t * src = ( const uint16_t * ) _src ; \n int bits = av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ; \n int sh = ( bits <= 7 ) ? 11 : ( bits - 4 ) ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n unsigned int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += src [ srcPos + j ] * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> sh , ( 1 << 19 ) - 1 ) ; \n } \n }", "idx": 3532}
{"project": "FFmpeg", "commit_id": "dd44d9e316c17f473eff9f4a5a94ad0d7adb157e", "target": 1, "func": "static int adts_write_header ( AVFormatContext * s ) \n { \n ADTSContext * adts = s -> priv_data ; \n AVCodecContext * avc = s -> streams [ 0 ] -> codec ; \n if ( avc -> extradata_size > 0 ) \n decode_extradata ( adts , avc -> extradata , avc -> extradata_size ) ; \n return 0 ; \n }", "idx": 3535}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "void * av_realloc ( void * ptr , unsigned int size ) \n { \n #ifdef MEMALIGN_HACK \n int diff ; \n if ( ! ptr ) return av_malloc ( size ) ; \n diff = ( ( char * ) ptr ) [ -1 ] ; \n return realloc ( ptr - diff , size + diff ) + diff ; \n #else \n return realloc ( ptr , size ) ; \n #endif \n }", "idx": 3545}
{"project": "FFmpeg", "commit_id": "7ee191cab0dc44700f26c5784e2adeb6a779651b", "target": 1, "func": "int avpriv_dv_produce_packet ( DVDemuxContext * c , AVPacket * pkt , \n uint8_t * buf , int buf_size ) \n { \n int size , i ; \n uint8_t * ppcm [ 4 ] = { 0 } ; \n if ( buf_size < DV_PROFILE_BYTES || \n ! ( c -> sys = avpriv_dv_frame_profile ( c -> sys , buf , buf_size ) ) || \n buf_size < c -> sys -> frame_size ) { \n return -1 ; \n } \n size = dv_extract_audio_info ( c , buf ) ; \n for ( i = 0 ; i < c -> ach ; i ++ ) { \n c -> audio_pkt [ i ] . size = size ; \n c -> audio_pkt [ i ] . pts = c -> abytes * 30000 * 8 / \n c -> ast [ i ] -> codec -> bit_rate ; \n ppcm [ i ] = c -> audio_buf [ i ] ; \n } \n if ( c -> ach ) \n dv_extract_audio ( buf , ppcm , c -> sys ) ; \n if ( c -> sys -> height == 720 ) { \n if ( buf [ 1 ] & 0x0C ) { \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n } else { \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n c -> abytes += size ; \n } \n } else { \n c -> abytes += size ; \n } \n size = dv_extract_video_info ( c , buf ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = buf ; \n pkt -> size = size ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> stream_index = c -> vst -> index ; \n pkt -> pts = c -> frames ; \n c -> frames ++ ; \n return size ; \n }", "idx": 3548}
{"project": "FFmpeg", "commit_id": "74474750f1ac522730dae271a5ea5003caa8b73c", "target": 1, "func": "static void align_position ( AVIOContext * pb , int64_t offset , uint64_t size ) \n { \n if ( avio_tell ( pb ) != offset + size ) \n avio_seek ( pb , offset + size , SEEK_SET ) ; \n }", "idx": 3556}
{"project": "FFmpeg", "commit_id": "096bc417ae9b5bf35631d48fbc798020aac08aee", "target": 1, "func": "static int decode_hextile ( VmncContext * c , uint8_t * dst , uint8_t * src , int w , int h , int stride ) \n { \n int i , j , k ; \n int bg = 0 , fg = 0 , rects , color , flags , xy , wh ; \n const int bpp = c -> bpp2 ; \n uint8_t * dst2 ; \n int bw = 16 , bh = 16 ; \n uint8_t * ssrc = src ; \n for ( j = 0 ; j < h ; j += 16 ) { \n dst2 = dst ; \n bw = 16 ; \n if ( j + 16 > h ) bh = h - j ; \n for ( i = 0 ; i < w ; i += 16 , dst2 += 16 * bpp ) { \n if ( i + 16 > w ) bw = w - i ; \n flags = * src ++ ; \n if ( flags & HT_RAW ) { \n paint_raw ( dst2 , bw , bh , src , bpp , c -> bigendian , stride ) ; \n src += bw * bh * bpp ; \n } else { \n if ( flags & HT_BKG ) { \n bg = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; src += bpp ; \n } \n if ( flags & HT_FG ) { \n fg = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; src += bpp ; \n } \n rects = 0 ; \n if ( flags & HT_SUB ) \n rects = * src ++ ; \n color = ( flags & HT_CLR ) ; \n paint_rect ( dst2 , 0 , 0 , bw , bh , bg , bpp , stride ) ; \n for ( k = 0 ; k < rects ; k ++ ) { \n if ( color ) { \n fg = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; src += bpp ; \n } \n xy = * src ++ ; \n wh = * src ++ ; \n paint_rect ( dst2 , xy >> 4 , xy & 0xF , ( wh >> 4 ) + 1 , ( wh & 0xF ) + 1 , fg , bpp , stride ) ; \n } \n } \n } \n dst += stride * 16 ; \n } \n return src - ssrc ; \n }", "idx": 3565}
{"project": "FFmpeg", "commit_id": "83f238cbf0c038245d2b2dffa5beb0916e7c36d2", "target": 0, "func": "static void arm_idct_add ( UINT8 * dest , int line_size , DCTELEM * block ) \n { \n j_rev_dct_ARM ( block ) ; \n add_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 3570}
{"project": "FFmpeg", "commit_id": "7fd88069241ead2d2fd3e2db1b79e4b292e90001", "target": 1, "func": "static av_cold void init_static ( void ) \n { \n if ( ! huff_vlc [ 0 ] . bits ) { \n INIT_VLC_STATIC ( & huff_vlc [ 0 ] , VLC_BITS , 18 , \n & ff_mlp_huffman_tables [ 0 ] [ 0 ] [ 1 ] , 2 , 1 , \n & ff_mlp_huffman_tables [ 0 ] [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; \n INIT_VLC_STATIC ( & huff_vlc [ 1 ] , VLC_BITS , 16 , \n & ff_mlp_huffman_tables [ 1 ] [ 0 ] [ 1 ] , 2 , 1 , \n & ff_mlp_huffman_tables [ 1 ] [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; \n INIT_VLC_STATIC ( & huff_vlc [ 2 ] , VLC_BITS , 15 , \n & ff_mlp_huffman_tables [ 2 ] [ 0 ] [ 1 ] , 2 , 1 , \n & ff_mlp_huffman_tables [ 2 ] [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; \n ff_mlp_init_crc ( ) ;", "idx": 3573}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "SwsFunc ff_yuv2rgb_init_mmx ( SwsContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( c -> srcFormat != PIX_FMT_YUV420P && \n c -> srcFormat != PIX_FMT_YUVA420P ) \n return NULL ; \n if ( HAVE_MMX2 && cpu_flags & AV_CPU_FLAG_MMX2 ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX2 ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX2 ; \n } \n } \n if ( HAVE_MMX && cpu_flags & AV_CPU_FLAG_MMX ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB32 : \n if ( CONFIG_SWSCALE_ALPHA && c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS  \n  \n  return yuva420_rgb32_MMX ; \n #endif \n break ; \n } else return yuv420_rgb32_MMX ; \n case PIX_FMT_BGR32 : \n if ( CONFIG_SWSCALE_ALPHA && c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS  \n  \n  return yuva420_bgr32_MMX ; \n #endif \n break ; \n } else return yuv420_bgr32_MMX ; \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX ; \n case PIX_FMT_RGB565 : return yuv420_rgb16_MMX ; \n case PIX_FMT_RGB555 : return yuv420_rgb15_MMX ; \n } \n } \n return NULL ; \n }", "idx": 3576}
{"project": "FFmpeg", "commit_id": "5f531386210e844f0a6819404cde58da54c46a00", "target": 0, "func": "static int mov_write_int8_metadata ( AVFormatContext * s , AVIOContext * pb , \n const char * name , const char * tag , \n int len ) \n { \n AVDictionaryEntry * t = NULL ; \n uint8_t num ; \n if ( ! ( t = av_dict_get ( s -> metadata , tag , NULL , 0 ) ) ) \n return 0 ; \n num = t ? atoi ( t -> value ) : 0 ; \n avio_wb32 ( pb , len + 8 ) ; \n ffio_wfourcc ( pb , name ) ; \n if ( len == 4 ) avio_wb32 ( pb , num ) ; \n else avio_w8 ( pb , num ) ; \n return len + 8 ; \n }", "idx": 3583}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , int dstW , int chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest != NULL ) \n { \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 3588}
{"project": "FFmpeg", "commit_id": "81fc2f37db98b3472bf997e5f302e65d75670f3e", "target": 0, "func": "int attribute_align_arg avcodec_decode_audio2 ( AVCodecContext * avctx , int16_t * samples , \n int * frame_size_ptr , \n uint8_t * buf , int buf_size ) \n { \n int ret ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || buf_size ) { \n if ( * frame_size_ptr < AVCODEC_MAX_AUDIO_FRAME_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( * frame_size_ptr < FF_MIN_BUFFER_SIZE || \n * frame_size_ptr < avctx -> channels * avctx -> frame_size * sizeof ( int16_t ) || \n * frame_size_ptr < buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , * frame_size_ptr ) ; \n return -1 ; \n } \n ret = avctx -> codec -> decode ( avctx , samples , frame_size_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n } else { \n ret = 0 ; \n * frame_size_ptr = 0 ; \n } \n return ret ; \n }", "idx": 3589}
{"project": "FFmpeg", "commit_id": "42a1f1d7a8cf67eed68db596d6a1e53c0c36e4ab", "target": 1, "func": "static unsigned int mszh_decomp ( const unsigned char * srcptr , int srclen , unsigned char * destptr , unsigned int destsize ) \n { \n unsigned char * destptr_bak = destptr ; \n unsigned char * destptr_end = destptr + destsize ; \n const unsigned char * srcptr_end = srcptr + srclen ; \n unsigned mask = * srcptr ++ ; \n unsigned maskbit = 0x80 ; \n while ( srcptr < srcptr_end && destptr < destptr_end ) { \n if ( ! ( mask & maskbit ) ) { \n memcpy ( destptr , srcptr , 4 ) ; \n destptr += 4 ; \n srcptr += 4 ; \n } else { \n unsigned ofs = bytestream_get_le16 ( & srcptr ) ; \n unsigned cnt = ( ofs >> 11 ) + 1 ; \n ofs &= 0x7ff ; \n ofs = FFMIN ( ofs , destptr - destptr_bak ) ; \n cnt *= 4 ; \n cnt = FFMIN ( cnt , destptr_end - destptr ) ; \n av_memcpy_backptr ( destptr , ofs , cnt ) ; \n destptr += cnt ; \n } \n maskbit >>= 1 ; \n if ( ! maskbit ) { \n mask = * srcptr ++ ; \n while ( ! mask ) { \n if ( destptr_end - destptr < 32 || srcptr_end - srcptr < 32 ) break ; \n memcpy ( destptr , srcptr , 32 ) ; \n destptr += 32 ; \n srcptr += 32 ; \n mask = * srcptr ++ ; \n } \n maskbit = 0x80 ; \n } \n } \n return destptr - destptr_bak ; \n }", "idx": 3595}
{"project": "FFmpeg", "commit_id": "a72b41035cc4925922b4164b7453c9a5c2b7e630", "target": 1, "func": "static int mxg_update_cache ( AVFormatContext * s , unsigned int cache_size ) \n { \n MXGContext * mxg = s -> priv_data ; \n unsigned int current_pos = mxg -> buffer_ptr - mxg -> buffer ; \n unsigned int soi_pos ; \n int ret ; \n if ( current_pos > current_pos + cache_size ) \n return AVERROR ( ENOMEM ) ; \n soi_pos = mxg -> soi_ptr - mxg -> buffer ; \n mxg -> buffer = av_fast_realloc ( mxg -> buffer , & mxg -> buffer_size , \n current_pos + cache_size + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! mxg -> buffer ) \n return AVERROR ( ENOMEM ) ; \n mxg -> buffer_ptr = mxg -> buffer + current_pos ; \n if ( mxg -> soi_ptr ) mxg -> soi_ptr = mxg -> buffer + soi_pos ; \n ret = avio_read ( s -> pb , mxg -> buffer_ptr + mxg -> cache_size , \n cache_size - mxg -> cache_size ) ; \n if ( ret < 0 ) \n return ret ; \n mxg -> cache_size += ret ; \n return ret ; \n }", "idx": 3599}
{"project": "FFmpeg", "commit_id": "a6653787a4b1e89170ff7962312dd110769c83a3", "target": 0, "func": "static av_cold int dilate_init ( AVFilterContext * ctx , const char * args ) \n { \n OCVContext * s = ctx -> priv ; \n DilateContext * dilate = s -> priv ; \n char default_kernel_str [ ] = \" \" ; \n char * kernel_str ; \n const char * buf = args ; \n int ret ; \n dilate -> nb_iterations = 1 ; \n if ( args ) \n kernel_str = av_get_token ( & buf , \" \" ) ; \n if ( ( ret = parse_iplconvkernel ( & dilate -> kernel , \n * kernel_str ? kernel_str : default_kernel_str , \n ctx ) ) < 0 ) \n return ret ; \n av_free ( kernel_str ) ; \n sscanf ( buf , \" \" , & dilate -> nb_iterations ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , dilate -> nb_iterations ) ; \n if ( dilate -> nb_iterations <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n dilate -> nb_iterations ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 3603}
{"project": "FFmpeg", "commit_id": "934982c4ace1a3d5d627b518782ed092a456c49e", "target": 0, "func": "static int dvvideo_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n DVVideoContext * s = avctx -> priv_data ; \n if ( buf_size == 0 ) \n return 0 ; \n s -> sys = dv_frame_profile ( buf ) ; \n if ( ! s -> sys || buf_size < s -> sys -> frame_size ) \n return -1 ; \n if ( s -> picture . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> picture ) ; \n s -> picture . reference = 0 ; \n avctx -> pix_fmt = s -> sys -> pix_fmt ; \n avctx -> width = s -> sys -> width ; \n avctx -> height = s -> sys -> height ; \n if ( avctx -> get_buffer ( avctx , & s -> picture ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> picture . interlaced_frame = 1 ; \n s -> picture . top_field_first = 0 ; \n s -> buf = buf ; \n avctx -> execute ( avctx , dv_decode_mt , ( void * * ) & dv_anchor [ 0 ] , NULL , \n s -> sys -> difseg_size * 27 ) ; \n emms_c ( ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> picture ; \n return s -> sys -> frame_size ; \n }", "idx": 3605}
{"project": "FFmpeg", "commit_id": "5d88c2647def2557637077e9284cfe9806954502", "target": 0, "func": "rdt_parse_packet ( PayloadContext * rdt , AVStream * st , \n AVPacket * pkt , uint32_t * timestamp , \n const uint8_t * buf , int len , int flags )  \n { \n int seq = 1 , res ; \n ByteIOContext pb ; \n if ( rdt -> audio_pkt_cnt == 0 ) { \n int pos ; \n init_put_byte ( & pb , buf , len , 0 , NULL , NULL , NULL , NULL ) ; \n flags = ( flags & PKT_FLAG_KEY ) ? 2 : 0 ; \n res = ff_rm_parse_packet ( rdt -> rmctx , & pb , st , rdt -> rmst [ 0 ] , len , pkt , \n & seq , & flags , timestamp ) ; \n pos = url_ftell ( & pb ) ; \n if ( res < 0 ) \n return res ; \n rdt -> audio_pkt_cnt [ st -> id ] = res ; \n if ( rdt -> audio_pkt_cnt [ st -> id ] > 0 && \n st -> codec -> codec_id == CODEC_ID_AAC ) { \n memcpy ( rdt -> buffer , buf + pos , len - pos ) ; \n rdt -> rmctx -> pb = av_alloc_put_byte ( rdt -> buffer , len - pos , 0 , \n NULL , NULL , NULL , NULL ) ; \n } \n } else { \n ff_rm_retrieve_cache ( rdt -> rmctx , rdt -> rmctx -> pb , st , rdt -> rmst [ 0 ] , pkt ) ; \n if ( rdt -> audio_pkt_cnt [ st -> id ] == 0 && \n st -> codec -> codec_id == CODEC_ID_AAC ) \n av_freep ( & rdt -> rmctx -> pb ) ; \n } \n pkt -> stream_index = st -> index ; \n pkt -> pts = * timestamp ; \n return rdt -> audio_pkt_cnt [ st -> id ] > 0 ; \n }", "idx": 3606}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC ( hevc_v_loop_filter_luma ) ( uint8_t * pix , ptrdiff_t stride , \n int * beta , int * tc , uint8_t * no_p , \n uint8_t * no_q ) \n { \n FUNC ( hevc_loop_filter_luma ) ( pix , sizeof ( pixel ) , stride , \n beta , tc , no_p , no_q ) ; \n }", "idx": 3607}
{"project": "FFmpeg", "commit_id": "a8ab52fae7286d4e7eec9256a08b6ad0b1e39d6c", "target": 1, "func": "static int config_output ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n LIBVMAFContext * s = ctx -> priv ; \n AVFilterLink * mainlink = ctx -> inputs [ 0 ] ; \n int ret ; \n outlink -> w = mainlink -> w ; \n outlink -> h = mainlink -> h ; \n outlink -> time_base = mainlink -> time_base ; \n outlink -> sample_aspect_ratio = mainlink -> sample_aspect_ratio ; \n outlink -> frame_rate = mainlink -> frame_rate ; \n if ( ( ret = ff_dualinput_init ( ctx , & s -> dinput ) ) < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 3613}
{"project": "FFmpeg", "commit_id": "77f521d9e5126575f9bcc21241d81867173c7619", "target": 0, "func": "static void encode_plane ( FFV1Context * s , uint8_t * src , int w , int h , \n int stride , int plane_index ) \n { \n int x , y , i ; \n const int ring_size = s -> avctx -> context_model ? 3 : 2 ; \n int16_t * sample [ 3 ] ; \n s -> run_index = 0 ; \n memset ( s -> sample_buffer , 0 , ring_size * ( w + 6 ) * sizeof ( * s -> sample_buffer ) ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( i = 0 ; i < ring_size ; i ++ ) \n sample [ i ] = s -> sample_buffer + ( w + 6 ) * ( ( h + i - y ) % ring_size ) + 3 ; \n sample [ 0 ] [ -1 ] = sample [ 1 ] [ 0 ] ; \n sample [ 1 ] [ w ] = sample [ 1 ] [ w - 1 ] ; \n if ( s -> bits_per_raw_sample <= 8 ) { \n for ( x = 0 ; x < w ; x ++ ) \n sample [ 0 ] [ x ] = src [ x + stride * y ] ; \n encode_line ( s , w , sample , plane_index , 8 ) ; \n } else { \n if ( s -> packed_at_lsb ) { \n for ( x = 0 ; x < w ; x ++ ) { \n sample [ 0 ] [ x ] = ( ( uint16_t * ) ( src + stride * y ) ) [ x ] ; \n } \n } else { \n for ( x = 0 ; x < w ; x ++ ) { \n sample [ 0 ] [ x ] = ( ( uint16_t * ) ( src + stride * y ) ) [ x ] >> ( 16 - s -> bits_per_raw_sample ) ; \n } \n } \n encode_line ( s , w , sample , plane_index , s -> bits_per_raw_sample ) ; \n } \n } \n }", "idx": 3646}
{"project": "FFmpeg", "commit_id": "1afe49b062a959ed0433e4fd9c1b5dff829ae03e", "target": 0, "func": "static int decode_plane ( Indeo3DecodeContext * ctx , AVCodecContext * avctx , \n Plane * plane , const uint8_t * data , int32_t data_size , \n int32_t strip_width ) \n { \n Cell curr_cell ; \n int num_vectors ; \n num_vectors = bytestream_get_le32 ( & data ) ; \n ctx -> mc_vectors = num_vectors ? data : 0 ; \n init_get_bits ( & ctx -> gb , & data [ num_vectors * 2 ] , data_size << 3 ) ; \n ctx -> skip_bits = 0 ; \n ctx -> need_resync = 0 ; \n ctx -> last_byte = data + data_size - 1 ; \n curr_cell . xpos = curr_cell . ypos = 0 ; \n curr_cell . width = plane -> width >> 2 ; \n curr_cell . height = plane -> height >> 2 ; \n curr_cell . tree = 0 ; \n curr_cell . mv_ptr = 0 ; \n return parse_bintree ( ctx , avctx , plane , INTRA_NULL , & curr_cell , CELL_STACK_MAX , strip_width ) ; \n }", "idx": 3647}
{"project": "FFmpeg", "commit_id": "1ba08c94f5bb4d1c3c2d3651b5e01edb4ce172e2", "target": 1, "func": "static inline void put_codeword ( PutBitContext * pb , vorbis_enc_codebook * cb , \n int entry ) \n { \n assert ( entry >= 0 ) ; \n assert ( entry < cb -> nentries ) ; \n assert ( cb -> lens [ entry ] ) ; \n put_bits ( pb , cb -> lens [ entry ] , cb -> codewords [ entry ] ) ; \n }", "idx": 3667}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb24 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst += 3 ; \n } \n }", "idx": 3671}
{"project": "FFmpeg", "commit_id": "bc851a2946c64eefb96145b70e2190ff7d5a4827", "target": 1, "func": "static int ogg_restore ( AVFormatContext * s , int discard ) \n { \n struct ogg * ogg = s -> priv_data ; \n AVIOContext * bc = s -> pb ; \n struct ogg_state * ost = ogg -> state ; \n int i ; \n if ( ! ost ) \n return 0 ; \n ogg -> state = ost -> next ; \n if ( ! discard ) { \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) \n av_free ( ogg -> streams [ i ] . buf ) ; \n avio_seek ( bc , ost -> pos , SEEK_SET ) ; \n ogg -> curidx = ost -> curidx ; \n ogg -> nstreams = ost -> nstreams ; \n memcpy ( ogg -> streams , ost -> streams , \n ost -> nstreams * sizeof ( * ogg -> streams ) ) ; \n } \n av_free ( ost ) ; \n return 0 ; \n }", "idx": 3672}
{"project": "FFmpeg", "commit_id": "dfdb353cd565efbd1f64105ce7519ec809ad338d", "target": 0, "func": "rdt_free_context ( PayloadContext * rdt )  \n { \n int i ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) \n if ( rdt -> rmst [ i ] ) { \n ff_rm_free_rmstream ( rdt -> rmst [ i ] ) ; \n av_freep ( & rdt -> rmst [ i ] ) ; \n } \n if ( rdt -> rmctx ) \n av_close_input_stream ( rdt -> rmctx ) ; \n av_freep ( & rdt -> mlti_data ) ; \n av_free ( rdt ) ; \n }", "idx": 3673}
{"project": "FFmpeg", "commit_id": "e2dae1faa84ada5746ac2114de7eb68abd824131", "target": 1, "func": "static int encode_nals ( AVCodecContext * ctx , uint8_t * buf , int size , \n x264_nal_t * nals , int nnal , int skip_sei ) \n { \n X264Context * x4 = ctx -> priv_data ; \n uint8_t * p = buf ; \n int i ; \n if ( x4 -> sei_size > 0 && nnal > 0 ) { \n if ( x4 -> sei_size > size ) { \n return -1 ; \n memcpy ( p , x4 -> sei , x4 -> sei_size ) ; \n p += x4 -> sei_size ; \n x4 -> sei_size = 0 ; \n for ( i = 0 ; i < nnal ; i ++ ) { \n if ( skip_sei && nals [ i ] . i_type == NAL_SEI ) { \n x4 -> sei_size = nals [ i ] . i_payload ; \n x4 -> sei = av_malloc ( x4 -> sei_size ) ; \n memcpy ( x4 -> sei , nals [ i ] . p_payload , nals [ i ] . i_payload ) ; \n continue ; \n memcpy ( p , nals [ i ] . p_payload , nals [ i ] . i_payload ) ; \n p += nals [ i ] . i_payload ; \n return p - buf ;", "idx": 3676}
{"project": "FFmpeg", "commit_id": "e45f7bca735ff7ba965ec1e441199dc7aeb0c8fc", "target": 0, "func": "static int copy_stream_props ( AVStream * st , AVStream * source_st ) \n { \n int ret ; \n if ( st -> codecpar -> codec_id || ! source_st -> codecpar -> codec_id ) { \n if ( st -> codecpar -> extradata_size < source_st -> codecpar -> extradata_size ) { \n if ( st -> codecpar -> extradata ) { \n av_freep ( & st -> codecpar -> extradata ) ; \n st -> codecpar -> extradata_size = 0 ; \n } \n ret = ff_alloc_extradata ( st -> codecpar , \n source_st -> codecpar -> extradata_size ) ; \n if ( ret < 0 ) \n return ret ; \n } \n memcpy ( st -> codecpar -> extradata , source_st -> codecpar -> extradata , \n source_st -> codecpar -> extradata_size ) ; \n return 0 ; \n } \n if ( ( ret = avcodec_parameters_copy ( st -> codecpar , source_st -> codecpar ) ) < 0 ) \n return ret ; \n st -> r_frame_rate = source_st -> r_frame_rate ; \n st -> avg_frame_rate = source_st -> avg_frame_rate ; \n st -> time_base = source_st -> time_base ; \n st -> sample_aspect_ratio = source_st -> sample_aspect_ratio ; \n av_dict_copy ( & st -> metadata , source_st -> metadata , 0 ) ; \n return 0 ; \n }", "idx": 3677}
{"project": "FFmpeg", "commit_id": "c3c3bc7ff6b25326800ef6aae3ba46f9de75d3a7", "target": 1, "func": "int ff_win32_open ( const char * filename_utf8 , int oflag , int pmode ) \n { \n int fd ; \n int num_chars ; \n wchar_t * filename_w ; \n num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , filename_utf8 , -1 , NULL , 0 ) ; \n if ( num_chars <= 0 ) \n return -1 ; \n filename_w = av_mallocz ( sizeof ( wchar_t ) * num_chars ) ; \n MultiByteToWideChar ( CP_UTF8 , 0 , filename_utf8 , -1 , filename_w , num_chars ) ; \n fd = _wsopen ( filename_w , oflag , SH_DENYNO , pmode ) ; \n av_freep ( & filename_w ) ; \n if ( fd == -1 && ! ( oflag & O_CREAT ) ) \n return _sopen ( filename_utf8 , oflag , SH_DENYNO , pmode ) ; \n return fd ; \n }", "idx": 3695}
{"project": "FFmpeg", "commit_id": "f7b47594dca27fffed9d0314ac09ffc1316514b5", "target": 0, "func": "void MPV_common_end ( MpegEncContext * s ) \n { \n int i ; \n av_freep ( & s -> mb_type ) ; \n av_freep ( & s -> p_mv_table ) ; \n av_freep ( & s -> b_forw_mv_table ) ; \n av_freep ( & s -> b_back_mv_table ) ; \n av_freep ( & s -> b_bidir_forw_mv_table ) ; \n av_freep ( & s -> b_bidir_back_mv_table ) ; \n av_freep ( & s -> b_direct_mv_table ) ; \n av_freep ( & s -> motion_val ) ; \n av_freep ( & s -> dc_val [ 0 ] ) ; \n av_freep ( & s -> ac_val [ 0 ] ) ; \n av_freep ( & s -> coded_block ) ; \n av_freep ( & s -> mbintra_table ) ; \n av_freep ( & s -> cbp_table ) ; \n av_freep ( & s -> pred_dir_table ) ; \n av_freep ( & s -> me . scratchpad ) ; \n av_freep ( & s -> me . map ) ; \n av_freep ( & s -> me . score_map ) ; \n av_freep ( & s -> mbskip_table ) ; \n av_freep ( & s -> bitstream_buffer ) ; \n av_freep ( & s -> tex_pb_buffer ) ; \n av_freep ( & s -> pb2_buffer ) ; \n av_freep ( & s -> edge_emu_buffer ) ; \n av_freep ( & s -> co_located_type_table ) ; \n av_freep ( & s -> field_mv_table ) ; \n av_freep ( & s -> field_select_table ) ; \n av_freep ( & s -> avctx -> stats_out ) ; \n av_freep ( & s -> ac_stats ) ; \n av_freep ( & s -> error_status_table ) ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n free_picture ( s , & s -> picture [ i ] ) ; \n } \n s -> context_initialized = 0 ; \n }", "idx": 3710}
{"project": "FFmpeg", "commit_id": "69b8d83ecf5f6deb9ad94bdaa816aa205430d3e9", "target": 1, "func": "static void end_frame ( AVFilterLink * inlink ) \n { \n GradFunContext * gf = inlink -> dst -> priv ; \n AVFilterBufferRef * inpic = inlink -> cur_buf ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * outpic = outlink -> out_buf ; \n int p ; \n for ( p = 0 ; p < 4 && inpic -> data [ p ] ; p ++ ) { \n int w = inlink -> w ; \n int h = inlink -> h ; \n int r = gf -> radius ; \n if ( p ) { \n w = gf -> chroma_w ; \n h = gf -> chroma_h ; \n r = gf -> chroma_r ; \n } \n if ( FFMIN ( w , h ) > 2 * r ) \n filter ( gf , outpic -> data [ p ] , inpic -> data [ p ] , w , h , outpic -> linesize [ p ] , inpic -> linesize [ p ] , r ) ; \n else if ( outpic -> data [ p ] != inpic -> data [ p ] ) \n av_image_copy_plane ( outpic -> data [ p ] , outpic -> linesize [ p ] , inpic -> data [ p ] , inpic -> linesize [ p ] , w , h ) ; \n } \n avfilter_draw_slice ( outlink , 0 , inlink -> h , 1 ) ; \n avfilter_end_frame ( outlink ) ; \n avfilter_unref_buffer ( inpic ) ; \n avfilter_unref_buffer ( outpic ) ; \n }", "idx": 3719}
{"project": "FFmpeg", "commit_id": "732f9764561558a388c05483ed6a722a5c67b05c", "target": 1, "func": "static inline void decode_subband_slice_buffered ( SnowContext * s , SubBand * b , slice_buffer * sb , int start_y , int h , int save_state [ 1 ] ) { \n const int w = b -> width ; \n int y ; \n const int qlog = av_clip ( s -> qlog + b -> qlog , 0 , QROOT * 16 ) ; \n int qmul = ff_qexp [ qlog & ( QROOT - 1 ) ] << ( qlog >> QSHIFT ) ; \n int qadd = ( s -> qbias * qmul ) >> QBIAS_SHIFT ; \n int new_index = 0 ; \n if ( b -> ibuf == s -> spatial_idwt_buffer || s -> qlog == LOSSLESS_QLOG ) { \n qadd = 0 ; \n qmul = 1 << QEXPSHIFT ; \n } \n if ( start_y != 0 ) \n new_index = save_state [ 0 ] ; \n for ( y = start_y ; y < h ; y ++ ) { \n int x = 0 ; \n int v ; \n IDWTELEM * line = slice_buffer_get_line ( sb , y * b -> stride_line + b -> buf_y_offset ) + b -> buf_x_offset ; \n memset ( line , 0 , b -> width * sizeof ( IDWTELEM ) ) ; \n v = b -> x_coeff [ new_index ] . coeff ; \n x = b -> x_coeff [ new_index ++ ] . x ; \n while ( x < w ) { \n register int t = ( ( v >> 1 ) * qmul + qadd ) >> QEXPSHIFT ; \n register int u = - ( v & 1 ) ; \n line [ x ] = ( t ^ u ) - u ; \n v = b -> x_coeff [ new_index ] . coeff ; \n x = b -> x_coeff [ new_index ++ ] . x ; \n } \n } \n save_state [ 0 ] = new_index ; \n return ; \n }", "idx": 3726}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int aiff_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n AIFFInputContext * aiff = s -> priv_data ; \n int64_t max_size ; \n int res , size ; \n max_size = aiff -> data_end - avio_tell ( s -> pb ) ; \n if ( max_size <= 0 ) \n return AVERROR_EOF ; \n if ( st -> codec -> block_align >= 33 ) \n size = st -> codec -> block_align ; \n else \n size = ( MAX_SIZE / st -> codec -> block_align ) * st -> codec -> block_align ; \n size = FFMIN ( max_size , size ) ; \n res = av_get_packet ( s -> pb , pkt , size ) ; \n if ( res < 0 ) \n return res ; \n pkt -> stream_index = 0 ; \n pkt -> duration = ( res / st -> codec -> block_align ) * aiff -> block_duration ; \n return 0 ; \n }", "idx": 3735}
{"project": "FFmpeg", "commit_id": "d38c173dfb4bbee19ec341202c6c79bb0aa2cdad", "target": 0, "func": "static void yae_clear ( ATempoContext * atempo ) \n { \n atempo -> size = 0 ; \n atempo -> head = 0 ; \n atempo -> tail = 0 ; \n atempo -> drift = 0 ; \n atempo -> nfrag = 0 ; \n atempo -> state = YAE_LOAD_FRAGMENT ; \n atempo -> position [ 0 ] = 0 ; \n atempo -> position [ 1 ] = 0 ; \n atempo -> frag [ 0 ] . position [ 0 ] = 0 ; \n atempo -> frag [ 0 ] . position [ 1 ] = 0 ; \n atempo -> frag [ 0 ] . nsamples = 0 ; \n atempo -> frag [ 1 ] . position [ 0 ] = 0 ; \n atempo -> frag [ 1 ] . position [ 1 ] = 0 ; \n atempo -> frag [ 1 ] . nsamples = 0 ; \n atempo -> frag [ 0 ] . position [ 0 ] = - ( int64_t ) ( atempo -> window / 2 ) ; \n atempo -> frag [ 0 ] . position [ 1 ] = - ( int64_t ) ( atempo -> window / 2 ) ; \n av_frame_free ( & atempo -> dst_buffer ) ; \n atempo -> dst = NULL ; \n atempo -> dst_end = NULL ; \n atempo -> request_fulfilled = 0 ; \n atempo -> nsamples_in = 0 ; \n atempo -> nsamples_out = 0 ; \n }", "idx": 3737}
{"project": "FFmpeg", "commit_id": "cfcd396bae11de94ad4a729361bc9b7b05f04c27", "target": 0, "func": "static void allocate_buffers ( FLACContext * s ) { \n int i ; \n assert ( s -> max_blocksize ) ; \n if ( s -> max_framesize == 0 && s -> max_blocksize ) { \n s -> max_framesize = ( s -> channels * s -> bps * s -> max_blocksize + 7 ) / 8 ; \n } \n for ( i = 0 ; i < s -> channels ; i ++ ) \n { \n s -> decoded [ i ] = av_realloc ( s -> decoded [ i ] , sizeof ( int32_t ) * s -> max_blocksize ) ; \n } \n s -> bitstream = av_fast_realloc ( s -> bitstream , & s -> allocated_bitstream_size , s -> max_framesize ) ; \n }", "idx": 3759}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_add_c ( uint8_t * dest \n , int line_size , DCTELEM * block \n ) { \n idct ( dest , line_size , block , 2 ) ; \n }", "idx": 3760}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void clear_blocks_dcbz32_ppc ( DCTELEM * blocks ) \n { \n POWERPC_TBL_DECLARE ( powerpc_clear_blocks_dcbz32 , 1 ) ; \n register int misal = ( ( unsigned long ) blocks & 0x00000010 ) ; \n register int i = 0 ; \n POWERPC_TBL_START_COUNT ( powerpc_clear_blocks_dcbz32 , 1 ) ; \n #if 1  \n  \n  if ( misal ) { \n ( ( unsigned long * ) blocks ) [ 0 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 1 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 2 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 3 ] = 0L ; \n i += 16 ; \n } \n for ( ; i < sizeof ( DCTELEM ) * 6 * 64 ; i += 32 ) { \n asm volatile ( \" \" : : \" \" ( blocks ) , \" \" ( i ) : \" \" ) ; \n } \n if ( misal ) { \n ( ( unsigned long * ) blocks ) [ 188 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 189 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 190 ] = 0L ; \n ( ( unsigned long * ) blocks ) [ 191 ] = 0L ; \n i += 16 ; \n } \n #else \n memset ( blocks , 0 , sizeof ( DCTELEM ) * 6 * 64 ) ; \n #endif \n POWERPC_TBL_STOP_COUNT ( powerpc_clear_blocks_dcbz32 , 1 ) ; \n }", "idx": 3787}
{"project": "FFmpeg", "commit_id": "bdf7093bd0cb78d39df8a32cfdc9188d7a960278", "target": 0, "func": "static int video_get_buffer ( AVCodecContext * s , AVFrame * pic ) \n { \n FramePool * pool = s -> internal -> pool ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pic -> format ) ; \n int i ; \n if ( pic -> data [ 0 ] ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( ! desc ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" , \n av_get_pix_fmt_name ( pic -> format ) ) ; \n return AVERROR ( EINVAL ) ; \n } \n memset ( pic -> data , 0 , sizeof ( pic -> data ) ) ; \n pic -> extended_data = pic -> data ; \n for ( i = 0 ; i < 4 && pool -> pools [ i ] ; i ++ ) { \n pic -> linesize [ i ] = pool -> linesize [ i ] ; \n pic -> buf [ i ] = av_buffer_pool_get ( pool -> pools [ i ] ) ; \n if ( ! pic -> buf [ i ] ) \n goto fail ; \n pic -> data [ i ] = pic -> buf [ i ] -> data ; \n } \n for ( ; i < AV_NUM_DATA_POINTERS ; i ++ ) { \n pic -> data [ i ] = NULL ; \n pic -> linesize [ i ] = 0 ; \n } \n if ( desc -> flags & AV_PIX_FMT_FLAG_PAL || \n desc -> flags & AV_PIX_FMT_FLAG_PSEUDOPAL ) \n avpriv_set_systematic_pal2 ( ( uint32_t * ) pic -> data [ 1 ] , pic -> format ) ; \n if ( s -> debug & FF_DEBUG_BUFFERS ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , pic ) ; \n return 0 ; \n fail : \n av_frame_unref ( pic ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 3798}
{"project": "FFmpeg", "commit_id": "0acf7e268b2f873379cd854b4d5aaba6f9c1f0b5", "target": 0, "func": "int avfilter_init_str ( AVFilterContext * filter , const char * args ) \n { \n return avfilter_init_filter ( filter , args , NULL ) ; \n }", "idx": 3807}
{"project": "FFmpeg", "commit_id": "75b9ed04b977bfd467816f7e60c6511ef89b8a2b", "target": 0, "func": "int av_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret = compute_pkt_fields2 ( s , s -> streams [ pkt -> stream_index ] , pkt ) ; \n if ( ret < 0 && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) \n return ret ; \n ret = s -> oformat -> write_packet ( s , pkt ) ; \n if ( ! ret ) \n ret = url_ferror ( s -> pb ) ; \n return ret ; \n }", "idx": 3818}
{"project": "FFmpeg", "commit_id": "e6b1ed693ae4098e6b9eabf938fc31ec0b09b120", "target": 0, "func": "av_cold int ff_fft_init ( FFTContext * s , int nbits , int inverse ) \n { \n int i , j , n ; \n if ( nbits < 2 || nbits > 16 ) \n goto fail ; \n s -> nbits = nbits ; \n n = 1 << nbits ; \n s -> revtab = av_malloc ( n * sizeof ( uint16_t ) ) ; \n if ( ! s -> revtab ) \n goto fail ; \n s -> tmp_buf = av_malloc ( n * sizeof ( FFTComplex ) ) ; \n if ( ! s -> tmp_buf ) \n goto fail ; \n s -> inverse = inverse ; \n s -> fft_permute = ff_fft_permute_c ; \n s -> fft_calc = ff_fft_calc_c ; \n #if CONFIG_MDCT  \n  \n  s -> imdct_calc = ff_imdct_calc_c ; \n s -> imdct_half = ff_imdct_half_c ; \n s -> mdct_calc = ff_mdct_calc_c ; \n #endif \n if ( ARCH_ARM ) ff_fft_init_arm ( s ) ; \n if ( HAVE_ALTIVEC ) ff_fft_init_altivec ( s ) ; \n if ( HAVE_MMX ) ff_fft_init_mmx ( s ) ; \n for ( j = 4 ; j <= nbits ; j ++ ) { \n ff_init_ff_cos_tabs ( j ) ; \n } \n for ( i = 0 ; i < n ; i ++ ) \n s -> revtab [ - split_radix_permutation ( i , n , s -> inverse ) & ( n - 1 ) ] = i ; \n return 0 ; \n fail : \n av_freep ( & s -> revtab ) ; \n av_freep ( & s -> tmp_buf ) ; \n return -1 ; \n }", "idx": 3821}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void start_frame ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n AVFilterBufferRef * outpicref = avfilter_ref_buffer ( inpicref , ~ 0 ) ; \n AVFilterContext * ctx = inlink -> dst ; \n OverlayContext * over = ctx -> priv ; \n av_unused AVFilterLink  * outlink = ctx -> outputs [ 0 ] ; \n inlink -> dst -> outputs [ 0 ] -> out_buf = outpicref ; \n outpicref -> pts = av_rescale_q ( outpicref -> pts , ctx -> inputs [ MAIN ] -> time_base , \n ctx -> outputs [ 0 ] -> time_base ) ; \n if ( ! over -> overpicref || over -> overpicref -> pts < outpicref -> pts ) { \n if ( ! over -> overpicref_next ) \n avfilter_request_frame ( ctx -> inputs [ OVERLAY ] ) ; \n if ( over -> overpicref && over -> overpicref_next && \n over -> overpicref_next -> pts <= outpicref -> pts ) { \n avfilter_unref_buffer ( over -> overpicref ) ; \n over -> overpicref = over -> overpicref_next ; \n over -> overpicref_next = NULL ; \n } \n } \n av_dlog ( ctx , \" \" , \n av_ts2str ( outpicref -> pts ) , av_ts2timestr ( outpicref -> pts , & outlink -> time_base ) ) ; \n if ( over -> overpicref ) \n av_dlog ( ctx , \" \" , \n av_ts2str ( over -> overpicref -> pts ) , av_ts2timestr ( over -> overpicref -> pts , & outlink -> time_base ) ) ; \n av_dlog ( ctx , \" \\n \" ) ; \n avfilter_start_frame ( inlink -> dst -> outputs [ 0 ] , outpicref ) ; \n }", "idx": 3823}
{"project": "FFmpeg", "commit_id": "1967cd4e4c1cd96dfa195ce14e4b212ddb70586d", "target": 0, "func": "static int interleave_new_audio_packet ( AVFormatContext * s , AVPacket * pkt , \n int stream_index , int flush ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n int size = FFMIN ( av_fifo_size ( aic -> fifo ) , * aic -> samples * aic -> sample_size ) ; \n if ( ! size || ( ! flush && size == av_fifo_size ( aic -> fifo ) ) ) \n return 0 ; \n av_new_packet ( pkt , size ) ; \n av_fifo_generic_read ( aic -> fifo , pkt -> data , size , NULL ) ; \n pkt -> dts = pkt -> pts = aic -> dts ; \n pkt -> duration = av_rescale_q ( * aic -> samples , st -> time_base , aic -> time_base ) ; \n pkt -> stream_index = stream_index ; \n aic -> dts += pkt -> duration ; \n aic -> samples ++ ; \n if ( ! * aic -> samples ) \n aic -> samples = aic -> samples_per_frame ; \n return size ; \n }", "idx": 3831}
{"project": "FFmpeg", "commit_id": "5e600185453e1a0ded70a59701f60a0022a88e42", "target": 0, "func": "static AVFilterContext * create_filter ( AVFilterGraph * ctx , int index , \n const char * name , const char * args , \n AVClass * log_ctx ) \n { \n AVFilterContext * filt ; \n AVFilter * filterdef ; \n char inst_name [ 30 ] ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , index ) ; \n if ( ! ( filterdef = avfilter_get_by_name ( name ) ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n if ( ! ( filt = avfilter_open ( filterdef , inst_name ) ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n if ( avfilter_graph_add_filter ( ctx , filt ) < 0 ) \n return NULL ; \n if ( avfilter_init_filter ( filt , args , NULL ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name , args ) ; \n return NULL ; \n } \n return filt ; \n }", "idx": 3839}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int get_last_needed_nal ( H264Context * h ) \n { \n int nals_needed = 0 ; \n int i ; \n for ( i = 0 ; i < h -> pkt . nb_nals ; i ++ ) { \n H2645NAL * nal = & h -> pkt . nals [ i ] ; \n GetBitContext gb ; \n switch ( nal -> type ) { \n case NAL_SPS : \n case NAL_PPS : \n nals_needed = i ; \n break ; \n case NAL_DPA : \n case NAL_IDR_SLICE : \n case NAL_SLICE : \n init_get_bits ( & gb , nal -> data + 1 , ( nal -> size - 1 ) * 8 ) ; \n if ( ! get_ue_golomb ( & gb ) ) \n nals_needed = i ; \n } \n } \n return nals_needed ; \n }", "idx": 3850}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static enum AVPixelFormat get_chroma_format ( SchroChromaFormat schro_pix_fmt ) \n { \n int num_formats = sizeof ( schro_pixel_format_map ) / \n sizeof ( schro_pixel_format_map [ 0 ] ) ; \n int idx ; \n for ( idx = 0 ; idx < num_formats ; ++ idx ) \n if ( schro_pixel_format_map [ idx ] . schro_pix_fmt == schro_pix_fmt ) \n return schro_pixel_format_map [ idx ] . ff_pix_fmt ; \n return AV_PIX_FMT_NONE ; \n }", "idx": 3860}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char * seq_decode_op3 ( SeqVideoContext * seq , const unsigned char * src , unsigned char * dst ) \n { \n int pos , offset ; \n do { \n pos = * src ++ ; \n offset = ( ( pos >> 3 ) & 7 ) * seq -> frame . linesize [ 0 ] + ( pos & 7 ) ; \n dst [ offset ] = * src ++ ; \n } while ( ! ( pos & 0x80 ) ) ; \n return src ; \n }", "idx": 3863}
{"project": "FFmpeg", "commit_id": "a717f9904227d7979473bad40c50eb40af41d01d", "target": 1, "func": "static int mpegts_read_close ( AVFormatContext * s ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int i ; \n clear_programs ( ts ) ; \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) \n if ( ts -> pids [ i ] ) mpegts_close_filter ( ts , ts -> pids [ i ] ) ; \n return 0 ; \n }", "idx": 3867}
{"project": "FFmpeg", "commit_id": "0e830094ad0dc251613a0aa3234d9c5c397e02e6", "target": 1, "func": "int av_samples_get_buffer_size ( int * linesize , int nb_channels , int nb_samples , \n enum AVSampleFormat sample_fmt , int align ) \n { \n int line_size ; \n int sample_size = av_get_bytes_per_sample ( sample_fmt ) ; \n int planar = av_sample_fmt_is_planar ( sample_fmt ) ; \n if ( ! sample_size || nb_samples <= 0 || nb_channels <= 0 ) \n if ( ! align ) { \n align = 1 ; \n nb_samples = FFALIGN ( nb_samples , 32 ) ; \n } \n if ( nb_channels > INT_MAX / align || \n ( int64_t ) nb_channels * nb_samples > ( INT_MAX - ( align * nb_channels ) ) / sample_size ) \n line_size = planar ? FFALIGN ( nb_samples * sample_size , align ) : \n FFALIGN ( nb_samples * sample_size * nb_channels , align ) ; \n if ( linesize ) \n * linesize = line_size ; \n return planar ? line_size * nb_channels : line_size ; \n }", "idx": 3868}
{"project": "FFmpeg", "commit_id": "954d94dd5e13ba7a5e9e049d0f980bddced9644c", "target": 1, "func": "static void adx_encode ( unsigned char * adx , const short * wav , \n ADXChannelState * prev ) \n { \n int scale ; \n int i ; \n int s0 , s1 , s2 , d ; \n int max = 0 ; \n int min = 0 ; \n int data [ 32 ] ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n s0 = wav [ i ] ; \n d = ( ( s0 << 14 ) - SCALE1 * s1 + SCALE2 * s2 ) / BASEVOL ; \n data [ i ] = d ; \n if ( max < d ) max = d ; \n if ( min > d ) min = d ; \n s2 = s1 ; \n s1 = s0 ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n if ( max == 0 && min == 0 ) { \n memset ( adx , 0 , 18 ) ; \n return ; \n } \n if ( max / 7 > - min / 8 ) scale = max / 7 ; \n else scale = - min / 8 ; \n if ( scale == 0 ) scale = 1 ; \n AV_WB16 ( adx , scale ) ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n adx [ i + 2 ] = ( ( data [ i * 2 ] / scale ) << 4 ) | ( ( data [ i * 2 + 1 ] / scale ) & 0xf ) ; \n } \n }", "idx": 3872}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_x2_mmx ( UINT8 * block , const UINT8 * pixels , int line_size , int h ) \n { \n UINT8 * p ; \n const UINT8 * pix ; \n p = block ; \n pix = pixels ; \n MOVQ_ZERO ( mm7 ) ; \n do { \n __asm __volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" = m \" ( * p ) \n : \" m \" ( * pix ) \n : \" memory \" ) ; \n pix += line_size ; \n p += line_size ; \n } while ( -- h ) ; \n }", "idx": 3876}
{"project": "FFmpeg", "commit_id": "86476c510ebd14d33ed02289d71bae874f8707a4", "target": 1, "func": "inline static int push_frame ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n ShowWavesContext * showwaves = outlink -> src -> priv ; \n int nb_channels = inlink -> channels ; \n int ret , i ; \n if ( ( ret = ff_filter_frame ( outlink , showwaves -> outpicref ) ) >= 0 ) \n showwaves -> req_fullfilled = 1 ; \n showwaves -> outpicref = NULL ; \n showwaves -> buf_idx = 0 ; \n for ( i = 0 ; i <= nb_channels ; i ++ ) \n showwaves -> buf_idy [ i ] = 0 ; \n return ret ; \n }", "idx": 3898}
{"project": "FFmpeg", "commit_id": "a606f27f4c610708fa96e35eed7b7537d3d8f712", "target": 0, "func": "int avio_read ( AVIOContext * s , unsigned char * buf , int size ) \n { \n int len , size1 ; \n size1 = size ; \n while ( size > 0 ) { \n len = FFMIN ( s -> buf_end - s -> buf_ptr , size ) ; \n if ( len == 0 || s -> write_flag ) { \n if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum ) { \n if ( s -> read_packet ) \n len = s -> read_packet ( s -> opaque , buf , size ) ; \n else \n len = AVERROR_EOF ; \n if ( len == AVERROR_EOF ) { \n s -> eof_reached = 1 ; \n break ; \n } else if ( len < 0 ) { \n s -> eof_reached = 1 ; \n s -> error = len ; \n break ; \n } else { \n s -> pos += len ; \n s -> bytes_read += len ; \n size -= len ; \n buf += len ; \n s -> buf_ptr = s -> buffer ; \n s -> buf_end = s -> buffer \n ; \n } \n } else { \n fill_buffer ( s ) ; \n len = s -> buf_end - s -> buf_ptr ; \n if ( len == 0 ) \n break ; \n } \n } else { \n memcpy ( buf , s -> buf_ptr , len ) ; \n buf += len ; \n s -> buf_ptr += len ; \n size -= len ; \n } \n } \n if ( size1 == size ) { \n if ( s -> error ) return s -> error ; \n if ( avio_feof ( s ) ) return AVERROR_EOF ; \n } \n return size1 - size ; \n }", "idx": 3903}
{"project": "FFmpeg", "commit_id": "cde57eee98d2e26daeeb1ba0cdd1f3d3acb3eb8a", "target": 0, "func": "static int hls_probe ( AVProbeData * p ) \n { \n if ( strncmp ( p -> buf , \" \" , 7 ) ) \n return 0 ; \n if ( p -> filename && ! av_match_ext ( p -> filename , \" \" ) ) \n return 0 ; \n if ( strstr ( p -> buf , \" \" ) || \n strstr ( p -> buf , \" \" ) || \n strstr ( p -> buf , \" \" ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 3904}
{"project": "FFmpeg", "commit_id": "7b9fc769e40a7709fa59a54e2a810f76364eee4b", "target": 0, "func": "static int svq1_motion_inter_block ( MpegEncContext * s , GetBitContext * bitbuf , \n uint8_t * current , uint8_t * previous , \n int pitch , svq1_pmv * motion , int x , int y ) \n { \n uint8_t * src ; \n uint8_t * dst ; \n svq1_pmv mv ; \n svq1_pmv * pmv [ 3 ] ; \n int result ; \n pmv [ 0 ] = & motion [ 0 ] ; \n if ( y == 0 ) { \n pmv [ 1 ] = \n pmv [ 2 ] = pmv [ 0 ] ; \n } else { \n pmv [ 1 ] = & motion [ x / 8 + 2 ] ; \n pmv [ 2 ] = & motion [ x / 8 + 4 ] ; \n } \n result = svq1_decode_motion_vector ( bitbuf , & mv , pmv ) ; \n if ( result != 0 ) \n return result ; \n motion [ 0 ] . x = \n motion [ x / 8 + 2 ] . x = \n motion [ x / 8 + 3 ] . x = mv . x ; \n motion [ 0 ] . y = \n motion [ x / 8 + 2 ] . y = \n motion [ x / 8 + 3 ] . y = mv . y ; \n if ( y + ( mv . y >> 1 ) < 0 ) \n mv . y = 0 ; \n if ( x + ( mv . x >> 1 ) < 0 ) \n mv . x = 0 ; \n src = & previous [ ( x + ( mv . x >> 1 ) ) + ( y + ( mv . y >> 1 ) ) * pitch ] ; \n dst = current ; \n s -> dsp . put_pixels_tab [ 0 ] [ ( mv . y & 1 ) << 1 | ( mv . x & 1 ) ] ( dst , src , pitch , 16 ) ; \n return 0 ; \n }", "idx": 3905}
{"project": "FFmpeg", "commit_id": "df92ac18528bac4566fc4f5ba4d607c1265791ea", "target": 1, "func": "static int r3d_read_reda ( AVFormatContext * s , AVPacket * pkt , Atom * atom ) \n { \n AVStream * st = s -> streams [ 1 ] ; \n int av_unused tmp , tmp2 ; \n int samples , size ; \n uint64_t pos = avio_tell ( s -> pb ) ; \n unsigned dts ; \n int ret ; \n dts = avio_rb32 ( s -> pb ) ; \n st -> codec -> sample_rate = avio_rb32 ( s -> pb ) ; \n samples = avio_rb32 ( s -> pb ) ; \n tmp = avio_rb32 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n tmp = avio_rb16 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n tmp = avio_r8 ( s -> pb ) ; \n tmp2 = avio_r8 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp , tmp2 ) ; \n tmp = avio_rb32 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n size = atom -> size - 8 - ( avio_tell ( s -> pb ) - pos ) ; \n if ( size < 0 ) \n return -1 ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n if ( ret < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n pkt -> stream_index = 1 ; \n pkt -> dts = dts ; \n pkt -> duration = av_rescale ( samples , st -> time_base . den , st -> codec -> sample_rate ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , \n pkt -> dts , pkt -> duration , samples , st -> codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 3915}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_packet ( AVFormatContext * fmt_ctx , AVPacket * pkt ) \n { \n char val_str [ 128 ] ; \n AVStream * st = fmt_ctx -> streams [ pkt -> stream_index ] ; \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" , media_type_string ( st -> codec -> codec_type ) ) ; \n printf ( \" \\n \" , pkt -> stream_index ) ; \n printf ( \" \\n \" , ts_value_string ( val_str , sizeof ( val_str ) , pkt -> pts ) ) ; \n printf ( \" \\n \" , time_value_string ( val_str , sizeof ( val_str ) , \n pkt -> pts , & st -> time_base ) ) ; \n printf ( \" \\n \" , ts_value_string ( val_str , sizeof ( val_str ) , pkt -> dts ) ) ; \n printf ( \" \\n \" , time_value_string ( val_str , sizeof ( val_str ) , \n pkt -> dts , & st -> time_base ) ) ; \n printf ( \" \\n \" , ts_value_string ( val_str , sizeof ( val_str ) , \n pkt -> duration ) ) ; \n printf ( \" \\n \" , time_value_string ( val_str , sizeof ( val_str ) , \n pkt -> duration , \n & st -> time_base ) ) ; \n printf ( \" \\n \" , value_string ( val_str , sizeof ( val_str ) , \n pkt -> size , unit_byte_str ) ) ; \n printf ( \" \" PRId64 \" \\n \" , pkt -> pos ) ; \n printf ( \" \\n \" , pkt -> flags & AV_PKT_FLAG_KEY ? ' ' : ' ' ) ; \n printf ( \" \\n \" ) ; \n }", "idx": 3932}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static int encode_individual_channel ( AVCodecContext * avctx , AACEncContext * s , \n SingleChannelElement * sce , \n int common_window ) \n { \n put_bits ( & s -> pb , 8 , sce -> sf_idx [ 0 ] ) ; \n if ( ! common_window ) { \n put_ics_info ( s , & sce -> ics ) ; \n if ( s -> coder -> encode_main_pred ) \n s -> coder -> encode_main_pred ( s , sce ) ; \n } \n encode_band_info ( s , sce ) ; \n encode_scale_factors ( avctx , s , sce ) ; \n encode_pulses ( s , & sce -> pulse ) ; \n if ( s -> coder -> encode_tns_info ) \n s -> coder -> encode_tns_info ( s , sce ) ; \n else \n put_bits ( & s -> pb , 1 , 0 ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n encode_spectral_coeffs ( s , sce ) ; \n return 0 ; \n }", "idx": 3943}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_top_dc ) ( uint8_t * _src , int stride ) { \n int i ; \n int dc0 , dc1 ; \n pixel4 dc0splat , dc1splat ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n dc0 = dc1 = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dc0 += src [ i - stride ] ; \n dc1 += src [ 4 + i - stride ] ; \n } \n dc0splat = PIXEL_SPLAT_X4 ( ( dc0 + 2 ) >> 2 ) ; \n dc1splat = PIXEL_SPLAT_X4 ( ( dc1 + 2 ) >> 2 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc0splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc1splat ; \n } \n for ( i = 4 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc0splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc1splat ; \n } \n }", "idx": 3947}
{"project": "FFmpeg", "commit_id": "efc8c709c93875dffa4c4181fa9b56fa6d20d4c7", "target": 1, "func": "static int draw_glyphs ( DrawTextContext * dtext , AVFilterBufferRef * picref , \n int width , int height , const uint8_t rgbcolor [ 4 ] , const uint8_t yuvcolor [ 4 ] , int x , int y ) \n { \n char * text = dtext -> text ; \n uint32_t code = 0 ; \n int i ; \n uint8_t * p ; \n Glyph * glyph = NULL ; \n for ( i = 0 , p = text ; * p ; i ++ ) { \n Glyph dummy = { 0 } ; \n GET_UTF8 ( code , * p ++ , continue ; ) ; \n if ( code == ' \\n ' || code == ' \\r ' || code == ' \\t ' ) \n continue ; \n dummy . code = code ; \n glyph = av_tree_find ( dtext -> glyphs , & dummy , ( void * ) glyph_cmp , NULL ) ; \n if ( glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_MONO && \n glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_GRAY ) \n return AVERROR ( EINVAL ) ; \n if ( dtext -> is_packed_rgb ) { \n draw_glyph_rgb ( picref , & glyph -> bitmap , \n dtext -> positions [ i ] . x + x , dtext -> positions [ i ] . y + y , width , height , \n dtext -> pixel_step [ 0 ] , rgbcolor , dtext -> rgba_map ) ; \n } else { \n draw_glyph_yuv ( picref , & glyph -> bitmap , \n dtext -> positions [ i ] . x + x , dtext -> positions [ i ] . y + y , width , height , \n yuvcolor , dtext -> hsub , dtext -> vsub ) ; \n } \n } \n return 0 ; \n }", "idx": 3949}
{"project": "FFmpeg", "commit_id": "8d168a9207f231c22a04a5a2b252d0ab89477b02", "target": 1, "func": "static int rtsp_read_play ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPMessageHeader reply1 , * reply = & reply1 ; \n int i ; \n char cmd [ 1024 ] ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , rt -> state ) ; \n if ( ! ( rt -> server_type == RTSP_SERVER_REAL && rt -> need_subscription ) ) { \n if ( rt -> state == RTSP_STATE_PAUSED ) { \n cmd [ 0 ] = 0 ; \n } else { \n snprintf ( cmd , sizeof ( cmd ) , \n \" \\r \\n \" , \n ( double ) rt -> seek_timestamp / AV_TIME_BASE ) ; \n } \n ff_rtsp_send_cmd ( s , \" \" , rt -> control_uri , cmd , reply , NULL ) ; \n if ( reply -> status_code != RTSP_STATUS_OK ) { \n return -1 ; \n } \n if ( reply -> range_start != AV_NOPTS_VALUE && \n rt -> transport == RTSP_TRANSPORT_RTP ) { \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n RTSPStream * rtsp_st = rt -> rtsp_streams [ i ] ; \n RTPDemuxContext * rtpctx = rtsp_st -> transport_priv ; \n AVStream * st = NULL ; \n if ( rtsp_st -> stream_index >= 0 ) \n st = s -> streams [ rtsp_st -> stream_index ] ; \n rtpctx -> last_rtcp_ntp_time = AV_NOPTS_VALUE ; \n rtpctx -> first_rtcp_ntp_time = AV_NOPTS_VALUE ; \n if ( st ) \n rtpctx -> range_start_offset = av_rescale_q ( reply -> range_start , \n AV_TIME_BASE_Q , \n st -> time_base ) ; \n } \n } \n } \n rt -> state = RTSP_STATE_STREAMING ; \n return 0 ; \n }", "idx": 3961}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "int match_ext ( const char * filename , const char * extensions ) \n { \n const char * ext , * p ; \n char ext1 [ 32 ] , * q ; \n if ( ! filename ) \n return 0 ; \n ext = strrchr ( filename , ' ' ) ; \n if ( ext ) { \n ext ++ ; \n p = extensions ; \n for ( ; ; ) { \n q = ext1 ; \n while ( * p != ' \\0 ' && * p != ' ' ) \n * q ++ = * p ++ ; \n * q = ' \\0 ' ; \n if ( ! strcasecmp ( ext1 , ext ) ) \n return 1 ; \n if ( * p == ' \\0 ' ) \n break ; \n p ++ ; \n } \n } \n return 0 ; \n }", "idx": 3965}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline float to_float ( uint8_t exp , int16_t mantissa ) \n { \n return ( ( float ) ( mantissa * scale_factors [ exp ] ) ) ; \n }", "idx": 3972}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dither_init_x86 ( DitherDSPContext * ddsp , \n enum AVResampleDitherMethod method ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n ddsp -> quantize = ff_quantize_sse2 ; \n ddsp -> ptr_align = 16 ; \n ddsp -> samples_align = 8 ; \n } \n if ( method == AV_RESAMPLE_DITHER_RECTANGULAR ) { \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_rectangular_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_rectangular_avx ; \n } \n } else { \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_triangular_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n ddsp -> dither_int_to_float = ff_dither_int_to_float_triangular_avx ; \n } \n } \n }", "idx": 3976}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static void calc_sums ( int pmin , int pmax , uint32_t * data , int n , int pred_order , \n uint32_t sums [ ] [ MAX_PARTITIONS ] ) \n { \n int i , j ; \n int parts ; \n uint32_t * res , * res_end ; \n parts = ( 1 << pmax ) ; \n res = & data [ pred_order ] ; \n res_end = & data [ n >> pmax ] ; \n for ( i = 0 ; i < parts ; i ++ ) { \n uint32_t sum = 0 ; \n while ( res < res_end ) \n sum += * ( res ++ ) ; \n sums [ pmax ] [ i ] = sum ; \n res_end += n >> pmax ; \n } \n for ( i = pmax - 1 ; i >= pmin ; i -- ) { \n parts = ( 1 << i ) ; \n for ( j = 0 ; j < parts ; j ++ ) \n sums [ i ] [ j ] = sums [ i + 1 ] [ 2 * j ] + sums [ i + 1 ] [ 2 * j + 1 ] ; \n } \n }", "idx": 3985}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void init_block_index ( VC1Context * v ) \n { \n MpegEncContext * s = & v -> s ; \n ff_init_block_index ( s ) ; \n if ( v -> field_mode && ! ( v -> second_field ^ v -> tff ) ) { \n s -> dest [ 0 ] += s -> current_picture_ptr -> f . linesize [ 0 ] ; \n s -> dest [ 1 ] += s -> current_picture_ptr -> f . linesize [ 1 ] ; \n s -> dest [ 2 ] += s -> current_picture_ptr -> f . linesize [ 2 ] ; \n } \n }", "idx": 3987}
{"project": "FFmpeg", "commit_id": "eddd580b743692bc930692cb0c5a3e930ab45ad4", "target": 1, "func": "static int64_t mkv_write_cues ( AVIOContext * pb , mkv_cues * cues , int num_tracks ) \n { \n ebml_master cues_element ; \n int64_t currentpos ; \n int i , j ; \n currentpos = avio_tell ( pb ) ; \n cues_element = start_ebml_master ( pb , MATROSKA_ID_CUES , 0 ) ; \n for ( i = 0 ; i < cues -> num_entries ; i ++ ) { \n ebml_master cuepoint , track_positions ; \n mkv_cuepoint * entry = & cues -> entries [ i ] ; \n uint64_t pts = entry -> pts ; \n cuepoint = start_ebml_master ( pb , MATROSKA_ID_POINTENTRY , MAX_CUEPOINT_SIZE ( num_tracks ) ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETIME , pts ) ; \n for ( j = 0 ; j < cues -> num_entries - i && entry [ j ] . pts == pts ; j ++ ) { \n track_positions = start_ebml_master ( pb , MATROSKA_ID_CUETRACKPOSITION , MAX_CUETRACKPOS_SIZE ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETRACK , entry [ j ] . tracknum ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUECLUSTERPOSITION , entry [ j ] . cluster_pos ) ; \n end_ebml_master ( pb , track_positions ) ; \n } \n i += j - 1 ; \n end_ebml_master ( pb , cuepoint ) ; \n } \n end_ebml_master ( pb , cues_element ) ; \n av_free ( cues -> entries ) ; \n av_free ( cues ) ; \n return currentpos ; \n }", "idx": 3990}
{"project": "FFmpeg", "commit_id": "59b126f92225316e0cd77bb952d630553801dc85", "target": 1, "func": "static int dxva2_device_create9ex ( AVHWDeviceContext * ctx , UINT adapter ) \n { \n DXVA2DevicePriv * priv = ctx -> user_opaque ; \n D3DPRESENT_PARAMETERS d3dpp = dxva2_present_params ; \n D3DDISPLAYMODEEX modeex = { 0 } ; \n IDirect3D9Ex * d3d9ex = NULL ; \n IDirect3DDevice9Ex * exdev = NULL ; \n HRESULT hr ; \n pDirect3DCreate9Ex * createD3DEx = ( pDirect3DCreate9Ex * ) dlsym ( priv -> d3dlib , \" \" ) ; \n if ( ! createD3DEx ) \n return AVERROR ( ENOSYS ) ; \n hr = createD3DEx ( D3D_SDK_VERSION , & d3d9ex ) ; \n if ( FAILED ( hr ) ) \n return AVERROR_UNKNOWN ; \n IDirect3D9Ex_GetAdapterDisplayModeEx ( d3d9ex , adapter , & modeex , NULL ) ; \n d3dpp . BackBufferFormat = modeex . Format ; \n hr = IDirect3D9Ex_CreateDeviceEx ( d3d9ex , adapter , D3DDEVTYPE_HAL , GetDesktopWindow ( ) , \n FF_D3DCREATE_FLAGS , \n & d3dpp , NULL , & exdev ) ; \n if ( FAILED ( hr ) ) { \n IDirect3D9Ex_Release ( d3d9ex ) ; \n return AVERROR_UNKNOWN ; \n } \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n priv -> d3d9 = ( IDirect3D9 * ) d3d9ex ; \n priv -> d3d9device = ( IDirect3DDevice9 * ) exdev ; \n return 0 ; \n }", "idx": 3991}
{"project": "FFmpeg", "commit_id": "39ee3ddff87a12e108fc4e0d36f756d0ca080472", "target": 1, "func": "static void mov_metadata_creation_time ( AVDictionary * * metadata , int64_t time ) \n { \n if ( time ) { \n if ( time >= 2082844800 ) \n time -= 2082844800 ; \n avpriv_dict_set_timestamp ( metadata , \" \" , time * 1000000 ) ;", "idx": 3993}
{"project": "FFmpeg", "commit_id": "d87ff555025e90ef285425216c29be95034e2485", "target": 0, "func": "static int amr_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int read , size = 0 , toc , mode ; \n int64_t pos = avio_tell ( s -> pb ) ; \n if ( url_feof ( s -> pb ) ) { \n return AVERROR ( EIO ) ; \n } \n toc = avio_r8 ( s -> pb ) ; \n mode = ( toc >> 3 ) & 0x0F ; \n if ( enc -> codec_id == AV_CODEC_ID_AMR_NB ) { \n static const uint8_t packed_size [ 16 ] = { \n 12 , 13 , 15 , 17 , 19 , 20 , 26 , 31 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 \n } ; \n size = packed_size [ mode ] + 1 ; \n } else if ( enc -> codec_id == AV_CODEC_ID_AMR_WB ) { \n static const uint8_t packed_size [ 16 ] = { \n 18 , 24 , 33 , 37 , 41 , 47 , 51 , 59 , 61 , 6 , 6 , 0 , 0 , 0 , 1 , 1 \n } ; \n size = packed_size [ mode ] ; \n } else { \n av_assert0 ( 0 ) ; \n } \n if ( ! size || av_new_packet ( pkt , size ) ) \n return AVERROR ( EIO ) ; \n s -> streams [ 0 ] -> codec -> bit_rate = size * 8 * 50 ; \n pkt -> stream_index = 0 ; \n pkt -> pos = pos ; \n pkt -> data [ 0 ] = toc ; \n pkt -> duration = enc -> codec_id == AV_CODEC_ID_AMR_NB ? 160 : 320 ; \n read = avio_read ( s -> pb , pkt -> data + 1 , size - 1 ) ; \n if ( read != size - 1 ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n return 0 ; \n }", "idx": 3997}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static int rm_write_audio ( AVFormatContext * s , const uint8_t * buf , int size ) \n { \n uint8_t * buf1 ; \n RMContext * rm = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n StreamInfo * stream = rm -> audio_stream ; \n int i ; \n buf1 = ( uint8_t * ) av_malloc ( size * sizeof ( uint8_t ) ) ; \n write_packet_header ( s , stream , size , stream -> enc -> coded_frame -> key_frame ) ; \n for ( i = 0 ; i < size ; i += 2 ) { \n buf1 [ i ] = buf [ i + 1 ] ; \n buf1 [ i + 1 ] = buf [ i ] ; \n } \n put_buffer ( pb , buf1 , size ) ; \n put_flush_packet ( pb ) ; \n stream -> nb_frames ++ ; \n av_free ( buf1 ) ; \n return 0 ; \n }", "idx": 3998}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( bgr24ToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToY_mmx ) ( dst , src , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int r = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n #endif \n }", "idx": 3999}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel8_mc30_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_8w_msa ( src - 2 , stride , dst , stride , 8 , 1 ) ; \n }", "idx": 4000}
{"project": "FFmpeg", "commit_id": "38893dc028e458eaf3f906833d4ee515689edb7e", "target": 0, "func": "static int pcm_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size , bps ; \n size = RAW_SAMPLES * s -> streams [ 0 ] -> codec -> block_align ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n bps = av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) ; \n assert ( bps ) ; \n pkt -> dts = \n pkt -> pts = pkt -> pos * 8 / ( bps * s -> streams [ 0 ] -> codec -> channels ) ; \n return ret ; \n }", "idx": 4002}
{"project": "FFmpeg", "commit_id": "56e11ebf55a5e51a8a7131d382c2020e35d34f42", "target": 1, "func": "static av_cold int encode_close ( AVCodecContext * avctx ) \n { \n if ( avctx -> priv_data ) { \n DCAEncContext * c = avctx -> priv_data ; \n subband_bufer_free ( c ) ; \n ff_dcaadpcm_free ( & c -> adpcm_ctx ) ; \n } \n return 0 ; \n }", "idx": 4004}
{"project": "FFmpeg", "commit_id": "a26e9c1040afeecf9013da742b0dec7009445f2b", "target": 0, "func": "static int amv_encode_picture ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * pic_arg , int * got_packet ) \n { \n MpegEncContext * s = avctx -> priv_data ; \n AVFrame * pic ; \n int i , ret ; \n int chroma_h_shift , chroma_v_shift ; \n av_pix_fmt_get_chroma_sub_sample ( avctx -> pix_fmt , & chroma_h_shift , & chroma_v_shift ) ; \n if ( s -> avctx -> flags & CODEC_FLAG_EMU_EDGE ) \n return AVERROR ( EINVAL ) ; \n pic = av_frame_alloc ( ) ; \n if ( ! pic ) \n return AVERROR ( ENOMEM ) ; \n av_frame_ref ( pic , pic_arg ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int vsample = i ? 2 >> chroma_v_shift : 2 ; \n pic -> data [ i ] += ( pic -> linesize [ i ] * ( vsample * ( 8 * s -> mb_height - ( ( s -> height / V_MAX ) & 7 ) ) - 1 ) ) ; \n pic -> linesize [ i ] *= -1 ; \n } \n ret = ff_MPV_encode_picture ( avctx , pkt , pic , got_packet ) ; \n av_frame_free ( & pic ) ; \n return ret ; \n }", "idx": 4011}
{"project": "FFmpeg", "commit_id": "237ccd8a165d2128e8c6bcb14c8c6c3e793cfe05", "target": 0, "func": "static av_always_inline int get_dst_color_err ( PaletteUseContext * s , \n uint32_t c , int * er , int * eg , int * eb , \n const enum color_search_method search_method ) \n { \n const uint8_t a = c >> 24 & 0xff ; \n const uint8_t r = c >> 16 & 0xff ; \n const uint8_t g = c >> 8 & 0xff ; \n const uint8_t b = c & 0xff ; \n const int dstx = color_get ( s , c , a , r , g , b , search_method ) ; \n const uint32_t dstc = s -> palette [ dstx ] ; \n * er = r - ( dstc >> 16 & 0xff ) ; \n * eg = g - ( dstc >> 8 & 0xff ) ; \n * eb = b - ( dstc & 0xff ) ; \n return dstx ; \n }", "idx": 4021}
{"project": "FFmpeg", "commit_id": "68f8d33becbd73b4d0aa277f472a6e8e72ea6849", "target": 0, "func": "static inline void put_symbol_inline ( RangeCoder * c , uint8_t * state , int v , int is_signed ) { \n int i ; \n if ( v ) { \n const int a = FFABS ( v ) ; \n const int e = av_log2 ( a ) ; \n put_rac ( c , state + 0 , 0 ) ; \n assert ( e <= 9 ) ; \n for ( i = 0 ; i < e ; i ++ ) { \n put_rac ( c , state + 1 + i , 1 ) ; \n } \n put_rac ( c , state + 1 + i , 0 ) ; \n for ( i = e - 1 ; i >= 0 ; i -- ) { \n put_rac ( c , state + 22 + i , ( a >> i ) & 1 ) ; \n } \n if ( is_signed ) \n put_rac ( c , state + 11 + e , v < 0 ) ; \n } else { \n put_rac ( c , state + 0 , 1 ) ; \n } \n }", "idx": 4022}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_rgb555 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n const unsigned char * p ; \n unsigned char * q ; \n int r , g , b , dst_wrap , src_wrap ; \n int x , y ; \n p = src -> data [ 0 ] ; \n src_wrap = src -> linesize [ 0 ] - 3 * width ; \n q = dst -> data [ 0 ] ; \n dst_wrap = dst -> linesize [ 0 ] - 2 * width ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n r = p [ 0 ] ; \n g = p [ 1 ] ; \n b = p [ 2 ] ; \n ( ( unsigned short * ) q ) [ 0 ] = \n ( ( r >> 3 ) << 10 ) | ( ( g >> 3 ) << 5 ) | ( b >> 3 ) | 0x8000 ; \n q += 2 ; \n p += 3 ; \n } \n p += src_wrap ; \n q += dst_wrap ; \n } \n }", "idx": 4023}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_left ( const char * arg ) \n { \n frame_padleft = atoi ( arg ) ; \n if ( frame_padleft < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n }", "idx": 4027}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 4040}
{"project": "FFmpeg", "commit_id": "74dc728a2c2cc353da20cdc09b8cdfbbe14b7be8", "target": 1, "func": "int32_t ff_mlp_pack_output ( int32_t lossless_check_data , \n uint16_t blockpos , \n int32_t ( * sample_buffer ) [ MAX_CHANNELS ] , \n void * data , \n uint8_t * ch_assign , \n int8_t * output_shift , \n uint8_t max_matrix_channel , \n int is32 ) \n { \n unsigned int i , out_ch = 0 ; \n int32_t * data_32 = data ; \n int16_t * data_16 = data ; \n for ( i = 0 ; i < blockpos ; i ++ ) { \n for ( out_ch = 0 ; out_ch <= max_matrix_channel ; out_ch ++ ) { \n int mat_ch = ch_assign [ out_ch ] ; \n int32_t sample = sample_buffer [ i ] [ mat_ch ] \n << output_shift [ mat_ch ] ; \n lossless_check_data ^= ( sample & 0xffffff ) << mat_ch ; \n if ( is32 ) \n * data_32 ++ = sample << 8 ; \n else \n * data_16 ++ = sample >> 8 ; \n } \n } \n return lossless_check_data ; \n }", "idx": 4044}
{"project": "FFmpeg", "commit_id": "cc4a41727e29a52a181e3d1c1a398f1da40969c3", "target": 1, "func": "void RENAME ( swri_noise_shaping ) ( SwrContext * s , AudioData * dsts , const AudioData * srcs , const AudioData * noises , int count ) { \n int i , j , pos , ch ; \n int taps = s -> dither . ns_taps ; \n float S = s -> dither . ns_scale ; \n float S_1 = s -> dither . ns_scale_1 ; \n av_assert2 ( ( taps & 3 ) != 2 ) ; \n av_assert2 ( ( taps & 3 ) != 3 || s -> dither . ns_coeffs [ taps ] == 0 ) ; \n for ( ch = 0 ; ch < srcs -> ch_count ; ch ++ ) { \n const float * noise = ( ( const float * ) noises -> ch [ ch ] ) + s -> dither . noise_pos ; \n const DELEM * src = ( const DELEM * ) srcs -> ch [ ch ] ; \n DELEM * dst = ( DELEM * ) dsts -> ch [ ch ] ; \n float * ns_errors = s -> dither . ns_errors [ ch ] ; \n const float * ns_coeffs = s -> dither . ns_coeffs ; \n pos = s -> dither . ns_pos ; \n for ( i = 0 ; i < count ; i ++ ) { \n double d1 , d = src [ i ] * S_1 ; \n for ( j = 0 ; j < taps - 2 ; j += 4 ) { \n d -= ns_coeffs [ j ] * ns_errors [ pos + j ] \n + ns_coeffs [ j + 1 ] * ns_errors [ pos + j + 1 ] \n + ns_coeffs [ j + 2 ] * ns_errors [ pos + j + 2 ] \n + ns_coeffs [ j + 3 ] * ns_errors [ pos + j + 3 ] ; \n } \n if ( j < taps ) \n d -= ns_coeffs [ j ] * ns_errors [ pos + j ] ; \n pos = pos ? pos - 1 : taps - 1 ; \n d1 = rint ( d + noise [ i ] ) ; \n ns_errors [ pos + taps ] = ns_errors [ pos ] = d1 - d ; \n d1 *= S ; \n CLIP ( d1 ) ; \n dst [ i ] = d1 ; \n } \n } \n s -> dither . ns_pos = pos ; \n }", "idx": 4066}
{"project": "FFmpeg", "commit_id": "70df51112ccc8d281cdb96141f20b3fd8a5b11f8", "target": 1, "func": "static av_cold void uninit ( AVFilterContext * ctx ) \n { \n DynamicAudioNormalizerContext * s = ctx -> priv ; \n int c ; \n av_freep ( & s -> prev_amplification_factor ) ; \n av_freep ( & s -> dc_correction_value ) ; \n av_freep ( & s -> compress_threshold ) ; \n av_freep ( & s -> fade_factors [ 0 ] ) ; \n av_freep ( & s -> fade_factors [ 1 ] ) ; \n for ( c = 0 ; c < s -> channels ; c ++ ) { \n cqueue_free ( s -> gain_history_original [ c ] ) ; \n cqueue_free ( s -> gain_history_minimum [ c ] ) ; \n cqueue_free ( s -> gain_history_smoothed [ c ] ) ; \n } \n av_freep ( & s -> gain_history_original ) ; \n av_freep ( & s -> gain_history_minimum ) ; \n av_freep ( & s -> gain_history_smoothed ) ; \n av_freep ( & s -> weights ) ; \n ff_bufqueue_discard_all ( & s -> queue ) ; \n }", "idx": 4068}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_sequence ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFSequence * sequence = arg ; \n switch ( tag ) { \n case 0x0202 : \n sequence -> duration = avio_rb64 ( pb ) ; \n break ; \n case 0x0201 : \n avio_read ( pb , sequence -> data_definition_ul , 16 ) ; \n break ; \n case 0x1001 : \n sequence -> structural_components_count = avio_rb32 ( pb ) ; \n if ( sequence -> structural_components_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n sequence -> structural_components_refs = av_malloc ( sequence -> structural_components_count * sizeof ( UID ) ) ; \n if ( ! sequence -> structural_components_refs ) \n return -1 ; \n avio_skip ( pb , 4 ) ; \n avio_read ( pb , ( uint8_t * ) sequence -> structural_components_refs , sequence -> structural_components_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 4073}
{"project": "FFmpeg", "commit_id": "7709ce029a7bc101b9ac1ceee607cda10dcb89dc", "target": 1, "func": "void ff_compute_frame_duration ( int * pnum , int * pden , AVStream * st , \n AVCodecParserContext * pc , AVPacket * pkt ) \n { \n int frame_size ; \n * pnum = 0 ; \n * pden = 0 ; \n switch ( st -> codec -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n if ( st -> avg_frame_rate . num ) { \n * pnum = st -> avg_frame_rate . den ; \n * pden = st -> avg_frame_rate . num ; \n } else if ( st -> time_base . num * 1000LL > st -> time_base . den ) { \n * pnum = st -> time_base . num ; \n * pden = st -> time_base . den ; \n } else if ( st -> codec -> time_base . num * 1000LL > st -> codec -> time_base . den ) { \n * pnum = st -> codec -> time_base . num ; \n * pden = st -> codec -> time_base . den ; \n if ( pc && pc -> repeat_pict ) { \n * pnum = ( * pnum ) * ( 1 + pc -> repeat_pict ) ; \n } \n if ( st -> codec -> ticks_per_frame > 1 && ! pc ) { \n * pnum = * pden = 0 ; \n } \n } \n break ; \n case AVMEDIA_TYPE_AUDIO : \n frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 0 ) ; \n if ( frame_size <= 0 || st -> codec -> sample_rate <= 0 ) \n break ; \n * pnum = frame_size ; \n * pden = st -> codec -> sample_rate ; \n break ; \n default : \n break ; \n } \n }", "idx": 4075}
{"project": "FFmpeg", "commit_id": "579795b2049bc8b0f291b302e7ab24f9561eaf24", "target": 1, "func": "static int get_channel_idx ( char * * map , int * ch , char delim , int max_ch ) \n { \n char * next = split ( * map , delim ) ; \n int len ; \n int n = 0 ; \n if ( ! next && delim == ' ' ) \n len = strlen ( * map ) ; \n sscanf ( * map , \" \" , ch , & n ) ; \n if ( n != len ) \n if ( * ch < 0 || * ch > max_ch ) \n * map = next ; \n return 0 ; \n }", "idx": 4086}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "func": "static int sad8_altivec ( void * v , uint8_t * pix1 , uint8_t * pix2 , int line_size , int h ) \n { \n int i ; \n int s ; \n const vector unsigned  int zero = ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n const vector unsigned  char permclear = ( vector unsigned char ) { 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; \n vector unsigned  char perm1 = vec_lvsl ( 0 , pix1 ) ; \n vector unsigned  char perm2 = vec_lvsl ( 0 , pix2 ) ; \n vector unsigned  char t1 , t2 , t3 , t4 , t5 ; \n vector unsigned  int sad ; \n vector signed  int sumdiffs ; \n sad = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n vector unsigned  char pix1l = vec_ld ( 0 , pix1 ) ; \n vector unsigned  char pix1r = vec_ld ( 15 , pix1 ) ; \n vector unsigned  char pix2l = vec_ld ( 0 , pix2 ) ; \n vector unsigned  char pix2r = vec_ld ( 15 , pix2 ) ; \n t1 = vec_and ( vec_perm ( pix1l , pix1r , perm1 ) , permclear ) ; \n t2 = vec_and ( vec_perm ( pix2l , pix2r , perm2 ) , permclear ) ; \n t3 = vec_max ( t1 , t2 ) ; \n t4 = vec_min ( t1 , t2 ) ; \n t5 = vec_sub ( t3 , t4 ) ; \n sad = vec_sum4s ( t5 , sad ) ; \n pix1 += line_size ; \n pix2 += line_size ; \n } \n sumdiffs = vec_sums ( ( vector signed int ) sad , ( vector signed int ) zero ) ; \n sumdiffs = vec_splat ( sumdiffs , 3 ) ; \n vec_ste ( sumdiffs , 0 , & s ) ; \n return s ; \n }", "idx": 4089}
{"project": "FFmpeg", "commit_id": "34c52005605d68f7cd1957b169b6732c7d2447d9", "target": 1, "func": "static void move_audio ( vorbis_enc_context * venc , float * * audio , int * samples , int sf_size ) \n { \n AVFrame * cur = NULL ; \n int frame_size = 1 << ( venc -> log2_blocksize [ 1 ] - 1 ) ; \n int subframes = frame_size / sf_size ; \n for ( int sf = 0 ; sf < subframes ; sf ++ ) { \n cur = ff_bufqueue_get ( & venc -> bufqueue ) ; \n * samples += cur -> nb_samples ; \n for ( int ch = 0 ; ch < venc -> channels ; ch ++ ) { \n const float * input = ( float * ) cur -> extended_data [ ch ] ; \n const size_t len = cur -> nb_samples * sizeof ( float ) ; \n memcpy ( & audio [ ch ] [ sf * sf_size ] , input , len ) ; \n } \n av_frame_free ( & cur ) ; \n } \n }", "idx": 4092}
{"project": "FFmpeg", "commit_id": "06599638dd678c9939df0fd83ff693c43b25971d", "target": 0, "func": "static int decode_frame ( NUTContext * nut , AVPacket * pkt , int frame_code ) { \n AVFormatContext * s = nut -> avf ; \n ByteIOContext * bc = & s -> pb ; \n int size , stream_id , flags , discard ; \n int64_t pts , last_IP_pts ; \n size = decode_frame_header ( nut , & flags , & pts , & stream_id , frame_code ) ; \n if ( size < 0 ) \n return -1 ; \n if ( flags & FLAG_KEY ) \n nut -> stream [ stream_id ] . skip_until_key_frame = 0 ; \n discard = s -> streams [ stream_id ] -> discard ; \n last_IP_pts = s -> streams [ stream_id ] -> last_IP_pts ; \n if ( ( discard >= AVDISCARD_NONKEY && ! ( flags & FLAG_KEY ) ) \n || ( discard >= AVDISCARD_BIDIR && last_IP_pts != AV_NOPTS_VALUE && last_IP_pts > pts ) \n || discard >= AVDISCARD_ALL \n || nut -> stream [ stream_id ] . skip_until_key_frame ) { \n url_fskip ( bc , size ) ; \n return 1 ; \n } \n av_get_packet ( bc , pkt , size ) ; \n pkt -> stream_index = stream_id ; \n if ( flags & FLAG_KEY ) \n pkt -> flags |= PKT_FLAG_KEY ; \n pkt -> pts = pts ; \n return 0 ; \n }", "idx": 4110}
{"project": "FFmpeg", "commit_id": "16a75304fe42d3a007c78126b6370c94ccf891f6", "target": 0, "func": "static av_cold int find_component ( OMXContext * omx_context , void * logctx , \n const char * role , char * str , int str_size ) \n { \n OMX_U32 i , num = 0 ; \n char * * components ; \n int ret = 0 ; \n #if CONFIG_OMX_RPI  \n  \n  if ( av_strstart ( role , \" \" , NULL ) ) { \n av_strlcpy ( str , \" \" , str_size ) ; \n return 0 ; \n } \n #endif \n omx_context -> ptr_GetComponentsOfRole ( ( OMX_STRING ) role , & num , NULL ) ; \n if ( ! num ) { \n av_log ( logctx , AV_LOG_WARNING , \" \\n \" , role ) ; \n return AVERROR_ENCODER_NOT_FOUND ; \n } \n components = av_mallocz ( sizeof ( char * ) * num ) ; \n if ( ! components ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < num ; i ++ ) { \n components [ i ] = av_mallocz ( OMX_MAX_STRINGNAME_SIZE ) ; \n if ( ! components ) { \n ret = AVERROR ( ENOMEM ) ; \n goto end ; \n } \n } \n omx_context -> ptr_GetComponentsOfRole ( ( OMX_STRING ) role , & num , ( OMX_U8 * * ) components ) ; \n av_strlcpy ( str , components [ 0 ] , str_size ) ; \n end : \n for ( i = 0 ; i < num ; i ++ ) \n av_free ( components [ i ] ) ; \n av_free ( components ) ; \n return ret ; \n }", "idx": 4122}
{"project": "FFmpeg", "commit_id": "09b23786b3986502ee88d4907356979127169bdd", "target": 1, "func": "static const uint8_t * pcx_rle_decode ( const uint8_t * src , \n const uint8_t * end , \n uint8_t * dst , \n unsigned int bytes_per_scanline , \n int compressed ) \n { \n unsigned int i = 0 ; \n unsigned char run , value ; \n if ( compressed ) { \n while ( i < bytes_per_scanline && src < end ) { \n run = 1 ; \n value = * src ++ ; \n if ( value >= 0xc0 && src < end ) { \n run = value & 0x3f ; \n value = * src ++ ; \n } \n while ( i < bytes_per_scanline && run -- ) \n dst [ i ++ ] = value ; \n } \n } else { \n memcpy ( dst , src , bytes_per_scanline ) ; \n src += bytes_per_scanline ; \n } \n return src ; \n }", "idx": 4140}
{"project": "FFmpeg", "commit_id": "5a0f6b099f3e8fcb95a80e3ffe52b3bf369efe24", "target": 0, "func": "static unsigned char get_ref_idx ( AVFrame * frame ) \n { \n FrameDecodeData * fdd ; \n NVDECFrame * cf ; \n if ( ! frame || ! frame -> private_ref ) \n return 255 ; \n fdd = ( FrameDecodeData * ) frame -> private_ref -> data ; \n cf = ( NVDECFrame * ) fdd -> hwaccel_priv ; \n return cf -> idx ; \n }", "idx": 4145}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int dnxhd_encode_end ( AVCodecContext * avctx ) \n { \n DNXHDEncContext * ctx = avctx -> priv_data ; \n int max_level = 1 << ( ctx -> cid_table -> bit_depth + 2 ) ; \n int i ; \n av_free ( ctx -> vlc_codes - max_level * 2 ) ; \n av_free ( ctx -> vlc_bits - max_level * 2 ) ; \n av_freep ( & ctx -> run_codes ) ; \n av_freep ( & ctx -> run_bits ) ; \n av_freep ( & ctx -> mb_bits ) ; \n av_freep ( & ctx -> mb_qscale ) ; \n av_freep ( & ctx -> mb_rc ) ; \n av_freep ( & ctx -> mb_cmp ) ; \n av_freep ( & ctx -> slice_size ) ; \n av_freep ( & ctx -> slice_offs ) ; \n av_freep ( & ctx -> qmatrix_c ) ; \n av_freep ( & ctx -> qmatrix_l ) ; \n av_freep ( & ctx -> qmatrix_c16 ) ; \n av_freep ( & ctx -> qmatrix_l16 ) ; \n for ( i = 1 ; i < avctx -> thread_count ; i ++ ) \n av_freep ( & ctx -> thread [ i ] ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 4146}
{"project": "FFmpeg", "commit_id": "2111a191ebec422cf7781225cbcfdd69e71afce1", "target": 1, "func": "static int decode_block ( MJpegDecodeContext * s , DCTELEM * block , \n int component , int dc_index , int ac_index , int16_t * quant_matrix ) \n { \n int code , i , j , level , val ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n val = val * quant_matrix [ 0 ] + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n i = 0 ; \n { OPEN_READER ( re , & s -> gb )  \n for ( ; ; ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 )  \n if ( code == 0x10 ) \n break ; \n i += ( ( unsigned ) code ) >> 4 ; \n code &= 0xf ; \n if ( code ) { \n if ( code > MIN_CACHE_BITS - 16 ) { \n UPDATE_CACHE ( re , & s -> gb )  \n } \n { \n int cache = GET_CACHE ( re , & s -> gb ) ; \n int sign = ( ~ cache ) >> 31 ; \n level = ( NEG_USR32 ( sign ^ cache , code ) ^ sign ) - sign ; \n } \n LAST_SKIP_BITS ( re , & s -> gb , code )  \n if ( i >= 63 ) { \n if ( i == 63 ) { \n j = s -> scantable . permutated [ 63 ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n break ; \n } \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return -1 ; \n } \n j = s -> scantable . permutated [ i ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n } \n } \n CLOSE_READER ( re , & s -> gb )  } \n return 0 ; \n }", "idx": 4158}
{"project": "FFmpeg", "commit_id": "3b99e00c7549ccad90c57b5bcd6e3456650a994a", "target": 1, "func": "static int decode_ext_header ( Wmv2Context * w ) { \n MpegEncContext * const s = & w -> s ; \n GetBitContext gb ; \n int fps ; \n int code ; \n if ( s -> avctx -> extradata_size < 4 ) return -1 ; \n init_get_bits ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size * 8 ) ; \n fps = get_bits ( & gb , 5 ) ; \n s -> bit_rate = get_bits ( & gb , 11 ) * 1024 ; \n w -> mspel_bit = get_bits1 ( & gb ) ; \n s -> loop_filter = get_bits1 ( & gb ) ; \n w -> abt_flag = get_bits1 ( & gb ) ; \n w -> j_type_bit = get_bits1 ( & gb ) ; \n w -> top_left_mv_flag = get_bits1 ( & gb ) ; \n w -> per_mb_rl_bit = get_bits1 ( & gb ) ; \n code = get_bits ( & gb , 3 ) ; \n if ( code == 0 ) return -1 ; \n s -> slice_height = s -> mb_height / code ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , \n fps , s -> bit_rate , w -> mspel_bit , w -> abt_flag , w -> j_type_bit , w -> top_left_mv_flag , w -> per_mb_rl_bit , code , s -> loop_filter , \n code ) ; \n } \n return 0 ; \n }", "idx": 4160}
{"project": "FFmpeg", "commit_id": "70df51112ccc8d281cdb96141f20b3fd8a5b11f8", "target": 1, "func": "static void cqueue_free ( cqueue * q ) \n { \n av_free ( q -> elements ) ; \n av_free ( q ) ; \n }", "idx": 4164}
{"project": "FFmpeg", "commit_id": "6f37226b687f969bcf6e47a4fb5c28a32d107aa3", "target": 1, "func": "static int alloc_scratch_buffers ( H264SliceContext * sl , int linesize ) \n { \n const H264Context * h = sl -> h264 ; \n int alloc_size = FFALIGN ( FFABS ( linesize ) + 32 , 32 ) ; \n av_fast_malloc ( & sl -> bipred_scratchpad , & sl -> bipred_scratchpad_allocated , 16 * 6 * alloc_size ) ; \n av_fast_malloc ( & sl -> edge_emu_buffer , & sl -> edge_emu_buffer_allocated , alloc_size * 2 * 21 ) ; \n av_fast_malloc ( & sl -> top_borders [ 0 ] , & sl -> top_borders_allocated [ 0 ] , \n h -> mb_width * 16 * 3 * sizeof ( uint8_t ) * 2 ) ; \n av_fast_malloc ( & sl -> top_borders [ 1 ] , & sl -> top_borders_allocated [ 1 ] , \n h -> mb_width * 16 * 3 * sizeof ( uint8_t ) * 2 ) ; \n if ( ! sl -> bipred_scratchpad || ! sl -> edge_emu_buffer || \n ! sl -> top_borders [ 0 ] || ! sl -> top_borders [ 1 ] ) { \n av_freep ( & sl -> bipred_scratchpad ) ; \n av_freep ( & sl -> edge_emu_buffer ) ; \n av_freep ( & sl -> top_borders [ 0 ] ) ; \n av_freep ( & sl -> top_borders [ 1 ] ) ; \n sl -> bipred_scratchpad_allocated = 0 ; \n sl -> edge_emu_buffer_allocated = 0 ; \n sl -> top_borders_allocated [ 0 ] = 0 ; \n sl -> top_borders_allocated [ 1 ] = 0 ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 4167}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( nv21ToUV ) ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src1 , const uint8_t * src2 , \n int width , uint32_t * unused ) \n { \n RENAME ( nvXXtoUV ) ( dstV , dstU , src1 , width ) ; \n }", "idx": 4168}
{"project": "FFmpeg", "commit_id": "87638494cac0e58178a445b2c6436264b3af31e9", "target": 1, "func": "static void close_connection ( HTTPContext * c ) \n { \n HTTPContext * * cp , * c1 ; \n int i , nb_streams ; \n AVFormatContext * ctx ; \n URLContext * h ; \n AVStream * st ; \n cp = & first_http_ctx ; \n while ( ( * cp ) != NULL ) { \n c1 = * cp ; \n if ( c1 == c ) { \n * cp = c -> next ; \n } else { \n cp = & c1 -> next ; \n if ( c -> fd >= 0 ) \n close ( c -> fd ) ; \n if ( c -> fmt_in ) { \n for ( i = 0 ; i < c -> fmt_in -> nb_streams ; i ++ ) { \n st = c -> fmt_in -> streams [ i ] ; \n if ( st -> codec . codec ) { \n avcodec_close ( & st -> codec ) ; \n av_close_input_file ( c -> fmt_in ) ; \n nb_streams = 0 ; \n if ( c -> stream ) \n nb_streams = c -> stream -> nb_streams ; \n for ( i = 0 ; i < nb_streams ; i ++ ) { \n ctx = c -> rtp_ctx [ i ] ; \n if ( ctx ) { \n av_free ( ctx ) ; \n h = c -> rtp_handles [ i ] ; \n if ( h ) { \n url_close ( h ) ; \n if ( c -> stream ) \n current_bandwidth -= c -> stream -> bandwidth ; \n av_freep ( & c -> pb_buffer ) ; \n av_free ( c -> buffer ) ; \n av_free ( c ) ; \n nb_connections -- ;", "idx": 4171}
{"project": "FFmpeg", "commit_id": "4073046089f59cb6d5d46a2a2ab28f8a59b0f428", "target": 0, "func": "static int read_ir ( AVFilterLink * inlink , AVFrame * frame ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n HeadphoneContext * s = ctx -> priv ; \n int ir_len , max_ir_len , input_number ; \n for ( input_number = 0 ; input_number < s -> nb_inputs ; input_number ++ ) \n if ( inlink == ctx -> inputs [ input_number ] ) \n break ; \n av_audio_fifo_write ( s -> in [ input_number ] . fifo , ( void * * ) frame -> extended_data , \n frame -> nb_samples ) ; \n av_frame_free ( & frame ) ; \n ir_len = av_audio_fifo_size ( s -> in [ input_number ] . fifo ) ; \n max_ir_len = 65536 ; \n if ( ir_len > max_ir_len ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , ir_len , max_ir_len ) ; \n return AVERROR ( EINVAL ) ; \n } \n s -> in [ input_number ] . ir_len = ir_len ; \n s -> ir_len = FFMAX ( ir_len , s -> ir_len ) ; \n return 0 ; \n }", "idx": 4195}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static int slice_end ( AVCodecContext * avctx , AVFrame * pict ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n if ( ! s1 -> mpeg_enc_ctx_allocated || ! s -> current_picture_ptr ) \n return 0 ; \n if ( s -> avctx -> hwaccel ) { \n if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration )  \n ff_xvmc_field_end ( s ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( \n ! s -> first_field ) { \n ff_er_frame_end ( & s -> er ) ; \n ff_mpv_frame_end ( s ) ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { \n int ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ; \n if ( ret < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> current_picture_ptr ) ; \n } else { \n if ( avctx -> active_thread_type & FF_THREAD_FRAME ) \n s -> picture_number ++ ; \n if ( s -> last_picture_ptr != NULL ) { \n int ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ; \n if ( ret < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> last_picture_ptr ) ; \n } \n } \n return 1 ; \n } else { \n return 0 ; \n } \n }", "idx": 4199}
{"project": "FFmpeg", "commit_id": "7c5ce99bd92fb480b7235cbc9a005f7e6d31f1d7", "target": 1, "func": "yuv2mono_X_c_template ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , int chrFilterSize , \n const int16_t * * alpSrc , uint8_t * dest , int dstW , \n int y , enum PixelFormat target )  \n { \n const uint8_t * const d128 = dither_8x8_220 [ y & 7 ] ; \n uint8_t * g = c -> table_gU [ 128 ] + c -> table_gV [ 128 ] ; \n int i ; \n int acc = 0 ; \n for ( i = 0 ; i < dstW - 1 ; i += 2 ) { \n int j ; \n int Y1 = 1 << 18 ; \n int Y2 = 1 << 18 ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) { \n Y1 += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n Y2 += lumSrc [ j ] [ i + 1 ] * lumFilter [ j ] ; \n } \n Y1 >>= 19 ; \n Y2 >>= 19 ; \n if ( ( Y1 | Y2 ) & 0x100 ) { \n Y1 = av_clip_uint8 ( Y1 ) ; \n Y2 = av_clip_uint8 ( Y2 ) ; \n } \n acc += acc + g [ Y1 + d128 [ ( i + 0 ) & 7 ] ] ; \n acc += acc + g [ Y2 + d128 [ ( i + 1 ) & 7 ] ] ; \n if ( ( i & 7 ) == 6 ) { \n output_pixel ( * dest ++ , acc ) ; \n } \n } \n }", "idx": 4224}
{"project": "FFmpeg", "commit_id": "b7702fafb356b757dcd1b3d1ed4f2f32e4ebe9c1", "target": 1, "func": "static void avi_read_nikon ( AVFormatContext * s , uint64_t end ) \n { \n while ( avio_tell ( s -> pb ) < end ) { \n uint32_t tag = avio_rl32 ( s -> pb ) ; \n uint32_t size = avio_rl32 ( s -> pb ) ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n { \n uint64_t tag_end = avio_tell ( s -> pb ) + size ; \n while ( avio_tell ( s -> pb ) < tag_end ) { \n uint16_t tag = avio_rl16 ( s -> pb ) ; \n uint16_t size = avio_rl16 ( s -> pb ) ; \n const char * name = NULL ; \n char buffer [ 64 ] = { 0 } ; \n if ( avio_tell ( s -> pb ) + size > tag_end ) \n size = tag_end - avio_tell ( s -> pb ) ; \n size -= avio_read ( s -> pb , buffer , \n FFMIN ( size , sizeof ( buffer ) - 1 ) ) ; \n switch ( tag ) { \n case 0x03 : \n name = \" \" ; \n break ; \n case 0x04 : \n name = \" \" ; \n break ; \n case 0x13 : \n name = \" \" ; \n if ( buffer [ 4 ] == ' ' && buffer [ 7 ] == ' ' ) \n buffer [ 4 ] = buffer [ 7 ] = ' ' ; \n break ; \n } \n if ( name ) \n av_dict_set ( & s -> metadata , name , buffer , 0 ) ; \n avio_skip ( s -> pb , size ) ; \n } \n break ; \n } \n default : \n avio_skip ( s -> pb , size ) ; \n break ; \n } \n } \n }", "idx": 4226}
{"project": "FFmpeg", "commit_id": "fdbd924b84e85ac5c80f01ee059ed5c81d3cc205", "target": 1, "func": "int ff_rv34_decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n int err ; \n RV34DecContext * r = avctx -> priv_data ; \n r -> s . avctx = avctx ; \n if ( avctx -> internal -> is_copy ) { \n r -> tmp_b_block_base = NULL ; \n if ( ( err = ff_MPV_common_init ( & r -> s ) ) < 0 ) \n return err ; \n if ( ( err = rv34_decoder_alloc ( r ) ) < 0 ) \n return err ; \n } \n return 0 ; \n }", "idx": 4233}
{"project": "FFmpeg", "commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "target": 1, "func": "static int shall_we_drop ( AVFormatContext * s , int index ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n static const uint8_t dropscore [ ] = { 62 , 75 , 87 , 100 } ; \n const int ndropscores = FF_ARRAY_ELEMS ( dropscore ) ; \n unsigned int buffer_fullness = ( ctx -> curbufsize [ index ] * 100 ) / s -> max_picture_buffer ; \n if ( dropscore [ ++ ctx -> video_frame_num % ndropscores ] <= buffer_fullness ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" , index , buffer_fullness , s -> max_picture_buffer ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 4235}
{"project": "FFmpeg", "commit_id": "500220a8e84acb952e8a62d88505c5fb6a51843a", "target": 1, "func": "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) \n { \n MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ; \n int i , ret ; \n if ( avctx == avctx_from ) \n return 0 ; \n dst -> cur_index = src -> next_cur_index ; \n dst -> prev_index = src -> next_prev_index ; \n memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( dst -> frames ) ; i ++ ) { \n ff_thread_release_buffer ( avctx , & dst -> frames [ i ] ) ; \n if ( src -> frames [ i ] . f -> data [ 0 ] ) { \n ret = ff_thread_ref_frame ( & dst -> frames [ i ] , & src -> frames [ i ] ) ; \n if ( ret < 0 ) \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 4240}
{"project": "FFmpeg", "commit_id": "0d0d24af0159ff08f396ad04cd63ce5655b1fc60", "target": 1, "func": "static void parse_ptl ( HEVCContext * s , PTL * ptl , int max_num_sub_layers ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n decode_profile_tier_level ( s , & ptl -> general_ptl ) ; \n ptl -> general_ptl . level_idc = get_bits ( gb , 8 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n ptl -> sub_layer_profile_present_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> sub_layer_level_present_flag [ i ] = get_bits1 ( gb ) ; \n } \n if ( max_num_sub_layers - 1 > 0 ) \n for ( i = max_num_sub_layers - 1 ; i < 8 ; i ++ ) \n skip_bits ( gb , 2 ) ; \n for ( i = 0 ; i < max_num_sub_layers - 1 ; i ++ ) { \n if ( ptl -> sub_layer_profile_present_flag [ i ] ) \n decode_profile_tier_level ( s , & ptl -> sub_layer_ptl [ i ] ) ; \n if ( ptl -> sub_layer_level_present_flag [ i ] ) \n ptl -> sub_layer_ptl [ i ] . level_idc = get_bits ( gb , 8 ) ; \n } \n }", "idx": 4257}
{"project": "FFmpeg", "commit_id": "669bbedfa863f8a1491a186fac4238baba407037", "target": 0, "func": "void av_blowfish_crypt ( AVBlowfish * ctx , uint8_t * dst , const uint8_t * src , \n int count , uint8_t * iv , int decrypt ) \n { \n uint32_t v0 , v1 ; \n int i ; \n while ( count > 0 ) { \n if ( decrypt ) { \n v0 = AV_RB32 ( src ) ; \n v1 = AV_RB32 ( src + 4 ) ; \n av_blowfish_crypt_ecb ( ctx , & v0 , & v1 , decrypt ) ; \n AV_WB32 ( dst , v0 ) ; \n AV_WB32 ( dst + 4 , v1 ) ; \n if ( iv ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = dst [ i ] ^ iv [ i ] ; \n memcpy ( iv , src , 8 ) ; \n } \n } else { \n if ( iv ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = src [ i ] ^ iv [ i ] ; \n v0 = AV_RB32 ( dst ) ; \n v1 = AV_RB32 ( dst + 4 ) ; \n } else { \n v0 = AV_RB32 ( src ) ; \n v1 = AV_RB32 ( src + 4 ) ; \n } \n av_blowfish_crypt_ecb ( ctx , & v0 , & v1 , decrypt ) ; \n AV_WB32 ( dst , v0 ) ; \n AV_WB32 ( dst + 4 , v1 ) ; \n if ( iv ) \n memcpy ( iv , dst , 8 ) ; \n } \n src += 8 ; \n dst += 8 ; \n count -= 8 ; \n } \n }", "idx": 4259}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel16_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_16w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 16 ) ; \n }", "idx": 4261}
{"project": "FFmpeg", "commit_id": "a2f8beef2dfaee573f7c4a607afaa9e83fc2c1e0", "target": 1, "func": "static void ffm_set_write_index ( AVFormatContext * s , int64_t pos , \n int64_t file_size ) \n { \n av_opt_set_int ( s , \" \" , 1 , AV_OPT_SEARCH_CHILDREN ) ; \n av_opt_set_int ( s , \" \" , pos , AV_OPT_SEARCH_CHILDREN ) ; \n av_opt_set_int ( s , \" \" , file_size , AV_OPT_SEARCH_CHILDREN ) ; \n }", "idx": 4266}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "int ff_dirac_parse_sequence_header ( AVCodecContext * avctx , GetBitContext * gb , \n dirac_source_params * source ) \n { \n unsigned version_major ; \n unsigned video_format , picture_coding_mode ; \n version_major = svq3_get_ue_golomb ( gb ) ; \n svq3_get_ue_golomb ( gb ) ; \n avctx -> profile = svq3_get_ue_golomb ( gb ) ; \n avctx -> level = svq3_get_ue_golomb ( gb ) ; \n video_format = svq3_get_ue_golomb ( gb ) ; \n if ( version_major < 2 ) \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n else if ( version_major > 2 ) \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n if ( video_format > 20 ) \n return -1 ; \n * source = dirac_source_parameters_defaults [ video_format ] ; \n if ( parse_source_parameters ( avctx , gb , source ) ) \n return -1 ; \n if ( av_image_check_size ( source -> width , source -> height , 0 , avctx ) ) \n return -1 ; \n avcodec_set_dimensions ( avctx , source -> width , source -> height ) ; \n picture_coding_mode = svq3_get_ue_golomb ( gb ) ; \n if ( picture_coding_mode != 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" , \n picture_coding_mode ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 4267}
{"project": "FFmpeg", "commit_id": "9cf0419bb1a2cf929dcf458d435ae3c3bfb5d3ab", "target": 0, "func": "static int mov_read_moov ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n int err ; \n err = mov_read_default ( c , pb , atom ) ; \n c -> found_moov = 1 ; \n if ( c -> found_mdat ) \n return 1 ; \n return 0 ; \n }", "idx": 4274}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int xvid_ff_2pass_create ( xvid_plg_create_t * param , \n void * * handle ) { \n struct xvid_ff_pass1 * x = ( struct xvid_ff_pass1 * ) param -> param ; \n char * log = x -> context -> twopassbuffer ; \n if ( log == NULL ) \n return XVID_ERR_FAIL ; \n log [ 0 ] = 0 ; \n snprintf ( log , BUFFER_REMAINING ( log ) , \n \" \\n \" ) ; \n snprintf ( BUFFER_CAT ( log ) , BUFFER_REMAINING ( log ) , \n \" \\n \\n \" , \n XVID_VERSION_MAJOR ( XVID_VERSION ) , \n XVID_VERSION_MINOR ( XVID_VERSION ) , \n XVID_VERSION_PATCH ( XVID_VERSION ) ) ; \n * handle = x -> context ; \n return 0 ; \n }", "idx": 4285}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "int rtp_set_remote_url ( URLContext * h , const char * uri ) \n { \n RTPContext * s = h -> priv_data ; \n char hostname [ 256 ] ; \n int port ; \n char buf [ 1024 ] ; \n char path [ 1024 ] ; \n url_split ( NULL , 0 , hostname , sizeof ( hostname ) , & port , \n path , sizeof ( path ) , uri ) ; \n snprintf ( buf , sizeof ( buf ) , \" \n udp_set_remote_url ( s -> rtp_hd , buf )  ; \n snprintf ( buf , sizeof ( buf ) , \" \n udp_set_remote_url ( s -> rtcp_hd , buf )  ; \n return 0 ; \n }", "idx": 4303}
{"project": "FFmpeg", "commit_id": "5098a6f6275a57f122cd8f03e7ffbe5dd090b8e0", "target": 0, "func": "int vp78_decode_mb_row_sliced ( AVCodecContext * avctx , void * tdata , int jobnr , \n int threadnr , int is_vp7 ) \n { \n VP8Context * s = avctx -> priv_data ; \n VP8ThreadData * td = & s -> thread_data [ jobnr ] ; \n VP8ThreadData * next_td = NULL , * prev_td = NULL ; \n VP8Frame * curframe = s -> curframe ; \n int mb_y , num_jobs = s -> num_jobs ; \n int ret ; \n td -> thread_nr = threadnr ; \n for ( mb_y = jobnr ; mb_y < s -> mb_height ; mb_y += num_jobs ) { \n if ( mb_y >= s -> mb_height ) \n break ; \n td -> thread_mb_pos = mb_y << 16 ; \n ret = s -> decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr ) ; \n if ( ret < 0 ) \n return ret ; \n if ( s -> deblock_filter ) \n s -> filter_mb_row ( avctx , tdata , jobnr , threadnr ) ; \n update_pos ( td , mb_y , INT_MAX & 0xFFFF ) ; \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n if ( avctx -> active_thread_type == FF_THREAD_FRAME ) \n ff_thread_report_progress ( & curframe -> tf , mb_y , 0 ) ; \n } \n return 0 ; \n }", "idx": 4304}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avfilter_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 4305}
{"project": "FFmpeg", "commit_id": "1b648c7cdbee335c642bd2c05fe624fc195b85e6", "target": 0, "func": "static enum CodecID find_codec_or_die ( const char * name , enum AVMediaType type , int encoder ) \n { \n const char * codec_string = encoder ? \" \" : \" \" ; \n AVCodec * codec ; \n if ( ! name ) \n return CODEC_ID_NONE ; \n codec = encoder ? \n avcodec_find_encoder_by_name ( name ) : \n avcodec_find_decoder_by_name ( name ) ; \n if ( ! codec ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , codec_string , name ) ; \n exit_program ( 1 ) ; \n } \n if ( codec -> type != type ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , codec_string , name ) ; \n exit_program ( 1 ) ; \n } \n return codec -> id ; \n }", "idx": 4314}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int filter_frame ( AVFilterLink * link , AVFrame * picref ) \n { \n AVFilterContext * ctx = link -> dst ; \n IDETContext * idet = ctx -> priv ; \n if ( idet -> prev ) \n av_frame_free ( & idet -> prev ) ; \n idet -> prev = idet -> cur ; \n idet -> cur = idet -> next ; \n idet -> next = picref ; \n if ( ! idet -> cur ) \n return 0 ; \n if ( ! idet -> prev ) \n idet -> prev = av_frame_clone ( idet -> cur ) ; \n if ( ! idet -> csp ) \n idet -> csp = av_pix_fmt_desc_get ( link -> format ) ; \n if ( idet -> csp -> comp [ 0 ] . depth_minus1 / 8 == 1 ) { \n idet -> filter_line = ( ff_idet_filter_func ) ff_idet_filter_line_c_16bit ; \n if ( ARCH_X86 ) \n ff_idet_init_x86 ( idet , 1 ) ; \n } \n filter ( ctx ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , av_frame_clone ( idet -> cur ) ) ; \n }", "idx": 4342}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void fft ( AC3MDCTContext * mdct , IComplex * z , int ln ) \n { \n int j , l , np , np2 ; \n int nblocks , nloops ; \n register IComplex * p , * q ; \n int tmp_re , tmp_im ; \n np = 1 << ln ; \n for ( j = 0 ; j < np ; j ++ ) { \n int k = av_reverse [ j ] >> ( 8 - ln ) ; \n if ( k < j ) \n FFSWAP ( IComplex , z [ k ] , z [ j ] ) ; \n } \n p = & z [ 0 ] ; \n j = np >> 1 ; \n do { \n BF ( p [ 0 ] . re , p [ 0 ] . im , p [ 1 ] . re , p [ 1 ] . im , \n p [ 0 ] . re , p [ 0 ] . im , p [ 1 ] . re , p [ 1 ] . im ) ; \n p += 2 ; \n } while ( -- j ) ; \n p = & z [ 0 ] ; \n j = np >> 2 ; \n do { \n BF ( p [ 0 ] . re , p [ 0 ] . im , p [ 2 ] . re , p [ 2 ] . im , \n p [ 0 ] . re , p [ 0 ] . im , p [ 2 ] . re , p [ 2 ] . im ) ; \n BF ( p [ 1 ] . re , p [ 1 ] . im , p [ 3 ] . re , p [ 3 ] . im , \n p [ 1 ] . re , p [ 1 ] . im , p [ 3 ] . im , - p [ 3 ] . re ) ; \n p += 4 ; \n } while ( -- j ) ; \n nblocks = np >> 3 ; \n nloops = 1 << 2 ; \n np2 = np >> 1 ; \n do { \n p = z ; \n q = z + nloops ; \n for ( j = 0 ; j < nblocks ; j ++ ) { \n BF ( p -> re , p -> im , q -> re , q -> im , \n p -> re , p -> im , q -> re , q -> im ) ; \n p ++ ; \n q ++ ; \n for ( l = nblocks ; l < np2 ; l += nblocks ) { \n CMUL ( tmp_re , tmp_im , mdct -> costab [ l ] , - mdct -> sintab [ l ] , q -> re , q -> im , 15 ) ; \n BF ( p -> re , p -> im , q -> re , q -> im , \n p -> re , p -> im , tmp_re , tmp_im ) ; \n p ++ ; \n q ++ ; \n } \n p += nloops ; \n q += nloops ; \n } \n nblocks = nblocks >> 1 ; \n nloops = nloops << 1 ; \n } while ( nblocks ) ; \n }", "idx": 4347}
{"project": "FFmpeg", "commit_id": "a9f3e4b138fc14f7512fde821c051fe1ff7f124f", "target": 1, "func": "static int parse_interval ( Interval * interval , int interval_count , \n const char * * buf , void * log_ctx ) \n { \n char * intervalstr ; \n int ret ; \n * buf += strspn ( * buf , SPACES ) ; \n if ( ! * * buf ) \n return 0 ; \n memset ( interval , 0 , sizeof ( Interval ) ) ; \n interval -> index = interval_count ; \n intervalstr = av_get_token ( buf , DELIMS ) ; \n if ( intervalstr && intervalstr [ 0 ] ) { \n char * start , * end ; \n start = av_strtok ( intervalstr , \" \" , & end ) ; \n if ( ( ret = av_parse_time ( & interval -> start_ts , start , 1 ) ) < 0 ) { \n \" \\n \" , \n start , interval_count ) ; \n if ( end ) { \n if ( ( ret = av_parse_time ( & interval -> end_ts , end , 1 ) ) < 0 ) { \n \" \\n \" , \n end , interval_count ) ; \n } else { \n interval -> end_ts = INT64_MAX ; \n if ( interval -> end_ts < interval -> start_ts ) { \n \" \" \n \" \\n \" , \n end , interval_count , start ) ; \n } else { \n \" \\n \" , interval_count ) ; \n ret = parse_commands ( & interval -> commands , & interval -> nb_commands , \n interval_count , buf , log_ctx ) ; \n end : \n av_free ( intervalstr ) ; \n return ret ;", "idx": 4349}
{"project": "FFmpeg", "commit_id": "b29feec9829cfab2523c8d95e35bd69e689ea4af", "target": 1, "func": "static int ir2_decode_plane_inter ( Ir2Context * ctx , int width , int height , uint8_t * dst , \n int pitch , const uint8_t * table ) \n { \n int j ; \n int out = 0 ; \n int c ; \n int t ; \n if ( width & 1 ) \n for ( j = 0 ; j < height ; j ++ ) { \n out = 0 ; \n while ( out < width ) { \n c = ir2_get_code ( & ctx -> gb ) ; \n if ( c >= 0x80 ) { \n c -= 0x7F ; \n out += c * 2 ; \n } else { \n t = dst [ out ] + ( ( ( table [ c * 2 ] - 128 ) * 3 ) >> 2 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n t = dst [ out ] + ( ( ( table [ ( c * 2 ) + 1 ] - 128 ) * 3 ) >> 2 ) ; \n t = av_clip_uint8 ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n } \n } \n dst += pitch ; \n } \n return 0 ; \n }", "idx": 4364}
{"project": "FFmpeg", "commit_id": "ee9794ed20528c2aa4c53cf67cb218bdce6e0485", "target": 1, "func": "void av_dynarray_add ( void * tab_ptr , int * nb_ptr , void * elem ) \n { \n int nb , nb_alloc ; \n intptr_t * tab ; \n nb = * nb_ptr ; \n tab = * ( intptr_t * * ) tab_ptr ; \n if ( ( nb & ( nb - 1 ) ) == 0 ) { \n if ( nb == 0 ) \n nb_alloc = 1 ; \n else \n nb_alloc = nb * 2 ; \n tab = av_realloc ( tab , nb_alloc * sizeof ( intptr_t ) ) ; \n * ( intptr_t * * ) tab_ptr = tab ; \n } \n tab [ nb ++ ] = ( intptr_t ) elem ; \n * nb_ptr = nb ; \n }", "idx": 4369}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void write_long ( unsigned char * p , uint32_t v ) \n { \n p [ 0 ] = v >> 24 ; \n p [ 1 ] = v >> 16 ; \n p [ 2 ] = v >> 8 ; \n p [ 3 ] = v ; \n }", "idx": 4370}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static void filter_edges_16bit ( void * dst1 , void * prev1 , void * cur1 , void * next1 , \n int w , int prefs , int mrefs , int parity , int mode ) \n { \n uint16_t * dst = dst1 ; \n uint16_t * prev = prev1 ; \n uint16_t * cur = cur1 ; \n uint16_t * next = next1 ; \n int x ; \n uint16_t * prev2 = parity ? prev : cur ; \n uint16_t * next2 = parity ? cur : next ; \n mrefs /= 2 ; \n prefs /= 2 ; \n FILTER ( 0 , 3 , 0 )  \n dst = ( uint16_t * ) dst1 + w - 3 ; \n prev = ( uint16_t * ) prev1 + w - 3 ; \n cur = ( uint16_t * ) cur1 + w - 3 ; \n next = ( uint16_t * ) next1 + w - 3 ; \n prev2 = ( uint16_t * ) ( parity ? prev : cur ) ; \n next2 = ( uint16_t * ) ( parity ? cur : next ) ; \n FILTER ( w - 3 , w , 0 )  \n }", "idx": 4371}
{"project": "FFmpeg", "commit_id": "44ed34b79097b972095e7c9efae32a13b4bc51dc", "target": 1, "func": "static int avi_load_index ( AVFormatContext * s ) \n { \n AVIContext * avi = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n uint32_t tag , size ; \n int64_t pos = url_ftell ( pb ) ; \n url_fseek ( pb , avi -> movi_end , SEEK_SET ) ; \n #ifdef DEBUG_SEEK \n printf ( \" \" PRIx64 \" \\n \" , avi -> movi_end ) ; \n #endif \n for ( ; ; ) { \n if ( url_feof ( pb ) ) \n break ; \n tag = get_le32 ( pb ) ; \n size = get_le32 ( pb ) ; \n #ifdef DEBUG_SEEK \n printf ( \" \\n \" , \n tag & 0xff , \n ( tag >> 8 ) & 0xff , \n ( tag >> 16 ) & 0xff , \n ( tag >> 24 ) & 0xff , \n size ) ; \n #endif \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( avi_read_idx1 ( s , size ) < 0 ) \n goto skip ; \n else \n goto the_end ; \n break ; \n default : \n skip : \n size += ( size & 1 ) ; \n url_fskip ( pb , size ) ; \n break ; \n } \n } \n the_end : \n url_fseek ( pb , pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 4374}
{"project": "FFmpeg", "commit_id": "1f48c5c0671bb4f39c9dc3ec44c727f1680547b3", "target": 1, "func": "static char * get_content_url ( xmlNodePtr * baseurl_nodes , \n int n_baseurl_nodes , \n char * rep_id_val , \n char * rep_bandwidth_val , \n char * val ) \n { \n int i ; \n char * text ; \n char * url = NULL ; \n char tmp_str [ MAX_URL_SIZE ] ; \n char tmp_str_2 [ MAX_URL_SIZE ] ; \n memset ( tmp_str , 0 , sizeof ( tmp_str ) ) ; \n for ( i = 0 ; i < n_baseurl_nodes ; ++ i ) { \n if ( baseurl_nodes [ i ] && \n baseurl_nodes [ i ] -> children && \n baseurl_nodes [ i ] -> children -> type == XML_TEXT_NODE ) { \n text = xmlNodeGetContent ( baseurl_nodes [ i ] -> children ) ; \n if ( text ) { \n memset ( tmp_str , 0 , sizeof ( tmp_str ) ) ; \n memset ( tmp_str_2 , 0 , sizeof ( tmp_str_2 ) ) ; \n ff_make_absolute_url ( tmp_str_2 , MAX_URL_SIZE , tmp_str , text ) ; \n av_strlcpy ( tmp_str , tmp_str_2 , sizeof ( tmp_str ) ) ; \n xmlFree ( text ) ; \n } \n } \n } \n if ( val ) \n av_strlcat ( tmp_str , ( const char * ) val , sizeof ( tmp_str ) ) ; \n if ( rep_id_val ) { \n url = av_strireplace ( tmp_str , \" \" , ( const char * ) rep_id_val ) ; \n if ( ! url ) { \n return NULL ; \n } \n av_strlcpy ( tmp_str , url , sizeof ( tmp_str ) ) ; \n av_free ( url ) ; \n } \n if ( rep_bandwidth_val && tmp_str [ 0 ] != ' \\0 ' ) { \n url = av_strireplace ( tmp_str , \" \" , ( const char * ) rep_bandwidth_val ) ; \n if ( ! url ) { \n return NULL ; \n } \n } \n return url ; \n }", "idx": 4378}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_cod ( J2kDecoderContext * s , J2kCodingStyle * c , uint8_t * properties ) \n { \n J2kCodingStyle tmp ; \n int compno ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n tmp . log2_prec_width = \n tmp . log2_prec_height = 15 ; \n tmp . csty = bytestream_get_byte ( & s -> buf ) ; \n if ( bytestream_get_byte ( & s -> buf ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n tmp . nlayers = bytestream_get_be16 ( & s -> buf ) ; \n tmp . mct = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , & tmp ) ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( J2kCodingStyle ) ) ; \n } \n return 0 ; \n }", "idx": 4384}
{"project": "FFmpeg", "commit_id": "1d0ae92a259b924952856de1a5ca0dc6fd5031e5", "target": 0, "func": "static void decode_mb ( MadContext * t , int inter ) \n { \n MpegEncContext * s = & t -> s ; \n int mv_map = 0 ; \n int mv_x , mv_y ; \n int j ; \n if ( inter ) { \n int v = decode210 ( & s -> gb ) ; \n if ( v < 2 ) { \n mv_map = v ? get_bits ( & s -> gb , 6 ) : 63 ; \n mv_x = decode_motion ( & s -> gb ) ; \n mv_y = decode_motion ( & s -> gb ) ; \n } else { \n mv_map = 0 ; \n } \n } \n for ( j = 0 ; j < 6 ; j ++ ) { \n if ( mv_map & ( 1 << j ) ) { \n int add = 2 * decode_motion ( & s -> gb ) ; \n if ( t -> last_frame . data [ 0 ] ) \n comp_block ( t , s -> mb_x , s -> mb_y , j , mv_x , mv_y , add ) ; \n } else { \n s -> dsp . clear_block ( t -> block ) ; \n decode_block_intra ( t , t -> block ) ; \n idct_put ( t , t -> block , s -> mb_x , s -> mb_y , j ) ; \n } \n } \n }", "idx": 4406}
{"project": "FFmpeg", "commit_id": "cdf58f0599c39852ee3beafe5f64af7d57d4215b", "target": 0, "func": "int av_packet_copy_props ( AVPacket * dst , const AVPacket * src ) \n { \n int i ; \n dst -> pts = src -> pts ; \n dst -> dts = src -> dts ; \n dst -> pos = src -> pos ; \n dst -> duration = src -> duration ; \n dst -> convergence_duration = src -> convergence_duration ; \n dst -> flags = src -> flags ; \n dst -> stream_index = src -> stream_index ; \n dst -> side_data_elems = src -> side_data_elems ; \n for ( i = 0 ; i < src -> side_data_elems ; i ++ ) { \n enum AVPacketSideDataType type = src -> side_data [ i ] . type ; \n int size = src -> side_data [ i ] . size ; \n uint8_t * src_data = src -> side_data [ i ] . data ; \n uint8_t * dst_data = av_packet_new_side_data ( dst , type , size ) ; \n if ( ! dst_data ) { \n av_packet_free_side_data ( dst ) ; \n return AVERROR ( ENOMEM ) ; \n } \n memcpy ( dst_data , src_data , size ) ; \n } \n return 0 ; \n }", "idx": 4413}
{"project": "FFmpeg", "commit_id": "d6af26c55c1ea30f85a7d9edbc373f53be1743ee", "target": 1, "func": "static inline int get_len ( LZOContext * c , int x , int mask ) \n { \n int cnt = x & mask ; \n if ( ! cnt ) { \n while ( ! ( x = get_byte ( c ) ) ) \n cnt += 255 ; \n cnt += mask + x ; \n } \n return cnt ; \n }", "idx": 4419}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_444 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , \n uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y ; \n int width = frame -> width ; \n int ystride = frame -> linesize [ 0 ] ; \n int ustride = frame -> linesize [ 1 ] ; \n int vstride = frame -> linesize [ 2 ] ; \n uint8_t * Y = frame -> data [ 0 ] + ystride * line ; \n uint8_t * U = frame -> data [ 1 ] + ustride * line ; \n uint8_t * V = frame -> data [ 2 ] + vstride * line ; \n for ( y = 0 ; y < left && get_bits_left ( gb ) > 16 ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n Y [ x ] = decode_sym ( gb , lru [ 0 ] ) ; \n U [ x ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; \n V [ x ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; \n } \n Y += ystride ; \n U += ustride ; \n V += vstride ; \n } \n return y ; \n }", "idx": 4426}
{"project": "FFmpeg", "commit_id": "2c69fcc2ffe671649e56dc981e9f4cd9d46a61be", "target": 0, "func": "static int smacker_decode_tree ( GetBitContext * gb , HuffContext * hc , uint32_t prefix , int length ) \n { \n if ( length > 32 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ! get_bits1 ( gb ) ) { \n if ( hc -> current >= 256 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( length ) { \n hc -> bits [ hc -> current ] = prefix ; \n hc -> lengths [ hc -> current ] = length ; \n } else { \n hc -> bits [ hc -> current ] = 0 ; \n hc -> lengths [ hc -> current ] = 0 ; \n } \n hc -> values [ hc -> current ] = get_bits ( gb , 8 ) ; \n hc -> current ++ ; \n if ( hc -> maxlength < length ) \n hc -> maxlength = length ; \n return 0 ; \n } else { \n int r ; \n length ++ ; \n r = smacker_decode_tree ( gb , hc , prefix , length ) ; \n if ( r ) \n return r ; \n return smacker_decode_tree ( gb , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; \n } \n }", "idx": 4436}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "void yuv2rgb_altivec_init_tables ( SwsContext * c , const int inv_table [ 4 ] , int brightness , int contrast , int saturation ) \n { \n union { \n signed short tmp [ 8 ]  __attribute__ ( ( aligned ( 16 ) ) ) ; \n vector signed  short vec ; \n } buf ; \n buf . tmp [ 0 ] = ( ( 0xffffLL ) * contrast >> 8 ) >> 9 ; \n buf . tmp [ 1 ] = -256 * brightness ; \n buf . tmp [ 2 ] = ( inv_table [ 0 ] >> 3 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ; \n buf . tmp [ 3 ] = ( inv_table [ 1 ] >> 3 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ; \n buf . tmp [ 4 ] = - ( ( inv_table [ 2 ] >> 1 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ) ; \n buf . tmp [ 5 ] = - ( ( inv_table [ 3 ] >> 1 ) * ( contrast >> 16 ) * ( saturation >> 16 ) ) ; \n c -> CSHIFT = ( vector unsigned short ) vec_splat_u16 ( 2 ) ; \n c -> CY = vec_splat ( ( vector signed short ) buf . vec , 0 ) ; \n c -> OY = vec_splat ( ( vector signed short ) buf . vec , 1 ) ; \n c -> CRV = vec_splat ( ( vector signed short ) buf . vec , 2 ) ; \n c -> CBU = vec_splat ( ( vector signed short ) buf . vec , 3 ) ; \n c -> CGU = vec_splat ( ( vector signed short ) buf . vec , 4 ) ; \n c -> CGV = vec_splat ( ( vector signed short ) buf . vec , 5 ) ; \n #if 0  \n  \n  { \n int i ; \n char * v [ 6 ] = { \" \" , \" \" , \" \" , \" \" , \" \" , \" \" } ; \n for ( i = 0 ; i < 6 ; i ++ ) \n printf ( \" \" , v [ i ] , buf . tmp [ i ] ) ; \n printf ( \" \\n \" ) ; \n } \n #endif \n return ; \n }", "idx": 4468}
{"project": "FFmpeg", "commit_id": "5e6ce28dabe002a6130f17b59c454bdee33088f7", "target": 0, "func": "static void read_xing_toc ( AVFormatContext * s , int64_t filesize , int64_t duration ) \n { \n int i ; \n MP3DecContext * mp3 = s -> priv_data ; \n int fill_index = mp3 -> usetoc == 1 && duration > 0 ; \n if ( ! filesize && \n ! ( filesize = avio_size ( s -> pb ) ) ) { \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n fill_index = 0 ; \n } \n for ( i = 0 ; i < XING_TOC_COUNT ; i ++ ) { \n uint8_t b = avio_r8 ( s -> pb ) ; \n if ( fill_index ) \n av_add_index_entry ( s -> streams [ 0 ] , \n av_rescale ( b , filesize , 256 ) , \n av_rescale ( i , duration , XING_TOC_COUNT ) , \n 0 , 0 , AVINDEX_KEYFRAME ) ; \n } \n if ( fill_index ) \n mp3 -> xing_toc = 1 ; \n }", "idx": 4475}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_put_h264_qpel8_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n copy_width8_msa ( src , stride , dst , stride , 8 ) ; \n }", "idx": 4476}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv30_decode_mb_info ( RV34DecContext * r ) \n { \n static const int rv30_p_types [ 6 ] = { RV34_MB_SKIP , RV34_MB_P_16x16 , RV34_MB_P_8x8 , -1 , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 } ; \n static const int rv30_b_types [ 6 ] = { RV34_MB_SKIP , RV34_MB_B_DIRECT , RV34_MB_B_FORWARD , RV34_MB_B_BACKWARD , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 } ; \n MpegEncContext * s = & r -> s ; \n GetBitContext * gb = & s -> gb ; \n int code = svq3_get_ue_golomb ( gb ) ; \n if ( code > 11 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( code > 5 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n code -= 6 ; \n } \n if ( s -> pict_type != AV_PICTURE_TYPE_B ) \n return rv30_p_types [ code ] ; \n else \n return rv30_b_types [ code ] ; \n }", "idx": 4502}
{"project": "FFmpeg", "commit_id": "e701cd96c2d5dc034e7615967d208db3d953e111", "target": 0, "func": "unsigned avutil_version ( void ) \n { \n av_assert0 ( AV_PIX_FMT_VDA_VLD == 81 ) ; \n av_assert0 ( AV_SAMPLE_FMT_DBLP == 9 ) ; \n av_assert0 ( AVMEDIA_TYPE_ATTACHMENT == 4 ) ; \n av_assert0 ( AV_PICTURE_TYPE_BI == 7 ) ; \n av_assert0 ( LIBAVUTIL_VERSION_MICRO >= 100 ) ; \n av_assert0 ( HAVE_MMX2 == HAVE_MMXEXT ) ; \n if ( av_sat_dadd32 ( 1 , 2 ) != 5 ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n abort ( ) ; \n } \n ff_check_pixfmt_descriptors ( ) ; \n return LIBAVUTIL_VERSION_INT ; \n }", "idx": 4512}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static int start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TileContext * tile = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n if ( tile -> current ) \n return 0 ; \n outlink -> out_buf = ff_get_video_buffer ( outlink , AV_PERM_WRITE , \n outlink -> w , outlink -> h ) ; \n avfilter_copy_buffer_ref_props ( outlink -> out_buf , picref ) ; \n outlink -> out_buf -> video -> w = outlink -> w ; \n outlink -> out_buf -> video -> h = outlink -> h ; \n if ( tile -> margin || tile -> padding ) \n ff_fill_rectangle ( & tile -> draw , & tile -> blank , \n outlink -> out_buf -> data , outlink -> out_buf -> linesize , \n 0 , 0 , outlink -> w , outlink -> h ) ; \n return 0 ; \n }", "idx": 4523}
{"project": "FFmpeg", "commit_id": "8c55ff393340998faae887dfac19e7ef128e1e58", "target": 0, "func": "static int output_frame ( H264Context * h , AVFrame * dst , Picture * srcp ) \n { \n AVFrame * src = & srcp -> f ; \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n av_dict_set ( & dst -> metadata , \" \" , ff_h264_sei_stereo_mode ( h ) , 0 ) ; \n if ( ! srcp -> crop ) \n return 0 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int hshift = ( i > 0 ) ? h -> chroma_x_shift : 0 ; \n int vshift = ( i > 0 ) ? h -> chroma_y_shift : 0 ; \n int off = ( ( srcp -> crop_left >> hshift ) << h -> pixel_shift ) + \n ( srcp -> crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 4527}
{"project": "FFmpeg", "commit_id": "0c1959b056f6ccaa2eee2c824352ba93c8e36d52", "target": 0, "func": "static int flac_write_header ( struct AVFormatContext * s ) \n { \n int ret ; \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n FlacMuxerContext * c = s -> priv_data ; \n if ( ! c -> write_header ) \n return 0 ; \n ret = ff_flac_write_header ( s -> pb , codec , 0 ) ; \n if ( ret ) \n return ret ; \n ret = flac_write_block_comment ( s -> pb , & s -> metadata , 0 , \n codec -> flags & CODEC_FLAG_BITEXACT ) ; \n if ( ret ) \n return ret ; \n flac_write_block_padding ( s -> pb , 8192 , 1 ) ; \n return ret ; \n }", "idx": 4528}
{"project": "FFmpeg", "commit_id": "ffcc82219cef0928bed2d558b19ef6ea35634130", "target": 0, "func": "int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , \n const uint8_t * name , uint8_t * dst , int dst_size ) \n { \n int namelen = strlen ( name ) ; \n int len ; \n while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { \n len = ff_amf_tag_size ( data , data_end ) ; \n if ( len < 0 ) \n len = data_end - data ; \n data += len ; \n } \n if ( data_end - data < 3 ) \n return -1 ; \n data ++ ; \n for ( ; ; ) { \n int size = bytestream_get_be16 ( & data ) ; \n if ( ! size ) \n break ; \n if ( size < 0 || size >= data_end - data ) \n return -1 ; \n data += size ; \n if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { \n switch ( * data ++ ) { \n case AMF_DATA_TYPE_NUMBER : \n snprintf ( dst , dst_size , \" \" , av_int2double ( AV_RB64 ( data ) ) ) ; \n break ; \n case AMF_DATA_TYPE_BOOL : \n snprintf ( dst , dst_size , \" \" , * data ? \" \" : \" \" ) ; \n break ; \n case AMF_DATA_TYPE_STRING : \n len = bytestream_get_be16 ( & data ) ; \n av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; \n break ; \n default : \n return -1 ; \n } \n return 0 ; \n } \n len = ff_amf_tag_size ( data , data_end ) ; \n if ( len < 0 || len >= data_end - data ) \n return -1 ; \n data += len ; \n } \n return -1 ; \n }", "idx": 4543}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 16 ) ; \n }", "idx": 4577}
{"project": "FFmpeg", "commit_id": "e91ba2efa949470e9157b652535d207a101f91e0", "target": 0, "func": "static void svq1_parse_string ( GetBitContext * bitbuf , uint8_t * out ) \n { \n uint8_t seed ; \n int i ; \n out [ 0 ] = get_bits ( bitbuf , 8 ) ; \n seed = string_table [ out [ 0 ] ] ; \n for ( i = 1 ; i <= out [ 0 ] ; i ++ ) { \n out [ i ] = get_bits ( bitbuf , 8 ) ^ seed ; \n seed = string_table [ out [ i ] ^ seed ] ; \n } \n }", "idx": 4585}
{"project": "FFmpeg", "commit_id": "80f955c90867561dcce769216bc497e13281eb38", "target": 0, "func": "static int vda_h264_end_frame ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n VDAContext * vda = avctx -> internal -> hwaccel_priv_data ; \n AVVDAContext * vda_ctx = avctx -> hwaccel_context ; \n AVFrame * frame = h -> cur_pic_ptr -> f ; \n uint32_t flush_flags = 1 << 0 ; \n CFDataRef coded_frame ; \n OSStatus status ; \n if ( ! vda -> bitstream_size ) \n return AVERROR_INVALIDDATA ; \n coded_frame = CFDataCreate ( kCFAllocatorDefault , \n vda -> bitstream , \n vda -> bitstream_size ) ; \n status = VDADecoderDecode ( vda_ctx -> decoder , 0 , coded_frame , NULL ) ; \n if ( status == kVDADecoderNoErr ) \n status = VDADecoderFlush ( vda_ctx -> decoder , flush_flags ) ; \n CFRelease ( coded_frame ) ; \n if ( ! vda -> frame ) \n return AVERROR_UNKNOWN ; \n if ( status != kVDADecoderNoErr ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , status ) ; \n return AVERROR_UNKNOWN ; \n } \n av_buffer_unref ( & frame -> buf [ 0 ] ) ; \n frame -> buf [ 0 ] = av_buffer_create ( ( uint8_t * ) vda -> frame , \n sizeof ( vda -> frame ) , \n release_buffer , NULL , \n AV_BUFFER_FLAG_READONLY ) ; \n if ( ! frame -> buf ) \n return AVERROR ( ENOMEM ) ; \n frame -> data [ 3 ] = ( uint8_t * ) vda -> frame ; \n vda -> frame = NULL ; \n return 0 ; \n }", "idx": 4586}
{"project": "FFmpeg", "commit_id": "19dc71045d2833d2b3b77648608687eb687b4af1", "target": 0, "func": "void avfilter_draw_slice ( AVFilterLink * link , int y , int h ) \n { \n uint8_t * src [ 4 ] , * dst [ 4 ] ; \n int i , j , hsub , vsub ; \n if ( link -> srcpic ) { \n avcodec_get_chroma_sub_sample ( link -> format , & hsub , & vsub ) ; \n src [ 0 ] = link -> srcpic -> data [ 0 ] + y * link -> srcpic -> linesize [ 0 ] ; \n dst [ 0 ] = link -> cur_pic -> data [ 0 ] + y * link -> cur_pic -> linesize [ 0 ] ; \n for ( i = 1 ; i < 4 ; i ++ ) { \n if ( link -> srcpic -> data [ i ] ) { \n src [ i ] = link -> srcpic -> data [ i ] + ( y >> vsub ) * link -> srcpic -> linesize [ i ] ; \n dst [ i ] = link -> cur_pic -> data [ i ] + ( y >> vsub ) * link -> cur_pic -> linesize [ i ] ; \n } else \n src [ i ] = dst [ i ] = NULL ; \n } \n for ( j = 0 ; j < h ; j ++ ) { \n memcpy ( dst [ 0 ] , src [ 0 ] , link -> cur_pic -> linesize [ 0 ] ) ; \n src [ 0 ] += link -> srcpic -> linesize [ 0 ] ; \n dst [ 0 ] += link -> cur_pic -> linesize [ 0 ] ; \n } \n for ( i = 1 ; i < 4 ; i ++ ) { \n if ( ! src [ i ] ) continue ; \n for ( j = 0 ; j < h >> vsub ; j ++ ) { \n memcpy ( dst [ i ] , src [ i ] , link -> cur_pic -> linesize [ i ] ) ; \n src [ i ] += link -> srcpic -> linesize [ i ] ; \n dst [ i ] += link -> cur_pic -> linesize [ i ] ; \n } \n } \n } \n if ( ! link_dpad ( link ) . draw_slice ) \n return ; \n link_dpad ( link ) . draw_slice ( link , y , h ) ; \n }", "idx": 4588}
{"project": "FFmpeg", "commit_id": "8ef98855d25e457094468e2e1a79d9b10d6445b2", "target": 0, "func": "static int ff_sctp_send ( int s , const void * msg , size_t len , \n const struct sctp_sndrcvinfo * sinfo , int flags ) \n { \n struct msghdr outmsg ; \n struct iovec iov ; \n outmsg . msg_name = NULL ; \n outmsg . msg_namelen = 0 ; \n outmsg . msg_iov = & iov ; \n iov . iov_base = msg ; \n iov . iov_len = len ; \n outmsg . msg_iovlen = 1 ; \n outmsg . msg_controllen = 0 ; \n if ( sinfo ) { \n char outcmsg [ CMSG_SPACE ( sizeof ( struct sctp_sndrcvinfo ) ) ] ; \n struct cmsghdr * cmsg ; \n outmsg . msg_control = outcmsg ; \n outmsg . msg_controllen = sizeof ( outcmsg ) ; \n outmsg . msg_flags = 0 ; \n cmsg = CMSG_FIRSTHDR ( & outmsg ) ; \n cmsg -> cmsg_level = IPPROTO_SCTP ; \n cmsg -> cmsg_type = SCTP_SNDRCV ; \n cmsg -> cmsg_len = CMSG_LEN ( sizeof ( struct sctp_sndrcvinfo ) ) ; \n outmsg . msg_controllen = cmsg -> cmsg_len ; \n memcpy ( CMSG_DATA ( cmsg ) , sinfo , sizeof ( struct sctp_sndrcvinfo ) ) ; \n } \n return sendmsg ( s , & outmsg , flags | MSG_NOSIGNAL ) ; \n }", "idx": 4589}
{"project": "FFmpeg", "commit_id": "9caa9414ccf2dcf8aee2695377dee830a5024c82", "target": 0, "func": "static int dxtory_decode_v1_420 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 3LL / 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 2 ) { \n for ( w = 0 ; w < avctx -> width ; w += 2 ) { \n AV_COPY16 ( Y1 + w , src ) ; \n AV_COPY16 ( Y2 + w , src + 2 ) ; \n U [ w >> 1 ] = src [ 4 ] + 0x80 ; \n V [ w >> 1 ] = src [ 5 ] + 0x80 ; \n src += 6 ; \n } \n Y1 += pic -> linesize [ 0 ] << 1 ; \n Y2 += pic -> linesize [ 0 ] << 1 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 4590}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_16x16_msa ( src + stride - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 4591}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_h_loop_filter_c ( uint8_t * first_pixel , int stride , int * bounding_values ) \n { \n unsigned char * end ; \n int filter_value ; \n for ( end = first_pixel + 8 * stride ; first_pixel != end ; first_pixel += stride ) { \n filter_value = \n ( first_pixel [ -2 ] - first_pixel [ 1 ] ) \n + 3 * ( first_pixel [ 0 ] - first_pixel [ -1 ] ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ -1 ] = av_clip_uint8 ( first_pixel [ -1 ] + filter_value ) ; \n first_pixel [ 0 ] = av_clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 4621}
{"project": "FFmpeg", "commit_id": "63736fe48c30c5db313c3a25d1462ad31b2a1671", "target": 0, "func": "int ff_avfilter_graph_config_formats ( AVFilterGraph * graph , AVClass * log_ctx ) \n { \n int ret ; \n if ( ( ret = query_formats ( graph , log_ctx ) ) < 0 ) \n return ret ; \n pick_formats ( graph ) ; \n return 0 ; \n }", "idx": 4651}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_midh_qrt_8w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height , uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_4w_msa ( src , src_stride , dst , dst_stride , height , \n horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 4652}
{"project": "FFmpeg", "commit_id": "127a362630e11fe724e2e63fc871791fdcbcfa64", "target": 1, "func": "static void mpeg_er_decode_mb ( void * opaque , int ref , int mv_dir , int mv_type , \n int ( * mv ) [ 2 ] [ 4 ] [ 2 ] , int mb_x , int mb_y , \n int mb_intra , int mb_skipped ) \n { \n MpegEncContext * s = opaque ; \n s -> mv_dir = mv_dir ; \n s -> mv_type = mv_type ; \n s -> mb_intra = mb_intra ; \n s -> mb_skipped = mb_skipped ; \n s -> mb_x = mb_x ; \n s -> mb_y = mb_y ; \n memcpy ( s -> mv , mv , sizeof ( * mv ) ) ; \n ff_init_block_index ( s ) ; \n ff_update_block_index ( s ) ; \n s -> bdsp . clear_blocks ( s -> block [ 0 ] ) ; \n s -> dest [ 0 ] = s -> current_picture . f -> data [ 0 ] + \n s -> mb_y * 16 * s -> linesize + \n s -> mb_x * 16 ; \n s -> dest [ 1 ] = s -> current_picture . f -> data [ 1 ] + \n s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize + \n s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n s -> dest [ 2 ] = s -> current_picture . f -> data [ 2 ] + \n s -> mb_y * ( 16 >> s -> chroma_y_shift ) * s -> uvlinesize + \n s -> mb_x * ( 16 >> s -> chroma_x_shift ) ; \n if ( ref ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \n \" \\n \" ) ; \n ff_mpv_reconstruct_mb ( s , s -> block ) ; \n }", "idx": 4656}
{"project": "FFmpeg", "commit_id": "15d7e31dcb68f30ebd725c495a191d5917a3b602", "target": 1, "func": "static int video_open ( VideoState * is ) \n { \n int w , h ; \n if ( screen_width ) { \n w = screen_width ; \n h = screen_height ; \n } else { \n w = default_width ; \n h = default_height ; \n } \n if ( ! window ) { \n int flags = SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE ; \n if ( ! window_title ) \n window_title = input_filename ; \n if ( is_full_screen ) \n flags |= SDL_WINDOW_FULLSCREEN_DESKTOP ; \n window = SDL_CreateWindow ( window_title , SDL_WINDOWPOS_UNDEFINED , SDL_WINDOWPOS_UNDEFINED , w , h , flags ) ; \n SDL_SetHint ( SDL_HINT_RENDER_SCALE_QUALITY , \" \" ) ; \n if ( window ) { \n SDL_RendererInfo info ; \n renderer = SDL_CreateRenderer ( window , -1 , SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC ) ; \n if ( ! renderer ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , SDL_GetError ( ) ) ; \n renderer = SDL_CreateRenderer ( window , -1 , 0 ) ; \n } \n if ( renderer ) { \n if ( ! SDL_GetRendererInfo ( renderer , & info ) ) \n av_log ( NULL , AV_LOG_VERBOSE , \" \\n \" , info . name ) ; \n } \n } \n } else { \n SDL_SetWindowSize ( window , w , h ) ; \n } \n if ( ! window || ! renderer ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n do_exit ( is ) ; \n } \n is -> width = w ; \n is -> height = h ; \n return 0 ; \n }", "idx": 4661}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_129_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( ( 1 << ( BIT_DEPTH - 1 ) ) + 1 ) ; \n }", "idx": 4662}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_cryptographic_context ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFCryptoContext * cryptocontext = arg ; \n if ( size != 16 ) \n return -1 ; \n if ( IS_KLV_KEY ( uid , mxf_crypto_source_container_ul ) ) \n avio_read ( pb , cryptocontext -> source_container_ul , 16 ) ; \n return 0 ; \n }", "idx": 4672}
{"project": "FFmpeg", "commit_id": "e2ad0b66fa273c5c823978e8f601f2c0d9ee42f8", "target": 0, "func": "int avpicture_layout ( const AVPicture * src , enum AVPixelFormat pix_fmt , \n int width , int height , \n unsigned char * dest , int dest_size ) \n { \n int i , j , nb_planes = 0 , linesizes [ 4 ] ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n int size = avpicture_get_size ( pix_fmt , width , height ) ; \n if ( size > dest_size || size < 0 ) \n return AVERROR ( EINVAL ) ; \n for ( i = 0 ; i < desc -> nb_components ; i ++ ) \n nb_planes = FFMAX ( desc -> comp [ i ] . plane , nb_planes ) ; \n nb_planes ++ ; \n av_image_fill_linesizes ( linesizes , pix_fmt , width ) ; \n for ( i = 0 ; i < nb_planes ; i ++ ) { \n int h , shift = ( i == 1 || i == 2 ) ? desc -> log2_chroma_h : 0 ; \n const unsigned char * s = src -> data [ i ] ; \n h = ( height + ( 1 << shift ) - 1 ) >> shift ; \n for ( j = 0 ; j < h ; j ++ ) { \n memcpy ( dest , s , linesizes [ i ] ) ; \n dest += linesizes [ i ] ; \n s += src -> linesize [ i ] ; \n } \n } \n if ( desc -> flags & AV_PIX_FMT_FLAG_PAL ) \n memcpy ( ( unsigned char * ) ( ( ( size_t ) dest + 3 ) & ~ 3 ) , \n src -> data [ 1 ] , 256 * 4 ) ; \n return size ; \n }", "idx": 4677}
{"project": "FFmpeg", "commit_id": "05d00e953f4cc08273fbb5f795f4fdc307140108", "target": 0, "func": "static int pipe_open ( URLContext * h , const char * filename , int flags ) \n { \n int fd ; \n if ( flags & URL_WRONLY ) { \n fd = 1 ; \n } else { \n fd = 0 ; \n } \n #if defined ( __MINGW32__ ) || defined ( CONFIG_OS2 ) || defined ( __CYGWIN__ )  \n  \n  setmode ( fd , O_BINARY ) ; \n #endif \n h -> priv_data = ( void * ) ( size_t ) fd ; \n h -> is_streamed = 1 ; \n return 0 ; \n }", "idx": 4678}
{"project": "FFmpeg", "commit_id": "5fba300d02f693de3c741e07740a851b2b3a94c7", "target": 0, "func": "static void dump_stream_format ( AVFormatContext * ic , int i , int index , int is_output ) \n { \n char buf [ 256 ] ; \n int flags = ( is_output ? ic -> oformat -> flags : ic -> iformat -> flags ) ; \n AVStream * st = ic -> streams [ i ] ; \n int g = ff_gcd ( st -> time_base . num , st -> time_base . den ) ; \n avcodec_string ( buf , sizeof ( buf ) , st -> codec , is_output ) ; \n av_log ( NULL , AV_LOG_INFO , \" \" , index , i ) ; \n if ( flags & AVFMT_SHOW_IDS ) \n av_log ( NULL , AV_LOG_INFO , \" \" , st -> id ) ; \n if ( strlen ( st -> language ) > 0 ) \n av_log ( NULL , AV_LOG_INFO , \" \" , st -> language ) ; \n av_log ( NULL , AV_LOG_DEBUG , \" \" , st -> time_base . num / g , st -> time_base . den / g ) ; \n av_log ( NULL , AV_LOG_INFO , \" \" , buf ) ; \n if ( st -> codec -> codec_type == CODEC_TYPE_VIDEO ) { \n if ( st -> r_frame_rate . den && st -> r_frame_rate . num ) \n av_log ( NULL , AV_LOG_INFO , \" \" , av_q2d ( st -> r_frame_rate ) ) ; \n else \n av_log ( NULL , AV_LOG_INFO , \" \" , 1 / av_q2d ( st -> codec -> time_base ) ) ; \n } \n av_log ( NULL , AV_LOG_INFO , \" \\n \" ) ; \n }", "idx": 4684}
{"project": "FFmpeg", "commit_id": "3faa303a47e0c3b59a53988e0f76018930c6cb1a", "target": 0, "func": "static inline void rv34_decode_block ( DCTELEM * dst , GetBitContext * gb , RV34VLC * rvlc , int fc , int sc , int q_dc , int q_ac1 , int q_ac2 ) \n { \n int code , pattern ; \n code = get_vlc2 ( gb , rvlc -> first_pattern [ fc ] . table , 9 , 2 ) ; \n pattern = code & 0x7 ; \n code >>= 3 ; \n decode_subblock3 ( dst , code , 0 , gb , & rvlc -> coefficient , q_dc , q_ac1 , q_ac2 ) ; \n if ( pattern & 4 ) { \n code = get_vlc2 ( gb , rvlc -> second_pattern [ sc ] . table , 9 , 2 ) ; \n decode_subblock ( dst + 2 , code , 0 , gb , & rvlc -> coefficient , q_ac2 ) ; \n } \n if ( pattern & 2 ) { \n code = get_vlc2 ( gb , rvlc -> second_pattern [ sc ] . table , 9 , 2 ) ; \n decode_subblock ( dst + 8 * 2 , code , 1 , gb , & rvlc -> coefficient , q_ac2 ) ; \n } \n if ( pattern & 1 ) { \n code = get_vlc2 ( gb , rvlc -> third_pattern [ sc ] . table , 9 , 2 ) ; \n decode_subblock ( dst + 8 * 2 + 2 , code , 0 , gb , & rvlc -> coefficient , q_ac2 ) ; \n } \n }", "idx": 4687}
{"project": "FFmpeg", "commit_id": "5804201cbac2de8824013a8294e381e93bbe45f2", "target": 1, "func": "AVFrameSideData * av_frame_new_side_data ( AVFrame * frame , \n enum AVFrameSideDataType type , \n int size ) \n { \n AVFrameSideData * ret , * * tmp ; \n if ( frame -> nb_side_data > INT_MAX / sizeof ( * frame -> side_data ) - 1 ) \n return NULL ; \n tmp = av_realloc ( frame -> side_data , \n ( frame -> nb_side_data + 1 ) * sizeof ( * frame -> side_data ) ) ; \n if ( ! tmp ) \n return NULL ; \n frame -> side_data = tmp ; \n ret = av_mallocz ( sizeof ( * ret ) ) ; \n if ( ! ret ) \n return NULL ; \n if ( size > 0 ) { \n ret -> buf = av_buffer_alloc ( size ) ; \n if ( ! ret -> buf ) { \n av_freep ( & ret ) ; \n return NULL ; \n } \n ret -> data = ret -> buf -> data ; \n ret -> size = size ; \n } \n ret -> type = type ; \n frame -> side_data [ frame -> nb_side_data ++ ] = ret ; \n return ret ; \n }", "idx": 4689}
{"project": "FFmpeg", "commit_id": "29fb49194bedc74ac9be0b49b6b42dcfeb6222d9", "target": 0, "func": "void av_force_cpu_flags ( int arg ) { \n if ( ( arg & ( AV_CPU_FLAG_3DNOW | \n AV_CPU_FLAG_3DNOWEXT | \n AV_CPU_FLAG_MMXEXT | \n AV_CPU_FLAG_SSE | \n AV_CPU_FLAG_SSE2 | \n AV_CPU_FLAG_SSE2SLOW | \n AV_CPU_FLAG_SSE3 | \n AV_CPU_FLAG_SSE3SLOW | \n AV_CPU_FLAG_SSSE3 | \n AV_CPU_FLAG_SSE4 | \n AV_CPU_FLAG_SSE42 | \n AV_CPU_FLAG_AVX | \n AV_CPU_FLAG_AVXSLOW | \n AV_CPU_FLAG_XOP | \n AV_CPU_FLAG_FMA3 | \n AV_CPU_FLAG_FMA4 | \n AV_CPU_FLAG_AVX2 ) ) \n && ! ( arg & AV_CPU_FLAG_MMX ) ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n arg |= AV_CPU_FLAG_MMX ; \n } \n flags = arg ; \n checked = arg != -1 ; \n }", "idx": 4699}
{"project": "FFmpeg", "commit_id": "ed2112fb36d7407d960b4f44475a700a7c44344c", "target": 0, "func": "static int mov_write_identification ( AVIOContext * pb , AVFormatContext * s ) \n { \n MOVMuxContext * mov = s -> priv_data ; \n int i ; \n mov_write_ftyp_tag ( pb , s ) ; \n if ( mov -> mode == MODE_PSP ) { \n int video_streams_nb = 0 , audio_streams_nb = 0 , other_streams_nb = 0 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) \n video_streams_nb ++ ; \n else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) \n audio_streams_nb ++ ; \n else \n other_streams_nb ++ ; \n } \n if ( video_streams_nb != 1 || audio_streams_nb != 1 || other_streams_nb ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n mov_write_uuidprof_tag ( pb , s ) ; \n } \n return 0 ; \n }", "idx": 4702}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int motion_inter_block ( bit_buffer_t * bitbuf , \n uint8_t * current , uint8_t * previous , int pitch , \n svq1_pmv_t * motion , int x , int y ) { \n uint8_t * src ; \n uint8_t * dst ; \n svq1_pmv_t mv ; \n svq1_pmv_t * pmv [ 3 ] ; \n int result ; \n pmv [ 0 ] = & motion [ 0 ] ; \n pmv [ 1 ] = & motion [ ( x / 8 ) + 2 ] ; \n pmv [ 2 ] = & motion [ ( x / 8 ) + 4 ] ; \n if ( y == 0 ) { \n pmv [ 1 ] = pmv [ 0 ] ; \n pmv [ 2 ] = pmv [ 0 ] ; \n } \n result = decode_motion_vector ( bitbuf , & mv , pmv ) ; \n if ( result != 0 ) \n return result ; \n motion [ 0 ] . x = mv . x ; \n motion [ 0 ] . y = mv . y ; \n motion [ ( x / 8 ) + 2 ] . x = mv . x ; \n motion [ ( x / 8 ) + 2 ] . y = mv . y ; \n motion [ ( x / 8 ) + 3 ] . x = mv . x ; \n motion [ ( x / 8 ) + 3 ] . y = mv . y ; \n src = & previous [ ( x + ( mv . x >> 1 ) ) + ( y + ( mv . y >> 1 ) ) * pitch ] ; \n dst = current ; \n put_pixels_tab [ ( ( mv . y & 1 ) << 1 ) | ( mv . x & 1 ) ] ( dst , src , pitch , 16 ) ; \n put_pixels_tab [ ( ( mv . y & 1 ) << 1 ) | ( mv . x & 1 ) ] ( dst + 8 , src + 8 , pitch , 16 ) ; \n return 0 ; \n }", "idx": 4707}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static int swf_write_video ( AVFormatContext * s , \n AVCodecContext * enc , const uint8_t * buf , int size ) \n { \n ByteIOContext * pb = & s -> pb ; \n static int tag_id = 0 ; \n if ( enc -> frame_number > 1 ) { \n put_swf_tag ( s , TAG_REMOVEOBJECT ) ; \n put_le16 ( pb , SHAPE_ID ) ; \n put_le16 ( pb , 1 ) ; \n put_swf_end_tag ( s ) ; \n put_swf_tag ( s , TAG_FREECHARACTER ) ; \n put_le16 ( pb , BITMAP_ID ) ; \n put_swf_end_tag ( s ) ; \n } \n put_swf_tag ( s , TAG_JPEG2 | TAG_LONG ) ; \n put_le16 ( pb , tag_id ) ; \n put_byte ( pb , 0xff ) ; \n put_byte ( pb , 0xd8 ) ; \n put_byte ( pb , 0xff ) ; \n put_byte ( pb , 0xd9 ) ; \n put_buffer ( pb , buf , size ) ; \n put_swf_end_tag ( s ) ; \n put_swf_tag ( s , TAG_PLACEOBJECT ) ; \n put_le16 ( pb , SHAPE_ID ) ; \n put_le16 ( pb , 1 ) ; \n put_swf_matrix ( pb , 1 << FRAC_BITS , 0 , 0 , 1 << FRAC_BITS , 0 , 0 ) ; \n put_swf_end_tag ( s ) ; \n put_swf_tag ( s , TAG_SHOWFRAME ) ; \n put_swf_end_tag ( s ) ; \n put_flush_packet ( & s -> pb ) ; \n return 0 ; \n }", "idx": 4730}
{"project": "FFmpeg", "commit_id": "a9f3bb14ba8b303cf87c42b8fe7e423571176d54", "target": 1, "func": "static int mov_skip_multiple_stsd ( MOVContext * c , AVIOContext * pb , \n int codec_tag , int format , \n int size ) \n { \n int video_codec_id = ff_codec_get_id ( ff_codec_movvideo_tags , format ) ; \n if ( codec_tag && \n ( codec_tag != format && \n ( c -> fc -> video_codec_id ? video_codec_id != c -> fc -> video_codec_id \n : codec_tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ) ) { \n av_log ( c -> fc , AV_LOG_WARNING , \" \\n \" ) ; \n avio_skip ( pb , size ) ; \n return 1 ; \n } \n if ( codec_tag == AV_RL32 ( \" \" ) || \n codec_tag == AV_RL32 ( \" \" ) || \n codec_tag == AV_RL32 ( \" \" ) \n ) \n av_log ( c -> fc , AV_LOG_WARNING , \" \\n \" ) ; \n return 0 ; \n }", "idx": 4732}
{"project": "FFmpeg", "commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "target": 1, "func": "void ff_slice_thread_free ( AVCodecContext * avctx ) \n { \n SliceThreadContext * c = avctx -> internal -> thread_ctx ; \n int i ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n c -> done = 1 ; \n pthread_cond_broadcast ( & c -> current_job_cond ) ; \n for ( i = 0 ; i < c -> thread_count ; i ++ ) \n pthread_cond_broadcast ( & c -> progress_cond [ i ] ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n for ( i = 0 ; i < avctx -> thread_count ; i ++ ) \n pthread_join ( c -> workers [ i ] , NULL ) ; \n for ( i = 0 ; i < c -> thread_count ; i ++ ) { \n pthread_mutex_destroy ( & c -> progress_mutex [ i ] ) ; \n pthread_cond_destroy ( & c -> progress_cond [ i ] ) ; \n } \n pthread_mutex_destroy ( & c -> current_job_lock ) ; \n pthread_cond_destroy ( & c -> current_job_cond ) ; \n pthread_cond_destroy ( & c -> last_job_cond ) ; \n av_freep ( & c -> entries ) ; \n av_freep ( & c -> progress_mutex ) ; \n av_freep ( & c -> progress_cond ) ; \n av_freep ( & c -> workers ) ; \n av_freep ( & avctx -> internal -> thread_ctx ) ; \n }", "idx": 4735}
{"project": "FFmpeg", "commit_id": "fc78b0cb7e115ae494861c37a9928cff74df8db9", "target": 1, "func": "RTPDemuxContext * rtp_parse_open ( AVFormatContext * s1 , AVStream * st , URLContext * rtpc , int payload_type , RTPPayloadData * rtp_payload_data ) \n { \n RTPDemuxContext * s ; \n s = av_mallocz ( sizeof ( RTPDemuxContext ) ) ; \n if ( ! s ) \n return NULL ; \n s -> payload_type = payload_type ; \n s -> last_rtcp_ntp_time = AV_NOPTS_VALUE ; \n s -> first_rtcp_ntp_time = AV_NOPTS_VALUE ; \n s -> ic = s1 ; \n s -> st = st ; \n s -> rtp_payload_data = rtp_payload_data ; \n rtp_init_statistics ( & s -> statistics , 0 ) ; \n if ( ! strcmp ( ff_rtp_enc_name ( payload_type ) , \" \" ) ) { \n s -> ts = ff_mpegts_parse_open ( s -> ic ) ; \n if ( s -> ts == NULL ) { \n av_free ( s ) ; \n return NULL ; \n } \n } else { \n av_set_pts_info ( st , 32 , 1 , 90000 ) ; \n switch ( st -> codec -> codec_id ) { \n case CODEC_ID_MPEG1VIDEO : \n case CODEC_ID_MPEG2VIDEO : \n case CODEC_ID_MP2 : \n case CODEC_ID_MP3 : \n case CODEC_ID_MPEG4 : \n case CODEC_ID_H263 : \n case CODEC_ID_H264 : \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n break ; \n default : \n if ( st -> codec -> codec_type == CODEC_TYPE_AUDIO ) { \n av_set_pts_info ( st , 32 , 1 , st -> codec -> sample_rate ) ; \n } \n break ; \n } \n } \n s -> rtp_ctx = rtpc ; \n gethostname ( s -> hostname , sizeof ( s -> hostname ) ) ; \n return s ; \n }", "idx": 4736}
{"project": "FFmpeg", "commit_id": "5eb765ef341c3ec1bea31914c897750f88476ede", "target": 1, "func": "static int http_send_data ( HTTPContext * c , long cur_time ) \n { \n int len , ret ; \n while ( c -> buffer_ptr >= c -> buffer_end ) { \n ret = http_prepare_data ( c , cur_time ) ; \n if ( ret < 0 ) \n return -1 ; \n else if ( ret == 0 ) { \n continue ; \n } else { \n return 0 ; \n } \n } \n if ( c -> buffer_end > c -> buffer_ptr ) { \n len = write ( c -> fd , c -> buffer_ptr , c -> buffer_end - c -> buffer_ptr ) ; \n if ( len < 0 ) { \n if ( errno != EAGAIN && errno != EINTR ) { \n return -1 ; \n } \n } else { \n c -> buffer_ptr += len ; \n c -> data_count += len ; \n if ( c -> stream ) \n c -> stream -> bytes_served += len ; \n } \n } \n return 0 ; \n }", "idx": 4737}
{"project": "FFmpeg", "commit_id": "689f65126be8a55e8a1e706cb56b19bb975c20ce", "target": 0, "func": "static inline void idct4col_put ( uint8_t * dest , int line_size , const DCTELEM * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 2 ] ; \n a2 = col [ 8 * 4 ] ; \n a3 = col [ 8 * 6 ] ; \n c0 = ( ( a0 + a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( ( a0 - a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = cm [ ( c0 + c1 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 + c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 - c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c0 - c1 ) >> C_SHIFT ] ; \n }", "idx": 4751}
{"project": "FFmpeg", "commit_id": "de64d8cf171c6ecdca22d57f0bdd7efec95d0c0e", "target": 1, "func": "static void qtrle_decode_16bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned short rgb16 ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n while ( lines_to_change -- ) { \n CHECK_STREAM_PTR ( 2 ) ; \n pixel_ptr = row_ptr + ( s -> buf [ stream_ptr ++ ] - 1 ) * 2 ; \n while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != -1 ) { \n if ( rle_code == 0 ) { \n CHECK_STREAM_PTR ( 1 ) ; \n pixel_ptr += ( s -> buf [ stream_ptr ++ ] - 1 ) * 2 ; \n CHECK_PIXEL_PTR ( 0 ) ; \n } else if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 2 ) ; \n rgb16 = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; \n stream_ptr += 2 ; \n CHECK_PIXEL_PTR ( rle_code * 2 ) ; \n while ( rle_code -- ) { \n * ( unsigned short * ) ( & rgb [ pixel_ptr ] ) = rgb16 ; \n pixel_ptr += 2 ; \n } \n } else { \n CHECK_STREAM_PTR ( rle_code * 2 ) ; \n CHECK_PIXEL_PTR ( rle_code * 2 ) ; \n while ( rle_code -- ) { \n rgb16 = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; \n stream_ptr += 2 ; \n * ( unsigned short * ) ( & rgb [ pixel_ptr ] ) = rgb16 ; \n pixel_ptr += 2 ; \n } \n } \n } \n row_ptr += row_inc ; \n } \n }", "idx": 4754}
{"project": "FFmpeg", "commit_id": "7b5ff7d57355dc608f0fd86e3ab32a2fda65e752", "target": 1, "func": "static void vp7_decode_mb_row_no_filter ( AVCodecContext * avctx , void * tdata , \n int jobnr , int threadnr ) \n { \n decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr , 1 ) ; \n }", "idx": 4758}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int expand_rle_row ( const uint8_t * in_buf , const uint8_t * in_end , \n unsigned char * out_buf , uint8_t * out_end , int pixelstride ) \n { \n unsigned char pixel , count ; \n unsigned char * orig = out_buf ; \n while ( 1 ) { \n if ( in_buf + 1 > in_end ) return -1 ; \n pixel = bytestream_get_byte ( & in_buf ) ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) { \n return ( out_buf - orig ) / pixelstride ; \n } \n if ( out_buf + pixelstride * count >= out_end ) return -1 ; \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n * out_buf = bytestream_get_byte ( & in_buf ) ; \n out_buf += pixelstride ; \n } \n } else { \n pixel = bytestream_get_byte ( & in_buf ) ; \n while ( count -- ) { \n * out_buf = pixel ; \n out_buf += pixelstride ; \n } \n } \n } \n }", "idx": 4771}
{"project": "FFmpeg", "commit_id": "cdedf7e6254024c643532d45ac7c68e84e50eb01", "target": 0, "func": "static void encode_exponents_blk_ch ( uint8_t * exp , \n int nb_exps , int exp_strategy , \n uint8_t * num_exp_groups ) \n { \n int group_size , nb_groups , i , j , k , exp_min ; \n group_size = exp_strategy + ( exp_strategy == EXP_D45 ) ; \n * num_exp_groups = ( nb_exps + ( group_size * 3 ) - 4 ) / ( 3 * group_size ) ; \n nb_groups = * num_exp_groups * 3 ; \n if ( exp_strategy > EXP_D15 ) { \n k = 1 ; \n for ( i = 1 ; i <= nb_groups ; i ++ ) { \n exp_min = exp [ k ] ; \n assert ( exp_min >= 0 && exp_min <= 24 ) ; \n for ( j = 1 ; j < group_size ; j ++ ) { \n if ( exp [ k + j ] < exp_min ) \n exp_min = exp [ k + j ] ; \n } \n exp [ i ] = exp_min ; \n k += group_size ; \n } \n } \n if ( exp [ 0 ] > 15 ) \n exp [ 0 ] = 15 ; \n for ( i = 1 ; i <= nb_groups ; i ++ ) \n exp [ i ] = FFMIN ( exp [ i ] , exp [ i - 1 ] + 2 ) ; \n for ( i = nb_groups - 1 ; i >= 0 ; i -- ) \n exp [ i ] = FFMIN ( exp [ i ] , exp [ i + 1 ] + 2 ) ; \n if ( exp_strategy > EXP_D15 ) { \n k = nb_groups * group_size ; \n for ( i = nb_groups ; i > 0 ; i -- ) { \n for ( j = 0 ; j < group_size ; j ++ ) \n exp [ k - j ] = exp [ i ] ; \n k -= group_size ; \n } \n } \n }", "idx": 4772}
{"project": "FFmpeg", "commit_id": "dc0ad40de2b0d6995eb842e56b22f9096bd539ff", "target": 0, "func": "static void ac3_update_bap_counts_c ( uint16_t mant_cnt [ 16 ] , uint8_t * bap , \n int len ) \n { \n while ( len -- >= 0 ) \n mant_cnt [ bap [ len ] ] ++ ; \n }", "idx": 4773}
{"project": "FFmpeg", "commit_id": "2ed0f76655a76cc49f8a1a1d59e545f5906e7924", "target": 1, "func": "av_cold void ff_h264_free_context ( H264Context * h ) \n { \n int i ; \n free_tables ( h ) ; \n for ( i = 0 ; i < MAX_SPS_COUNT ; i ++ ) \n av_freep ( h -> sps_buffers + i ) ; \n for ( i = 0 ; i < MAX_PPS_COUNT ; i ++ ) \n av_freep ( h -> pps_buffers + i ) ; \n }", "idx": 4782}
{"project": "FFmpeg", "commit_id": "136f55207521f0b03194ef5b55ba70f1635d6aee", "target": 1, "func": "static inline int hpel_motion ( MpegEncContext * s , \n uint8_t * dest , uint8_t * src , \n int src_x , int src_y , \n op_pixels_func * pix_op , \n int motion_x , int motion_y ) \n { \n int dxy = 0 ; \n int emu = 0 ; \n src_x += motion_x >> 1 ; \n src_y += motion_y >> 1 ; \n src_x = av_clip ( src_x , -16 , s -> width ) ; \n if ( src_x != s -> width ) \n dxy |= motion_x & 1 ; \n src_y = av_clip ( src_y , -16 , s -> height ) ; \n if ( src_y != s -> height ) \n dxy |= ( motion_y & 1 ) << 1 ; \n src += src_y * s -> linesize + src_x ; \n if ( s -> unrestricted_mv ) { \n if ( ( unsigned ) src_x > FFMAX ( s -> h_edge_pos - ( motion_x & 1 ) - 8 , 0 ) || \n ( unsigned ) src_y > FFMAX ( s -> v_edge_pos - ( motion_y & 1 ) - 8 , 0 ) ) { \n s -> vdsp . emulated_edge_mc ( s -> sc . edge_emu_buffer , src , \n s -> linesize , s -> linesize , \n 9 , 9 , \n src_x , src_y , s -> h_edge_pos , \n s -> v_edge_pos ) ; \n src = s -> sc . edge_emu_buffer ; \n emu = 1 ; \n } \n } \n pix_op [ dxy ] ( dest , src , s -> linesize , 8 ) ; \n return emu ; \n }", "idx": 4785}
{"project": "FFmpeg", "commit_id": "e2b54464c6a9de5d6b9ad4307696b0215d5e05a4", "target": 0, "func": "static int set_format ( void * obj , const char * name , int fmt , int search_flags , \n enum AVOptionType type , const char * desc , int nb_fmts ) \n { \n void * target_obj ; \n const AVOption * o = av_opt_find2 ( obj , name , NULL , 0 , \n search_flags , & target_obj ) ; \n int min , max ; \n const AVClass * class = * ( AVClass * * ) obj ; \n if ( ! o || ! target_obj ) \n return AVERROR_OPTION_NOT_FOUND ; \n if ( o -> type != type ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \" , name , desc ) ; \n return AVERROR ( EINVAL ) ; \n } \n #if LIBAVUTIL_VERSION_MAJOR < 54  \n  \n  if ( class -> version && class -> version < AV_VERSION_INT ( 52 , 11 , 100 ) ) { \n min = -1 ; \n max = nb_fmts - 1 ; \n } else \n #endif \n { \n min = FFMIN ( o -> min , -1 ) ; \n max = FFMAX ( o -> max , nb_fmts - 1 ) ; \n } \n if ( fmt < min || fmt > max ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \\n \" , \n fmt , name , desc , min , max ) ; \n return AVERROR ( ERANGE ) ; \n } \n * ( int * ) ( ( ( uint8_t * ) target_obj ) + o -> offset ) = fmt ; \n return 0 ; \n }", "idx": 4787}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel4_mc01_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_4w_msa ( src - ( stride * 2 ) , stride , dst , stride , 4 , 0 ) ; \n }", "idx": 4788}
{"project": "FFmpeg", "commit_id": "702200358197a0ea5ea82d1d6540c785bb04fae4", "target": 0, "func": "static void dump_cook_context ( COOKContext * q , COOKextradata * e ) \n { \n #define PRINT ( a , b )  av_log(NULL,AV_LOG_ERROR,\" %s = %d\\n\", a, b);  \n  \n  av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , e -> cookversion ) ; \n if ( e -> cookversion > MONO_COOK2 ) { \n PRINT ( \" \" , e -> js_subband_start ) ; \n PRINT ( \" \" , e -> js_vlc_bits ) ; \n } \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n PRINT ( \" \" , q -> nb_channels ) ; \n PRINT ( \" \" , q -> bit_rate ) ; \n PRINT ( \" \" , q -> sample_rate ) ; \n PRINT ( \" \" , q -> samples_per_channel ) ; \n PRINT ( \" \" , q -> samples_per_frame ) ; \n PRINT ( \" \" , q -> subbands ) ; \n PRINT ( \" \" , q -> random_state ) ; \n PRINT ( \" \" , q -> mlt_size ) ; \n PRINT ( \" \" , q -> js_subband_start ) ; \n PRINT ( \" \" , q -> numvector_bits ) ; \n PRINT ( \" \" , q -> numvector_size ) ; \n PRINT ( \" \" , q -> total_subbands ) ; \n PRINT ( \" \" , q -> frame_reorder_counter ) ; \n PRINT ( \" \" , q -> frame_reorder_index_size ) ; \n }", "idx": 4789}
{"project": "FFmpeg", "commit_id": "e33d3720239314d28a48c64c1071ba9c048280d1", "target": 0, "func": "static void ffm_set_write_index ( AVFormatContext * s , int64_t pos , \n int64_t file_size ) \n { \n FFMContext * ffm = s -> priv_data ; \n ffm -> write_index = pos ; \n ffm -> file_size = file_size ; \n }", "idx": 4790}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "av_cold int ff_vp8_decode_init ( AVCodecContext * avctx ) \n { \n VP8Context * s = avctx -> priv_data ; \n int ret ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n avctx -> internal -> allocate_progress = 1 ; \n ff_videodsp_init ( & s -> vdsp , 8 ) ; \n ff_h264_pred_init ( & s -> hpc , AV_CODEC_ID_VP8 , 8 , 1 ) ; \n ff_vp8dsp_init ( & s -> vp8dsp ) ; \n if ( ( ret = vp8_init_frames ( s ) ) < 0 ) { \n ff_vp8_decode_free ( avctx ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 4799}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static inline void json_print_item_str ( WriterContext * wctx , \n const char * key , const char * value , \n const char * indent ) \n { \n char * key_esc = json_escape_str ( key ) ; \n char * value_esc = json_escape_str ( value ) ; \n printf ( \" \\\" \\\" \\\" \\\" \" , indent , \n key_esc ? key_esc : \" \" , \n value_esc ? value_esc : \" \" ) ; \n av_free ( key_esc ) ; \n av_free ( value_esc ) ; \n }", "idx": 4802}
{"project": "FFmpeg", "commit_id": "5e6439a12508f8f7f30aeef64eb96c2311b7f573", "target": 1, "func": "AVRational ff_choose_timebase ( AVFormatContext * s , AVStream * st , int min_precission ) \n { \n AVRational q ; \n int j ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n q = ( AVRational ) { 1 , st -> codec -> sample_rate } ; \n } else { \n q = st -> codec -> time_base ; \n } \n for ( j = 2 ; j < 2000 ; j += 1 + ( j > 2 ) ) \n while ( q . den / q . num < min_precission && q . num % j == 0 ) \n q . num /= j ; \n while ( q . den / q . num < min_precission && q . den < ( 1 << 24 ) ) \n q . den <<= 1 ; \n return q ; \n }", "idx": 4804}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int init_dimensions ( H264Context * h ) \n { \n int width = h -> width - ( h -> sps . crop_right + h -> sps . crop_left ) ; \n int height = h -> height - ( h -> sps . crop_top + h -> sps . crop_bottom ) ; \n if ( FFALIGN ( h -> avctx -> width , 16 ) == FFALIGN ( width , 16 ) && \n FFALIGN ( h -> avctx -> height , 16 ) == FFALIGN ( height , 16 ) ) { \n width = h -> avctx -> width ; \n height = h -> avctx -> height ; \n } \n if ( width <= 0 || height <= 0 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \" \\n \" , \n width , height ) ; \n if ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) \n return AVERROR_INVALIDDATA ; \n av_log ( h -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n h -> sps . crop_bottom = \n h -> sps . crop_top = \n h -> sps . crop_right = \n h -> sps . crop_left = \n h -> sps . crop = 0 ; \n width = h -> width ; \n height = h -> height ; \n } \n h -> avctx -> coded_width = h -> width ; \n h -> avctx -> coded_height = h -> height ; \n h -> avctx -> width = width ; \n h -> avctx -> height = height ; \n return 0 ; \n }", "idx": 4808}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_generic_value ( AVFormatContext * s , uint8_t * name , uint16_t name_len , \n int type , AVDictionary * * met ) \n { \n AVIOContext * pb = s -> pb ; \n uint64_t value ; \n char buf [ 32 ] ; \n switch ( type ) { \n case ASF_BOOL : \n value = avio_rl32 ( pb ) ; \n break ; \n case ASF_DWORD : \n value = avio_rl32 ( pb ) ; \n break ; \n case ASF_QWORD : \n value = avio_rl64 ( pb ) ; \n break ; \n case ASF_WORD : \n value = avio_rl16 ( pb ) ; \n break ; \n default : \n av_freep ( & name ) ; \n return AVERROR_INVALIDDATA ; \n } \n snprintf ( buf , sizeof ( buf ) , \" \" PRIu64 , value ) ; \n if ( av_dict_set ( met , name , buf , 0 ) < 0 ) \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n return 0 ; \n }", "idx": 4813}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_close ( URLContext * h ) \n { \n FTPContext * s = h -> priv_data ; \n av_dlog ( h , \" \\n \" ) ; \n ftp_close_both_connections ( s ) ; \n av_freep ( & s -> user ) ; \n av_freep ( & s -> password ) ; \n av_freep ( & s -> hostname ) ; \n av_freep ( & s -> path ) ; \n av_freep ( & s -> features ) ; \n return 0 ; \n }", "idx": 4822}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static inline void conv_to_int32 ( int32_t * loc , float * samples , int num , float norm ) \n { \n int i ; \n for ( i = 0 ; i < num ; i ++ ) \n loc [ i ] = ceilf ( ( samples [ i ] / norm ) * INT32_MAX ) ; \n }", "idx": 4836}
{"project": "FFmpeg", "commit_id": "b8ed15d6378f00e158c72c526fa0fce17da77361", "target": 1, "func": "static int parse_header ( OutputStream * os , const uint8_t * buf , int buf_size ) \n { \n if ( buf_size < 13 ) \n return AVERROR_INVALIDDATA ; \n if ( memcmp ( buf , \" \" , 3 ) ) \n return AVERROR_INVALIDDATA ; \n buf += 13 ; \n buf_size -= 13 ; \n while ( buf_size >= 11 + 4 ) { \n int type = buf [ 0 ] ; \n int size = AV_RB24 ( & buf [ 1 ] ) + 11 + 4 ; \n if ( size > buf_size ) \n return AVERROR_INVALIDDATA ; \n if ( type == 8 || type == 9 ) { \n if ( os -> nb_extra_packets > FF_ARRAY_ELEMS ( os -> extra_packets ) ) \n return AVERROR_INVALIDDATA ; \n os -> extra_packet_sizes [ os -> nb_extra_packets ] = size ; \n os -> extra_packets [ os -> nb_extra_packets ] = av_malloc ( size ) ; \n if ( ! os -> extra_packets [ os -> nb_extra_packets ] ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( os -> extra_packets [ os -> nb_extra_packets ] , buf , size ) ; \n os -> nb_extra_packets ++ ; \n } else if ( type == 0x12 ) { \n if ( os -> metadata ) \n return AVERROR_INVALIDDATA ; \n os -> metadata_size = size - 11 - 4 ; \n os -> metadata = av_malloc ( os -> metadata_size ) ; \n if ( ! os -> metadata ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( os -> metadata , buf + 11 , os -> metadata_size ) ; \n } \n buf += size ; \n buf_size -= size ; \n } \n if ( ! os -> metadata ) \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 4852}
{"project": "FFmpeg", "commit_id": "e3694478a98bc2cd702b3b3f0bfb19a100da737e", "target": 1, "func": "static int yuv4_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int i ; \n char header [ MAX_FRAME_HEADER + 1 ] ; \n int ret ; \n int64_t off = avio_tell ( s -> pb ) ; \n for ( i = 0 ; i < MAX_FRAME_HEADER ; i ++ ) { \n header [ i ] = avio_r8 ( s -> pb ) ; \n if ( header [ i ] == ' \\n ' ) { \n header [ i + 1 ] = 0 ; \n break ; \n } \n } \n if ( s -> pb -> error ) \n return s -> pb -> error ; \n else if ( s -> pb -> eof_reached ) \n return AVERROR_EOF ; \n else if ( i == MAX_FRAME_HEADER ) \n return AVERROR_INVALIDDATA ; \n if ( strncmp ( header , Y4M_FRAME_MAGIC , strlen ( Y4M_FRAME_MAGIC ) ) ) \n return AVERROR_INVALIDDATA ; \n ret = av_get_packet ( s -> pb , pkt , s -> packet_size - Y4M_FRAME_MAGIC_LEN ) ; \n if ( ret < 0 ) \n return ret ; \n else if ( ret != s -> packet_size - Y4M_FRAME_MAGIC_LEN ) \n return s -> pb -> eof_reached ? AVERROR_EOF : AVERROR ( EIO ) ; \n pkt -> stream_index = 0 ; \n pkt -> pts = ( off - s -> internal -> data_offset ) / s -> packet_size ; \n pkt -> duration = 1 ; \n return 0 ; \n }", "idx": 4857}
{"project": "FFmpeg", "commit_id": "ce9e31655e5b8f8db3bb4f13f436fc836062a514", "target": 1, "func": "static void new_pes_packet ( PESContext * pes , AVPacket * pkt ) \n { \n av_init_packet ( pkt ) ; \n pkt -> destruct = av_destruct_packet ; \n pkt -> data = pes -> buffer ; \n pkt -> size = pes -> data_index ; \n memset ( pkt -> data + pkt -> size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( pes -> sub_st && pes -> stream_type == 0x83 && pes -> extended_stream_id == 0x76 ) \n pkt -> stream_index = pes -> sub_st -> index ; \n else \n pkt -> stream_index = pes -> st -> index ; \n pkt -> pts = pes -> pts ; \n pkt -> dts = pes -> dts ; \n pkt -> pos = pes -> ts_packet_pos ; \n pes -> pts = AV_NOPTS_VALUE ; \n pes -> dts = AV_NOPTS_VALUE ; \n pes -> buffer = NULL ; \n pes -> data_index = 0 ; \n }", "idx": 4862}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static int seqvideo_decode ( SeqVideoContext * seq , const unsigned char * data , int data_size ) \n { \n const unsigned char * data_end = data + data_size ; \n GetBitContext gb ; \n int flags , i , j , x , y , op ; \n unsigned char c [ 3 ] ; \n unsigned char * dst ; \n uint32_t * palette ; \n flags = * data ++ ; \n if ( flags & 1 ) { \n palette = ( uint32_t * ) seq -> frame . data [ 1 ] ; \n if ( data_end - data < 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ , data ++ ) \n c [ j ] = ( * data << 2 ) | ( * data >> 4 ) ; \n palette [ i ] = 0xFF << 24 | AV_RB24 ( c ) ; \n } \n seq -> frame . palette_has_changed = 1 ; \n } \n if ( flags & 2 ) { \n if ( data_end - data < 128 ) \n return AVERROR_INVALIDDATA ; \n init_get_bits ( & gb , data , 128 * 8 ) ; data += 128 ; \n for ( y = 0 ; y < 128 ; y += 8 ) \n for ( x = 0 ; x < 256 ; x += 8 ) { \n dst = & seq -> frame . data [ 0 ] [ y * seq -> frame . linesize [ 0 ] + x ] ; \n op = get_bits ( & gb , 2 ) ; \n switch ( op ) { \n case 1 : \n data = seq_decode_op1 ( seq , data , data_end , dst ) ; \n break ; \n case 2 : \n data = seq_decode_op2 ( seq , data , data_end , dst ) ; \n break ; \n case 3 : \n data = seq_decode_op3 ( seq , data , data_end , dst ) ; \n break ; \n } \n if ( ! data ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 4863}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static inline unsigned char gif_clut_index ( uint8_t r , uint8_t g , uint8_t b ) \n { \n return ( ( ( ( r ) / 47 ) % 6 ) * 6 * 6 + ( ( ( g ) / 47 ) % 6 ) * 6 + ( ( ( b ) / 47 ) % 6 ) ) ; \n }", "idx": 4885}
{"project": "FFmpeg", "commit_id": "992b03183819553a73b4f870a710ef500b4eb6d0", "target": 0, "func": "static void draw_line ( uint8_t * buf , int sx , int sy , int ex , int ey , \n int w , int h , int stride , int color ) \n { \n int x , y , fr , f ; \n sx = av_clip ( sx , 0 , w - 1 ) ; \n sy = av_clip ( sy , 0 , h - 1 ) ; \n ex = av_clip ( ex , 0 , w - 1 ) ; \n ey = av_clip ( ey , 0 , h - 1 ) ; \n buf [ sy * stride + sx ] += color ; \n if ( FFABS ( ex - sx ) > FFABS ( ey - sy ) ) { \n if ( sx > ex ) { \n FFSWAP ( int , sx , ex ) ; \n FFSWAP ( int , sy , ey ) ; \n } \n buf += sx + sy * stride ; \n ex -= sx ; \n f = ( ( ey - sy ) << 16 ) / ex ; \n for ( x = 0 ; x = ex ; x ++ ) { \n y = ( x * f ) >> 16 ; \n fr = ( x * f ) & 0xFFFF ; \n buf [ y * stride + x ] += ( color * ( 0x10000 - fr ) ) >> 16 ; \n buf [ ( y + 1 ) * stride + x ] += ( color * fr ) >> 16 ; \n } \n } else { \n if ( sy > ey ) { \n FFSWAP ( int , sx , ex ) ; \n FFSWAP ( int , sy , ey ) ; \n } \n buf += sx + sy * stride ; \n ey -= sy ; \n if ( ey ) \n f = ( ( ex - sx ) << 16 ) / ey ; \n else \n f = 0 ; \n for ( y = 0 ; y = ey ; y ++ ) { \n x = ( y * f ) >> 16 ; \n fr = ( y * f ) & 0xFFFF ; \n buf [ y * stride + x ] += ( color * ( 0x10000 - fr ) ) >> 16 ; \n buf [ y * stride + x + 1 ] += ( color * fr ) >> 16 ; \n } \n } \n }", "idx": 4919}
{"project": "FFmpeg", "commit_id": "340b7caf5457b2988bfd53709a00cedc2fcd73b7", "target": 0, "func": "static int hls_start ( AVFormatContext * s ) \n { \n HLSContext * c = s -> priv_data ; \n AVFormatContext * oc = c -> avf ; \n int err = 0 ; \n if ( c -> wrap ) \n c -> number %= c -> wrap ; \n if ( av_get_frame_filename ( oc -> filename , sizeof ( oc -> filename ) , \n c -> basename , c -> number ++ ) < 0 ) \n return AVERROR ( EINVAL ) ; \n if ( ( err = avio_open2 ( & oc -> pb , oc -> filename , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ) < 0 ) \n return err ; \n if ( oc -> oformat -> priv_class && oc -> priv_data ) \n av_opt_set ( oc -> priv_data , \" \" , \" \" , 0 ) ; \n return 0 ; \n }", "idx": 4947}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_status ( FTPContext * s , char * * line , const int response_codes [ ] ) \n { \n int err , i , result = 0 , pref_code_found = 0 , wait_count = 100 ; \n char buf [ CONTROL_BUFFER_SIZE ] ; \n s -> conn_control_block_flag = 0 ; \n for ( ; ; ) { \n if ( ( err = ftp_get_line ( s , buf , sizeof ( buf ) ) ) < 0 ) { \n if ( err == AVERROR_EXIT ) { \n if ( ! pref_code_found && wait_count -- ) { \n av_usleep ( 10000 ) ; \n continue ; \n } \n } \n return result ; \n } \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , buf ) ; \n if ( ! pref_code_found ) { \n if ( strlen ( buf ) < 3 ) \n continue ; \n err = 0 ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n if ( buf [ i ] < ' ' || buf [ i ] > ' ' ) \n continue ; \n err *= 10 ; \n err += buf [ i ] - ' ' ; \n } \n for ( i = 0 ; response_codes [ i ] ; ++ i ) { \n if ( err == response_codes [ i ] ) { \n s -> conn_control_block_flag = 1 ; \n pref_code_found = 1 ; \n result = err ; \n if ( line ) \n * line = av_strdup ( buf ) ; \n break ; \n } \n } \n } \n } \n return result ; \n }", "idx": 4965}
{"project": "FFmpeg", "commit_id": "2856332719d8ec182523f7793bb0517aaac68e73", "target": 1, "func": "static int vda_h264_uninit ( AVCodecContext * avctx ) \n { \n VDAContext * vda = avctx -> internal -> hwaccel_priv_data ; \n av_freep ( & vda -> bitstream ) ; \n if ( vda -> frame ) \n CVPixelBufferRelease ( vda -> frame ) ; \n return 0 ; \n }", "idx": 4975}
{"project": "FFmpeg", "commit_id": "088ed5314694031e07e02e9d364c9d486a60e704", "target": 0, "func": "static int mkv_write_tags ( AVFormatContext * s ) \n { \n ebml_master tags = { 0 } ; \n int i , ret ; \n ff_metadata_conv_ctx ( s , ff_mkv_metadata_conv , NULL ) ; \n if ( av_dict_get ( s -> metadata , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) { \n ret = mkv_write_tag ( s , s -> metadata , 0 , 0 , & tags ) ; \n if ( ret < 0 ) return ret ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n if ( ! av_dict_get ( st -> metadata , \" \" , 0 , AV_DICT_IGNORE_SUFFIX ) ) \n continue ; \n ret = mkv_write_tag ( s , st -> metadata , MATROSKA_ID_TAGTARGETS_TRACKUID , i + 1 , & tags ) ; \n if ( ret < 0 ) return ret ; \n } \n for ( i = 0 ; i < s -> nb_chapters ; i ++ ) { \n AVChapter * ch = s -> chapters [ i ] ; \n if ( ! av_dict_get ( ch -> metadata , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) \n continue ; \n ret = mkv_write_tag ( s , ch -> metadata , MATROSKA_ID_TAGTARGETS_CHAPTERUID , ch -> id , & tags ) ; \n if ( ret < 0 ) return ret ; \n } \n if ( tags . pos ) \n end_ebml_master ( s -> pb , tags ) ; \n return 0 ; \n }", "idx": 4986}
{"project": "FFmpeg", "commit_id": "2e664b9c1e73c80aab91070c1eb7676f04bdd12d", "target": 1, "func": "void ff_thread_report_progress ( ThreadFrame * f , int n , int field ) \n { \n PerThreadContext * p ; \n atomic_int * progress = f -> progress ? ( atomic_int * ) f -> progress -> data : NULL ; \n if ( ! progress || \n atomic_load_explicit ( & progress [ field ] , memory_order_relaxed ) >= n ) \n return ; \n p = f -> owner [ field ] -> internal -> thread_ctx ; \n if ( f -> owner [ field ] -> debug & FF_DEBUG_THREADS ) \n av_log ( f -> owner [ field ] , AV_LOG_DEBUG , \n \" \\n \" , progress , n , field ) ; \n pthread_mutex_lock ( & p -> progress_mutex ) ; \n atomic_store_explicit ( & progress [ field ] , n , memory_order_release ) ; \n pthread_cond_broadcast ( & p -> progress_cond ) ; \n pthread_mutex_unlock ( & p -> progress_mutex ) ; \n }", "idx": 4989}
{"project": "FFmpeg", "commit_id": "05e161952954acf247e0fd1fdef00559675c4d4d", "target": 1, "func": "static inline int64_t bs_get_v ( const uint8_t * * bs ) \n { \n int64_t v = 0 ; \n int br = 0 ; \n int c ; \n do { \n c = * * bs ; ( * bs ) ++ ; \n v <<= 7 ; \n v |= c & 0x7F ; \n br ++ ; \n if ( br > 10 ) \n return -1 ; \n } while ( c & 0x80 ) ; \n return v - br ; \n }", "idx": 4990}
{"project": "FFmpeg", "commit_id": "6abe7edabb7d57e82d7ea6312d30cf05d2192c5b", "target": 1, "func": "static void find_best_state ( uint8_t best_state [ 256 ] [ 256 ] , \n const uint8_t one_state [ 256 ] ) \n { \n int i , j , k , m ; \n double l2tab [ 256 ] ; \n for ( i = 1 ; i < 256 ; i ++ ) \n l2tab [ i ] = log2 ( i / 256.0 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n double best_len [ 256 ] ; \n double p = i / 256.0 ; \n for ( j = 0 ; j < 256 ; j ++ ) \n best_len [ j ] = 1 << 30 ; \n for ( j = FFMAX ( i - 10 , 1 ) ; j < FFMIN ( i + 11 , 256 ) ; j ++ ) { \n double occ [ 256 ] = { 0 } ; \n double len = 0 ; \n occ [ j ] = 1.0 ; \n for ( k = 0 ; k < 256 ; k ++ ) { \n double newocc [ 256 ] = { 0 } ; \n for ( m = 1 ; m < 256 ; m ++ ) \n if ( occ [ m ] ) { \n len -= occ [ m ] * ( p * l2tab [ m ] + \n ( 1 - p ) * l2tab [ 256 - m ] ) ; \n } \n if ( len < best_len [ k ] ) { \n best_len [ k ] = len ; \n best_state [ i ] [ k ] = j ; \n } \n for ( m = 0 ; m < 256 ; m ++ ) \n if ( occ [ m ] ) { \n newocc [ one_state [ m ] ] += occ [ m ] * p ; \n newocc [ 256 - one_state [ 256 - m ] ] += occ [ m ] * ( 1 - p ) ; \n } \n memcpy ( occ , newocc , sizeof ( occ ) ) ; \n } \n } \n } \n }", "idx": 4997}
{"project": "FFmpeg", "commit_id": "a1f48480497bb462c5d1d589ae393335f50b06e0", "target": 0, "func": "static float ssim_end4 ( int sum0 [ 5 ] [ 4 ] , int sum1 [ 5 ] [ 4 ] , int width ) \n { \n float ssim = 0.0 ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n ssim += ssim_end1 ( sum0 [ i ] [ 0 ] + sum0 [ i + 1 ] [ 0 ] + sum1 [ i ] [ 0 ] + sum1 [ i + 1 ] [ 0 ] , \n sum0 [ i ] [ 1 ] + sum0 [ i + 1 ] [ 1 ] + sum1 [ i ] [ 1 ] + sum1 [ i + 1 ] [ 1 ] , \n sum0 [ i ] [ 2 ] + sum0 [ i + 1 ] [ 2 ] + sum1 [ i ] [ 2 ] + sum1 [ i + 1 ] [ 2 ] , \n sum0 [ i ] [ 3 ] + sum0 [ i + 1 ] [ 3 ] + sum1 [ i ] [ 3 ] + sum1 [ i + 1 ] [ 3 ] ) ; \n return ssim ; \n }", "idx": 5005}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static int device_init ( AVFormatContext * ctx , int * width , int * height , \n uint32_t pix_fmt ) \n { \n struct video_data * s = ctx -> priv_data ; \n int fd = s -> fd ; \n struct v4l2_format fmt ; \n struct v4l2_pix_format * pix = & fmt . fmt . pix ; \n int res ; \n memset ( & fmt , 0 , sizeof ( struct v4l2_format ) ) ; \n fmt . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n pix -> width = * width ; \n pix -> height = * height ; \n pix -> pixelformat = pix_fmt ; \n pix -> field = V4L2_FIELD_ANY ; \n res = ioctl ( fd , VIDIOC_S_FMT , & fmt ) ; \n if ( ( * width != fmt . fmt . pix . width ) || ( * height != fmt . fmt . pix . height ) ) { \n av_log ( ctx , AV_LOG_INFO , \n \" \\n \" , \n * width , * height , fmt . fmt . pix . width , fmt . fmt . pix . height ) ; \n * width = fmt . fmt . pix . width ; \n * height = fmt . fmt . pix . height ; \n } \n if ( pix_fmt != fmt . fmt . pix . pixelformat ) { \n av_log ( ctx , AV_LOG_DEBUG , \n \" \" \n \" \\n \" , \n pix_fmt , fmt . fmt . pix . pixelformat ) ; \n res = -1 ; \n } \n if ( fmt . fmt . pix . field == V4L2_FIELD_INTERLACED ) { \n av_log ( ctx , AV_LOG_DEBUG , \" \" ) ; \n s -> interlaced = 1 ; \n } \n return res ; \n }", "idx": 5033}
{"project": "FFmpeg", "commit_id": "2580bae54a45d6aaf85ddc5e780389e7e90b2c86", "target": 1, "func": "static int encode_packets ( Jpeg2000EncoderContext * s , Jpeg2000Tile * tile , int tileno ) \n { \n int compno , reslevelno , ret ; \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n Jpeg2000QuantStyle * qntsty = & s -> qntsty ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n int precno ; \n Jpeg2000ResLevel * reslevel = s -> tile [ tileno ] . comp [ compno ] . reslevel + reslevelno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n if ( ret = encode_packet ( s , reslevel , precno , qntsty -> expn + ( reslevelno ? 3 * reslevelno - 2 : 0 ) , \n qntsty -> nguardbits ) ) \n return ret ; \n } \n } \n } \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return 0 ; \n }", "idx": 5058}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static void chomp3 ( ChannelData * ctx , int16_t * output , uint8_t val , \n const uint16_t tab1 [ ] , \n const int16_t * tab2 , int tab2_stride , \n uint32_t numChannels ) \n { \n int16_t current ; \n current = tab2 [ ( ( ctx -> index & 0x7f0 ) >> 4 ) * tab2_stride + val ] ; \n current = mace_broken_clip_int16 ( current + ctx -> lev ) ; \n ctx -> lev = current - ( current >> 3 ) ; \n * output = QT_8S_2_16S ( current ) ; \n if ( ( ctx -> index += tab1 [ val ] - ( ctx -> index >> 5 ) ) < 0 ) \n ctx -> index = 0 ; \n }", "idx": 5062}
{"project": "FFmpeg", "commit_id": "c11d3634b07b4aa71f75478aa1bcb63b0c22e030", "target": 1, "func": "static void srt_to_ass ( AVCodecContext * avctx , AVBPrint * dst , \n const char * in , int x1 , int y1 , int x2 , int y2 ) \n { \n if ( x1 >= 0 && y1 >= 0 ) { \n if ( x2 >= 0 && y2 >= 0 && ( x2 != x1 || y2 != y1 ) && x2 >= x1 && y2 >= y1 ) { \n const int cx = x1 + ( x2 - x1 ) / 2 ; \n const int cy = y1 + ( y2 - y1 ) / 2 ; \n const int scaled_x = cx * ASS_DEFAULT_PLAYRESX / 720 ; \n const int scaled_y = cy * ASS_DEFAULT_PLAYRESY / 480 ; \n av_bprintf ( dst , \" \\\\ \\\\ \" , scaled_x , scaled_y ) ; \n } else { \n const int scaled_x = x1 * ASS_DEFAULT_PLAYRESX / 720 ; \n const int scaled_y = y1 * ASS_DEFAULT_PLAYRESY / 480 ; \n av_bprintf ( dst , \" \\\\ \\\\ \" , scaled_x , scaled_y ) ; \n } \n } \n ff_htmlmarkup_to_ass ( avctx , dst , in ) ; \n }", "idx": 5063}
{"project": "FFmpeg", "commit_id": "9e7b62f0fb7462a902330fcc82cf596388f0187b", "target": 0, "func": "int ff_twinvq_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n AVFrame * frame = data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n TwinVQContext * tctx = avctx -> priv_data ; \n const TwinVQModeTab * mtab = tctx -> mtab ; \n float * * out = NULL ; \n int ret ; \n if ( tctx -> discarded_packets >= 2 ) { \n frame -> nb_samples = mtab -> size ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n out = ( float * * ) frame -> extended_data ; \n } \n if ( ( ret = tctx -> read_bitstream ( avctx , tctx , buf , buf_size ) ) < 0 ) \n return ret ; \n read_and_decode_spectrum ( tctx , tctx -> spectrum , tctx -> bits . ftype ) ; \n imdct_output ( tctx , tctx -> bits . ftype , tctx -> bits . window_type , out ) ; \n FFSWAP ( float * , tctx -> curr_frame , tctx -> prev_frame ) ; \n if ( tctx -> discarded_packets < 2 ) { \n tctx -> discarded_packets ++ ; \n * got_frame_ptr = 0 ; \n return buf_size ; \n } \n * got_frame_ptr = 1 ; \n return buf_size ; \n }", "idx": 5065}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int split_field_ref_list ( Picture * dest , int dest_len , \n Picture * src , int src_len , \n int parity , int long_i ) { \n int i = split_field_half_ref_list ( dest , dest_len , src , long_i , parity ) ; \n dest += i ; \n dest_len -= i ; \n i += split_field_half_ref_list ( dest , dest_len , src + long_i , \n src_len - long_i , parity ) ; \n return i ; \n }", "idx": 5067}
{"project": "FFmpeg", "commit_id": "5a840f636491fa52a003fb8f674f6db39d5edd66", "target": 0, "func": "SwsFunc ff_yuv2rgb_init_mmx ( SwsContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( c -> srcFormat != PIX_FMT_YUV420P && \n c -> srcFormat != PIX_FMT_YUVA420P ) \n return NULL ; \n #if HAVE_MMX2  \n  \n  if ( cpu_flags & AV_CPU_FLAG_MMX2 ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX2 ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX2 ; \n } \n } \n #endif \n if ( cpu_flags & AV_CPU_FLAG_MMX ) { \n switch ( c -> dstFormat ) { \n case PIX_FMT_RGB32 : \n if ( c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS && CONFIG_SWSCALE_ALPHA  \n  \n  return yuva420_rgb32_MMX ; \n #endif \n break ; \n } else return yuv420_rgb32_MMX ; \n case PIX_FMT_BGR32 : \n if ( c -> srcFormat == PIX_FMT_YUVA420P ) { \n #if HAVE_7REGS && CONFIG_SWSCALE_ALPHA  \n  \n  return yuva420_bgr32_MMX ; \n #endif \n break ; \n } else return yuv420_bgr32_MMX ; \n case PIX_FMT_RGB24 : return yuv420_rgb24_MMX ; \n case PIX_FMT_BGR24 : return yuv420_bgr24_MMX ; \n case PIX_FMT_RGB565 : return yuv420_rgb16_MMX ; \n case PIX_FMT_RGB555 : return yuv420_rgb15_MMX ; \n } \n } \n return NULL ; \n }", "idx": 5069}
{"project": "FFmpeg", "commit_id": "fd5293d216316752fd34dcb29051e748f076e5fb", "target": 1, "func": "static int start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TInterlaceContext * tinterlace = ctx -> priv ; \n avfilter_unref_buffer ( tinterlace -> cur ) ; \n tinterlace -> cur = tinterlace -> next ; \n tinterlace -> next = picref ; \n return 0 ; \n }", "idx": 5076}
{"project": "FFmpeg", "commit_id": "bbcc09518e0d1efc189a43ff0120c1a31f51c802", "target": 0, "func": "static void write_odml_master ( AVFormatContext * s , int stream_index ) \n { \n AVIOContext * pb = s -> pb ; \n AVStream * st = s -> streams [ stream_index ] ; \n AVCodecContext * enc = st -> codec ; \n AVIStream * avist = st -> priv_data ; \n unsigned char tag [ 5 ] ; \n int j ; \n avist -> indexes . entry = avist -> indexes . ents_allocated = 0 ; \n avist -> indexes . indx_start = ff_start_tag ( pb , \" \" ) ; \n avio_wl16 ( pb , 4 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_wl32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , avi_stream2fourcc ( tag , stream_index , enc -> codec_type ) ) ; \n avio_wl64 ( pb , 0 ) ; \n avio_wl32 ( pb , 0 ) ; \n for ( j = 0 ; j < AVI_MASTER_INDEX_SIZE * 2 ; j ++ ) \n avio_wl64 ( pb , 0 ) ; \n ff_end_tag ( pb , avist -> indexes . indx_start ) ; \n }", "idx": 5077}
{"project": "FFmpeg", "commit_id": "85e7386ae0d33ede4c575d4df4c1faae6c906338", "target": 0, "func": "static void cook_imlt ( COOKContext * q , float * inbuffer , float * outbuffer ) \n { \n int i ; \n q -> mdct_ctx . fft . imdct_calc ( & q -> mdct_ctx , outbuffer , inbuffer , q -> mdct_tmp ) ; \n for ( i = 0 ; i < q -> samples_per_channel ; i ++ ) { \n float tmp = outbuffer [ i ] ; \n outbuffer [ i ] = q -> mlt_window [ i ] * outbuffer [ q -> samples_per_channel + i ] ; \n outbuffer [ q -> samples_per_channel + i ] = q -> mlt_window [ q -> samples_per_channel - 1 - i ] * - tmp ; \n } \n }", "idx": 5078}
{"project": "FFmpeg", "commit_id": "f1f298cd32b18bb910ff045df327ccb139628db7", "target": 0, "func": "static int mp3_write_trailer ( struct AVFormatContext * s ) \n { \n uint8_t buf [ ID3v1_TAG_SIZE ] ; \n MP3Context * mp3 = s -> priv_data ; \n if ( id3v1_create_tag ( s , buf ) > 0 ) { \n avio_write ( s -> pb , buf , ID3v1_TAG_SIZE ) ; \n } \n if ( mp3 && mp3 -> nb_frames_offset ) { \n avio_seek ( s -> pb , mp3 -> nb_frames_offset , SEEK_SET ) ; \n avio_wb32 ( s -> pb , s -> streams [ 0 ] -> nb_frames ) ; \n avio_seek ( s -> pb , 0 , SEEK_END ) ; \n } \n avio_flush ( s -> pb ) ; \n return 0 ; \n }", "idx": 5079}
{"project": "FFmpeg", "commit_id": "eed752d61da332fb13e9893a175a90fed7b1d7d3", "target": 0, "func": "static void SET_TYPE ( resample_one ) ( ResampleContext * c , \n void * dst0 , int dst_index , const void * src0 , \n int src_size , int index , int frac ) \n { \n FELEM * dst = dst0 ; \n const FELEM * src = src0 ; \n int i ; \n int sample_index = index >> c -> phase_shift ; \n FELEM2 val = 0 ; \n FELEM * filter = ( ( FELEM * ) c -> filter_bank ) + \n c -> filter_length * ( index & c -> phase_mask ) ; \n if ( sample_index < 0 ) { \n for ( i = 0 ; i < c -> filter_length ; i ++ ) \n val += src [ FFABS ( sample_index + i ) % src_size ] * \n ( FELEM2 ) filter [ i ] ; \n } else if ( c -> linear ) { \n FELEM2 v2 = 0 ; \n for ( i = 0 ; i < c -> filter_length ; i ++ ) { \n val += src [ abs ( sample_index + i ) ] * ( FELEM2 ) filter [ i ] ; \n v2 += src [ abs ( sample_index + i ) ] * ( FELEM2 ) filter [ i + c -> filter_length ] ; \n } \n val += ( v2 - val ) * ( FELEML ) frac / c -> src_incr ; \n } else { \n for ( i = 0 ; i < c -> filter_length ; i ++ ) \n val += src [ sample_index + i ] * ( FELEM2 ) filter [ i ] ; \n } \n OUT ( dst [ dst_index ] , val ) ; \n }", "idx": 5095}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int thp_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' \\0 ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 5106}
{"project": "FFmpeg", "commit_id": "64476d7ee86e01f43312dc5dff850d641d2b6c9a", "target": 1, "func": "static int read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n avio_seek ( s -> pb , FFMAX ( timestamp , 0 ) * st -> codec -> width * st -> codec -> height * 4 , SEEK_SET ) ; \n return 0 ; \n }", "idx": 5119}
{"project": "FFmpeg", "commit_id": "f73e3938ac70524826664855210446c3739c4a5e", "target": 0, "func": "static int mp3_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret ; \n ret = av_get_packet ( s -> pb , pkt , MP3_PACKET_SIZE ) ; \n pkt -> stream_index = 0 ; \n if ( ret <= 0 ) { \n return AVERROR ( EIO ) ; \n } \n if ( ret > ID3v1_TAG_SIZE && \n memcmp ( & pkt -> data [ ret - ID3v1_TAG_SIZE ] , \" \" , 3 ) == 0 ) \n ret -= ID3v1_TAG_SIZE ; \n pkt -> size = ret ; \n return ret ; \n }", "idx": 5123}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add_mmx ( uint8_t * dst , int16_t * block , int stride ) \n { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( block ) ) ; \n __asm__ volatile ( \n IDCT4_1D ( % % mm2 , % % mm1 , % % mm0 , % % mm3 , % % mm4 ) \n \" \\n \\t \"  \n TRANSPOSE4 ( % % mm3 , % % mm1 , % % mm0 , % % mm2 , % % mm4 ) \n \" \\n \\t \"  \n IDCT4_1D ( % % mm4 , % % mm2 , % % mm3 , % % mm0 , % % mm1 ) \n \" \\n \\t \" \n :: \" \" ( ff_pw_32 ) ) ; \n __asm__ volatile ( \n STORE_DIFF_4P ( % % mm0 , % % mm1 , % % mm7 ) \n \" \\n \\t \"  \n STORE_DIFF_4P ( % % mm2 , % % mm1 , % % mm7 ) \n \" \\n \\t \"  \n STORE_DIFF_4P ( % % mm3 , % % mm1 , % % mm7 ) \n \" \\n \\t \"  \n STORE_DIFF_4P ( % % mm4 , % % mm1 , % % mm7 ) \n : \" \" ( dst ) \n : \" \" ( ( x86_reg ) stride ) \n ) ; \n }", "idx": 5124}
{"project": "FFmpeg", "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51", "target": 0, "func": "static void vdadec_flush ( AVCodecContext * avctx ) \n { \n return ff_h264_decoder . flush ( avctx ) ; \n }", "idx": 5125}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_decode_init ( AVCodecContext * avctx ) \n { \n ADXContext * c = avctx -> priv_data ; \n c -> prev [ 0 ] . s1 = 0 ; \n c -> prev [ 0 ] . s2 = 0 ; \n c -> prev [ 1 ] . s1 = 0 ; \n c -> prev [ 1 ] . s2 = 0 ; \n c -> header_parsed = 0 ; \n c -> in_temp = 0 ; \n return 0 ; \n }", "idx": 5128}
{"project": "FFmpeg", "commit_id": "c8b835954ae4aef797112afda3b52f8dfe3c7b74", "target": 1, "func": "static int xan_huffman_decode ( unsigned char * dest , int dest_len , \n const unsigned char * src , int src_len ) \n { \n unsigned char byte = * src ++ ; \n unsigned char ival = byte + 0x16 ; \n const unsigned char * ptr = src + byte * 2 ; \n int ptr_len = src_len - 1 - byte * 2 ; \n unsigned char val = ival ; \n unsigned char * dest_end = dest + dest_len ; \n GetBitContext gb ; \n if ( ptr_len < 0 ) \n return AVERROR_INVALIDDATA ; \n init_get_bits ( & gb , ptr , ptr_len * 8 ) ; \n while ( val != 0x16 ) { \n val = src [ val - 0x17 + get_bits1 ( & gb ) * byte ] ; \n if ( val < 0x16 ) { \n if ( dest >= dest_end ) \n return 0 ; \n * dest ++ = val ; \n val = ival ; \n } \n } \n return 0 ; \n }", "idx": 5130}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static int init ( AVCodecParserContext * s ) \n { \n H264Context * h = s -> priv_data ; \n h -> thread_context [ 0 ] = h ; \n return 0 ; \n }", "idx": 5131}
{"project": "FFmpeg", "commit_id": "32be264cea542b4dc721b10092bf1dfe511a28ee", "target": 1, "func": "static void avoid_clipping ( AACEncContext * s , SingleChannelElement * sce ) \n { \n int start , i , j , w ; \n if ( sce -> ics . clip_avoidance_factor < 1.0f ) { \n for ( w = 0 ; w < sce -> ics . num_windows ; w ++ ) { \n start = 0 ; \n for ( i = 0 ; i < sce -> ics . max_sfb ; i ++ ) { \n float * swb_coeffs = sce -> coeffs + start + w * 128 ; \n for ( j = 0 ; j < sce -> ics . swb_sizes [ i ] ; j ++ ) \n swb_coeffs [ j ] *= sce -> ics . clip_avoidance_factor ; \n start += sce -> ics . swb_sizes [ i ] ; \n } \n } \n } \n }", "idx": 5133}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_refpass ( Jpeg2000T1Context * t1 , int width , int height , int * nmsedec , int bpno ) \n { \n int y0 , x , y , mask = 1 << ( bpno + NMSEDEC_FRACBITS ) ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) == JPEG2000_T1_SIG ) { \n int ctxno = ff_jpeg2000_getrefctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] ) ; \n * nmsedec += getnmsedec_ref ( t1 -> data [ y ] [ x ] , bpno + NMSEDEC_FRACBITS ) ; \n ff_mqc_encode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno , t1 -> data [ y ] [ x ] & mask ? 1 : 0 ) ; \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_REF ; \n } \n }", "idx": 5151}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int mb_var_thread ( AVCodecContext * c , void * arg ) { \n MpegEncContext * s = * ( void * * ) arg ; \n int mb_x , mb_y ; \n for ( mb_y = s -> start_mb_y ; mb_y < s -> end_mb_y ; mb_y ++ ) { \n for ( mb_x = 0 ; mb_x < s -> mb_width ; mb_x ++ ) { \n int xx = mb_x * 16 ; \n int yy = mb_y * 16 ; \n uint8_t * pix = s -> new_picture . f . data [ 0 ] + ( yy * s -> linesize ) + xx ; \n int varc ; \n int sum = s -> dsp . pix_sum ( pix , s -> linesize ) ; \n varc = ( s -> dsp . pix_norm1 ( pix , s -> linesize ) - ( ( ( unsigned ) sum * sum ) >> 8 ) + 500 + 128 ) >> 8 ; \n s -> current_picture . mb_var [ s -> mb_stride * mb_y + mb_x ] = varc ; \n s -> current_picture . mb_mean [ s -> mb_stride * mb_y + mb_x ] = ( sum + 128 ) >> 8 ; \n s -> me . mb_var_sum_temp += varc ; \n } \n } \n return 0 ; \n }", "idx": 5154}
{"project": "FFmpeg", "commit_id": "f5e717f3c735af5c941b458d42615c97028aa916", "target": 1, "func": "static int socket_open_listen ( struct sockaddr_in * my_addr ) \n { \n int server_fd , tmp ; \n server_fd = socket ( AF_INET , SOCK_STREAM , 0 ) ; \n if ( server_fd < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n tmp = 1 ; \n setsockopt ( server_fd , SOL_SOCKET , SO_REUSEADDR , & tmp , sizeof ( tmp ) ) ; \n if ( bind ( server_fd , ( struct sockaddr * ) my_addr , sizeof ( * my_addr ) ) < 0 ) { \n char bindmsg [ 32 ] ; \n snprintf ( bindmsg , sizeof ( bindmsg ) , \" \" , ntohs ( my_addr -> sin_port ) ) ; \n perror ( bindmsg ) ; \n closesocket ( server_fd ) ; \n return -1 ; \n } \n if ( listen ( server_fd , 5 ) < 0 ) { \n perror ( \" \" ) ; \n closesocket ( server_fd ) ; \n return -1 ; \n } \n ff_socket_nonblock ( server_fd , 1 ) ; \n return server_fd ; \n }", "idx": 5159}
{"project": "FFmpeg", "commit_id": "276839b8de7ff836a529bbd6221f615a343b23e1", "target": 0, "func": "static int dxva2_h264_decode_slice ( AVCodecContext * avctx , \n const uint8_t * buffer , \n uint32_t size ) \n { \n const H264Context * h = avctx -> priv_data ; \n struct dxva_context * ctx = avctx -> hwaccel_context ; \n const Picture * current_picture = h -> cur_pic_ptr ; \n struct dxva2_picture_context * ctx_pic = current_picture -> hwaccel_picture_private ; \n unsigned position ; \n if ( ctx_pic -> slice_count >= MAX_SLICES ) \n return -1 ; \n if ( ! ctx_pic -> bitstream ) \n ctx_pic -> bitstream = buffer ; \n ctx_pic -> bitstream_size += size ; \n position = buffer - ctx_pic -> bitstream ; \n if ( is_slice_short ( ctx ) ) \n fill_slice_short ( & ctx_pic -> slice_short [ ctx_pic -> slice_count ] , \n position , size ) ; \n else \n fill_slice_long ( avctx , & ctx_pic -> slice_long [ ctx_pic -> slice_count ] , \n position , size ) ; \n ctx_pic -> slice_count ++ ; \n if ( h -> slice_type != AV_PICTURE_TYPE_I && h -> slice_type != AV_PICTURE_TYPE_SI ) \n ctx_pic -> pp . wBitFields &= ~ ( 1 << 15 ) ; \n return 0 ; \n }", "idx": 5182}
{"project": "FFmpeg", "commit_id": "1509c018bd5b054a2354e20021ccbac9c934d213", "target": 1, "func": "static int mpegts_probe ( AVProbeData * p ) \n { \n const int size = p -> buf_size ; \n int score , fec_score , dvhs_score ; \n int check_count = size / TS_FEC_PACKET_SIZE ; \n #define CHECK_COUNT  10  \n  \n  \n  \n  if ( check_count < CHECK_COUNT ) \n return AVERROR_INVALIDDATA ; \n score = analyze ( p -> buf , TS_PACKET_SIZE * check_count , \n TS_PACKET_SIZE , NULL ) * CHECK_COUNT / check_count ; \n dvhs_score = analyze ( p -> buf , TS_DVHS_PACKET_SIZE * check_count , \n TS_DVHS_PACKET_SIZE , NULL ) * CHECK_COUNT / check_count ; \n fec_score = analyze ( p -> buf , TS_FEC_PACKET_SIZE * check_count , \n TS_FEC_PACKET_SIZE , NULL ) * CHECK_COUNT / check_count ; \n av_dlog ( NULL , \" \\n \" , \n score , dvhs_score , fec_score ) ; \n if ( score > fec_score && score > dvhs_score && score > 6 ) \n return AVPROBE_SCORE_MAX + score - CHECK_COUNT ; \n else if ( dvhs_score > score && dvhs_score > fec_score && dvhs_score > 6 ) \n return AVPROBE_SCORE_MAX + dvhs_score - CHECK_COUNT ; \n else if ( fec_score > 6 ) \n return AVPROBE_SCORE_MAX + fec_score - CHECK_COUNT ; \n else \n return AVERROR_INVALIDDATA ; \n }", "idx": 5184}
{"project": "FFmpeg", "commit_id": "0be95996d0a07a2f92105da1ed8c13d239c46ad8", "target": 1, "func": "static inline int l1_unscale ( int n , int mant , int scale_factor ) \n { \n int shift , mod ; \n int64_t val ; \n shift = scale_factor_modshift [ scale_factor ] ; \n mod = shift & 3 ; \n shift >>= 2 ; \n val = MUL64 ( mant + ( -1 << n ) + 1 , scale_factor_mult [ n - 1 ] [ mod ] ) ; \n shift += n ; \n return ( int ) ( ( val + ( 1LL << ( shift - 1 ) ) ) >> shift ) ; \n }", "idx": 5185}
{"project": "FFmpeg", "commit_id": "407a3d94f566a68c7a862fcdac812bf53741af94", "target": 0, "func": "matroska_read_packet ( AVFormatContext * s , \n AVPacket * pkt )  \n { \n MatroskaDemuxContext * matroska = s -> priv_data ; \n int res = 0 ; \n uint32_t id ; \n while ( matroska_deliver_packet ( matroska , pkt ) ) { \n if ( matroska -> done ) \n return AVERROR_IO ; \n while ( res == 0 ) { \n if ( ! ( id = ebml_peek_id ( matroska , & matroska -> level_up ) ) ) { \n return AVERROR_IO ; \n } else if ( matroska -> level_up ) { \n matroska -> level_up -- ; \n break ; \n } \n switch ( id ) { \n case MATROSKA_ID_CLUSTER : \n if ( ( res = ebml_read_master ( matroska , & id ) ) < 0 ) \n break ; \n if ( ( res = matroska_parse_cluster ( matroska ) ) == 0 ) \n res = 1 ; \n break ; \n default : \n case EBML_ID_VOID : \n res = ebml_read_skip ( matroska ) ; \n break ; \n } \n if ( matroska -> level_up ) { \n matroska -> level_up -- ; \n break ; \n } \n } \n if ( res == -1 ) \n matroska -> done = 1 ; \n } \n return 0 ; \n }", "idx": 5225}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libopenjpeg_encode_close ( AVCodecContext * avctx ) \n { \n LibOpenJPEGContext * ctx = avctx -> priv_data ; \n opj_destroy_compress ( ctx -> compress ) ; \n opj_image_destroy ( ctx -> image ) ; \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 5236}
{"project": "FFmpeg", "commit_id": "dc179ec81902e3c9d327f9e818454f2849308000", "target": 0, "func": "void ff_sws_init_swScale_altivec ( SwsContext * c ) \n { \n enum PixelFormat dstFormat = c -> dstFormat ; \n if ( ! ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) ) \n return ; \n c -> hScale = hScale_altivec_real ; \n if ( ! is16BPS ( dstFormat ) && ! is9_OR_10BPS ( dstFormat ) ) { \n c -> yuv2yuvX = yuv2yuvX_altivec_real ; \n } \n if ( ! ( c -> flags & ( SWS_BITEXACT | SWS_FULL_CHR_H_INT ) ) && ! c -> alpPixBuf && \n ( c -> dstFormat == PIX_FMT_ABGR || c -> dstFormat == PIX_FMT_BGRA || \n c -> dstFormat == PIX_FMT_BGR24 || c -> dstFormat == PIX_FMT_RGB24 || \n c -> dstFormat == PIX_FMT_RGBA || c -> dstFormat == PIX_FMT_ARGB ) ) { \n c -> yuv2packedX = ff_yuv2packedX_altivec ; \n } \n }", "idx": 5237}
{"project": "FFmpeg", "commit_id": "5c95de150f3b18f2e76fed670d6ea579feab1206", "target": 1, "func": "static int xvid_strip_vol_header ( AVCodecContext * avctx , AVPacket * pkt , \n unsigned int header_len , \n unsigned int frame_len ) \n { \n int vo_len = 0 , i ; \n for ( i = 0 ; i < header_len - 3 ; i ++ ) { \n if ( pkt -> data [ i ] == 0x00 && \n pkt -> data [ i + 1 ] == 0x00 && \n pkt -> data [ i + 2 ] == 0x01 && \n pkt -> data [ i + 3 ] == 0xB6 ) { \n vo_len = i ; \n break ; \n } \n } \n if ( vo_len > 0 ) { \n if ( ! avctx -> extradata ) { \n avctx -> extradata = av_malloc ( vo_len ) ; \n memcpy ( avctx -> extradata , pkt -> data , vo_len ) ; \n avctx -> extradata_size = vo_len ; \n } \n memmove ( pkt -> data , & pkt -> data [ vo_len ] , frame_len - vo_len ) ; \n pkt -> size = frame_len - vo_len ; \n } \n return 0 ; \n }", "idx": 5256}
{"project": "FFmpeg", "commit_id": "ddd0e23d587e3e7ae81ee8a16a079221b0232782", "target": 1, "func": "static int remove_decoded_packets ( AVFormatContext * ctx , int64_t scr ) { \n int i ; \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) { \n AVStream * st = ctx -> streams [ i ] ; \n StreamInfo * stream = st -> priv_data ; \n PacketDesc * pkt_desc ; \n while ( ( pkt_desc = stream -> predecode_packet ) \n && scr > pkt_desc -> dts ) { \n if ( stream -> buffer_index < pkt_desc -> size || \n stream -> predecode_packet == stream -> premux_packet ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n i , stream -> buffer_index , pkt_desc -> size ) ; \n break ; \n } \n stream -> buffer_index -= pkt_desc -> size ; \n stream -> predecode_packet = pkt_desc -> next ; \n av_freep ( & pkt_desc ) ; \n } \n } \n return 0 ; \n }", "idx": 5258}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x16_horizontal_add ) ( uint8_t * pix , \n const int * block_offset , \n const int16_t * block , ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n for ( i = 4 ; i < 8 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i + 4 ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 5266}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static void seek_to_maindata ( MPADecodeContext * s , long backstep ) \n { \n UINT8 * ptr ; \n ptr = s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) ; \n ptr -= backstep ; \n memcpy ( ptr , s -> inbuf1 [ s -> inbuf_index ^ 1 ] + \n BACKSTEP_SIZE + s -> old_frame_size - backstep , backstep ) ; \n init_get_bits ( & s -> gb , ptr , s -> frame_size + backstep ) ; \n s -> inbuf_index ^= 1 ; \n s -> inbuf = & s -> inbuf1 [ s -> inbuf_index ] [ BACKSTEP_SIZE ] ; \n s -> old_frame_size = s -> frame_size ; \n }", "idx": 5267}
{"project": "FFmpeg", "commit_id": "c2500635235d809e0c0ac526a7e13072ab7c8900", "target": 0, "func": "static int codec_get_buffer ( AVCodecContext * s , AVFrame * frame ) \n { \n InputStream * ist = s -> opaque ; \n FrameBuffer * buf ; \n int ret , i ; \n if ( av_image_check_size ( s -> width , s -> height , 0 , s ) ) \n return -1 ; \n if ( ! ist -> buffer_pool && ( ret = alloc_buffer ( s , ist , & ist -> buffer_pool ) ) < 0 ) \n return ret ; \n buf = ist -> buffer_pool ; \n ist -> buffer_pool = buf -> next ; \n buf -> next = NULL ; \n if ( buf -> w != s -> width || buf -> h != s -> height || buf -> pix_fmt != s -> pix_fmt ) { \n av_freep ( & buf -> base [ 0 ] ) ; \n av_free ( buf ) ; \n ist -> dr1 = 0 ; \n if ( ( ret = alloc_buffer ( s , ist , & buf ) ) < 0 ) \n return ret ; \n } \n buf -> refcount ++ ; \n frame -> opaque = buf ; \n frame -> type = FF_BUFFER_TYPE_USER ; \n frame -> extended_data = frame -> data ; \n frame -> pkt_pts = s -> pkt ? s -> pkt -> pts : AV_NOPTS_VALUE ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n frame -> base [ i ] = buf -> base [ i ] ; \n frame -> data [ i ] = buf -> data [ i ] ; \n frame -> linesize [ i ] = buf -> linesize [ i ] ; \n } \n return 0 ; \n }", "idx": 5269}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static void json_print_int ( WriterContext * wctx , const char * key , int value ) \n { \n char * key_esc = json_escape_str ( key ) ; \n if ( wctx -> nb_item ) printf ( \" \\n \" ) ; \n printf ( INDENT \" \\\" \\\" \" , key_esc ? key_esc : \" \" , value ) ; \n av_free ( key_esc ) ; \n }", "idx": 5270}
{"project": "FFmpeg", "commit_id": "c27939d871030ab79d5ef4e40ad6e4388db0c746", "target": 0, "func": "static int concat_read_packet ( AVFormatContext * avf , AVPacket * pkt ) \n { \n ConcatContext * cat = avf -> priv_data ; \n int ret ; \n int64_t delta ; \n ConcatStream * cs ; \n while ( 1 ) { \n ret = av_read_frame ( cat -> avf , pkt ) ; \n if ( ret == AVERROR_EOF ) { \n if ( ( ret = open_next_file ( avf ) ) < 0 ) \n return ret ; \n continue ; \n } \n if ( ret < 0 ) \n return ret ; \n if ( cat -> match_streams ) { \n match_streams ( avf ) ; \n cs = & cat -> cur_file -> streams [ pkt -> stream_index ] ; \n if ( cs -> out_stream_index < 0 ) { \n av_packet_unref ( pkt ) ; \n continue ; \n } \n pkt -> stream_index = cs -> out_stream_index ; \n } \n break ; \n } \n delta = av_rescale_q ( cat -> cur_file -> start_time - cat -> avf -> start_time , \n AV_TIME_BASE_Q , \n cat -> avf -> streams [ pkt -> stream_index ] -> time_base ) ; \n if ( pkt -> pts != AV_NOPTS_VALUE ) \n pkt -> pts += delta ; \n if ( pkt -> dts != AV_NOPTS_VALUE ) \n pkt -> dts += delta ; \n return ret ; \n }", "idx": 5279}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int dxa_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 4 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 5280}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static int joint_decode ( COOKContext * q , COOKSubpacket * p , float * mlt_buffer1 , \n float * mlt_buffer2 ) \n { \n int i , j , ret ; \n int decouple_tab [ SUBBAND_SIZE ] ; \n float * decode_buffer = q -> decode_buffer_0 ; \n int idx , cpl_tmp ; \n float f1 , f2 ; \n const float * cplscale ; \n memset ( decouple_tab , 0 , sizeof ( decouple_tab ) ) ; \n memset ( decode_buffer , 0 , sizeof ( q -> decode_buffer_0 ) ) ; \n memset ( mlt_buffer1 , 0 , 1024 * sizeof ( * mlt_buffer1 ) ) ; \n memset ( mlt_buffer2 , 0 , 1024 * sizeof ( * mlt_buffer2 ) ) ; \n decouple_info ( q , p , decouple_tab ) ; \n if ( ( ret = mono_decode ( q , p , decode_buffer ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < p -> js_subband_start ; i ++ ) { \n for ( j = 0 ; j < SUBBAND_SIZE ; j ++ ) { \n mlt_buffer1 [ i * 20 + j ] = decode_buffer [ i * 40 + j ] ; \n mlt_buffer2 [ i * 20 + j ] = decode_buffer [ i * 40 + 20 + j ] ; \n } \n } \n idx = ( 1 << p -> js_vlc_bits ) - 1 ; \n for ( i = p -> js_subband_start ; i < p -> subbands ; i ++ ) { \n cpl_tmp = cplband [ i ] ; \n idx -= decouple_tab [ cpl_tmp ] ; \n cplscale = q -> cplscales [ p -> js_vlc_bits - 2 ] ; \n f1 = cplscale [ decouple_tab [ cpl_tmp ] ] ; \n f2 = cplscale [ idx - 1 ] ; \n q -> decouple ( q , p , i , f1 , f2 , decode_buffer , mlt_buffer1 , mlt_buffer2 ) ; \n idx = ( 1 << p -> js_vlc_bits ) - 1 ; \n } \n return 0 ; \n }", "idx": 5299}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void calc_scales ( DCAEncContext * c ) \n { \n int band , ch ; \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n c -> scale_factor [ band ] [ ch ] = calc_one_scale ( c -> peak_cb [ band ] [ ch ] , \n c -> abits [ band ] [ ch ] , \n & c -> quant [ band ] [ ch ] ) ; \n if ( c -> lfe_channel ) \n c -> lfe_scale_factor = calc_one_scale ( c -> lfe_peak_cb , 11 , & c -> lfe_quant ) ; \n }", "idx": 5301}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_vert_16x16_msa ( uint8_t * src , uint8_t * dst , \n int32_t dst_stride ) \n { \n uint32_t row ; \n v16u8 src0 ; \n src0 = LD_UB ( src ) ; \n for ( row = 16 ; row -- ; ) { \n ST_UB ( src0 , dst ) ; \n dst += dst_stride ; \n } \n }", "idx": 5310}
{"project": "FFmpeg", "commit_id": "84dda407628e298f33d610e9e04a8b2945d24665", "target": 1, "func": "static inline void mcdc ( uint16_t * dst , uint16_t * src , int log2w , int h , int stride , int scale , int dc ) { \n int i ; \n dc *= 0x10001 ; \n switch ( log2w ) { \n case 0 : \n for ( i = 0 ; i < h ; i ++ ) { \n dst [ 0 ] = scale * src [ 0 ] + dc ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n case 1 : \n for ( i = 0 ; i < h ; i ++ ) { \n LE_CENTRIC_MUL ( dst , src , scale , dc ) ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n case 2 : \n for ( i = 0 ; i < h ; i ++ ) { \n LE_CENTRIC_MUL ( dst , src , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n case 3 : \n for ( i = 0 ; i < h ; i ++ ) { \n LE_CENTRIC_MUL ( dst , src , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 4 , src + 4 , scale , dc ) ; \n LE_CENTRIC_MUL ( dst + 6 , src + 6 , scale , dc ) ; \n if ( scale ) src += stride ; \n dst += stride ; \n } \n break ; \n default : assert ( 0 ) ; \n } \n }", "idx": 5311}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_vlcs ( void ) \n { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_vlc ( & dc_lum_vlc , DC_VLC_BITS , 12 , \n vlc_dc_lum_bits , 1 , 1 , \n vlc_dc_lum_code , 2 , 2 ) ; \n init_vlc ( & dc_chroma_vlc , DC_VLC_BITS , 12 , \n vlc_dc_chroma_bits , 1 , 1 , \n vlc_dc_chroma_code , 2 , 2 ) ; \n init_vlc ( & mv_vlc , MV_VLC_BITS , 17 , \n & mbMotionVectorTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbMotionVectorTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mbincr_vlc , MBINCR_VLC_BITS , 36 , \n & mbAddrIncrTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbAddrIncrTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_pat_vlc , MB_PAT_VLC_BITS , 64 , \n & mbPatTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbPatTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_ptype_vlc , MB_PTYPE_VLC_BITS , 7 , \n & table_mb_ptype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_ptype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_btype_vlc , MB_BTYPE_VLC_BITS , 11 , \n & table_mb_btype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_btype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_rl ( & rl_mpeg1 ) ; \n init_rl ( & rl_mpeg2 ) ; \n init_2d_vlc_rl ( & rl_mpeg1 ) ; \n init_2d_vlc_rl ( & rl_mpeg2 ) ; \n } \n }", "idx": 5312}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static enum AVPixelFormat get_format ( HEVCContext * s , const HEVCSPS * sps ) \n { \n #define HWACCEL_MAX  (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL)  \n  \n  enum AVPixelFormat pix_fmts [ HWACCEL_MAX + 2 ] , * fmt = pix_fmts ; \n switch ( sps -> pix_fmt ) { \n case AV_PIX_FMT_YUV420P : \n case AV_PIX_FMT_YUVJ420P : \n #if CONFIG_HEVC_DXVA2_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_DXVA2_VLD ; \n #endif \n #if CONFIG_HEVC_D3D11VA_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_D3D11VA_VLD ; \n #endif \n #if CONFIG_HEVC_VAAPI_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VAAPI ; \n #endif \n #if CONFIG_HEVC_VDPAU_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VDPAU ; \n #endif \n break ; \n case AV_PIX_FMT_YUV420P10 : \n #if CONFIG_HEVC_DXVA2_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_DXVA2_VLD ; \n #endif \n #if CONFIG_HEVC_D3D11VA_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_D3D11VA_VLD ; \n #endif \n #if CONFIG_HEVC_VAAPI_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VAAPI ; \n #endif \n break ; \n } \n * fmt ++ = sps -> pix_fmt ; \n * fmt = AV_PIX_FMT_NONE ; \n return ff_thread_get_format ( s -> avctx , pix_fmts ) ; \n }", "idx": 5316}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_fft_init_x86 ( FFTContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) { \n s -> imdct_calc = ff_imdct_calc_3dnow ; \n s -> imdct_half = ff_imdct_half_3dnow ; \n s -> fft_calc = ff_fft_calc_3dnow ; \n } \n if ( EXTERNAL_AMD3DNOWEXT ( cpu_flags ) ) { \n s -> imdct_calc = ff_imdct_calc_3dnowext ; \n s -> imdct_half = ff_imdct_half_3dnowext ; \n s -> fft_calc = ff_fft_calc_3dnowext ; \n } \n #endif \n if ( EXTERNAL_SSE ( cpu_flags ) ) { \n s -> imdct_calc = ff_imdct_calc_sse ; \n s -> imdct_half = ff_imdct_half_sse ; \n s -> fft_permute = ff_fft_permute_sse ; \n s -> fft_calc = ff_fft_calc_sse ; \n s -> fft_permutation = FF_FFT_PERM_SWAP_LSBS ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) && s -> nbits >= 5 ) { \n s -> imdct_half = ff_imdct_half_avx ; \n s -> fft_calc = ff_fft_calc_avx ; \n s -> fft_permutation = FF_FFT_PERM_AVX ; \n } \n }", "idx": 5317}
{"project": "FFmpeg", "commit_id": "9076a6a943f7855756222181698aba78d3773d8f", "target": 1, "func": "static void print_samplesref ( AVFilterBufferRef * samplesref ) \n { \n const AVFilterBufferRefAudioProps * props = samplesref -> audio ; \n const int n = props -> nb_samples * av_get_channel_layout_nb_channels ( props -> channel_layout ) ; \n const uint16_t * p = ( uint16_t * ) samplesref -> data [ 0 ] ; \n const uint16_t * p_end = p + n ; \n while ( p < p_end ) { \n fputc ( * p & 0xff , stdout ) ; \n fputc ( * p >> 8 & 0xff , stdout ) ; \n p ++ ; \n } \n fflush ( stdout ) ; \n }", "idx": 5322}
{"project": "FFmpeg", "commit_id": "49e5dcbce5f9e08ec375fd54c413148beb81f1d7", "target": 1, "func": "static int h261_decode_gob_header ( H261Context * h ) { \n unsigned int val ; \n MpegEncContext * const s = & h -> s ; \n val = show_bits ( & s -> gb , 15 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n h -> gob_number = get_bits ( & s -> gb , 4 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n while ( get_bits1 ( & s -> gb ) != 0 ) { \n skip_bits ( & s -> gb , 8 ) ; \n } \n if ( s -> qscale == 0 ) \n return -1 ; \n h -> current_mba = 0 ; \n h -> mba_diff = 0 ; \n return 0 ; \n }", "idx": 5326}
{"project": "FFmpeg", "commit_id": "f4a8a0080537484154bb74e08ec76cbcbd25484b", "target": 1, "func": "static int read_rle_sgi ( uint8_t * out_buf , SgiState * s ) \n { \n uint8_t * dest_row ; \n unsigned int len = s -> height * s -> depth * 4 ; \n GetByteContext g_table = s -> g ; \n unsigned int y , z ; \n unsigned int start_offset ; \n if ( len * 2 > bytestream2_get_bytes_left ( & s -> g ) ) { \n return AVERROR_INVALIDDATA ; \n } \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n dest_row = out_buf ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n dest_row -= s -> linesize ; \n start_offset = bytestream2_get_be32 ( & g_table ) ; \n bytestream2_seek ( & s -> g , start_offset , SEEK_SET ) ; \n if ( expand_rle_row ( s , dest_row + z , dest_row + FFABS ( s -> linesize ) , \n s -> depth ) != s -> width ) { \n return AVERROR_INVALIDDATA ; \n } \n } \n } \n return 0 ; \n }", "idx": 5329}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( uyvyToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i + 1 ] ; \n #endif \n }", "idx": 5330}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yv12toyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 5331}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static av_always_inline void filter_common ( uint8_t * p , ptrdiff_t stride , int is4tap ) \n { \n LOAD_PIXELS \n int a , f1 , f2 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a = 3 * ( q0 - p0 ) ; \n if ( is4tap ) \n a += clip_int8 ( p1 - q1 ) ; \n a = clip_int8 ( a ) ; \n f1 = FFMIN ( a + 4 , 127 ) >> 3 ; \n f2 = FFMIN ( a + 3 , 127 ) >> 3 ; \n p [ -1 * stride ] = cm [ p0 + f2 ] ; \n p [ 0 * stride ] = cm [ q0 - f1 ] ; \n if ( ! is4tap ) { \n a = ( f1 + 1 ) >> 1 ; \n p [ -2 * stride ] = cm [ p1 + a ] ; \n p [ 1 * stride ] = cm [ q1 - a ] ; \n } \n }", "idx": 5332}
{"project": "FFmpeg", "commit_id": "e278056fbad7405fc47901faea7de98db003a0fa", "target": 0, "func": "static int theora_decode_init ( AVCodecContext * avctx ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n GetBitContext gb ; \n int ptype ; \n uint8_t * p = avctx -> extradata ; \n int op_bytes , i ; \n s -> theora = 1 ; \n if ( ! avctx -> extradata_size ) \n { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n op_bytes = * ( p ++ ) << 8 ; \n op_bytes += * ( p ++ ) ; \n init_get_bits ( & gb , p , op_bytes ) ; \n p += op_bytes ; \n ptype = get_bits ( & gb , 8 ) ; \n debug_vp3 ( \" \\n \" , ptype ) ; \n if ( ! ( ptype & 0x80 ) ) \n { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n skip_bits ( & gb , 6 * 8 ) ; \n switch ( ptype ) \n { \n case 0x80 : \n theora_decode_header ( avctx , gb ) ; \n break ; \n case 0x81 : \n break ; \n case 0x82 : \n theora_decode_tables ( avctx , gb ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ptype & ~ 0x80 ) ; \n break ; \n } \n } \n vp3_decode_init ( avctx ) ; \n return 0 ; \n }", "idx": 5334}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pcm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> frame_size = 0 ; \n switch ( avctx -> codec -> id ) { \n case AV_CODEC_ID_PCM_ALAW : \n pcm_alaw_tableinit ( ) ; \n break ; \n case AV_CODEC_ID_PCM_MULAW : \n pcm_ulaw_tableinit ( ) ; \n break ; \n default : \n break ; \n } \n avctx -> bits_per_coded_sample = av_get_bits_per_sample ( avctx -> codec -> id ) ; \n avctx -> block_align = avctx -> channels * avctx -> bits_per_coded_sample / 8 ; \n avctx -> bit_rate = avctx -> block_align * avctx -> sample_rate * 8 ; \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 5335}
{"project": "FFmpeg", "commit_id": "21bfeec27f933e18e7aac52ec025831353f47430", "target": 0, "func": "void ff_aac_apply_tns ( SingleChannelElement * sce ) \n { \n const int mmm = FFMIN ( sce -> ics . tns_max_bands , sce -> ics . max_sfb ) ; \n float * coef = sce -> pcoeffs ; \n TemporalNoiseShaping * tns = & sce -> tns ; \n int w , filt , m , i ; \n int bottom , top , order , start , end , size , inc ; \n float * lpc , tmp [ TNS_MAX_ORDER + 1 ] ; \n for ( w = 0 ; w < sce -> ics . num_windows ; w ++ ) { \n bottom = sce -> ics . num_swb ; \n for ( filt = 0 ; filt < tns -> n_filt [ w ] ; filt ++ ) { \n top = bottom ; \n bottom = FFMAX ( 0 , top - tns -> length [ w ] [ filt ] ) ; \n order = tns -> order [ w ] [ filt ] ; \n lpc = tns -> coef [ w ] [ filt ] ; \n if ( ! order ) \n continue ; \n start = sce -> ics . swb_offset [ FFMIN ( bottom , mmm ) ] ; \n end = sce -> ics . swb_offset [ FFMIN ( top , mmm ) ] ; \n if ( ( size = end - start ) <= 0 ) \n continue ; \n if ( tns -> direction [ w ] [ filt ] ) { \n inc = -1 ; \n start = end - 1 ; \n } else { \n inc = 1 ; \n } \n start += w * 128 ; \n if ( ! sce -> ics . ltp . present ) { \n for ( m = 0 ; m < size ; m ++ , start += inc ) \n for ( i = 1 ; i <= FFMIN ( m , order ) ; i ++ ) \n coef [ start ] += coef [ start - i * inc ] * lpc [ i - 1 ] ; \n } else { \n for ( m = 0 ; m < size ; m ++ , start += inc ) { \n tmp [ 0 ] = coef [ start ] ; \n for ( i = 1 ; i <= FFMIN ( m , order ) ; i ++ ) \n coef [ start ] += tmp [ i ] * lpc [ i - 1 ] ; \n for ( i = order ; i > 0 ; i -- ) \n tmp [ i ] = tmp [ i - 1 ] ; \n } \n } \n } \n } \n }", "idx": 5338}
{"project": "FFmpeg", "commit_id": "3ca8a2328878ebdb203e49d0a060df1b5337a370", "target": 0, "func": "static int ff_interleave_new_audio_packet ( AVFormatContext * s , AVPacket * pkt , \n int stream_index , int flush ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n int size = FFMIN ( av_fifo_size ( aic -> fifo ) , * aic -> samples * aic -> sample_size ) ; \n if ( ! size || ( ! flush && size == av_fifo_size ( aic -> fifo ) ) ) \n return 0 ; \n av_new_packet ( pkt , size ) ; \n av_fifo_generic_read ( aic -> fifo , pkt -> data , size , NULL ) ; \n pkt -> dts = pkt -> pts = aic -> dts ; \n pkt -> duration = av_rescale_q ( * aic -> samples , st -> time_base , aic -> time_base ) ; \n pkt -> stream_index = stream_index ; \n aic -> dts += pkt -> duration ; \n aic -> samples ++ ; \n if ( ! * aic -> samples ) \n aic -> samples = aic -> samples_per_frame ; \n return size ; \n }", "idx": 5351}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_nal_sei_frame_packing_arrangement ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n get_ue_golomb ( gb ) ; \n s -> sei_frame_packing_present = ! get_bits1 ( gb ) ; \n if ( s -> sei_frame_packing_present ) { \n s -> frame_packing_arrangement_type = get_bits ( gb , 7 ) ; \n s -> quincunx_subsampling = get_bits1 ( gb ) ; \n s -> content_interpretation_type = get_bits ( gb , 6 ) ; \n skip_bits ( gb , 6 ) ; \n if ( ! s -> quincunx_subsampling && s -> frame_packing_arrangement_type != 5 ) \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 8 ) ; \n skip_bits1 ( gb ) ; \n } \n skip_bits1 ( gb ) ; \n return 0 ; \n }", "idx": 5354}
{"project": "FFmpeg", "commit_id": "4527ec2216109867498edc3ac8a17fd879b5d017", "target": 1, "func": "static int decode_blocks ( SnowContext * s ) { \n int x , y ; \n int w = s -> b_width ; \n int h = s -> b_height ; \n int res ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n if ( ( res = decode_q_branch ( s , 0 , x , y ) ) < 0 ) \n return res ; \n } \n } \n return 0 ; \n }", "idx": 5360}
{"project": "FFmpeg", "commit_id": "2171dfae8c065878a2e130390eb78cf2947a5b69", "target": 1, "func": "static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) \n { \n GetByteContext * gb = & s -> gb ; \n RangeCoder * rc = & s -> rc ; \n unsigned totfr = pixel -> total_freq ; \n unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; \n int i , j , ret , c , cnt_c ; \n if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) \n return ret ; \n while ( x < 16 ) { \n cnt_x = pixel -> lookup [ x ] ; \n if ( value >= cumfr + cnt_x ) \n cumfr += cnt_x ; \n else \n break ; \n x ++ ; \n c = x * 16 ; \n cnt_c = 0 ; \n while ( c < 256 ) { \n cnt_c = pixel -> freq [ c ] ; \n if ( value >= cumfr + cnt_c ) \n cumfr += cnt_c ; \n else \n break ; \n c ++ ; \n if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) \n return ret ; \n pixel -> freq [ c ] = cnt_c + step ; \n pixel -> lookup [ x ] = cnt_x + step ; \n totfr += step ; \n if ( totfr > BOT ) { \n totfr = 0 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; \n pixel -> freq [ i ] = nc ; \n totfr += nc ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n unsigned sum = 0 ; \n unsigned i16_17 = i << 4 ; \n for ( j = 0 ; j < 16 ; j ++ ) \n sum += pixel -> freq [ i16_17 + j ] ; \n pixel -> lookup [ i ] = sum ; \n pixel -> total_freq = totfr ; \n * rval = c & s -> cbits ; \n return 0 ;", "idx": 5364}
{"project": "FFmpeg", "commit_id": "69c23e6f33c38ebc03ce7f51fcb963deaff7383b", "target": 0, "func": "static void prodsum ( float * tgt , float * src , int len , int n ) \n { \n unsigned int x ; \n float * p1 , * p2 ; \n double sum ; \n while ( n >= 0 ) { \n p1 = ( p2 = src ) - n ; \n for ( sum = 0 , x = len ; x -- ; sum += ( * p1 ++ ) * ( * p2 ++ ) ) ; \n tgt [ n -- ] = sum ; \n } \n }", "idx": 5374}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred4x4_vertical_vp8_c ( uint8_t * src , const uint8_t * topright , int stride ) { \n const int lt = src [ -1 - 1 * stride ] ; \n LOAD_TOP_EDGE \n LOAD_TOP_RIGHT_EDGE  \n uint32_t v = PACK_4U8 ( ( lt + 2 * t0 + t1 + 2 ) >> 2 , \n ( t0 + 2 * t1 + t2 + 2 ) >> 2 , \n ( t1 + 2 * t2 + t3 + 2 ) >> 2 , \n ( t2 + 2 * t3 + t4 + 2 ) >> 2 ) ; \n AV_WN32A ( src + 0 * stride , v ) ; \n AV_WN32A ( src + 1 * stride , v ) ; \n AV_WN32A ( src + 2 * stride , v ) ; \n AV_WN32A ( src + 3 * stride , v ) ; \n }", "idx": 5400}
{"project": "FFmpeg", "commit_id": "1afab338575810acc5eb75c17c4adfb73504de10", "target": 1, "func": "static void end_frame ( AVFilterLink * link ) \n { \n CropContext * crop = link -> dst -> priv ; \n crop -> var_values [ N ] += 1.0 ; \n avfilter_unref_buffer ( link -> cur_buf ) ; \n avfilter_end_frame ( link -> dst -> outputs [ 0 ] ) ; \n }", "idx": 5401}
{"project": "FFmpeg", "commit_id": "f800d6508d7e8fbd8d9777b775d333a4f02112ef", "target": 1, "func": "static av_cold int dnxhd_decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n DNXHDContext * ctx = avctx -> priv_data ; \n ctx -> cid = -1 ; \n ctx -> rows = av_mallocz_array ( avctx -> thread_count , sizeof ( RowContext ) ) ; \n if ( ! ctx -> rows ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 5422}
{"project": "FFmpeg", "commit_id": "946ecd19ea752399bccc751c9339ff74b815587e", "target": 1, "func": "static int smacker_decode_bigtree ( GetBitContext * gb , HuffContext * hc , DBCtx * ctx ) \n { \n if ( hc -> current + 1 >= hc -> length ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ! get_bits1 ( gb ) ) { \n int val , i1 , i2 ; \n i1 = ctx -> v1 -> table ? get_vlc2 ( gb , ctx -> v1 -> table , SMKTREE_BITS , 3 ) : 0 ; \n i2 = ctx -> v2 -> table ? get_vlc2 ( gb , ctx -> v2 -> table , SMKTREE_BITS , 3 ) : 0 ; \n if ( i1 < 0 || i2 < 0 ) \n return AVERROR_INVALIDDATA ; \n val = ctx -> recode1 [ i1 ] | ( ctx -> recode2 [ i2 ] << 8 ) ; \n if ( val == ctx -> escapes [ 0 ] ) { \n ctx -> last [ 0 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 1 ] ) { \n ctx -> last [ 1 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 2 ] ) { \n ctx -> last [ 2 ] = hc -> current ; \n val = 0 ; \n } \n hc -> values [ hc -> current ++ ] = val ; \n return 1 ; \n } else { \n int r = 0 , r_new , t ; \n t = hc -> current ++ ; \n r = smacker_decode_bigtree ( gb , hc , ctx ) ; \n if ( r < 0 ) \n return r ; \n hc -> values [ t ] = SMK_NODE | r ; \n r ++ ; \n r_new = smacker_decode_bigtree ( gb , hc , ctx ) ; \n if ( r_new < 0 ) \n return r_new ; \n return r + r_new ; \n } \n }", "idx": 5426}
{"project": "FFmpeg", "commit_id": "a5c1c7a8b3d13c86b453558628951c3f52054ab4", "target": 0, "func": "static int mpegps_read_header ( AVFormatContext * s ) \n { \n MpegDemuxContext * m = s -> priv_data ; \n char buffer [ 7 ] ; \n int64_t last_pos = avio_tell ( s -> pb ) ; \n m -> header_state = 0xff ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n avio_get_str ( s -> pb , 6 , buffer , sizeof ( buffer ) ) ; \n if ( ! memcmp ( \" \" , buffer , 4 ) ) { \n m -> imkh_cctv = 1 ; \n } else if ( ! memcmp ( \" \" , buffer , 6 ) ) { \n m -> sofdec = 1 ; \n } else \n avio_seek ( s -> pb , last_pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 5433}
{"project": "FFmpeg", "commit_id": "90b2f3136778311fb5e097b8ee1f527518231c23", "target": 0, "func": "static void read_info_chunk ( AVFormatContext * s , int64_t size ) \n { \n AVIOContext * pb = s -> pb ; \n unsigned int i ; \n unsigned int nb_entries = avio_rb32 ( pb ) ; \n for ( i = 0 ; i < nb_entries ; i ++ ) { \n char key [ 32 ] ; \n char value [ 1024 ] ; \n avio_get_str ( pb , INT_MAX , key , sizeof ( key ) ) ; \n avio_get_str ( pb , INT_MAX , value , sizeof ( value ) ) ; \n av_dict_set ( & s -> metadata , key , value , 0 ) ; \n } \n }", "idx": 5441}
{"project": "FFmpeg", "commit_id": "9888ffb1ce5e0a17f711b01933d504c72ea29d3b", "target": 0, "func": "static int mov_read_stps ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned i , entries ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_rb32 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stps_data ) ) \n return AVERROR_INVALIDDATA ; \n sc -> stps_data = av_malloc ( entries * sizeof ( * sc -> stps_data ) ) ; \n if ( ! sc -> stps_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stps_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> stps_data [ i ] = avio_rb32 ( pb ) ; \n } \n return 0 ; \n }", "idx": 5443}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add8_sse2 ( uint8_t * * dest , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 16 ; i < 16 + 8 ; i += 2 ) { \n if ( nnzc [ scan8 [ i + 0 ] ] | nnzc [ scan8 [ i + 1 ] ] ) \n ff_x264_add8x4_idct_sse2 ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] | block [ i * 16 + 16 ] ) \n ff_h264_idct_dc_add8_mmx2 ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 5447}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hcscale_fast_c ( SwsContext * c , int16_t * dst1 , int16_t * dst2 , \n int dstWidth , const uint8_t * src1 , \n const uint8_t * src2 , int srcW , int xInc ) \n { \n int i ; \n unsigned int xpos = 0 ; \n for ( i = 0 ; i < dstWidth ; i ++ ) { \n register unsigned int xx = xpos >> 16 ; \n register unsigned int xalpha = ( xpos & 0xFFFF ) >> 9 ; \n dst1 [ i ] = ( src1 [ xx ] * ( xalpha ^ 127 ) + src1 [ xx + 1 ] * xalpha ) ; \n dst2 [ i ] = ( src2 [ xx ] * ( xalpha ^ 127 ) + src2 [ xx + 1 ] * xalpha ) ; \n xpos += xInc ;", "idx": 5451}
{"project": "FFmpeg", "commit_id": "32be264cea542b4dc721b10092bf1dfe511a28ee", "target": 1, "func": "static void apply_window_and_mdct ( AACEncContext * s , SingleChannelElement * sce , \n float * audio ) \n { \n int i ; \n float * output = sce -> ret_buf ; \n apply_window [ sce -> ics . window_sequence [ 0 ] ] ( s -> fdsp , sce , audio ) ; \n if ( sce -> ics . window_sequence [ 0 ] != EIGHT_SHORT_SEQUENCE ) \n s -> mdct1024 . mdct_calc ( & s -> mdct1024 , sce -> coeffs , output ) ; \n else \n for ( i = 0 ; i < 1024 ; i += 128 ) \n s -> mdct128 . mdct_calc ( & s -> mdct128 , sce -> coeffs + i , output + i * 2 ) ; \n memcpy ( audio , audio + 1024 , sizeof ( audio [ 0 ] ) * 1024 ) ; \n memcpy ( sce -> pcoeffs , sce -> coeffs , sizeof ( sce -> pcoeffs ) ) ; \n }", "idx": 5453}
{"project": "FFmpeg", "commit_id": "da8242e2d6f85d95239082efd0e5e2345e685a2c", "target": 0, "func": "static av_cold int eightsvx_decode_init ( AVCodecContext * avctx ) \n { \n EightSvxContext * esc = avctx -> priv_data ; \n if ( avctx -> channels < 1 || avctx -> channels > 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n switch ( avctx -> codec -> id ) { \n case AV_CODEC_ID_8SVX_FIB : esc -> table = fibonacci ; break ; \n case AV_CODEC_ID_8SVX_EXP : esc -> table = exponential ; break ; \n case AV_CODEC_ID_PCM_S8_PLANAR : \n case AV_CODEC_ID_8SVX_RAW : esc -> table = NULL ; break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , avctx -> codec -> id ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_U8P ; \n avcodec_get_frame_defaults ( & esc -> frame ) ; \n avctx -> coded_frame = & esc -> frame ; \n return 0 ; \n }", "idx": 5468}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int decode_b_mbs ( VC9Context * v ) \n { \n int x , y , current_mb = 0 , last_mb = v -> height_mb * v -> width_mb , \n i \n ; \n int direct_b_bit = 0 , skip_mb_bit = 0 ; \n int ac_pred ; \n int b_mv1 = 0 , b_mv2 = 0 , b_mv_type = 0 ; \n int mquant , mqdiff ; \n int tt_block ; \n for ( y = 0 ; y < v -> height_mb ; y ++ ) \n { \n for ( x = 0 ; x < v -> width_mb ; x ++ ) \n { \n if ( v -> direct_mb_plane [ current_mb ] ) \n direct_b_bit = get_bits ( & v -> gb , 1 ) ; \n if ( 1 \n ) \n { \n #if 0  \n  \n  skip_mb_bit = get_bits ( & v -> gb , n ) ; \n #endif \n } \n if ( ! direct_b_bit ) \n { \n if ( skip_mb_bit ) \n { \n #if 0  \n  \n  b_mv_type = get_bits ( & v -> gb , n ) ; \n #endif \n } \n else \n { \n #if 0  \n  \n  b_mv1 = get_bits ( & v -> gb , n ) ; \n #endif \n if ( 1 \n ) \n { \n b_mv_type = 0 ; \n } \n } \n } \n if ( ! skip_mb_bit ) \n { \n if ( b_mv1 != last_mb ) \n { \n GET_MQUANT ( ) ; \n if ( 1 \n ) \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n } \n else \n { \n if ( 1 \n ) \n { \n b_mv2 = 0 ; \n } \n if ( 1 \n ) \n { \n if ( 1 \n ) \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n GET_MQUANT ( ) ; \n } \n } \n } \n #if 0  \n  \n  if ( v -> ttmbf ) \n v -> ttmb = get_bits ( & v -> gb , n ) ; \n #endif \n } \n for ( i = 0 ; i < 6 ; i ++ ) \n { \n } \n current_mb ++ ; \n } \n return 0 ; \n }", "idx": 5481}
{"project": "FFmpeg", "commit_id": "ec482e738ddcb90b156cf306eb1911f7038efa19", "target": 0, "func": "av_cold void ff_flacdsp_init_x86 ( FLACDSPContext * c , enum AVSampleFormat fmt , \n int bps ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE4 ( cpu_flags ) ) { \n if ( bps > 16 && CONFIG_FLAC_DECODER ) \n c -> lpc = ff_flac_lpc_32_sse4 ; \n } \n if ( EXTERNAL_XOP ( cpu_flags ) ) { \n if ( bps > 16 ) \n c -> lpc = ff_flac_lpc_32_xop ; \n } \n #endif \n }", "idx": 5489}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void up_heap ( uint32_t val , uint32_t * heap , uint32_t * weights ) \n { \n uint32_t initial_val = heap [ val ] ; \n while ( weights [ initial_val ] < weights [ heap [ val >> 1 ] ] ) { \n heap [ val ] = heap [ val >> 1 ] ; \n val >>= 1 ; \n } \n heap [ val ] = initial_val ; \n }", "idx": 5491}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void ff_simple_idct84_add ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n idctRowCondDC_8 ( block + i * 8 ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n idct4col_add ( dest + i , line_size , block + i ) ; \n } \n }", "idx": 5493}
{"project": "FFmpeg", "commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "target": 1, "func": "static int tee_write_trailer ( AVFormatContext * avf ) \n { \n TeeContext * tee = avf -> priv_data ; \n AVFormatContext * avf2 ; \n int ret_all = 0 , ret ; \n unsigned i ; \n for ( i = 0 ; i < tee -> nb_slaves ; i ++ ) { \n avf2 = tee -> slaves [ i ] . avf ; \n if ( ( ret = av_write_trailer ( avf2 ) ) < 0 ) \n if ( ! ret_all ) \n ret_all = ret ; \n if ( ! ( avf2 -> oformat -> flags & AVFMT_NOFILE ) ) \n ff_format_io_close ( avf2 , & avf2 -> pb ) ; \n } \n close_slaves ( avf ) ; \n return ret_all ; \n }", "idx": 5495}
{"project": "FFmpeg", "commit_id": "2cface71ca58b1ab811efae7d22f3264f362f672", "target": 1, "func": "static int write_trailer ( AVFormatContext * s ) { \n NUTContext * nut = s -> priv_data ; \n AVIOContext * bc = s -> pb ; \n while ( nut -> header_count < 3 ) \n write_headers ( s , bc ) ; \n avio_flush ( bc ) ; \n ff_nut_free_sp ( nut ) ; \n av_freep ( & nut -> stream ) ; \n av_freep ( & nut -> time_base ) ; \n return 0 ; \n }", "idx": 5496}
{"project": "FFmpeg", "commit_id": "1851e1d05d06f6ef3436c667e4354da0f407b226", "target": 1, "func": "static int rtp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n RTPContext * s = h -> priv_data ; \n int ret ; \n URLContext * hd ; \n if ( RTP_PT_IS_RTCP ( buf [ 1 ] ) ) { \n hd = s -> rtcp_hd ; \n } else { \n hd = s -> rtp_hd ; \n } \n ret = ffurl_write ( hd , buf , size ) ; \n return ret ; \n }", "idx": 5498}
{"project": "FFmpeg", "commit_id": "ab2bfb85d49b2f8aa505816f93e75fd18ad0a361", "target": 1, "func": "int ff_insert_pad ( unsigned idx , unsigned * count , size_t padidx_off , \n AVFilterPad * * pads , AVFilterLink * * * links , \n AVFilterPad * newpad ) \n { \n AVFilterLink * * newlinks ; \n AVFilterPad * newpads ; \n unsigned i ; \n idx = FFMIN ( idx , * count ) ; \n newpads = av_realloc_array ( * pads , * count + 1 , sizeof ( AVFilterPad ) ) ; \n newlinks = av_realloc_array ( * links , * count + 1 , sizeof ( AVFilterLink * ) ) ; \n if ( newpads ) \n * pads = newpads ; \n if ( newlinks ) \n * links = newlinks ; \n if ( ! newpads || ! newlinks ) \n return AVERROR ( ENOMEM ) ; \n memmove ( * pads + idx + 1 , * pads + idx , sizeof ( AVFilterPad ) * ( * count - idx ) ) ; \n memmove ( * links + idx + 1 , * links + idx , sizeof ( AVFilterLink * ) * ( * count - idx ) ) ; \n memcpy ( * pads + idx , newpad , sizeof ( AVFilterPad ) ) ; \n ( * links ) [ idx ] = NULL ; \n ( * count ) ++ ; \n for ( i = idx + 1 ; i < * count ; i ++ ) \n if ( * links [ i ] ) \n ( * ( unsigned * ) ( ( uint8_t * ) * links [ i ] + padidx_off ) ) ++ ; \n return 0 ; \n }", "idx": 5501}
{"project": "FFmpeg", "commit_id": "4fecc3cf0998927456a9f8d8334587dd64154ec5", "target": 1, "func": "int ff_h264_decode_extradata ( H264Context * h , const uint8_t * buf , int size ) \n { \n AVCodecContext * avctx = h -> s . avctx ; \n if ( ! buf || size <= 0 ) \n return -1 ; \n if ( buf [ 0 ] == 1 ) { \n int i , cnt , nalsize ; \n const unsigned char * p = buf ; \n h -> is_avc = 1 ; \n if ( size < 7 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n h -> nal_length_size = 2 ; \n cnt = * ( p + 5 ) & 0x1f ; \n p += 6 ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( nalsize > size - ( p - buf ) ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n cnt = * ( p ++ ) ; \n for ( i = 0 ; i < cnt ; i ++ ) { \n nalsize = AV_RB16 ( p ) + 2 ; \n if ( nalsize > size - ( p - buf ) ) \n return -1 ; \n if ( decode_nal_units ( h , p , nalsize ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , i ) ; \n return -1 ; \n } \n p += nalsize ; \n } \n h -> nal_length_size = ( buf [ 4 ] & 0x03 ) + 1 ; \n } else { \n h -> is_avc = 0 ; \n if ( decode_nal_units ( h , buf , size ) < 0 ) \n return -1 ; \n } \n return size ; \n }", "idx": 5507}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int amr_wb_encode_init ( AVCodecContext * avctx ) \n { \n AMRWBContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 16000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> last_bitrate = avctx -> bit_rate ; \n avctx -> frame_size = 320 ; \n avctx -> delay = 80 ; \n s -> state = E_IF_init ( ) ; \n return 0 ; \n }", "idx": 5524}
{"project": "FFmpeg", "commit_id": "4391805916a1557278351f25428d0145b1073520", "target": 1, "func": "rgb16_32ToUV_c_template ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src , int width , \n enum PixelFormat origin , \n int shr , int shg , int shb , int shp , \n int maskr , int maskg , int maskb , \n int rsh , int gsh , int bsh , int S )  \n { \n const int ru = RU << rsh , gu = GU << gsh , bu = BU << bsh , \n rv = RV << rsh , gv = GV << gsh , bv = BV << bsh , \n rnd = 257 << ( S - 1 ) ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int px = input_pixel ( i ) >> shp ; \n int b = ( px & maskb ) >> shb ; \n int g = ( px & maskg ) >> shg ; \n int r = ( px & maskr ) >> shr ; \n dstU [ i ] = ( ru * r + gu * g + bu * b + rnd ) >> S ; \n dstV [ i ] = ( rv * r + gv * g + bv * b + rnd ) >> S ; \n } \n }", "idx": 5532}
{"project": "FFmpeg", "commit_id": "a4435f9235eefac8a25f1cda471486e2c37b21b5", "target": 1, "func": "static void print_track_chunks ( FILE * out , struct Tracks * tracks , int main , \n const char * type ) \n { \n int i , j ; \n struct Track * track = tracks -> tracks [ main ] ; \n for ( i = 0 ; i < track -> chunks ; i ++ ) { \n for ( j = main + 1 ; j < tracks -> nb_tracks ; j ++ ) { \n if ( tracks -> tracks [ j ] -> is_audio == track -> is_audio && \n track -> offsets [ i ] . duration != tracks -> tracks [ j ] -> offsets [ i ] . duration ) \n fprintf ( stderr , \" \\n \" , \n type , i , track -> name , tracks -> tracks [ j ] -> name ) ; \n } \n fprintf ( out , \" \\t \\t \\\" \\\" \\\" \\\" \\n \" , \n i , track -> offsets [ i ] . duration ) ; \n } \n }", "idx": 5544}
{"project": "FFmpeg", "commit_id": "8248b51e0b94f0151b6a2057ee639d6e0db29f5f", "target": 1, "func": "av_cold void ff_diracdsp_init ( DiracDSPContext * c ) \n { \n c -> dirac_hpel_filter = dirac_hpel_filter ; \n c -> add_rect_clamped = add_rect_clamped_c ; \n c -> put_signed_rect_clamped [ 0 ] = put_signed_rect_clamped_8bit_c ; \n c -> put_signed_rect_clamped [ 1 ] = put_signed_rect_clamped_10bit_c ; \n c -> add_dirac_obmc [ 0 ] = add_obmc8_c ; \n c -> add_dirac_obmc [ 1 ] = add_obmc16_c ; \n c -> add_dirac_obmc [ 2 ] = add_obmc32_c ; \n c -> weight_dirac_pixels_tab [ 0 ] = weight_dirac_pixels8_c ; \n c -> weight_dirac_pixels_tab [ 1 ] = weight_dirac_pixels16_c ; \n c -> weight_dirac_pixels_tab [ 2 ] = weight_dirac_pixels32_c ; \n c -> biweight_dirac_pixels_tab [ 0 ] = biweight_dirac_pixels8_c ; \n c -> biweight_dirac_pixels_tab [ 1 ] = biweight_dirac_pixels16_c ; \n c -> biweight_dirac_pixels_tab [ 2 ] = biweight_dirac_pixels32_c ; \n PIXFUNC ( put , 8 ) ; \n PIXFUNC ( put , 16 ) ; \n PIXFUNC ( put , 32 ) ; \n PIXFUNC ( avg , 8 ) ; \n PIXFUNC ( avg , 16 ) ; \n PIXFUNC ( avg , 32 ) ; \n if ( HAVE_MMX && HAVE_YASM ) ff_diracdsp_init_mmx ( c ) ; \n }", "idx": 5548}
{"project": "FFmpeg", "commit_id": "1af5f60f6aafa5f2653e7ea7cd054b0a4f31c103", "target": 0, "func": "static void horizontal_filter ( unsigned char * first_pixel , int stride , \n int * bounding_values ) \n { \n unsigned char * end ; \n int filter_value ; \n for ( end = first_pixel + 8 * stride ; first_pixel < end ; first_pixel += stride ) { \n filter_value = \n ( first_pixel [ -2 ] - first_pixel [ 1 ] ) \n + 3 * ( first_pixel [ 0 ] - first_pixel [ -1 ] ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ -1 ] = clip_uint8 ( first_pixel [ -1 ] + filter_value ) ; \n first_pixel [ 0 ] = clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 5556}
{"project": "FFmpeg", "commit_id": "eabbc64728c2fdb74f565aededec2ab023d20699", "target": 0, "func": "static void end_ebml_master_crc32 ( AVIOContext * pb , AVIOContext * * dyn_cp , MatroskaMuxContext * mkv , \n ebml_master master ) \n { \n uint8_t * buf , crc [ 4 ] ; \n int size ; \n if ( pb -> seekable ) { \n size = avio_close_dyn_buf ( * dyn_cp , & buf ) ; \n if ( mkv -> write_crc && mkv -> mode != MODE_WEBM ) { \n AV_WL32 ( crc , av_crc ( av_crc_get_table ( AV_CRC_32_IEEE_LE ) , UINT32_MAX , buf , size ) ^ UINT32_MAX ) ; \n put_ebml_binary ( pb , EBML_ID_CRC32 , crc , sizeof ( crc ) ) ; \n } \n avio_write ( pb , buf , size ) ; \n end_ebml_master ( pb , master ) ; \n } else { \n end_ebml_master ( * dyn_cp , master ) ; \n size = avio_close_dyn_buf ( * dyn_cp , & buf ) ; \n avio_write ( pb , buf , size ) ; \n } \n av_free ( buf ) ; \n * dyn_cp = NULL ; \n }", "idx": 5589}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static int mace3_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n const uint8_t * buf , int buf_size ) \n { \n int16_t * samples = data ; \n MACEContext * ctx = avctx -> priv_data ; \n int i , j , k ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) { \n int16_t * output = samples + i ; \n for ( j = 0 ; j < buf_size / 2 / avctx -> channels ; j ++ ) \n for ( k = 0 ; k < 2 ; k ++ ) { \n uint8_t pkt = buf [ i * 2 + j * 2 * avctx -> channels + k ] ; \n chomp3 ( & ctx -> chd [ i ] , output , pkt & 7 , MACEtab1 , MACEtab2 , \n 8 , avctx -> channels ) ; \n output += avctx -> channels ; \n chomp3 ( & ctx -> chd [ i ] , output , ( pkt >> 3 ) & 3 , MACEtab3 , MACEtab4 , \n 4 , avctx -> channels ) ; \n output += avctx -> channels ; \n chomp3 ( & ctx -> chd [ i ] , output , pkt >> 5 , MACEtab1 , MACEtab2 , \n 8 , avctx -> channels ) ; \n output += avctx -> channels ; \n } \n } \n * data_size = 2 * 3 * buf_size ; \n return buf_size ; \n }", "idx": 5598}
{"project": "FFmpeg", "commit_id": "01bd1ed2db53fa90a0512d65ad6c08170061dfdf", "target": 1, "func": "static int nut_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n int64_t pos ; \n int inited_stream_count ; \n nut -> avf = s ; \n pos = 0 ; \n for ( ; ; ) { \n pos = find_startcode ( bc , MAIN_STARTCODE , pos ) + 1 ; \n if ( pos < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( decode_main_header ( nut ) >= 0 ) \n break ; \n } \n s -> bit_rate = 0 ; \n nut -> stream = av_malloc ( sizeof ( StreamContext ) * nut -> stream_count ) ; \n pos = 0 ; \n for ( inited_stream_count = 0 ; inited_stream_count < nut -> stream_count ; ) { \n pos = find_startcode ( bc , STREAM_STARTCODE , pos ) + 1 ; \n if ( pos < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( decode_stream_header ( nut ) >= 0 ) \n inited_stream_count ++ ; \n } \n pos = 0 ; \n for ( ; ; ) { \n uint64_t startcode = find_any_startcode ( bc , pos ) ; \n pos = url_ftell ( bc ) ; \n if ( startcode == 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } else if ( startcode == KEYFRAME_STARTCODE ) { \n nut -> next_startcode = startcode ; \n break ; \n } else if ( startcode != INFO_STARTCODE ) { \n continue ; \n } \n decode_info_header ( nut ) ; \n } \n return 0 ; \n }", "idx": 5600}
{"project": "FFmpeg", "commit_id": "c9281a01b78cc3f09e36300a0ca3f5824d1c74cf", "target": 0, "func": "int av_interleaved_write_frame ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , flush = 0 ; \n ret = check_packet ( s , pkt ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( pkt ) { \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && pkt -> size == 0 ) { \n ret = 0 ; \n goto fail ; \n } \n av_dlog ( s , \" \" PRId64 \" \" PRId64 \" \\n \" , \n pkt -> size , pkt -> dts , pkt -> pts ) ; \n if ( ( ret = compute_pkt_fields2 ( s , st , pkt ) ) < 0 && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) \n goto fail ; \n if ( pkt -> dts == AV_NOPTS_VALUE && ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) { \n ret = AVERROR ( EINVAL ) ; \n goto fail ; \n } \n } else { \n av_dlog ( s , \" \\n \" ) ; \n flush = 1 ; \n } \n for ( ; ; ) { \n AVPacket opkt ; \n int ret = interleave_packet ( s , & opkt , pkt , flush ) ; \n if ( pkt ) { \n memset ( pkt , 0 , sizeof ( * pkt ) ) ; \n av_init_packet ( pkt ) ; \n pkt = NULL ; \n } \n if ( ret <= 0 ) \n return ret ; \n ret = write_packet ( s , & opkt ) ; \n if ( ret >= 0 ) \n s -> streams [ opkt . stream_index ] -> nb_frames ++ ; \n av_free_packet ( & opkt ) ; \n if ( ret < 0 ) \n return ret ; \n } \n fail : \n av_packet_unref ( pkt ) ; \n return ret ; \n }", "idx": 5602}
{"project": "FFmpeg", "commit_id": "ef0d779706c77ca9007527bd8d41e9400682f4e4", "target": 1, "func": "static int ogg_new_stream ( AVFormatContext * s , uint32_t serial , int new_avstream ) \n { \n struct ogg * ogg = s -> priv_data ; \n int idx = ogg -> nstreams ++ ; \n AVStream * st ; \n struct ogg_stream * os ; \n ogg -> streams = av_realloc ( ogg -> streams , \n ogg -> nstreams * sizeof ( * ogg -> streams ) ) ; \n memset ( ogg -> streams + idx , 0 , sizeof ( * ogg -> streams ) ) ; \n os = ogg -> streams + idx ; \n os -> serial = serial ; \n os -> bufsize = DECODER_BUFFER_SIZE ; \n os -> buf = av_malloc ( os -> bufsize ) ; \n os -> header = -1 ; \n if ( new_avstream ) { \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> id = idx ; \n avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ; \n } \n return idx ; \n }", "idx": 5606}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void adx_decode_stereo ( short * out , const unsigned char * in , PREV * prev ) \n { \n short tmp [ 32 * 2 ] ; \n int i ; \n adx_decode ( tmp , in , prev ) ; \n adx_decode ( tmp + 32 , in + 18 , prev + 1 ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n out [ i * 2 ] = tmp [ i ] ; \n out [ i * 2 + 1 ] = tmp [ i + 32 ] ; \n } \n }", "idx": 5613}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "int add_av_stream ( FFStream * feed , \n AVStream * st ) \n { \n AVStream * fst ; \n AVCodecContext * av , * av1 ; \n int i ; \n av = & st -> codec ; \n for ( i = 0 ; i < feed -> nb_streams ; i ++ ) { \n st = feed -> streams [ i ] ; \n av1 = & st -> codec ; \n if ( av1 -> codec_id == av -> codec_id && \n av1 -> codec_type == av -> codec_type && \n av1 -> bit_rate == av -> bit_rate ) { \n switch ( av -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n if ( av1 -> channels == av -> channels && \n av1 -> sample_rate == av -> sample_rate ) \n goto found ; \n break ; \n case CODEC_TYPE_VIDEO : \n if ( av1 -> width == av -> width && \n av1 -> height == av -> height && \n av1 -> frame_rate == av -> frame_rate && \n av1 -> gop_size == av -> gop_size ) \n goto found ; \n break ; \n default : \n abort ( ) ; \n } \n } \n } \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return -1 ; \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n memcpy ( & fst -> codec , av , sizeof ( AVCodecContext ) ) ; \n feed -> streams [ feed -> nb_streams ++ ] = fst ; \n return feed -> nb_streams - 1 ; \n found : \n return i ; \n }", "idx": 5616}
{"project": "FFmpeg", "commit_id": "b0635e2fcf80717dd618ef75d3317d62ed85c300", "target": 0, "func": "static void mov_text_new_line_cb ( void * priv , int forced ) \n { \n MovTextContext * s = priv ; \n av_strlcpy ( s -> ptr , \" \\n \" , FFMIN ( s -> end - s -> ptr , 2 ) ) ; \n s -> ptr ++ ; \n }", "idx": 5618}
{"project": "FFmpeg", "commit_id": "a1e5be5c1a0c98206a1ae034d278702f5c8ef2a3", "target": 0, "func": "static void pulse_get_output_timestamp ( AVFormatContext * h , int stream , int64_t * dts , int64_t * wall ) \n { \n PulseData * s = h -> priv_data ; \n pa_usec_t latency ; \n int neg ; \n pa_threaded_mainloop_lock ( s -> mainloop ) ; \n pa_stream_get_latency ( s -> stream , & latency , & neg ) ; \n pa_threaded_mainloop_unlock ( s -> mainloop ) ; \n * wall = av_gettime ( ) ; \n * dts = s -> timestamp - ( neg ? - latency : latency ) ; \n }", "idx": 5619}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int update_packetheader ( NUTContext * nut , ByteIOContext * bc , int additional_size ) { \n int64_t start = nut -> packet_start ; \n int64_t cur = url_ftell ( bc ) ; \n int size = cur - start + additional_size ; \n if ( size != nut -> written_packet_size ) { \n int i ; \n assert ( size <= nut -> written_packet_size ) ; \n url_fseek ( bc , nut -> packet_size_pos , SEEK_SET ) ; \n for ( i = get_length ( size ) ; i < get_length ( nut -> written_packet_size ) ; i += 7 ) \n put_byte ( bc , 0x80 ) ; \n put_v ( bc , size ) ; \n url_fseek ( bc , cur , SEEK_SET ) ; \n nut -> written_packet_size = size ; \n } \n return 0 ; \n }", "idx": 5620}
{"project": "FFmpeg", "commit_id": "46e1af3b0f2c28936dfa88063cc5a35f466f5ac3", "target": 0, "func": "static int build_huff ( const uint8_t * src , VLC * vlc ) \n { \n int i ; \n HuffEntry he [ 256 ] ; \n int last ; \n uint32_t codes [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint8_t syms [ 256 ] ; \n uint32_t code ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n he [ i ] . sym = i ; \n he [ i ] . len = * src ++ ; \n } \n qsort ( he , 256 , sizeof ( * he ) , huff_cmp ) ; \n if ( ! he [ 0 ] . len || he [ 0 ] . len > 32 ) \n return -1 ; \n last = 255 ; \n while ( he [ last ] . len == 255 && last ) \n last -- ; \n code = 1 ; \n for ( i = last ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n return init_vlc_sparse ( vlc , FFMIN ( he [ last ] . len , 9 ) , last + 1 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 5622}
{"project": "FFmpeg", "commit_id": "94350ab986dfce1c93fa720baf28b548c60a9879", "target": 0, "func": "int av_expr_parse ( AVExpr * * expr , const char * s , \n const char * const * const_names , \n const char * const * func1_names , double ( * const * funcs1 ) ( void * , double ) , \n const char * const * func2_names , double ( * const * funcs2 ) ( void * , double , double ) , \n int log_offset , void * log_ctx ) \n { \n Parser p ; \n AVExpr * e = NULL ; \n char * w = av_malloc ( strlen ( s ) + 1 ) ; \n char * wp = w ; \n const char * s0 = s ; \n int ret = 0 ; \n if ( ! w ) \n return AVERROR ( ENOMEM ) ; \n while ( * s ) \n if ( ! isspace ( * s ++ ) ) * wp ++ = s [ -1 ] ; \n * wp ++ = 0 ; \n p . class = & class ; \n p . stack_index = 100 ; \n p . s = w ; \n p . const_names = const_names ; \n p . funcs1 = funcs1 ; \n p . func1_names = func1_names ; \n p . funcs2 = funcs2 ; \n p . func2_names = func2_names ; \n p . log_offset = log_offset ; \n p . log_ctx = log_ctx ; \n if ( ( ret = parse_expr ( & e , & p ) ) < 0 ) \n goto end ; \n if ( * p . s ) { \n av_log ( & p , AV_LOG_ERROR , \" \\n \" , p . s , s0 ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n if ( ! verify_expr ( e ) ) { \n av_expr_free ( e ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n * expr = e ; \n end : \n av_free ( w ) ; \n return ret ; \n }", "idx": 5633}
{"project": "FFmpeg", "commit_id": "387783749faca39c98571d139c32866923ab5653", "target": 0, "func": "void ff_jpegls_init_state ( JLSState * state ) { \n int i ; \n state -> twonear = state -> near * 2 + 1 ; \n state -> range = ( ( state -> maxval + state -> twonear - 1 ) / state -> twonear ) + 1 ; \n for ( state -> qbpp = 0 ; ( 1 << state -> qbpp ) < state -> range ; state -> qbpp ++ ) ; \n if ( state -> bpp < 8 ) \n state -> limit = 16 + 2 * state -> bpp - state -> qbpp ; \n else \n state -> limit = ( 4 * state -> bpp ) - state -> qbpp ; \n for ( i = 0 ; i < 367 ; i ++ ) { \n state -> A [ i ] = FFMAX ( ( state -> range + 32 ) >> 6 , 2 ) ; \n state -> N [ i ] = 1 ; \n } \n }", "idx": 5644}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void upmix_mono_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 2 ] [ i ] = output [ 1 ] [ i ] ; \n }", "idx": 5655}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static int draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TileContext * tile = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n unsigned x0 , y0 ; \n get_current_tile_pos ( ctx , & x0 , & y0 ) ; \n ff_copy_rectangle2 ( & tile -> draw , \n outlink -> out_buf -> data , outlink -> out_buf -> linesize , \n inlink -> cur_buf -> data , inlink -> cur_buf -> linesize , \n x0 , y0 + y , 0 , y , inlink -> cur_buf -> video -> w , h ) ; \n return 0 ; \n }", "idx": 5688}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_midh_qrt_16w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height , uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 4 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_4w_msa ( src , src_stride , dst , dst_stride , height , \n horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 5710}
{"project": "FFmpeg", "commit_id": "713f490467e0d4b64e4d2e8f5ee98034235d2010", "target": 0, "func": "static void vc1_put_block ( VC1Context * v , DCTELEM block [ 6 ] [ 64 ] ) \n { \n uint8_t * Y ; \n int ys , us , vs ; \n DSPContext * dsp = & v -> s . dsp ; \n if ( v -> rangeredfrm ) { \n int i , j , k ; \n for ( k = 0 ; k < 6 ; k ++ ) \n for ( j = 0 ; j < 8 ; j ++ ) \n for ( i = 0 ; i < 8 ; i ++ ) \n block [ k ] [ i + j * 8 ] = ( block [ k ] [ i + j * 8 ] - 64 ) << 1 ; \n } \n ys = v -> s . current_picture . linesize [ 0 ] ; \n us = v -> s . current_picture . linesize [ 1 ] ; \n vs = v -> s . current_picture . linesize [ 2 ] ; \n Y = v -> s . dest [ 0 ] ; \n dsp -> put_pixels_clamped ( block [ 0 ] , Y , ys ) ; \n dsp -> put_pixels_clamped ( block [ 1 ] , Y + 8 , ys ) ; \n Y += ys * 8 ; \n dsp -> put_pixels_clamped ( block [ 2 ] , Y , ys ) ; \n dsp -> put_pixels_clamped ( block [ 3 ] , Y + 8 , ys ) ; \n if ( ! ( v -> s . flags & CODEC_FLAG_GRAY ) ) { \n dsp -> put_pixels_clamped ( block [ 4 ] , v -> s . dest [ 1 ] , us ) ; \n dsp -> put_pixels_clamped ( block [ 5 ] , v -> s . dest [ 2 ] , vs ) ; \n } \n }", "idx": 5711}
{"project": "FFmpeg", "commit_id": "58b1cba0c9173741cf769117a735b429356d83c0", "target": 1, "func": "static unsigned int read_sbr_data ( AACContext * ac , SpectralBandReplication * sbr , \n GetBitContext * gb , int id_aac ) \n { \n unsigned int cnt = get_bits_count ( gb ) ; \n if ( id_aac == TYPE_SCE || id_aac == TYPE_CCE ) { \n read_sbr_single_channel_element ( ac , sbr , gb ) ; \n } else if ( id_aac == TYPE_CPE ) { \n read_sbr_channel_pair_element ( ac , sbr , gb ) ; \n } else { \n av_log ( ac -> avccontext , AV_LOG_ERROR , \n \" \\n \" , id_aac ) ; \n sbr -> start = 0 ; \n return get_bits_count ( gb ) - cnt ; \n } \n if ( get_bits1 ( gb ) ) { \n int num_bits_left = get_bits ( gb , 4 ) ; \n if ( num_bits_left == 15 ) \n num_bits_left += get_bits ( gb , 8 ) ; \n num_bits_left <<= 3 ; \n while ( num_bits_left > 7 ) { \n num_bits_left -= 2 ; \n read_sbr_extension ( ac , sbr , gb , get_bits ( gb , 2 ) , & num_bits_left ) ; \n } \n } \n return get_bits_count ( gb ) - cnt ; \n }", "idx": 5716}
{"project": "FFmpeg", "commit_id": "84af4a7ee6f938c6466c8d795ead0e6ee8ed486d", "target": 1, "func": "void sample_dump ( int fnum , int32_t * tab , int n ) \n { \n static FILE * files [ 16 ] , * f ; \n char buf [ 512 ] ; \n int i ; \n int32_t v ; \n f = files [ fnum ] ; \n if ( ! f ) { \n snprintf ( buf , sizeof ( buf ) , \" \" , \n fnum , \n #ifdef USE_HIGHPRECISION \n \" \" \n #else \n \" \" \n #endif \n ) ; \n f = fopen ( buf , \" \" ) ; \n if ( ! f ) \n return ; \n files [ fnum ] = f ; \n } \n if ( fnum == 0 ) { \n static int pos = 0 ; \n printf ( \" \\n \" , pos ) ; \n for ( i = 0 ; i < n ; i ++ ) { \n printf ( \" \" , ( double ) tab [ i ] / FRAC_ONE ) ; \n if ( ( i % 18 ) == 17 ) \n printf ( \" \\n \" ) ; \n } \n pos += n ; \n } \n for ( i = 0 ; i < n ; i ++ ) { \n v = tab [ i ] << ( 23 - FRAC_BITS ) ; \n fwrite ( & v , 1 , sizeof ( int32_t ) , f ) ; \n } \n }", "idx": 5724}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "int ff_vdpau_mpeg_end_frame ( AVCodecContext * avctx ) \n { \n AVVDPAUContext * hwctx = avctx -> hwaccel_context ; \n MpegEncContext * s = avctx -> priv_data ; \n Picture * pic = s -> current_picture_ptr ; \n struct vdpau_picture_context * pic_ctx = pic -> hwaccel_picture_private ; \n VdpVideoSurface surf = ff_vdpau_get_surface_id ( & pic -> f ) ; \n hwctx -> render ( hwctx -> decoder , surf , ( void * ) & pic_ctx -> info , \n pic_ctx -> bitstream_buffers_used , pic_ctx -> bitstream_buffers ) ; \n ff_mpeg_draw_horiz_band ( s , 0 , s -> avctx -> height ) ; \n av_freep ( & pic_ctx -> bitstream_buffers ) ; \n return 0 ; \n }", "idx": 5725}
{"project": "FFmpeg", "commit_id": "8d637124864dcf8bf367ab96e572d6c7cf043675", "target": 1, "func": "static void skip_data_stream_element ( GetBitContext * gb ) \n { \n int byte_align = get_bits1 ( gb ) ; \n int count = get_bits ( gb , 8 ) ; \n if ( count == 255 ) \n count += get_bits ( gb , 8 ) ; \n if ( byte_align ) \n align_get_bits ( gb ) ; \n skip_bits_long ( gb , 8 * count ) ; \n }", "idx": 5726}
{"project": "FFmpeg", "commit_id": "22b8ada7b5e0a1ef58b21cf8e481e0c2b28ce94e", "target": 0, "func": "static void celt_pvq_search ( float * X , int * y , int K , int N ) \n { \n int i ; \n float res = 0.0f , y_norm = 0.0f , xy_norm = 0.0f ; \n for ( i = 0 ; i < N ; i ++ ) \n res += FFABS ( X [ i ] ) ; \n res = K / res ; \n for ( i = 0 ; i < N ; i ++ ) { \n y [ i ] = lrintf ( res * X [ i ] ) ; \n y_norm += y [ i ] * y [ i ] ; \n xy_norm += y [ i ] * X [ i ] ; \n K -= FFABS ( y [ i ] ) ; \n } \n while ( K ) { \n int max_idx = 0 , phase = FFSIGN ( K ) ; \n float max_den = 1.0f , max_num = 0.0f ; \n y_norm += 1.0f ; \n for ( i = 0 ; i < N ; i ++ ) { \n float xy_new = xy_norm + 1 * phase * FFABS ( X [ i ] ) ; \n float y_new = y_norm + 2 * phase * FFABS ( y [ i ] ) ; \n xy_new = xy_new * xy_new ; \n if ( y [ i ] && ( max_den * xy_new ) > ( y_new * max_num ) ) { \n max_den = y_new ; \n max_num = xy_new ; \n max_idx = i ; \n } \n } \n K -= phase ; \n phase *= FFSIGN ( X [ max_idx ] ) ; \n xy_norm += 1 * phase * X [ max_idx ] ; \n y_norm += 2 * phase * y [ max_idx ] ; \n y [ max_idx ] += phase ; \n } \n }", "idx": 5732}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int rtsp_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n RTSPState * rt = s -> priv_data ; \n rt -> seek_timestamp = av_rescale_q ( timestamp , s -> streams [ stream_index ] -> time_base , AV_TIME_BASE_Q ) ; \n switch ( rt -> state ) { \n default : \n case RTSP_STATE_IDLE : \n break ; \n case RTSP_STATE_PLAYING : \n if ( rtsp_read_pause ( s ) != 0 ) \n return -1 ; \n rt -> state = RTSP_STATE_SEEKING ; \n if ( rtsp_read_play ( s ) != 0 ) \n return -1 ; \n break ; \n case RTSP_STATE_PAUSED : \n rt -> state = RTSP_STATE_IDLE ; \n break ; \n } \n return 0 ; \n }", "idx": 5733}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , const uint8_t * src , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 5734}
{"project": "FFmpeg", "commit_id": "8672c0a6436c9fc9d107617cf28cafe09ad3d9a5", "target": 0, "func": "static int jpeg2000_decode_packets ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile ) \n { \n int ret , i ; \n int tp_index = 0 ; \n s -> bit_index = 8 ; \n if ( tile -> poc . nb_poc ) { \n for ( i = 0 ; i < tile -> poc . nb_poc ; i ++ ) { \n Jpeg2000POCEntry * e = & tile -> poc . poc [ i ] ; \n ret = jpeg2000_decode_packets_po_iteration ( s , tile , \n e -> RSpoc , e -> CSpoc , \n e -> LYEpoc , e -> REpoc , e -> CEpoc , \n e -> Ppoc , & tp_index \n ) ; \n if ( ret < 0 ) \n return ret ; \n } \n } else { \n ret = jpeg2000_decode_packets_po_iteration ( s , tile , \n 0 , 0 , \n tile -> codsty [ 0 ] . nlayers , \n 33 , \n s -> ncomponents , \n tile -> codsty [ 0 ] . prog_order , \n & tp_index \n ) ; \n } \n bytestream2_skip ( & s -> g , 2 ) ; \n return ret ; \n }", "idx": 5737}
{"project": "FFmpeg", "commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "target": 1, "func": "static int pix_sum_altivec ( uint8_t * pix , int line_size ) \n { \n int i , s ; \n const vector unsigned  int zero = \n ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector unsigned  int sad = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector signed  int sumdiffs ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n vector unsigned  char t1 = vec_vsx_ld ( 0 , pix ) ; \n sad = vec_sum4s ( t1 , sad ) ; \n pix += line_size ; \n } \n sumdiffs = vec_sums ( ( vector signed int ) sad , ( vector signed int ) zero ) ; \n sumdiffs = vec_splat ( sumdiffs , 3 ) ; \n vec_vsx_st ( sumdiffs , 0 , & s ) ; \n return s ; \n }", "idx": 5740}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_dolby ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] - output [ 4 ] [ i ] ) ; \n output [ 2 ] [ i ] += ( output [ 3 ] [ i ] + output [ 4 ] [ i ] ) ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 5747}
{"project": "FFmpeg", "commit_id": "3303926c2f06841270281e7f5210c0c94292e089", "target": 0, "func": "static int has_codec_parameters ( AVCodecContext * enc ) \n { \n int val ; \n switch ( enc -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n val = enc -> sample_rate ; \n break ; \n case CODEC_TYPE_VIDEO : \n val = enc -> width && enc -> pix_fmt != PIX_FMT_NONE ; \n break ; \n default : \n val = 1 ; \n break ; \n } \n return ( val != 0 ) ; \n }", "idx": 5748}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , float scale ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_scalar ( cdst , v1 , scale , LEN ) ; \n fdsp -> vector_fmul_scalar ( odst , v1 , scale , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , FLT_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 5749}
{"project": "FFmpeg", "commit_id": "73db0bf1b06084022db5f42377b3b7960b3d3f5e", "target": 0, "func": "int ff_mpv_frame_size_alloc ( MpegEncContext * s , int linesize ) \n { \n int alloc_size = FFALIGN ( FFABS ( linesize ) + 64 , 32 ) ; \n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> edge_emu_buffer , alloc_size * 4 * 24 , \n fail ) ; \n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> me . scratchpad , alloc_size * 2 * 16 * 2 , \n fail ) \n s -> me . temp = s -> me . scratchpad ; \n s -> rd_scratchpad = s -> me . scratchpad ; \n s -> b_scratchpad = s -> me . scratchpad ; \n s -> obmc_scratchpad = s -> me . scratchpad + 16 ; \n return 0 ; \n fail : \n av_freep ( & s -> edge_emu_buffer ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 5763}
{"project": "FFmpeg", "commit_id": "9eef2b77b29189606148e1fdf5d6c8d7b52b08b0", "target": 0, "func": "static int http_read ( URLContext * h , uint8_t * buf , int size ) \n { \n HTTPContext * s = h -> priv_data ; \n int size1 , len ; \n size1 = size ; \n while ( size > 0 ) { \n len = s -> buf_end - s -> buf_ptr ; \n if ( len > 0 ) { \n if ( len > size ) \n len = size ; \n memcpy ( buf , s -> buf_ptr , len ) ; \n s -> buf_ptr += len ; \n } else { \n len = url_read ( s -> hd , buf , size ) ; \n if ( len < 0 ) { \n return len ; \n } else if ( len == 0 ) { \n break ; \n } \n } \n size -= len ; \n buf += len ; \n } \n return size1 - size ; \n }", "idx": 5765}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "av_cold void ff_vc2enc_free_transforms ( VC2TransformContext * s ) \n { \n av_freep ( & s -> buffer ) ; \n }", "idx": 5770}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int v410_encode_init ( AVCodecContext * avctx ) \n { \n if ( avctx -> width & 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 5773}
{"project": "FFmpeg", "commit_id": "6c3cb02a742f0ce32a85e86738a18e3d6d711d59", "target": 1, "func": "static int find_headers_search_validate ( FLACParseContext * fpc , int offset ) \n { \n FLACFrameInfo fi ; \n uint8_t * header_buf ; \n int size = 0 ; \n header_buf = flac_fifo_read_wrap ( fpc , offset , \n MAX_FRAME_HEADER_SIZE , \n & fpc -> wrap_buf , \n & fpc -> wrap_buf_allocated_size ) ; \n if ( frame_header_is_valid ( fpc -> avctx , header_buf , & fi ) ) { \n FLACHeaderMarker * * end_handle = & fpc -> headers ; \n int i ; \n size = 0 ; \n while ( * end_handle ) { \n end_handle = & ( * end_handle ) -> next ; \n size ++ ; \n * end_handle = av_mallocz ( sizeof ( * * end_handle ) ) ; \n if ( ! * end_handle ) { \n av_log ( fpc -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n ( * end_handle ) -> fi = fi ; \n ( * end_handle ) -> offset = offset ; \n ( * end_handle ) -> link_penalty = av_malloc ( sizeof ( int ) * \n FLAC_MAX_SEQUENTIAL_HEADERS ) ; \n for ( i = 0 ; i < FLAC_MAX_SEQUENTIAL_HEADERS ; i ++ ) \n ( * end_handle ) -> link_penalty [ i ] = FLAC_HEADER_NOT_PENALIZED_YET ; \n fpc -> nb_headers_found ++ ; \n size ++ ; \n return size ;", "idx": 5778}
{"project": "FFmpeg", "commit_id": "8cafeb8bca5d079041739dbd72ccec0ead138eaf", "target": 1, "func": "static int mxf_timestamp_to_str ( uint64_t timestamp , char * * str ) \n { \n struct tm time = { 0 } ; \n time . tm_year = ( timestamp >> 48 ) - 1900 ; \n time . tm_mon = ( timestamp >> 40 & 0xFF ) - 1 ; \n time . tm_mday = ( timestamp >> 32 & 0xFF ) ; \n time . tm_hour = ( timestamp >> 24 & 0xFF ) ; \n time . tm_min = ( timestamp >> 16 & 0xFF ) ; \n time . tm_sec = ( timestamp >> 8 & 0xFF ) ; \n * str = av_mallocz ( 32 ) ; \n if ( ! * str ) \n return AVERROR ( ENOMEM ) ; \n strftime ( * str , 32 , \" \" , & time ) ; \n return 0 ; \n }", "idx": 5780}
{"project": "FFmpeg", "commit_id": "51000b994514e64a6c5039e179f20c9e24f87c45", "target": 0, "func": "static int check_pkt ( AVFormatContext * s , AVPacket * pkt ) \n { \n MOVMuxContext * mov = s -> priv_data ; \n MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; \n if ( trk -> entry ) { \n int64_t duration = pkt -> dts - trk -> cluster [ trk -> entry - 1 ] . dts ; \n if ( duration < 0 || duration > INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \" PRId64 \" \\n \" , \n duration , pkt -> dts \n ) ; \n pkt -> dts = trk -> cluster [ trk -> entry - 1 ] . dts + 1 ; \n pkt -> pts = AV_NOPTS_VALUE ; \n } \n } else if ( pkt -> dts <= INT_MIN || pkt -> dts >= INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , \n pkt -> dts \n ) ; \n pkt -> dts = 0 ; \n pkt -> pts = AV_NOPTS_VALUE ; \n } \n if ( pkt -> duration < 0 || pkt -> duration > INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , pkt -> duration ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 5782}
{"project": "FFmpeg", "commit_id": "a00676e48e49a3d794d6d2063ceca539e945a4a4", "target": 1, "func": "static int read_dcs ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b , \n int start_bits , int has_sign ) \n { \n int i , j , len , len2 , bsize , sign , v , v2 ; \n int16_t * dst = ( int16_t * ) b -> cur_dec ; \n CHECK_READ_VAL ( gb , b , len ) ; \n v = get_bits ( gb , start_bits - has_sign ) ; \n if ( v && has_sign ) { \n sign = - get_bits1 ( gb ) ; \n v = ( v ^ sign ) - sign ; \n } \n * dst ++ = v ; \n len -- ; \n for ( i = 0 ; i < len ; i += 8 ) { \n len2 = FFMIN ( len - i , 8 ) ; \n bsize = get_bits ( gb , 4 ) ; \n if ( bsize ) { \n for ( j = 0 ; j < len2 ; j ++ ) { \n v2 = get_bits ( gb , bsize ) ; \n if ( v2 ) { \n sign = - get_bits1 ( gb ) ; \n v2 = ( v2 ^ sign ) - sign ; \n } \n v += v2 ; \n * dst ++ = v ; \n if ( v < -32768 || v > 32767 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , v ) ; \n return -1 ; \n } \n } \n } else { \n for ( j = 0 ; j < len2 ; j ++ ) \n * dst ++ = v ; \n } \n } \n b -> cur_dec = ( uint8_t * ) dst ; \n return 0 ; \n }", "idx": 5788}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void await_reference_mb_row ( const H264Context * const h , H264Picture * ref , \n int mb_y ) \n { \n int ref_field = ref -> reference - 1 ; \n int ref_field_picture = ref -> field_picture ; \n int ref_height = 16 * h -> mb_height >> ref_field_picture ; \n if ( ! HAVE_THREADS || ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) \n return ; \n ff_thread_await_progress ( & ref -> tf , \n FFMIN ( 16 * mb_y >> ref_field_picture , \n ref_height - 1 ) , \n ref_field_picture && ref_field ) ; \n }", "idx": 5795}
{"project": "FFmpeg", "commit_id": "6c10281c3a3c5fe0ce9c5943ed94c73ebd0a5209", "target": 1, "func": "static int gxf_packet ( AVFormatContext * s , AVPacket * pkt ) { \n ByteIOContext * pb = s -> pb ; \n pkt_type_t pkt_type ; \n int pkt_len ; \n while ( ! url_feof ( pb ) ) { \n int track_type , track_id , ret ; \n int field_nr ; \n if ( ! parse_packet_header ( pb , & pkt_type , & pkt_len ) ) { \n if ( ! url_feof ( pb ) ) \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( pkt_type == PKT_FLT ) { \n gxf_read_index ( s , pkt_len ) ; \n continue ; \n } \n if ( pkt_type != PKT_MEDIA ) { \n url_fskip ( pb , pkt_len ) ; \n continue ; \n } \n if ( pkt_len < 16 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n continue ; \n } \n pkt_len -= 16 ; \n track_type = get_byte ( pb ) ; \n track_id = get_byte ( pb ) ; \n field_nr = get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; \n ret = av_get_packet ( pb , pkt , pkt_len ) ; \n pkt -> stream_index = get_sindex ( s , track_id , track_type ) ; \n pkt -> dts = field_nr ; \n return ret ; \n } \n return AVERROR ( EIO ) ; \n }", "idx": 5796}
{"project": "FFmpeg", "commit_id": "515b69f8f8e9a24cfaee95d8c1f63f265d8582fe", "target": 0, "func": "static void check_pred8x8l ( H264PredContext * h , uint8_t * buf0 , uint8_t * buf1 , \n int codec , int chroma_format , int bit_depth ) \n { \n if ( chroma_format == 1 && codec_ids [ codec ] == AV_CODEC_ID_H264 ) { \n int pred_mode ; \n for ( pred_mode = 0 ; pred_mode < 12 ; pred_mode ++ ) { \n if ( check_pred_func ( h -> pred8x8l [ pred_mode ] , \" \" , pred4x4_modes [ codec ] [ pred_mode ] ) ) { \n int neighbors ; \n for ( neighbors = 0 ; neighbors <= 0xc000 ; neighbors += 0x4000 ) { \n int has_topleft = neighbors & 0x8000 ; \n int has_topright = neighbors & 0x4000 ; \n if ( ( pred_mode == DIAG_DOWN_RIGHT_PRED || pred_mode == VERT_RIGHT_PRED ) && ! has_topleft ) \n continue ; \n randomize_buffers ( ) ; \n call_ref ( src0 , has_topleft , has_topright , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n call_new ( src1 , has_topleft , has_topright , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( src1 , has_topleft , has_topright , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n } \n } \n } \n } \n }", "idx": 5804}
{"project": "FFmpeg", "commit_id": "8b1cd25ca7e64e6128fa2902d78e48bfeeec9786", "target": 1, "func": "static int pmp_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n PMPContext * pmp = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int ret = 0 ; \n int i ; \n if ( url_feof ( pb ) ) \n return AVERROR_EOF ; \n if ( pmp -> cur_stream == 0 ) { \n int num_packets ; \n pmp -> audio_packets = avio_r8 ( pb ) ; \n num_packets = ( pmp -> num_streams - 1 ) * pmp -> audio_packets + 1 ; \n avio_skip ( pb , 8 ) ; \n pmp -> current_packet = 0 ; \n av_fast_malloc ( & pmp -> packet_sizes , \n & pmp -> packet_sizes_alloc , \n num_packets * sizeof ( * pmp -> packet_sizes ) ) ; \n if ( ! pmp -> packet_sizes_alloc ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < num_packets ; i ++ ) \n pmp -> packet_sizes [ i ] = avio_rl32 ( pb ) ; \n ret = av_get_packet ( pb , pkt , pmp -> packet_sizes [ pmp -> current_packet ] ) ; \n if ( ret >= 0 ) { \n ret = 0 ; \n if ( pmp -> cur_stream == 0 ) \n pkt -> dts = s -> streams [ 0 ] -> cur_dts ++ ; \n pkt -> stream_index = pmp -> cur_stream ; \n if ( pmp -> current_packet % pmp -> audio_packets == 0 ) \n pmp -> cur_stream = ( pmp -> cur_stream + 1 ) % pmp -> num_streams ; \n pmp -> current_packet ++ ; \n return ret ;", "idx": 5835}
{"project": "FFmpeg", "commit_id": "d7e14c0d103a2c9cca6c50568e09b40d6f48ea19", "target": 0, "func": "int av_picture_crop ( AVPicture * dst , const AVPicture * src , \n enum PixelFormat pix_fmt , int top_band , int left_band ) \n { \n int y_shift ; \n int x_shift ; \n if ( pix_fmt < 0 || pix_fmt >= PIX_FMT_NB ) \n return -1 ; \n y_shift = av_pix_fmt_descriptors [ pix_fmt ] . log2_chroma_h ; \n x_shift = av_pix_fmt_descriptors [ pix_fmt ] . log2_chroma_w ; \n if ( is_yuv_planar ( & pix_fmt_info [ pix_fmt ] ) ) { \n dst -> data [ 0 ] = src -> data [ 0 ] + ( top_band * src -> linesize [ 0 ] ) + left_band ; \n dst -> data [ 1 ] = src -> data [ 1 ] + ( ( top_band >> y_shift ) * src -> linesize [ 1 ] ) + ( left_band >> x_shift ) ; \n dst -> data [ 2 ] = src -> data [ 2 ] + ( ( top_band >> y_shift ) * src -> linesize [ 2 ] ) + ( left_band >> x_shift ) ; \n } else { \n if ( top_band % ( 1 << y_shift ) || left_band % ( 1 << x_shift ) ) \n return -1 ; \n if ( left_band ) \n return -1 ; \n dst -> data [ 0 ] = src -> data [ 0 ] + ( top_band * src -> linesize [ 0 ] ) + left_band ; \n } \n dst -> linesize [ 0 ] = src -> linesize [ 0 ] ; \n dst -> linesize [ 1 ] = src -> linesize [ 1 ] ; \n dst -> linesize [ 2 ] = src -> linesize [ 2 ] ; \n return 0 ; \n }", "idx": 5838}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel16_mc30_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_16w_msa ( src - 2 , stride , dst , stride , 16 , 1 ) ; \n }", "idx": 5839}
{"project": "FFmpeg", "commit_id": "4ec0beaa593860796feead14132506226a1edf0e", "target": 0, "func": "static int wv_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n WVContext * wc = s -> priv_data ; \n int ret , samples ; \n if ( url_feof ( & s -> pb ) ) \n return - EIO ; \n if ( wc -> block_parsed ) { \n if ( wv_read_block_header ( s , & s -> pb ) < 0 ) \n return -1 ; \n } \n samples = LE_32 ( wc -> extra ) ; \n if ( samples * 2 * wc -> chan > AVCODEC_MAX_AUDIO_FRAME_SIZE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return - EIO ; \n } \n if ( av_new_packet ( pkt , wc -> blksize + WV_EXTRA_SIZE ) < 0 ) \n return AVERROR_NOMEM ; \n memcpy ( pkt -> data , wc -> extra , WV_EXTRA_SIZE ) ; \n ret = get_buffer ( & s -> pb , pkt -> data + WV_EXTRA_SIZE , wc -> blksize ) ; \n if ( ret != wc -> blksize ) { \n av_free_packet ( pkt ) ; \n return AVERROR_IO ; \n } \n pkt -> stream_index = 0 ; \n wc -> block_parsed = 1 ; \n pkt -> size = ret + WV_EXTRA_SIZE ; \n return 0 ; \n }", "idx": 5841}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void calc_masking ( DCAEncContext * c , const int32_t * input ) \n { \n int i , k , band , ch , ssf ; \n int32_t data [ 512 ] ; \n for ( i = 0 ; i < 256 ; i ++ ) \n for ( ssf = 0 ; ssf < SUBSUBFRAMES ; ssf ++ ) \n c -> masking_curve_cb [ ssf ] [ i ] = -2047 ; \n for ( ssf = 0 ; ssf < SUBSUBFRAMES ; ssf ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n const int chi = c -> channel_order_tab [ ch ] ; \n for ( i = 0 , k = 128 + 256 * ssf ; k < 512 ; i ++ , k ++ ) \n data [ i ] = c -> history [ k ] [ ch ] ; \n for ( k -= 512 ; i < 512 ; i ++ , k ++ ) \n data [ i ] = input [ k * c -> channels + chi ] ; \n adjust_jnd ( c -> samplerate_index , data , c -> masking_curve_cb [ ssf ] ) ; \n } \n for ( i = 0 ; i < 256 ; i ++ ) { \n int32_t m = 2048 ; \n for ( ssf = 0 ; ssf < SUBSUBFRAMES ; ssf ++ ) \n if ( c -> masking_curve_cb [ ssf ] [ i ] < m ) \n m = c -> masking_curve_cb [ ssf ] [ i ] ; \n c -> eff_masking_curve_cb [ i ] = m ; \n } \n for ( band = 0 ; band < 32 ; band ++ ) { \n c -> band_masking_cb [ band ] = 2048 ; \n walk_band_low ( c , band , 0 , update_band_masking , NULL ) ; \n walk_band_high ( c , band , 0 , update_band_masking , NULL ) ; \n } \n }", "idx": 5842}
{"project": "FFmpeg", "commit_id": "9bf4523e40148fdd27064ab570952bd8c4d1016e", "target": 1, "func": "static int vp8_lossy_decode_frame ( AVCodecContext * avctx , AVFrame * p , \n int * got_frame , uint8_t * data_start , \n unsigned int data_size ) \n { \n WebPContext * s = avctx -> priv_data ; \n AVPacket pkt ; \n int ret ; \n if ( ! s -> initialized ) { \n ff_vp8_decode_init ( avctx ) ; \n s -> initialized = 1 ; \n if ( s -> has_alpha ) \n avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; \n } \n s -> lossless = 0 ; \n if ( data_size > INT_MAX ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n av_init_packet ( & pkt ) ; \n pkt . data = data_start ; \n pkt . size = data_size ; \n ret = ff_vp8_decode_frame ( avctx , p , got_frame , & pkt ) ; \n if ( s -> has_alpha ) { \n ret = vp8_lossy_decode_alpha ( avctx , p , s -> alpha_data , \n s -> alpha_data_size ) ; \n } \n }", "idx": 5851}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr15 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x1F ) << 5 ) | ( ( r & 0x1F ) << 10 ) ; \n } \n }", "idx": 5858}
{"project": "FFmpeg", "commit_id": "c42a1388a6d1bfd8001bf6a4241d8ca27e49326d", "target": 1, "func": "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , \n AVStream * stream , \n PayloadContext * h264_data , \n const char * attr , const char * value ) \n { \n AVCodecParameters * par = stream -> codecpar ; \n if ( ! strcmp ( attr , \" \" ) ) { \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , atoi ( value ) ) ; \n h264_data -> packetization_mode = atoi ( value ) ; \n if ( h264_data -> packetization_mode > 1 ) \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n } else if ( ! strcmp ( attr , \" \" ) ) { \n if ( strlen ( value ) == 6 ) \n parse_profile_level_id ( s , h264_data , value ) ; \n } else if ( ! strcmp ( attr , \" \" ) ) { \n int ret ; \n if ( value [ strlen ( value ) - 1 ] == ' ' ) { \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n return 0 ; \n } \n par -> extradata_size = 0 ; \n av_freep ( & par -> extradata ) ; \n ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , \n & par -> extradata_size , value ) ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , \n par -> extradata , par -> extradata_size ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 5866}
{"project": "FFmpeg", "commit_id": "b65efbc0f4195421c15d2a6c228d331eec5b31c3", "target": 1, "func": "int ff_mpv_reallocate_putbitbuffer ( MpegEncContext * s , size_t threshold , size_t size_increase ) \n { \n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < threshold \n && s -> slice_context_count == 1 \n && s -> pb . buf == s -> avctx -> internal -> byte_buffer ) { \n int lastgob_pos = s -> ptr_lastgob - s -> pb . buf ; \n int vbv_pos = s -> vbv_delay_ptr - s -> pb . buf ; \n uint8_t * new_buffer = NULL ; \n int new_buffer_size = 0 ; \n av_fast_padded_malloc ( & new_buffer , & new_buffer_size , \n s -> avctx -> internal -> byte_buffer_size + size_increase ) ; \n if ( ! new_buffer ) \n memcpy ( new_buffer , s -> avctx -> internal -> byte_buffer , s -> avctx -> internal -> byte_buffer_size ) ; \n av_free ( s -> avctx -> internal -> byte_buffer ) ; \n s -> avctx -> internal -> byte_buffer = new_buffer ; \n s -> avctx -> internal -> byte_buffer_size = new_buffer_size ; \n rebase_put_bits ( & s -> pb , new_buffer , new_buffer_size ) ; \n s -> ptr_lastgob = s -> pb . buf + lastgob_pos ; \n s -> vbv_delay_ptr = s -> pb . buf + vbv_pos ; \n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < threshold ) \n return AVERROR ( EINVAL ) ; \n return 0 ;", "idx": 5868}
{"project": "FFmpeg", "commit_id": "019dd2365729d44d66a5b629102e1ecb919f4f67", "target": 1, "func": "void av_get_channel_layout_string ( char * buf , int buf_size , \n int nb_channels , uint64_t channel_layout ) \n { \n int i ; \n if ( nb_channels <= 0 ) \n nb_channels = av_get_channel_layout_nb_channels ( channel_layout ) ; \n for ( i = 0 ; channel_layout_map [ i ] . name ; i ++ ) \n if ( nb_channels == channel_layout_map [ i ] . nb_channels && \n channel_layout == channel_layout_map [ i ] . layout ) { \n av_strlcpy ( buf , channel_layout_map [ i ] . name , buf_size ) ; \n return ; \n } \n snprintf ( buf , buf_size , \" \" , nb_channels ) ; \n if ( channel_layout ) { \n int i , ch ; \n av_strlcat ( buf , \" \" , buf_size ) ; \n for ( i = 0 , ch = 0 ; i < 64 ; i ++ ) { \n if ( ( channel_layout & ( 1L << i ) ) ) { \n const char * name = get_channel_name ( i ) ; \n if ( name ) { \n if ( ch > 0 ) \n av_strlcat ( buf , \" \" , buf_size ) ; \n av_strlcat ( buf , name , buf_size ) ; \n } \n ch ++ ; \n } \n } \n av_strlcat ( buf , \" \" , buf_size ) ; \n } \n }", "idx": 5871}
{"project": "FFmpeg", "commit_id": "34fd21120d8672357293cb83d8c9b770850db516", "target": 0, "func": "static inline int retry_transfer_wrapper ( URLContext * h , unsigned char * buf , int size , int size_min , \n int ( * transfer_func ) ( URLContext * h , unsigned char * buf , int size ) ) \n { \n int ret , len ; \n int fast_retries = 5 ; \n int64_t wait_since = 0 ; \n len = 0 ; \n while ( len < size_min ) { \n ret = transfer_func ( h , buf + len , size - len ) ; \n if ( ret == AVERROR ( EINTR ) ) \n continue ; \n if ( h -> flags & AVIO_FLAG_NONBLOCK ) \n return ret ; \n if ( ret == AVERROR ( EAGAIN ) ) { \n ret = 0 ; \n if ( fast_retries ) { \n fast_retries -- ; \n } else { \n if ( h -> rw_timeout ) { \n if ( ! wait_since ) \n wait_since = av_gettime ( ) ; \n else if ( av_gettime ( ) > wait_since + h -> rw_timeout ) \n return AVERROR ( EIO ) ; \n } \n av_usleep ( 1000 ) ; \n } \n } else if ( ret < 1 ) \n return ( ret < 0 && ret != AVERROR_EOF ) ? ret : len ; \n if ( ret ) \n fast_retries = FFMAX ( fast_retries , 2 ) ; \n len += ret ; \n if ( len < size && ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n } \n return len ; \n }", "idx": 5879}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_qmin ( const char * arg ) \n { \n video_qmin = atoi ( arg ) ; \n if ( video_qmin < 0 || \n video_qmin > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 5891}
{"project": "FFmpeg", "commit_id": "49bf712a892901bd6a2e8815d085487180894d8c", "target": 1, "func": "static void revert_cdlms ( WmallDecodeCtx * s , int ch , \n int coef_begin , int coef_end ) \n { \n int icoef , pred , ilms , num_lms , residue , input ; \n num_lms = s -> cdlms_ttl [ ch ] ; \n for ( ilms = num_lms - 1 ; ilms >= 0 ; ilms -- ) { \n for ( icoef = coef_begin ; icoef < coef_end ; icoef ++ ) { \n pred = 1 << ( s -> cdlms [ ch ] [ ilms ] . scaling - 1 ) ; \n residue = s -> channel_residues [ ch ] [ icoef ] ; \n pred += s -> dsp . scalarproduct_and_madd_int16 ( s -> cdlms [ ch ] [ ilms ] . coefs , \n s -> cdlms [ ch ] [ ilms ] . lms_prevvalues \n + s -> cdlms [ ch ] [ ilms ] . recent , \n s -> cdlms [ ch ] [ ilms ] . lms_updates \n + s -> cdlms [ ch ] [ ilms ] . recent , \n s -> cdlms [ ch ] [ ilms ] . order , \n WMASIGN ( residue ) ) ; \n input = residue + ( pred >> s -> cdlms [ ch ] [ ilms ] . scaling ) ; \n lms_update ( s , ch , ilms , input ) ; \n s -> channel_residues [ ch ] [ icoef ] = input ; \n } \n } \n }", "idx": 5901}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr32ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int b = ( ( uint32_t * ) src ) [ i ] & 0xFF ; \n int g = ( ( ( uint32_t * ) src ) [ i ] >> 8 ) & 0xFF ; \n int r = ( ( ( uint32_t * ) src ) [ i ] >> 16 ) & 0xFF ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n }", "idx": 5919}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_chroma_intra_c ( uint8_t * pix , int stride , int alpha , int beta ) \n { \n h264_loop_filter_chroma_intra_c ( pix , 1 , stride , alpha , beta ) ; \n }", "idx": 5924}
{"project": "FFmpeg", "commit_id": "331fae80a1fb9b027442047fb564c02c6c41e70b", "target": 1, "func": "static av_cold int mss1_decode_init ( AVCodecContext * avctx ) \n { \n MSS1Context * const c = avctx -> priv_data ; \n int ret ; \n c -> ctx . avctx = avctx ; \n c -> pic = av_frame_alloc ( ) ; \n if ( ! c -> pic ) \n return AVERROR ( ENOMEM ) ; \n ret = ff_mss12_decode_init ( & c -> ctx , 0 , & c -> sc , NULL ) ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n return ret ; \n }", "idx": 5936}
{"project": "FFmpeg", "commit_id": "b06cb15b9d7928bf54b639c9f9f7658c2c38bfb9", "target": 1, "func": "int ff_dca_convert_bitstream ( const uint8_t * src , int src_size , uint8_t * dst , \n int max_size ) \n { \n uint32_t mrk ; \n int i , tmp ; \n const uint16_t * ssrc = ( const uint16_t * ) src ; \n uint16_t * sdst = ( uint16_t * ) dst ; \n PutBitContext pb ; \n if ( ( unsigned ) src_size > ( unsigned ) max_size ) \n src_size = max_size ; \n mrk = AV_RB32 ( src ) ; \n switch ( mrk ) { \n case DCA_SYNCWORD_CORE_BE : \n memcpy ( dst , src , src_size ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_LE : \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ ) \n * sdst ++ = av_bswap16 ( * ssrc ++ ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_14B_BE : \n case DCA_SYNCWORD_CORE_14B_LE : \n init_put_bits ( & pb , dst , max_size ) ; \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ , src += 2 ) { \n tmp = ( ( mrk == DCA_SYNCWORD_CORE_14B_BE ) ? AV_RB16 ( src ) : AV_RL16 ( src ) ) & 0x3FFF ; \n put_bits ( & pb , 14 , tmp ) ; \n } \n flush_put_bits ( & pb ) ; \n return ( put_bits_count ( & pb ) + 7 ) >> 3 ; \n default : \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 5940}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "av_cold void ff_vp8dsp_init_arm ( VP8DSPContext * dsp ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_armv6 ( cpu_flags ) ) \n ff_vp8dsp_init_armv6 ( dsp ) ; \n if ( have_neon ( cpu_flags ) ) \n ff_vp8dsp_init_neon ( dsp ) ; \n }", "idx": 5941}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "void ff_wmv2_idct_c ( short * block ) { \n int i ; \n for ( i = 0 ; i < 64 ; i += 8 ) { \n wmv2_idct_row ( block + i ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n wmv2_idct_col ( block + i ) ; \n } \n }", "idx": 5943}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "double parse_number_or_die ( const char * context , const char * numstr , int type , \n double min , double max ) \n { \n char * tail ; \n const char * error ; \n double d = av_strtod ( numstr , & tail ) ; \n if ( * tail ) \n error = \" \\n \" ; \n else if ( d < min || d > max ) \n error = \" \\n \" ; \n else if ( type == OPT_INT64 && ( int64_t ) d != d ) \n error = \" \\n \" ; \n else if ( type == OPT_INT && ( int ) d != d ) \n error = \" \\n \" ; \n else \n return d ; \n av_log ( NULL , AV_LOG_FATAL , error , context , numstr , min , max ) ; \n exit ( 1 ) ; \n return 0 ; \n }", "idx": 5949}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale16To19_c ( SwsContext * c , int16_t * _dst , int dstW , const uint8_t * _src , \n const int16_t * filter , \n const int16_t * filterPos , int filterSize ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n const uint16_t * src = ( const uint16_t * ) _src ; \n int bits = av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ; \n int sh = bits - 4 ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += src [ srcPos + j ] * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> sh , ( 1 << 19 ) - 1 ) ; \n } \n }", "idx": 5956}
{"project": "FFmpeg", "commit_id": "a579dbb4f7deee142d1bb6545a169c9fcaa467af", "target": 0, "func": "static void test_butterflies_float ( const float * src0 , const float * src1 ) \n { \n LOCAL_ALIGNED_16 ( float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED_16 ( float , odst ,  [ LEN ] ) ; \n LOCAL_ALIGNED_16 ( float , cdst1 ,  [ LEN ] ) ; \n LOCAL_ALIGNED_16 ( float , odst1 ,  [ LEN ] ) ; \n int i ; \n declare_func ( void , float * av_restrict src0 , float * av_restrict src1 , \n int len ) ; \n memcpy ( cdst , src0 , LEN * sizeof ( * src0 ) ) ; \n memcpy ( cdst1 , src1 , LEN * sizeof ( * src1 ) ) ; \n memcpy ( odst , src0 , LEN * sizeof ( * src0 ) ) ; \n memcpy ( odst1 , src1 , LEN * sizeof ( * src1 ) ) ; \n call_ref ( cdst , cdst1 , LEN ) ; \n call_new ( odst , odst1 , LEN ) ; \n for ( i = 0 ; i < LEN ; i ++ ) { \n if ( ! float_near_abs_eps ( cdst [ i ] , odst [ i ] , FLT_EPSILON ) ) { \n fprintf ( stderr , \" \\n \" , \n i , cdst [ i ] , odst [ i ] , cdst [ i ] - odst [ i ] ) ; \n fail ( ) ; \n break ; \n } \n } \n memcpy ( odst , src0 , LEN * sizeof ( * src0 ) ) ; \n memcpy ( odst1 , src1 , LEN * sizeof ( * src1 ) ) ; \n bench_new ( odst , odst1 , LEN ) ; \n }", "idx": 5971}
{"project": "FFmpeg", "commit_id": "0dac708e2d31898ebccacdb5911b5496b1616989", "target": 0, "func": "int ff_new_chapter ( AVFormatContext * s , int id , int64_t start , int64_t end , const char * title ) \n { \n AVChapter * chapter = NULL ; \n int i ; \n for ( i = 0 ; i < s -> num_chapters ; i ++ ) \n if ( s -> chapters [ i ] -> id == id ) \n chapter = s -> chapters [ i ] ; \n if ( ! chapter ) { \n chapter = av_mallocz ( sizeof ( AVChapter ) ) ; \n if ( ! chapter ) \n return AVERROR ( ENOMEM ) ; \n dynarray_add ( & s -> chapters , & s -> num_chapters , chapter ) ; \n } \n if ( chapter -> title ) \n av_free ( chapter -> title ) ; \n if ( title ) \n chapter -> title = av_strdup ( title ) ; \n chapter -> id = id ; \n chapter -> start = start ; \n chapter -> end = end ; \n return 0 ; \n }", "idx": 5973}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "func": "static void get_pixels_altivec ( int16_t * restrict block , const uint8_t * pixels , int line_size ) \n { \n int i ; \n vector unsigned  char perm = vec_lvsl ( 0 , pixels ) ; \n vector unsigned  char bytes ; \n const vector unsigned  char zero = ( const vector unsigned char ) vec_splat_u8 ( 0 ) ; \n vector signed  short shorts ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n vector unsigned  char pixl = vec_ld ( 0 , pixels ) ; \n vector unsigned  char pixr = vec_ld ( 15 , pixels ) ; \n bytes = vec_perm ( pixl , pixr , perm ) ; \n shorts = ( vector signed short ) vec_mergeh ( zero , bytes ) ; \n vec_st ( shorts , i * 16 , ( vector signed short * ) block ) ; \n pixels += line_size ; \n } \n }", "idx": 5984}
{"project": "FFmpeg", "commit_id": "a991b8dec654ad09a35494e0cabbbc157bb04dab", "target": 1, "func": "static int sap_write_close ( AVFormatContext * s ) \n { \n struct SAPState * sap = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVFormatContext * rtpctx = s -> streams [ i ] -> priv_data ; \n if ( ! rtpctx ) \n continue ; \n av_write_trailer ( rtpctx ) ; \n url_fclose ( rtpctx -> pb ) ; \n av_metadata_free ( & rtpctx -> streams [ 0 ] -> metadata ) ; \n av_metadata_free ( & rtpctx -> metadata ) ; \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n s -> streams [ i ] -> priv_data = NULL ; \n } \n if ( sap -> last_time && sap -> ann && sap -> ann_fd ) { \n sap -> ann [ 0 ] |= 4 ; \n url_write ( sap -> ann_fd , sap -> ann , sap -> ann_size ) ; \n } \n av_freep ( & sap -> ann ) ; \n if ( sap -> ann_fd ) \n url_close ( sap -> ann_fd ) ; \n ff_network_close ( ) ; \n return 0 ; \n }", "idx": 5986}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_cod ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n Jpeg2000CodingStyle tmp ; \n int compno ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR_INVALIDDATA ; \n tmp . log2_prec_width = \n tmp . log2_prec_height = 15 ; \n tmp . csty = bytestream_get_byte ( & s -> buf ) ; \n tmp . prog_order = bytestream_get_byte ( & s -> buf ) ; \n tmp . nlayers = bytestream_get_be16 ( & s -> buf ) ; \n tmp . mct = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , & tmp ) ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; \n }", "idx": 5990}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel4_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_4w_msa ( src - ( stride * 2 ) , stride , dst , stride , 4 ) ; \n }", "idx": 6019}
{"project": "FFmpeg", "commit_id": "c9e884f3d98df85bf7f2cf30d71877b22929fdcb", "target": 1, "func": "static int tm2_read_deltas ( TM2Context * ctx , int stream_id ) \n { \n int d , mb ; \n int i , v ; \n d = get_bits ( & ctx -> gb , 9 ) ; \n mb = get_bits ( & ctx -> gb , 5 ) ; \n av_assert2 ( mb < 32 ) ; \n if ( ( d < 1 ) || ( d > TM2_DELTAS ) || ( mb < 1 ) ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , d , mb ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < d ; i ++ ) { \n v = get_bits_long ( & ctx -> gb , mb ) ; \n if ( v & ( 1 << ( mb - 1 ) ) ) \n ctx -> deltas [ stream_id ] [ i ] = v - ( 1 << mb ) ; \n else \n ctx -> deltas [ stream_id ] [ i ] = v ; \n } \n for ( ; i < TM2_DELTAS ; i ++ ) \n ctx -> deltas [ stream_id ] [ i ] = 0 ; \n return 0 ; \n }", "idx": 6022}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int flac_write_trailer ( struct AVFormatContext * s ) \n { \n ByteIOContext * pb = s -> pb ; \n uint8_t * streaminfo = s -> streams [ 0 ] -> codec -> extradata ; \n int len = s -> streams [ 0 ] -> codec -> extradata_size ; \n int64_t file_size ; \n if ( streaminfo && len > 0 && ! url_is_streamed ( s -> pb ) ) { \n file_size = url_ftell ( pb ) ; \n url_fseek ( pb , 8 , SEEK_SET ) ; \n put_buffer ( pb , streaminfo , len ) ; \n url_fseek ( pb , file_size , SEEK_SET ) ; \n put_flush_packet ( pb ) ; \n } \n return 0 ; \n }", "idx": 6026}
{"project": "FFmpeg", "commit_id": "0c6b9b9fe5edb7b4307e1705bac7f1087262a6fb", "target": 1, "func": "static inline int read_line ( AVFormatContext * s , char * rbuf , const int rbufsize , \n int * rbuflen ) \n { \n RTSPState * rt = s -> priv_data ; \n int idx = 0 ; \n int ret = 0 ; \n * rbuflen = 0 ; \n do { \n ret = ffurl_read_complete ( rt -> rtsp_hd , rbuf + idx , 1 ) ; \n if ( ret < 0 ) \n return ret ; \n if ( rbuf [ idx ] == ' \\r ' ) { \n } else if ( rbuf [ idx ] == ' \\n ' ) { \n rbuf [ idx ] = ' \\0 ' ; \n * rbuflen = idx ; \n return 0 ; \n } else \n idx ++ ; \n } while ( idx < rbufsize ) ; \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 6029}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_wave ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return -1 ; \n if ( st -> codec -> codec_id == CODEC_ID_QDM2 ) { \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size ; \n get_buffer ( pb , st -> codec -> extradata , atom . size ) ; \n } else if ( atom . size > 8 ) { \n if ( mov_read_default ( c , pb , atom ) < 0 ) \n return -1 ; \n } else \n url_fskip ( pb , atom . size ) ; \n return 0 ; \n }", "idx": 6051}
{"project": "FFmpeg", "commit_id": "ed1f8915daf6b84a940463dfe83c7b970f82383d", "target": 0, "func": "static void report_config_error ( const char * filename , int line_num , int log_level , int * errors , const char * fmt , ... ) \n { \n va_list vl ; \n va_start ( vl , fmt ) ; \n av_log ( NULL , log_level , \" \" , filename , line_num ) ; \n av_vlog ( NULL , log_level , fmt , vl ) ; \n va_end ( vl ) ; \n ( * errors ) ++ ; \n }", "idx": 6058}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_add ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 , const float * v3 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_add ( cdst , v1 , v2 , v3 , LEN ) ; \n fdsp -> vector_fmul_add ( odst , v1 , v2 , v3 , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , ARBITRARY_FMUL_ADD_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6060}
{"project": "FFmpeg", "commit_id": "ad786dd450f26ecfbd35bb26e8b149664ecde049", "target": 0, "func": "int ff_h264_execute_decode_slices ( H264Context * h , unsigned context_count ) \n { \n AVCodecContext * const avctx = h -> avctx ; \n H264Context * hx ; \n int i ; \n if ( h -> mb_y >= h -> mb_height ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( h -> avctx -> hwaccel ) \n return 0 ; \n if ( context_count == 1 ) { \n return decode_slice ( avctx , & h ) ; \n } else { \n for ( i = 1 ; i < context_count ; i ++ ) { \n hx = h -> thread_context [ i ] ; \n hx -> er . error_count = 0 ; \n } \n avctx -> execute ( avctx , decode_slice , h -> thread_context , \n NULL , context_count , sizeof ( void * ) ) ; \n hx = h -> thread_context [ context_count - 1 ] ; \n h -> mb_x = hx -> mb_x ; \n h -> mb_y = hx -> mb_y ; \n h -> droppable = hx -> droppable ; \n h -> picture_structure = hx -> picture_structure ; \n for ( i = 1 ; i < context_count ; i ++ ) \n h -> er . error_count += h -> thread_context [ i ] -> er . error_count ; \n } \n return 0 ; \n }", "idx": 6062}
{"project": "FFmpeg", "commit_id": "1a0d9b503d2e9c4278d6e93d40873dff9d191a25", "target": 0, "func": "static int open_next_file ( AVFormatContext * avf ) \n { \n ConcatContext * cat = avf -> priv_data ; \n unsigned fileno = cat -> cur_file - cat -> files ; \n if ( cat -> cur_file -> duration == AV_NOPTS_VALUE ) \n cat -> cur_file -> duration = cat -> avf -> duration - ( cat -> cur_file -> file_inpoint - cat -> cur_file -> file_start_time ) ; \n if ( ++ fileno >= cat -> nb_files ) { \n cat -> eof = 1 ; \n return AVERROR_EOF ; \n } \n return open_file ( avf , fileno ) ; \n }", "idx": 6064}
{"project": "FFmpeg", "commit_id": "33ae681f5ca9fa9aae82081dd6a6edbe2509f983", "target": 0, "func": "static void lsp2polyf ( const double * lsp , double * f , int lp_half_order ) \n { \n int i , j ; \n f [ 0 ] = 1.0 ; \n f [ 1 ] = -2 * lsp [ 0 ] ; \n lsp -= 2 ; \n for ( i = 2 ; i <= lp_half_order ; i ++ ) \n { \n double val = -2 * lsp [ 2 * i ] ; \n f [ i ] = val * f [ i - 1 ] + 2 * f [ i - 2 ] ; \n for ( j = i - 1 ; j > 1 ; j -- ) \n f [ j ] += f [ j - 1 ] * val + f [ j - 2 ] ; \n f [ 1 ] += val ; \n } \n }", "idx": 6093}
{"project": "FFmpeg", "commit_id": "e322b7061f873e8fd33b9e518caa19b87616a528", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n DCAEncContext * c = avctx -> priv_data ; \n const int32_t * samples ; \n int ret , i ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , c -> frame_size , 0 ) ) < 0 ) \n return ret ; \n samples = ( const int32_t * ) frame -> data [ 0 ] ; \n subband_transform ( c , samples ) ; \n if ( c -> lfe_channel ) \n lfe_downsample ( c , samples ) ; \n calc_masking ( c , samples ) ; \n find_peaks ( c ) ; \n assign_bits ( c ) ; \n calc_scales ( c ) ; \n quantize_all ( c ) ; \n shift_history ( c , samples ) ; \n init_put_bits ( & c -> pb , avpkt -> data , avpkt -> size ) ; \n put_frame_header ( c ) ; \n put_primary_audio_header ( c ) ; \n for ( i = 0 ; i < SUBFRAMES ; i ++ ) \n put_subframe ( c , i ) ; \n flush_put_bits ( & c -> pb ) ; \n avpkt -> pts = frame -> pts ; \n avpkt -> duration = ff_samples_to_time_base ( avctx , frame -> nb_samples ) ; \n avpkt -> size = c -> frame_size + 1 ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 6117}
{"project": "FFmpeg", "commit_id": "4c472c52525fcab4c80cdbc98b4625d318c84fcb", "target": 1, "func": "void ff_subblock_synthesis ( RA144Context * ractx , const int16_t * lpc_coefs , \n int cba_idx , int cb1_idx , int cb2_idx , \n int gval , int gain ) \n { \n int16_t * block ; \n int m [ 3 ] ; \n if ( cba_idx ) { \n cba_idx += BLOCKSIZE / 2 - 1 ; \n ff_copy_and_dup ( ractx -> buffer_a , ractx -> adapt_cb , cba_idx ) ; \n m [ 0 ] = ( ff_irms ( & ractx -> adsp , ractx -> buffer_a ) * gval ) >> 12 ; \n } else { \n m [ 0 ] = 0 ; \n } \n m [ 1 ] = ( ff_cb1_base [ cb1_idx ] * gval ) >> 8 ; \n m [ 2 ] = ( ff_cb2_base [ cb2_idx ] * gval ) >> 8 ; \n memmove ( ractx -> adapt_cb , ractx -> adapt_cb + BLOCKSIZE , \n ( BUFFERSIZE - BLOCKSIZE ) * sizeof ( * ractx -> adapt_cb ) ) ; \n block = ractx -> adapt_cb + BUFFERSIZE - BLOCKSIZE ; \n add_wav ( block , gain , cba_idx , m , cba_idx ? ractx -> buffer_a : NULL , \n ff_cb1_vects [ cb1_idx ] , ff_cb2_vects [ cb2_idx ] ) ; \n memcpy ( ractx -> curr_sblock , ractx -> curr_sblock + BLOCKSIZE , \n LPC_ORDER * sizeof ( * ractx -> curr_sblock ) ) ; \n if ( ff_celp_lp_synthesis_filter ( ractx -> curr_sblock + LPC_ORDER , lpc_coefs , \n block , BLOCKSIZE , LPC_ORDER , 1 , 0 , 0xfff ) ) \n memset ( ractx -> curr_sblock , 0 , ( LPC_ORDER + BLOCKSIZE ) * sizeof ( * ractx -> curr_sblock ) ) ; \n }", "idx": 6119}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void close_file ( OutputStream * os ) \n { \n int64_t pos = avio_tell ( os -> out ) ; \n avio_seek ( os -> out , 0 , SEEK_SET ) ; \n avio_wb32 ( os -> out , pos ) ; \n avio_flush ( os -> out ) ; \n avio_close ( os -> out ) ; \n os -> out = NULL ; \n }", "idx": 6121}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g726_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n G726Context * c = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n PutBitContext pb ; \n int i , ret , out_size ; \n out_size = ( frame -> nb_samples * c -> code_size + 7 ) / 8 ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , out_size ) ) ) \n return ret ; \n init_put_bits ( & pb , avpkt -> data , avpkt -> size ) ; \n for ( i = 0 ; i < frame -> nb_samples ; i ++ ) \n put_bits ( & pb , c -> code_size , g726_encode ( c , * samples ++ ) ) ; \n flush_put_bits ( & pb ) ; \n avpkt -> size = out_size ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 6122}
{"project": "FFmpeg", "commit_id": "8e91d9652ea5048d9014e7636e12c6ed4732d7b7", "target": 1, "func": "static int opt_vstats ( void * optctx , const char * opt , const char * arg ) \n { \n char filename [ 40 ] ; \n time_t today2 = time ( NULL ) ; \n struct tm * today = localtime ( & today2 ) ; \n snprintf ( filename , sizeof ( filename ) , \" \" , today -> tm_hour , today -> tm_min , \n today -> tm_sec ) ; \n return opt_vstats_file ( NULL , opt , filename ) ; \n }", "idx": 6130}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8tobgr24 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst += 3 ; \n } \n }", "idx": 6132}
{"project": "FFmpeg", "commit_id": "f4e593f7b51f7cb30986186c187cff939c82d86d", "target": 0, "func": "static av_cold int ffat_close_decoder ( AVCodecContext * avctx ) \n { \n ATDecodeContext * at = avctx -> priv_data ; \n if ( at -> converter ) \n AudioConverterDispose ( at -> converter ) ; \n av_packet_unref ( & at -> new_in_pkt ) ; \n av_packet_unref ( & at -> in_pkt ) ; \n av_free ( at -> decoded_data ) ; \n av_free ( at -> extradata ) ; \n return 0 ; \n }", "idx": 6139}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "static void reset_contexts ( SnowContext * s ) { \n int plane_index , level , orientation ; \n for ( plane_index = 0 ; plane_index < 2 ; plane_index ++ ) { \n for ( level = 0 ; level < s -> spatial_decomposition_count ; level ++ ) { \n for ( orientation = level ? 1 : 0 ; orientation < 4 ; orientation ++ ) { \n memset ( s -> plane [ plane_index ] . band [ level ] [ orientation ] . state , 0 , sizeof ( s -> plane [ plane_index ] . band [ level ] [ orientation ] . state ) ) ; \n } \n } \n } \n memset ( s -> mb_band . state , 0 , sizeof ( s -> mb_band . state ) ) ; \n memset ( s -> mv_band [ 0 ] . state , 0 , sizeof ( s -> mv_band [ 0 ] . state ) ) ; \n memset ( s -> mv_band [ 1 ] . state , 0 , sizeof ( s -> mv_band [ 1 ] . state ) ) ; \n memset ( s -> header_state , 0 , sizeof ( s -> header_state ) ) ; \n }", "idx": 6142}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xF ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char sample [ 2 ] ; \n CHECK_STREAM_PTR ( 2 ) ; \n sample [ 0 ] = * s -> stream_ptr ++ ; \n sample [ 1 ] = * s -> stream_ptr ++ ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n for ( x = 0 ; x < 8 ; x += 2 ) { \n * s -> pixel_ptr ++ = sample [ y & 1 ] ; \n * s -> pixel_ptr ++ = sample [ ! ( y & 1 ) ] ; \n } \n s -> pixel_ptr += s -> line_inc ; \n } \n return 0 ; \n }", "idx": 6144}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( hyscale ) ( SwsContext * c , uint16_t * dst , int dstWidth , const uint8_t * src , int srcW , int xInc , \n const int16_t * hLumFilter , \n const int16_t * hLumFilterPos , int hLumFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal , int isAlpha ) \n { \n void ( * toYV12 ) ( uint8_t * , const uint8_t * , int , uint32_t * ) = isAlpha ? c -> alpToYV12 : c -> lumToYV12 ; \n void ( * convertRange ) ( uint16_t * , int ) = isAlpha ? NULL : c -> lumConvertRange ; \n src += isAlpha ? c -> alpSrcOffset : c -> lumSrcOffset ; \n if ( toYV12 ) { \n toYV12 ( formatConvBuffer , src , srcW , pal ) ; \n src = formatConvBuffer ; \n } \n if ( ! c -> hyscale_fast ) { \n c -> hScale ( dst , dstWidth , src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize ) ; \n } else { \n c -> hyscale_fast ( c , dst , dstWidth , src , srcW , xInc ) ; \n } \n if ( convertRange ) \n convertRange ( dst , dstWidth ) ; \n }", "idx": 6149}
{"project": "FFmpeg", "commit_id": "c9bfd6a8c35a2102e730aca12f6e09d1627f76b3", "target": 1, "func": "static uint64_t get_channel_layout_single ( const char * name , int name_len ) \n { \n int i ; \n char * end ; \n int64_t layout ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( channel_layout_map ) ; i ++ ) { \n if ( strlen ( channel_layout_map [ i ] . name ) == name_len && \n ! memcmp ( channel_layout_map [ i ] . name , name , name_len ) ) \n return channel_layout_map [ i ] . layout ; \n } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( channel_names ) ; i ++ ) \n if ( channel_names [ i ] . name && \n strlen ( channel_names [ i ] . name ) == name_len && \n ! memcmp ( channel_names [ i ] . name , name , name_len ) ) \n return ( int64_t ) 1 << i ; \n i = strtol ( name , & end , 10 ) ; \n if ( ( end + 1 - name == name_len && * end == ' ' ) ) \n return av_get_default_channel_layout ( i ) ; \n layout = strtoll ( name , & end , 0 ) ; \n if ( end - name == name_len ) \n return FFMAX ( layout , 0 ) ; \n return 0 ; \n }", "idx": 6161}
{"project": "FFmpeg", "commit_id": "255be0734d9293309b42d8029d2004ec3732c8bc", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFilterBufferRef * buf ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AlphaMergeContext * merge = ctx -> priv ; \n int is_alpha = ( inlink == ctx -> inputs [ 1 ] ) ; \n struct FFBufQueue * queue = \n ( is_alpha ? & merge -> queue_alpha : & merge -> queue_main ) ; \n ff_bufqueue_add ( ctx , queue , buf ) ; \n while ( 1 ) { \n AVFilterBufferRef * main_buf , * alpha_buf ; \n if ( ! ff_bufqueue_peek ( & merge -> queue_main , 0 ) || \n ! ff_bufqueue_peek ( & merge -> queue_alpha , 0 ) ) break ; \n main_buf = ff_bufqueue_get ( & merge -> queue_main ) ; \n alpha_buf = ff_bufqueue_get ( & merge -> queue_alpha ) ; \n merge -> frame_requested = 0 ; \n draw_frame ( ctx , main_buf , alpha_buf ) ; \n ff_filter_frame ( ctx -> outputs [ 0 ] , avfilter_ref_buffer ( main_buf , ~ 0 ) ) ; \n avfilter_unref_buffer ( alpha_buf ) ; \n } \n return 0 ; \n }", "idx": 6172}
{"project": "FFmpeg", "commit_id": "03289958938e91dc9bc398fdf1489677c6030063", "target": 1, "func": "static void id3v2_read_ttag ( AVFormatContext * s , int taglen , char * dst , int dstlen ) \n { \n char * q ; \n int len ; \n if ( dstlen > 0 ) \n dst [ 0 ] = 0 ; \n if ( taglen < 1 ) \n return ; \n taglen -- ; \n dstlen -- ; \n switch ( get_byte ( s -> pb ) ) { \n case 0 : \n q = dst ; \n while ( taglen -- ) { \n uint8_t tmp ; \n PUT_UTF8 ( get_byte ( s -> pb ) , tmp , if ( q - dst < dstlen - 1 ) * q ++  = tmp ; ) \n } \n * q = ' \\0 ' ; \n break ; \n case 3 : \n len = FFMIN ( taglen , dstlen ) ; \n get_buffer ( s -> pb , dst , len ) ; \n dst [ len ] = 0 ; \n break ; \n } \n }", "idx": 6173}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose97i ( DWTELEM * buffer , int width , int height , int stride ) { \n int y ; \n DWTELEM * b0 = buffer + mirror ( -4 - 1 , height - 1 ) * stride ; \n DWTELEM * b1 = buffer + mirror ( -4 , height - 1 ) * stride ; \n DWTELEM * b2 = buffer + mirror ( -4 + 1 , height - 1 ) * stride ; \n DWTELEM * b3 = buffer + mirror ( -4 + 2 , height - 1 ) * stride ; \n for ( y = -4 ; y < height ; y += 2 ) { \n DWTELEM * b4 = buffer + mirror ( y + 3 , height - 1 ) * stride ; \n DWTELEM * b5 = buffer + mirror ( y + 4 , height - 1 ) * stride ; \n { START_TIMER \n if ( b3 <= b5 )  horizontal_decompose97i ( b4 , width ) ; \n if ( y + 4 < height ) horizontal_decompose97i ( b5 , width ) ; \n if ( width > 400 ) { \n STOP_TIMER ( \" \" )  \n } } \n { START_TIMER \n if ( b3 <= b5 )  vertical_decompose97iH0 ( b3 , b4 , b5 , width ) ; \n if ( b2 <= b4 ) vertical_decompose97iL0 ( b2 , b3 , b4 , width ) ; \n if ( b1 <= b3 ) vertical_decompose97iH1 ( b1 , b2 , b3 , width ) ; \n if ( b0 <= b2 ) vertical_decompose97iL1 ( b0 , b1 , b2 , width ) ; \n if ( width > 400 ) { \n STOP_TIMER ( \" \" )  \n } } \n b0 = b2 ; \n b1 = b3 ; \n b2 = b4 ; \n b3 = b5 ; \n } \n }", "idx": 6175}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , const uint8_t * src , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 6176}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_parse_stsd_data ( MOVContext * c , AVIOContext * pb , \n AVStream * st , MOVStreamContext * sc , \n int size ) \n { \n if ( st -> codec -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n st -> codec -> extradata_size = size ; \n st -> codec -> extradata = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n avio_read ( pb , st -> codec -> extradata , size ) ; \n } else { \n avio_skip ( pb , size ) ; \n } \n return 0 ; \n }", "idx": 6178}
{"project": "FFmpeg", "commit_id": "3df18b3ed1177037892ce5b3db113d52dcdcdbf3", "target": 0, "func": "static void rv34_gen_vlc ( const uint8_t * bits , int size , VLC * vlc , const uint8_t * insyms , \n const int num ) \n { \n int i ; \n int counts [ 17 ] = { 0 } , codes [ 17 ] ; \n uint16_t cw [ size ] , syms [ size ] ; \n uint8_t bits2 [ size ] ; \n int maxbits = 0 , realsize = 0 ; \n for ( i = 0 ; i < size ; i ++ ) { \n if ( bits [ i ] ) { \n bits2 [ realsize ] = bits [ i ] ; \n syms [ realsize ] = insyms ? insyms [ i ] : i ; \n realsize ++ ; \n maxbits = FFMAX ( maxbits , bits [ i ] ) ; \n counts [ bits [ i ] ] ++ ; \n } \n } \n codes [ 0 ] = 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) \n codes [ i + 1 ] = ( codes [ i ] + counts [ i ] ) << 1 ; \n for ( i = 0 ; i < realsize ; i ++ ) \n cw [ i ] = codes [ bits2 [ i ] ] ++ ; \n vlc -> table = & table_data [ table_offs [ num ] ] ; \n vlc -> table_allocated = table_offs [ num + 1 ] - table_offs [ num ] ; \n init_vlc_sparse ( vlc , FFMIN ( maxbits , 9 ) , realsize , \n bits2 , 1 , 1 , \n cw , 2 , 2 , \n syms , 2 , 2 , INIT_VLC_USE_NEW_STATIC ) ; \n }", "idx": 6180}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int request_frame ( AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n TrimContext * s = ctx -> priv ; \n int ret ; \n s -> got_output = 0 ; \n while ( ! s -> got_output ) { \n if ( s -> eof ) \n return AVERROR_EOF ; \n ret = ff_request_frame ( ctx -> inputs [ 0 ] ) ; \n if ( ret < 0 ) \n return ret ; \n } \n return 0 ; \n }", "idx": 6191}
{"project": "FFmpeg", "commit_id": "caf7be30b11288c498fae67be4741bfbf083d977", "target": 1, "func": "static int mpjpeg_read_probe ( AVProbeData * p ) \n { \n AVIOContext * pb ; \n char line [ 128 ] = { 0 } ; \n int ret = 0 ; \n pb = avio_alloc_context ( p -> buf , p -> buf_size , 0 , NULL , NULL , NULL , NULL ) ; \n if ( ! pb ) \n return AVERROR ( ENOMEM ) ; \n if ( p -> buf_size < 2 || p -> buf [ 0 ] != ' ' || p -> buf [ 1 ] != ' ' ) \n return 0 ; \n while ( ! pb -> eof_reached ) { \n ret = get_line ( pb , line , sizeof ( line ) ) ; \n if ( ret < 0 ) \n break ; \n ret = check_content_type ( line ) ; \n if ( ! ret ) { \n ret = AVPROBE_SCORE_MAX ; \n break ; \n } \n } \n av_free ( pb ) ; \n return ret ; \n }", "idx": 6205}
{"project": "FFmpeg", "commit_id": "15a29c39d9ef15b0783c04b3228e1c55f6701ee3", "target": 1, "func": "av_cold void ff_mlpdsp_init ( MLPDSPContext * c ) \n { \n c -> mlp_filter_channel = mlp_filter_channel ; \n if ( ARCH_X86 ) \n ff_mlpdsp_init_x86 ( c ) ; \n }", "idx": 6211}
{"project": "FFmpeg", "commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "target": 1, "func": "static PullupField * make_field_queue ( PullupContext * s , int len ) \n { \n PullupField * head , * f ; \n f = head = av_mallocz ( sizeof ( * head ) ) ; \n if ( ! f ) \n return NULL ; \n if ( alloc_metrics ( s , f ) < 0 ) { \n av_free ( f ) ; \n return NULL ; \n } \n for ( ; len > 0 ; len -- ) { \n f -> next = av_mallocz ( sizeof ( * f -> next ) ) ; \n if ( ! f -> next ) { \n free_field_queue ( head , & f ) ; \n return NULL ; \n } \n f -> next -> prev = f ; \n f = f -> next ; \n if ( alloc_metrics ( s , f ) < 0 ) { \n free_field_queue ( head , & f ) ; \n return NULL ; \n } \n } \n f -> next = head ; \n head -> prev = f ; \n return head ; \n }", "idx": 6213}
{"project": "FFmpeg", "commit_id": "b0635e2fcf80717dd618ef75d3317d62ed85c300", "target": 0, "func": "static void mov_text_text_cb ( void * priv , const char * text , int len ) \n { \n MovTextContext * s = priv ; \n av_strlcpy ( s -> ptr , text , FFMIN ( s -> end - s -> ptr , len + 1 ) ) ; \n s -> ptr += len ; \n }", "idx": 6222}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avcodec_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 6244}
{"project": "FFmpeg", "commit_id": "e90e1f558a194ef75e396ac9ae5128be03e66362", "target": 0, "func": "av_cold void ff_ps_ctx_init ( PSContext * ps ) \n { \n ipdopd_reset ( ps -> ipd_hist , ps -> opd_hist ) ; \n }", "idx": 6245}
{"project": "FFmpeg", "commit_id": "63a37d0e1ec59377af9fb7973ffc847f928ba851", "target": 0, "func": "static void active_parameter_sets ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n int num_sps_ids_minus1 ; \n int i ; \n get_bits ( gb , 4 ) ; \n get_bits ( gb , 1 ) ; \n get_bits ( gb , 1 ) ; \n num_sps_ids_minus1 = get_ue_golomb_long ( gb ) ; \n s -> active_seq_parameter_set_id = get_ue_golomb_long ( gb ) ; \n for ( i = 1 ; i <= num_sps_ids_minus1 ; i ++ ) \n get_ue_golomb_long ( gb ) ; \n }", "idx": 6258}
{"project": "FFmpeg", "commit_id": "22f15f5735389e992ec9aed43b0680e75746b3a1", "target": 0, "func": "static int on2avc_decode_band_types ( On2AVCContext * c , GetBitContext * gb ) \n { \n int bits_per_sect = c -> is_long ? 5 : 3 ; \n int esc_val = ( 1 << bits_per_sect ) - 1 ; \n int num_bands = c -> num_bands * c -> num_windows ; \n int band = 0 , i , band_type , run_len , run ; \n while ( band < num_bands ) { \n band_type = get_bits ( gb , 4 ) ; \n run_len = 1 ; \n do { \n run = get_bits ( gb , bits_per_sect ) ; \n run_len += run ; \n } while ( run == esc_val ) ; \n if ( band + run_len > num_bands ) { \n av_log ( c -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = band ; i < band + run_len ; i ++ ) { \n c -> band_type [ i ] = band_type ; \n c -> band_run_end [ i ] = band + run_len ; \n } \n band += run_len ; \n } \n return 0 ; \n }", "idx": 6304}
{"project": "FFmpeg", "commit_id": "c7ded42d5dfc0124008b5b9b13a1a342324885ed", "target": 1, "func": "static int activate ( AVFilterContext * ctx ) \n { \n PreMultiplyContext * s = ctx -> priv ; \n if ( s -> inplace ) { \n AVFrame * frame = NULL ; \n AVFrame * out = NULL ; \n int ret , status ; \n int64_t pts ; \n if ( ( ret = ff_inlink_consume_frame ( ctx -> inputs [ 0 ] , & frame ) ) > 0 ) { \n if ( ( ret = filter_frame ( ctx , & out , frame , frame ) ) < 0 ) \n return ret ; \n av_frame_free ( & frame ) ; \n ret = ff_filter_frame ( ctx -> outputs [ 0 ] , out ) ; \n } \n if ( ret < 0 ) { \n return ret ; \n } else if ( ff_inlink_acknowledge_status ( ctx -> inputs [ 0 ] , & status , & pts ) ) { \n ff_outlink_set_status ( ctx -> outputs [ 0 ] , status , pts ) ; \n return 0 ; \n } else { \n if ( ff_outlink_frame_wanted ( ctx -> outputs [ 0 ] ) ) \n ff_inlink_request_frame ( ctx -> inputs [ 0 ] ) ; \n return 0 ; \n } \n } else { \n return ff_framesync_activate ( & s -> fs ) ; \n } \n }", "idx": 6311}
{"project": "FFmpeg", "commit_id": "27852f2f1dec3749ea79883b70484c841169f747", "target": 1, "func": "static int unix_open ( URLContext * h , const char * filename , int flags ) \n { \n UnixContext * s = h -> priv_data ; \n int fd , ret ; \n av_strstart ( filename , \" \" , & filename ) ; \n s -> addr . sun_family = AF_UNIX ; \n av_strlcpy ( s -> addr . sun_path , filename , sizeof ( s -> addr . sun_path ) ) ; \n if ( ( fd = ff_socket ( AF_UNIX , s -> type , 0 ) ) < 0 ) \n return ff_neterrno ( ) ; \n if ( s -> listen ) { \n fd = ff_listen_bind ( fd , ( struct sockaddr * ) & s -> addr , \n sizeof ( s -> addr ) , s -> timeout , h ) ; \n if ( fd < 0 ) { \n ret = fd ; \n goto fail ; \n } \n } else { \n ret = ff_listen_connect ( fd , ( struct sockaddr * ) & s -> addr , \n sizeof ( s -> addr ) , s -> timeout , h , 0 ) ; \n if ( ret < 0 ) \n goto fail ; \n } \n s -> fd = fd ; \n return 0 ; \n fail : \n if ( s -> listen && AVUNERROR ( ret ) != EADDRINUSE ) \n unlink ( s -> addr . sun_path ) ; \n if ( fd >= 0 ) \n closesocket ( fd ) ; \n return ret ; \n }", "idx": 6313}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb16ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x07E0F81F ) ; \n int dh = ( ( d0 >> 5 ) & 0x07C0F83F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int r = d & 0x7F ; \n int b = ( d >> 11 ) & 0x7F ; \n int g = d >> 21 ; \n dstU [ i ] = ( ( 2 * RU * r + GU * g + 2 * BU * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n dstV [ i ] = ( ( 2 * RV * r + GV * g + 2 * BV * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n } \n }", "idx": 6316}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void yuv2yuvX_c ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , \n int chrFilterSize , const int16_t * * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( uDest ) \n for ( i = 0 ; i < chrDstW ; i ++ ) { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) { \n u += chrUSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrVSrc [ j ] [ i ] * chrFilter [ j ] ; \n } \n uDest [ i ] = av_clip_uint8 ( u >> 19 ) ; \n vDest [ i ] = av_clip_uint8 ( v >> 19 ) ; \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += alpSrc [ j ] [ i ] * lumFilter [ j ] ; \n aDest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n }", "idx": 6320}
{"project": "FFmpeg", "commit_id": "ab28108a361196134704071b7b34c42fc7d747c7", "target": 0, "func": "static int dxva2_mpeg2_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const struct MpegEncContext * s = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct dxva2_picture_context * ctx_pic = \n s -> current_picture_ptr -> hwaccel_picture_private ; \n if ( ! DXVA_CONTEXT_VALID ( avctx , ctx ) ) \n return -1 ; \n assert ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , s , & ctx_pic -> pp ) ; \n fill_quantization_matrices ( avctx , ctx , s , & ctx_pic -> qm ) ; \n ctx_pic -> slice_count = 0 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 6321}
{"project": "FFmpeg", "commit_id": "0ac2d86c4758e1419934905b6c092910296aa16a", "target": 0, "func": "static int dxva2_h264_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const H264Context * h = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct dxva2_picture_context * ctx_pic = h -> cur_pic_ptr -> hwaccel_picture_private ; \n if ( DXVA_CONTEXT_DECODER ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_CFG ( avctx , ctx ) == NULL || \n DXVA_CONTEXT_COUNT ( avctx , ctx ) <= 0 ) \n return -1 ; \n assert ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , h , & ctx_pic -> pp ) ; \n fill_scaling_lists ( avctx , ctx , h , & ctx_pic -> qm ) ; \n ctx_pic -> slice_count = 0 ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 6325}
{"project": "FFmpeg", "commit_id": "bca11e75fbc6b922438670733c6cb418c70433b4", "target": 0, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest != NULL ) \n { \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET ) \n :: \" r \" \n \" r \" \" p \" \n : \" % \" \" % \" \" % \" \n ) ; \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 6326}
{"project": "FFmpeg", "commit_id": "9ee1feaa7c2822240b93d4640ec6e8d3e5b6139b", "target": 0, "func": "static double fade_gain ( int curve , int64_t index , int range ) \n { \n double gain ; \n gain = av_clipd ( 1.0 * index / range , 0 , 1.0 ) ; \n switch ( curve ) { \n case QSIN : \n gain = sin ( gain * M_PI / 2.0 ) ; \n break ; \n case IQSIN : \n gain = 0.636943 * asin ( gain ) ; \n break ; \n case ESIN : \n gain = 1.0 - cos ( M_PI / 4.0 * ( pow ( 2.0 * gain - 1 , 3 ) + 1 ) ) ; \n break ; \n case HSIN : \n gain = ( 1.0 - cos ( gain * M_PI ) ) / 2.0 ; \n break ; \n case IHSIN : \n gain = 0.318471 * acos ( 1 - 2 * gain ) ; \n break ; \n case EXP : \n gain = pow ( 0.1 , ( 1 - gain ) * 5.0 ) ; \n break ; \n case LOG : \n gain = av_clipd ( 0.0868589 * log ( 100000 * gain ) , 0 , 1.0 ) ; \n break ; \n case PAR : \n gain = 1 - sqrt ( 1 - gain ) ; \n break ; \n case IPAR : \n gain = ( 1 - ( 1 - gain ) * ( 1 - gain ) ) ; \n break ; \n case QUA : \n gain *= gain ; \n break ; \n case CUB : \n gain = gain * gain * gain ; \n break ; \n case SQU : \n gain = sqrt ( gain ) ; \n break ; \n case CBR : \n gain = cbrt ( gain ) ; \n break ; \n case DESE : \n gain = gain <= 0.5 ? pow ( 2 * gain , 1 / 3. ) / 2 : 1 - pow ( 2 * ( 1 - gain ) , 1 / 3. ) / 2 ; \n break ; \n case DESI : \n gain = gain <= 0.5 ? pow ( 2 * gain , 3 ) / 2 : 1 - pow ( 2 * ( 1 - gain ) , 3 ) / 2 ; \n break ; \n } \n return gain ; \n }", "idx": 6328}
{"project": "FFmpeg", "commit_id": "dcd3418a35aab7ef283b68ed9997ce4ac204094e", "target": 0, "func": "static int get_cv_ycbcr_matrix ( AVCodecContext * avctx , CFStringRef * matrix ) { \n switch ( avctx -> colorspace ) { \n case AVCOL_SPC_BT709 : \n * matrix = kCVImageBufferYCbCrMatrix_ITU_R_709_2 ; \n break ; \n case AVCOL_SPC_UNSPECIFIED : \n * matrix = NULL ; \n break ; \n case AVCOL_SPC_BT470BG : \n case AVCOL_SPC_SMPTE170M : \n * matrix = kCVImageBufferYCbCrMatrix_ITU_R_601_4 ; \n break ; \n case AVCOL_SPC_SMPTE240M : \n * matrix = kCVImageBufferYCbCrMatrix_SMPTE_240M_1995 ; \n break ; \n case AVCOL_SPC_BT2020_NCL : \n * matrix = kCVImageBufferYCbCrMatrix_ITU_R_2020 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , av_color_space_name ( avctx -> colorspace ) ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 6329}
{"project": "FFmpeg", "commit_id": "34c340d49f2e6ca5190f16ced82da32561a7bef2", "target": 0, "func": "static AVStream * add_av_stream1 ( FFStream * stream , AVCodecContext * codec , int copy ) \n { \n AVStream * fst ; \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return NULL ; \n if ( copy ) { \n fst -> codec = avcodec_alloc_context ( ) ; \n memcpy ( fst -> codec , codec , sizeof ( AVCodecContext ) ) ; \n if ( codec -> extradata_size ) { \n fst -> codec -> extradata = av_malloc ( codec -> extradata_size ) ; \n memcpy ( fst -> codec -> extradata , codec -> extradata , \n codec -> extradata_size ) ; \n } \n } else { \n fst -> codec = codec ; \n } \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n fst -> index = stream -> nb_streams ; \n av_set_pts_info ( fst , 33 , 1 , 90000 ) ; \n fst -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n stream -> streams [ stream -> nb_streams ++ ] = fst ; \n return fst ; \n }", "idx": 6330}
{"project": "FFmpeg", "commit_id": "73ad4471a48bd02b2c2a55de116161b87e061023", "target": 1, "func": "int ff_rv34_decode_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) \n { \n RV34DecContext * r = dst -> priv_data , * r1 = src -> priv_data ; \n MpegEncContext * const s = & r -> s , * const s1 = & r1 -> s ; \n int err ; \n if ( dst == src || ! s1 -> context_initialized ) \n return 0 ; \n if ( s -> height != s1 -> height || s -> width != s1 -> width ) { \n ff_MPV_common_end ( s ) ; \n s -> height = s1 -> height ; \n s -> width = s1 -> width ; \n if ( ( err = ff_MPV_common_init ( s ) ) < 0 ) \n return err ; \n if ( ( err = rv34_decoder_realloc ( r ) ) < 0 ) \n return err ; \n } \n if ( ( err = ff_mpeg_update_thread_context ( dst , src ) ) ) \n return err ; \n r -> cur_pts = r1 -> cur_pts ; \n r -> last_pts = r1 -> last_pts ; \n r -> next_pts = r1 -> next_pts ; \n memset ( & r -> si , 0 , sizeof ( r -> si ) ) ; \n s -> current_picture_ptr = NULL ; \n return 0 ; \n }", "idx": 6336}
{"project": "FFmpeg", "commit_id": "0bb7408e557f5d5ee3f8c1d001012e5c204c20b4", "target": 1, "func": "void avfilter_destroy ( AVFilterContext * filter ) \n { \n int i ; \n if ( filter -> filter -> uninit ) \n filter -> filter -> uninit ( filter ) ; \n for ( i = 0 ; i < filter -> input_count ; i ++ ) { \n if ( filter -> inputs [ i ] ) { \n filter -> inputs [ i ] -> src -> outputs [ filter -> inputs [ i ] -> srcpad ] = NULL ; \n avfilter_formats_unref ( & filter -> inputs [ i ] -> in_formats ) ; \n avfilter_formats_unref ( & filter -> inputs [ i ] -> out_formats ) ; \n } \n av_freep ( & filter -> inputs [ i ] ) ; \n } \n for ( i = 0 ; i < filter -> output_count ; i ++ ) { \n if ( filter -> outputs [ i ] ) { \n if ( filter -> outputs [ i ] -> dst ) \n filter -> outputs [ i ] -> dst -> inputs [ filter -> outputs [ i ] -> dstpad ] = NULL ; \n avfilter_formats_unref ( & filter -> outputs [ i ] -> in_formats ) ; \n avfilter_formats_unref ( & filter -> outputs [ i ] -> out_formats ) ; \n } \n av_freep ( & filter -> outputs [ i ] ) ; \n } \n av_freep ( & filter -> name ) ; \n av_freep ( & filter -> input_pads ) ; \n av_freep ( & filter -> output_pads ) ; \n av_freep ( & filter -> inputs ) ; \n av_freep ( & filter -> outputs ) ; \n av_freep ( & filter -> priv ) ; \n av_free ( filter ) ; \n }", "idx": 6341}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_coc ( J2kDecoderContext * s , J2kCodingStyle * c , uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n c += compno ; \n c -> csty = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , c ) ; \n properties [ compno ] |= HAD_COC ; \n return 0 ; \n }", "idx": 6344}
{"project": "FFmpeg", "commit_id": "63d33cf4390a9280b1ba42ee722f3140cf1cad3e", "target": 1, "func": "static int decode_user_data ( MpegEncContext * s , GetBitContext * gb ) { \n char buf [ 256 ] ; \n int i ; \n int e ; \n int ver , build , ver2 , ver3 ; \n char last ; \n for ( i = 0 ; i < 255 ; i ++ ) { \n if ( show_bits ( gb , 23 ) == 0 ) break ; \n buf [ i ] = get_bits ( gb , 8 ) ; \n } \n buf [ i ] = 0 ; \n e = sscanf ( buf , \" \" , & ver , & build , & last ) ; \n if ( e < 2 ) \n e = sscanf ( buf , \" \" , & ver , & build , & last ) ; \n if ( e >= 2 ) { \n s -> divx_version = ver ; \n s -> divx_build = build ; \n s -> divx_packed = e == 3 && last == ' ' ; \n } \n e = sscanf ( buf , \" \" , & build ) + 3 ; \n if ( e != 4 ) \n e = sscanf ( buf , \" \" , & ver , & ver2 , & ver3 , & build ) ; \n if ( e != 4 ) { \n e = sscanf ( buf , \" \" , & ver , & ver2 , & ver3 ) + 1 ; \n build = ( ver << 16 ) + ( ver2 << 8 ) + ver3 ; \n } \n if ( e != 4 ) { \n if ( strcmp ( buf , \" \" ) == 0 ) { \n s -> lavc_build = 4600 ; \n } \n } \n if ( e == 4 ) { \n s -> lavc_build = build ; \n } \n e = sscanf ( buf , \" \" , & build ) ; \n if ( e == 1 ) { \n s -> xvid_build = build ; \n } \n return 0 ; \n }", "idx": 6355}
{"project": "FFmpeg", "commit_id": "f55df62998681c7702f008ce7c12a00b15e33f53", "target": 1, "func": "static void do_adaptive_prediction ( struct G722Band * band , const int cur_diff ) \n { \n int sg [ 2 ] , limit , cur_qtzd_reconst ; \n const int cur_part_reconst = band -> s_zero + cur_diff < 0 ; \n sg [ 0 ] = sign_lookup [ cur_part_reconst != band -> part_reconst_mem [ 0 ] ] ; \n sg [ 1 ] = sign_lookup [ cur_part_reconst == band -> part_reconst_mem [ 1 ] ] ; \n band -> part_reconst_mem [ 1 ] = band -> part_reconst_mem [ 0 ] ; \n band -> part_reconst_mem [ 0 ] = cur_part_reconst ; \n band -> pole_mem [ 1 ] = av_clip ( ( sg [ 0 ] * av_clip ( band -> pole_mem [ 0 ] , -8191 , 8191 ) >> 5 ) + \n ( sg [ 1 ] << 7 ) + ( band -> pole_mem [ 1 ] * 127 >> 7 ) , -12288 , 12288 ) ; \n limit = 15360 - band -> pole_mem [ 1 ] ; \n band -> pole_mem [ 0 ] = av_clip ( -192 * sg [ 0 ] + ( band -> pole_mem [ 0 ] * 255 >> 8 ) , - limit , limit ) ; \n s_zero ( cur_diff , band ) ; \n cur_qtzd_reconst = av_clip_int16 ( ( band -> s_predictor + cur_diff ) << 1 ) ; \n band -> s_predictor = av_clip_int16 ( band -> s_zero + \n ( band -> pole_mem [ 0 ] * cur_qtzd_reconst >> 15 ) + \n ( band -> pole_mem [ 1 ] * band -> prev_qtzd_reconst >> 15 ) ) ; \n band -> prev_qtzd_reconst = cur_qtzd_reconst ; \n }", "idx": 6356}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static const AVClass * ff_avio_child_class_next ( const AVClass * prev ) \n { \n return prev ? NULL : & ffurl_context_class ; \n }", "idx": 6358}
{"project": "FFmpeg", "commit_id": "f5fc28d23c46d334c809c11d62651d0080f1c325", "target": 1, "func": "static int gif_image_write_image ( ByteIOContext * pb , \n int x1 , int y1 , int width , int height , \n const uint8_t * buf , int linesize , int pix_fmt ) \n { \n PutBitContext p ; \n uint8_t buffer [ 200 ] ; \n int i , left , w , v ; \n const uint8_t * ptr ; \n put_byte ( pb , 0x2c ) ; \n put_le16 ( pb , x1 ) ; \n put_le16 ( pb , y1 ) ; \n put_le16 ( pb , width ) ; \n put_le16 ( pb , height ) ; \n put_byte ( pb , 0x00 ) ; \n put_byte ( pb , 0x08 ) ; \n left = width * height ; \n init_put_bits ( & p , buffer , 130 ) ; \n ptr = buf ; \n w = width ; \n while ( left > 0 ) { \n gif_put_bits_rev ( & p , 9 , 0x0100 ) ; \n for ( i = 0 ; i < GIF_CHUNKS ; i ++ ) { \n if ( pix_fmt == PIX_FMT_RGB24 ) { \n v = gif_clut_index ( ptr [ 0 ] , ptr [ 1 ] , ptr [ 2 ] ) ; \n ptr += 3 ; \n } else { \n v = * ptr ++ ; \n } \n gif_put_bits_rev ( & p , 9 , v ) ; \n if ( -- w == 0 ) { \n w = width ; \n buf += linesize ; \n ptr = buf ; \n } \n } \n if ( left <= GIF_CHUNKS ) { \n gif_put_bits_rev ( & p , 9 , 0x101 ) ; \n gif_flush_put_bits_rev ( & p ) ; \n } \n if ( pbBufPtr ( & p ) - p . buf > 0 ) { \n put_byte ( pb , pbBufPtr ( & p ) - p . buf ) ; \n put_buffer ( pb , p . buf , pbBufPtr ( & p ) - p . buf ) ; \n p . buf_ptr = p . buf ; \n } \n if ( left <= GIF_CHUNKS ) { \n put_byte ( pb , 0x00 ) ; \n } \n left -= GIF_CHUNKS ; \n } \n return 0 ; \n }", "idx": 6367}
{"project": "FFmpeg", "commit_id": "465c28b6b43be2563e0b644ec22cf641fe374d8d", "target": 1, "func": "static int matroska_ebmlnum_uint ( MatroskaDemuxContext * matroska , \n uint8_t * data , uint32_t size , uint64_t * num ) \n { \n ByteIOContext pb ; \n init_put_byte ( & pb , data , size , 0 , NULL , NULL , NULL , NULL ) ; \n return ebml_read_num ( matroska , & pb , 8 , num ) ; \n }", "idx": 6386}
{"project": "FFmpeg", "commit_id": "de1b1a7da9e6ddf42447271e519099a88b389e4a", "target": 0, "func": "static int check ( AVIOContext * pb , int64_t pos ) \n { \n int64_t ret = avio_seek ( pb , pos , SEEK_SET ) ; \n unsigned header ; \n MPADecodeHeader sd ; \n if ( ret < 0 ) \n return ret ; \n header = avio_rb32 ( pb ) ; \n if ( ff_mpa_check_header ( header ) < 0 ) \n return -1 ; \n if ( avpriv_mpegaudio_decode_header ( & sd , header ) == 1 ) \n return -1 ; \n return sd . frame_size ; \n }", "idx": 6387}
{"project": "FFmpeg", "commit_id": "5b220e1e19c17b202d83d9be0868d152109ae8f0", "target": 1, "func": "static MpegTSService * mpegts_add_service ( MpegTSWrite * ts , int sid , \n const char * provider_name , \n const char * name ) \n { \n MpegTSService * service ; \n service = av_mallocz ( sizeof ( MpegTSService ) ) ; \n if ( ! service ) \n return NULL ; \n service -> pmt . pid = ts -> pmt_start_pid + ts -> nb_services ; \n service -> sid = sid ; \n service -> provider_name = av_strdup ( provider_name ) ; \n service -> name = av_strdup ( name ) ; \n service -> pcr_pid = 0x1fff ; \n dynarray_add ( & ts -> services , & ts -> nb_services , service ) ; \n return service ; \n }", "idx": 6412}
{"project": "FFmpeg", "commit_id": "1bcd7fefcb3c1ec47978fdc64a9e8dfb9512ae62", "target": 1, "func": "static const uint8_t * parse_opus_ts_header ( const uint8_t * start , int * payload_len , int buf_len ) \n { \n const uint8_t * buf = start + 1 ; \n int start_trim_flag , end_trim_flag , control_extension_flag , control_extension_length ; \n uint8_t flags ; \n GetByteContext gb ; \n bytestream2_init ( & gb , buf , buf_len ) ; \n flags = bytestream2_get_byte ( & gb ) ; \n start_trim_flag = ( flags >> 4 ) & 1 ; \n end_trim_flag = ( flags >> 3 ) & 1 ; \n control_extension_flag = ( flags >> 2 ) & 1 ; \n * payload_len = 0 ; \n while ( bytestream2_peek_byte ( & gb ) == 0xff ) \n * payload_len += bytestream2_get_byte ( & gb ) ; \n * payload_len += bytestream2_get_byte ( & gb ) ; \n if ( start_trim_flag ) \n bytestream2_skip ( & gb , 2 ) ; \n if ( end_trim_flag ) \n bytestream2_skip ( & gb , 2 ) ; \n if ( control_extension_flag ) { \n control_extension_length = bytestream2_get_byte ( & gb ) ; \n bytestream2_skip ( & gb , control_extension_length ) ; \n } \n return buf + bytestream2_tell ( & gb ) ; \n }", "idx": 6414}
{"project": "FFmpeg", "commit_id": "635ac8e1be91e941908f85642e4bbb609e48193f", "target": 1, "func": "static int handle_ping ( URLContext * s , RTMPPacket * pkt ) \n { \n RTMPContext * rt = s -> priv_data ; \n int t , ret ; \n if ( pkt -> data_size < 2 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n pkt -> data_size ) ; \n return AVERROR_INVALIDDATA ; \n t = AV_RB16 ( pkt -> data ) ; \n if ( t == 6 ) { \n if ( ( ret = gen_pong ( s , rt , pkt ) ) < 0 ) \n return 0 ;", "idx": 6418}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFilterBufferRef * outpicref = outlink -> out_buf ; \n OverlayContext * over = ctx -> priv ; \n if ( over -> overpicref && \n ! ( over -> x >= outpicref -> video -> w || over -> y >= outpicref -> video -> h || \n y + h < over -> y || y >= over -> y + over -> overpicref -> video -> h ) ) { \n blend_slice ( ctx , outpicref , over -> overpicref , over -> x , over -> y , \n over -> overpicref -> video -> w , over -> overpicref -> video -> h , \n y , outpicref -> video -> w , h ) ; \n } \n avfilter_draw_slice ( outlink , y , h , slice_dir ) ; \n }", "idx": 6419}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int avpicture_get_size ( enum PixelFormat pix_fmt , int width , int height ) \n { \n AVPicture dummy_pict ; \n if ( av_image_check_size ( width , height , 0 , NULL ) ) \n return -1 ; \n switch ( pix_fmt ) { \n case PIX_FMT_RGB8 : \n case PIX_FMT_BGR8 : \n case PIX_FMT_RGB4_BYTE : \n case PIX_FMT_BGR4_BYTE : \n case PIX_FMT_GRAY8 : \n return width * height ; \n } \n return avpicture_fill ( & dummy_pict , NULL , pix_fmt , width , height ) ; \n }", "idx": 6422}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static void rm_read_metadata ( AVFormatContext * s , int wide ) \n { \n char buf [ 1024 ] ; \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ff_rm_metadata ) ; i ++ ) { \n int len = wide ? avio_rb16 ( s -> pb ) : avio_r8 ( s -> pb ) ; \n get_strl ( s -> pb , buf , sizeof ( buf ) , len ) ; \n av_dict_set ( & s -> metadata , ff_rm_metadata [ i ] , buf , 0 ) ; \n } \n }", "idx": 6435}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "void ff_jpeg2000_set_significance ( Jpeg2000T1Context * t1 , int x , int y , \n int negative ) \n { \n x ++ ; \n y ++ ; \n t1 -> flags [ y ] [ x ] |= JPEG2000_T1_SIG ; \n if ( negative ) { \n t1 -> flags [ y ] [ x + 1 ] |= JPEG2000_T1_SIG_W | JPEG2000_T1_SGN_W ; \n t1 -> flags [ y ] [ x - 1 ] |= JPEG2000_T1_SIG_E | JPEG2000_T1_SGN_E ; \n t1 -> flags [ y + 1 ] [ x ] |= JPEG2000_T1_SIG_N | JPEG2000_T1_SGN_N ; \n t1 -> flags [ y - 1 ] [ x ] |= JPEG2000_T1_SIG_S | JPEG2000_T1_SGN_S ; \n } else { \n t1 -> flags [ y ] [ x + 1 ] |= JPEG2000_T1_SIG_W ; \n t1 -> flags [ y ] [ x - 1 ] |= JPEG2000_T1_SIG_E ; \n t1 -> flags [ y + 1 ] [ x ] |= JPEG2000_T1_SIG_N ; \n t1 -> flags [ y - 1 ] [ x ] |= JPEG2000_T1_SIG_S ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_SIG_NW ; \n t1 -> flags [ y + 1 ] [ x - 1 ] |= JPEG2000_T1_SIG_NE ; \n t1 -> flags [ y - 1 ] [ x + 1 ] |= JPEG2000_T1_SIG_SW ; \n t1 -> flags [ y - 1 ] [ x - 1 ] |= JPEG2000_T1_SIG_SE ; \n }", "idx": 6443}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static inline int pic_is_unused ( H264Context * h , Picture * pic ) \n { \n if ( pic -> f . data [ 0 ] == NULL ) \n return 1 ; \n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) \n return 1 ; \n return 0 ; \n }", "idx": 6446}
{"project": "FFmpeg", "commit_id": "e3d8504fd043bdc2535525128b158fbc1fb18c67", "target": 0, "func": "static int hls_mux_init ( AVFormatContext * s ) \n { \n HLSContext * hls = s -> priv_data ; \n AVFormatContext * oc ; \n AVFormatContext * vtt_oc ; \n int i , ret ; \n ret = avformat_alloc_output_context2 ( & hls -> avf , hls -> oformat , NULL , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n oc = hls -> avf ; \n oc -> oformat = hls -> oformat ; \n oc -> interrupt_callback = s -> interrupt_callback ; \n oc -> max_delay = s -> max_delay ; \n av_dict_copy ( & oc -> metadata , s -> metadata , 0 ) ; \n if ( hls -> vtt_oformat ) { \n ret = avformat_alloc_output_context2 ( & hls -> vtt_avf , hls -> vtt_oformat , NULL , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n vtt_oc = hls -> vtt_avf ; \n vtt_oc -> oformat = hls -> vtt_oformat ; \n av_dict_copy ( & vtt_oc -> metadata , s -> metadata , 0 ) ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st ; \n AVFormatContext * loc ; \n if ( s -> streams [ i ] -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE ) \n loc = vtt_oc ; \n else \n loc = oc ; \n if ( ! ( st = avformat_new_stream ( loc , NULL ) ) ) \n return AVERROR ( ENOMEM ) ; \n avcodec_copy_context ( st -> codec , s -> streams [ i ] -> codec ) ; \n st -> sample_aspect_ratio = s -> streams [ i ] -> sample_aspect_ratio ; \n st -> time_base = s -> streams [ i ] -> time_base ; \n } \n hls -> start_pos = 0 ; \n return 0 ; \n }", "idx": 6449}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void idct_put_altivec ( uint8_t * dest , int stride , vector_s16_t * block ) \n { \n POWERPC_TBL_DECLARE ( altivec_idct_put_num , 1 ) ; \n #ifdef ALTIVEC_USE_REFERENCE_C_CODE \n POWERPC_TBL_START_COUNT ( altivec_idct_put_num , 1 ) ; \n void simple_idct_put ( uint8_t * dest , int line_size , int16_t * block ) ; \n simple_idct_put ( dest , stride , ( int16_t * ) block ) ; \n POWERPC_TBL_STOP_COUNT ( altivec_idct_put_num , 1 ) ; \n #else \n vector_u8_t tmp ; \n POWERPC_TBL_START_COUNT ( altivec_idct_put_num , 1 ) ; \n IDCT  \n #define COPY ( dest , src ) \t\t\t\t\t\t\\ \n  \n  tmp = vec_packsu ( src , src ) ; \n vec_ste ( ( vector_u32_t ) tmp , 0 , ( unsigned int * ) dest ) ; \n vec_ste ( ( vector_u32_t ) tmp , 4 , ( unsigned int * ) dest ) ; \n COPY ( dest , vx0 ) dest += stride ; \n COPY ( dest , vx1 ) dest += stride ; \n COPY ( dest , vx2 ) dest += stride ; \n COPY ( dest , vx3 ) dest += stride ; \n COPY ( dest , vx4 ) dest += stride ; \n COPY ( dest , vx5 ) dest += stride ; \n COPY ( dest , vx6 ) dest += stride ; \n COPY ( dest , vx7 )  \n POWERPC_TBL_STOP_COUNT ( altivec_idct_put_num , 1 ) ; \n #endif \n }", "idx": 6450}
{"project": "FFmpeg", "commit_id": "bdf3d3bf9dce398acce608de77da205e08bdace3", "target": 0, "func": "static void opt_top_field_first ( const char * arg ) \n { \n top_field_first = atoi ( arg ) ; \n }", "idx": 6451}
{"project": "FFmpeg", "commit_id": "79798f7c57b098c78e0bbc6becd64b9888b013d1", "target": 1, "func": "static int unpack_parse_unit ( DiracParseUnit * pu , DiracParseContext * pc , \n int offset ) \n { \n uint8_t * start = pc -> buffer + offset ; \n uint8_t * end = pc -> buffer + pc -> index ; \n if ( start < pc -> buffer || ( start + 13 > end ) ) \n return 0 ; \n pu -> pu_type = start [ 4 ] ; \n pu -> next_pu_offset = AV_RB32 ( start + 5 ) ; \n pu -> prev_pu_offset = AV_RB32 ( start + 9 ) ; \n if ( pu -> pu_type == 0x10 && pu -> next_pu_offset == 0 ) \n pu -> next_pu_offset = 13 ; \n return 1 ; \n }", "idx": 6460}
{"project": "FFmpeg", "commit_id": "4fded0480f20f4d7ca5e776a85574de34dfead14", "target": 1, "func": "static int h264_init_context ( AVCodecContext * avctx , H264Context * h ) \n { \n int i ; \n h -> avctx = avctx ; \n h -> picture_structure = PICT_FRAME ; \n h -> workaround_bugs = avctx -> workaround_bugs ; \n h -> flags = avctx -> flags ; \n h -> poc . prev_poc_msb = 1 << 16 ; \n h -> recovery_frame = -1 ; \n h -> frame_recovered = 0 ; \n h -> next_outputed_poc = INT_MIN ; \n for ( i = 0 ; i < MAX_DELAYED_PIC_COUNT ; i ++ ) \n h -> last_pocs [ i ] = INT_MIN ; \n ff_h264_sei_uninit ( & h -> sei ) ; \n avctx -> chroma_sample_location = AVCHROMA_LOC_LEFT ; \n h -> nb_slice_ctx = ( avctx -> active_thread_type & FF_THREAD_SLICE ) ? avctx -> thread_count : 1 ; \n h -> slice_ctx = av_mallocz_array ( h -> nb_slice_ctx , sizeof ( * h -> slice_ctx ) ) ; \n if ( ! h -> slice_ctx ) { \n h -> nb_slice_ctx = 0 ; \n return AVERROR ( ENOMEM ) ; \n } \n for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) { \n h -> DPB [ i ] . f = av_frame_alloc ( ) ; \n if ( ! h -> DPB [ i ] . f ) \n return AVERROR ( ENOMEM ) ; \n } \n h -> cur_pic . f = av_frame_alloc ( ) ; \n if ( ! h -> cur_pic . f ) \n return AVERROR ( ENOMEM ) ; \n h -> output_frame = av_frame_alloc ( ) ; \n if ( ! h -> output_frame ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < h -> nb_slice_ctx ; i ++ ) \n h -> slice_ctx [ i ] . h264 = h ; \n return 0 ; \n }", "idx": 6468}
{"project": "FFmpeg", "commit_id": "e86df0206f06b8d1e97e2b60db8f74a398d53127", "target": 0, "func": "static int xcbgrab_reposition ( AVFormatContext * s , \n xcb_query_pointer_reply_t * p , \n xcb_get_geometry_reply_t * geo ) \n { \n XCBGrabContext * c = s -> priv_data ; \n int x = c -> x , y = c -> y , p_x = p -> win_x , p_y = p -> win_y ; \n int w = c -> width , h = c -> height , f = c -> follow_mouse ; \n if ( ! p || ! geo ) \n return AVERROR ( EIO ) ; \n if ( f == FOLLOW_CENTER ) { \n x = p_x - w / 2 ; \n y = p_y - h / 2 ; \n } else { \n int left = x + f ; \n int right = x + w - f ; \n int top = y + f ; \n int bottom = y + h + f ; \n if ( p_x > right ) { \n x += p_x - right ; \n } else if ( p_x < left ) { \n x -= left - p_x ; \n } \n if ( p_y > bottom ) { \n y += p_y - bottom ; \n } else if ( p_y < top ) { \n y -= top - p_y ; \n } \n } \n c -> x = FFMIN ( FFMAX ( 0 , x ) , geo -> width - w ) ; \n c -> y = FFMIN ( FFMAX ( 0 , y ) , geo -> height - h ) ; \n return 0 ; \n }", "idx": 6469}
{"project": "FFmpeg", "commit_id": "0c67864a37a5a6dee19341da6e6cfa369c52d1db", "target": 1, "func": "static int vp9_alloc_frame ( AVCodecContext * ctx , VP9Frame * f ) \n { \n VP9Context * s = ctx -> priv_data ; \n int ret , sz ; \n if ( ( ret = ff_thread_get_buffer ( ctx , & f -> tf , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) \n return ret ; \n sz = 64 * s -> sb_cols * s -> sb_rows ; \n if ( ! ( f -> extradata = av_buffer_allocz ( sz * ( 1 + sizeof ( struct VP9mvrefPair ) ) ) ) ) { \n ff_thread_release_buffer ( ctx , & f -> tf ) ; \n return AVERROR ( ENOMEM ) ; \n } \n f -> segmentation_map = f -> extradata -> data ; \n f -> mv = ( struct VP9mvrefPair * ) ( f -> extradata -> data + sz ) ; \n if ( s -> segmentation . enabled && ! s -> segmentation . update_map && \n ! s -> keyframe && ! s -> intraonly ) { \n memcpy ( f -> segmentation_map , s -> frames [ LAST_FRAME ] . segmentation_map , sz ) ; \n } \n return 0 ; \n }", "idx": 6477}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "int ff_get_best_fcode ( MpegEncContext * s , int16_t ( * mv_table ) [ 2 ] , int type ) \n { \n int f_code ; \n if ( s -> me_method >= ME_EPZS ) { \n int mv_num [ 8 ] ; \n int i , y ; \n int loose = 0 ; \n UINT8 * fcode_tab = s -> fcode_tab ; \n for ( i = 0 ; i < 8 ; i ++ ) mv_num [ i ] = 0 ; \n for ( y = 0 ; y < s -> mb_height ; y ++ ) { \n int x ; \n int xy = ( y + 1 ) * ( s -> mb_width + 2 ) + 1 ; \n i = y * s -> mb_width ; \n for ( x = 0 ; x < s -> mb_width ; x ++ ) { \n if ( s -> mb_type [ i ] & type ) { \n mv_num [ fcode_tab [ mv_table [ xy ] [ 0 ] + MAX_MV ] ] ++ ; \n mv_num [ fcode_tab [ mv_table [ xy ] [ 1 ] + MAX_MV ] ] ++ ; \n } \n i ++ ; \n xy ++ ; \n } \n } \n for ( i = MAX_FCODE ; i > 1 ; i -- ) { \n int threshold ; \n loose += mv_num [ i ] ; \n if ( s -> pict_type == B_TYPE ) threshold = 0 ; \n else threshold = s -> mb_num / 20 ; \n if ( loose > threshold ) break ; \n } \n return i ; \n } else { \n return 1 ; \n } \n }", "idx": 6483}
{"project": "FFmpeg", "commit_id": "ef9f8dd7305e39f5579b33abeec425c11f4f1b6d", "target": 0, "func": "static void start_frame ( AVFilterLink * link , AVFilterPicRef * picref ) \n { \n CropContext * crop = link -> dst -> priv ; \n AVFilterPicRef * ref2 = avfilter_ref_pic ( picref , ~ 0 ) ; \n int i ; \n ref2 -> w = crop -> w ; \n ref2 -> h = crop -> h ; \n ref2 -> data [ 0 ] += crop -> y * ref2 -> linesize [ 0 ] ; \n ref2 -> data [ 0 ] += ( crop -> x * crop -> bpp ) >> 3 ; \n if ( link -> format != PIX_FMT_PAL8 && \n link -> format != PIX_FMT_BGR4_BYTE && \n link -> format != PIX_FMT_RGB4_BYTE && \n link -> format != PIX_FMT_BGR8 && \n link -> format != PIX_FMT_RGB8 ) { \n for ( i = 1 ; i < 3 ; i ++ ) { \n if ( ref2 -> data [ i ] ) { \n ref2 -> data [ i ] += ( crop -> y >> crop -> vsub ) * ref2 -> linesize [ i ] ; \n ref2 -> data [ i ] += ( ( crop -> x * crop -> bpp ) >> 3 ) >> crop -> hsub ; \n } \n } \n } \n if ( ref2 -> data [ 3 ] ) { \n ref2 -> data [ 3 ] += crop -> y * ref2 -> linesize [ 3 ] ; \n ref2 -> data [ 3 ] += ( crop -> x * crop -> bpp ) >> 3 ; \n } \n avfilter_start_frame ( link -> dst -> outputs [ 0 ] , ref2 ) ; \n }", "idx": 6485}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int pcm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> frame_size = 0 ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_PCM_ALAW : \n pcm_alaw_tableinit ( ) ; \n break ; \n case CODEC_ID_PCM_MULAW : \n pcm_ulaw_tableinit ( ) ; \n break ; \n default : \n break ; \n } \n avctx -> bits_per_coded_sample = av_get_bits_per_sample ( avctx -> codec -> id ) ; \n avctx -> block_align = avctx -> channels * avctx -> bits_per_coded_sample / 8 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n return 0 ; \n }", "idx": 6492}
{"project": "FFmpeg", "commit_id": "3faa303a47e0c3b59a53988e0f76018930c6cb1a", "target": 0, "func": "static int rv34_decode_cbp ( GetBitContext * gb , RV34VLC * vlc , int table ) \n { \n int pattern , code , cbp = 0 ; \n int ones ; \n static const int cbp_masks [ 3 ] = { 0x100000 , 0x010000 , 0x110000 } ; \n static const int shifts [ 4 ] = { 0 , 2 , 8 , 10 } ; \n const int * curshift = shifts ; \n int i , t , mask ; \n code = get_vlc2 ( gb , vlc -> cbppattern [ table ] . table , 9 , 2 ) ; \n pattern = code & 0xF ; \n code >>= 4 ; \n ones = rv34_count_ones [ pattern ] ; \n for ( mask = 8 ; mask ; mask >>= 1 , curshift ++ ) { \n if ( pattern & mask ) \n cbp |= get_vlc2 ( gb , vlc -> cbp [ table ] [ ones ] . table , vlc -> cbp [ table ] [ ones ] . bits , 1 ) << curshift [ 0 ] ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n t = modulo_three_table [ code ] [ i ] ; \n if ( t == 1 ) \n cbp |= cbp_masks [ get_bits1 ( gb ) ] << i ; \n if ( t == 2 ) \n cbp |= cbp_masks [ 2 ] << i ; \n } \n return cbp ; \n }", "idx": 6497}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmac_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * src0 , float scale ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n memcpy ( cdst , v1 , LEN * sizeof ( * v1 ) ) ; \n memcpy ( odst , v1 , LEN * sizeof ( * v1 ) ) ; \n cdsp -> vector_fmac_scalar ( cdst , src0 , scale , LEN ) ; \n fdsp -> vector_fmac_scalar ( odst , src0 , scale , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , ARBITRARY_FMAC_SCALAR_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6512}
{"project": "FFmpeg", "commit_id": "9054f6b66b3883d615177c738cb69c6337c4375c", "target": 1, "func": "static void probe_codec ( AVFormatContext * s , AVStream * st , const AVPacket * pkt ) \n { \n if ( st -> request_probe > 0 ) { \n AVProbeData * pd = & st -> probe_data ; \n int end ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index , st -> probe_packets ) ; \n -- st -> probe_packets ; \n if ( pkt ) { \n pd -> buf = av_realloc ( pd -> buf , pd -> buf_size + pkt -> size + AVPROBE_PADDING_SIZE ) ; \n memcpy ( pd -> buf + pd -> buf_size , pkt -> data , pkt -> size ) ; \n pd -> buf_size += pkt -> size ; \n memset ( pd -> buf + pd -> buf_size , 0 , AVPROBE_PADDING_SIZE ) ; \n } else { \n st -> probe_packets = 0 ; \n } \n end = s -> raw_packet_buffer_remaining_size <= 0 \n || st -> probe_packets <= 0 ; \n if ( end || av_log2 ( pd -> buf_size ) != av_log2 ( pd -> buf_size - pkt -> size ) ) { \n int score = set_codec_from_probe_data ( s , st , pd ) ; \n if ( ( st -> codec -> codec_id != CODEC_ID_NONE && score > AVPROBE_SCORE_MAX / 4 ) \n || end ) { \n pd -> buf_size = 0 ; \n av_freep ( & pd -> buf ) ; \n st -> request_probe = -1 ; \n if ( st -> codec -> codec_id != CODEC_ID_NONE ) { \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index ) ; \n } else \n av_log ( s , AV_LOG_WARNING , \" \\n \" , st -> index ) ; \n } \n } \n } \n }", "idx": 6521}
{"project": "FFmpeg", "commit_id": "1ee20141900c98f9dc25eca121c66c3ff468c1e4", "target": 0, "func": "static av_cold int init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n UnsharpContext * unsharp = ctx -> priv ; \n int lmsize_x = 5 , cmsize_x = 0 ; \n int lmsize_y = 5 , cmsize_y = 0 ; \n double lamount = 1.0f , camount = 0.0f ; \n if ( args ) \n sscanf ( args , \" \" , & lmsize_x , & lmsize_y , & lamount , \n & cmsize_x , & cmsize_y , & camount ) ; \n if ( ( lamount && ( lmsize_x < 2 || lmsize_y < 2 ) ) || \n ( camount && ( cmsize_x < 2 || cmsize_y < 2 ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n lmsize_x , lmsize_y , cmsize_x , cmsize_y ) ; \n return AVERROR ( EINVAL ) ; \n } \n set_filter_param ( & unsharp -> luma , lmsize_x , lmsize_y , lamount ) ; \n set_filter_param ( & unsharp -> chroma , cmsize_x , cmsize_y , camount ) ; \n return 0 ; \n }", "idx": 6534}
{"project": "FFmpeg", "commit_id": "ca6c3f2c53be70aa3c38e8f1292809db89ea1ba6", "target": 1, "func": "static inline void copy_backptr ( LZOContext * c , int back , int cnt ) \n { \n register const uint8_t * src = & c -> out [ - back ] ; \n register uint8_t * dst = c -> out ; \n if ( src < c -> out_start || src > dst ) { \n c -> error |= AV_LZO_INVALID_BACKPTR ; \n return ; \n } \n if ( cnt > c -> out_end - dst ) { \n cnt = FFMAX ( c -> out_end - dst , 0 ) ; \n c -> error |= AV_LZO_OUTPUT_FULL ; \n } \n av_memcpy_backptr ( dst , back , cnt ) ; \n c -> out = dst + cnt ; \n }", "idx": 6544}
{"project": "FFmpeg", "commit_id": "4391805916a1557278351f25428d0145b1073520", "target": 1, "func": "rgb48funcs ( rgb , LE , PIX_FMT_RGB48LE )  \n rgb48funcs ( rgb , BE , PIX_FMT_RGB48BE )  \n rgb48funcs ( bgr , LE , PIX_FMT_BGR48LE )  \n rgb48funcs ( bgr , BE , PIX_FMT_BGR48BE )  \n #define input_pixel ( i )  ((origin == PIX_FMT_RGBA || origin == PIX_FMT_BGRA || \\ \n   \n  origin == PIX_FMT_ARGB || origin == PIX_FMT_ABGR ) ? AV_RN32A ( & src [ ( i ) * 4 ] ) : \n ( isBE ( origin ) ? AV_RB16 ( & src [ ( i ) * 2 ] ) : AV_RL16 ( & src [ ( i ) * 2 ] ) ) ) \n static av_always_inline void \n rgb16_32ToY_c_template ( uint8_t * dst , const uint8_t * src , \n int width , enum PixelFormat origin , \n int shr , int shg , int shb , int shp , \n int maskr , int maskg , int maskb , \n int rsh , int gsh , int bsh , int S ) \n { \n const int ry = RY << rsh , gy = GY << gsh , by = BY << bsh , \n rnd = 33 << ( S - 1 ) ; \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int px = input_pixel ( i ) >> shp ; \n int b = ( px & maskb ) >> shb ; \n int g = ( px & maskg ) >> shg ; \n int r = ( px & maskr ) >> shr ; \n dst [ i ] = ( ry * r + gy * g + by * b + rnd ) >> S ; \n } \n }", "idx": 6568}
{"project": "FFmpeg", "commit_id": "8540dcfd7af14da4080770dfbfa997cffdd0878b", "target": 1, "func": "static av_always_inline int check_block ( SnowContext * s , int mb_x , int mb_y , int p [ 3 ] , int intra , const uint8_t * obmc_edged , int * best_rd ) { \n const int b_stride = s -> b_width << s -> block_max_depth ; \n BlockNode * block = & s -> block [ mb_x + mb_y * b_stride ] ; \n BlockNode backup = * block ; \n int rd , index , value ; \n assert ( mb_x >= 0 && mb_y >= 0 ) ; \n assert ( mb_x < b_stride ) ; \n if ( intra ) { \n block -> color [ 0 ] = p [ 0 ] ; \n block -> color [ 1 ] = p [ 1 ] ; \n block -> color [ 2 ] = p [ 2 ] ; \n block -> type |= BLOCK_INTRA ; \n } else { \n index = ( p [ 0 ] + 31 * p [ 1 ] ) & ( ME_CACHE_SIZE - 1 ) ; \n value = s -> me_cache_generation + ( p [ 0 ] >> 10 ) + ( p [ 1 ] << 6 ) + ( block -> ref << 12 ) ; \n if ( s -> me_cache [ index ] == value ) \n return 0 ; \n s -> me_cache [ index ] = value ; \n block -> mx = p [ 0 ] ; \n block -> my = p [ 1 ] ; \n block -> type &= ~ BLOCK_INTRA ; \n } \n rd = get_block_rd ( s , mb_x , mb_y , 0 , obmc_edged ) ; \n if ( rd < * best_rd ) { \n * best_rd = rd ; \n return 1 ; \n } else { \n * block = backup ; \n return 0 ; \n } \n }", "idx": 6573}
{"project": "FFmpeg", "commit_id": "7a28b7714e4503149f773782a19708c773f3d62d", "target": 0, "func": "static int gif_parse_next_image ( GifState * s ) \n { \n for ( ; ; ) { \n int code = bytestream_get_byte ( & s -> bytestream ) ; \n #ifdef DEBUG \n dprintf ( s -> avctx , \" \\n \" , code , code ) ; \n #endif \n switch ( code ) { \n case ' ' : \n if ( gif_read_image ( s ) < 0 ) \n return -1 ; \n return 0 ; \n case ' ' : \n return -1 ; \n case ' ' : \n if ( gif_read_extension ( s ) < 0 ) \n return -1 ; \n break ; \n default : \n return -1 ; \n } \n } \n }", "idx": 6581}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_reverse ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul_reverse ( cdst , v1 , v2 , LEN ) ; \n fdsp -> vector_fmul_reverse ( odst , v1 , v2 , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , FLT_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 6582}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x3 ( IpvideoContext * s ) \n { \n unsigned char B ; \n int x , y ; \n CHECK_STREAM_PTR ( 1 ) ; \n B = * s -> stream_ptr ++ ; \n if ( B < 56 ) { \n x = - ( 8 + ( B % 7 ) ) ; \n y = - ( B / 7 ) ; \n } else { \n x = - ( -14 + ( ( B - 56 ) % 29 ) ) ; \n y = - ( 8 + ( ( B - 56 ) / 29 ) ) ; \n } \n debug_interplay ( \" \\n \" , B , x , y ) ; \n return copy_from ( s , & s -> current_frame , x , y ) ; \n }", "idx": 6583}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) \n { \n int y ; \n unsigned char pix ; \n CHECK_STREAM_PTR ( 1 ) ; \n pix = * s -> stream_ptr ++ ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n memset ( s -> pixel_ptr , pix , 8 ) ; \n s -> pixel_ptr += s -> stride ; \n } \n return 0 ; \n }", "idx": 6585}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void dca_init_vlcs ( void ) \n { \n static int vlcs_inited = 0 ; \n int i , j ; \n if ( vlcs_inited ) \n return ; \n dca_bitalloc_index . offset = 1 ; \n dca_bitalloc_index . wrap = 2 ; \n for ( i = 0 ; i < 5 ; i ++ ) \n init_vlc ( & dca_bitalloc_index . vlc [ i ] , bitalloc_12_vlc_bits [ i ] , 12 , \n bitalloc_12_bits [ i ] , 1 , 1 , \n bitalloc_12_codes [ i ] , 2 , 2 , 1 ) ; \n dca_scalefactor . offset = -64 ; \n dca_scalefactor . wrap = 2 ; \n for ( i = 0 ; i < 5 ; i ++ ) \n init_vlc ( & dca_scalefactor . vlc [ i ] , SCALES_VLC_BITS , 129 , \n scales_bits [ i ] , 1 , 1 , \n scales_codes [ i ] , 2 , 2 , 1 ) ; \n dca_tmode . offset = 0 ; \n dca_tmode . wrap = 1 ; \n for ( i = 0 ; i < 4 ; i ++ ) \n init_vlc ( & dca_tmode . vlc [ i ] , tmode_vlc_bits [ i ] , 4 , \n tmode_bits [ i ] , 1 , 1 , \n tmode_codes [ i ] , 2 , 2 , 1 ) ; \n for ( i = 0 ; i < 10 ; i ++ ) \n for ( j = 0 ; j < 7 ; j ++ ) { \n if ( ! bitalloc_codes [ i ] [ j ] ) break ; \n dca_smpl_bitalloc [ i + 1 ] . offset = bitalloc_offsets [ i ] ; \n dca_smpl_bitalloc [ i + 1 ] . wrap = 1 + ( j > 4 ) ; \n init_vlc ( & dca_smpl_bitalloc [ i + 1 ] . vlc [ j ] , bitalloc_maxbits [ i ] [ j ] , \n bitalloc_sizes [ i ] , \n bitalloc_bits [ i ] [ j ] , 1 , 1 , \n bitalloc_codes [ i ] [ j ] , 2 , 2 , 1 ) ; \n } \n vlcs_inited = 1 ; \n }", "idx": 6617}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static inline int is_yuv_planar ( PixFmtInfo * ps ) \n { \n return ( ps -> color_type == FF_COLOR_YUV || \n ps -> color_type == FF_COLOR_YUV_JPEG ) && ! ps -> is_packed ; \n }", "idx": 6620}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "AVFilter * avfilter_get_by_name ( const char * name ) \n { \n int i ; \n for ( i = 0 ; registered_avfilters [ i ] ; i ++ ) \n if ( ! strcmp ( registered_avfilters [ i ] -> name , name ) ) \n return registered_avfilters [ i ] ; \n return NULL ; \n }", "idx": 6621}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int output_frame ( H264Context * h , AVFrame * dst , AVFrame * src ) \n { \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! h -> sps . crop ) \n return 0 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int hshift = ( i > 0 ) ? h -> chroma_x_shift : 0 ; \n int vshift = ( i > 0 ) ? h -> chroma_y_shift : 0 ; \n int off = ( ( h -> sps . crop_left >> hshift ) << h -> pixel_shift ) + \n ( h -> sps . crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 6623}
{"project": "FFmpeg", "commit_id": "a863c97e99bf30a88baa74f83bab9e3ab25984dc", "target": 1, "func": "static void get_private_data ( OutputStream * os ) \n { \n AVCodecContext * codec = os -> ctx -> streams [ 0 ] -> codec ; \n uint8_t * ptr = codec -> extradata ; \n int size = codec -> extradata_size ; \n int i ; \n if ( codec -> codec_id == AV_CODEC_ID_H264 ) { \n ff_avc_write_annexb_extradata ( ptr , & ptr , & size ) ; \n if ( ! ptr ) \n ptr = codec -> extradata ; \n } \n if ( ! ptr ) \n return ; \n os -> private_str = av_mallocz ( 2 * size + 1 ) ; \n if ( ! os -> private_str ) \n return ; \n for ( i = 0 ; i < size ; i ++ ) \n snprintf ( & os -> private_str [ 2 * i ] , 3 , \" \" , ptr [ i ] ) ; \n if ( ptr != codec -> extradata ) \n av_free ( ptr ) ; \n }", "idx": 6629}
{"project": "FFmpeg", "commit_id": "28eddef689f2b4843a84f7d05fd9614246f92cc4", "target": 0, "func": "static int hq_decode_block ( HQContext * c , GetBitContext * gb , int16_t block [ 64 ] , \n int qsel , int is_chroma , int is_hqa ) \n { \n const int32_t * q ; \n int val , pos = 1 ; \n memset ( block , 0 , 64 * sizeof ( * block ) ) ; \n if ( ! is_hqa ) { \n block [ 0 ] = get_sbits ( gb , 9 ) << 6 ; \n q = ff_hq_quants [ qsel ] [ is_chroma ] [ get_bits ( gb , 2 ) ] ; \n } else { \n q = ff_hq_quants [ qsel ] [ is_chroma ] [ get_bits ( gb , 2 ) ] ; \n block [ 0 ] = get_sbits ( gb , 9 ) << 6 ; \n } \n for ( ; ; ) { \n val = get_vlc2 ( gb , c -> hq_ac_vlc . table , 9 , 2 ) ; \n pos += ff_hq_ac_skips [ val ] ; \n if ( pos >= 64 ) \n break ; \n block [ ff_zigzag_direct [ pos ] ] = ( ff_hq_ac_syms [ val ] * q [ pos ] ) >> 12 ; \n pos ++ ; \n } \n return 0 ; \n }", "idx": 6640}
{"project": "FFmpeg", "commit_id": "13b6729361d45b9f308d731dd6b82dac01428dc3", "target": 1, "func": "static void final ( const short * i1 , const short * i2 , \n void * out , int * statbuf , int len ) \n { \n int x , i ; \n unsigned short int work [ 50 ] ; \n short * ptr = work ; \n memcpy ( work , statbuf , 20 ) ; \n memcpy ( work + 10 , i2 , len * 2 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n int sum = 0 ; \n for ( x = 0 ; x < 10 ; x ++ ) \n sum += i1 [ 9 - x ] * ptr [ x ] ; \n sum >>= 12 ; \n if ( ptr [ 10 ] - sum < -32768 || ptr [ 10 ] - sum > 32767 ) { \n memset ( out , 0 , len * 2 ) ; \n memset ( statbuf , 0 , 20 ) ; \n return ; \n } \n ptr [ 10 ] -= sum ; \n ptr ++ ; \n } \n memcpy ( out , work + 10 , len * 2 ) ; \n memcpy ( statbuf , work + 40 , 20 ) ; \n }", "idx": 6642}
{"project": "FFmpeg", "commit_id": "f2c539d3501111f10a2b4e9480ea54c0a3190680", "target": 1, "func": "static void residual_interp ( int16_t * buf , int16_t * out , int lag , \n int gain , int * rseed ) \n { \n int i ; \n if ( lag ) { \n int16_t * vector_ptr = buf + PITCH_MAX ; \n for ( i = 0 ; i < lag ; i ++ ) \n out [ i ] = vector_ptr [ i - lag ] * 3 >> 2 ; \n av_memcpy_backptr ( ( uint8_t * ) ( out + lag ) , lag * sizeof ( * out ) , \n ( FRAME_LEN - lag ) * sizeof ( * out ) ) ; \n } else { \n for ( i = 0 ; i < FRAME_LEN ; i ++ ) { \n * rseed = * rseed * 521 + 259 ; \n out [ i ] = gain * * rseed >> 15 ; \n } \n memset ( buf , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * buf ) ) ; \n } \n }", "idx": 6653}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int aiff_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AIFFOutputContext * aiff = s -> priv_data ; \n AVCodecParameters * par = s -> streams [ 0 ] -> codecpar ; \n int64_t file_size , end_size ; \n end_size = file_size = avio_tell ( pb ) ; \n if ( file_size & 1 ) { \n avio_w8 ( pb , 0 ) ; \n end_size ++ ; \n } \n if ( s -> pb -> seekable ) { \n avio_seek ( pb , aiff -> form , SEEK_SET ) ; \n avio_wb32 ( pb , file_size - aiff -> form - 4 ) ; \n avio_seek ( pb , aiff -> frames , SEEK_SET ) ; \n avio_wb32 ( pb , ( file_size - aiff -> ssnd - 12 ) / par -> block_align ) ; \n avio_seek ( pb , aiff -> ssnd , SEEK_SET ) ; \n avio_wb32 ( pb , file_size - aiff -> ssnd - 4 ) ; \n avio_seek ( pb , end_size , SEEK_SET ) ; \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 6656}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2rgb565_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2RGB ( % % REGBP , % 5 ) \n \" \\n \\t \" \n #ifdef DITHER1XBPP \n \" \" BLUE_DITHER \" \\n \\t \" \n \" \" GREEN_DITHER \" \\n \\t \" \n \" \" RED_DITHER \" \\n \\t \" \n #endif \n WRITERGB16 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n }", "idx": 6657}
{"project": "FFmpeg", "commit_id": "e421b79d01a3bf18d1ff8d8c4639669b66d788a5", "target": 1, "func": "static void copy_cell ( Indeo3DecodeContext * ctx , Plane * plane , Cell * cell ) \n { \n int h , w , mv_x , mv_y , offset , offset_dst ; \n uint8_t * src , * dst ; \n offset_dst = ( cell -> ypos << 2 ) * plane -> pitch + ( cell -> xpos << 2 ) ; \n dst = plane -> pixels [ ctx -> buf_sel ] + offset_dst ; \n mv_y = cell -> mv_ptr [ 0 ] ; \n mv_x = cell -> mv_ptr [ 1 ] ; \n offset = offset_dst + mv_y * plane -> pitch + mv_x ; \n src = plane -> pixels [ ctx -> buf_sel ^ 1 ] + offset ; \n h = cell -> height << 2 ; \n for ( w = cell -> width ; w > 0 ; ) { \n if ( ! ( ( cell -> xpos << 2 ) & 15 ) && w >= 4 ) { \n for ( ; w >= 4 ; src += 16 , dst += 16 , w -= 4 ) \n ctx -> dsp . put_no_rnd_pixels_tab [ 0 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n } \n if ( ! ( ( cell -> xpos << 2 ) & 7 ) && w >= 2 ) { \n ctx -> dsp . put_no_rnd_pixels_tab [ 1 ] [ 0 ] ( dst , src , plane -> pitch , h ) ; \n w -= 2 ; \n src += 8 ; \n dst += 8 ; \n } \n if ( w >= 1 ) { \n copy_block4 ( dst , src , plane -> pitch , plane -> pitch , h ) ; \n w -- ; \n src += 4 ; \n dst += 4 ; \n } \n } \n }", "idx": 6660}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_chroma_c ( uint8_t * pix , int stride , int alpha , int beta , int8_t * tc0 ) \n { \n h264_loop_filter_chroma_c ( pix , 1 , stride , alpha , beta , tc0 ) ; \n }", "idx": 6662}
{"project": "FFmpeg", "commit_id": "ca6776a993903dbcfef5ae8a18556c40ecf83e1c", "target": 1, "func": "static int fdk_aac_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n FDKAACDecContext * s = avctx -> priv_data ; \n AVFrame * frame = data ; \n int ret ; \n AAC_DECODER_ERROR err ; \n UINT valid = avpkt -> size ; \n err = aacDecoder_Fill ( s -> handle , & avpkt -> data , & avpkt -> size , & valid ) ; \n if ( err != AAC_DEC_OK ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , err ) ; \n return AVERROR_INVALIDDATA ; \n } \n err = aacDecoder_DecodeFrame ( s -> handle , ( INT_PCM * ) s -> decoder_buffer , s -> decoder_buffer_size , 0 ) ; \n if ( err == AAC_DEC_NOT_ENOUGH_BITS ) { \n ret = avpkt -> size - valid ; \n goto end ; \n } \n if ( err != AAC_DEC_OK ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , err ) ; \n ret = AVERROR_UNKNOWN ; \n goto end ; \n } \n if ( ( ret = get_stream_info ( avctx ) ) < 0 ) \n goto end ; \n frame -> nb_samples = avctx -> frame_size ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n goto end ; \n memcpy ( frame -> extended_data [ 0 ] , s -> decoder_buffer , \n avctx -> channels * avctx -> frame_size * \n av_get_bytes_per_sample ( avctx -> sample_fmt ) ) ; \n * got_frame_ptr = 1 ; \n ret = avpkt -> size - valid ; \n end : \n return ret ; \n }", "idx": 6666}
{"project": "FFmpeg", "commit_id": "6e9b060e4f0c24d2689bebd7fc03e52d75da25b2", "target": 1, "func": "static av_cold int png_dec_init ( AVCodecContext * avctx ) \n { \n PNGDecContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> previous_picture . f = av_frame_alloc ( ) ; \n s -> last_picture . f = av_frame_alloc ( ) ; \n s -> picture . f = av_frame_alloc ( ) ; \n if ( ! s -> previous_picture . f || ! s -> last_picture . f || ! s -> picture . f ) \n return AVERROR ( ENOMEM ) ; \n if ( ! avctx -> internal -> is_copy ) { \n avctx -> internal -> allocate_progress = 1 ; \n ff_pngdsp_init ( & s -> dsp ) ; \n } \n return 0 ; \n }", "idx": 6668}
{"project": "FFmpeg", "commit_id": "9221445fa001093307864a53f91c1172c239de18", "target": 1, "func": "static int tiff_unpack_fax ( TiffContext * s , uint8_t * dst , int stride , \n const uint8_t * src , int size , int width , int lines ) \n { \n int i , ret = 0 ; \n int line ; \n uint8_t * src2 = av_malloc ( ( unsigned ) size + \n AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! src2 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! s -> fill_order ) { \n memcpy ( src2 , src , size ) ; \n } else { \n for ( i = 0 ; i < size ; i ++ ) \n src2 [ i ] = ff_reverse [ src [ i ] ] ; \n } \n memset ( src2 + size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; \n ret = ff_ccitt_unpack ( s -> avctx , src2 , size , dst , lines , stride , \n s -> compr , s -> fax_opts ) ; \n if ( s -> bpp < 8 && s -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) \n for ( line = 0 ; line < lines ; line ++ ) { \n horizontal_fill ( s -> bpp , dst , 1 , dst , 0 , width , 0 ) ; \n dst += stride ; \n } \n av_free ( src2 ) ; \n return ret ; \n }", "idx": 6669}
{"project": "FFmpeg", "commit_id": "c28f648b19dd36ff9bc869ad527a1569a0b623e2", "target": 1, "func": "static int decode_block ( MJpegDecodeContext * s , int16_t * block , int component , \n int dc_index , int ac_index , uint16_t * quant_matrix ) \n { \n int code , i , j , level , val ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xfffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n val = val * quant_matrix [ 0 ] + s -> last_dc [ component ] ; \n val = FFMIN ( val , 32767 ) ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n i = 0 ; \n { OPEN_READER ( re , & s -> gb ) ; \n do { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 ) ; \n i += ( ( unsigned ) code ) >> 4 ; \n code &= 0xf ; \n if ( code ) { \n if ( code > MIN_CACHE_BITS - 16 ) \n UPDATE_CACHE ( re , & s -> gb ) ; \n { \n int cache = GET_CACHE ( re , & s -> gb ) ; \n int sign = ( ~ cache ) >> 31 ; \n level = ( NEG_USR32 ( sign ^ cache , code ) ^ sign ) - sign ; \n } \n LAST_SKIP_BITS ( re , & s -> gb , code ) ; \n if ( i > 63 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n j = s -> scantable . permutated [ i ] ; \n block [ j ] = level * quant_matrix [ i ] ; \n } \n } while ( i < 63 ) ; \n CLOSE_READER ( re , & s -> gb ) ; } \n return 0 ; \n }", "idx": 6684}
{"project": "FFmpeg", "commit_id": "9dd04f6d8cdd1c10c28b2cb4252c1a41df581915", "target": 1, "func": "static int process_frame_obj ( SANMVideoContext * ctx ) \n { \n uint16_t codec , top , left , w , h ; \n codec = bytestream2_get_le16u ( & ctx -> gb ) ; \n left = bytestream2_get_le16u ( & ctx -> gb ) ; \n top = bytestream2_get_le16u ( & ctx -> gb ) ; \n w = bytestream2_get_le16u ( & ctx -> gb ) ; \n h = bytestream2_get_le16u ( & ctx -> gb ) ; \n if ( ctx -> width < left + w || ctx -> height < top + h ) { \n if ( av_image_check_size ( FFMAX ( left + w , ctx -> width ) , \n FFMAX ( top + h , ctx -> height ) , 0 , ctx -> avctx ) < 0 ) \n avcodec_set_dimensions ( ctx -> avctx , FFMAX ( left + w , ctx -> width ) , \n FFMAX ( top + h , ctx -> height ) ) ; \n init_sizes ( ctx , FFMAX ( left + w , ctx -> width ) , \n FFMAX ( top + h , ctx -> height ) ) ; \n if ( init_buffers ( ctx ) ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n bytestream2_skip ( & ctx -> gb , 4 ) ; \n av_dlog ( ctx -> avctx , \" \\n \" , codec ) ; \n switch ( codec ) { \n case 1 : \n case 3 : \n return old_codec1 ( ctx , top , left , w , h ) ; \n break ; \n case 37 : \n return old_codec37 ( ctx , top , left , w , h ) ; \n break ; \n case 47 : \n return old_codec47 ( ctx , top , left , w , h ) ; \n break ; \n default : \n avpriv_request_sample ( ctx -> avctx , \" \" , codec ) ; \n return AVERROR_PATCHWELCOME ;", "idx": 6689}
{"project": "FFmpeg", "commit_id": "c447ab0e746c6b4d8d703a55190ae7444199e502", "target": 1, "func": "static int tgq_decode_mb ( TgqContext * s , AVFrame * frame , int mb_y , int mb_x ) \n { \n int mode ; \n int i ; \n int8_t dc [ 6 ] ; \n mode = bytestream2_get_byte ( & s -> gb ) ; \n if ( mode > 12 ) { \n GetBitContext gb ; \n init_get_bits8 ( & gb , s -> gb . buffer , FFMIN ( bytestream2_get_bytes_left ( & s -> gb ) , mode ) ) ; \n for ( i = 0 ; i < 6 ; i ++ ) \n tgq_decode_block ( s , s -> block [ i ] , & gb ) ; \n tgq_idct_put_mb ( s , s -> block , frame , mb_x , mb_y ) ; \n bytestream2_skip ( & s -> gb , mode ) ; \n } else { \n if ( mode == 3 ) { \n memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ; \n dc [ 4 ] = bytestream2_get_byte ( & s -> gb ) ; \n dc [ 5 ] = bytestream2_get_byte ( & s -> gb ) ; \n } else if ( mode == 6 ) { \n bytestream2_get_buffer ( & s -> gb , dc , 6 ) ; \n } else if ( mode == 12 ) { \n for ( i = 0 ; i < 6 ; i ++ ) { \n dc [ i ] = bytestream2_get_byte ( & s -> gb ) ; \n bytestream2_skip ( & s -> gb , 1 ) ; \n } \n } else { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , mode ) ; \n return -1 ; \n } \n tgq_idct_put_mb_dconly ( s , frame , mb_x , mb_y , dc ) ; \n } \n return 0 ; \n }", "idx": 6690}
{"project": "FFmpeg", "commit_id": "28dc6e729137ba7927f46ba15c337417b8708fe8", "target": 1, "func": "static inline void idct4col_put ( uint8_t * dest , int line_size , const int16_t * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 2 ] ; \n a2 = col [ 8 * 4 ] ; \n a3 = col [ 8 * 6 ] ; \n c0 = ( ( a0 + a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( ( a0 - a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = av_clip_uint8 ( ( c0 + c1 ) >> C_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = av_clip_uint8 ( ( c2 + c3 ) >> C_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = av_clip_uint8 ( ( c2 - c3 ) >> C_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = av_clip_uint8 ( ( c0 - c1 ) >> C_SHIFT ) ; \n }", "idx": 6693}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "void fifo_realloc ( FifoBuffer * f , int new_size ) { \n int old_size = f -> end - f -> buffer ; \n if ( old_size < new_size ) { \n uint8_t * old = f -> buffer ; \n f -> buffer = av_realloc ( f -> buffer , new_size ) ; \n f -> rptr += f -> buffer - old ; \n f -> wptr += f -> buffer - old ; \n if ( f -> wptr < f -> rptr ) { \n memmove ( f -> rptr + new_size - old_size , f -> rptr , f -> buffer + old_size - f -> rptr ) ; \n f -> rptr += new_size - old_size ; \n } \n f -> end = f -> buffer + new_size ; \n } \n }", "idx": 6695}
{"project": "FFmpeg", "commit_id": "dacf07661467bc349d17bdab06516daceabffb23", "target": 1, "func": "static int ogg_write_trailer ( AVFormatContext * s ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n ogg_buffer_page ( s , s -> streams [ i ] -> priv_data ) ; \n ogg_write_pages ( s , 1 ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n OGGStreamContext * oggstream = st -> priv_data ; \n if ( st -> codec -> codec_id == CODEC_ID_FLAC || \n st -> codec -> codec_id == CODEC_ID_SPEEX ) { \n av_free ( oggstream -> header [ 0 ] ) ; \n } \n av_freep ( & st -> priv_data ) ; \n } \n return 0 ; \n }", "idx": 6703}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int roq_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 6 ) \n return 0 ; \n if ( ( AV_RL16 ( & p -> buf [ 0 ] ) != RoQ_MAGIC_NUMBER ) || \n ( AV_RL32 ( & p -> buf [ 2 ] ) != 0xFFFFFFFF ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 6707}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "inline static void RENAME ( hcscale ) ( SwsContext * c , uint16_t * dst , long dstWidth , const uint8_t * src1 , const uint8_t * src2 , \n int srcW , int xInc , const int16_t * hChrFilter , \n const int16_t * hChrFilterPos , int hChrFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal ) \n { \n src1 += c -> chrSrcOffset ; \n src2 += c -> chrSrcOffset ; \n if ( c -> chrToYV12 ) { \n c -> chrToYV12 ( formatConvBuffer , formatConvBuffer + VOFW , src1 , src2 , srcW , pal ) ; \n src1 = formatConvBuffer ; \n src2 = formatConvBuffer + VOFW ; \n } \n if ( c -> hScale16 ) { \n c -> hScale16 ( dst , dstWidth , ( uint16_t * ) src1 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; \n c -> hScale16 ( dst + VOFW , dstWidth , ( uint16_t * ) src2 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; \n } else if ( ! c -> hcscale_fast ) { \n c -> hScale ( dst , dstWidth , src1 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n c -> hScale ( dst + VOFW , dstWidth , src2 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n } else { \n c -> hcscale_fast ( c , dst , dstWidth , src1 , src2 , srcW , xInc ) ; \n } \n if ( c -> chrConvertRange ) \n c -> chrConvertRange ( dst , dstWidth ) ; \n }", "idx": 6709}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static int mm_decode_pal ( MmContext * s ) \n { \n int i ; \n bytestream2_skip ( & s -> gb , 4 ) ; \n for ( i = 0 ; i < 128 ; i ++ ) { \n s -> palette [ i ] = 0xFF << 24 | bytestream2_get_be24 ( & s -> gb ) ; \n s -> palette [ i + 128 ] = s -> palette [ i ] << 2 ; \n } \n return 0 ; \n }", "idx": 6718}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred16x16_horizontal_add ) ( uint8_t * pix , \n const int * block_offset , \n const int16_t * block , \n ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 6720}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static void release_unused_pictures ( H264Context * h , int remove_current ) \n { \n int i ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( h -> DPB [ i ] . f . data [ 0 ] && ! h -> DPB [ i ] . reference && \n ( remove_current || & h -> DPB [ i ] != h -> cur_pic_ptr ) ) { \n unref_picture ( h , & h -> DPB [ i ] ) ; \n } \n } \n }", "idx": 6721}
{"project": "FFmpeg", "commit_id": "51daafb02eaf96e0743a37ce95a7f5d02c1fa3c2", "target": 1, "func": "static av_noinline void emulated_edge_mc_sse ( uint8_t * buf , const uint8_t * src , \n ptrdiff_t buf_stride , \n ptrdiff_t src_stride , \n int block_w , int block_h , \n int src_x , int src_y , int w , int h ) \n { \n emulated_edge_mc ( buf , src , buf_stride , src_stride , block_w , block_h , \n src_x , src_y , w , h , vfixtbl_sse , & ff_emu_edge_vvar_sse , \n hfixtbl_sse , & ff_emu_edge_hvar_sse ) ; \n }", "idx": 6722}
{"project": "FFmpeg", "commit_id": "6ea428789371fa0601e9ebb5b7f2216d4e73e831", "target": 1, "func": "static void dss_sp_shift_sq_sub ( const int32_t * filter_buf , \n int32_t * error_buf , int32_t * dst ) \n { \n int a ; \n for ( a = 0 ; a < 72 ; a ++ ) { \n int i , tmp ; \n tmp = dst [ a ] * filter_buf [ 0 ] ; \n for ( i = 14 ; i > 0 ; i -- ) \n tmp -= error_buf [ i ] * ( unsigned ) filter_buf [ i ] ; \n for ( i = 14 ; i > 0 ; i -- ) \n error_buf [ i ] = error_buf [ i - 1 ] ; \n tmp = ( tmp + 4096 ) >> 13 ; \n error_buf [ 1 ] = tmp ; \n dst [ a ] = av_clip_int16 ( tmp ) ; \n } \n }", "idx": 6726}
{"project": "FFmpeg", "commit_id": "dbbb9262ca0fd09f2582b11157a74c88ab7e1db5", "target": 0, "func": "static void decorrelate_stereo_24 ( int32_t * buffer [ MAX_CHANNELS ] , \n int32_t * buffer_out , \n int32_t * wasted_bits_buffer [ MAX_CHANNELS ] , \n int wasted_bits , \n int numchannels , int numsamples , \n uint8_t interlacing_shift , \n uint8_t interlacing_leftweight ) \n { \n int i ; \n if ( numsamples <= 0 ) \n return ; \n if ( interlacing_leftweight ) { \n for ( i = 0 ; i < numsamples ; i ++ ) { \n int32_t a , b ; \n a = buffer [ 0 ] [ i ] ; \n b = buffer [ 1 ] [ i ] ; \n a -= ( b * interlacing_leftweight ) >> interlacing_shift ; \n b += a ; \n if ( wasted_bits ) { \n b = ( b << wasted_bits ) | wasted_bits_buffer [ 0 ] [ i ] ; \n a = ( a << wasted_bits ) | wasted_bits_buffer [ 1 ] [ i ] ; \n } \n buffer_out [ i * numchannels ] = b << 8 ; \n buffer_out [ i * numchannels + 1 ] = a << 8 ; \n } \n } else { \n for ( i = 0 ; i < numsamples ; i ++ ) { \n int32_t left , right ; \n left = buffer [ 0 ] [ i ] ; \n right = buffer [ 1 ] [ i ] ; \n if ( wasted_bits ) { \n left = ( left << wasted_bits ) | wasted_bits_buffer [ 0 ] [ i ] ; \n right = ( right << wasted_bits ) | wasted_bits_buffer [ 1 ] [ i ] ; \n } \n buffer_out [ i * numchannels ] = left << 8 ; \n buffer_out [ i * numchannels + 1 ] = right << 8 ; \n } \n } \n }", "idx": 6734}
{"project": "FFmpeg", "commit_id": "12a419dacb479d663f04e316f9997568ef326965", "target": 0, "func": "static int v210_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int packet_size , ret , width , height ; \n AVStream * st = s -> streams [ 0 ] ; \n width = st -> codec -> width ; \n height = st -> codec -> height ; \n packet_size = GET_PACKET_SIZE ( width , height ) ; \n if ( packet_size < 0 ) \n return -1 ; \n ret = av_get_packet ( s -> pb , pkt , packet_size ) ; \n pkt -> pts = pkt -> dts = pkt -> pos / packet_size ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 6741}
{"project": "FFmpeg", "commit_id": "0a82f5275f719e6e369a807720a2c3603aa0ddd9", "target": 1, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , int width , \n int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n } \n } \n return start - src ; \n }", "idx": 6764}
{"project": "FFmpeg", "commit_id": "fed50c4304eecb352e29ce789cdb96ea84d6162f", "target": 1, "func": "void av_force_cpu_flags ( int arg ) { \n if ( ( arg & ( AV_CPU_FLAG_3DNOW | \n AV_CPU_FLAG_3DNOWEXT | \n AV_CPU_FLAG_MMXEXT | \n AV_CPU_FLAG_SSE | \n AV_CPU_FLAG_SSE2 | \n AV_CPU_FLAG_SSE2SLOW | \n AV_CPU_FLAG_SSE3 | \n AV_CPU_FLAG_SSE3SLOW | \n AV_CPU_FLAG_SSSE3 | \n AV_CPU_FLAG_SSE4 | \n AV_CPU_FLAG_SSE42 | \n AV_CPU_FLAG_AVX | \n AV_CPU_FLAG_AVXSLOW | \n AV_CPU_FLAG_XOP | \n AV_CPU_FLAG_FMA3 | \n AV_CPU_FLAG_FMA4 | \n AV_CPU_FLAG_AVX2 ) ) \n && ! ( arg & AV_CPU_FLAG_MMX ) ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n arg |= AV_CPU_FLAG_MMX ; \n } \n cpu_flags = arg ; \n }", "idx": 6765}
{"project": "FFmpeg", "commit_id": "120b38b966b92a50dd36542190d35daba6730eb3", "target": 1, "func": "int ffio_rewind_with_probe_data ( AVIOContext * s , unsigned char * buf , int buf_size ) \n { \n int64_t buffer_start ; \n int buffer_size ; \n int overlap , new_size , alloc_size ; \n if ( s -> write_flag ) \n return AVERROR ( EINVAL ) ; \n buffer_size = s -> buf_end - s -> buffer ; \n if ( ( buffer_start = s -> pos - buffer_size ) > buf_size ) \n return AVERROR ( EINVAL ) ; \n overlap = buf_size - buffer_start ; \n new_size = buf_size + buffer_size - overlap ; \n alloc_size = FFMAX ( s -> buffer_size , new_size ) ; \n if ( alloc_size > buf_size ) \n if ( ! ( buf = av_realloc_f ( buf , 1 , alloc_size ) ) ) \n return AVERROR ( ENOMEM ) ; \n if ( new_size > buf_size ) { \n memcpy ( buf + buf_size , s -> buffer + overlap , buffer_size - overlap ) ; \n buf_size = new_size ; \n } \n av_free ( s -> buffer ) ; \n s -> buf_ptr = s -> buffer = buf ; \n s -> buffer_size = alloc_size ; \n s -> pos = buf_size ; \n s -> buf_end = s -> buf_ptr + buf_size ; \n s -> eof_reached = 0 ; \n s -> must_flush = 0 ; \n return 0 ; \n }", "idx": 6773}
{"project": "FFmpeg", "commit_id": "4eca1939ef0614d0959fffb93f93d44af6740e8c", "target": 1, "func": "static int url_connect ( struct playlist * pls , AVDictionary * opts , AVDictionary * opts2 ) \n { \n AVDictionary * tmp = NULL ; \n int ret ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n av_dict_copy ( & tmp , opts2 , 0 ) ; \n av_opt_set_dict ( pls -> input , & tmp ) ; \n if ( ( ret = ffurl_connect ( pls -> input , NULL ) ) < 0 ) { \n ffurl_close ( pls -> input ) ; \n pls -> input = NULL ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 6774}
{"project": "FFmpeg", "commit_id": "211a185cba78aa8410e85de91630aa3a8c083883", "target": 1, "func": "void ff_insert_pad ( unsigned idx , unsigned * count , size_t padidx_off , \n AVFilterPad * * pads , AVFilterLink * * * links , \n AVFilterPad * newpad ) \n { \n unsigned i ; \n idx = FFMIN ( idx , * count ) ; \n * pads = av_realloc ( * pads , sizeof ( AVFilterPad ) * ( * count + 1 ) ) ; \n * links = av_realloc ( * links , sizeof ( AVFilterLink * ) * ( * count + 1 ) ) ; \n memmove ( * pads + idx + 1 , * pads + idx , sizeof ( AVFilterPad ) * ( * count - idx ) ) ; \n memmove ( * links + idx + 1 , * links + idx , sizeof ( AVFilterLink * ) * ( * count - idx ) ) ; \n memcpy ( * pads + idx , newpad , sizeof ( AVFilterPad ) ) ; \n ( * links ) [ idx ] = NULL ; \n ( * count ) ++ ; \n for ( i = idx + 1 ; i < * count ; i ++ ) \n if ( * links [ i ] ) \n ( * ( unsigned * ) ( ( uint8_t * ) * links [ i ] + padidx_off ) ) ++ ; \n }", "idx": 6776}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static void write_strip_header ( CinepakEncContext * s , int y , int h , int keyframe , unsigned char * buf , int strip_size ) \n { \n buf [ 0 ] = keyframe ? 0x11 : 0x10 ; \n AV_WB24 ( & buf [ 1 ] , strip_size + STRIP_HEADER_SIZE ) ; \n AV_WB16 ( & buf [ 4 ] , y ) ; \n AV_WB16 ( & buf [ 6 ] , 0 ) ; \n AV_WB16 ( & buf [ 8 ] , h ) ; \n AV_WB16 ( & buf [ 10 ] , s -> w ) ; \n }", "idx": 6786}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_rice_params ( RiceContext * rc , int pmin , int pmax , \n int32_t * data , int n , int pred_order ) \n { \n int i ; \n uint32_t bits [ MAX_PARTITION_ORDER + 1 ] ; \n int opt_porder ; \n RiceContext tmp_rc ; \n uint32_t * udata ; \n uint32_t sums [ MAX_PARTITION_ORDER + 1 ] [ MAX_PARTITIONS ] ; \n assert ( pmin >= 0 && pmin <= MAX_PARTITION_ORDER ) ; \n assert ( pmax >= 0 && pmax <= MAX_PARTITION_ORDER ) ; \n assert ( pmin <= pmax ) ; \n udata = av_malloc ( n * sizeof ( uint32_t ) ) ; \n for ( i = 0 ; i < n ; i ++ ) \n udata [ i ] = ( 2 * data [ i ] ) ^ ( data [ i ] >> 31 ) ; \n calc_sums ( pmin , pmax , udata , n , pred_order , sums ) ; \n opt_porder = pmin ; \n bits [ pmin ] = UINT32_MAX ; \n for ( i = pmin ; i <= pmax ; i ++ ) { \n bits [ i ] = calc_optimal_rice_params ( & tmp_rc , i , sums [ i ] , n , pred_order ) ; \n if ( bits [ i ] <= bits [ opt_porder ] ) { \n opt_porder = i ; \n * rc = tmp_rc ; \n } \n } \n av_freep ( & udata ) ; \n return bits [ opt_porder ] ; \n }", "idx": 6789}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgech ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = 52 + qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> s . dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 6799}
{"project": "FFmpeg", "commit_id": "ce558c8f590610fc68596ef0b4ac2a9d299fbcb2", "target": 0, "func": "x11grab_read_packet ( AVFormatContext * s1 , AVPacket * pkt )  \n { \n struct x11_grab * s = s1 -> priv_data ; \n Display * dpy = s -> dpy ; \n XImage * image = s -> image ; \n int x_off = s -> x_off ; \n int y_off = s -> y_off ; \n int64_t curtime , delay ; \n struct timespec ts ; \n s -> time_frame += INT64_C ( 1000000 ) ; \n for ( ; ; ) { \n curtime = av_gettime ( ) ; \n delay = s -> time_frame * av_q2d ( s -> time_base ) - curtime ; \n if ( delay <= 0 ) { \n if ( delay < INT64_C ( -1000000 ) * av_q2d ( s -> time_base ) ) { \n s -> time_frame += INT64_C ( 1000000 ) ; \n } \n break ; \n } \n ts . tv_sec = delay / 1000000 ; \n ts . tv_nsec = ( delay % 1000000 ) * 1000 ; \n nanosleep ( & ts , NULL ) ; \n } \n av_init_packet ( pkt ) ; \n pkt -> data = image -> data ; \n pkt -> size = s -> frame_size ; \n pkt -> pts = curtime ; \n if ( s -> use_shm ) { \n if ( ! XShmGetImage ( dpy , RootWindow ( dpy , DefaultScreen ( dpy ) ) , image , x_off , y_off , AllPlanes ) ) { \n av_log ( s1 , AV_LOG_INFO , \" \\n \" ) ; \n } \n } else { \n if ( ! xget_zpixmap ( dpy , RootWindow ( dpy , DefaultScreen ( dpy ) ) , image , x_off , y_off ) ) { \n av_log ( s1 , AV_LOG_INFO , \" \\n \" ) ; \n } \n } \n if ( ! s -> nomouse ) { \n paint_mouse_pointer ( image , s ) ; \n } \n return s -> frame_size ; \n }", "idx": 6804}
{"project": "FFmpeg", "commit_id": "59975de77741766df4cc48c66bc151a6c31f9291", "target": 1, "func": "static void sub2video_update ( InputStream * ist , AVSubtitle * sub ) \n { \n int w = ist -> sub2video . w , h = ist -> sub2video . h ; \n AVFrame * frame = ist -> sub2video . frame ; \n int8_t * dst ; \n int dst_linesize ; \n int num_rects , i ; \n int64_t pts , end_pts ; \n if ( ! frame ) \n return ; \n if ( sub ) { \n pts = av_rescale_q ( sub -> pts + sub -> start_display_time * 1000 , \n AV_TIME_BASE_Q , ist -> st -> time_base ) ; \n end_pts = av_rescale_q ( sub -> pts + sub -> end_display_time * 1000 , \n AV_TIME_BASE_Q , ist -> st -> time_base ) ; \n num_rects = sub -> num_rects ; \n } else { \n pts = ist -> sub2video . end_pts ; \n end_pts = INT64_MAX ; \n num_rects = 0 ; \n } \n if ( sub2video_get_blank_frame ( ist ) < 0 ) { \n av_log ( ist -> dec_ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return ; \n } \n dst = frame -> data [ 0 ] ; \n dst_linesize = frame -> linesize [ 0 ] ; \n for ( i = 0 ; i < num_rects ; i ++ ) \n sub2video_copy_rect ( dst , dst_linesize , w , h , sub -> rects [ i ] ) ; \n sub2video_push_ref ( ist , pts ) ; \n ist -> sub2video . end_pts = end_pts ; \n }", "idx": 6813}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_dolby ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] - samples [ i + 768 ] ) ; \n samples [ i + 256 ] = ( samples [ i + 512 ] + samples [ i + 1024 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = samples [ i + 1024 ] = 0 ; \n } \n }", "idx": 6871}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "int rtsp_next_attr_and_value ( const char * * p , char * attr , int attr_size , char * value , int value_size ) \n { \n skip_spaces ( p ) ; \n if ( * * p ) { \n get_word_sep ( attr , attr_size , \" \" , p ) ; \n if ( * * p == ' ' ) \n ( * p ) ++ ; \n get_word_sep ( value , value_size , \" \" , p ) ; \n if ( * * p == ' ' ) \n ( * p ) ++ ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 6873}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_init ( AVDictionary * options , AVOpenCLExternalEnv * ext_opencl_env ) \n { \n int ret = 0 ; \n AVDictionaryEntry * opt_build_entry ; \n AVDictionaryEntry * opt_platform_entry ; \n AVDictionaryEntry * opt_device_entry ; \n LOCK_OPENCL \n if ( ! gpu_env . init_count ) { \n opt_platform_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n opt_device_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n gpu_env . usr_spec_dev_info . platform_idx = -1 ; \n gpu_env . usr_spec_dev_info . dev_idx = -1 ; \n if ( opt_platform_entry ) { \n gpu_env . usr_spec_dev_info . platform_idx = strtol ( opt_platform_entry -> value , NULL , 10 ) ; \n } \n if ( opt_device_entry ) { \n gpu_env . usr_spec_dev_info . dev_idx = strtol ( opt_device_entry -> value , NULL , 10 ) ; \n } \n ret = init_opencl_env ( & gpu_env , ext_opencl_env ) ; \n if ( ret < 0 ) \n goto end ; \n } \n opt_build_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n if ( opt_build_entry ) \n ret = compile_kernel_file ( & gpu_env , opt_build_entry -> value ) ; \n else \n ret = compile_kernel_file ( & gpu_env , NULL ) ; \n if ( ret < 0 ) \n goto end ; \n av_assert1 ( gpu_env . kernel_code_count > 0 ) ; \n gpu_env . init_count ++ ; \n end : \n UNLOCK_OPENCL  \n return ret ; \n }", "idx": 6874}
{"project": "FFmpeg", "commit_id": "e494f44c051d7dccc038a603ab22532b87dd1705", "target": 0, "func": "static CodeBook unpack_codebook ( GetBitContext * gb , unsigned depth , \n unsigned size ) \n { \n unsigned i , j ; \n CodeBook cb = { 0 } ; \n if ( ! can_safely_read ( gb , ( uint64_t ) size * 34 ) ) \n return cb ; \n if ( size >= INT_MAX / sizeof ( MacroBlock ) ) \n return cb ; \n cb . blocks = av_malloc ( size ? size * sizeof ( MacroBlock ) : 1 ) ; \n if ( ! cb . blocks ) \n return cb ; \n cb . depth = depth ; \n cb . size = size ; \n for ( i = 0 ; i < size ; i ++ ) { \n unsigned mask_bits = get_bits ( gb , 4 ) ; \n unsigned color0 = get_bits ( gb , 15 ) ; \n unsigned color1 = get_bits ( gb , 15 ) ; \n for ( j = 0 ; j < 4 ; j ++ ) { \n if ( mask_bits & ( 1 << j ) ) \n cb . blocks [ i ] . pixels [ j ] = color1 ; \n else \n cb . blocks [ i ] . pixels [ j ] = color0 ; \n } \n } \n return cb ; \n }", "idx": 6875}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid4_8_12_cx ( float ( * in ) [ 2 ] , float ( * out ) [ 32 ] [ 2 ] , const float ( * filter ) [ 7 ] [ 2 ] , int N , int len ) \n { \n int i , j , ssb ; \n for ( i = 0 ; i < len ; i ++ , in ++ ) { \n for ( ssb = 0 ; ssb < N ; ssb ++ ) { \n float sum_re = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 0 ] , sum_im = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 1 ] ; \n for ( j = 0 ; j < 6 ; j ++ ) { \n float in0_re = in [ j ] [ 0 ] ; \n float in0_im = in [ j ] [ 1 ] ; \n float in1_re = in [ 12 - j ] [ 0 ] ; \n float in1_im = in [ 12 - j ] [ 1 ] ; \n sum_re += filter [ ssb ] [ j ] [ 0 ] * ( in0_re + in1_re ) - filter [ ssb ] [ j ] [ 1 ] * ( in0_im - in1_im ) ; \n sum_im += filter [ ssb ] [ j ] [ 0 ] * ( in0_im + in1_im ) + filter [ ssb ] [ j ] [ 1 ] * ( in0_re - in1_re ) ; \n } \n out [ ssb ] [ i ] [ 0 ] = sum_re ; \n out [ ssb ] [ i ] [ 1 ] = sum_im ; \n } \n } \n }", "idx": 6876}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static int add_metadata ( const uint8_t * * buf , int count , int type , \n const char * name , const char * sep , TiffContext * s ) \n { \n switch ( type ) { \n case TIFF_DOUBLE : return add_doubles_metadata ( buf , count , name , sep , s ) ; \n case TIFF_SHORT : return add_shorts_metadata ( buf , count , name , sep , s ) ; \n default : return AVERROR_INVALIDDATA ; \n } ; \n }", "idx": 6877}
{"project": "FFmpeg", "commit_id": "c0002ddb019d7f2f22da301b2855f86d697d37bd", "target": 0, "func": "static int opt_recording_timestamp ( void * optctx , const char * opt , const char * arg ) \n { \n OptionsContext * o = optctx ; \n char buf [ 128 ] ; \n int64_t recording_timestamp = parse_time_or_die ( opt , arg , 0 ) / 1E6 ; \n struct tm time = * gmtime ( ( time_t * ) & recording_timestamp ) ; \n strftime ( buf , sizeof ( buf ) , \" \" , & time ) ; \n parse_option ( o , \" \" , buf , options ) ; \n av_log ( NULL , AV_LOG_WARNING , \" \" \n \" \\n \" , opt ) ; \n return 0 ; \n }", "idx": 6878}
{"project": "FFmpeg", "commit_id": "c49a3ec30aaa8042335656982054f02847c03aae", "target": 1, "func": "rdt_free_extradata ( PayloadContext * rdt )  \n { \n ff_rm_free_rmstream ( rdt -> rmst [ 0 ] ) ; \n if ( rdt -> rmctx ) \n av_close_input_stream ( rdt -> rmctx ) ; \n av_freep ( & rdt -> mlti_data ) ; \n av_free ( rdt ) ; \n }", "idx": 6881}
{"project": "FFmpeg", "commit_id": "2baf36caed98cfdc7f6a2086fbf26f1a172f16cf", "target": 1, "func": "static int h263_decode_gob_header ( MpegEncContext * s ) \n { \n unsigned int val , gob_number ; \n int left ; \n val = show_bits ( & s -> gb , 16 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n left = get_bits_left ( & s -> gb ) ; \n for ( ; left > 13 ; left -- ) { \n if ( get_bits1 ( & s -> gb ) ) break ; \n } \n if ( left <= 13 ) \n return -1 ; \n if ( s -> h263_slice_structured ) { \n if ( check_marker ( s -> avctx , & s -> gb , \" \" ) == 0 ) \n return -1 ; \n ff_h263_decode_mba ( s ) ; \n if ( s -> mb_num > 1583 ) \n if ( check_marker ( s -> avctx , & s -> gb , \" \" ) == 0 ) \n return -1 ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n if ( check_marker ( s -> avctx , & s -> gb , \" \" ) == 0 ) \n return -1 ; \n skip_bits ( & s -> gb , 2 ) ; \n } else { \n gob_number = get_bits ( & s -> gb , 5 ) ; \n s -> mb_x = 0 ; \n s -> mb_y = s -> gob_index * gob_number ; \n skip_bits ( & s -> gb , 2 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n } \n if ( s -> mb_y >= s -> mb_height ) \n return -1 ; \n if ( s -> qscale == 0 ) \n return -1 ; \n return 0 ; \n }", "idx": 6882}
{"project": "FFmpeg", "commit_id": "fd6e513ee1dc13174256de8adaeeb2c2691eee95", "target": 1, "func": "static int mov_read_wide ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n int err ; \n uint32_t type ; \n #ifdef DEBUG \n print_atom ( \" \" , atom ) ; \n debug_indent ++ ; \n #endif \n if ( atom . size < 8 ) \n return 0 ; \n if ( get_be32 ( pb ) != 0 ) { \n url_fskip ( pb , atom . size - 4 ) ; \n return 0 ; \n } \n atom . type = get_le32 ( pb ) ; \n atom . offset += 8 ; \n atom . size -= 8 ; \n if ( type != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n url_fskip ( pb , atom . size ) ; \n return 0 ; \n } \n err = mov_read_mdat ( c , pb , atom ) ; \n #ifdef DEBUG \n debug_indent -- ; \n #endif \n return err ; \n }", "idx": 6883}
{"project": "FFmpeg", "commit_id": "da9b170c6f06184a5114dc66afb8385cd0ffff83", "target": 0, "func": "void * av_malloc ( unsigned int size ) \n { \n void * ptr ; \n #if defined ( HAVE_MEMALIGN )  \n  \n  ptr = memalign ( 16 , size ) ; \n #else \n ptr = malloc ( size ) ; \n #endif \n return ptr ; \n }", "idx": 6887}
{"project": "FFmpeg", "commit_id": "be9ce6e10a8d53b8bc346c9337d75a5a30631a2a", "target": 1, "func": "static void mov_parse_stsd_subtitle ( MOVContext * c , AVIOContext * pb , \n AVStream * st , MOVStreamContext * sc , \n int size ) \n { \n MOVAtom fake_atom = { . size = size } ; \n if ( st -> codec -> codec_tag != AV_RL32 ( \" \" ) ) \n mov_read_glbl ( c , pb , fake_atom ) ; \n st -> codec -> width = sc -> width ; \n st -> codec -> height = sc -> height ; \n }", "idx": 6900}
{"project": "FFmpeg", "commit_id": "a4d70941cd4a82f7db9fbaa2148d60ce550e7611", "target": 1, "func": "AVStream * add_av_stream1 ( FFStream * stream , AVCodecContext * codec ) \n { \n AVStream * fst ; \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return NULL ; \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n memcpy ( & fst -> codec , codec , sizeof ( AVCodecContext ) ) ; \n stream -> streams [ stream -> nb_streams ++ ] = fst ; \n return fst ; \n }", "idx": 6904}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int asf_write_trailer ( AVFormatContext * s ) \n { \n ASFContext * asf = s -> priv_data ; \n int64_t file_size , data_size ; \n if ( asf -> pb . buf_ptr > asf -> pb . buffer ) \n flush_packet ( s ) ; \n data_size = avio_tell ( s -> pb ) ; \n if ( ( ! asf -> is_streamed ) && ( asf -> nb_index_count != 0 ) ) \n asf_write_index ( s , asf -> index_ptr , asf -> maximum_packet , asf -> nb_index_count ) ; \n avio_flush ( s -> pb ) ; \n if ( asf -> is_streamed || ! s -> pb -> seekable ) { \n put_chunk ( s , 0x4524 , 0 , 0 ) ; \n } else { \n file_size = avio_tell ( s -> pb ) ; \n avio_seek ( s -> pb , 0 , SEEK_SET ) ; \n asf_write_header1 ( s , file_size , data_size - asf -> data_offset ) ; \n } \n av_free ( asf -> index_ptr ) ; \n return 0 ; \n }", "idx": 6908}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static void dvbsub_parse_display_definition_segment ( AVCodecContext * avctx , \n const uint8_t * buf , \n int buf_size ) \n { \n DVBSubContext * ctx = avctx -> priv_data ; \n DVBSubDisplayDefinition * display_def = ctx -> display_definition ; \n int dds_version , info_byte ; \n if ( buf_size < 5 ) \n return ; \n info_byte = bytestream_get_byte ( & buf ) ; \n dds_version = info_byte >> 4 ; \n if ( display_def && display_def -> version == dds_version ) \n return ; \n if ( ! display_def ) { \n display_def = av_mallocz ( sizeof ( * display_def ) ) ; \n ctx -> display_definition = display_def ; \n } \n if ( ! display_def ) \n return ; \n display_def -> version = dds_version ; \n display_def -> x = 0 ; \n display_def -> y = 0 ; \n display_def -> width = bytestream_get_be16 ( & buf ) + 1 ; \n display_def -> height = bytestream_get_be16 ( & buf ) + 1 ; \n if ( buf_size < 13 ) \n return ; \n if ( info_byte & 1 << 3 ) { \n display_def -> x = bytestream_get_be16 ( & buf ) ; \n display_def -> y = bytestream_get_be16 ( & buf ) ; \n display_def -> width = bytestream_get_be16 ( & buf ) - display_def -> x + 1 ; \n display_def -> height = bytestream_get_be16 ( & buf ) - display_def -> y + 1 ; \n } \n }", "idx": 6909}
{"project": "FFmpeg", "commit_id": "00663de3b752fc3bdd47d4516ad2fcc720722782", "target": 0, "func": "int ff_alloc_packet ( AVPacket * avpkt , int size ) \n { \n if ( size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE ) \n return AVERROR ( EINVAL ) ; \n if ( avpkt -> data ) { \n void * destruct = avpkt -> destruct ; \n if ( avpkt -> size < size ) \n return AVERROR ( EINVAL ) ; \n av_init_packet ( avpkt ) ; \n avpkt -> destruct = destruct ; \n avpkt -> size = size ; \n return 0 ; \n } else { \n return av_new_packet ( avpkt , size ) ; \n } \n }", "idx": 6911}
{"project": "FFmpeg", "commit_id": "c8dcff0cdb17d0aa03ac729eba12d1a20f1f59c8", "target": 0, "func": "int ff_h264_field_end ( H264Context * h , H264SliceContext * sl , int in_setup ) \n { \n AVCodecContext * const avctx = h -> avctx ; \n int err = 0 ; \n h -> mb_y = 0 ; \n if ( ! in_setup && ! h -> droppable ) \n ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , \n h -> picture_structure == PICT_BOTTOM_FIELD ) ; \n if ( in_setup || ! ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( ! h -> droppable ) { \n err = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; \n h -> prev_poc_msb = h -> poc_msb ; \n h -> prev_poc_lsb = h -> poc_lsb ; \n } \n h -> prev_frame_num_offset = h -> frame_num_offset ; \n h -> prev_frame_num = h -> frame_num ; \n } \n if ( avctx -> hwaccel ) { \n if ( avctx -> hwaccel -> end_frame ( avctx ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n #if CONFIG_ERROR_RESILIENCE  \n  \n  \n  if ( ! FIELD_PICTURE ( h ) && h -> enable_er ) { \n h264_set_erpic ( & sl -> er . cur_pic , h -> cur_pic_ptr ) ; \n h264_set_erpic ( & sl -> er . last_pic , \n sl -> ref_count [ 0 ] ? sl -> ref_list [ 0 ] [ 0 ] . parent : NULL ) ; \n h264_set_erpic ( & sl -> er . next_pic , \n sl -> ref_count [ 1 ] ? sl -> ref_list [ 1 ] [ 0 ] . parent : NULL ) ; \n ff_er_frame_end ( & sl -> er ) ; \n } \n #endif \n emms_c ( ) ; \n h -> current_slice = 0 ; \n return err ; \n }", "idx": 6913}
{"project": "FFmpeg", "commit_id": "089fac77a6bf9199a5ec161e9c27850f0a680541", "target": 0, "func": "static int audio_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n AlsaData * s = s1 -> priv_data ; \n AVStream * st = s1 -> streams [ 0 ] ; \n int res ; \n snd_htimestamp_t timestamp ; \n snd_pcm_uframes_t ts_delay ; \n if ( av_new_packet ( pkt , s -> period_size ) < 0 ) { \n return AVERROR ( EIO ) ; \n } \n while ( ( res = snd_pcm_readi ( s -> h , pkt -> data , pkt -> size / s -> frame_size ) ) < 0 ) { \n if ( res == - EAGAIN ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EAGAIN ) ; \n } \n if ( ff_alsa_xrun_recover ( s1 , res ) < 0 ) { \n av_log ( s1 , AV_LOG_ERROR , \" \\n \" , \n snd_strerror ( res ) ) ; \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n } \n snd_pcm_htimestamp ( s -> h , & ts_delay , & timestamp ) ; \n ts_delay += res ; \n pkt -> pts = timestamp . tv_sec * 1000000LL \n + ( timestamp . tv_nsec * st -> codec -> sample_rate \n - ts_delay * 1000000000LL + st -> codec -> sample_rate * 500LL ) \n / ( st -> codec -> sample_rate * 1000LL ) ; \n pkt -> size = res * s -> frame_size ; \n return 0 ; \n }", "idx": 6914}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( uyvytoyuv422 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n long width , long height , \n long lumStride , long chromStride , long srcStride ) \n { \n long y ; \n const long chromWidth = - ( ( - width ) >> 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src + 1 , ydst , width ) ; \n RENAME ( extract_even2 ) ( src , udst , vdst , chromWidth ) ; \n src += srcStride ; \n ydst += lumStride ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n #endif \n }", "idx": 6915}
{"project": "FFmpeg", "commit_id": "eb19d89d8eb51f20299d59558d69d0f057583e7c", "target": 0, "func": "static int64_t cache_seek ( URLContext * h , int64_t pos , int whence ) \n { \n Context * c = h -> priv_data ; \n if ( whence == AVSEEK_SIZE ) { \n pos = ffurl_seek ( c -> inner , pos , whence ) ; \n if ( pos <= 0 ) { \n pos = ffurl_seek ( c -> inner , -1 , SEEK_END ) ; \n ffurl_seek ( c -> inner , c -> end , SEEK_SET ) ; \n if ( pos <= 0 ) \n return c -> end ; \n } \n return pos ; \n } \n pos = lseek ( c -> fd , pos , whence ) ; \n if ( pos < 0 ) { \n return pos ; \n } else if ( pos <= c -> end ) { \n c -> pos = pos ; \n return pos ; \n } else { \n lseek ( c -> fd , c -> pos , SEEK_SET ) ; \n return AVERROR ( EPIPE ) ; \n } \n }", "idx": 6942}
{"project": "FFmpeg", "commit_id": "e30004fa733ec64b6ff90678098c1f1132d4d603", "target": 1, "func": "static int read_huffman_tables ( HYuvContext * s , uint8_t * src , int length ) { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , src , length * 8 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n read_len_table ( s -> len [ i ] , & gb ) ; \n if ( generate_bits_table ( s -> bits [ i ] , s -> len [ i ] ) < 0 ) { \n return -1 ; \n } \n #if 0  \n  \n  for ( j = 0 ; j < 256 ; j ++ ) { \n printf ( \" \\n \" , s -> bits [ i ] [ j ] , s -> len [ i ] [ j ] , j ) ; \n } \n #endif \n free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return ( get_bits_count ( & gb ) + 7 ) / 8 ; \n }", "idx": 6949}
{"project": "FFmpeg", "commit_id": "0ee143558d55b590774dba69cff5a16eda089a4d", "target": 1, "func": "int ff_hevc_cu_qp_delta_abs ( HEVCContext * s ) \n { \n int prefix_val = 0 ; \n int suffix_val = 0 ; \n int inc = 0 ; \n while ( prefix_val < 5 && GET_CABAC ( elem_offset [ CU_QP_DELTA ] + inc ) ) { \n prefix_val ++ ; \n inc = 1 ; \n } \n if ( prefix_val >= 5 ) { \n int k = 0 ; \n while ( k < CABAC_MAX_BIN && get_cabac_bypass ( & s -> HEVClc -> cc ) ) { \n suffix_val += 1 << k ; \n k ++ ; \n } \n if ( k == CABAC_MAX_BIN ) \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , k ) ; \n while ( k -- ) \n suffix_val += get_cabac_bypass ( & s -> HEVClc -> cc ) << k ; \n } \n return prefix_val + suffix_val ; \n }", "idx": 6952}
{"project": "FFmpeg", "commit_id": "aac7d6b284c3976eb0c48d61f342f008fb6e4103", "target": 1, "func": "av_cold int ff_nvenc_encode_close ( AVCodecContext * avctx ) \n { \n NVENCContext * ctx = avctx -> priv_data ; \n NV_ENCODE_API_FUNCTION_LIST * nv = & ctx -> nvel . nvenc_funcs ; \n int i ; \n av_fifo_free ( ctx -> timestamps ) ; \n av_fifo_free ( ctx -> pending ) ; \n av_fifo_free ( ctx -> ready ) ; \n if ( ctx -> in ) { \n for ( i = 0 ; i < ctx -> nb_surfaces ; ++ i ) { \n nv -> nvEncDestroyInputBuffer ( ctx -> nvenc_ctx , ctx -> in [ i ] . in ) ; \n nv -> nvEncDestroyBitstreamBuffer ( ctx -> nvenc_ctx , ctx -> out [ i ] . out ) ; \n av_freep ( & ctx -> in ) ; \n av_freep ( & ctx -> out ) ; \n if ( ctx -> nvenc_ctx ) \n nv -> nvEncDestroyEncoder ( ctx -> nvenc_ctx ) ; \n if ( ctx -> cu_context ) \n ctx -> nvel . cu_ctx_destroy ( ctx -> cu_context ) ; \n if ( ctx -> nvel . nvenc ) \n dlclose ( ctx -> nvel . nvenc ) ; \n if ( ctx -> nvel . cuda ) \n dlclose ( ctx -> nvel . cuda ) ; \n return 0 ;", "idx": 6955}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_p_picture_primary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int lowquant , pqindex , status = 0 ; \n pqindex = get_bits ( gb , 5 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_IMPLICIT ) \n v -> pq = pquant_table [ 0 ] [ pqindex ] ; \n else \n { \n v -> pq = pquant_table [ v -> quantizer_mode - 1 ] [ pqindex ] ; \n } \n if ( pqindex < 9 ) v -> halfpq = get_bits ( gb , 1 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_EXPLICIT ) \n v -> pquantizer = get_bits ( gb , 1 ) ; \n av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \\n \" , \n v -> pq , v -> halfpq ) ; \n if ( v -> extended_mv == 1 ) v -> mvrange = get_prefix ( gb , 0 , 3 ) ; \n #if HAS_ADVANCED_PROFILE  \n  \n  if ( v -> profile > PROFILE_MAIN ) \n { \n if ( v -> postprocflag ) v -> postproc = get_bits ( gb , 1 ) ; \n } \n else \n #endif \n if ( v -> multires ) v -> respic = get_bits ( gb , 2 ) ; \n lowquant = ( v -> pquantizer > 12 ) ? 0 : 1 ; \n v -> mv_mode = mv_pmode_table [ lowquant ] [ get_prefix ( gb , 1 , 4 ) ] ; \n if ( v -> mv_mode == MV_PMODE_INTENSITY_COMP ) \n { \n v -> mv_mode2 = mv_pmode_table [ lowquant ] [ get_prefix ( gb , 1 , 3 ) ] ; \n v -> lumscale = get_bits ( gb , 6 ) ; \n v -> lumshift = get_bits ( gb , 6 ) ; \n } \n return 0 ; \n }", "idx": 6964}
{"project": "FFmpeg", "commit_id": "b8cc5a9fdfbc514a0d6e02b7c5380853a50ae1ac", "target": 1, "func": "static int sync ( AVFormatContext * s , int64_t * timestamp , int * flags , int * stream_index , int64_t * pos ) { \n RMDemuxContext * rm = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n int len , num , res , i ; \n AVStream * st ; \n uint32_t state = 0xFFFFFFFF ; \n while ( ! url_feof ( pb ) ) { \n * pos = url_ftell ( pb ) - 3 ; \n if ( rm -> remaining_len > 0 ) { \n num = rm -> current_stream ; \n len = rm -> remaining_len ; \n * timestamp = AV_NOPTS_VALUE ; \n * flags = 0 ; \n } else { \n state = ( state << 8 ) + get_byte ( pb ) ; \n if ( state == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n len = get_be16 ( pb ) - 6 ; \n if ( len < 0 ) \n continue ; \n goto skip ; \n } \n if ( state > ( unsigned ) 0xFFFF || state < 12 ) \n continue ; \n len = state ; \n state = 0xFFFFFFFF ; \n num = get_be16 ( pb ) ; \n * timestamp = get_be32 ( pb ) ; \n res = get_byte ( pb ) ; \n * flags = get_byte ( pb ) ; \n len -= 12 ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( num == st -> id ) \n break ; \n } \n if ( i == s -> nb_streams ) { \n skip : \n url_fskip ( pb , len ) ; \n rm -> remaining_len -= len ; \n continue ; \n } \n * stream_index = i ; \n return len ; \n } \n return -1 ; \n }", "idx": 6965}
{"project": "FFmpeg", "commit_id": "f72601d06378494b5026b919fcd3eb5eb22799a1", "target": 1, "func": "static int txd_read_header ( AVFormatContext * s , AVFormatParameters * ap ) { \n AVStream * st ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = CODEC_ID_TXD ; \n st -> codec -> time_base . den = 5 ; \n st -> codec -> time_base . num = 1 ; \n return 0 ; \n }", "idx": 6969}
{"project": "FFmpeg", "commit_id": "8501c098687bbf551a2f1cdef80ee653fdfff6ac", "target": 1, "func": "static int output_frame ( AVFilterLink * outlink , int nb_samples ) \n { \n AVFilterContext * ctx = outlink -> src ; \n MixContext * s = ctx -> priv ; \n AVFilterBufferRef * out_buf , * in_buf ; \n int i ; \n calculate_scales ( s , nb_samples ) ; \n out_buf = ff_get_audio_buffer ( outlink , AV_PERM_WRITE , nb_samples ) ; \n if ( ! out_buf ) \n return AVERROR ( ENOMEM ) ; \n in_buf = ff_get_audio_buffer ( outlink , AV_PERM_WRITE , nb_samples ) ; \n if ( ! in_buf ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < s -> nb_inputs ; i ++ ) { \n if ( s -> input_state [ i ] == INPUT_ON ) { \n int planes , plane_size , p ; \n av_audio_fifo_read ( s -> fifos [ i ] , ( void * * ) in_buf -> extended_data , \n nb_samples ) ; \n planes = s -> planar ? s -> nb_channels : 1 ; \n plane_size = nb_samples * ( s -> planar ? 1 : s -> nb_channels ) ; \n plane_size = FFALIGN ( plane_size , 16 ) ; \n for ( p = 0 ; p < planes ; p ++ ) { \n s -> fdsp . vector_fmac_scalar ( ( float * ) out_buf -> extended_data [ p ] , \n ( float * ) in_buf -> extended_data [ p ] , \n s -> input_scale [ i ] , plane_size ) ; \n } \n } \n } \n avfilter_unref_buffer ( in_buf ) ; \n out_buf -> pts = s -> next_pts ; \n if ( s -> next_pts != AV_NOPTS_VALUE ) \n s -> next_pts += nb_samples ; \n return ff_filter_samples ( outlink , out_buf ) ; \n }", "idx": 6970}
{"project": "FFmpeg", "commit_id": "ec6a855b3a6b87f3415cc4ecfc685bd2eefc6a80", "target": 1, "func": "MAKE_ACCESSORS ( AVVDPAUContext , vdpau_hwaccel , AVVDPAU_Render2 , render2 )  \n int ff_vdpau_common_init ( AVCodecContext * avctx , VdpDecoderProfile profile , \n int level ) \n { \n VDPAUHWContext * hwctx = avctx -> hwaccel_context ; \n VDPAUContext * vdctx = avctx -> internal -> hwaccel_priv_data ; \n VdpDecoderCreate * create ; \n void * func ; \n VdpStatus status ; \n uint32_t width = ( avctx -> coded_width + 1 ) & ~ 1 ; \n uint32_t height = ( avctx -> coded_height + 3 ) & ~ 3 ; \n if ( hwctx -> context . decoder != VDP_INVALID_HANDLE ) { \n vdctx -> decoder = hwctx -> context . decoder ; \n vdctx -> render = hwctx -> context . render ; \n return 0 ; \n vdctx -> device = hwctx -> device ; \n vdctx -> get_proc_address = hwctx -> get_proc_address ; \n status = vdctx -> get_proc_address ( vdctx -> device , VDP_FUNC_ID_DECODER_CREATE , \n & func ) ; \n if ( status != VDP_STATUS_OK ) \n return vdpau_error ( status ) ; \n else \n create = func ; \n status = vdctx -> get_proc_address ( vdctx -> device , VDP_FUNC_ID_DECODER_RENDER , \n & func ) ; \n if ( status != VDP_STATUS_OK ) \n return vdpau_error ( status ) ; \n else \n vdctx -> render = func ; \n status = create ( vdctx -> device , profile , width , height , avctx -> refs , \n & vdctx -> decoder ) ; \n return vdpau_error ( status ) ;", "idx": 6971}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_mpeg_draw_horiz_band ( MpegEncContext * s , int y , int h ) \n { \n ff_draw_horiz_band ( s -> avctx , & s -> current_picture . f , \n & s -> last_picture . f , y , h , s -> picture_structure , \n s -> first_field , s -> low_delay ) ; \n }", "idx": 6985}
{"project": "FFmpeg", "commit_id": "8aba7968dd604aae91ee42cbce0be3dad7dceb30", "target": 1, "func": "static av_cold int vcr1_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; \n return 0 ; ", "idx": 6988}
{"project": "FFmpeg", "commit_id": "9b8c8a9395c849639aea0f6b5300e991e93c3a73", "target": 0, "func": "static int svq1_decode_block_non_intra ( GetBitContext * bitbuf , uint8_t * pixels , \n int pitch ) \n { \n uint32_t bit_cache ; \n uint8_t * list [ 63 ] ; \n uint32_t * dst ; \n const uint32_t * codebook ; \n int entries [ 6 ] ; \n int i , j , m , n ; \n int mean , stages ; \n int x , y , width , height , level ; \n uint32_t n1 , n2 , n3 , n4 ; \n list [ 0 ] = pixels ; \n for ( i = 0 , m = 1 , n = 1 , level = 5 ; i < n ; i ++ ) { \n SVQ1_PROCESS_VECTOR ( ) ; \n dst = ( uint32_t * ) list [ i ] ; \n width = 1 << ( ( 4 + level ) / 2 ) ; \n height = 1 << ( ( 3 + level ) / 2 ) ; \n stages = get_vlc2 ( bitbuf , svq1_inter_multistage [ level ] . table , 3 , 2 ) - 1 ; \n if ( stages == -1 ) \n continue ; \n if ( ( stages > 0 ) && ( level >= 4 ) ) { \n av_dlog ( NULL , \n \" \\n \" , \n stages , level ) ; \n return AVERROR_INVALIDDATA ; \n } \n mean = get_vlc2 ( bitbuf , svq1_inter_mean . table , 9 , 3 ) - 256 ; \n SVQ1_CALC_CODEBOOK_ENTRIES ( ff_svq1_inter_codebooks ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width / 4 ; x ++ , codebook ++ ) { \n n3 = dst [ x ] ; \n n1 = n4 + ( ( n3 & 0xFF00FF00 ) >> 8 ) ; \n n2 = n4 + ( n3 & 0x00FF00FF ) ; \n SVQ1_ADD_CODEBOOK ( )  \n dst [ x ] = n1 << 8 | n2 ; \n } \n dst += pitch / 4 ; \n } \n } \n return 0 ; \n }", "idx": 6996}
{"project": "FFmpeg", "commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "target": 1, "func": "static int get_video_frame ( VideoState * is , AVFrame * frame ) \n { \n int got_picture ; \n if ( ( got_picture = decoder_decode_frame ( & is -> viddec , frame ) ) < 0 ) \n return -1 ; \n if ( got_picture ) { \n double dpts = NAN ; \n if ( frame -> pts != AV_NOPTS_VALUE ) \n dpts = av_q2d ( is -> video_st -> time_base ) * frame -> pts ; \n frame -> sample_aspect_ratio = av_guess_sample_aspect_ratio ( is -> ic , is -> video_st , frame ) ; \n if ( framedrop > 0 || ( framedrop && get_master_sync_type ( is ) != AV_SYNC_VIDEO_MASTER ) ) { \n if ( frame -> pts != AV_NOPTS_VALUE ) { \n double diff = dpts - get_master_clock ( is ) ; \n if ( ! isnan ( diff ) && fabs ( diff ) < AV_NOSYNC_THRESHOLD && \n diff - is -> frame_last_filter_delay < 0 && \n is -> viddec . pkt_serial == is -> vidclk . serial && \n is -> videoq . nb_packets ) { \n is -> frame_drops_early ++ ; \n av_frame_unref ( frame ) ; \n got_picture = 0 ; \n } \n } \n } \n } \n return got_picture ; \n }", "idx": 7007}
{"project": "FFmpeg", "commit_id": "cece491daa9f4c7c908e016f4e285a49d37cb17c", "target": 0, "func": "static void init_quantized_coeffs_elem0 ( int8_t * quantized_coeffs , GetBitContext * gb , int length ) \n { \n int i , k , run , level , diff ; \n if ( BITS_LEFT ( length , gb ) < 16 ) \n return ; \n level = qdm2_get_vlc ( gb , & vlc_tab_level , 0 , 2 ) ; \n quantized_coeffs [ 0 ] = level ; \n for ( i = 0 ; i < 7 ; ) { \n if ( BITS_LEFT ( length , gb ) < 16 ) \n break ; \n run = qdm2_get_vlc ( gb , & vlc_tab_run , 0 , 1 ) + 1 ; \n if ( BITS_LEFT ( length , gb ) < 16 ) \n break ; \n diff = qdm2_get_se_vlc ( & vlc_tab_diff , gb , 2 ) ; \n for ( k = 1 ; k <= run ; k ++ ) \n quantized_coeffs [ i + k ] = ( level + ( ( k * diff ) / run ) ) ; \n level += diff ; \n i += run ; \n } \n }", "idx": 7015}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_dc ) ( uint8_t * _src , int stride ) { \n int i ; \n int dc0 , dc1 , dc2 ; \n pixel4 dc0splat , dc1splat , dc2splat , dc3splat ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n dc0 = dc1 = dc2 = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dc0 += src [ -1 + i * stride ] + src [ i - stride ] ; \n dc1 += src [ 4 + i - stride ] ; \n dc2 += src [ -1 + ( i + 4 ) * stride ] ; \n } \n dc0splat = PIXEL_SPLAT_X4 ( ( dc0 + 4 ) >> 3 ) ; \n dc1splat = PIXEL_SPLAT_X4 ( ( dc1 + 2 ) >> 2 ) ; \n dc2splat = PIXEL_SPLAT_X4 ( ( dc2 + 2 ) >> 2 ) ; \n dc3splat = PIXEL_SPLAT_X4 ( ( dc1 + dc2 + 4 ) >> 3 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc0splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc1splat ; \n } \n for ( i = 4 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = dc2splat ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc3splat ; \n } \n }", "idx": 7041}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( uyvyToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( long ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i + 1 ] ; \n #endif \n }", "idx": 7044}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "func": "static void decodeplane32 ( uint32_t * dst , const uint8_t * const buf , int buf_size , int bps , int plane ) \n { \n GetBitContext gb ; \n int i , b ; \n init_get_bits ( & gb , buf , buf_size * 8 ) ; \n for ( i = 0 ; i < ( buf_size * 8 + bps - 1 ) / bps ; i ++ ) { \n for ( b = 0 ; b < bps ; b ++ ) { \n dst [ i * bps + b ] |= get_bits1 ( & gb ) << plane ; \n } \n } \n }", "idx": 7063}
{"project": "FFmpeg", "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51", "target": 0, "func": "static av_cold int vdadec_close ( AVCodecContext * avctx ) \n { \n VDADecoderContext * ctx = avctx -> priv_data ; \n ff_vda_destroy_decoder ( & ctx -> vda_ctx ) ; \n if ( ctx -> h264_initialized ) \n ff_h264_decoder . close ( avctx ) ; \n return 0 ; \n }", "idx": 7100}
{"project": "FFmpeg", "commit_id": "48efe9ec86acf6dcf6aabef2114f8dd04e4fbce4", "target": 1, "func": "static int build_huff ( const uint8_t * src , VLC * vlc , int * fsym ) \n { \n int i ; \n HuffEntry he [ 256 ] ; \n int last ; \n uint32_t codes [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint8_t syms [ 256 ] ; \n uint32_t code ; \n * fsym = -1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n he [ i ] . sym = i ; \n he [ i ] . len = * src ++ ; \n } \n qsort ( he , 256 , sizeof ( * he ) , ff_ut_huff_cmp_len ) ; \n if ( ! he [ 0 ] . len ) { \n * fsym = he [ 0 ] . sym ; \n return 0 ; \n } \n if ( he [ 0 ] . len > 32 ) \n return -1 ; \n last = 255 ; \n while ( he [ last ] . len == 255 && last ) \n last -- ; \n code = 1 ; \n for ( i = last ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n return ff_init_vlc_sparse ( vlc , FFMIN ( he [ last ] . len , 11 ) , last + 1 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 7127}
{"project": "FFmpeg", "commit_id": "5484dad7f6122a4d4dbc28e867a8c71d22ba2297", "target": 1, "func": "static int decode_residuals ( FLACContext * s , int channel , int pred_order ) \n { \n int i , tmp , partition , method_type , rice_order ; \n int sample = 0 , samples ; \n method_type = get_bits ( & s -> gb , 2 ) ; \n if ( method_type != 0 ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , method_type ) ; \n rice_order = get_bits ( & s -> gb , 4 ) ; \n samples = s -> blocksize >> rice_order ; \n sample = \n i = pred_order ; \n for ( partition = 0 ; partition < ( 1 << rice_order ) ; partition ++ ) \n { \n tmp = get_bits ( & s -> gb , 4 ) ; \n if ( tmp == 15 ) \n { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n tmp = get_bits ( & s -> gb , 5 ) ; \n for ( ; i < samples ; i ++ , sample ++ ) \n s -> decoded [ channel ] [ sample ] = get_sbits ( & s -> gb , tmp ) ; \n else  \n { \n for ( ; i < samples ; i ++ , sample ++ ) { \n s -> decoded [ channel ] [ sample ] = get_sr_golomb_flac ( & s -> gb , tmp , INT_MAX , 0 ) ; \n i = 0 ; \n return 0 ;", "idx": 7134}
{"project": "FFmpeg", "commit_id": "9d0b45ade864f3d2ccd8610149fe1fff53c4e937", "target": 1, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , int size , \n const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint32_t pos , taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n if ( taglen + ( ( ( uint64_t ) datalen ) << 4 ) + 44 > size ) \n return -1 ; \n pos += 44 + taglen ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 7141}
{"project": "FFmpeg", "commit_id": "a8ab52fae7286d4e7eec9256a08b6ad0b1e39d6c", "target": 1, "func": "static AVFrame * do_vmaf ( AVFilterContext * ctx , AVFrame * main , const AVFrame * ref ) \n { \n LIBVMAFContext * s = ctx -> priv ; \n pthread_mutex_lock ( & s -> lock ) ; \n while ( s -> frame_set != 0 ) { \n pthread_cond_wait ( & s -> cond , & s -> lock ) ; \n } \n av_frame_ref ( s -> gref , ref ) ; \n av_frame_ref ( s -> gmain , main ) ; \n s -> frame_set = 1 ; \n pthread_cond_signal ( & s -> cond ) ; \n pthread_mutex_unlock ( & s -> lock ) ; \n return main ; \n }", "idx": 7142}
{"project": "FFmpeg", "commit_id": "2ed9e17ed1793b3b66ed27c0a113676a46eb9871", "target": 1, "func": "int ff_audio_interleave_init ( AVFormatContext * s , \n const int * samples_per_frame , \n AVRational time_base ) \n { \n int i ; \n if ( ! samples_per_frame ) \n return -1 ; \n if ( ! time_base . num ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n aic -> sample_size = ( st -> codec -> channels * \n av_get_bits_per_sample ( st -> codec -> codec_id ) ) / 8 ; \n if ( ! aic -> sample_size ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n aic -> samples_per_frame = samples_per_frame ; \n aic -> samples = aic -> samples_per_frame ; \n aic -> time_base = time_base ; \n aic -> fifo_size = 100 * * aic -> samples ; \n aic -> fifo = av_fifo_alloc_array ( 100 , * aic -> samples ) ; \n } \n } \n return 0 ; \n }", "idx": 7143}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void set_frame_distances ( MpegEncContext * s ) { \n assert ( s -> current_picture_ptr -> f . pts != AV_NOPTS_VALUE ) ; \n s -> time = s -> current_picture_ptr -> f . pts * s -> avctx -> time_base . num ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B ) { \n s -> pb_time = s -> pp_time - ( s -> last_non_b_time - s -> time ) ; \n assert ( s -> pb_time > 0 && s -> pb_time < s -> pp_time ) ; \n } else { \n s -> pp_time = s -> time - s -> last_non_b_time ; \n s -> last_non_b_time = s -> time ; \n assert ( s -> picture_number == 0 || s -> pp_time > 0 ) ; \n } \n }", "idx": 7147}
{"project": "FFmpeg", "commit_id": "5128842ea2057c86550b833c9141c271df1bdc94", "target": 0, "func": "static int cbr_bit_allocation ( AC3EncodeContext * s ) \n { \n int ch ; \n int bits_left ; \n int snr_offset , snr_incr ; \n bits_left = 8 * s -> frame_size - ( s -> frame_bits + s -> exponent_bits ) ; \n snr_offset = s -> coarse_snr_offset << 4 ; \n while ( snr_offset >= 0 && \n bit_alloc ( s , snr_offset ) > bits_left ) { \n snr_offset -= 64 ; \n } \n if ( snr_offset < 0 ) \n return AVERROR ( EINVAL ) ; \n FFSWAP ( uint8_t * , s -> bap_buffer , s -> bap1_buffer ) ; \n for ( snr_incr = 64 ; snr_incr > 0 ; snr_incr >>= 2 ) { \n while ( snr_offset + 64 <= 1023 && \n bit_alloc ( s , snr_offset + snr_incr ) <= bits_left ) { \n snr_offset += snr_incr ; \n FFSWAP ( uint8_t * , s -> bap_buffer , s -> bap1_buffer ) ; \n } \n } \n FFSWAP ( uint8_t * , s -> bap_buffer , s -> bap1_buffer ) ; \n reset_block_bap ( s ) ; \n s -> coarse_snr_offset = snr_offset >> 4 ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) \n s -> fine_snr_offset [ ch ] = snr_offset & 0xF ; \n return 0 ; \n }", "idx": 7161}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static inline void transpose4x4 ( uint8_t * dst , uint8_t * src , x86_reg dst_stride , x86_reg src_stride ) { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + & r \" ( dst ) , \n \" \" ( src ) \n : \" \" ( dst_stride ) , \n \" \" ( src_stride ) \n : \" \" \n ) ; \n }", "idx": 7163}
{"project": "FFmpeg", "commit_id": "8b19ae07616bbd18969b94cbf5d74308a8f2bbdf", "target": 1, "func": "int av_crc_init ( AVCRC * ctx , int le , int bits , uint32_t poly , int ctx_size ) { \n int i , j ; \n uint32_t c ; \n if ( bits < 8 || bits > 32 || poly >= ( 1LL << bits ) ) \n return -1 ; \n if ( ctx_size != sizeof ( AVCRC ) * 257 && ctx_size != sizeof ( AVCRC ) * 1024 ) \n return -1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n if ( le ) { \n for ( c = i , j = 0 ; j < 8 ; j ++ ) \n c = ( c >> 1 ) ^ ( poly & ( - ( c & 1 ) ) ) ; \n ctx [ i ] = c ; \n } else { \n for ( c = i << 24 , j = 0 ; j < 8 ; j ++ ) \n c = ( c << 1 ) ^ ( ( poly << ( 32 - bits ) ) & ( ( ( int32_t ) c ) >> 31 ) ) ; \n ctx [ i ] = av_bswap32 ( c ) ; \n } \n } \n ctx [ 256 ] = 1 ; \n #if ! CONFIG_SMALL  \n  \n  if ( ctx_size >= sizeof ( AVCRC ) * 1024 ) \n for ( i = 0 ; i < 256 ; i ++ ) \n for ( j = 0 ; j < 3 ; j ++ ) \n ctx [ 256 * ( j + 1 ) + i ] = ( ctx [ 256 * j + i ] >> 8 ) ^ ctx [ ctx [ 256 * j + i ] & 0xFF ] ; \n #endif \n return 0 ; \n }", "idx": 7172}
{"project": "FFmpeg", "commit_id": "4ed66517c62c599701b3793fa2843d5a8530a4f4", "target": 1, "func": "int ff_lock_avcodec ( AVCodecContext * log_ctx , const AVCodec * codec ) \n { \n if ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || ! codec -> init ) \n return 0 ; \n if ( ff_mutex_lock ( & codec_mutex ) ) \n return -1 ; \n if ( atomic_fetch_add ( & entangled_thread_counter , 1 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n atomic_load ( & entangled_thread_counter ) ) ; \n ff_avcodec_locked = 1 ; \n ff_unlock_avcodec ( codec ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_assert0 ( ! ff_avcodec_locked ) ; \n ff_avcodec_locked = 1 ; \n return 0 ; \n }", "idx": 7181}
{"project": "FFmpeg", "commit_id": "47572323f2f908913b4d031af733047d481fb1f6", "target": 0, "func": "int av_get_packet ( AVIOContext * s , AVPacket * pkt , int size ) \n { \n int ret = av_new_packet ( pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pos = avio_tell ( s ) ; \n ret = avio_read ( s , pkt -> data , size ) ; \n if ( ret <= 0 ) \n av_free_packet ( pkt ) ; \n else \n av_shrink_packet ( pkt , ret ) ; \n return ret ; \n }", "idx": 7185}
{"project": "FFmpeg", "commit_id": "e8c93839148a168aedc978388f14c3599dd072f8", "target": 0, "func": "static int check_pes ( uint8_t * p , uint8_t * end ) { \n int pes1 ; \n int pes2 = ( p [ 3 ] & 0xC0 ) == 0x80 \n && ( p [ 4 ] & 0xC0 ) != 0x40 \n && ( ( p [ 4 ] & 0xC0 ) == 0x00 || ( p [ 4 ] & 0xC0 ) >> 2 == ( p [ 6 ] & 0xF0 ) ) ; \n for ( p += 3 ; p < end && * p == 0xFF ; p ++ ) ; \n if ( ( * p & 0xC0 ) == 0x40 ) p += 2 ; \n if ( ( * p & 0xF0 ) == 0x20 ) { \n pes1 = p [ 0 ] & p [ 2 ] & p [ 4 ] & 1 ; \n p += 5 ; \n } else if ( ( * p & 0xF0 ) == 0x30 ) { \n pes1 = p [ 0 ] & p [ 2 ] & p [ 4 ] & p [ 5 ] & p [ 7 ] & p [ 9 ] & 1 ; \n p += 10 ; \n } else \n pes1 = * p == 0x0F ; \n return pes1 || pes2 ; \n }", "idx": 7188}
{"project": "FFmpeg", "commit_id": "b57083529650be5417056453fae8b2bf2dface59", "target": 1, "func": "static int ape_probe ( AVProbeData * p ) \n { \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 7193}
{"project": "FFmpeg", "commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "target": 1, "func": "static int32_t scalarproduct_and_madd_int32_c ( int16_t * v1 , const int32_t * v2 , \n const int16_t * v3 , \n int order , int mul ) \n { \n int res = 0 ; \n while ( order -- ) { \n res += * v1 * * v2 ++ ; \n * v1 ++ += mul * * v3 ++ ; \n } \n return res ; \n }", "idx": 7198}
{"project": "FFmpeg", "commit_id": "e9064c9ce8ed18c3a3aab61e58e663b8f5b0c551", "target": 1, "func": "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) { \n unsigned char * dst = s -> frame . data [ 0 ] ; \n int i ; \n for ( i = 0 ; i < s -> avctx -> height && buf + s -> avctx -> width <= buf_end ; i ++ ) { \n memcpy ( dst , buf , s -> avctx -> width ) ; \n dst += s -> frame . linesize [ 0 ] ; \n buf += s -> avctx -> width ; \n } \n }", "idx": 7203}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "int av_buffersink_get_frame_flags ( AVFilterContext * ctx , AVFrame * frame , int flags ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n int ret ; \n AVFrame * cur_frame ; \n if ( ! av_fifo_size ( buf -> fifo ) ) { \n if ( flags & AV_BUFFERSINK_FLAG_NO_REQUEST ) \n return AVERROR ( EAGAIN ) ; \n if ( ( ret = ff_request_frame ( inlink ) ) < 0 ) \n return ret ; \n } \n if ( ! av_fifo_size ( buf -> fifo ) ) \n return AVERROR ( EINVAL ) ; \n if ( flags & AV_BUFFERSINK_FLAG_PEEK ) { \n cur_frame = * ( ( AVFrame * * ) av_fifo_peek2 ( buf -> fifo , 0 ) ) ; \n av_frame_ref ( frame , cur_frame ) ; \n } else { \n av_fifo_generic_read ( buf -> fifo , & cur_frame , sizeof ( cur_frame ) , NULL ) ; \n av_frame_move_ref ( frame , cur_frame ) ; \n av_frame_free ( & cur_frame ) ; \n } \n return 0 ; \n }", "idx": 7205}
{"project": "FFmpeg", "commit_id": "b371539a3d9be9b05cb9ea8065e8e3617a45b02f", "target": 0, "func": "static int mov_write_stbl_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n offset_t pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n mov_write_stsd_tag ( pb , track ) ; \n mov_write_stts_tag ( pb , track ) ; \n if ( track -> enc -> codec_type == CODEC_TYPE_VIDEO && \n track -> hasKeyframes < track -> entry ) \n mov_write_stss_tag ( pb , track ) ; \n if ( track -> enc -> codec_type == CODEC_TYPE_VIDEO && \n track -> hasBframes ) \n mov_write_ctts_tag ( pb , track ) ; \n mov_write_stsc_tag ( pb , track ) ; \n mov_write_stsz_tag ( pb , track ) ; \n mov_write_stco_tag ( pb , track ) ; \n return updateSize ( pb , pos ) ; \n }", "idx": 7227}
{"project": "FFmpeg", "commit_id": "6a4832caaede15e3d918b1408ff83fe30324507b", "target": 0, "func": "void ff_avg_dirac_pixels16_sse2 ( uint8_t * dst , const uint8_t * src [ 5 ] , int stride , int h ) \n { \n if ( h & 3 ) \n ff_avg_dirac_pixels16_c ( dst , src , stride , h ) ; \n else \n ff_avg_pixels16_sse2 ( dst , src [ 0 ] , stride , h ) ; \n }", "idx": 7236}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "int ff_ape_write_tag ( AVFormatContext * s ) \n { \n AVDictionaryEntry * e = NULL ; \n int64_t start , end ; \n int size , count = 0 ; \n if ( ! s -> pb -> seekable ) \n return 0 ; \n start = avio_tell ( s -> pb ) ; \n avio_write ( s -> pb , \" \" , 8 ) ; \n avio_wl32 ( s -> pb , APE_TAG_VERSION ) ; \n avio_wl32 ( s -> pb , 0 ) ; \n avio_wl32 ( s -> pb , 0 ) ; \n avio_wl32 ( s -> pb , APE_TAG_FLAG_CONTAINS_HEADER | APE_TAG_FLAG_CONTAINS_FOOTER | \n APE_TAG_FLAG_IS_HEADER ) ; \n ffio_fill ( s -> pb , 0 , 8 ) ; \n while ( ( e = av_dict_get ( s -> metadata , \" \" , e , AV_DICT_IGNORE_SUFFIX ) ) ) { \n int val_len = strlen ( e -> value ) ; \n avio_wl32 ( s -> pb , val_len ) ; \n avio_wl32 ( s -> pb , 0 ) ; \n avio_put_str ( s -> pb , e -> key ) ; \n avio_write ( s -> pb , e -> value , val_len ) ; \n count ++ ; \n } \n size = avio_tell ( s -> pb ) - start ; \n avio_write ( s -> pb , \" \" , 8 ) ; \n avio_wl32 ( s -> pb , APE_TAG_VERSION ) ; \n avio_wl32 ( s -> pb , size ) ; \n avio_wl32 ( s -> pb , count ) ; \n avio_wl32 ( s -> pb , APE_TAG_FLAG_CONTAINS_HEADER | APE_TAG_FLAG_CONTAINS_FOOTER ) ; \n ffio_fill ( s -> pb , 0 , 8 ) ; \n end = avio_tell ( s -> pb ) ; \n avio_seek ( s -> pb , start + 12 , SEEK_SET ) ; \n avio_wl32 ( s -> pb , size ) ; \n avio_wl32 ( s -> pb , count ) ; \n avio_seek ( s -> pb , end , SEEK_SET ) ; \n return 0 ; \n }", "idx": 7237}
{"project": "FFmpeg", "commit_id": "2e96f5278095d44f090a4d89507e62d27cccf3b9", "target": 1, "func": "static inline uint64_t v4l2_get_pts ( V4L2Buffer * avbuf ) \n { \n V4L2m2mContext * s = buf_to_m2mctx ( avbuf ) ; \n AVRational v4l2_timebase = { 1 , USEC_PER_SEC } ; \n int64_t v4l2_pts ; \n v4l2_pts = avbuf -> buf . timestamp . tv_sec * USEC_PER_SEC + avbuf -> buf . timestamp . tv_usec ; \n return av_rescale_q ( v4l2_pts , v4l2_timebase , s -> avctx -> time_base ) ; \n }", "idx": 7239}
{"project": "FFmpeg", "commit_id": "787f8fad00c66fc225662f7defb90e79c112ed40", "target": 0, "func": "static void read_ttag ( AVFormatContext * s , int taglen , const char * key ) \n { \n char * q , dst [ 512 ] ; \n int len , dstlen = sizeof ( dst ) - 1 ; \n unsigned genre ; \n dst [ 0 ] = 0 ; \n if ( taglen < 1 ) \n return ; \n taglen -- ; \n switch ( get_byte ( s -> pb ) ) { \n case 0 : \n q = dst ; \n while ( taglen -- ) { \n uint8_t tmp ; \n PUT_UTF8 ( get_byte ( s -> pb ) , tmp , if ( q - dst < dstlen - 1 ) * q ++  = tmp ; ) \n } \n * q = ' \\0 ' ; \n break ; \n case 3 : \n len = FFMIN ( taglen , dstlen - 1 ) ; \n get_buffer ( s -> pb , dst , len ) ; \n dst [ len ] = 0 ; \n break ; \n } \n if ( ! strcmp ( key , \" \" ) \n && ( sscanf ( dst , \" \" , & genre ) == 1 || sscanf ( dst , \" \" , & genre ) == 1 ) \n && genre <= ID3v1_GENRE_MAX ) \n av_strlcpy ( dst , ff_id3v1_genre_str [ genre ] , sizeof ( dst ) ) ; \n if ( * dst ) \n av_metadata_set ( & s -> metadata , key , dst ) ; \n }", "idx": 7247}
{"project": "FFmpeg", "commit_id": "310afddfe0c31ffd844eb640bdf2b3f052286dbe", "target": 0, "func": "static int unpack_block_qpis ( Vp3DecodeContext * s , GetBitContext * gb ) \n { \n int qpi , i , j , bit , run_length , blocks_decoded , num_blocks_at_qpi ; \n int num_blocks = s -> coded_fragment_list_index ; \n for ( qpi = 0 ; qpi < s -> nqps - 1 && num_blocks > 0 ; qpi ++ ) { \n i = blocks_decoded = num_blocks_at_qpi = 0 ; \n bit = get_bits1 ( gb ) ; \n do { \n run_length = get_vlc2 ( gb , s -> superblock_run_length_vlc . table , 6 , 2 ) + 1 ; \n if ( run_length == 34 ) \n run_length += get_bits ( gb , 12 ) ; \n blocks_decoded += run_length ; \n if ( ! bit ) \n num_blocks_at_qpi += run_length ; \n for ( j = 0 ; j < run_length ; i ++ ) { \n if ( i > s -> coded_fragment_list_index ) \n return -1 ; \n if ( s -> all_fragments [ s -> coded_fragment_list [ i ] ] . qpi == qpi ) { \n s -> all_fragments [ s -> coded_fragment_list [ i ] ] . qpi += bit ; \n j ++ ; \n } \n } \n if ( run_length == 4129 ) \n bit = get_bits1 ( gb ) ; \n else \n bit ^= 1 ; \n } while ( blocks_decoded < num_blocks ) ; \n num_blocks -= num_blocks_at_qpi ; \n } \n return 0 ; \n }", "idx": 7249}
{"project": "FFmpeg", "commit_id": "4f5c2e651a95b950f6a3fb36f2342cbc32515f17", "target": 1, "func": "static int dirac_header ( AVFormatContext * s , int idx ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n AVStream * st = s -> streams [ idx ] ; \n dirac_source_params source ; \n GetBitContext gb ; \n if ( st -> codec -> codec_id == AV_CODEC_ID_DIRAC ) \n return 0 ; \n init_get_bits ( & gb , os -> buf + os -> pstart + 13 , ( os -> psize - 13 ) * 8 ) ; \n if ( avpriv_dirac_parse_sequence_header ( st -> codec , & gb , & source ) < 0 ) \n return -1 ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = AV_CODEC_ID_DIRAC ; \n avpriv_set_pts_info ( st , 64 , st -> codec -> framerate . den , 2 * st -> codec -> framerate . num ) ; \n return 1 ; \n }", "idx": 7255}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static void sdp_parse_fmtp ( AVStream * st , const char * p ) \n { \n char attr [ 256 ] ; \n char value [ 16384 ] ; \n int i ; \n RTSPStream * rtsp_st = st -> priv_data ; \n AVCodecContext * codec = st -> codec ; \n RTPPayloadData * rtp_payload_data = & rtsp_st -> rtp_payload_data ; \n while ( rtsp_next_attr_and_value ( & p , attr , sizeof ( attr ) , value , sizeof ( value ) ) ) \n { \n sdp_parse_fmtp_config ( codec , rtsp_st -> dynamic_protocol_context , \n attr , value ) ; \n for ( i = 0 ; attr_names [ i ] . str ; ++ i ) { \n if ( ! strcasecmp ( attr , attr_names [ i ] . str ) ) { \n if ( attr_names [ i ] . type == ATTR_NAME_TYPE_INT ) \n * ( int * ) ( ( char * ) rtp_payload_data + attr_names [ i ] . offset ) = atoi ( value ) ; \n else if ( attr_names [ i ] . type == ATTR_NAME_TYPE_STR ) \n * ( char * * ) ( ( char * ) rtp_payload_data + attr_names [ i ] . offset ) = av_strdup ( value ) ; \n } \n } \n } \n }", "idx": 7258}
{"project": "FFmpeg", "commit_id": "49e5dcbce5f9e08ec375fd54c413148beb81f1d7", "target": 1, "func": "static int h261_decode_gob ( H261Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int v ; \n ff_set_qscale ( s , s -> qscale ) ; \n v = show_bits ( & s -> gb , 15 ) ; \n if ( get_bits_count ( & s -> gb ) + 15 > s -> gb . size_in_bits ) { \n v >>= get_bits_count ( & s -> gb ) + 15 - s -> gb . size_in_bits ; \n } \n if ( v == 0 ) { \n h261_decode_mb_skipped ( h , 0 , 33 ) ; \n return 0 ; \n } \n while ( h -> current_mba <= MAX_MBA ) \n { \n int ret ; \n ret = h261_decode_mb ( h , s -> block ) ; \n if ( ret < 0 ) { \n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ; \n if ( ret == SLICE_END ) { \n MPV_decode_mb ( s , s -> block ) ; \n if ( h -> loop_filter ) { \n ff_h261_loop_filter ( h ) ; \n } \n h -> loop_filter = 0 ; \n h261_decode_mb_skipped ( h , h -> current_mba - h -> mba_diff , h -> current_mba - 1 ) ; \n h261_decode_mb_skipped ( h , h -> current_mba , 33 ) ; \n return 0 ; \n } else if ( ret == SLICE_NOEND ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , xy ) ; \n return -1 ; \n } \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , xy ) ; \n return -1 ; \n } \n MPV_decode_mb ( s , s -> block ) ; \n if ( h -> loop_filter ) { \n ff_h261_loop_filter ( h ) ; \n } \n h -> loop_filter = 0 ; \n h261_decode_mb_skipped ( h , h -> current_mba - h -> mba_diff , h -> current_mba - 1 ) ; \n } \n return -1 ; \n }", "idx": 7259}
{"project": "FFmpeg", "commit_id": "e614fac2e6e185a247d722d4e92368b3c3bc4bdb", "target": 1, "func": "static av_cold int adpcm_decode_init ( AVCodecContext * avctx ) \n { \n ADPCMDecodeContext * c = avctx -> priv_data ; \n unsigned int max_channels = 2 ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_ADPCM_EA_R1 : \n case CODEC_ID_ADPCM_EA_R2 : \n case CODEC_ID_ADPCM_EA_R3 : \n case CODEC_ID_ADPCM_EA_XAS : \n max_channels = 6 ; \n break ; \n } \n if ( avctx -> channels > max_channels ) { \n return -1 ; \n } \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_ADPCM_CT : \n c -> status [ 0 ] . step = c -> status [ 1 ] . step = 511 ; \n break ; \n case CODEC_ID_ADPCM_IMA_WAV : \n if ( avctx -> bits_per_coded_sample != 4 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n break ; \n case CODEC_ID_ADPCM_IMA_WS : \n if ( avctx -> extradata && avctx -> extradata_size == 2 * 4 ) { \n c -> status [ 0 ] . predictor = AV_RL32 ( avctx -> extradata ) ; \n c -> status [ 1 ] . predictor = AV_RL32 ( avctx -> extradata + 4 ) ; \n } \n break ; \n default : \n break ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n avcodec_get_frame_defaults ( & c -> frame ) ; \n avctx -> coded_frame = & c -> frame ; \n return 0 ; \n }", "idx": 7268}
{"project": "FFmpeg", "commit_id": "9ac1bf88c00dbe7eb2191e2d5325fb104b9d8341", "target": 0, "func": "AVFormatContext * avformat_alloc_context ( void ) \n { \n AVFormatContext * ic ; \n ic = av_malloc ( sizeof ( AVFormatContext ) ) ; \n if ( ! ic ) return ic ; \n avformat_get_context_defaults ( ic ) ; \n ic -> av_class = & av_format_context_class ; \n return ic ; \n }", "idx": 7274}
{"project": "FFmpeg", "commit_id": "eabbae730cf732afeb7c2a085e0e5c1e7b1b8614", "target": 0, "func": "offset_t url_filesize ( URLContext * h ) \n { \n offset_t pos , size ; \n size = url_seek ( h , 0 , AVSEEK_SIZE ) ; \n if ( size < 0 ) { \n pos = url_seek ( h , 0 , SEEK_CUR ) ; \n size = url_seek ( h , -1 , SEEK_END ) + 1 ; \n url_seek ( h , pos , SEEK_SET ) ; \n } \n return size ; \n }", "idx": 7275}
{"project": "FFmpeg", "commit_id": "6470abc740367cc881c181db866891f8dd1d342f", "target": 0, "func": "static int load_apply_palette ( FFFrameSync * fs ) \n { \n AVFilterContext * ctx = fs -> parent ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n PaletteUseContext * s = ctx -> priv ; \n AVFrame * master , * second , * out ; \n int ret ; \n ret = ff_framesync_dualinput_get_writable ( fs , & master , & second ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! master || ! second ) { \n ret = AVERROR_BUG ; \n goto error ; \n } \n if ( ! s -> palette_loaded ) { \n load_palette ( s , second ) ; \n } \n out = apply_palette ( inlink , master ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out ) ; \n error : \n av_frame_free ( & master ) ; \n av_frame_free ( & second ) ; \n return ret ; \n }", "idx": 7278}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static int ac3_encode_frame ( AVCodecContext * avctx , unsigned char * frame , \n int buf_size , void * data ) \n { \n AC3EncodeContext * s = avctx -> priv_data ; \n const SampleType * samples = data ; \n int ret ; \n if ( s -> bit_alloc . sr_code == 1 ) \n adjust_frame_size ( s ) ; \n deinterleave_input_samples ( s , samples ) ; \n apply_mdct ( s ) ; \n compute_rematrixing_strategy ( s ) ; \n scale_coefficients ( s ) ; \n apply_rematrixing ( s ) ; \n process_exponents ( s ) ; \n ret = compute_bit_allocation ( s ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n quantize_mantissas ( s ) ; \n output_frame ( s , frame ) ; \n return s -> frame_size ; \n }", "idx": 7282}
{"project": "FFmpeg", "commit_id": "71a2c9b26567e2294b54eedafeb23aee08563de7", "target": 1, "func": "static void term_init ( void ) \n { \n #if HAVE_TERMIOS_H  \n  \n  if ( ! run_as_daemon ) { \n struct termios tty ; \n tcgetattr ( 0 , & tty ) ; \n oldtty = tty ; \n atexit ( term_exit ) ; \n tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP \n | INLCR | IGNCR | ICRNL | IXON ) ; \n tty . c_oflag |= OPOST ; \n tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; \n tty . c_cflag &= ~ ( CSIZE | PARENB ) ; \n tty . c_cflag |= CS8 ; \n tty . c_cc [ VMIN ] = 1 ; \n tty . c_cc [ VTIME ] = 0 ; \n tcsetattr ( 0 , TCSANOW , & tty ) ; \n signal ( SIGQUIT , sigterm_handler ) ; \n } \n #endif \n avformat_network_deinit ( ) ; \n signal ( SIGINT , sigterm_handler ) ; \n signal ( SIGTERM , sigterm_handler ) ; \n #ifdef SIGXCPU \n signal ( SIGXCPU , sigterm_handler ) ; \n #endif \n }", "idx": 7284}
{"project": "FFmpeg", "commit_id": "f542dedf72091af8e6f32a12bd64289c58857c21", "target": 1, "func": "static int tcp_write_packet ( AVFormatContext * s , RTSPStream * rtsp_st ) \n { \n RTSPState * rt = s -> priv_data ; \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n uint8_t * buf , * ptr ; \n int size ; \n uint8_t * interleave_header , * interleaved_packet ; \n size = avio_close_dyn_buf ( rtpctx -> pb , & buf ) ; \n ptr = buf ; \n while ( size > 4 ) { \n uint32_t packet_len = AV_RB32 ( ptr ) ; \n int id ; \n interleaved_packet = interleave_header = ptr ; \n ptr += 4 ; \n size -= 4 ; \n if ( packet_len > size || packet_len < 2 ) \n break ; \n if ( RTP_PT_IS_RTCP ( ptr [ 1 ] ) ) \n id = rtsp_st -> interleaved_max ; \n else \n id = rtsp_st -> interleaved_min ; \n interleave_header [ 0 ] = ' ' ; \n interleave_header [ 1 ] = id ; \n AV_WB16 ( interleave_header + 2 , packet_len ) ; \n ffurl_write ( rt -> rtsp_hd_out , interleaved_packet , 4 + packet_len ) ; \n ptr += packet_len ; \n size -= packet_len ; \n } \n av_free ( buf ) ; \n ffio_open_dyn_packet_buf ( & rtpctx -> pb , RTSP_TCP_MAX_PACKET_SIZE ) ; \n return 0 ; \n }", "idx": 7285}
{"project": "FFmpeg", "commit_id": "001bcd29556b32c1afd686c03f6bdd65dd0e9a36", "target": 1, "func": "static int modify_current_stream ( HTTPContext * c , char * rates ) \n { \n int i ; \n FFStream * req = c -> stream ; \n int action_required = 0 ; \n for ( i = 0 ; i < req -> nb_streams ; i ++ ) { \n AVCodecContext * codec = & req -> streams [ i ] -> codec ; \n switch ( rates [ i ] ) { \n case 0 : \n c -> switch_feed_streams [ i ] = req -> feed_streams [ i ] ; \n break ; \n case 1 : \n c -> switch_feed_streams [ i ] = find_stream_in_feed ( req -> feed , codec , codec -> bit_rate / 2 ) ; \n break ; \n case 2 : \n c -> switch_feed_streams [ i ] = find_stream_in_feed ( req -> feed , codec , codec -> bit_rate / 4 ) ; \n #ifdef WANTS_OFF \n c -> switch_feed_streams [ i ] = -2 ; \n c -> feed_streams [ i ] = -2 ; \n #endif \n break ; \n } \n if ( c -> switch_feed_streams [ i ] >= 0 && c -> switch_feed_streams [ i ] != c -> feed_streams [ i ] ) \n action_required = 1 ; \n } \n return action_required ; \n }", "idx": 7293}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( nv12ToUV ) ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src1 , const uint8_t * src2 , \n int width , uint32_t * unused ) \n { \n RENAME ( nvXXtoUV ) ( dstU , dstV , src1 , width ) ; \n }", "idx": 7298}
{"project": "FFmpeg", "commit_id": "df8aa4598c7cc1c2f863f6fc6b2d4b3e6dc7345e", "target": 1, "func": "static int mpegts_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int ret , i ; \n ts -> pkt = pkt ; \n ret = handle_packets ( ts , 0 ) ; \n if ( ret < 0 ) { \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) { \n if ( ts -> pids [ i ] && ts -> pids [ i ] -> type == MPEGTS_PES ) { \n PESContext * pes = ts -> pids [ i ] -> u . pes_filter . opaque ; \n if ( pes -> state == MPEGTS_PAYLOAD && pes -> data_index > 0 ) { \n new_pes_packet ( pes , pkt ) ; \n pes -> state = MPEGTS_SKIP ; \n ret = 0 ; \n break ; \n } \n } \n } \n } \n if ( ! ret && pkt -> size < 0 ) \n ret = AVERROR ( EINTR ) ; \n return ret ; \n }", "idx": 7302}
{"project": "FFmpeg", "commit_id": "e9064c9ce8ed18c3a3aab61e58e663b8f5b0c551", "target": 1, "func": "static void cmv_decode_inter ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) { \n const uint8_t * raw = buf + ( s -> avctx -> width * s -> avctx -> height / 16 ) ; \n int x , y , i ; \n i = 0 ; \n for ( y = 0 ; y < s -> avctx -> height / 4 ; y ++ ) \n for ( x = 0 ; x < s -> avctx -> width / 4 && buf + i < buf_end ; x ++ ) { \n if ( buf [ i ] == 0xFF ) { \n unsigned char * dst = s -> frame . data [ 0 ] + ( y * 4 ) * s -> frame . linesize [ 0 ] + x * 4 ; \n if ( raw + 16 < buf_end && * raw == 0xFF ) { \n raw ++ ; \n memcpy ( dst , raw , 4 ) ; \n memcpy ( dst + s -> frame . linesize [ 0 ] , raw + 4 , 4 ) ; \n memcpy ( dst + 2 * s -> frame . linesize [ 0 ] , raw + 8 , 4 ) ; \n memcpy ( dst + 3 * s -> frame . linesize [ 0 ] , raw + 12 , 4 ) ; \n raw += 16 ; \n } else if ( raw < buf_end ) { \n int xoffset = ( * raw & 0xF ) - 7 ; \n int yoffset = ( ( * raw >> 4 ) ) - 7 ; \n if ( s -> last2_frame . data [ 0 ] ) \n cmv_motcomp ( s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] , \n s -> last2_frame . data [ 0 ] , s -> last2_frame . linesize [ 0 ] , \n x * 4 , y * 4 , xoffset , yoffset , s -> avctx -> width , s -> avctx -> height ) ; \n raw ++ ; \n } \n } else { \n int xoffset = ( buf [ i ] & 0xF ) - 7 ; \n int yoffset = ( ( buf [ i ] >> 4 ) ) - 7 ; \n cmv_motcomp ( s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] , \n s -> last_frame . data [ 0 ] , s -> last_frame . linesize [ 0 ] , \n x * 4 , y * 4 , xoffset , yoffset , s -> avctx -> width , s -> avctx -> height ) ; \n } \n i ++ ; \n } \n }", "idx": 7304}
{"project": "FFmpeg", "commit_id": "552a99957f7c6f6ed13795caee7ab7b9deb5d76e", "target": 1, "func": "static int qdm2_parse_packet ( AVFormatContext * s , PayloadContext * qdm , \n AVStream * st , AVPacket * pkt , \n uint32_t * timestamp , \n const uint8_t * buf , int len , int flags ) \n { \n int res = AVERROR_INVALIDDATA , n ; \n const uint8_t * end = buf + len , * p = buf ; \n if ( len > 0 ) { \n if ( len < 2 ) \n return AVERROR_INVALIDDATA ; \n if ( * p == 0xff ) { \n if ( qdm -> n_pkts > 0 ) { \n av_log ( s , AV_LOG_WARNING , \n \" \\n \" ) ; \n qdm -> n_pkts = 0 ; \n memset ( qdm -> len , 0 , sizeof ( qdm -> len ) ) ; \n } \n if ( ( res = qdm2_parse_config ( qdm , st , ++ p , end ) ) < 0 ) \n return res ; \n p += res ; \n st -> codec -> codec_id = CODEC_ID_QDM2 ; \n } \n while ( end - p >= 4 ) { \n if ( ( res = qdm2_parse_subpacket ( qdm , st , p , end ) ) < 0 ) \n return res ; \n p += res ; \n } \n qdm -> timestamp = * timestamp ; \n if ( ++ qdm -> n_pkts < qdm -> subpkts_per_block ) \n qdm -> cache = 0 ; \n for ( n = 0 ; n < 0x80 ; n ++ ) \n if ( qdm -> len [ n ] > 0 ) \n qdm -> cache ++ ; \n } \n if ( ! qdm -> cache || ( res = qdm2_restore_block ( qdm , st , pkt ) ) < 0 ) \n return res ; \n if ( -- qdm -> cache == 0 ) \n qdm -> n_pkts = 0 ; \n * timestamp = qdm -> timestamp ; \n qdm -> timestamp = RTP_NOTS_VALUE ; \n return ( qdm -> cache > 0 ) ? 1 : 0 ; \n }", "idx": 7306}
{"project": "FFmpeg", "commit_id": "9588ec340c3f33c7474b4cd2893046cfdaee42bf", "target": 0, "func": "static inline int get_cabac_cbf_ctx ( H264Context * h , int cat , int idx ) { \n int nza , nzb ; \n int ctx = 0 ; \n if ( cat == 0 ) { \n nza = h -> left_cbp & 0x100 ; \n nzb = h -> top_cbp & 0x100 ; \n } else if ( cat == 1 || cat == 2 ) { \n nza = h -> non_zero_count_cache [ scan8 [ idx ] - 1 ] ; \n nzb = h -> non_zero_count_cache [ scan8 [ idx ] - 8 ] ; \n } else if ( cat == 3 ) { \n nza = ( h -> left_cbp >> ( 6 + idx ) ) & 0x01 ; \n nzb = ( h -> top_cbp >> ( 6 + idx ) ) & 0x01 ; \n } else { \n assert ( cat == 4 ) ; \n nza = h -> non_zero_count_cache [ scan8 [ 16 + idx ] - 1 ] ; \n nzb = h -> non_zero_count_cache [ scan8 [ 16 + idx ] - 8 ] ; \n } \n if ( nza > 0 ) \n ctx ++ ; \n if ( nzb > 0 ) \n ctx += 2 ; \n return ctx + 4 * cat ; \n }", "idx": 7330}
{"project": "FFmpeg", "commit_id": "c49e7924a8b537f2cda0da8627641fb97528fc11", "target": 1, "func": "int av_expr_parse ( AVExpr * * expr , const char * s , \n const char * const * const_names , \n const char * const * func1_names , double ( * const * funcs1 ) ( void * , double ) , \n const char * const * func2_names , double ( * const * funcs2 ) ( void * , double , double ) , \n int log_offset , void * log_ctx ) \n { \n Parser p = { 0 } ; \n AVExpr * e = NULL ; \n char * w = av_malloc ( strlen ( s ) + 1 ) ; \n char * wp = w ; \n const char * s0 = s ; \n int ret = 0 ; \n if ( ! w ) \n return AVERROR ( ENOMEM ) ; \n while ( * s ) \n if ( ! av_isspace ( * s ++ ) ) * wp ++ = s [ -1 ] ; \n * wp ++ = 0 ; \n p . class = & eval_class ; \n p . stack_index = 100 ; \n p . s = w ; \n p . const_names = const_names ; \n p . funcs1 = funcs1 ; \n p . func1_names = func1_names ; \n p . funcs2 = funcs2 ; \n p . func2_names = func2_names ; \n p . log_offset = log_offset ; \n p . log_ctx = log_ctx ; \n if ( ( ret = parse_expr ( & e , & p ) ) < 0 ) \n if ( * p . s ) { \n av_log ( & p , AV_LOG_ERROR , \" \\n \" , p . s , s0 ) ; \n ret = AVERROR ( EINVAL ) ; \n if ( ! verify_expr ( e ) ) { \n ret = AVERROR ( EINVAL ) ; \n e -> var = av_mallocz ( sizeof ( double ) * VARS ) ; \n * expr = e ; \n e = NULL ; \n end : \n av_expr_free ( e ) ; \n av_free ( w ) ; \n return ret ;", "idx": 7338}
{"project": "FFmpeg", "commit_id": "9e329185d701f60412eb70c4ffbeb345bd459e82", "target": 1, "func": "static double get_volume ( CompandContext * s , double in_lin ) \n { \n CompandSegment * cs ; \n double in_log , out_log ; \n int i ; \n if ( in_lin < s -> in_min_lin ) \n return s -> out_min_lin ; \n in_log = log ( in_lin ) ; \n for ( i = 1 ; ; i ++ ) \n if ( in_log <= s -> segments [ i + 1 ] . x ) \n break ; \n cs = & s -> segments [ i ] ; \n in_log -= cs -> x ; \n out_log = cs -> y + in_log * ( cs -> a * in_log + cs -> b ) ; \n return exp ( out_log ) ; \n }", "idx": 7345}
{"project": "FFmpeg", "commit_id": "04618b98e361951f550b3970865803a875f4a8f0", "target": 0, "func": "static int decode_cabac_mb_ref ( H264Context * h , int list , int n ) { \n int refa = h -> ref_cache [ list ] [ scan8 [ n ] - 1 ] ; \n int refb = h -> ref_cache [ list ] [ scan8 [ n ] - 8 ] ; \n int ref = 0 ; \n int ctx = 0 ; \n if ( h -> slice_type_nos == FF_B_TYPE ) { \n if ( refa > 0 && ! h -> direct_cache [ scan8 [ n ] - 1 ] ) \n ctx ++ ; \n if ( refb > 0 && ! h -> direct_cache [ scan8 [ n ] - 8 ] ) \n ctx += 2 ; \n } else { \n if ( refa > 0 ) \n ctx ++ ; \n if ( refb > 0 ) \n ctx += 2 ; \n } \n while ( get_cabac ( & h -> cabac , & h -> cabac_state [ 54 + ctx ] ) ) { \n ref ++ ; \n if ( ctx < 4 ) \n ctx = 4 ; \n else \n ctx = 5 ; \n if ( ref >= 32 \n ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n return ref ; \n }", "idx": 7362}
{"project": "FFmpeg", "commit_id": "56279f1d6155a7af52526b9852ee28831d0232a6", "target": 0, "func": "static av_cold int roq_dpcm_encode_init ( AVCodecContext * avctx ) \n { \n ROQDPCMContext * context = avctx -> priv_data ; \n if ( avctx -> channels > 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_rate != 22050 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_fmt != AV_SAMPLE_FMT_S16 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> frame_size = ROQ_FIRST_FRAME_SIZE ; \n context -> lastSample [ 0 ] = context -> lastSample [ 1 ] = 0 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 7384}
{"project": "FFmpeg", "commit_id": "c4e6024adc18df8ff82157227e2b4159f77951f9", "target": 1, "func": "static void close_slaves ( AVFormatContext * avf ) \n { \n TeeContext * tee = avf -> priv_data ; \n AVFormatContext * avf2 ; \n unsigned i , j ; \n for ( i = 0 ; i < tee -> nb_slaves ; i ++ ) { \n avf2 = tee -> slaves [ i ] . avf ; \n for ( j = 0 ; j < avf2 -> nb_streams ; j ++ ) { \n AVBitStreamFilterContext * bsf_next , * bsf = tee -> slaves [ i ] . bsfs [ j ] ; \n while ( bsf ) { \n bsf_next = bsf -> next ; \n av_bitstream_filter_close ( bsf ) ; \n bsf = bsf_next ; \n } \n } \n av_freep ( & tee -> slaves [ i ] . stream_map ) ; \n avio_close ( avf2 -> pb ) ; \n avf2 -> pb = NULL ; \n avformat_free_context ( avf2 ) ; \n tee -> slaves [ i ] . avf = NULL ; \n } \n }", "idx": 7390}
{"project": "FFmpeg", "commit_id": "e9d443cf08503f7bd0149576ba9e891322de340d", "target": 0, "func": "static void cmv_process_header ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) \n { \n int pal_start , pal_count , i ; \n if ( buf_end - buf < 16 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return ; \n } \n s -> width = AV_RL16 ( & buf [ 4 ] ) ; \n s -> height = AV_RL16 ( & buf [ 6 ] ) ; \n if ( s -> avctx -> width != s -> width || s -> avctx -> height != s -> height ) \n avcodec_set_dimensions ( s -> avctx , s -> width , s -> height ) ; \n s -> avctx -> time_base . num = 1 ; \n s -> avctx -> time_base . den = AV_RL16 ( & buf [ 10 ] ) ; \n pal_start = AV_RL16 ( & buf [ 12 ] ) ; \n pal_count = AV_RL16 ( & buf [ 14 ] ) ; \n buf += 16 ; \n for ( i = pal_start ; i < pal_start + pal_count && i < AVPALETTE_COUNT && buf_end - buf >= 3 ; i ++ ) { \n s -> palette [ i ] = 0xFFU << 24 | AV_RB24 ( buf ) ; \n buf += 3 ; \n } \n }", "idx": 7417}
{"project": "FFmpeg", "commit_id": "f5be7958e313f3f62505ea7f90007800e8e1dcb5", "target": 0, "func": "static void qdm2_calculate_fft ( QDM2Context * q , int channel , int sub_packet ) \n { \n const float gain = ( q -> channels == 1 && q -> nb_channels == 2 ) ? 0.5f : 1.0f ; \n int i ; \n q -> fft . complex [ channel ] [ 0 ] . re *= 2.0f ; \n q -> fft . complex [ channel ] [ 0 ] . im = 0.0f ; \n q -> rdft_ctx . rdft_calc ( & q -> rdft_ctx , ( FFTSample * ) q -> fft . complex [ channel ] ) ; \n for ( i = 0 ; i < ( ( q -> fft_frame_size + 15 ) & ~ 15 ) ; i ++ ) \n q -> output_buffer [ q -> channels * i + channel ] += ( ( float * ) q -> fft . complex [ channel ] ) [ i ] * gain ; \n }", "idx": 7433}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_v_lpf_luma_inter_msa ( uint8_t * data , int img_width , \n int alpha , int beta , int8_t * tc ) \n { \n uint8_t bs0 = 1 ; \n uint8_t bs1 = 1 ; \n uint8_t bs2 = 1 ; \n uint8_t bs3 = 1 ; \n if ( tc [ 0 ] < 0 ) \n bs0 = 0 ; \n if ( tc [ 1 ] < 0 ) \n bs1 = 0 ; \n if ( tc [ 2 ] < 0 ) \n bs2 = 0 ; \n if ( tc [ 3 ] < 0 ) \n bs3 = 0 ; \n avc_loopfilter_luma_inter_edge_hor_msa ( data , \n bs0 , bs1 , bs2 , bs3 , \n tc [ 0 ] , tc [ 1 ] , tc [ 2 ] , tc [ 3 ] , \n alpha , beta , img_width ) ; \n }", "idx": 7465}
{"project": "FFmpeg", "commit_id": "eb89b4fc0994d682cd3f24b882164439c8c3af28", "target": 0, "func": "static int device_open ( AVFormatContext * ctx , uint32_t * capabilities ) \n { \n struct v4l2_capability cap ; \n int fd ; \n int res , err ; \n int flags = O_RDWR ; \n if ( ctx -> flags & AVFMT_FLAG_NONBLOCK ) { \n flags |= O_NONBLOCK ; \n } \n fd = open ( ctx -> filename , flags , 0 ) ; \n if ( fd < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n ctx -> filename , strerror ( errno ) ) ; \n return AVERROR ( errno ) ; \n } \n res = ioctl ( fd , VIDIOC_QUERYCAP , & cap ) ; \n if ( res < 0 && ( ( err = errno ) == 515 ) ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n close ( fd ) ; \n return AVERROR ( 515 ) ; \n } \n if ( res < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n strerror ( errno ) ) ; \n close ( fd ) ; \n return AVERROR ( err ) ; \n } \n if ( ( cap . capabilities & V4L2_CAP_VIDEO_CAPTURE ) == 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n close ( fd ) ; \n return AVERROR ( ENODEV ) ; \n } \n * capabilities = cap . capabilities ; \n return fd ; \n }", "idx": 7468}
{"project": "FFmpeg", "commit_id": "147ee4cf065a20bbba10292b496a037e6573cd6e", "target": 0, "func": "void ff_thread_flush ( AVCodecContext * avctx ) \n { \n FrameThreadContext * fctx = avctx -> thread_opaque ; \n if ( ! avctx -> thread_opaque ) return ; \n park_frame_worker_threads ( fctx , avctx -> thread_count ) ; \n if ( fctx -> prev_thread ) { \n if ( fctx -> prev_thread != & fctx -> threads [ 0 ] ) \n update_context_from_thread ( fctx -> threads [ 0 ] . avctx , fctx -> prev_thread -> avctx , 0 ) ; \n if ( avctx -> codec -> flush ) \n avctx -> codec -> flush ( fctx -> threads [ 0 ] . avctx ) ; \n } \n fctx -> next_decoding = fctx -> next_finished = 0 ; \n fctx -> delaying = 1 ; \n fctx -> prev_thread = NULL ; \n for ( int i = 0 ; i < avctx -> thread_count ; i ++ ) \n fctx -> threads [ i ] . got_frame = 0 ; \n }", "idx": 7478}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_mb_qmin ( const char * arg ) \n { \n video_mb_qmin = atoi ( arg ) ; \n if ( video_mb_qmin < 0 || \n video_mb_qmin > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 7489}
{"project": "FFmpeg", "commit_id": "dc6f1a8dda00c3bc206486396e4a11941fc1cbe3", "target": 1, "func": "static int64_t get_pts ( const char * * buf , int * duration , \n int32_t * x1 , int32_t * y1 , int32_t * x2 , int32_t * y2 ) \n { \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n int hh1 , mm1 , ss1 , ms1 ; \n int hh2 , mm2 , ss2 , ms2 ; \n if ( sscanf ( * buf , \" \" \n \" \" , \n & hh1 , & mm1 , & ss1 , & ms1 , \n & hh2 , & mm2 , & ss2 , & ms2 , \n x1 , x2 , y1 , y2 ) >= 8 ) { \n int64_t start = ( hh1 * 3600LL + mm1 * 60LL + ss1 ) * 1000LL + ms1 ; \n int64_t end = ( hh2 * 3600LL + mm2 * 60LL + ss2 ) * 1000LL + ms2 ; \n * duration = end - start ; \n * buf += strcspn ( * buf , \" \\n \" ) + 1 ; \n return start ; \n } \n * buf += strcspn ( * buf , \" \\n \" ) + 1 ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 7526}
{"project": "FFmpeg", "commit_id": "ca2209d67af0a73fe0edb2fce1cea2445dbfd8db", "target": 1, "func": "static int hevc_find_frame_end ( AVCodecParserContext * s , const uint8_t * buf , \n int buf_size ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n ParseContext * pc = & ctx -> pc ; \n int i ; \n for ( i = 0 ; i < buf_size ; i ++ ) { \n int nut ; \n pc -> state64 = ( pc -> state64 << 8 ) | buf [ i ] ; \n if ( ( ( pc -> state64 >> 3 * 8 ) & 0xFFFFFF ) != START_CODE ) \n continue ; \n nut = ( pc -> state64 >> 2 * 8 + 1 ) & 0x3F ; \n if ( ( nut >= HEVC_NAL_VPS && nut <= HEVC_NAL_AUD ) || nut == HEVC_NAL_SEI_PREFIX || \n ( nut >= 41 && nut <= 44 ) || ( nut >= 48 && nut <= 55 ) ) { \n if ( pc -> frame_start_found ) { \n pc -> frame_start_found = 0 ; \n return i - 5 ; \n } \n } else if ( nut <= HEVC_NAL_RASL_R || \n ( nut >= HEVC_NAL_BLA_W_LP && nut <= HEVC_NAL_CRA_NUT ) ) { \n int first_slice_segment_in_pic_flag = buf [ i ] >> 7 ; \n if ( first_slice_segment_in_pic_flag ) { \n if ( ! pc -> frame_start_found ) { \n pc -> frame_start_found = 1 ; \n } else { \n pc -> frame_start_found = 0 ; \n return i - 5 ; \n } \n } \n } \n } \n return END_NOT_FOUND ; \n }", "idx": 7532}
{"project": "FFmpeg", "commit_id": "69dde1ad36b7d95b8b9268f414aa6c076212ed41", "target": 0, "func": "static int mov_write_audio_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n int pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n if ( track -> enc -> codec_id == CODEC_ID_PCM_MULAW ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_PCM_ALAW ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_ADPCM_IMA_QT ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_MACE3 ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_MACE6 ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_AAC ) \n put_tag ( pb , \" \" ) ; \n else if ( track -> enc -> codec_id == CODEC_ID_AMR_NB ) \n put_tag ( pb , \" \" ) ; \n else \n put_tag ( pb , \" \" ) ; \n put_be32 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 1 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be32 ( pb , 0 ) ; \n put_be16 ( pb , track -> enc -> channels ) ; \n put_be16 ( pb , 0x10 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , track -> timescale ) ; \n put_be16 ( pb , 0 ) ; \n if ( track -> enc -> codec_id == CODEC_ID_AAC ) \n mov_write_esds_tag ( pb , track ) ; \n if ( track -> enc -> codec_id == CODEC_ID_AMR_NB ) \n mov_write_damr_tag ( pb ) ; \n return updateSize ( pb , pos ) ; \n }", "idx": 7534}
{"project": "FFmpeg", "commit_id": "fc3a03fcf9cd7eafe7342e2508e6128888efa0bb", "target": 1, "func": "void ff_framequeue_skip_samples ( FFFrameQueue * fq , size_t samples , AVRational time_base ) \n { \n FFFrameBucket * b ; \n size_t bytes ; \n int planar , planes , i ; \n check_consistency ( fq ) ; \n av_assert1 ( fq -> queued ) ; \n b = bucket ( fq , 0 ) ; \n av_assert1 ( samples < b -> frame -> nb_samples ) ; \n planar = av_sample_fmt_is_planar ( b -> frame -> format ) ; \n planes = planar ? b -> frame -> channels : 1 ; \n bytes = samples * av_get_bytes_per_sample ( b -> frame -> format ) ; \n if ( ! planar ) \n bytes *= b -> frame -> channels ; \n if ( b -> frame -> pts != AV_NOPTS_VALUE ) \n b -> frame -> pts += av_rescale_q ( samples , av_make_q ( 1 , b -> frame -> sample_rate ) , time_base ) ; \n b -> frame -> nb_samples -= samples ; \n b -> frame -> linesize [ 0 ] -= bytes ; \n for ( i = 0 ; i < planes ; i ++ ) \n b -> frame -> extended_data [ i ] += bytes ; \n for ( i = 0 ; i < planes && i < AV_NUM_DATA_POINTERS ; i ++ ) \n b -> frame -> data [ i ] = b -> frame -> extended_data [ i ] ; \n fq -> total_samples_tail += samples ; \n ff_framequeue_update_peeked ( fq , 0 ) ; \n }", "idx": 7541}
{"project": "FFmpeg", "commit_id": "ca203e9985cd2dcf42a0c0853940850d3a8edf3a", "target": 1, "func": "av_cold int ff_psy_init ( FFPsyContext * ctx , AVCodecContext * avctx , int num_lens , \n const uint8_t * * bands , const int * num_bands , \n int num_groups , const uint8_t * group_map ) \n { \n int i , j , k = 0 ; \n ctx -> avctx = avctx ; \n ctx -> ch = av_mallocz_array ( sizeof ( ctx -> ch [ 0 ] ) , avctx -> channels * 2 ) ; \n ctx -> group = av_mallocz_array ( sizeof ( ctx -> group [ 0 ] ) , num_groups ) ; \n ctx -> bands = av_malloc_array ( sizeof ( ctx -> bands [ 0 ] ) , num_lens ) ; \n ctx -> num_bands = av_malloc_array ( sizeof ( ctx -> num_bands [ 0 ] ) , num_lens ) ; \n if ( ! ctx -> ch || ! ctx -> group || ! ctx -> bands || ! ctx -> num_bands ) { \n ff_psy_end ( ctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n memcpy ( ctx -> bands , bands , sizeof ( ctx -> bands [ 0 ] ) * num_lens ) ; \n memcpy ( ctx -> num_bands , num_bands , sizeof ( ctx -> num_bands [ 0 ] ) * num_lens ) ; \n for ( i = 0 ; i < num_groups ; i ++ ) { \n ctx -> group [ i ] . num_ch = group_map [ i ] + 1 ; \n for ( j = 0 ; j < ctx -> group [ i ] . num_ch * 2 ; j ++ ) \n ctx -> group [ i ] . ch [ j ] = & ctx -> ch [ k ++ ] ; \n } \n switch ( ctx -> avctx -> codec_id ) { \n case AV_CODEC_ID_AAC : \n ctx -> model = & ff_aac_psy_model ; \n break ; \n } \n if ( ctx -> model -> init ) \n return ctx -> model -> init ( ctx ) ; \n return 0 ; \n }", "idx": 7546}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void extract_exponents ( AC3EncodeContext * s ) \n { \n int blk , ch , i ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n uint8_t * exp = block -> exp [ ch ] ; \n int32_t * coef = block -> fixed_coef [ ch ] ; \n int exp_shift = block -> exp_shift [ ch ] ; \n for ( i = 0 ; i < AC3_MAX_COEFS ; i ++ ) { \n int e ; \n int v = abs ( coef [ i ] ) ; \n if ( v == 0 ) \n e = 24 ; \n else { \n e = 23 - av_log2 ( v ) + exp_shift ; \n if ( e >= 24 ) { \n e = 24 ; \n coef [ i ] = 0 ; \n } \n av_assert2 ( e >= 0 ) ; \n } \n exp [ i ] = e ; \n } \n } \n } \n }", "idx": 7549}
{"project": "FFmpeg", "commit_id": "f15c4281dcabeddb61cb6430e0cc1047173292f8", "target": 1, "func": "static av_cold int oggvorbis_encode_close ( AVCodecContext * avctx ) \n { \n OggVorbisContext * s = avctx -> priv_data ; \n vorbis_analysis_wrote ( & s -> vd , 0 ) ; \n vorbis_block_clear ( & s -> vb ) ; \n vorbis_dsp_clear ( & s -> vd ) ; \n vorbis_info_clear ( & s -> vi ) ; \n av_freep ( & avctx -> coded_frame ) ; \n av_freep ( & avctx -> extradata ) ; \n return 0 ; \n }", "idx": 7551}
{"project": "FFmpeg", "commit_id": "65d4cab5627f9c8add3eff73f0d1148a8a95e91c", "target": 0, "func": "AVFilterBufferRef * avfilter_default_get_video_buffer ( AVFilterLink * link , int perms , int w , int h ) \n { \n AVFilterBuffer * pic = av_mallocz ( sizeof ( AVFilterBuffer ) ) ; \n AVFilterBufferRef * ref = av_mallocz ( sizeof ( AVFilterBufferRef ) ) ; \n int i , tempsize ; \n char * buf ; \n ref -> buf = pic ; \n ref -> video = av_mallocz ( sizeof ( AVFilterBufferRefVideoProps ) ) ; \n ref -> video -> w = w ; \n ref -> video -> h = h ; \n ref -> perms = perms | AV_PERM_READ ; \n pic -> refcount = 1 ; \n ref -> format = link -> format ; \n pic -> free = avfilter_default_free_buffer ; \n av_fill_image_linesizes ( pic -> linesize , ref -> format , ref -> video -> w ) ; \n for ( i = 0 ; i < 4 ; i ++ ) \n pic -> linesize [ i ] = FFALIGN ( pic -> linesize [ i ] , 16 ) ; \n tempsize = av_fill_image_pointers ( pic -> data , ref -> format , ref -> video -> h , NULL , pic -> linesize ) ; \n buf = av_malloc ( tempsize + 16 ) ; \n av_fill_image_pointers ( pic -> data , ref -> format , ref -> video -> h , buf , pic -> linesize ) ; \n memcpy ( ref -> data , pic -> data , sizeof ( ref -> data ) ) ; \n memcpy ( ref -> linesize , pic -> linesize , sizeof ( ref -> linesize ) ) ; \n return ref ; \n }", "idx": 7570}
{"project": "FFmpeg", "commit_id": "2ceccf045c295b9a507d6e3be7710c63f51c0529", "target": 0, "func": "static int decode_exponents ( GetBitContext * gbc , int exp_strategy , int ngrps , \n uint8_t absexp , int8_t * dexps ) \n { \n int i , j , grp , group_size ; \n int dexp [ 256 ] ; \n int expacc , prevexp ; \n group_size = exp_strategy + ( exp_strategy == EXP_D45 ) ; \n for ( grp = 0 , i = 0 ; grp < ngrps ; grp ++ ) { \n expacc = get_bits ( gbc , 7 ) ; \n dexp [ i ++ ] = ungroup_3_in_7_bits_tab [ expacc ] [ 0 ] ; \n dexp [ i ++ ] = ungroup_3_in_7_bits_tab [ expacc ] [ 1 ] ; \n dexp [ i ++ ] = ungroup_3_in_7_bits_tab [ expacc ] [ 2 ] ; \n } \n prevexp = absexp ; \n for ( i = 0 , j = 0 ; i < ngrps * 3 ; i ++ ) { \n prevexp += dexp [ i ] - 2 ; \n if ( prevexp < 0 || prevexp > 24 ) \n return -1 ; \n switch ( group_size ) { \n case 4 : dexps [ j ++ ] = prevexp ; \n dexps [ j ++ ] = prevexp ; \n case 2 : dexps [ j ++ ] = prevexp ; \n case 1 : dexps [ j ++ ] = prevexp ; \n } \n } \n return 0 ; \n }", "idx": 7581}
{"project": "FFmpeg", "commit_id": "21b25537fb8f77b098575e90d8b24556451badf3", "target": 1, "func": "int ff_mpeg4_frame_end ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) \n { \n Mpeg4DecContext * ctx = avctx -> priv_data ; \n MpegEncContext * s = & ctx -> m ; \n if ( s -> divx_packed ) { \n int current_pos = s -> gb . buffer == s -> bitstream_buffer ? 0 : ( get_bits_count ( & s -> gb ) >> 3 ) ; \n int startcode_found = 0 ; \n if ( buf_size - current_pos > 7 ) { \n int i ; \n for ( i = current_pos ; i < buf_size - 4 ; i ++ ) \n if ( buf [ i ] == 0 && \n buf [ i + 1 ] == 0 && \n buf [ i + 2 ] == 1 && \n buf [ i + 3 ] == 0xB6 ) { \n startcode_found = ! ( buf [ i + 4 ] & 0x40 ) ; \n break ; \n } \n } \n if ( startcode_found ) { \n av_fast_malloc ( & s -> bitstream_buffer , \n & s -> allocated_bitstream_buffer_size , \n buf_size - current_pos + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! s -> bitstream_buffer ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( s -> bitstream_buffer , buf + current_pos , \n buf_size - current_pos ) ; \n s -> bitstream_buffer_size = buf_size - current_pos ; \n } \n } \n return 0 ; \n }", "idx": 7592}
{"project": "FFmpeg", "commit_id": "34fb84a97d112d85091369e9ef9ce177a05644e9", "target": 1, "func": "av_cold int ff_dcaadpcm_init ( DCAADPCMEncContext * s ) \n { \n if ( ! s ) \n return -1 ; \n s -> private_data = av_malloc ( sizeof ( premultiplied_coeffs ) * DCA_ADPCM_VQCODEBOOK_SZ ) ; \n precalc ( s -> private_data ) ; \n return 0 ; \n }", "idx": 7595}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void null_draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) { }", "idx": 7597}
{"project": "FFmpeg", "commit_id": "76170f537304cc845d6d334d36daa0a0f16efb32", "target": 0, "func": "static int yop_probe ( AVProbeData * probe_packet ) \n { \n if ( AV_RB16 ( probe_packet -> buf ) == AV_RB16 ( \" \" ) && \n probe_packet -> buf [ 6 ] && \n probe_packet -> buf [ 7 ] && \n ! ( probe_packet -> buf [ 8 ] & 1 ) && \n ! ( probe_packet -> buf [ 10 ] & 1 ) ) \n return AVPROBE_SCORE_MAX * 3 / 4 ; \n return 0 ; \n }", "idx": 7600}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "av_cold int ff_vp8_decode_init ( AVCodecContext * avctx ) \n { \n VP8Context * s = avctx -> priv_data ; \n int ret ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n avctx -> internal -> allocate_progress = 1 ; \n ff_videodsp_init ( & s -> vdsp , 8 ) ; \n ff_h264_pred_init ( & s -> hpc , AV_CODEC_ID_VP8 , 8 , 1 ) ; \n ff_vp8dsp_init ( & s -> vp8dsp ) ; \n if ( ( ret = vp8_init_frames ( s ) ) < 0 ) { \n ff_vp8_decode_free ( avctx ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 7601}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_unk6 ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n return -1 ; \n }", "idx": 7602}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int encode_codebook ( CinepakEncContext * s , int * codebook , int size , int chunk_type_yuv , int chunk_type_gray , unsigned char * buf ) \n { \n int x , y , ret , entry_size = s -> pix_fmt == AV_PIX_FMT_YUV420P ? 6 : 4 ; \n ret = write_chunk_header ( buf , s -> pix_fmt == AV_PIX_FMT_YUV420P ? chunk_type_yuv : chunk_type_gray , entry_size * size ) ; \n for ( x = 0 ; x < size ; x ++ ) \n for ( y = 0 ; y < entry_size ; y ++ ) \n buf [ ret ++ ] = codebook [ y + x * entry_size ] ^ ( y >= 4 ? 0x80 : 0 ) ; \n return ret ; \n }", "idx": 7607}
{"project": "FFmpeg", "commit_id": "db374790c75fa4ef947abcb5019fcf21d0b2de85", "target": 1, "func": "static int read_probe ( AVProbeData * pd ) \n { \n if ( pd -> buf [ 0 ] == ' ' && pd -> buf [ 1 ] == ' ' && strlen ( MAGIC ) <= pd -> buf_size - 4 && \n ! memcmp ( pd -> buf + 4 , MAGIC , strlen ( MAGIC ) ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 7620}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static int mlib_YUV2ABGR420_32 ( SwsContext * c , uint8_t * src [ ] , int srcStride [ ] , int srcSliceY , \n int srcSliceH , uint8_t * dst [ ] , int dstStride [ ] ) { \n if ( c -> srcFormat == PIX_FMT_YUV422P ) { \n srcStride [ 1 ] *= 2 ; \n srcStride [ 2 ] *= 2 ; \n } \n assert ( srcStride [ 1 ] == srcStride [ 2 ] ) ; \n mlib_VideoColorYUV2ABGR420 ( dst [ 0 ] + srcSliceY * dstStride [ 0 ] , src [ 0 ] , src [ 1 ] , src [ 2 ] , c -> dstW , \n srcSliceH , dstStride [ 0 ] , srcStride [ 0 ] , srcStride [ 1 ] ) ; \n return srcSliceH ; \n }", "idx": 7626}
{"project": "FFmpeg", "commit_id": "1831274ff1ef69d4b730993e03283430775e2eca", "target": 1, "func": "static int process_video_header_vp6 ( AVFormatContext * s ) \n { \n EaDemuxContext * ea = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n avio_skip ( pb , 8 ) ; \n ea -> nb_frames = avio_rl32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n ea -> time_base . den = avio_rl32 ( pb ) ; \n ea -> time_base . num = avio_rl32 ( pb ) ; \n ea -> video_codec = AV_CODEC_ID_VP6 ; \n return 1 ; ", "idx": 7631}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "void av_thread_message_queue_set_err_recv ( AVThreadMessageQueue * mq , \n int err ) \n { \n #if HAVE_THREADS  \n  \n  pthread_mutex_lock ( & mq -> lock ) ; \n mq -> err_recv = err ; \n pthread_cond_broadcast ( & mq -> cond ) ; \n pthread_mutex_unlock ( & mq -> lock ) ; \n #endif \n }", "idx": 7635}
{"project": "FFmpeg", "commit_id": "d03d38616278bf209e6c860d8f9f564cbc6c1780", "target": 1, "func": "static void update_error_limit ( WavpackFrameContext * ctx ) \n { \n int i , br [ 2 ] , sl [ 2 ] ; \n for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { \n ctx -> ch [ i ] . bitrate_acc += ctx -> ch [ i ] . bitrate_delta ; \n br [ i ] = ctx -> ch [ i ] . bitrate_acc >> 16 ; \n sl [ i ] = LEVEL_DECAY ( ctx -> ch [ i ] . slow_level ) ; \n } \n if ( ctx -> stereo_in && ctx -> hybrid_bitrate ) { \n int balance = ( sl [ 1 ] - sl [ 0 ] + br [ 1 ] + 1 ) >> 1 ; \n if ( balance > br [ 0 ] ) { \n br [ 1 ] = br [ 0 ] << 1 ; \n br [ 0 ] = 0 ; \n } else if ( - balance > br [ 0 ] ) { \n br [ 0 ] <<= 1 ; \n br [ 1 ] = 0 ; \n } else { \n br [ 1 ] = br [ 0 ] + balance ; \n br [ 0 ] = br [ 0 ] - balance ; \n } \n } \n for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { \n if ( ctx -> hybrid_bitrate ) { \n if ( sl [ i ] - br [ i ] > -0x100 ) \n ctx -> ch [ i ] . error_limit = wp_exp2 ( sl [ i ] - br [ i ] + 0x100 ) ; \n else \n ctx -> ch [ i ] . error_limit = 0 ; \n } else { \n ctx -> ch [ i ] . error_limit = wp_exp2 ( br [ i ] ) ; \n } \n } \n }", "idx": 7638}
{"project": "FFmpeg", "commit_id": "d9c2cfd31675a6403ae4ac7c141a8185dadceb12", "target": 1, "func": "int av_bsf_list_parse_str ( const char * str , AVBSFContext * * bsf_lst ) \n { \n AVBSFList * lst ; \n char * bsf_str , * buf , * dup , * saveptr ; \n int ret ; \n if ( ! str ) \n return av_bsf_get_null_filter ( bsf_lst ) ; \n lst = av_bsf_list_alloc ( ) ; \n if ( ! lst ) \n return AVERROR ( ENOMEM ) ; \n if ( ! ( dup = buf = av_strdup ( str ) ) ) \n return AVERROR ( ENOMEM ) ; \n while ( 1 ) { \n bsf_str = av_strtok ( buf , \" \" , & saveptr ) ; \n if ( ! bsf_str ) \n break ; \n ret = bsf_parse_single ( bsf_str , lst ) ; \n if ( ret < 0 ) \n goto end ; \n buf = NULL ; \n } \n ret = av_bsf_list_finalize ( & lst , bsf_lst ) ; \n end : \n if ( ret < 0 ) \n av_bsf_list_free ( & lst ) ; \n av_free ( dup ) ; \n return ret ; \n }", "idx": 7643}
{"project": "FFmpeg", "commit_id": "84be80698227366d970e045001e4b59e4f99f0a1", "target": 0, "func": "void * av_malloc ( size_t size ) \n { \n void * ptr = NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  long diff ; \n #endif \n if ( size > ( max_alloc_size - 32 ) ) \n return NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  ptr = malloc ( size + ALIGN ) ; \n if ( ! ptr ) \n return ptr ; \n diff = ( ( ~ ( long ) ptr ) & ( ALIGN - 1 ) ) + 1 ; \n ptr = ( char * ) ptr + diff ; \n ( ( char * ) ptr ) [ -1 ] = diff ; \n #elif HAVE_POSIX_MEMALIGN  \n  \n  if ( size ) \n if ( posix_memalign ( & ptr , ALIGN , size ) ) \n ptr = NULL ; \n #elif HAVE_ALIGNED_MALLOC  \n  \n  ptr = _aligned_malloc ( size , ALIGN ) ; \n #elif HAVE_MEMALIGN  \n  \n  #ifndef __DJGPP__ \n ptr = memalign ( ALIGN , size ) ; \n #else \n ptr = memalign ( size , ALIGN ) ; \n #endif \n #else \n ptr = malloc ( size ) ; \n #endif \n if ( ! ptr && ! size ) { \n size = 1 ; \n ptr = av_malloc ( 1 ) ; \n } \n #if CONFIG_MEMORY_POISONING  \n  \n  if ( ptr ) \n memset ( ptr , 0x2a , size ) ; \n #endif \n return ptr ; \n }", "idx": 7648}
{"project": "FFmpeg", "commit_id": "55a727383bab266b757b642aabaa2b066c14e7c7", "target": 0, "func": "static int metadata_parse ( FLACContext * s ) \n { \n int i , metadata_last , metadata_type , metadata_size ; \n int initial_pos = get_bits_count ( & s -> gb ) ; \n if ( show_bits_long ( & s -> gb , 32 ) == MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n skip_bits_long ( & s -> gb , 32 ) ; \n do { \n metadata_last = get_bits1 ( & s -> gb ) ; \n metadata_type = get_bits ( & s -> gb , 7 ) ; \n metadata_size = get_bits_long ( & s -> gb , 24 ) ; \n if ( get_bits_count ( & s -> gb ) + 8 * metadata_size > s -> gb . size_in_bits ) { \n skip_bits_long ( & s -> gb , initial_pos - get_bits_count ( & s -> gb ) ) ; \n break ; \n } \n if ( metadata_size ) { \n switch ( metadata_type ) { \n case FLAC_METADATA_TYPE_STREAMINFO : \n if ( ! s -> got_streaminfo ) { \n ff_flac_parse_streaminfo ( s -> avctx , ( FLACStreaminfo * ) s , \n s -> gb . buffer + get_bits_count ( & s -> gb ) / 8 ) ; \n allocate_buffers ( s ) ; \n s -> got_streaminfo = 1 ; \n } \n default : \n for ( i = 0 ; i < metadata_size ; i ++ ) \n skip_bits ( & s -> gb , 8 ) ; \n } \n } \n } while ( ! metadata_last ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 7652}
{"project": "FFmpeg", "commit_id": "53df079a730043cd0aa330c9aba7950034b1424f", "target": 1, "func": "static av_cold int alac_decode_close ( AVCodecContext * avctx ) \n { \n ALACContext * alac = avctx -> priv_data ; \n int chan ; \n for ( chan = 0 ; chan < alac -> numchannels ; chan ++ ) { \n av_freep ( & alac -> predicterror_buffer [ chan ] ) ; \n av_freep ( & alac -> outputsamples_buffer [ chan ] ) ; \n av_freep ( & alac -> wasted_bits_buffer [ chan ] ) ; \n } \n return 0 ; \n }", "idx": 7655}
{"project": "FFmpeg", "commit_id": "6a817ac1e9a0d2b747f71abc5345a54434ceb4a2", "target": 1, "func": "static void setup_window ( AVFormatContext * s ) \n { \n XCBGrabContext * c = s -> priv_data ; \n uint32_t mask = XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK ; \n uint32_t values [ ] = { 1 , \n XCB_EVENT_MASK_EXPOSURE | \n XCB_EVENT_MASK_STRUCTURE_NOTIFY } ; \n xcb_rectangle_t rect = { 0 , 0 , c -> width , c -> height } ; \n c -> window = xcb_generate_id ( c -> conn ) ; \n xcb_create_window ( c -> conn , XCB_COPY_FROM_PARENT , \n c -> window , \n c -> screen -> root , \n c -> x - c -> region_border , \n c -> y - c -> region_border , \n c -> width + c -> region_border * 2 , \n c -> height + c -> region_border * 2 , \n 0 , \n XCB_WINDOW_CLASS_INPUT_OUTPUT , \n XCB_COPY_FROM_PARENT , \n mask , values ) ; \n #if CONFIG_LIBXCB_SHAPE  \n  \n  xcb_shape_rectangles ( c -> conn , XCB_SHAPE_SO_SUBTRACT , \n XCB_SHAPE_SK_BOUNDING , XCB_CLIP_ORDERING_UNSORTED , \n c -> window , \n c -> region_border , c -> region_border , \n 1 , & rect ) ; \n #endif \n xcb_map_window ( c -> conn , c -> window ) ; \n draw_rectangle ( s ) ; \n }", "idx": 7673}
{"project": "FFmpeg", "commit_id": "e823e7367754dd23de16a141c06471735a488f0d", "target": 0, "func": "SwsVector * sws_getGaussianVec ( double variance , double quality ) \n { \n const int length = ( int ) ( variance * quality + 0.5 ) | 1 ; \n int i ; \n double middle = ( length - 1 ) * 0.5 ; \n SwsVector * vec = sws_allocVec ( length ) ; \n if ( ! vec ) \n return NULL ; \n for ( i = 0 ; i < length ; i ++ ) { \n double dist = i - middle ; \n vec -> coeff [ i ] = exp ( - dist * dist / ( 2 * variance * variance ) ) / \n sqrt ( 2 * variance * M_PI ) ; \n } \n sws_normalizeVec ( vec , 1.0 ) ; \n return vec ; \n }", "idx": 7680}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_h_loop_filter_c ( uint8_t * dest , uint8_t * src , int stride ) { \n int i , j , xy , yz ; \n int res ; \n for ( i = 1 ; i < 7 ; i ++ ) { \n for ( j = 0 ; j < 8 ; j ++ ) { \n xy = j * stride + i ; \n yz = j * 8 + i ; \n res = ( int ) src [ yz - 1 ] + ( ( int ) ( src [ yz ] ) * 2 ) + ( int ) src [ yz + 1 ] ; \n res += 2 ; \n res >>= 2 ; \n dest [ xy ] = ( uint8_t ) res ; \n } \n } \n }", "idx": 7681}
{"project": "FFmpeg", "commit_id": "c9da676de43d778d62efb1cfa75544d770736d67", "target": 1, "func": "ogg_read_header ( AVFormatContext * s , AVFormatParameters * ap )  \n { \n struct ogg * ogg = s -> priv_data ; \n ogg -> curidx = -1 ; \n if ( ogg_get_headers ( s ) < 0 ) { \n return -1 ; \n } \n ogg_get_length ( s ) ; \n return 0 ; \n }", "idx": 7684}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static int apng_read_close ( AVFormatContext * s ) \n { \n APNGDemuxContext * ctx = s -> priv_data ; \n av_freep ( & ctx -> extra_data ) ; \n ctx -> extra_data_size = 0 ; \n return 0 ; \n }", "idx": 7686}
{"project": "FFmpeg", "commit_id": "301a24de52f5baa09beff0958327af2c2a7005dc", "target": 1, "func": "static int dnxhd_write_header ( AVCodecContext * avctx , uint8_t * buf ) \n { \n DNXHDEncContext * ctx = avctx -> priv_data ; \n const uint8_t header_prefix [ 5 ] = { 0x00 , 0x00 , 0x02 , 0x80 , 0x01 } ; \n memcpy ( buf , header_prefix , 5 ) ; \n buf [ 5 ] = ctx -> interlaced ? ctx -> cur_field + 2 : 0x01 ; \n buf [ 6 ] = 0x80 ; \n buf [ 7 ] = 0xa0 ; \n AV_WB16 ( buf + 0x18 , avctx -> height ) ; \n AV_WB16 ( buf + 0x1a , avctx -> width ) ; \n AV_WB16 ( buf + 0x1d , avctx -> height ) ; \n buf [ 0x21 ] = 0x38 ; \n buf [ 0x22 ] = 0x88 + ( ctx -> frame . interlaced_frame << 2 ) ; \n AV_WB32 ( buf + 0x28 , ctx -> cid ) ; \n buf [ 0x2c ] = ctx -> interlaced ? 0 : 0x80 ; \n buf [ 0x5f ] = 0x01 ; \n buf [ 0x167 ] = 0x02 ; \n AV_WB16 ( buf + 0x16a , ctx -> m . mb_height * 4 + 4 ) ; \n buf [ 0x16d ] = ctx -> m . mb_height ; \n buf [ 0x16f ] = 0x10 ; \n ctx -> msip = buf + 0x170 ; \n return 0 ; \n }", "idx": 7688}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel16_mc01_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_16w_msa ( src - ( stride * 2 ) , stride , dst , stride , 16 , 0 ) ; \n }", "idx": 7725}
{"project": "FFmpeg", "commit_id": "97f8c6e14753b94c1f6a96fe354a125bbfdea2cb", "target": 0, "func": "int ff_thread_can_start_frame ( AVCodecContext * avctx ) \n { \n PerThreadContext * p = avctx -> thread_opaque ; \n if ( ( avctx -> active_thread_type & FF_THREAD_FRAME ) && p -> state != STATE_SETTING_UP && \n ( avctx -> codec -> update_thread_context || ( ! avctx -> thread_safe_callbacks && \n avctx -> get_buffer != avcodec_default_get_buffer ) ) ) { \n return 0 ; \n } \n return 1 ; \n }", "idx": 7726}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "unsigned int av_codec_get_tag ( const AVCodecTag * tags [ 4 ] , enum CodecID id ) \n { \n int i ; \n for ( i = 0 ; i < 4 && tags [ i ] ; i ++ ) { \n int tag = codec_get_tag ( tags [ i ] , id ) ; \n if ( tag ) return tag ; \n } \n return 0 ; \n }", "idx": 7728}
{"project": "FFmpeg", "commit_id": "46db10ed0e04872eb9b003129f8395005c935ca4", "target": 0, "func": "const char * avcodec_get_pix_fmt_name ( enum PixelFormat pix_fmt ) \n { \n if ( pix_fmt < 0 || pix_fmt >= PIX_FMT_NB ) \n return NULL ; \n else \n return av_pix_fmt_descriptors [ pix_fmt ] . name ; \n }", "idx": 7730}
{"project": "FFmpeg", "commit_id": "6481a36010d8f7d834676f17ba555d0a3815c760", "target": 0, "func": "static int decode_residual_block ( AVSContext * h , GetBitContext * gb , \n const struct dec_2dvlc * r , int esc_golomb_order , \n int qp , uint8_t * dst , int stride ) { \n int i , level_code , esc_code , level , run , mask ; \n DCTELEM level_buf [ 65 ] ; \n uint8_t run_buf [ 65 ] ; \n DCTELEM * block = h -> block ; \n for ( i = 0 ; i < 65 ; i ++ ) { \n level_code = get_ue_code ( gb , r -> golomb_order ) ; \n if ( level_code >= ESCAPE_CODE ) { \n run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 ; \n esc_code = get_ue_code ( gb , esc_golomb_order ) ; \n level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ) ; \n while ( level > r -> inc_limit ) \n r ++ ; \n mask = - ( level_code & 1 ) ; \n level = ( level ^ mask ) - mask ; \n } else { \n level = r -> rltab [ level_code ] [ 0 ] ; \n if ( ! level ) \n break ; \n run = r -> rltab [ level_code ] [ 1 ] ; \n r += r -> rltab [ level_code ] [ 2 ] ; \n } \n level_buf [ i ] = level ; \n run_buf [ i ] = run ; \n } \n if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , \n ff_cavs_dequant_shift [ qp ] , i ) ) \n return -1 ; \n h -> cdsp . cavs_idct8_add ( dst , block , stride ) ; \n h -> s . dsp . clear_block ( block ) ; \n return 0 ; \n }", "idx": 7731}
{"project": "FFmpeg", "commit_id": "330deb75923675224fb9aed311d3d6ce3ec52420", "target": 1, "func": "static void free_duplicate_context ( MpegEncContext * s ) { \n if ( s == NULL ) return ; \n av_freep ( & s -> allocated_edge_emu_buffer ) ; s -> edge_emu_buffer = NULL ; \n av_freep ( & s -> me . scratchpad ) ; \n s -> me . temp = \n s -> rd_scratchpad = \n s -> b_scratchpad = \n s -> obmc_scratchpad = NULL ; \n av_freep ( & s -> dct_error_sum ) ; \n av_freep ( & s -> me . map ) ; \n av_freep ( & s -> me . score_map ) ; \n av_freep ( & s -> blocks ) ; \n av_freep ( & s -> ac_val_base ) ; \n s -> block = NULL ; \n }", "idx": 7733}
{"project": "FFmpeg", "commit_id": "501158c682ceb7546d71209374dac406a7f43238", "target": 1, "func": "static av_cold int peak_init_writer ( AVFormatContext * s ) \n { \n WAVMuxContext * wav = s -> priv_data ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n if ( enc -> codec_id != AV_CODEC_ID_PCM_S8 && \n enc -> codec_id != AV_CODEC_ID_PCM_S16LE && \n enc -> codec_id != AV_CODEC_ID_PCM_U8 && \n enc -> codec_id != AV_CODEC_ID_PCM_U16LE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n s -> streams [ 0 ] -> codec -> codec ? s -> streams [ 0 ] -> codec -> codec -> name : \" \" ) ; \n return -1 ; \n } \n wav -> peak_bps = av_get_bits_per_sample ( enc -> codec_id ) / 8 ; \n if ( wav -> peak_bps == 1 && wav -> peak_format == PEAK_FORMAT_UINT16 ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n wav -> peak_maxpos = av_mallocz ( enc -> channels * sizeof ( * wav -> peak_maxpos ) ) ; \n if ( ! wav -> peak_maxpos ) \n goto nomem ; \n wav -> peak_maxneg = av_mallocz ( enc -> channels * sizeof ( * wav -> peak_maxneg ) ) ; \n if ( ! wav -> peak_maxneg ) \n goto nomem ; \n wav -> peak_output = av_malloc ( PEAK_BUFFER_SIZE ) ; \n if ( ! wav -> peak_output ) \n goto nomem ; \n wav -> peak_outbuf_size = PEAK_BUFFER_SIZE ; \n return 0 ; \n nomem : \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n peak_free_buffers ( s ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 7737}
{"project": "FFmpeg", "commit_id": "74942685cb457c01937686892878403a409baf27", "target": 0, "func": "static int url_connect ( struct variant * var , AVDictionary * opts ) \n { \n AVDictionary * tmp = NULL ; \n int ret ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n av_opt_set_dict ( var -> input , & tmp ) ; \n if ( ( ret = ffurl_connect ( var -> input , NULL ) ) < 0 ) { \n ffurl_close ( var -> input ) ; \n var -> input = NULL ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 7746}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xwd_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 7757}
{"project": "FFmpeg", "commit_id": "1d22d269f54cc7e44f778bb6ffee96a172eb07a1", "target": 1, "func": "static void mxf_read_pixel_layout ( AVIOContext * pb , MXFDescriptor * descriptor ) \n { \n int code , value , ofs = 0 ; \n char layout [ 16 ] = { 0 } ; \n do { \n code = avio_r8 ( pb ) ; \n value = avio_r8 ( pb ) ; \n av_dlog ( NULL , \" \\n \" , code ) ; \n if ( ofs <= 14 ) { \n layout [ ofs ++ ] = code ; \n layout [ ofs ++ ] = value ; \n } \n } while ( code != 0 ) ; \n ff_mxf_decode_pixel_layout ( layout , & descriptor -> pix_fmt ) ; \n }", "idx": 7769}
{"project": "FFmpeg", "commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter ( uint8_t * src , \n const int step , \n const ptrdiff_t stride , \n const int filter_p1 , \n const int filter_q1 , \n const int alpha , \n const int beta , \n const int lim_p0q0 , \n const int lim_q1 , \n const int lim_p1 ) \n { \n const uint8_t * cm = ff_crop_tab + MAX_NEG_CROP ; \n int i , t , u , diff ; \n for ( i = 0 ; i < 4 ; i ++ , src += stride ) { \n int diff_p1p0 = src [ -2 * step ] - src [ -1 * step ] ; \n int diff_q1q0 = src [ 1 * step ] - src [ 0 * step ] ; \n int diff_p1p2 = src [ -2 * step ] - src [ -3 * step ] ; \n int diff_q1q2 = src [ 1 * step ] - src [ 2 * step ] ; \n t = src [ 0 * step ] - src [ -1 * step ] ; \n if ( ! t ) \n continue ; \n u = ( alpha * FFABS ( t ) ) >> 7 ; \n if ( u > 3 - ( filter_p1 && filter_q1 ) ) \n continue ; \n t <<= 2 ; \n if ( filter_p1 && filter_q1 ) \n t += src [ -2 * step ] - src [ 1 * step ] ; \n diff = CLIP_SYMM ( ( t + 4 ) >> 3 , lim_p0q0 ) ; \n src [ -1 * step ] = cm [ src [ -1 * step ] + diff ] ; \n src [ 0 * step ] = cm [ src [ 0 * step ] - diff ] ; \n if ( filter_p1 && FFABS ( diff_p1p2 ) <= beta ) { \n t = ( diff_p1p0 + diff_p1p2 - diff ) >> 1 ; \n src [ -2 * step ] = cm [ src [ -2 * step ] - CLIP_SYMM ( t , lim_p1 ) ] ; \n } \n if ( filter_q1 && FFABS ( diff_q1q2 ) <= beta ) { \n t = ( diff_q1q0 + diff_q1q2 + diff ) >> 1 ; \n src [ 1 * step ] = cm [ src [ 1 * step ] - CLIP_SYMM ( t , lim_q1 ) ] ; \n } \n } \n }", "idx": 7771}
{"project": "FFmpeg", "commit_id": "4dfbc7a7559ccab666a8fd39de4224eb4b02c768", "target": 1, "func": "static int msnwc_tcp_read_packet ( AVFormatContext * ctx , AVPacket * pkt ) \n { \n AVIOContext * pb = ctx -> pb ; \n uint16_t keyframe ; \n uint32_t size , timestamp ; \n avio_skip ( pb , 1 ) ; \n avio_skip ( pb , 2 ) ; \n avio_skip ( pb , 2 ) ; \n keyframe = avio_rl16 ( pb ) ; \n size = avio_rl32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n avio_skip ( pb , 4 ) ; \n timestamp = avio_rl32 ( pb ) ; \n if ( ! size || av_get_packet ( pb , pkt , size ) != size ) \n return -1 ; \n avio_skip ( pb , 1 ) ; \n pkt -> pts = timestamp ; \n pkt -> dts = timestamp ; \n pkt -> stream_index = 0 ; \n if ( keyframe & 1 ) \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n return HEADER_SIZE + size ; \n }", "idx": 7774}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int nut_probe ( AVProbeData * p ) { \n if ( p -> buf_size >= ID_LENGTH && ! memcmp ( p -> buf , ID_STRING , ID_LENGTH ) ) return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 7784}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_mbaff_edgev ( H264Context * h , uint8_t * pix , int stride , const int16_t bS [ 7 ] , int bsi , int qp , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 7849}
{"project": "FFmpeg", "commit_id": "94350ab986dfce1c93fa720baf28b548c60a9879", "target": 0, "func": "double av_expr_eval ( AVExpr * e , const double * const_values , void * opaque ) \n { \n Parser p ; \n p . const_values = const_values ; \n p . opaque = opaque ; \n return eval_expr ( & p , e ) ; \n }", "idx": 7851}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_init_ls ( AVCodecContext * ctx ) \n { \n ctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! ctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n ctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n ctx -> coded_frame -> key_frame = 1 ; \n if ( ctx -> pix_fmt != AV_PIX_FMT_GRAY8 && \n ctx -> pix_fmt != AV_PIX_FMT_GRAY16 && \n ctx -> pix_fmt != AV_PIX_FMT_RGB24 && \n ctx -> pix_fmt != AV_PIX_FMT_BGR24 ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 7876}
{"project": "FFmpeg", "commit_id": "af19f78f2fe2b969104d4419efd25fdee90a2814", "target": 0, "func": "void dsputil_init_mmi ( void ) \n { \n clear_blocks = clear_blocks_mmi ; \n put_pixels_tab [ 1 ] [ 0 ] = put_pixels8_mmi ; \n put_no_rnd_pixels_tab [ 1 ] [ 0 ] = put_pixels8_mmi ; \n put_pixels_tab [ 0 ] [ 0 ] = put_pixels16_mmi ; \n put_no_rnd_pixels_tab [ 0 ] [ 0 ] = put_pixels16_mmi ; \n get_pixels = get_pixels_mmi ; \n }", "idx": 7879}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr15 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = bswap_16 ( ( ( uint16_t * ) palette ) [ src [ i ] ] ) ; \n }", "idx": 7883}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int config ( struct vf_instance * vf , \n int width , int height , int d_width , int d_height , \n unsigned int flags , unsigned int outfmt ) \n { \n return ff_vf_next_config ( vf , width * vf -> priv -> scalew , \n height / vf -> priv -> scaleh - vf -> priv -> skipline , d_width , d_height , flags , IMGFMT_YV12 ) ; \n }", "idx": 7886}
{"project": "FFmpeg", "commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "target": 1, "func": "void av_register_input_format ( AVInputFormat * format ) \n { \n AVInputFormat * * p = last_iformat ; \n format -> next = NULL ; \n while ( * p || avpriv_atomic_ptr_cas ( ( void * volatile * ) p , NULL , format ) ) \n p = & ( * p ) -> next ; \n last_iformat = & format -> next ; \n }", "idx": 7887}
{"project": "FFmpeg", "commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "target": 1, "func": "static int dnxhd_decode_row ( AVCodecContext * avctx , void * data , \n int rownb , int threadnb ) \n { \n const DNXHDContext * ctx = avctx -> priv_data ; \n uint32_t offset = ctx -> mb_scan_index [ rownb ] ; \n RowContext * row = ctx -> rows + threadnb ; \n int x ; \n row -> last_dc [ 0 ] = \n row -> last_dc [ 1 ] = \n row -> last_dc [ 2 ] = 1 << ( ctx -> bit_depth + 2 ) ; \n init_get_bits ( & row -> gb , ctx -> buf + offset , ( ctx -> buf_size - offset ) << 3 ) ; \n for ( x = 0 ; x < ctx -> mb_width ; x ++ ) { \n dnxhd_decode_macroblock ( ctx , row , data , x , rownb ) ; \n } \n return 0 ; \n }", "idx": 7888}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static void pool_release_buffer ( void * opaque , uint8_t * data ) \n { \n BufferPoolEntry * buf = opaque ; \n AVBufferPool * pool = buf -> pool ; \n add_to_pool ( buf ) ; \n if ( ! avpriv_atomic_int_add_and_fetch ( & pool -> refcount , -1 ) ) \n buffer_pool_free ( pool ) ; \n }", "idx": 7895}
{"project": "FFmpeg", "commit_id": "7fb92be7e50ea4ba5712804326c6814ae02dd190", "target": 1, "func": "static void qtrle_decode_8bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned char pi1 , pi2 , pi3 , pi4 ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n while ( lines_to_change -- ) { \n CHECK_STREAM_PTR ( 2 ) ; \n pixel_ptr = row_ptr + ( 4 * ( s -> buf [ stream_ptr ++ ] - 1 ) ) ; \n while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != -1 ) { \n if ( rle_code == 0 ) { \n CHECK_STREAM_PTR ( 1 ) ; \n pixel_ptr += ( 4 * ( s -> buf [ stream_ptr ++ ] - 1 ) ) ; \n } else if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 4 ) ; \n pi1 = s -> buf [ stream_ptr ++ ] ; \n pi2 = s -> buf [ stream_ptr ++ ] ; \n pi3 = s -> buf [ stream_ptr ++ ] ; \n pi4 = s -> buf [ stream_ptr ++ ] ; \n CHECK_PIXEL_PTR ( rle_code * 4 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = pi1 ; \n rgb [ pixel_ptr ++ ] = pi2 ; \n rgb [ pixel_ptr ++ ] = pi3 ; \n rgb [ pixel_ptr ++ ] = pi4 ; \n } \n } else { \n rle_code *= 4 ; \n CHECK_STREAM_PTR ( rle_code ) ; \n CHECK_PIXEL_PTR ( rle_code ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n } \n } \n } \n row_ptr += row_inc ; \n } \n }", "idx": 7901}
{"project": "FFmpeg", "commit_id": "26fc6ffec45c954cd8ca46342ac75cd90bcc7e02", "target": 1, "func": "static inline void libopenjpeg_copyto16 ( AVFrame * picture , opj_image_t * image ) { \n int * comp_data ; \n uint16_t * img_ptr ; \n int index , x , y ; \n int adjust [ 4 ] ; \n for ( x = 0 ; x < image -> numcomps ; x ++ ) \n adjust [ x ] = FFMAX ( FFMIN ( av_pix_fmt_desc_get ( picture -> format ) -> comp [ x ] . depth_minus1 + 1 - image -> comps [ x ] . prec , 8 ) , 0 ) ; \n for ( index = 0 ; index < image -> numcomps ; index ++ ) { \n comp_data = image -> comps [ index ] . data ; \n for ( y = 0 ; y < image -> comps [ index ] . h ; y ++ ) { \n img_ptr = ( uint16_t * ) ( picture -> data [ index ] + y * picture -> linesize [ index ] ) ; \n for ( x = 0 ; x < image -> comps [ index ] . w ; x ++ ) { \n * img_ptr = 0x8000 * image -> comps [ index ] . sgnd + ( * comp_data << adjust [ index ] ) ; \n img_ptr ++ ; \n comp_data ++ ; \n } \n } \n } \n }", "idx": 7902}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_idx1 ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AVIContext * avi = s -> priv_data ; \n int64_t idx_chunk ; \n int i ; \n char tag [ 5 ] ; \n if ( pb -> seekable ) { \n AVIStream * avist ; \n AVIIentry * ie = 0 , * tie ; \n int empty , stream_id = -1 ; \n idx_chunk = ff_start_tag ( pb , \" \" ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n avist = s -> streams [ i ] -> priv_data ; \n avist -> entry = 0 ; \n } \n do { \n empty = 1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n avist = s -> streams [ i ] -> priv_data ; \n if ( avist -> indexes . entry <= avist -> entry ) \n continue ; \n tie = avi_get_ientry ( & avist -> indexes , avist -> entry ) ; \n if ( empty || tie -> pos < ie -> pos ) { \n ie = tie ; \n stream_id = i ; \n } \n empty = 0 ; \n } \n if ( ! empty ) { \n avist = s -> streams [ stream_id ] -> priv_data ; \n avi_stream2fourcc ( tag , stream_id , \n s -> streams [ stream_id ] -> codecpar -> codec_type ) ; \n ffio_wfourcc ( pb , tag ) ; \n avio_wl32 ( pb , ie -> flags ) ; \n avio_wl32 ( pb , ie -> pos ) ; \n avio_wl32 ( pb , ie -> len ) ; \n avist -> entry ++ ; \n } \n } while ( ! empty ) ; \n ff_end_tag ( pb , idx_chunk ) ; \n avi_write_counters ( s , avi -> riff_id ) ; \n } \n return 0 ; \n }", "idx": 7911}
{"project": "FFmpeg", "commit_id": "a2b8dde65947bfabf42269e124ef83ecf9c5974a", "target": 0, "func": "static int idcin_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n IdcinContext * s = avctx -> priv_data ; \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n AVFrame * frame = data ; \n int ret ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n return ret ; \n if ( idcin_decode_vlcs ( s , frame ) ) \n return AVERROR_INVALIDDATA ; \n if ( pal ) { \n frame -> palette_has_changed = 1 ; \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n } \n memcpy ( frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; \n * got_frame = 1 ; \n return buf_size ; \n }", "idx": 7914}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_mid_16w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_mid_8w_msa ( src , src_stride , dst , dst_stride , height ) ; \n src += 8 ; \n dst += 8 ; \n } \n }", "idx": 7922}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "AVFilterBufferRef * avfilter_get_audio_buffer ( AVFilterLink * link , int perms , \n enum AVSampleFormat sample_fmt , int size , \n int64_t channel_layout , int planar ) \n { \n AVFilterBufferRef * ret = NULL ; \n if ( link -> dstpad -> get_audio_buffer ) \n ret = link -> dstpad -> get_audio_buffer ( link , perms , sample_fmt , size , channel_layout , planar ) ; \n if ( ! ret ) \n ret = avfilter_default_get_audio_buffer ( link , perms , sample_fmt , size , channel_layout , planar ) ; \n if ( ret ) \n ret -> type = AVMEDIA_TYPE_AUDIO ; \n return ret ; \n }", "idx": 7924}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void shift_history ( DCAEncContext * c , const int32_t * input ) \n { \n int k , ch ; \n for ( k = 0 ; k < 512 ; k ++ ) \n for ( ch = 0 ; ch < c -> channels ; ch ++ ) { \n const int chi = c -> channel_order_tab [ ch ] ; \n c -> history [ k ] [ ch ] = input [ k * c -> channels + chi ] ; \n } \n }", "idx": 7946}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "static void init_vlcs ( ) \n { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_vlc ( & dc_lum_vlc , DC_VLC_BITS , 12 , \n vlc_dc_lum_bits , 1 , 1 , \n vlc_dc_lum_code , 2 , 2 ) ; \n init_vlc ( & dc_chroma_vlc , DC_VLC_BITS , 12 , \n vlc_dc_chroma_bits , 1 , 1 , \n vlc_dc_chroma_code , 2 , 2 ) ; \n init_vlc ( & mv_vlc , MV_VLC_BITS , 17 , \n & mbMotionVectorTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbMotionVectorTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mbincr_vlc , MBINCR_VLC_BITS , 36 , \n & mbAddrIncrTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbAddrIncrTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_pat_vlc , MB_PAT_VLC_BITS , 63 , \n & mbPatTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbPatTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_ptype_vlc , MB_PTYPE_VLC_BITS , 7 , \n & table_mb_ptype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_ptype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_btype_vlc , MB_BTYPE_VLC_BITS , 11 , \n & table_mb_btype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_btype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_rl ( & rl_mpeg1 ) ; \n init_rl ( & rl_mpeg2 ) ; \n init_2d_vlc_rl ( & rl_mpeg1 ) ; \n init_2d_vlc_rl ( & rl_mpeg2 ) ; \n } \n }", "idx": 7947}
{"project": "FFmpeg", "commit_id": "baab248c499a7689aefb5f2e9c004338deb08d74", "target": 1, "func": "int ff_socket ( int af , int type , int proto ) \n { \n int fd ; \n #ifdef SOCK_CLOEXEC \n fd = socket ( af , type | SOCK_CLOEXEC , proto ) ; \n if ( fd == -1 && errno == EINVAL )  \n #endif \n { \n fd = socket ( af , type , proto ) ; \n #if HAVE_FCNTL  \n  \n  if ( fd != -1 ) \n fcntl ( fd , F_SETFD , FD_CLOEXEC ) ; \n #endif \n } \n return fd ; \n }", "idx": 7951}
{"project": "FFmpeg", "commit_id": "bdab2421a540efc0593c87e6d247427a0a6e16bc", "target": 1, "func": "static int dfa_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 || AV_RL32 ( p -> buf ) != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 7957}
{"project": "FFmpeg", "commit_id": "5c8467a07c654f6acd9e8e3a436cd5b746bb2f44", "target": 1, "func": "static int ivf_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n if ( pb -> seekable ) { \n IVFEncContext * ctx = s -> priv_data ; \n size_t end = avio_tell ( pb ) ; \n avio_seek ( pb , 24 , SEEK_SET ) ; \n avio_wl64 ( pb , ctx -> frame_cnt * ctx -> sum_delta_pts / ( ctx -> frame_cnt - 1 ) ) ; \n avio_seek ( pb , end , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 7981}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int mov_read_stsz ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = ( MOVStreamContext * ) st -> priv_data ; \n int entries , i ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; get_byte ( pb ) ; \n sc -> sample_size = get_be32 ( pb ) ; \n entries = get_be32 ( pb ) ; \n sc -> sample_count = entries ; \n #ifdef DEBUG \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , sc -> sample_size , sc -> sample_count ) ; \n #endif \n if ( sc -> sample_size ) \n return 0 ; \n sc -> sample_sizes = ( long * ) av_malloc ( entries * sizeof ( long ) ) ; \n if ( ! sc -> sample_sizes ) \n return -1 ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> sample_sizes [ i ] = get_be32 ( pb ) ; \n #ifdef DEBUG \n #endif \n } \n return 0 ; \n }", "idx": 7985}
{"project": "FFmpeg", "commit_id": "499b82f604616a6ce7de4bd8e15f4698702c1e6a", "target": 1, "func": "static int vdadec_decode ( AVCodecContext * avctx , \n void * data , int * got_frame , AVPacket * avpkt ) \n { \n VDADecoderContext * ctx = avctx -> priv_data ; \n AVFrame * pic = data ; \n int ret ; \n ret = ff_h264_decoder . decode ( avctx , data , got_frame , avpkt ) ; \n if ( * got_frame ) { \n AVBufferRef * buffer = pic -> buf [ 0 ] ; \n VDABufferContext * context = av_buffer_get_opaque ( buffer ) ; \n CVPixelBufferRef cv_buffer = ( CVPixelBufferRef ) pic -> data [ 3 ] ; \n CVPixelBufferLockBaseAddress ( cv_buffer , 0 ) ; \n context -> cv_buffer = cv_buffer ; \n pic -> format = ctx -> pix_fmt ; \n if ( CVPixelBufferIsPlanar ( cv_buffer ) ) { \n int i , count = CVPixelBufferGetPlaneCount ( cv_buffer ) ; \n av_assert0 ( count < 4 ) ; \n for ( i = 0 ; i < count ; i ++ ) { \n pic -> data [ i ] = CVPixelBufferGetBaseAddressOfPlane ( cv_buffer , i ) ; \n pic -> linesize [ i ] = CVPixelBufferGetBytesPerRowOfPlane ( cv_buffer , i ) ; \n } \n } else { \n pic -> data [ 0 ] = CVPixelBufferGetBaseAddress ( cv_buffer ) ; \n pic -> linesize [ 0 ] = CVPixelBufferGetBytesPerRow ( cv_buffer ) ; \n } \n } \n avctx -> pix_fmt = ctx -> pix_fmt ; \n return ret ; \n }", "idx": 7988}
{"project": "FFmpeg", "commit_id": "f61bece684d9685b07895508e6c1c733b5564ccf", "target": 0, "func": "av_cold void ff_dsputil_init_ppc ( DSPContext * c , AVCodecContext * avctx ) \n { \n const int high_bit_depth = avctx -> bits_per_raw_sample > 8 ; \n if ( ! high_bit_depth ) { \n switch ( check_dcbzl_effect ( ) ) { \n case 32 : \n c -> clear_blocks = clear_blocks_dcbz32_ppc ; \n break ; \n case 128 : \n c -> clear_blocks = clear_blocks_dcbz128_ppc ; \n break ; \n default : \n break ; \n } \n } \n #if HAVE_ALTIVEC  \n  \n  if ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) { \n ff_dsputil_init_altivec ( c , avctx ) ; \n ff_int_init_altivec ( c , avctx ) ; \n c -> gmc1 = ff_gmc1_altivec ; \n #if CONFIG_ENCODERS  \n  \n  if ( avctx -> bits_per_raw_sample <= 8 && \n ( avctx -> dct_algo == FF_DCT_AUTO || \n avctx -> dct_algo == FF_DCT_ALTIVEC ) ) { \n c -> fdct = ff_fdct_altivec ; \n } \n #endif \n if ( avctx -> bits_per_raw_sample <= 8 ) { \n if ( ( avctx -> idct_algo == FF_IDCT_AUTO ) || \n ( avctx -> idct_algo == FF_IDCT_ALTIVEC ) ) { \n c -> idct_put = ff_idct_put_altivec ; \n c -> idct_add = ff_idct_add_altivec ; \n c -> idct_permutation_type = FF_TRANSPOSE_IDCT_PERM ; \n } \n } \n } \n #endif \n }", "idx": 7994}
{"project": "FFmpeg", "commit_id": "294bb6cbd7bdc52233ddfa8f88f99aaf0d64d183", "target": 0, "func": "static HEVCFrame * find_ref_idx ( HEVCContext * s , int poc ) \n { \n int i ; \n int LtMask = ( 1 << s -> sps -> log2_max_poc_lsb ) - 1 ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> DPB ) ; i ++ ) { \n HEVCFrame * ref = & s -> DPB [ i ] ; \n if ( ref -> frame -> buf [ 0 ] && ( ref -> sequence == s -> seq_decode ) ) { \n if ( ( ref -> poc & LtMask ) == poc ) \n return ref ; \n } \n } \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> DPB ) ; i ++ ) { \n HEVCFrame * ref = & s -> DPB [ i ] ; \n if ( ref -> frame -> buf [ 0 ] && ref -> sequence == s -> seq_decode ) { \n if ( ref -> poc == poc || ( ref -> poc & LtMask ) == poc ) \n return ref ; \n } \n } \n av_log ( s -> avctx , AV_LOG_ERROR , \n \" \\n \" , poc ) ; \n return NULL ; \n }", "idx": 8005}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void calc_slice_sizes ( VC2EncContext * s ) \n { \n int slice_x , slice_y ; \n SliceArgs * enc_args = s -> slice_args ; \n for ( slice_y = 0 ; slice_y < s -> num_y ; slice_y ++ ) { \n for ( slice_x = 0 ; slice_x < s -> num_x ; slice_x ++ ) { \n SliceArgs * args = & enc_args [ s -> num_x * slice_y + slice_x ] ; \n args -> ctx = s ; \n args -> x = slice_x ; \n args -> y = slice_y ; \n args -> bits_ceil = s -> slice_max_bytes << 3 ; \n args -> bits_floor = s -> slice_min_bytes << 3 ; \n memset ( args -> cache , 0 , MAX_QUANT_INDEX * sizeof ( * args -> cache ) ) ; \n } \n } \n s -> avctx -> execute ( s -> avctx , rate_control , enc_args , NULL , s -> num_x * s -> num_y , \n sizeof ( SliceArgs ) ) ; \n }", "idx": 8023}
{"project": "FFmpeg", "commit_id": "49d2d1c35cc0438747dd8ef111163cb341f8f9fe", "target": 1, "func": "static inline void mpeg4_encode_dc ( PutBitContext * s , int level , int n ) \n { \n #if 1  \n  \n  \n  level += 256 ; \n if ( n < 4 ) { \n put_bits ( s , uni_DCtab_lum_len [ level ] , uni_DCtab_lum_bits [ level ] ) ; \n } else { \n put_bits ( s , uni_DCtab_chrom_len [ level ] , uni_DCtab_chrom_bits [ level ] ) ; \n } \n #else \n int size , v ; \n size = 0 ; \n v = abs ( level ) ; \n while ( v ) { \n v >>= 1 ; \n size ++ ; \n } \n if ( n < 4 ) { \n put_bits ( & s -> pb , DCtab_lum [ size ] [ 1 ] , DCtab_lum [ size ] [ 0 ] ) ; \n } else { \n put_bits ( & s -> pb , DCtab_chrom [ size ] [ 1 ] , DCtab_chrom [ size ] [ 0 ] ) ; \n } \n if ( size > 0 ) { \n if ( level < 0 ) \n level = ( - level ) ^ ( ( 1 << size ) - 1 ) ; \n put_bits ( & s -> pb , size , level ) ; \n if ( size > 8 ) \n put_bits ( & s -> pb , 1 , 1 ) ; \n } \n #endif \n }", "idx": 8027}
{"project": "FFmpeg", "commit_id": "87513d654546a99f8ddb045ca4fa5d33778a617e", "target": 1, "func": "static void to_meta_with_crop ( AVCodecContext * avctx , AVFrame * p , int * dest ) \n { \n int blockx , blocky , x , y ; \n int luma = 0 ; \n int height = FFMIN ( avctx -> height , C64YRES ) ; \n int width = FFMIN ( avctx -> width , C64XRES ) ; \n uint8_t * src = p -> data [ 0 ] ; \n for ( blocky = 0 ; blocky < C64YRES ; blocky += 8 ) { \n for ( blockx = 0 ; blockx < C64XRES ; blockx += 8 ) { \n for ( y = blocky ; y < blocky + 8 && y < C64YRES ; y ++ ) { \n for ( x = blockx ; x < blockx + 8 && x < C64XRES ; x += 2 ) { \n if ( x < width && y < height ) { \n luma = ( src [ ( x + 0 + y * p -> linesize [ 0 ] ) ] + \n src [ ( x + 1 + y * p -> linesize [ 0 ] ) ] ) / 2 ; \n dest [ 0 ] = luma ; \n } \n dest ++ ; \n } \n } \n } \n } \n }", "idx": 8039}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "int av_reduce ( int * dst_num , int * dst_den , int64_t num , int64_t den , int64_t max ) { \n AVRational a0 = { 0 , 1 } , a1 = { 1 , 0 } ; \n int sign = ( num < 0 ) ^ ( den < 0 ) ; \n int64_t gcd = av_gcd ( FFABS ( num ) , FFABS ( den ) ) ; \n if ( gcd ) { \n num = FFABS ( num ) / gcd ; \n den = FFABS ( den ) / gcd ; \n } \n if ( num <= max && den <= max ) { \n a1 = ( AVRational ) { num , den } ; \n den = 0 ; \n } \n while ( den ) { \n uint64_t x = num / den ; \n int64_t next_den = num - den * x ; \n int64_t a2n = x * a1 . num + a0 . num ; \n int64_t a2d = x * a1 . den + a0 . den ; \n if ( a2n > max || a2d > max ) { \n if ( a1 . num ) x = ( max - a0 . num ) / a1 . num ; \n if ( a1 . den ) x = FFMIN ( x , ( max - a0 . den ) / a1 . den ) ; \n if ( den * ( 2 * x * a1 . den + a0 . den ) > num * a1 . den ) \n a1 = ( AVRational ) { x * a1 . num + a0 . num , x * a1 . den + a0 . den } ; \n break ; \n } \n a0 = a1 ; \n a1 = ( AVRational ) { a2n , a2d } ; \n num = den ; \n den = next_den ; \n } \n assert ( av_gcd ( a1 . num , a1 . den ) <= 1U ) ; \n * dst_num = sign ? - a1 . num : a1 . num ; \n * dst_den = a1 . den ; \n return den == 0 ; \n }", "idx": 8057}
{"project": "FFmpeg", "commit_id": "64f6570c6e2c5a0344383e89c7897809f0c6e1f1", "target": 0, "func": "static void decode_sigpass ( Jpeg2000T1Context * t1 , int width , int height , \n int bpno , int bandno ) \n { \n int mask = 3 << ( bpno - 1 ) , y0 , x , y ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG_NB ) \n && ! ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) ) { \n if ( ff_mqc_decode ( & t1 -> mqc , \n t1 -> mqc . cx_states + \n ff_jpeg2000_getsigctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , \n bandno ) ) ) { \n int xorbit , ctxno = ff_jpeg2000_getsgnctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , \n & xorbit ) ; \n t1 -> data [ y ] [ x ] = \n ( ff_mqc_decode ( & t1 -> mqc , \n t1 -> mqc . cx_states + ctxno ) ^ xorbit ) \n ? - mask : mask ; \n ff_jpeg2000_set_significance ( t1 , x , y , \n t1 -> data [ y ] [ x ] < 0 ) ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_VIS ; \n } \n }", "idx": 8064}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static uint8_t get_tlm ( Jpeg2000DecoderContext * s , int n ) \n { \n uint8_t Stlm , ST , SP , tile_tlm , i ; \n bytestream_get_byte ( & s -> buf ) ; \n Stlm = bytestream_get_byte ( & s -> buf ) ; \n ST = ( Stlm >> 4 ) & 0x03 ; \n SP = ( Stlm >> 6 ) & 0x01 ; \n tile_tlm = ( n - 4 ) / ( ( SP + 1 ) * 2 + ST ) ; \n for ( i = 0 ; i < tile_tlm ; i ++ ) { \n switch ( ST ) { \n case 0 : \n break ; \n case 1 : \n bytestream_get_byte ( & s -> buf ) ; \n break ; \n case 2 : \n bytestream_get_be16 ( & s -> buf ) ; \n break ; \n case 3 : \n bytestream_get_be32 ( & s -> buf ) ; \n break ; \n } \n if ( SP == 0 ) { \n bytestream_get_be16 ( & s -> buf ) ; \n } else { \n bytestream_get_be32 ( & s -> buf ) ; \n } \n } \n return 0 ; \n }", "idx": 8066}
{"project": "FFmpeg", "commit_id": "20fa3fb93d0f3d3eab2b1f63a03168f492fae047", "target": 0, "func": "static int get_cluster_duration ( MOVTrack * track , int cluster_idx ) \n { \n int64_t next_dts ; \n if ( cluster_idx >= track -> entry ) \n return 0 ; \n if ( cluster_idx + 1 == track -> entry ) \n next_dts = track -> track_duration + track -> start_dts ; \n else \n next_dts = track -> cluster [ cluster_idx + 1 ] . dts ; \n return next_dts - track -> cluster [ cluster_idx ] . dts ; \n }", "idx": 8074}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int jp2_find_codestream ( Jpeg2000DecoderContext * s ) \n { \n int32_t atom_size ; \n int found_codestream = 0 , search_range = 10 ; \n s -> buf += 12 ; \n while ( ! found_codestream && search_range ) { \n atom_size = AV_RB32 ( s -> buf ) ; \n if ( AV_RB32 ( s -> buf + 4 ) == JP2_CODESTREAM ) { \n found_codestream = 1 ; \n s -> buf += 8 ; \n } else { \n s -> buf += atom_size ; \n search_range -- ; \n } \n } \n if ( found_codestream ) \n return 1 ; \n return 0 ; \n }", "idx": 8094}
{"project": "FFmpeg", "commit_id": "042ef4b720f5d3321d9b7eeeb2067c671d5aeefd", "target": 1, "func": "static inline int get_chroma_qp ( int chroma_qp_index_offset , int qscale ) { \n return chroma_qp [ av_clip ( qscale + chroma_qp_index_offset , 0 , 51 ) ] ; \n }", "idx": 8097}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int raw_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size , bps ; \n size = RAW_SAMPLES * s -> streams [ 0 ] -> codec -> block_align ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n bps = av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) ; \n assert ( bps ) ; \n pkt -> dts = \n pkt -> pts = pkt -> pos * 8 / ( bps * s -> streams [ 0 ] -> codec -> channels ) ; \n return ret ; \n }", "idx": 8108}
{"project": "FFmpeg", "commit_id": "8bb376cf6b4ab8645daedb8becaa7163656436a4", "target": 0, "func": "static int cmp_func_names ( const char * a , const char * b ) \n { \n int ascii_diff , digit_diff ; \n for ( ; ! ( ascii_diff = * a - * b ) && * a ; a ++ , b ++ ) ; \n for ( ; av_isdigit ( * a ) && av_isdigit ( * b ) ; a ++ , b ++ ) ; \n return ( digit_diff = av_isdigit ( * a ) - av_isdigit ( * b ) ) ? digit_diff : ascii_diff ; \n }", "idx": 8113}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_doubles_metadata ( int count , \n const char * name , const char * sep , \n TiffContext * s ) \n { \n char * ap ; \n int i ; \n double * dp ; \n if ( count >= INT_MAX / sizeof ( int64_t ) || count <= 0 ) \n return AVERROR_INVALIDDATA ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) ) \n return AVERROR_INVALIDDATA ; \n dp = av_malloc ( count * sizeof ( double ) ) ; \n if ( ! dp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n dp [ i ] = tget_double ( & s -> gb , s -> le ) ; \n ap = doubles2str ( dp , count , sep ) ; \n av_freep ( & dp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( avpriv_frame_get_metadatap ( & s -> picture ) , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 8118}
{"project": "FFmpeg", "commit_id": "b99ca863506f0630514921b740b78364de67a3ff", "target": 1, "func": "static av_cold int che_configure ( AACContext * ac , \n enum ChannelPosition che_pos , \n int type , int id , int * channels ) \n { \n if ( * channels >= MAX_CHANNELS ) \n return AVERROR_INVALIDDATA ; \n if ( che_pos ) { \n if ( ! ac -> che [ type ] [ id ] ) { \n if ( ! ( ac -> che [ type ] [ id ] = av_mallocz ( sizeof ( ChannelElement ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n ff_aac_sbr_ctx_init ( ac , & ac -> che [ type ] [ id ] -> sbr ) ; \n } \n if ( type != TYPE_CCE ) { \n ac -> output_element [ ( * channels ) ++ ] = & ac -> che [ type ] [ id ] -> ch [ 0 ] ; \n if ( type == TYPE_CPE || \n ( type == TYPE_SCE && ac -> oc [ 1 ] . m4ac . ps == 1 ) ) { \n ac -> output_element [ ( * channels ) ++ ] = & ac -> che [ type ] [ id ] -> ch [ 1 ] ; \n } \n } \n } else { \n if ( ac -> che [ type ] [ id ] ) \n ff_aac_sbr_ctx_close ( & ac -> che [ type ] [ id ] -> sbr ) ; \n av_freep ( & ac -> che [ type ] [ id ] ) ; \n } \n return 0 ; \n }", "idx": 8119}
{"project": "FFmpeg", "commit_id": "44cde38c8acbef7d5250e6d1b52b1020871e093b", "target": 0, "func": "static int cbs_read_ue_golomb ( CodedBitstreamContext * ctx , BitstreamContext * bc , \n const char * name , uint32_t * write_to , \n uint32_t range_min , uint32_t range_max ) \n { \n uint32_t value ; \n int position ; \n if ( ctx -> trace_enable ) { \n char bits [ 65 ] ; \n unsigned int k ; \n int i , j ; \n position = bitstream_tell ( bc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n k = bitstream_read_bit ( bc ) ; \n bits [ i ] = k ? ' ' : ' ' ; \n if ( k ) \n break ; \n } \n if ( i >= 32 ) { \n av_log ( ctx -> log_ctx , AV_LOG_ERROR , \" \" \n \" \" \n \" \\n \" , name ) ; \n return AVERROR_INVALIDDATA ; \n } \n value = 1 ; \n for ( j = 0 ; j < i ; j ++ ) { \n k = bitstream_read_bit ( bc ) ; \n bits [ i + j + 1 ] = k ? ' ' : ' ' ; \n value = value << 1 | k ; \n } \n bits [ i + j + 1 ] = 0 ; \n -- value ; \n ff_cbs_trace_syntax_element ( ctx , position , name , bits , value ) ; \n } else { \n value = get_ue_golomb_long ( bc ) ; \n } \n if ( value < range_min || value > range_max ) { \n av_log ( ctx -> log_ctx , AV_LOG_ERROR , \" \" \n \" \" PRIu32 \" \" PRIu32 \" \" PRIu32 \" \\n \" , \n name , value , range_min , range_max ) ; \n return AVERROR_INVALIDDATA ; \n } \n * write_to = value ; \n return 0 ; \n }", "idx": 8122}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8torgb32 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 3 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 0 ] ; \n #else \n dst [ 0 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 0 ] ; \n #endif \n dst += 4 ; \n } \n }", "idx": 8125}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avdevice_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 8126}
{"project": "FFmpeg", "commit_id": "3cff53369acdb3bc0695dd6d5df51457fdaa16ce", "target": 1, "func": "int ff_amf_tag_size ( const uint8_t * data , const uint8_t * data_end ) \n { \n const uint8_t * base = data ; \n if ( data >= data_end ) \n return -1 ; \n switch ( * data ++ ) { \n case AMF_DATA_TYPE_NUMBER : return 9 ; \n case AMF_DATA_TYPE_BOOL : return 2 ; \n case AMF_DATA_TYPE_STRING : return 3 + AV_RB16 ( data ) ; \n case AMF_DATA_TYPE_LONG_STRING : return 5 + AV_RB32 ( data ) ; \n case AMF_DATA_TYPE_NULL : return 1 ; \n case AMF_DATA_TYPE_ARRAY : \n data += 4 ; \n case AMF_DATA_TYPE_OBJECT : \n for ( ; ; ) { \n int size = bytestream_get_be16 ( & data ) ; \n int t ; \n if ( ! size ) { \n data ++ ; \n break ; \n } \n if ( data + size >= data_end || data + size < data ) \n return -1 ; \n data += size ; \n t = ff_amf_tag_size ( data , data_end ) ; \n if ( t < 0 || data + t >= data_end ) \n return -1 ; \n data += t ; \n } \n return data - base ; \n case AMF_DATA_TYPE_OBJECT_END : return 1 ; \n default : return -1 ; \n } \n }", "idx": 8127}
{"project": "FFmpeg", "commit_id": "e494f44c051d7dccc038a603ab22532b87dd1705", "target": 0, "func": "static unsigned decode_skip_count ( GetBitContext * gb ) \n { \n unsigned value ; \n if ( ! can_safely_read ( gb , 1 ) ) \n return -1 ; \n value = get_bits1 ( gb ) ; \n if ( ! value ) \n return value ; \n value += get_bits ( gb , 3 ) ; \n if ( value != ( 1 + ( ( 1 << 3 ) - 1 ) ) ) \n return value ; \n value += get_bits ( gb , 7 ) ; \n if ( value != ( 1 + ( ( 1 << 3 ) - 1 ) ) + ( ( 1 << 7 ) - 1 ) ) \n return value ; \n return value + get_bits ( gb , 12 ) ; \n }", "idx": 8132}
{"project": "FFmpeg", "commit_id": "c4be288fdbe1993110f1abd28ea57587cb2bc221", "target": 0, "func": "static int check_init_output_file ( OutputFile * of , int file_index ) \n { \n int ret , i ; \n for ( i = 0 ; i < of -> ctx -> nb_streams ; i ++ ) { \n OutputStream * ost = output_streams [ of -> ost_index + i ] ; \n if ( ! ost -> initialized ) \n return 0 ; \n } \n of -> ctx -> interrupt_callback = int_cb ; \n ret = avformat_write_header ( of -> ctx , & of -> opts ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n file_index , av_err2str ( ret ) ) ; \n return ret ; \n } \n of -> header_written = 1 ; \n av_dump_format ( of -> ctx , file_index , of -> ctx -> filename , 1 ) ; \n if ( sdp_filename || want_sdp ) \n print_sdp ( ) ; \n for ( i = 0 ; i < of -> ctx -> nb_streams ; i ++ ) { \n OutputStream * ost = output_streams [ of -> ost_index + i ] ; \n if ( ! av_fifo_size ( ost -> muxing_queue ) ) \n ost -> mux_timebase = ost -> st -> time_base ; \n while ( av_fifo_size ( ost -> muxing_queue ) ) { \n AVPacket pkt ; \n av_fifo_generic_read ( ost -> muxing_queue , & pkt , sizeof ( pkt ) , NULL ) ; \n write_packet ( of , & pkt , ost ) ; \n } \n } \n return 0 ; \n }", "idx": 8143}
{"project": "FFmpeg", "commit_id": "60ea0a5236ceac03b8d3ab3b73bda04d04c17273", "target": 1, "func": "static int read_uncompressed_sgi ( unsigned char * out_buf , SgiState * s ) \n { \n int x , y , z ; \n unsigned int offset = s -> height * s -> width * s -> bytes_per_channel ; \n GetByteContext gp [ 4 ] ; \n uint8_t * out_end ; \n if ( offset * s -> depth > bytestream2_get_bytes_left ( & s -> g ) ) \n return AVERROR_INVALIDDATA ; \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n gp [ z ] = s -> g ; \n bytestream2_skip ( & gp [ z ] , z * offset ) ; \n } \n for ( y = s -> height - 1 ; y >= 0 ; y -- ) { \n out_end = out_buf + ( y * s -> linesize ) ; \n if ( s -> bytes_per_channel == 1 ) { \n for ( x = s -> width ; x > 0 ; x -- ) { \n bytestream2_get_bufferu ( & gp [ z ] , out_end , s -> depth ) ; \n out_end += s -> depth ; \n } \n } else { \n uint16_t * out16 = ( uint16_t * ) out_end ; \n for ( x = s -> width ; x > 0 ; x -- ) \n for ( z = 0 ; z < s -> depth ; z ++ ) \n * out16 ++ = bytestream2_get_ne16u ( & gp [ z ] ) ; \n } \n } \n return 0 ; \n }", "idx": 8152}
{"project": "FFmpeg", "commit_id": "0e58865d6e86bbb664d92311c0f81c65e0213c35", "target": 0, "func": "static av_always_inline int vc1_filter_line ( uint8_t * src , int stride , int pq ) { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int a0 = ( 2 * ( src [ -2 * stride ] - src [ 1 * stride ] ) - 5 * ( src [ -1 * stride ] - src [ 0 * stride ] ) + 4 ) >> 3 ; \n int a0_sign = a0 >> 31 ; \n a0 = ( a0 ^ a0_sign ) - a0_sign ; \n if ( a0 < pq ) { \n int a1 = FFABS ( ( 2 * ( src [ -4 * stride ] - src [ -1 * stride ] ) - 5 * ( src [ -3 * stride ] - src [ -2 * stride ] ) + 4 ) >> 3 ) ; \n int a2 = FFABS ( ( 2 * ( src [ 0 * stride ] - src [ 3 * stride ] ) - 5 * ( src [ 1 * stride ] - src [ 2 * stride ] ) + 4 ) >> 3 ) ; \n if ( a1 < a0 || a2 < a0 ) { \n int clip = src [ -1 * stride ] - src [ 0 * stride ] ; \n int clip_sign = clip >> 31 ; \n clip = ( ( clip ^ clip_sign ) - clip_sign ) >> 1 ; \n if ( clip ) { \n int a3 = FFMIN ( a1 , a2 ) ; \n int d = 5 * ( a3 - a0 ) ; \n int d_sign = ( d >> 31 ) ; \n d = ( ( d ^ d_sign ) - d_sign ) >> 3 ; \n d_sign ^= a0_sign ; \n if ( d_sign ^ clip_sign ) \n d = 0 ; \n else { \n d = FFMIN ( d , clip ) ; \n d = ( d ^ d_sign ) - d_sign ; \n src [ -1 * stride ] = cm [ src [ -1 * stride ] - d ] ; \n src [ 0 * stride ] = cm [ src [ 0 * stride ] + d ] ; \n } \n return 1 ; \n } \n } \n } \n return 0 ; \n }", "idx": 8165}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void subband_transform ( DCAEncContext * c , const int32_t * input ) \n { \n int ch , subs , i , k , j ; \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n int32_t hist [ 512 ] ; \n int hist_start = 0 ; \n const int chi = c -> channel_order_tab [ ch ] ; \n for ( i = 0 ; i < 512 ; i ++ ) \n hist [ i ] = c -> history [ i ] [ ch ] ; \n for ( subs = 0 ; subs < SUBBAND_SAMPLES ; subs ++ ) { \n int32_t accum [ 64 ] ; \n int32_t resp ; \n int band ; \n for ( i = 0 ; i < 64 ; i ++ ) \n accum [ i ] = 0 ; \n for ( k = 0 , i = hist_start , j = 0 ; \n i < 512 ; k = ( k + 1 ) & 63 , i ++ , j ++ ) \n accum [ k ] += mul32 ( hist [ i ] , c -> band_interpolation [ j ] ) ; \n for ( i = 0 ; i < hist_start ; k = ( k + 1 ) & 63 , i ++ , j ++ ) \n accum [ k ] += mul32 ( hist [ i ] , c -> band_interpolation [ j ] ) ; \n for ( k = 16 ; k < 32 ; k ++ ) \n accum [ k ] = accum [ k ] - accum [ 31 - k ] ; \n for ( k = 32 ; k < 48 ; k ++ ) \n accum [ k ] = accum [ k ] + accum [ 95 - k ] ; \n for ( band = 0 ; band < 32 ; band ++ ) { \n resp = 0 ; \n for ( i = 16 ; i < 48 ; i ++ ) { \n int s = ( 2 * band + 1 ) * ( 2 * ( i + 16 ) + 1 ) ; \n resp += mul32 ( accum [ i ] , cos_t ( s << 3 ) ) >> 3 ; \n } \n c -> subband [ subs ] [ band ] [ ch ] = ( ( band + 1 ) & 2 ) ? - resp : resp ; \n } \n for ( i = 0 ; i < 32 ; i ++ ) \n hist [ i + hist_start ] = input [ ( subs * 32 + i ) * c -> channels + chi ] ; \n hist_start = ( hist_start + 32 ) & 511 ; \n } \n } \n }", "idx": 8185}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static void pcx_palette ( const uint8_t * * src , uint32_t * dst , unsigned int pallen ) { \n unsigned int i ; \n for ( i = 0 ; i < pallen ; i ++ ) \n * dst ++ = 0xFF000000 | bytestream_get_be24 ( src ) ; \n if ( pallen < 256 ) \n memset ( dst , 0 , ( 256 - pallen ) * sizeof ( * dst ) ) ; \n }", "idx": 8187}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_sequence ( MXFSequence * sequence , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x0202 : \n sequence -> duration = get_be64 ( pb ) ; \n break ; \n case 0x0201 : \n get_buffer ( pb , sequence -> data_definition_ul , 16 ) ; \n break ; \n case 0x1001 : \n sequence -> structural_components_count = get_be32 ( pb ) ; \n if ( sequence -> structural_components_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n sequence -> structural_components_refs = av_malloc ( sequence -> structural_components_count * sizeof ( UID ) ) ; \n if ( ! sequence -> structural_components_refs ) \n return -1 ; \n url_fskip ( pb , 4 ) ; \n get_buffer ( pb , ( uint8_t * ) sequence -> structural_components_refs , sequence -> structural_components_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 8191}
{"project": "FFmpeg", "commit_id": "ae2f1d4624dc372aa86f85aeb47f820f48a4af38", "target": 1, "func": "static int common_init ( AVCodecContext * avctx ) { \n HYuvContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> flags = avctx -> flags ; \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n assert ( s -> width > 0 && s -> height > 0 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n s -> temp [ i ] = av_malloc ( avctx -> width + 16 ) ; \n } \n return 0 ; \n }", "idx": 8192}
{"project": "FFmpeg", "commit_id": "23f3f92361a3db53e595de33cfd5440f53bee220", "target": 1, "func": "static int decode_dc_progressive ( MJpegDecodeContext * s , int16_t * block , \n int component , int dc_index , \n int16_t * quant_matrix , int Al ) \n { \n int val ; \n s -> bdsp . clear_block ( block ) ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xfffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n val = ( val * ( quant_matrix [ 0 ] << Al ) ) + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n return 0 ; \n }", "idx": 8194}
{"project": "FFmpeg", "commit_id": "3ba35a346cd2ee86fff83a0d0534e8a2265984fd", "target": 1, "func": "static int config_input ( AVFilterLink * inlink ) \n { \n HQDN3DContext * s = inlink -> dst -> priv ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; \n int i ; \n s -> hsub = desc -> log2_chroma_w ; \n s -> vsub = desc -> log2_chroma_h ; \n s -> depth = desc -> comp [ 0 ] . depth_minus1 + 1 ; \n s -> line = av_malloc ( inlink -> w * sizeof ( * s -> line ) ) ; \n if ( ! s -> line ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n s -> coefs [ i ] = precalc_coefs ( s -> strength [ i ] , s -> depth ) ; \n if ( ! s -> coefs [ i ] ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( ARCH_X86 ) \n ff_hqdn3d_init_x86 ( s ) ; \n return 0 ; \n }", "idx": 8195}
{"project": "FFmpeg", "commit_id": "285485ac5f896cc450e0183daa41a8ee63d17076", "target": 0, "func": "static int64_t mkv_write_cues ( AVIOContext * pb , mkv_cues * cues , mkv_track * tracks , int num_tracks ) \n { \n ebml_master cues_element ; \n int64_t currentpos ; \n int i , j ; \n currentpos = avio_tell ( pb ) ; \n cues_element = start_ebml_master ( pb , MATROSKA_ID_CUES , 0 ) ; \n for ( i = 0 ; i < cues -> num_entries ; i ++ ) { \n ebml_master cuepoint , track_positions ; \n mkv_cuepoint * entry = & cues -> entries [ i ] ; \n uint64_t pts = entry -> pts ; \n cuepoint = start_ebml_master ( pb , MATROSKA_ID_POINTENTRY , MAX_CUEPOINT_SIZE ( num_tracks ) ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETIME , pts ) ; \n for ( j = 0 ; j < num_tracks ; j ++ ) \n tracks [ j ] . has_cue = 0 ; \n for ( j = 0 ; j < cues -> num_entries - i && entry [ j ] . pts == pts ; j ++ ) { \n if ( tracks [ entry [ j ] . tracknum ] . has_cue ) \n continue ; \n tracks [ entry [ j ] . tracknum ] . has_cue = 1 ; \n track_positions = start_ebml_master ( pb , MATROSKA_ID_CUETRACKPOSITION , MAX_CUETRACKPOS_SIZE ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUETRACK , entry [ j ] . tracknum ) ; \n put_ebml_uint ( pb , MATROSKA_ID_CUECLUSTERPOSITION , entry [ j ] . cluster_pos ) ; \n end_ebml_master ( pb , track_positions ) ; \n } \n i += j - 1 ; \n end_ebml_master ( pb , cuepoint ) ; \n } \n end_ebml_master ( pb , cues_element ) ; \n return currentpos ; \n }", "idx": 8198}
{"project": "FFmpeg", "commit_id": "b9f92093a10217b14d923220aaa186f41a0cf555", "target": 1, "func": "static void decode_plane ( FFV1Context * s , uint8_t * src , \n int w , int h , int stride , int plane_index , \n int pixel_stride ) \n { \n int x , y ; \n int16_t * sample [ 2 ] ; \n sample [ 0 ] = s -> sample_buffer + 3 ; \n sample [ 1 ] = s -> sample_buffer + w + 6 + 3 ; \n s -> run_index = 0 ; \n memset ( s -> sample_buffer , 0 , 2 * ( w + 6 ) * sizeof ( * s -> sample_buffer ) ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n int16_t * temp = sample [ 0 ] ; \n sample [ 0 ] = sample [ 1 ] ; \n sample [ 1 ] = temp ; \n sample [ 1 ] [ -1 ] = sample [ 0 ] [ 0 ] ; \n sample [ 0 ] [ w ] = sample [ 0 ] [ w - 1 ] ; \n if ( s -> avctx -> bits_per_raw_sample <= 8 ) { \n decode_line ( s , w , sample , plane_index , 8 ) ; \n for ( x = 0 ; x < w ; x ++ ) \n src [ x * pixel_stride + stride * y ] = sample [ 1 ] [ x ] ; \n } else { \n decode_line ( s , w , sample , plane_index , s -> avctx -> bits_per_raw_sample ) ; \n if ( s -> packed_at_lsb ) { \n for ( x = 0 ; x < w ; x ++ ) { \n ( ( uint16_t * ) ( src + stride * y ) ) [ x * pixel_stride ] = sample [ 1 ] [ x ] ; \n } \n } else { \n for ( x = 0 ; x < w ; x ++ ) { \n ( ( uint16_t * ) ( src + stride * y ) ) [ x * pixel_stride ] = sample [ 1 ] [ x ] << ( 16 - s -> avctx -> bits_per_raw_sample ) | ( ( uint16_t * * ) sample ) [ 1 ] [ x ] >> ( 2 * s -> avctx -> bits_per_raw_sample - 16 ) ; \n } \n } \n } \n } \n }", "idx": 8200}
{"project": "FFmpeg", "commit_id": "502d6c0a234b10f65acb0a203aedf14de70dc555", "target": 1, "func": "static int wav_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n int size ; \n unsigned int tag ; \n ByteIOContext * pb = s -> pb ; \n AVStream * st ; \n WAVContext * wav = s -> priv_data ; \n tag = get_le32 ( pb ) ; \n if ( tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return -1 ; \n get_le32 ( pb ) ; \n tag = get_le32 ( pb ) ; \n if ( tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return -1 ; \n size = find_tag ( pb , MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ; \n if ( size < 0 ) \n return -1 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n get_wav_header ( pb , st -> codec , size ) ; \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n av_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n size = find_tag ( pb , MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ; \n if ( size < 0 ) \n return -1 ; \n wav -> data_end = url_ftell ( pb ) + size ; \n return 0 ; \n }", "idx": 8202}
{"project": "FFmpeg", "commit_id": "a0b468f5db92daf1854c49d920169ed39e9cfb1b", "target": 1, "func": "int av_new_packet ( AVPacket * pkt , int size ) \n { \n uint8_t * data ; \n if ( ( unsigned ) size > ( unsigned ) size + FF_INPUT_BUFFER_PADDING_SIZE ) \n return AVERROR ( ENOMEM ) ; \n data = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! data ) \n return AVERROR ( ENOMEM ) ; \n memset ( data + size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = data ; \n pkt -> size = size ; \n pkt -> destruct = av_destruct_packet ; \n return 0 ; \n }", "idx": 8205}
{"project": "FFmpeg", "commit_id": "a91394f4de63ae5c2e21c548045b79393ca7fea1", "target": 1, "func": "static av_cold int dirac_decode_init ( AVCodecContext * avctx ) \n { \n DiracContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> frame_number = -1 ; \n if ( avctx -> flags & CODEC_FLAG_EMU_EDGE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n ff_dsputil_init ( & s -> dsp , avctx ) ; \n ff_diracdsp_init ( & s -> diracdsp ) ; \n for ( i = 0 ; i < MAX_FRAMES ; i ++ ) \n s -> all_frames [ i ] . avframe = av_frame_alloc ( ) ; \n return 0 ; \n }", "idx": 8207}
{"project": "FFmpeg", "commit_id": "5ed5e90f2ae299cbec66996860d794771a85fee8", "target": 1, "func": "static int color_distance ( uint32_t a , uint32_t b ) \n { \n int r = 0 , d , i ; \n for ( i = 0 ; i < 32 ; i += 8 ) { \n d = ( ( a >> i ) & 0xFF ) - ( ( b >> i ) & 0xFF ) ; \n r += d * d ; \n } \n return r ; \n }", "idx": 8213}
{"project": "FFmpeg", "commit_id": "7c36ee216f1e668e2c2af1573bd9dbbb2a501f48", "target": 1, "func": "static void sbr_qmf_deint_bfly_c ( INTFLOAT * v , const INTFLOAT * src0 , const INTFLOAT * src1 ) \n { \n int i ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n v [ i ] = AAC_SRA_R ( ( src0 [ i ] - src1 [ 63 - i ] ) , 5 ) ; \n v [ 127 - i ] = AAC_SRA_R ( ( src0 [ i ] + src1 [ 63 - i ] ) , 5 ) ; \n } \n }", "idx": 8219}
{"project": "FFmpeg", "commit_id": "9321e93502810e4a3fcaf87bac156dba2fe3b477", "target": 1, "func": "static void gif_copy_img_rect ( const uint32_t * src , uint32_t * dst , \n int linesize , int l , int t , int w , int h ) \n { \n const int y_start = t * linesize ; \n const uint32_t * src_px , * src_pr , \n * src_py = src + y_start , \n * dst_py = dst + y_start ; \n const uint32_t * src_pb = src_py + ( t + h ) * linesize ; \n uint32_t * dst_px ; \n for ( ; src_py < src_pb ; src_py += linesize , dst_py += linesize ) { \n src_px = src_py + l ; \n dst_px = ( uint32_t * ) dst_py + l ; \n src_pr = src_px + w ; \n for ( ; src_px < src_pr ; src_px ++ , dst_px ++ ) \n * dst_px = * src_px ; \n } \n }", "idx": 8220}
{"project": "FFmpeg", "commit_id": "7bc155163ec08a0302526d7e19d08c8053f932f0", "target": 1, "func": "static int expand_rle_row ( SgiState * s , uint8_t * out_buf , \n uint8_t * out_end , int pixelstride ) \n { \n unsigned char pixel , count ; \n unsigned char * orig = out_buf ; \n while ( 1 ) { \n if ( bytestream2_get_bytes_left ( & s -> g ) < 1 ) \n return AVERROR_INVALIDDATA ; \n pixel = bytestream2_get_byteu ( & s -> g ) ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) { \n return ( out_buf - orig ) / pixelstride ; \n } \n if ( out_buf + pixelstride * count >= out_end ) return -1 ; \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n * out_buf = bytestream2_get_byte ( & s -> g ) ; \n out_buf += pixelstride ; \n } \n } else { \n pixel = bytestream2_get_byte ( & s -> g ) ; \n while ( count -- ) { \n * out_buf = pixel ; \n out_buf += pixelstride ; \n } \n } \n } \n }", "idx": 8224}
{"project": "FFmpeg", "commit_id": "8bc80f8b24cb6f03ad209ce546ae594904c8b353", "target": 1, "func": "static void new_connection ( int server_fd , int is_rtsp ) \n { \n struct sockaddr_in from_addr ; \n int fd , len ; \n HTTPContext * c = NULL ; \n len = sizeof ( from_addr ) ; \n fd = accept ( server_fd , ( struct sockaddr * ) & from_addr , \n & len ) ; \n if ( fd < 0 ) \n return ; \n fcntl ( fd , F_SETFL , O_NONBLOCK ) ; \n if ( nb_connections >= nb_max_connections ) \n goto fail ; \n c = av_mallocz ( sizeof ( HTTPContext ) ) ; \n if ( ! c ) \n goto fail ; \n c -> next = first_http_ctx ; \n first_http_ctx = c ; \n c -> fd = fd ; \n c -> poll_entry = NULL ; \n c -> from_addr = from_addr ; \n c -> buffer_size = IOBUFFER_INIT_SIZE ; \n c -> buffer = av_malloc ( c -> buffer_size ) ; \n if ( ! c -> buffer ) \n goto fail ; \n nb_connections ++ ; \n start_wait_request ( c , is_rtsp ) ; \n return ; \n fail : \n if ( c ) { \n av_free ( c -> buffer ) ; \n av_free ( c ) ; \n } \n close ( fd ) ; \n }", "idx": 8225}
{"project": "FFmpeg", "commit_id": "620b452a118a6a2345addb4e1d8abf36ad8d1bab", "target": 1, "func": "static void apply_independent_coupling_fixed ( AACContext * ac , \n SingleChannelElement * target , \n ChannelElement * cce , int index ) \n { \n int i , c , shift , round , tmp ; \n const int gain = cce -> coup . gain [ index ] [ 0 ] ; \n const int * src = cce -> ch [ 0 ] . ret ; \n int * dest = target -> ret ; \n const int len = 1024 << ( ac -> oc [ 1 ] . m4ac . sbr == 1 ) ; \n c = cce_scale_fixed [ gain & 7 ] ; \n shift = ( gain - 1024 ) >> 3 ; \n if ( shift < 0 ) { \n shift = - shift ; \n round = 1 << ( shift - 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n tmp = ( int ) ( ( ( int64_t ) src [ i ] * c + ( int64_t ) 0x1000000000 ) >> 37 ) ; \n dest [ i ] += ( tmp + round ) >> shift ; \n } \n } \n else { \n for ( i = 0 ; i < len ; i ++ ) { \n tmp = ( int ) ( ( ( int64_t ) src [ i ] * c + ( int64_t ) 0x1000000000 ) >> 37 ) ; \n dest [ i ] += tmp << shift ; \n } \n } \n }", "idx": 8227}
{"project": "FFmpeg", "commit_id": "a96b39de622592cb595bf20ae009ed415b98cde9", "target": 1, "func": "static int64_t get_pts ( const char * buf , int * duration ) \n { \n int i , hour , min , sec , hsec ; \n int he , me , se , mse ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n int64_t start , end ; \n if ( sscanf ( buf , \" \" , \n & hour , & min , & sec , & hsec , & he , & me , & se , & mse ) == 8 ) { \n min += 60 * hour ; \n sec += 60 * min ; \n start = sec * 1000 + hsec ; \n me += 60 * he ; \n se += 60 * me ; \n end = se * 1000 + mse ; \n * duration = end - start ; \n return start ; \n } \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 8235}
{"project": "FFmpeg", "commit_id": "8e094dd6674e3fd503e1fc2f68883fd3f73a5bd1", "target": 0, "func": "int av_parse_color ( uint8_t * rgba_color , const char * color_string , void * log_ctx ) \n { \n if ( ! strcasecmp ( color_string , \" \" ) || ! strcasecmp ( color_string , \" \" ) ) { \n int rgba = av_get_random_seed ( ) ; \n rgba_color [ 0 ] = rgba >> 24 ; \n rgba_color [ 1 ] = rgba >> 16 ; \n rgba_color [ 2 ] = rgba >> 8 ; \n rgba_color [ 3 ] = rgba ; \n } else \n if ( ! strncmp ( color_string , \" \" , 2 ) ) { \n char * tail ; \n int len = strlen ( color_string ) ; \n unsigned int rgba = strtoul ( color_string , & tail , 16 ) ; \n if ( * tail || ( len != 8 && len != 10 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , color_string ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( len == 10 ) { \n rgba_color [ 3 ] = rgba ; \n rgba >>= 8 ; \n } \n rgba_color [ 0 ] = rgba >> 16 ; \n rgba_color [ 1 ] = rgba >> 8 ; \n rgba_color [ 2 ] = rgba ; \n } else { \n const ColorEntry * entry = bsearch ( color_string , \n color_table , \n FF_ARRAY_ELEMS ( color_table ) , \n sizeof ( ColorEntry ) , \n color_table_compare ) ; \n if ( ! entry ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , color_string ) ; \n return AVERROR ( EINVAL ) ; \n } \n memcpy ( rgba_color , entry -> rgba_color , 4 ) ; \n } \n return 0 ; \n }", "idx": 8238}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( lumRangeToJpeg ) ( int16_t * dst , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = ( FFMIN ( dst [ i ] , 30189 ) * 19077 - 39057361 ) >> 14 ; \n }", "idx": 8252}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "void avcodec_get_context_defaults ( AVCodecContext * s ) { \n memset ( s , 0 , sizeof ( AVCodecContext ) ) ; \n s -> av_class = & av_codec_context_class ; \n s -> bit_rate = 800 * 1000 ; \n s -> bit_rate_tolerance = s -> bit_rate * 10 ; \n s -> qmin = 2 ; \n s -> qmax = 31 ; \n s -> mb_qmin = 2 ; \n s -> mb_qmax = 31 ; \n s -> rc_eq = \" \" ; \n s -> qcompress = 0.5 ; \n s -> max_qdiff = 3 ; \n s -> b_quant_factor = 1.25 ; \n s -> b_quant_offset = 1.25 ; \n s -> i_quant_factor = -0.8 ; \n s -> i_quant_offset = 0.0 ; \n s -> error_concealment = 3 ; \n s -> error_resilience = 1 ; \n s -> workaround_bugs = FF_BUG_AUTODETECT ; \n s -> frame_rate_base = 1 ; \n s -> frame_rate = 25 ; \n s -> gop_size = 50 ; \n s -> me_method = ME_EPZS ; \n s -> get_buffer = avcodec_default_get_buffer ; \n s -> release_buffer = avcodec_default_release_buffer ; \n s -> get_format = avcodec_default_get_format ; \n s -> execute = avcodec_default_execute ; \n s -> thread_count = 1 ; \n s -> me_subpel_quality = 8 ; \n s -> lmin = FF_QP2LAMBDA * s -> qmin ; \n s -> lmax = FF_QP2LAMBDA * s -> qmax ; \n s -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> ildct_cmp = FF_CMP_VSAD ; \n s -> profile = FF_PROFILE_UNKNOWN ; \n s -> level = FF_LEVEL_UNKNOWN ; \n s -> intra_quant_bias = FF_DEFAULT_QUANT_BIAS ; \n s -> inter_quant_bias = FF_DEFAULT_QUANT_BIAS ; \n s -> palctrl = NULL ; \n s -> reget_buffer = avcodec_default_reget_buffer ; \n }", "idx": 8263}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int amr_wb_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n AMRWBContext * s = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n int size , ret ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , MAX_PACKET_SIZE ) ) ) \n return ret ; \n if ( s -> last_bitrate != avctx -> bit_rate ) { \n s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> last_bitrate = avctx -> bit_rate ; \n } \n size = E_IF_encode ( s -> state , s -> mode , samples , avpkt -> data , s -> allow_dtx ) ; \n if ( size <= 0 || size > MAX_PACKET_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( frame -> pts != AV_NOPTS_VALUE ) \n avpkt -> pts = frame -> pts - ff_samples_to_time_base ( avctx , avctx -> delay ) ; \n avpkt -> size = size ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 8272}
{"project": "FFmpeg", "commit_id": "3b9dd906d18f4cd801ceedd20d800a7e53074be9", "target": 0, "func": "static int decode_2 ( SANMVideoContext * ctx ) \n { \n int cx , cy , ret ; \n for ( cy = 0 ; cy != ctx -> aligned_height ; cy += 8 ) { \n for ( cx = 0 ; cx != ctx -> aligned_width ; cx += 8 ) { \n if ( ret = codec2subblock ( ctx , cx , cy , 8 ) ) \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 8275}
{"project": "FFmpeg", "commit_id": "eac5c7b8377f3f0e8262ab44e5ccb2c7ed060cdd", "target": 0, "func": "int ff_get_line ( AVIOContext * s , char * buf , int maxlen ) \n { \n int i = 0 ; \n char c ; \n do { \n c = avio_r8 ( s ) ; \n if ( c && i < maxlen - 1 ) \n buf [ i ++ ] = c ; \n } while ( c != ' \\n ' && c != ' \\r ' && c ) ; \n if ( c == ' \\r ' && avio_r8 ( s ) != ' \\n ' ) \n avio_skip ( s , -1 ) ; \n buf [ i ] = 0 ; \n return i ; \n }", "idx": 8301}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static enum AVHWDeviceType hw_device_match_type_by_hwaccel ( enum HWAccelID hwaccel_id ) \n { \n int i ; \n if ( hwaccel_id == HWACCEL_NONE ) \n return AV_HWDEVICE_TYPE_NONE ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) { \n if ( hwaccels [ i ] . id == hwaccel_id ) \n return hwaccels [ i ] . device_type ; \n } \n return AV_HWDEVICE_TYPE_NONE ; \n }", "idx": 8310}
{"project": "FFmpeg", "commit_id": "8a78ae2d2101622fd244b99178d8bc61175c878e", "target": 0, "func": "static int seg_write_trailer ( struct AVFormatContext * s ) \n { \n SegmentContext * seg = s -> priv_data ; \n AVFormatContext * oc = seg -> avf ; \n int ret = 0 ; \n if ( ! oc ) \n goto fail ; \n if ( ! seg -> write_header_trailer ) { \n if ( ( ret = segment_end ( oc , 0 ) ) < 0 ) \n goto fail ; \n open_null_ctx ( & oc -> pb ) ; \n ret = av_write_trailer ( oc ) ; \n close_null_ctx ( oc -> pb ) ; \n } else { \n ret = segment_end ( oc , 1 ) ; \n } \n if ( ret < 0 ) \n goto fail ; \n if ( seg -> list && seg -> list_type == LIST_HLS ) { \n if ( ( ret = segment_hls_window ( s , 1 ) < 0 ) ) \n goto fail ; \n } \n fail : \n avio_close ( seg -> pb ) ; \n avformat_free_context ( oc ) ; \n return ret ; \n }", "idx": 8315}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "int ff_tempfile ( const char * prefix , char * * filename ) { \n int fd = -1 ; \n #if ! HAVE_MKSTEMP  \n  \n  * filename = tempnam ( \" \" , prefix ) ; \n #else \n size_t len = strlen ( prefix ) + 12 ; \n * filename = av_malloc ( len ) ; \n #endif \n if ( * filename == NULL ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n #if ! HAVE_MKSTEMP  \n  \n  fd = avpriv_open ( * filename , O_RDWR | O_BINARY | O_CREAT , 0444 ) ; \n #else \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n if ( fd < 0 ) { \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n } \n #endif \n if ( fd < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , * filename ) ; \n return -1 ; \n } \n return fd ; \n }", "idx": 8316}
{"project": "FFmpeg", "commit_id": "92a0f338786b629c5661f5b552e32c6154c3389d", "target": 0, "func": "static void ffm_seek1 ( AVFormatContext * s , int64_t pos1 ) \n { \n FFMContext * ffm = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n int64_t pos ; \n pos = pos1 + ffm -> write_index ; \n if ( pos >= ffm -> file_size ) \n pos -= ( ffm -> file_size - FFM_PACKET_SIZE ) ; \n #ifdef DEBUG_SEEK \n av_log ( s , AV_LOG_DEBUG , \" \" PRIx64 \" \" PRIx64 \" \\n \" , pos1 , pos ) ; \n #endif \n url_fseek ( pb , pos , SEEK_SET ) ; \n }", "idx": 8317}
{"project": "FFmpeg", "commit_id": "179a2f04eb2bd6df7221883a92dc4e00cf94394b", "target": 0, "func": "void checkasm_check_vf_threshold ( void ) \n { \n check_threshold_8 ( ) ; \n report ( \" \" ) ; \n }", "idx": 8319}
{"project": "FFmpeg", "commit_id": "ca41c72c6d9515d9045bd3b68104525dee81b8d0", "target": 1, "func": "static int mp_get_vlc ( MotionPixelsContext * mp , GetBitContext * gb ) \n { \n int i ; \n i = ( mp -> codes_count == 1 ) ? 0 : get_vlc2 ( gb , mp -> vlc . table , mp -> max_codes_bits , 1 ) ; \n return mp -> codes [ i ] . delta ; \n }", "idx": 8321}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int64_t get_dts ( AVFormatContext * s , int64_t pos ) \n { \n AVIOContext * pb = s -> pb ; \n int64_t dts ; \n ffm_seek1 ( s , pos ) ; \n avio_skip ( pb , 4 ) ; \n dts = avio_rb64 ( pb ) ; \n av_dlog ( s , \" \\n \" , dts / 1000000.0 ) ; \n return dts ; \n }", "idx": 8327}
{"project": "FFmpeg", "commit_id": "44f1698a3824836d32708ae93e78ac1f2310a07e", "target": 1, "func": "static void compute_antialias_integer ( MPADecodeContext * s , \n GranuleDef * g ) \n { \n int32_t * ptr , * csa ; \n int n , i ; \n if ( g -> block_type == 2 ) { \n if ( ! g -> switch_point ) \n return ; \n n = 1 ; \n } else { \n n = SBLIMIT - 1 ; \n } \n ptr = g -> sb_hybrid + 18 ; \n for ( i = n ; i > 0 ; i -- ) { \n int tmp0 , tmp1 , tmp2 ; \n csa = & csa_table [ 0 ] [ 0 ] ; \n #define INT_AA ( j )  \\ \n  \n  tmp0 = 4 * ( ptr [ -1 - j ] ) ; \n tmp1 = 4 * ( ptr [ j ] ) ; \n tmp2 = MULH ( tmp0 + tmp1 , csa [ 0 + 4 * j ] ) ; \n ptr [ -1 - j ] = tmp2 - MULH ( tmp1 , csa [ 2 + 4 * j ] ) ; \n ptr [ j ] = tmp2 + MULH ( tmp0 , csa [ 3 + 4 * j ] ) ; \n INT_AA ( 0 )  \n INT_AA ( 1 )  \n INT_AA ( 2 )  \n INT_AA ( 3 )  \n INT_AA ( 4 )  \n INT_AA ( 5 )  \n INT_AA ( 6 )  \n INT_AA ( 7 )  \n ptr += 18 ; \n } \n }", "idx": 8330}
{"project": "FFmpeg", "commit_id": "44f110f509d0ab4fc73b9f2363a97c6577d3850f", "target": 1, "func": "static void expand_rle_row ( unsigned char * optr , unsigned char * iptr , \n int chan_offset , int pixelstride ) \n { \n unsigned char pixel , count ; \n #ifndef WORDS_BIGENDIAN \n if ( pixelstride == 4 && chan_offset != 3 ) { \n chan_offset = 2 - chan_offset ; \n } \n #endif \n optr += chan_offset ; \n while ( 1 ) { \n pixel = * iptr ++ ; \n if ( ! ( count = ( pixel & 0x7f ) ) ) { \n return ; \n } \n if ( pixel & 0x80 ) { \n while ( count -- ) { \n * optr = * iptr ; \n optr += pixelstride ; \n iptr ++ ; \n } \n } else { \n pixel = * iptr ++ ; \n while ( count -- ) { \n * optr = pixel ; \n optr += pixelstride ; \n } \n } \n } \n }", "idx": 8332}
{"project": "FFmpeg", "commit_id": "25e3e53d4092e7b69a4d681824fa0f7b2731bb1e", "target": 1, "func": "static void rtsp_cmd_describe ( HTTPContext * c , const char * url ) \n { \n FFStream * stream ; \n char path1 [ 1024 ] ; \n const char * path ; \n uint8_t * content ; \n int content_length , len ; \n struct sockaddr_in my_addr ; \n url_split ( NULL , 0 , NULL , 0 , NULL , 0 , NULL , path1 , sizeof ( path1 ) , url ) ; \n path = path1 ; \n if ( * path == ' ' ) \n path ++ ; \n for ( stream = first_stream ; stream != NULL ; stream = stream -> next ) { \n if ( ! stream -> is_feed && ! strcmp ( stream -> fmt -> name , \" \" ) && \n ! strcmp ( path , stream -> filename ) ) { \n goto found ; \n } \n } \n rtsp_reply_error ( c , RTSP_STATUS_SERVICE ) ; \n return ; \n found : \n len = sizeof ( my_addr ) ; \n getsockname ( c -> fd , ( struct sockaddr * ) & my_addr , & len ) ; \n content_length = prepare_sdp_description ( stream , & content , my_addr . sin_addr ) ; \n if ( content_length < 0 ) { \n rtsp_reply_error ( c , RTSP_STATUS_INTERNAL ) ; \n return ; \n } \n rtsp_reply_header ( c , RTSP_STATUS_OK ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" , content_length ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n put_buffer ( c -> pb , content , content_length ) ; \n }", "idx": 8333}
{"project": "FFmpeg", "commit_id": "a84f0e8d8f293df3c535f9b893730a835bed6520", "target": 1, "func": "av_cold int ff_vp8_decode_free ( AVCodecContext * avctx ) \n { \n VP8Context * s = avctx -> priv_data ; \n int i ; \n vp8_decode_flush_impl ( avctx , 1 ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> frames ) ; i ++ ) \n av_frame_free ( & s -> frames [ i ] . tf . f ) ; \n }", "idx": 8334}
{"project": "FFmpeg", "commit_id": "30be1ea33e5525266ad871bed60b1893a53caeaf", "target": 1, "func": "static int ebml_read_binary ( AVIOContext * pb , int length , EbmlBin * bin ) \n { \n av_free ( bin -> data ) ; \n if ( ! ( bin -> data = av_malloc ( length ) ) ) \n return AVERROR ( ENOMEM ) ; \n bin -> size = length ; \n bin -> pos = avio_tell ( pb ) ; \n if ( avio_read ( pb , bin -> data , length ) != length ) { \n av_freep ( & bin -> data ) ; \n return AVERROR ( EIO ) ; \n } \n return 0 ; \n }", "idx": 8338}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "void avcodec_init ( void ) \n { \n static int inited = 0 ; \n if ( inited != 0 ) \n return ; \n inited = 1 ; \n dsputil_static_init ( ) ; \n }", "idx": 8339}
{"project": "FFmpeg", "commit_id": "196b885a5f0aa3ca022c1fa99509f47341239784", "target": 0, "func": "void swri_get_dither ( SwrContext * s , void * dst , int len , unsigned seed , enum AVSampleFormat noise_fmt ) { \n double scale = s -> dither . noise_scale ; \n #define TMP_EXTRA  2  \n  \n  double * tmp = av_malloc_array ( len + TMP_EXTRA , sizeof ( double ) ) ; \n int i ; \n for ( i = 0 ; i < len + TMP_EXTRA ; i ++ ) { \n double v ; \n seed = seed * 1664525 + 1013904223 ; \n switch ( s -> dither . method ) { \n case SWR_DITHER_RECTANGULAR : v = ( ( double ) seed ) / UINT_MAX - 0.5 ; break ; \n default : \n av_assert0 ( s -> dither . method < SWR_DITHER_NB ) ; \n v = ( ( double ) seed ) / UINT_MAX ; \n seed = seed * 1664525 + 1013904223 ; \n v -= ( ( double ) seed ) / UINT_MAX ; \n break ; \n } \n tmp [ i ] = v ; \n } \n for ( i = 0 ; i < len ; i ++ ) { \n double v ; \n switch ( s -> dither . method ) { \n default : \n av_assert0 ( s -> dither . method < SWR_DITHER_NB ) ; \n v = tmp [ i ] ; \n break ; \n case SWR_DITHER_TRIANGULAR_HIGHPASS : \n v = ( - tmp [ i ] + 2 * tmp [ i + 1 ] - tmp [ i + 2 ] ) / sqrt ( 6 ) ; \n break ; \n } \n v *= scale ; \n switch ( noise_fmt ) { \n case AV_SAMPLE_FMT_S16P : ( ( int16_t * ) dst ) [ i ] = v ; break ; \n case AV_SAMPLE_FMT_S32P : ( ( int32_t * ) dst ) [ i ] = v ; break ; \n case AV_SAMPLE_FMT_FLTP : ( ( float * ) dst ) [ i ] = v ; break ; \n case AV_SAMPLE_FMT_DBLP : ( ( double * ) dst ) [ i ] = v ; break ; \n default : av_assert0 ( 0 ) ; \n } \n } \n av_free ( tmp ) ; \n }", "idx": 8341}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static void vp8_idct_dc_add4y_c ( uint8_t * dst , int16_t block [ 4 ] [ 16 ] , \n ptrdiff_t stride ) \n { \n vp8_idct_dc_add_c ( dst + 0 , block [ 0 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 4 , block [ 1 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 8 , block [ 2 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 12 , block [ 3 ] , stride ) ; \n }", "idx": 8354}
{"project": "FFmpeg", "commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "target": 1, "func": "void ff_frame_thread_encoder_free ( AVCodecContext * avctx ) { \n int i ; \n ThreadContext * c = avctx -> internal -> frame_thread_encoder ; \n pthread_mutex_lock ( & c -> task_fifo_mutex ) ; \n c -> exit = 1 ; \n pthread_cond_broadcast ( & c -> task_fifo_cond ) ; \n pthread_mutex_unlock ( & c -> task_fifo_mutex ) ; \n for ( i = 0 ; i < avctx -> thread_count ; i ++ ) { \n pthread_join ( c -> worker [ i ] , NULL ) ; \n } \n pthread_mutex_destroy ( & c -> task_fifo_mutex ) ; \n pthread_mutex_destroy ( & c -> finished_task_mutex ) ; \n pthread_mutex_destroy ( & c -> buffer_mutex ) ; \n pthread_cond_destroy ( & c -> task_fifo_cond ) ; \n pthread_cond_destroy ( & c -> finished_task_cond ) ; \n av_fifo_freep ( & c -> task_fifo ) ; \n av_freep ( & avctx -> internal -> frame_thread_encoder ) ; \n }", "idx": 8355}
{"project": "FFmpeg", "commit_id": "ab61b79b1c707a9ea0512238d837ea3e8b8395ed", "target": 0, "func": "static int mov_read_mdhd ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n int version ; \n char language [ 4 ] = { 0 } ; \n unsigned lang ; \n int64_t creation_time ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n if ( sc -> time_scale ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n version = avio_r8 ( pb ) ; \n if ( version > 1 ) { \n avpriv_request_sample ( c -> fc , \" \" , version ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avio_rb24 ( pb ) ; \n if ( version == 1 ) { \n creation_time = avio_rb64 ( pb ) ; \n avio_rb64 ( pb ) ; \n } else { \n creation_time = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n } \n mov_metadata_creation_time ( & st -> metadata , creation_time ) ; \n sc -> time_scale = avio_rb32 ( pb ) ; \n if ( sc -> time_scale <= 0 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" , sc -> time_scale ) ; \n return AVERROR_INVALIDDATA ; \n } \n st -> duration = ( version == 1 ) ? avio_rb64 ( pb ) : avio_rb32 ( pb ) ; \n lang = avio_rb16 ( pb ) ; \n if ( ff_mov_lang_to_iso639 ( lang , language ) ) \n av_dict_set ( & st -> metadata , \" \" , language , 0 ) ; \n avio_rb16 ( pb ) ; \n return 0 ; \n }", "idx": 8358}
{"project": "FFmpeg", "commit_id": "aafd659518356d1ae3624830a36816f154d94d83", "target": 1, "func": "av_cold int ff_rdft_init ( RDFTContext * s , int nbits , enum RDFTransformType trans ) \n { \n int n = 1 << nbits ; \n int i ; \n const double theta = ( trans == RDFT || trans == IRIDFT ? -1 : 1 ) * 2 * M_PI / n ; \n s -> nbits = nbits ; \n s -> inverse = trans == IRDFT || trans == IRIDFT ; \n s -> sign_convention = trans == RIDFT || trans == IRIDFT ? 1 : -1 ; \n if ( nbits < 4 || nbits > 16 ) \n return -1 ; \n if ( ff_fft_init ( & s -> fft , nbits - 1 , trans == IRDFT || trans == RIDFT ) < 0 ) \n return -1 ; \n s -> tcos = ff_cos_tabs [ nbits - 4 ] ; \n s -> tsin = ff_sin_tabs [ nbits - 4 ] + ( trans == RDFT || trans == IRIDFT ) * ( n >> 2 ) ; \n for ( i = 0 ; i < ( n >> 2 ) ; i ++ ) { \n s -> tcos [ i ] = cos ( i * theta ) ; \n s -> tsin [ i ] = sin ( i * theta ) ; \n } \n return 0 ; \n }", "idx": 8360}
{"project": "FFmpeg", "commit_id": "3fb726c6b4772594365271046d11c87ae8417bde", "target": 0, "func": "static av_cold int dsp_init ( AVCodecContext * avctx , AACEncContext * s ) \n { \n int ret = 0 ; \n s -> fdsp = avpriv_float_dsp_alloc ( avctx -> flags & CODEC_FLAG_BITEXACT ) ; \n if ( ! s -> fdsp ) \n return AVERROR ( ENOMEM ) ; \n ff_kbd_window_init ( ff_aac_kbd_long_1024 , 4.0 , 1024 ) ; \n ff_kbd_window_init ( ff_aac_kbd_short_128 , 6.0 , 128 ) ; \n ff_init_ff_sine_windows ( 10 ) ; \n ff_init_ff_sine_windows ( 7 ) ; \n if ( ret = ff_mdct_init ( & s -> mdct1024 , 11 , 0 , 32768.0 ) ) \n return ret ; \n if ( ret = ff_mdct_init ( & s -> mdct128 , 8 , 0 , 32768.0 ) ) \n return ret ; \n return 0 ; \n }", "idx": 8369}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static int decode_value ( SCPRContext * s , unsigned * cnt , unsigned maxc , unsigned step , unsigned * rval ) \n { \n GetByteContext * gb = & s -> gb ; \n RangeCoder * rc = & s -> rc ; \n unsigned totfr = cnt [ maxc ] ; \n unsigned value ; \n unsigned c = 0 , cumfr = 0 , cnt_c = 0 ; \n int i , ret ; \n if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) \n return ret ; \n while ( c < maxc ) { \n cnt_c = cnt [ c ] ; \n if ( value >= cumfr + cnt_c ) \n cumfr += cnt_c ; \n else \n break ; \n c ++ ; \n } \n s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ; \n cnt [ c ] = cnt_c + step ; \n totfr += step ; \n if ( totfr > BOT ) { \n totfr = 0 ; \n for ( i = 0 ; i < maxc ; i ++ ) { \n unsigned nc = ( cnt [ i ] >> 1 ) + 1 ; \n cnt [ i ] = nc ; \n totfr += nc ; \n } \n } \n cnt [ maxc ] = totfr ; \n * rval = c ; \n return 0 ; \n }", "idx": 8372}
{"project": "FFmpeg", "commit_id": "c914c99d4b8159d6be7c53c21f63d84f24d5ffeb", "target": 0, "func": "SwsVector * sws_cloneVec ( SwsVector * a ) \n { \n int i ; \n SwsVector * vec = sws_allocVec ( a -> length ) ; \n if ( ! vec ) \n return NULL ; \n for ( i = 0 ; i < a -> length ; i ++ ) \n vec -> coeff [ i ] = a -> coeff [ i ] ; \n return vec ; \n }", "idx": 8389}
{"project": "FFmpeg", "commit_id": "857cd1f33bcf86005529af2a77f861f884327be5", "target": 0, "func": "void swri_resample_dsp_init ( ResampleContext * c ) \n { \n #define FNIDX ( fmt )  (AV_SAMPLE_FMT_##fmt - AV_SAMPLE_FMT_S16P)  \n  \n  c -> dsp . resample_one [ FNIDX ( S16P ) ] = ( resample_one_fn ) resample_one_int16 ; \n c -> dsp . resample_one [ FNIDX ( S32P ) ] = ( resample_one_fn ) resample_one_int32 ; \n c -> dsp . resample_one [ FNIDX ( FLTP ) ] = ( resample_one_fn ) resample_one_float ; \n c -> dsp . resample_one [ FNIDX ( DBLP ) ] = ( resample_one_fn ) resample_one_double ; \n c -> dsp . resample_common [ FNIDX ( S16P ) ] = ( resample_fn ) resample_common_int16 ; \n c -> dsp . resample_common [ FNIDX ( S32P ) ] = ( resample_fn ) resample_common_int32 ; \n c -> dsp . resample_common [ FNIDX ( FLTP ) ] = ( resample_fn ) resample_common_float ; \n c -> dsp . resample_common [ FNIDX ( DBLP ) ] = ( resample_fn ) resample_common_double ; \n c -> dsp . resample_linear [ FNIDX ( S16P ) ] = ( resample_fn ) resample_linear_int16 ; \n c -> dsp . resample_linear [ FNIDX ( S32P ) ] = ( resample_fn ) resample_linear_int32 ; \n c -> dsp . resample_linear [ FNIDX ( FLTP ) ] = ( resample_fn ) resample_linear_float ; \n c -> dsp . resample_linear [ FNIDX ( DBLP ) ] = ( resample_fn ) resample_linear_double ; \n if ( ARCH_X86 ) swri_resample_dsp_x86_init ( c ) ; \n }", "idx": 8400}
{"project": "FFmpeg", "commit_id": "a8ff69ce2bad1c4bb043e88ea35f5ab5691d4f3c", "target": 0, "func": "static int decode_ext_header ( Wmv2Context * w ) { \n MpegEncContext * const s = & w -> s ; \n GetBitContext gb ; \n int fps ; \n int code ; \n if ( s -> avctx -> extradata_size < 4 ) return -1 ; \n init_get_bits ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size * 8 ) ; \n fps = get_bits ( & gb , 5 ) ; \n s -> bit_rate = get_bits ( & gb , 11 ) * 1024 ; \n w -> mspel_bit = get_bits1 ( & gb ) ; \n w -> flag3 = get_bits1 ( & gb ) ; \n w -> abt_flag = get_bits1 ( & gb ) ; \n w -> j_type_bit = get_bits1 ( & gb ) ; \n w -> top_left_mv_flag = get_bits1 ( & gb ) ; \n w -> per_mb_rl_bit = get_bits1 ( & gb ) ; \n code = get_bits ( & gb , 3 ) ; \n if ( code == 0 ) return -1 ; \n s -> slice_height = s -> mb_height / code ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , \n fps , s -> bit_rate , w -> mspel_bit , w -> abt_flag , w -> j_type_bit , w -> top_left_mv_flag , w -> per_mb_rl_bit , code , w -> flag3 , \n code ) ; \n } \n return 0 ; \n }", "idx": 8410}
{"project": "FFmpeg", "commit_id": "27bcf55f459e038e81f09c17e72e6d44898b9015", "target": 1, "func": "int av_vsrc_buffer_add_frame ( AVFilterContext * buffer_src , const AVFrame * frame ) \n { \n int ret ; \n AVFilterBufferRef * picref = \n avfilter_get_video_buffer_ref_from_frame ( frame , AV_PERM_WRITE ) ; \n if ( ! picref ) \n return AVERROR ( ENOMEM ) ; \n ret = av_vsrc_buffer_add_video_buffer_ref ( buffer_src , picref ) ; \n picref -> buf -> data [ 0 ] = NULL ; \n avfilter_unref_buffer ( picref ) ; \n return ret ; \n }", "idx": 8420}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void generate_codebook ( RoqContext * enc , RoqTempdata * tempdata , \n int * points , int inputCount , roq_cell * results , \n int size , int cbsize ) \n { \n int i , j , k ; \n int c_size = size * size / 4 ; \n int * buf ; \n int * codebook = av_malloc ( 6 * c_size * cbsize * sizeof ( int ) ) ; \n int * closest_cb ; \n if ( size == 4 ) \n closest_cb = av_malloc ( 6 * c_size * inputCount * sizeof ( int ) ) ; \n else \n closest_cb = tempdata -> closest_cb2 ; \n ff_init_elbg ( points , 6 * c_size , inputCount , codebook , cbsize , 1 , closest_cb , & enc -> randctx ) ; \n ff_do_elbg ( points , 6 * c_size , inputCount , codebook , cbsize , 1 , closest_cb , & enc -> randctx ) ; \n if ( size == 4 ) \n av_free ( closest_cb ) ; \n buf = codebook ; \n for ( i = 0 ; i < cbsize ; i ++ ) \n for ( k = 0 ; k < c_size ; k ++ ) { \n for ( j = 0 ; j < 4 ; j ++ ) \n results -> y [ j ] = * buf ++ ; \n results -> u = ( * buf ++ + CHROMA_BIAS / 2 ) / CHROMA_BIAS ; \n results -> v = ( * buf ++ + CHROMA_BIAS / 2 ) / CHROMA_BIAS ; \n results ++ ; \n } \n av_free ( codebook ) ; \n }", "idx": 8423}
{"project": "FFmpeg", "commit_id": "45f4bf94afb8b70d99fb7b5760fd65f5c3ad8b88", "target": 0, "func": "static av_cold int xma_decode_init ( AVCodecContext * avctx ) \n { \n XMADecodeCtx * s = avctx -> priv_data ; \n int i , ret ; \n for ( i = 0 ; i < avctx -> channels / 2 ; i ++ ) { \n ret = decode_init ( & s -> xma [ i ] , avctx ) ; \n s -> frames [ i ] = av_frame_alloc ( ) ; \n if ( ! s -> frames [ i ] ) \n return AVERROR ( ENOMEM ) ; \n s -> frames [ i ] -> nb_samples = 512 ; \n if ( ( ret = ff_get_buffer ( avctx , s -> frames [ i ] , 0 ) ) < 0 ) { \n return AVERROR ( ENOMEM ) ; \n } \n } \n return ret ; \n }", "idx": 8426}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_v_strong_loop_filter ( uint8_t * src , const int stride , \n const int alpha , const int lims , \n const int dmode , const int chroma ) \n { \n rv40_strong_loop_filter ( src , 1 , stride , alpha , lims , dmode , chroma ) ; \n }", "idx": 8436}
{"project": "FFmpeg", "commit_id": "5a2ad7ede33b5d63c1f1b1313a218da62e1c0d48", "target": 0, "func": "static void move_audio ( vorbis_enc_context * venc , float * audio , int * samples , int sf_size ) \n { \n AVFrame * cur = NULL ; \n int frame_size = 1 << ( venc -> log2_blocksize [ 1 ] - 1 ) ; \n int subframes = frame_size / sf_size ; \n for ( int sf = 0 ; sf < subframes ; sf ++ ) { \n cur = ff_bufqueue_get ( & venc -> bufqueue ) ; \n * samples += cur -> nb_samples ; \n for ( int ch = 0 ; ch < venc -> channels ; ch ++ ) { \n const float * input = ( float * ) cur -> extended_data [ ch ] ; \n const size_t len = cur -> nb_samples * sizeof ( float ) ; \n memcpy ( audio + ch * frame_size + sf * sf_size , input , len ) ; \n } \n av_frame_free ( & cur ) ; \n } \n }", "idx": 8441}
{"project": "FFmpeg", "commit_id": "1f99939a6361e2e6d6788494dd7c682b051c6c34", "target": 1, "func": "int ff_j2k_dwt_init ( DWTContext * s , uint16_t border [ 2 ] [ 2 ] , int decomp_levels , int type ) \n { \n int i , j , lev = decomp_levels , maxlen , \n b [ 2 ] [ 2 ] ; \n if ( decomp_levels >= FF_DWT_MAX_DECLVLS ) \n return AVERROR_INVALIDDATA ; \n s -> ndeclevels = decomp_levels ; \n s -> type = type ; \n for ( i = 0 ; i < 2 ; i ++ ) \n for ( j = 0 ; j < 2 ; j ++ ) \n b [ i ] [ j ] = border [ i ] [ j ] ; \n maxlen = FFMAX ( b [ 0 ] [ 1 ] - b [ 0 ] [ 0 ] , \n b [ 1 ] [ 1 ] - b [ 1 ] [ 0 ] ) ; \n while ( -- lev >= 0 ) { \n for ( i = 0 ; i < 2 ; i ++ ) { \n s -> linelen [ lev ] [ i ] = b [ i ] [ 1 ] - b [ i ] [ 0 ] ; \n s -> mod [ lev ] [ i ] = b [ i ] [ 0 ] & 1 ; \n for ( j = 0 ; j < 2 ; j ++ ) \n b [ i ] [ j ] = ( b [ i ] [ j ] + 1 ) >> 1 ; \n } \n } \n if ( type == FF_DWT97 ) \n s -> linebuf = av_malloc ( ( maxlen + 12 ) * sizeof ( float ) ) ; \n else if ( type == FF_DWT53 ) \n s -> linebuf = av_malloc ( ( maxlen + 6 ) * sizeof ( int ) ) ; \n else \n return -1 ; \n if ( ! s -> linebuf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 8444}
{"project": "FFmpeg", "commit_id": "a00676e48e49a3d794d6d2063ceca539e945a4a4", "target": 1, "func": "static int read_block_types ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b ) \n { \n int t , v ; \n int last = 0 ; \n const uint8_t * dec_end ; \n CHECK_READ_VAL ( gb , b , t ) ; \n dec_end = b -> cur_dec + t ; \n if ( dec_end > b -> data_end ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( get_bits1 ( gb ) ) { \n v = get_bits ( gb , 4 ) ; \n memset ( b -> cur_dec , v , t ) ; \n b -> cur_dec += t ; \n } else { \n do { \n v = GET_HUFF ( gb , b -> tree ) ; \n if ( v < 12 ) { \n last = v ; \n * b -> cur_dec ++ = v ; \n } else { \n int run = bink_rlelens [ v - 12 ] ; \n memset ( b -> cur_dec , last , run ) ; \n b -> cur_dec += run ; \n } \n } while ( b -> cur_dec < dec_end ) ; \n } \n return 0 ; \n }", "idx": 8445}
{"project": "FFmpeg", "commit_id": "3d8d3729475c7dce52d8fb9ffb280fd2ea62e1a2", "target": 1, "func": "static int y41p_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame , AVPacket * avpkt ) \n { \n AVFrame * pic = data ; \n uint8_t * src = avpkt -> data ; \n uint8_t * y , * u , * v ; \n int i , j , ret ; \n if ( avpkt -> size < 3LL * avctx -> height * avctx -> width / 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n pic -> key_frame = 1 ; \n pic -> pict_type = AV_PICTURE_TYPE_I ; \n for ( i = avctx -> height - 1 ; i >= 0 ; i -- ) { \n y = & pic -> data [ 0 ] [ i * pic -> linesize [ 0 ] ] ; \n u = & pic -> data [ 1 ] [ i * pic -> linesize [ 1 ] ] ; \n v = & pic -> data [ 2 ] [ i * pic -> linesize [ 2 ] ] ; \n for ( j = 0 ; j < avctx -> width ; j += 8 ) { \n * ( u ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( v ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( u ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( v ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n * ( y ++ ) = * src ++ ; \n } \n } \n * got_frame = 1 ; \n return avpkt -> size ; \n }", "idx": 8446}
{"project": "FFmpeg", "commit_id": "4ce87ecf2a8a8a9348f9bdbb420f3bee92e6513f", "target": 1, "func": "static int select_voice ( cst_voice * * voice , const char * voice_name , void * log_ctx ) \n { \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( voice_entries ) ; i ++ ) { \n struct voice_entry * entry = & voice_entries [ i ] ; \n if ( ! strcmp ( entry -> name , voice_name ) ) { \n * voice = entry -> register_fn ( NULL ) ; \n if ( ! * voice ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , voice_name ) ; \n return AVERROR_UNKNOWN ; \n } \n return 0 ; \n } \n } \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , voice_name ) ; \n av_log ( log_ctx , AV_LOG_INFO , \" \" ) ; \n list_voices ( log_ctx , \" \" ) ; \n return AVERROR ( EINVAL ) ; \n }", "idx": 8461}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void init_custom_qm ( VC2EncContext * s ) \n { \n int level , orientation ; \n if ( s -> quant_matrix == VC2_QM_DEF ) { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = 0 ; orientation < 4 ; orientation ++ ) { \n if ( level <= 3 ) \n s -> quant [ level ] [ orientation ] = ff_dirac_default_qmat [ s -> wavelet_idx ] [ level ] [ orientation ] ; \n else \n s -> quant [ level ] [ orientation ] = vc2_qm_col_tab [ level ] [ orientation ] ; \n } \n } \n } else if ( s -> quant_matrix == VC2_QM_COL ) { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = 0 ; orientation < 4 ; orientation ++ ) { \n s -> quant [ level ] [ orientation ] = vc2_qm_col_tab [ level ] [ orientation ] ; \n } \n } \n } else { \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = 0 ; orientation < 4 ; orientation ++ ) { \n s -> quant [ level ] [ orientation ] = vc2_qm_flat_tab [ level ] [ orientation ] ; \n } \n } \n } \n }", "idx": 8465}
{"project": "FFmpeg", "commit_id": "f3c9d66bafde9b8586bd63dd3307daa87352af75", "target": 0, "func": "static int libspeex_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n LibSpeexContext * s = avctx -> priv_data ; \n int16_t * output ; \n int ret , consumed = 0 ; \n s -> frame . nb_samples = s -> frame_size ; \n if ( ( ret = ff_get_buffer ( avctx , & s -> frame ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n output = ( int16_t * ) s -> frame . data [ 0 ] ; \n if ( speex_bits_remaining ( & s -> bits ) < 5 || \n speex_bits_peek_unsigned ( & s -> bits , 5 ) == 0x1F ) { \n if ( ! buf || ! buf_size ) { \n * got_frame_ptr = 0 ; \n return buf_size ; \n } \n speex_bits_read_from ( & s -> bits , buf , buf_size ) ; \n consumed = buf_size ; \n } \n ret = speex_decode_int ( s -> dec_state , & s -> bits , output ) ; \n if ( ret <= -2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( avctx -> channels == 2 ) \n speex_decode_stereo_int ( output , s -> frame_size , & s -> stereo ) ; \n * got_frame_ptr = 1 ; \n * ( AVFrame * ) data = s -> frame ; \n return consumed ; \n }", "idx": 8475}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int put_image ( struct vf_instance * vf , mp_image_t * mpi , double pts ) \n { \n mp_image_t * dmpi ; \n dmpi = ff_vf_get_image ( vf -> next , IMGFMT_YV12 , \n MP_IMGTYPE_TEMP , MP_IMGFLAG_ACCEPT_STRIDE | \n ( ( vf -> priv -> scaleh == 1 ) ? MP_IMGFLAG_READABLE : 0 ) , \n mpi -> w * vf -> priv -> scalew , \n mpi -> h / vf -> priv -> scaleh - vf -> priv -> skipline ) ; \n toright ( dmpi -> planes , mpi -> planes , dmpi -> stride , \n mpi -> stride , mpi -> w , mpi -> h , vf -> priv ) ; \n return ff_vf_next_put_image ( vf , dmpi , pts ) ; \n }", "idx": 8479}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int msrle_decode_init ( AVCodecContext * avctx ) \n { \n MsrleContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_coded_sample ) { \n case 4 : \n case 8 : \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n break ; \n case 24 : \n avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 8484}
{"project": "FFmpeg", "commit_id": "8b0e96e1f21b761ca15dbb470cd619a1ebf86c3e", "target": 0, "func": "static int mm_decode_intra ( MmContext * s , int half_horiz , int half_vert ) \n { \n int x = 0 , y = 0 ; \n while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) { \n int run_length , color ; \n if ( y >= s -> avctx -> height ) \n return 0 ; \n color = bytestream2_get_byte ( & s -> gb ) ; \n if ( color & 0x80 ) { \n run_length = 1 ; \n } else { \n run_length = ( color & 0x7f ) + 2 ; \n color = bytestream2_get_byte ( & s -> gb ) ; \n } \n if ( half_horiz ) \n run_length *= 2 ; \n if ( run_length > s -> avctx -> width - x ) \n return AVERROR_INVALIDDATA ; \n if ( color ) { \n memset ( s -> frame -> data [ 0 ] + y * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; \n if ( half_vert ) \n memset ( s -> frame -> data [ 0 ] + ( y + 1 ) * s -> frame -> linesize [ 0 ] + x , color , run_length ) ; \n } \n x += run_length ; \n if ( x >= s -> avctx -> width ) { \n x = 0 ; \n y += 1 + half_vert ; \n } \n } \n return 0 ; \n }", "idx": 8485}
{"project": "FFmpeg", "commit_id": "bd03c380ce67cffaaf3c456407cc98e02917ebf7", "target": 0, "func": "char * av_base64_encode ( uint8_t * src , int len ) \n { \n static const char b64 [ ] = \n \" \" ; \n char * ret , * dst ; \n unsigned i_bits = 0 ; \n int i_shift = 0 ; \n int bytes_remaining = len ; \n if ( len < UINT_MAX / 4 ) { \n ret = dst = av_malloc ( len * 4 / 3 + 12 ) ; \n } else \n return NULL ; \n if ( len ) { \n while ( bytes_remaining ) { \n i_bits = ( i_bits << 8 ) + * src ++ ; \n bytes_remaining -- ; \n i_shift += 8 ; \n do { \n * dst ++ = b64 [ ( i_bits << 6 >> i_shift ) & 0x3f ] ; \n i_shift -= 6 ; \n } while ( i_shift > 6 || ( bytes_remaining == 0 && i_shift > 0 ) ) ; \n } \n while ( ( dst - ret ) & 3 ) \n * dst ++ = ' ' ; \n } \n * dst = ' \\0 ' ; \n return ret ; \n }", "idx": 8488}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "av_cold void ff_blockdsp_init_x86 ( BlockDSPContext * c , \n AVCodecContext * avctx ) \n #else \n av_cold  void ff_blockdsp_init_x86 ( BlockDSPContext * c ) \n #endif \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( INLINE_MMX ( cpu_flags ) ) { \n c -> clear_block = clear_block_mmx ; \n c -> clear_blocks = clear_blocks_mmx ; \n } \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( CONFIG_MPEG_XVMC_DECODER && avctx -> xvmc_acceleration > 1 ) \n return ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( INLINE_SSE ( cpu_flags ) ) { \n c -> clear_block = clear_block_sse ; \n c -> clear_blocks = clear_blocks_sse ; \n } \n #endif \n }", "idx": 8489}
{"project": "FFmpeg", "commit_id": "dcf5bfbdb6137ffdca66e0b7c2929ced42732951", "target": 0, "func": "static int read_bfraction ( VC1Context * v , GetBitContext * gb ) { \n v -> bfraction_lut_index = get_vlc2 ( gb , ff_vc1_bfraction_vlc . table , VC1_BFRACTION_VLC_BITS , 1 ) ; \n v -> bfraction = ff_vc1_bfraction_lut [ v -> bfraction_lut_index ] ; \n return 0 ; \n }", "idx": 8490}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream * add_video_stream ( AVFormatContext * oc , int codec_id ) \n { \n AVCodec * codec ; \n AVCodecContext * c ; \n AVStream * st ; \n uint8_t * picture_buf ; \n int size ; \n st = av_new_stream ( oc , 0 ) ; \n if ( ! st ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n codec = avcodec_find_encoder ( codec_id ) ; \n if ( ! codec ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n c = & st -> codec ; \n c -> codec_type = CODEC_TYPE_VIDEO ; \n c -> bit_rate = 400000 ; \n c -> width = 352 ; \n c -> height = 288 ; \n c -> frame_rate = 25 ; \n c -> frame_rate_base = 1 ; \n c -> gop_size = 12 ; \n if ( avcodec_open ( c , codec ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n picture = avcodec_alloc_frame ( ) ; \n video_outbuf_size = 100000 ; \n video_outbuf = malloc ( video_outbuf_size ) ; \n size = c -> width * c -> height ; \n picture_buf = malloc ( ( size * 3 ) / 2 ) ; \n picture -> data [ 0 ] = picture_buf ; \n picture -> data [ 1 ] = picture -> data [ 0 ] + size ; \n picture -> data [ 2 ] = picture -> data [ 1 ] + size / 4 ; \n picture -> linesize [ 0 ] = c -> width ; \n picture -> linesize [ 1 ] = c -> width / 2 ; \n picture -> linesize [ 2 ] = c -> width / 2 ; \n return st ; \n }", "idx": 8491}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "const uint8_t * get_submv_prob ( uint32_t left , uint32_t top ) \n { \n if ( left == top ) \n return vp8_submv_prob [ 4 - ! ! left ] ; \n if ( ! top ) \n return vp8_submv_prob [ 2 ] ; \n return vp8_submv_prob [ 1 - ! ! left ] ; \n }", "idx": 8492}
{"project": "FFmpeg", "commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "target": 1, "func": "libAVMemInputPin_Receive ( libAVMemInputPin * this , IMediaSample * sample )  \n { \n libAVPin * pin = ( libAVPin * ) ( ( uint8_t * ) this - imemoffset ) ; \n enum dshowDeviceType devtype = pin -> filter -> type ; \n void * priv_data ; \n uint8_t * buf ; \n int buf_size ; \n int index ; \n int64_t curtime ; \n dshowdebug ( \" \\n \" , this ) ; \n if ( ! sample ) \n return E_POINTER ; \n if ( devtype == VideoDevice ) { \n IReferenceClock * clock = pin -> filter -> clock ; \n IReferenceClock_GetTime ( clock , & curtime ) ; \n } else { \n int64_t dummy ; \n IMediaSample_GetTime ( sample , & curtime , & dummy ) ; \n curtime += pin -> filter -> start_time ; \n } \n buf_size = IMediaSample_GetActualDataLength ( sample ) ; \n IMediaSample_GetPointer ( sample , & buf ) ; \n priv_data = pin -> filter -> priv_data ; \n index = pin -> filter -> stream_index ; \n pin -> filter -> callback ( priv_data , index , buf , buf_size , curtime ) ; \n return S_OK ; \n }", "idx": 8499}
{"project": "FFmpeg", "commit_id": "104d04182d85e8538e8934c072432a05ab7ed999", "target": 1, "func": "int inet_aton ( const char * str , struct in_addr * add ) \n { \n const char * pch = str ; \n unsigned int add1 = 0 , add2 = 0 , add3 = 0 , add4 = 0 ; \n add1 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) goto done ; \n add2 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) goto done ; \n add3 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) goto done ; \n add4 = atoi ( pch ) ; \n done : \n add -> s_addr = ( add4 << 24 ) + ( add3 << 16 ) + ( add2 << 8 ) + add1 ; \n return 1 ; \n }", "idx": 8502}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static void * circular_buffer_task_tx ( void * _URLContext ) \n { \n URLContext * h = _URLContext ; \n UDPContext * s = h -> priv_data ; \n int old_cancelstate ; \n pthread_setcancelstate ( PTHREAD_CANCEL_DISABLE , & old_cancelstate ) ; \n for ( ; ; ) { \n int len ; \n uint8_t tmp [ 4 ] ; \n pthread_setcancelstate ( PTHREAD_CANCEL_ENABLE , & old_cancelstate ) ; \n av_usleep ( s -> packet_gap ) ; \n pthread_setcancelstate ( PTHREAD_CANCEL_DISABLE , & old_cancelstate ) ; \n pthread_mutex_lock ( & s -> mutex ) ; \n len = av_fifo_size ( s -> fifo ) ; \n while ( len < 4 ) { \n if ( pthread_cond_wait ( & s -> cond , & s -> mutex ) < 0 ) { \n goto end ; \n } \n len = av_fifo_size ( s -> fifo ) ; \n } \n av_fifo_generic_peek ( s -> fifo , tmp , 4 , NULL ) ; \n len = AV_RL32 ( tmp ) ; \n if ( len > 0 && av_fifo_size ( s -> fifo ) >= len + 4 ) { \n av_fifo_drain ( s -> fifo , 4 ) ; \n av_fifo_generic_read ( s -> fifo , h , len , do_udp_write ) ; \n if ( s -> circular_buffer_error == len ) { \n s -> circular_buffer_error = 0 ; \n } \n } \n pthread_mutex_unlock ( & s -> mutex ) ; \n } \n end : \n pthread_mutex_unlock ( & s -> mutex ) ; \n return NULL ; \n }", "idx": 8505}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static void GLZWDecodeInit ( GifState * s , int csize ) \n { \n s -> eob_reached = 0 ; \n s -> pbuf = s -> buf ; \n s -> ebuf = s -> buf ; \n s -> bbuf = 0 ; \n s -> bbits = 0 ; \n s -> codesize = csize ; \n s -> cursize = s -> codesize + 1 ; \n s -> curmask = mask [ s -> cursize ] ; \n s -> top_slot = 1 << s -> cursize ; \n s -> clear_code = 1 << s -> codesize ; \n s -> end_code = s -> clear_code + 1 ; \n s -> slot = s -> newcodes = s -> clear_code + 2 ; \n s -> oc = s -> fc = 0 ; \n s -> sp = s -> stack ; \n }", "idx": 8514}
{"project": "FFmpeg", "commit_id": "643bae382c2610512652d3c5cfa7aabb450a706e", "target": 1, "func": "static int interp ( RA144Context * ractx , int16_t * out , int a , \n int copyold , int energy ) \n { \n int work [ 10 ] ; \n int b = NBLOCKS - a ; \n int i ; \n for ( i = 0 ; i < 30 ; i ++ ) \n out [ i ] = ( a * ractx -> lpc_coef [ 0 ] [ i ] + b * ractx -> lpc_coef [ 1 ] [ i ] ) >> 2 ; \n if ( eval_refl ( work , out , ractx ) ) { \n int_to_int16 ( out , ractx -> lpc_coef [ copyold ] ) ; \n return rescale_rms ( ractx -> lpc_refl_rms [ copyold ] , energy ) ; \n } else { \n return rescale_rms ( rms ( work ) , energy ) ; \n } \n }", "idx": 8521}
{"project": "FFmpeg", "commit_id": "b3415e4c5f9205820fd6c9211ad50a4df2692a36", "target": 1, "func": "void * av_fast_realloc ( void * ptr , unsigned int * size , size_t min_size ) \n { \n if ( min_size < * size ) \n return ptr ; \n min_size = FFMAX ( 17 * min_size / 16 + 32 , min_size ) ; \n ptr = av_realloc ( ptr , min_size ) ; \n if ( ! ptr ) \n min_size = 0 ; \n * size = min_size ; \n return ptr ; \n }", "idx": 8524}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int64_t avcodec_guess_channel_layout ( int nb_channels , enum CodecID codec_id , const char * fmt_name ) \n { \n switch ( nb_channels ) { \n case 1 : return AV_CH_LAYOUT_MONO ; \n case 2 : return AV_CH_LAYOUT_STEREO ; \n case 3 : return AV_CH_LAYOUT_SURROUND ; \n case 4 : return AV_CH_LAYOUT_QUAD ; \n case 5 : return AV_CH_LAYOUT_5POINT0 ; \n case 6 : return AV_CH_LAYOUT_5POINT1 ; \n case 8 : return AV_CH_LAYOUT_7POINT1 ; \n default : return 0 ; \n } \n }", "idx": 8529}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_1r_to_dolby ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] -= samples [ i + 512 ] ; \n samples [ i + 256 ] += samples [ i + 512 ] ; \n samples [ i + 512 ] = 0 ; \n } \n }", "idx": 8530}
{"project": "FFmpeg", "commit_id": "1e85b5e077e7e6fb9901bfd1a7a4f2594ba5a9a5", "target": 0, "func": "int ff_network_wait_fd_timeout ( int fd , int write , int64_t timeout , AVIOInterruptCB * int_cb ) \n { \n int ret ; \n int64_t wait_start = 0 ; \n while ( 1 ) { \n ret = ff_network_wait_fd ( fd , write ) ; \n if ( ret != AVERROR ( EAGAIN ) ) \n return ret ; \n if ( ff_check_interrupt ( int_cb ) ) \n return AVERROR_EXIT ; \n if ( timeout > 0 ) { \n if ( ! wait_start ) \n wait_start = av_gettime ( ) ; \n else if ( av_gettime ( ) - wait_start > timeout ) \n return AVERROR ( ETIMEDOUT ) ; \n } \n } \n }", "idx": 8533}
{"project": "FFmpeg", "commit_id": "c6303f8d70c25dd6c6e6486c78bf99c9924e2b6b", "target": 1, "func": "static void yop_next_macroblock ( YopDecContext * s ) \n { \n if ( s -> row_pos == s -> frame . linesize [ 0 ] - 2 ) { \n s -> dstptr += s -> frame . linesize [ 0 ] ; \n s -> row_pos = 0 ; \n } else { \n s -> row_pos += 2 ; \n } \n s -> dstptr += 2 ; \n }", "idx": 8540}
{"project": "FFmpeg", "commit_id": "8c222bb405f7031b2326c601f5072ca2980b1079", "target": 1, "func": "static int ac3_probe ( AVProbeData * p ) \n { \n int max_frames , first_frames , frames ; \n uint8_t * buf , * buf2 , * end ; \n AC3HeaderInfo hdr ; \n if ( p -> buf_size < 7 ) \n return 0 ; \n max_frames = 0 ; \n buf = p -> buf ; \n end = buf + FFMIN ( 4096 , p -> buf_size - 7 ) ; \n for ( ; buf < end ; buf ++ ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n if ( ff_ac3_parse_header ( buf2 , & hdr ) < 0 ) \n break ; \n buf2 += hdr . frame_size ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == p -> buf ) \n first_frames = frames ; \n } \n if ( first_frames >= 3 ) return AVPROBE_SCORE_MAX * 3 / 4 ; \n else if ( max_frames >= 3 ) return AVPROBE_SCORE_MAX / 2 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 8544}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( bgr24ToUV_half ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , long width , uint32_t * unused ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int r = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n } \n assert ( src1 == src2 ) ; \n }", "idx": 8549}
{"project": "FFmpeg", "commit_id": "d7eabd50425a61b31e90c763a0c3e4316a725404", "target": 0, "func": "static int get_scale_idx ( GetBitContext * gb , int ref ) \n { \n int t = get_vlc2 ( gb , dscf_vlc . table , MPC7_DSCF_BITS , 1 ) - 7 ; \n if ( t == 8 ) \n return get_bits ( gb , 6 ) ; \n return ref + t ; \n }", "idx": 8551}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "void filter_level_for_mb ( VP8Context * s , VP8Macroblock * mb , VP8FilterStrength * f ) \n { \n int interior_limit , filter_level ; \n if ( s -> segmentation . enabled ) { \n filter_level = s -> segmentation . filter_level [ mb -> segment ] ; \n if ( ! s -> segmentation . absolute_vals ) \n filter_level += s -> filter . level ; \n } else \n filter_level = s -> filter . level ; \n if ( s -> lf_delta . enabled ) { \n filter_level += s -> lf_delta . ref [ mb -> ref_frame ] ; \n filter_level += s -> lf_delta . mode [ mb -> mode ] ; \n } \n filter_level = av_clip_uintp2 ( filter_level , 6 ) ; \n interior_limit = filter_level ; \n if ( s -> filter . sharpness ) { \n interior_limit >>= ( s -> filter . sharpness + 3 ) >> 2 ; \n interior_limit = FFMIN ( interior_limit , 9 - s -> filter . sharpness ) ; \n } \n interior_limit = FFMAX ( interior_limit , 1 ) ; \n f -> filter_level = filter_level ; \n f -> inner_limit = interior_limit ; \n f -> inner_filter = ! mb -> skip || mb -> mode == MODE_I4x4 || \n mb -> mode == VP8_MVMODE_SPLIT ; \n }", "idx": 8579}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int decode_syncpoint ( NUTContext * nut ) { \n AVFormatContext * s = nut -> avf ; \n ByteIOContext * bc = & s -> pb ; \n int64_t end ; \n uint64_t tmp ; \n int i ; \n AVRational time_base ; \n nut -> last_syncpoint_pos = url_ftell ( bc ) - 8 ; \n end = get_packetheader ( nut , bc , 1 ) ; \n end += url_ftell ( bc ) - 4 ; \n tmp = get_v ( bc ) ; \n get_v ( bc ) ; \n time_base = nut -> time_base [ tmp % nut -> time_base_count ] ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n nut -> stream [ i ] . last_pts = av_rescale_rnd ( \n tmp / nut -> time_base_count , \n time_base . num * ( int64_t ) nut -> stream [ i ] . time_base . den , \n time_base . den * ( int64_t ) nut -> stream [ i ] . time_base . num , \n AV_ROUND_DOWN ) ; \n } \n if ( skip_reserved ( bc , end ) || check_checksum ( bc ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 8583}
{"project": "FFmpeg", "commit_id": "2c2f25eb8920129ef3cfe6da2e1cefdedc485965", "target": 1, "func": "static void free_texture ( void * opaque , uint8_t * data ) \n { \n ID3D11Texture2D_Release ( ( ID3D11Texture2D * ) opaque ) ; \n }", "idx": 8585}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static int configure_filtergraph ( FilterGraph * fg ) \n { \n return fg -> graph_desc ? configure_complex_filter ( fg ) : configure_video_filters ( fg ) ; \n }", "idx": 8597}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8torgb15 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 8598}
{"project": "FFmpeg", "commit_id": "5eb901cfec4a1bca4d961c6eb6889a91a87031ca", "target": 1, "func": "static int request_frame ( AVFilterLink * outlink ) \n { \n AVFilterBufferRef * outpicref ; \n MovieContext * movie = outlink -> src -> priv ; \n int ret ; \n if ( movie -> is_done ) \n return AVERROR_EOF ; \n if ( ( ret = movie_get_frame ( outlink ) ) < 0 ) \n return ret ; \n outpicref = avfilter_ref_buffer ( movie -> picref , ~ 0 ) ; \n avfilter_start_frame ( outlink , outpicref ) ; \n avfilter_draw_slice ( outlink , 0 , outlink -> h , 1 ) ; \n avfilter_end_frame ( outlink ) ; \n return 0 ; \n }", "idx": 8612}
{"project": "FFmpeg", "commit_id": "3d7817048cb387de87600f2152075f78b37b60a6", "target": 1, "func": "static int can_safely_read ( GetBitContext * gb , int bits ) { \n return get_bits_left ( gb ) >= bits ; \n }", "idx": 8614}
{"project": "FFmpeg", "commit_id": "762bf6f4afa906a69366cbd125ef40fb788280de", "target": 0, "func": "void av_bsf_list_free ( AVBSFList * * lst ) \n { \n int i ; \n if ( * lst ) \n return ; \n for ( i = 0 ; i < ( * lst ) -> nb_bsfs ; ++ i ) \n av_bsf_free ( & ( * lst ) -> bsfs [ i ] ) ; \n av_free ( ( * lst ) -> bsfs ) ; \n av_freep ( lst ) ; \n }", "idx": 8628}
{"project": "FFmpeg", "commit_id": "386aee6864c5cfc438785d2421b2f056450da014", "target": 0, "func": "static av_cold int vsink_init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n av_unused AVBufferSinkParams  * params ; \n if ( ! opaque ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } else { \n #if FF_API_OLD_VSINK_API  \n  \n  buf -> pixel_fmts = ( const enum PixelFormat * ) opaque ; \n #else \n params = ( AVBufferSinkParams * ) opaque ; \n buf -> pixel_fmts = params -> pixel_fmts ; \n #endif \n } \n return common_init ( ctx ) ; \n }", "idx": 8652}
{"project": "FFmpeg", "commit_id": "ac47e014bbaf5163871a8beb7522015e0bc27615", "target": 0, "func": "int ff_adts_write_frame_header ( ADTSContext * ctx , \n uint8_t * buf , int size , int pce_size ) \n { \n PutBitContext pb ; \n init_put_bits ( & pb , buf , ADTS_HEADER_SIZE ) ; \n put_bits ( & pb , 12 , 0xfff ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 2 , 0 ) ; \n put_bits ( & pb , 1 , 1 ) ; \n put_bits ( & pb , 2 , ctx -> objecttype ) ; \n put_bits ( & pb , 4 , ctx -> sample_rate_index ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 3 , ctx -> channel_conf ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 13 , ADTS_HEADER_SIZE + size + pce_size ) ; \n put_bits ( & pb , 11 , 0x7ff ) ; \n put_bits ( & pb , 2 , 0 ) ; \n flush_put_bits ( & pb ) ; \n return 0 ; \n }", "idx": 8653}
{"project": "FFmpeg", "commit_id": "72b9537d8886f679494651df517dfed9b420cf1f", "target": 0, "func": "static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) \n { \n const uint8_t * frame_start = frame ; \n const uint8_t * frame_end = frame + width * height ; \n int mask = 0x10000 , bitbuf = 0 ; \n int i , v , offset , count , segments ; \n segments = bytestream2_get_le16 ( gb ) ; \n while ( segments -- ) { \n if ( bytestream2_get_bytes_left ( gb ) < 2 ) \n return -1 ; \n if ( mask == 0x10000 ) { \n bitbuf = bytestream2_get_le16u ( gb ) ; \n mask = 1 ; \n } \n if ( frame_end - frame < 2 ) \n return -1 ; \n if ( bitbuf & mask ) { \n v = bytestream2_get_le16 ( gb ) ; \n offset = ( v & 0x1FFF ) << 2 ; \n count = ( ( v >> 13 ) + 2 ) << 1 ; \n if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) \n return -1 ; \n for ( i = 0 ; i < count ; i ++ ) { \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; \n frame += 2 ; \n } \n } else if ( bitbuf & ( mask << 1 ) ) { \n frame += bytestream2_get_le16 ( gb ) * 2 ; \n } else { \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; \n frame += 2 ; \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; \n frame += 2 ; \n } \n mask <<= 2 ; \n } \n return 0 ; \n }", "idx": 8665}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int ac3_parse_sync_info ( AC3DecodeContext * ctx ) \n { \n ac3_sync_info * sync_info = & ctx -> sync_info ; \n GetBitContext * gb = & ctx -> gb ; \n sync_info -> sync_word = get_bits ( gb , 16 ) ; \n sync_info -> crc1 = get_bits ( gb , 16 ) ; \n sync_info -> fscod = get_bits ( gb , 2 ) ; \n if ( sync_info -> fscod == 0x03 ) \n return -1 ; \n sync_info -> frmsizecod = get_bits ( gb , 6 ) ; \n if ( sync_info -> frmsizecod >= 0x38 ) \n return -1 ; \n sync_info -> sampling_rate = ac3_freqs [ sync_info -> fscod ] ; \n sync_info -> bit_rate = ac3_bitratetab [ sync_info -> frmsizecod >> 1 ] ; \n return 0 ; \n }", "idx": 8676}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_metadata_ext ( DBEContext * s ) \n { \n if ( s -> mtd_ext_size ) \n skip_input ( s , s -> key_present + s -> mtd_ext_size + 1 ) ; \n return 0 ; \n }", "idx": 8691}
{"project": "FFmpeg", "commit_id": "3eedd29bd7df6f21a79e1a67a6d905049996d2ec", "target": 0, "func": "static void set_palette ( AVFrame * frame , const uint8_t * palette_buffer ) \n { \n uint32_t * palette = ( uint32_t * ) frame -> data [ 1 ] ; \n int a ; \n for ( a = 0 ; a < 256 ; a ++ ) { \n palette [ a ] = AV_RB24 ( & palette_buffer [ a * 3 ] ) * 4 ; \n } \n frame -> palette_has_changed = 1 ; \n }", "idx": 8704}
{"project": "FFmpeg", "commit_id": "345e7072ab867ee1e56cbf857dbc93d37f168294", "target": 1, "func": "int avfilter_graph_config ( AVFilterGraph * graphctx , void * log_ctx ) \n { \n int ret ; \n if ( ( ret = graph_check_validity ( graphctx , log_ctx ) ) ) \n if ( ( ret = graph_insert_fifos ( graphctx , log_ctx ) ) < 0 ) \n if ( ( ret = graph_config_formats ( graphctx , log_ctx ) ) ) \n if ( ( ret = graph_config_links ( graphctx , log_ctx ) ) ) \n if ( ( ret = graph_config_pointers ( graphctx , log_ctx ) ) ) \n return 0 ; \n }", "idx": 8717}
{"project": "FFmpeg", "commit_id": "2820c9dfaa1f4093fea471665fdbef9ca7080bcd", "target": 0, "func": "static void process_param ( float * bc , EqParameter * param , float fs ) \n { \n int i ; \n for ( i = 0 ; i <= NBANDS ; i ++ ) { \n param [ i ] . lower = i == 0 ? 0 : bands [ i - 1 ] ; \n param [ i ] . upper = i == NBANDS - 1 ? fs : bands [ i ] ; \n param [ i ] . gain = bc [ i ] ; \n } \n }", "idx": 8718}
{"project": "FFmpeg", "commit_id": "aff6cebb41669a25008f76ce3c310001613e6263", "target": 1, "func": "static int set_expr ( AVExpr * * pexpr , const char * expr , void * log_ctx ) \n { \n int ret ; \n if ( * pexpr ) \n av_expr_free ( * pexpr ) ; \n * pexpr = NULL ; \n ret = av_expr_parse ( pexpr , expr , var_names , \n NULL , NULL , NULL , NULL , 0 , log_ctx ) ; \n if ( ret < 0 ) \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , expr ) ; \n return ret ; \n }", "idx": 8722}
{"project": "FFmpeg", "commit_id": "32f0c658283e2451add02a6ee5c719efa877a34c", "target": 0, "func": "static void vc1_inv_trans_4x4_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n register int t1 , t2 , t3 , t4 ; \n DCTELEM * src , * dst ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n src = block ; \n dst = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t1 = 17 * ( src [ 0 ] + src [ 2 ] ) + 4 ; \n t2 = 17 * ( src [ 0 ] - src [ 2 ] ) + 4 ; \n t3 = 22 * src [ 1 ] + 10 * src [ 3 ] ; \n t4 = 22 * src [ 3 ] - 10 * src [ 1 ] ; \n dst [ 0 ] = ( t1 + t3 ) >> 3 ; \n dst [ 1 ] = ( t2 - t4 ) >> 3 ; \n dst [ 2 ] = ( t2 + t4 ) >> 3 ; \n dst [ 3 ] = ( t1 - t3 ) >> 3 ; \n src += 8 ; \n dst += 8 ; \n } \n src = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t1 = 17 * ( src [ 0 ] + src [ 16 ] ) + 64 ; \n t2 = 17 * ( src [ 0 ] - src [ 16 ] ) + 64 ; \n t3 = 22 * src [ 8 ] + 10 * src [ 24 ] ; \n t4 = 22 * src [ 24 ] - 10 * src [ 8 ] ; \n dest [ 0 * linesize ] = cm [ dest [ 0 * linesize ] + ( ( t1 + t3 ) >> 7 ) ] ; \n dest [ 1 * linesize ] = cm [ dest [ 1 * linesize ] + ( ( t2 - t4 ) >> 7 ) ] ; \n dest [ 2 * linesize ] = cm [ dest [ 2 * linesize ] + ( ( t2 + t4 ) >> 7 ) ] ; \n dest [ 3 * linesize ] = cm [ dest [ 3 * linesize ] + ( ( t1 - t3 ) >> 7 ) ] ; \n src ++ ; \n dest ++ ; \n } \n }", "idx": 8729}
{"project": "FFmpeg", "commit_id": "ea8de109af46ae8e6751217977ae8f7becf94ba5", "target": 0, "func": "AVFilterFormats * avfilter_make_all_channel_layouts ( void ) \n { \n static int64_t chlayouts [ ] = { \n AV_CH_LAYOUT_MONO , \n AV_CH_LAYOUT_STEREO , \n AV_CH_LAYOUT_4POINT0 , \n AV_CH_LAYOUT_QUAD , \n AV_CH_LAYOUT_5POINT0 , \n AV_CH_LAYOUT_5POINT0_BACK , \n AV_CH_LAYOUT_5POINT1 , \n AV_CH_LAYOUT_5POINT1_BACK , \n AV_CH_LAYOUT_5POINT1 | AV_CH_LAYOUT_STEREO_DOWNMIX , \n AV_CH_LAYOUT_7POINT1 , \n AV_CH_LAYOUT_7POINT1_WIDE , \n AV_CH_LAYOUT_7POINT1 | AV_CH_LAYOUT_STEREO_DOWNMIX , \n -1 , \n } ; \n return avfilter_make_format64_list ( chlayouts ) ; \n }", "idx": 8731}
{"project": "FFmpeg", "commit_id": "8689d87ac61a412b88326c4d31a8f3375926f869", "target": 1, "func": "static int matroska_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MatroskaDemuxContext * matroska = s -> priv_data ; \n int ret = 0 ; \n while ( ! ret && matroska_deliver_packet ( matroska , pkt ) ) { \n if ( matroska -> done ) \n return AVERROR_EOF ; \n ret = matroska_parse_cluster ( matroska ) ; \n } \n return ret ; \n }", "idx": 8732}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int replaygain_export ( AVStream * st , \n const uint8_t * track_gain , const uint8_t * track_peak , \n const uint8_t * album_gain , const uint8_t * album_peak ) \n { \n AVPacketSideData * sd , * tmp ; \n AVReplayGain * replaygain ; \n uint8_t * data ; \n int32_t tg , ag ; \n uint32_t tp , ap ; \n tg = parse_gain ( track_gain ) ; \n ag = parse_gain ( album_gain ) ; \n tp = parse_peak ( track_peak ) ; \n ap = parse_peak ( album_peak ) ; \n if ( tg == INT32_MIN && ag == INT32_MIN ) \n return 0 ; \n replaygain = av_mallocz ( sizeof ( * replaygain ) ) ; \n if ( ! replaygain ) \n return AVERROR ( ENOMEM ) ; \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n av_freep ( & replaygain ) ; \n return AVERROR ( ENOMEM ) ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = AV_PKT_DATA_REPLAYGAIN ; \n sd -> data = ( uint8_t * ) replaygain ; \n sd -> size = sizeof ( * replaygain ) ; \n replaygain -> track_gain = tg ; \n replaygain -> track_peak = tp ; \n replaygain -> album_gain = ag ; \n replaygain -> album_peak = ap ; \n return 0 ; \n }", "idx": 8737}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int bytes_left ( ByteIOContext * bc ) \n { \n return bc -> buf_end - bc -> buf_ptr ; \n }", "idx": 8738}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "static av_always_inline void thread_park_workers ( ThreadContext * c , int thread_count ) \n { \n while ( c -> current_job != thread_count + c -> job_count ) \n pthread_cond_wait ( & c -> last_job_cond , & c -> current_job_lock ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n }", "idx": 8740}
{"project": "FFmpeg", "commit_id": "a4fd95b5d511384ed3ce388d8d20a16b1c4c0530", "target": 0, "func": "int ff_h264_check_intra4x4_pred_mode ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n static const int8_t top [ 12 ] = { -1 , 0 , LEFT_DC_PRED , -1 , -1 , -1 , -1 , -1 , 0 } ; \n static const int8_t left [ 12 ] = { 0 , -1 , TOP_DC_PRED , 0 , -1 , -1 , -1 , 0 , -1 , DC_128_PRED } ; \n int i ; \n if ( ! ( h -> top_samples_available & 0x8000 ) ) { \n for ( i = 0 ; i < 4 ; i ++ ) { \n int status = top [ h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + i ] ] ; \n if ( status < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , status , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } else if ( status ) { \n h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + i ] = status ; \n } \n } \n } \n if ( ( h -> left_samples_available & 0x8888 ) != 0x8888 ) { \n static const int mask [ 4 ] = { 0x8000 , 0x2000 , 0x80 , 0x20 } ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( ! ( h -> left_samples_available & mask [ i ] ) ) { \n int status = left [ h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] ] ; \n if ( status < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , status , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } else if ( status ) { \n h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] = status ; \n } \n } \n } \n } \n return 0 ; \n }", "idx": 8741}
{"project": "FFmpeg", "commit_id": "52a2c17ec006282f388071a831dfb21288611253", "target": 0, "func": "RefPicList * ff_hevc_get_ref_list ( HEVCContext * s , HEVCFrame * ref , int x0 , int y0 ) \n { \n if ( x0 < 0 || y0 < 0 ) { \n return s -> ref -> refPicList ; \n } else { \n int x_cb = x0 >> s -> sps -> log2_ctb_size ; \n int y_cb = y0 >> s -> sps -> log2_ctb_size ; \n int pic_width_cb = ( s -> sps -> width + ( 1 << s -> sps -> log2_ctb_size ) - 1 ) >> \n s -> sps -> log2_ctb_size ; \n int ctb_addr_ts = s -> pps -> ctb_addr_rs_to_ts [ y_cb * pic_width_cb + x_cb ] ; \n return ( RefPicList * ) ref -> rpl_tab [ ctb_addr_ts ] ; \n } \n }", "idx": 8748}
{"project": "FFmpeg", "commit_id": "937cfebd72d30e617591c666ea4854a3898a64b2", "target": 0, "func": "static av_cold void uninit ( AVFilterContext * ctx ) \n { \n EvalContext * eval = ctx -> priv ; \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n av_expr_free ( eval -> expr [ i ] ) ; \n eval -> expr [ i ] = NULL ; \n } \n }", "idx": 8759}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_packets ( AVFormatContext * fmt_ctx ) \n { \n AVPacket pkt ; \n av_init_packet ( & pkt ) ; \n while ( ! av_read_frame ( fmt_ctx , & pkt ) ) \n show_packet ( fmt_ctx , & pkt ) ; \n }", "idx": 8766}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static int div_round ( int dividend , int divisor ) \n { \n if ( dividend > 0 ) \n return ( dividend + ( divisor >> 1 ) ) / divisor ; \n else \n return - ( ( - dividend + ( divisor >> 1 ) ) / divisor ) ; \n }", "idx": 8769}
{"project": "FFmpeg", "commit_id": "81c1657a593b1c0f8e46fca00ead1d30ee1cd418", "target": 0, "func": "static int dvdsub_parse ( AVCodecParserContext * s , \n AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n DVDSubParseContext * pc = s -> priv_data ; \n if ( pc -> packet_index == 0 ) { \n if ( buf_size < 2 ) \n return buf_size ; \n pc -> packet_len = AV_RB16 ( buf ) ; \n if ( pc -> packet_len == 0 ) \n pc -> packet_len = AV_RB32 ( buf + 2 ) ; \n av_freep ( & pc -> packet ) ; \n pc -> packet = av_malloc ( pc -> packet_len ) ; \n } \n if ( pc -> packet ) { \n if ( pc -> packet_index + buf_size <= pc -> packet_len ) { \n memcpy ( pc -> packet + pc -> packet_index , buf , buf_size ) ; \n pc -> packet_index += buf_size ; \n if ( pc -> packet_index >= pc -> packet_len ) { \n * poutbuf = pc -> packet ; \n * poutbuf_size = pc -> packet_len ; \n pc -> packet_index = 0 ; \n return buf_size ; \n } \n } else { \n pc -> packet_index = 0 ; \n } \n } \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n }", "idx": 8782}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "uint32_t avpriv_fmt_ff2v4l ( enum AVPixelFormat pix_fmt , enum AVCodecID codec_id ) \n { \n int i ; \n for ( i = 0 ; avpriv_fmt_conversion_table [ i ] . codec_id != AV_CODEC_ID_NONE ; i ++ ) { \n if ( ( codec_id == AV_CODEC_ID_NONE || \n avpriv_fmt_conversion_table [ i ] . codec_id == codec_id ) && \n ( pix_fmt == AV_PIX_FMT_NONE || \n avpriv_fmt_conversion_table [ i ] . ff_fmt == pix_fmt ) ) { \n return avpriv_fmt_conversion_table [ i ] . v4l2_fmt ; \n } \n } \n return 0 ; \n }", "idx": 8786}
{"project": "FFmpeg", "commit_id": "5f68a91be242c05bdd5aeffd74b36a1e6c782dd5", "target": 0, "func": "int avfilter_default_config_output_link ( AVFilterLink * link ) \n { \n if ( link -> src -> input_count && link -> src -> inputs [ 0 ] ) { \n if ( link -> type == AVMEDIA_TYPE_VIDEO ) { \n link -> w = link -> src -> inputs [ 0 ] -> w ; \n link -> h = link -> src -> inputs [ 0 ] -> h ; \n link -> time_base = link -> src -> inputs [ 0 ] -> time_base ; \n } else if ( link -> type == AVMEDIA_TYPE_AUDIO ) { \n link -> channel_layout = link -> src -> inputs [ 0 ] -> channel_layout ; \n link -> sample_rate = link -> src -> inputs [ 0 ] -> sample_rate ; \n } \n } else { \n return -1 ; \n } \n return 0 ; \n }", "idx": 8787}
{"project": "FFmpeg", "commit_id": "54a5c7193be19ad781a1df539bd120c3d8987251", "target": 0, "func": "static int mov_seek_stream ( AVStream * st , int64_t timestamp , int flags ) \n { \n MOVStreamContext * sc = st -> priv_data ; \n int sample , time_sample ; \n int i ; \n sample = av_index_search_timestamp ( st , timestamp , flags ) ; \n dprintf ( st -> codec , \" \" PRId64 \" \\n \" , st -> index , timestamp , sample ) ; \n if ( sample < 0 ) \n return -1 ; \n sc -> current_sample = sample ; \n dprintf ( st -> codec , \" \\n \" , st -> index , sc -> current_sample ) ; \n if ( sc -> ctts_data ) { \n time_sample = 0 ; \n for ( i = 0 ; i < sc -> ctts_count ; i ++ ) { \n time_sample += sc -> ctts_data [ i ] . count ; \n if ( time_sample >= sc -> current_sample ) { \n sc -> sample_to_ctime_index = i ; \n sc -> sample_to_ctime_sample = time_sample - sc -> current_sample ; \n break ; \n } \n } \n } \n return sample ; \n }", "idx": 8788}
{"project": "FFmpeg", "commit_id": "98b3f17bd7182f4fbf318e09068bc19457a82d69", "target": 0, "func": "static int find_image_range ( int * pfirst_index , int * plast_index , \n const char * path ) \n { \n char buf [ 1024 ] ; \n int range , last_index , range1 , first_index ; \n for ( first_index = 0 ; first_index < 5 ; first_index ++ ) { \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , first_index ) < 0 ) { \n * pfirst_index = \n * plast_index = 1 ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n return 0 ; \n return -1 ; \n } \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n break ; \n } \n if ( first_index == 5 ) \n goto fail ; \n last_index = first_index ; \n for ( ; ; ) { \n range = 0 ; \n for ( ; ; ) { \n if ( ! range ) \n range1 = 1 ; \n else \n range1 = 2 * range ; \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , \n last_index + range1 ) < 0 ) \n goto fail ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) <= 0 ) \n break ; \n range = range1 ; \n if ( range >= ( 1 << 30 ) ) \n goto fail ; \n } \n if ( ! range ) \n break ; \n last_index += range ; \n } \n * pfirst_index = first_index ; \n * plast_index = last_index ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 8798}
{"project": "FFmpeg", "commit_id": "6369ba3c9cc74becfaad2a8882dff3dd3e7ae3c0", "target": 0, "func": "av_cold void ff_MPV_common_init_x86 ( MpegEncContext * s ) \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( cpu_flags & AV_CPU_FLAG_MMX ) { \n s -> dct_unquantize_h263_intra = dct_unquantize_h263_intra_mmx ; \n s -> dct_unquantize_h263_inter = dct_unquantize_h263_inter_mmx ; \n s -> dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_mmx ; \n s -> dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_mmx ; \n if ( ! ( s -> flags & CODEC_FLAG_BITEXACT ) ) \n s -> dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_mmx ; \n s -> dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_mmx ; \n if ( cpu_flags & AV_CPU_FLAG_SSE2 ) { \n s -> denoise_dct = denoise_dct_sse2 ; \n } else { \n s -> denoise_dct = denoise_dct_mmx ; \n } \n } \n #endif \n }", "idx": 8799}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_extradata ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n uint64_t size ; \n uint8_t * buf ; \n int err ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE ; \n if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX ) \n return AVERROR_INVALIDDATA ; \n if ( ( err = av_reallocp ( & st -> codec -> extradata , size ) ) < 0 ) { \n st -> codec -> extradata_size = 0 ; \n return err ; \n } \n buf = st -> codec -> extradata + st -> codec -> extradata_size ; \n st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE ; \n AV_WB32 ( buf , atom . size + 8 ) ; \n AV_WL32 ( buf + 4 , atom . type ) ; \n avio_read ( pb , buf + 8 , atom . size ) ; \n return 0 ; \n }", "idx": 8810}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr32 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n #ifdef WORDS_BIGENDIAN \n * d ++ = 0 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n #else \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = 0 ; \n #endif \n } \n }", "idx": 8820}
{"project": "FFmpeg", "commit_id": "b3415e4c5f9205820fd6c9211ad50a4df2692a36", "target": 1, "func": "static inline int ff_fast_malloc ( void * ptr , unsigned int * size , size_t min_size , int zero_realloc ) \n { \n void * val ; \n if ( min_size < * size ) \n return 0 ; \n min_size = FFMAX ( 17 * min_size / 16 + 32 , min_size ) ; \n av_freep ( ptr ) ; \n val = zero_realloc ? av_mallocz ( min_size ) : av_malloc ( min_size ) ; \n memcpy ( ptr , & val , sizeof ( val ) ) ; \n if ( ! val ) \n min_size = 0 ; \n * size = min_size ; \n return 1 ; \n }", "idx": 8821}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_float_dsp_init_x86 ( AVFloatDSPContext * fdsp ) \n { \n #if HAVE_YASM  \n  \n  int mm_flags = av_get_cpu_flags ( ) ; \n if ( mm_flags & AV_CPU_FLAG_SSE && HAVE_SSE ) { \n fdsp -> vector_fmul = ff_vector_fmul_sse ; \n fdsp -> vector_fmac_scalar = ff_vector_fmac_scalar_sse ; \n } \n if ( mm_flags & AV_CPU_FLAG_AVX && HAVE_AVX ) { \n fdsp -> vector_fmul = ff_vector_fmul_avx ; \n fdsp -> vector_fmac_scalar = ff_vector_fmac_scalar_avx ; \n } \n #endif \n }", "idx": 8823}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_float ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j ; \n int w = cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) { \n float * datap = & comp -> f_data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( y + j ) + x ] ; \n int * src = t1 -> data [ j ] ; \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = src [ i ] * band -> f_stepsize ; \n } \n }", "idx": 8824}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_end ( AVCodecContext * avctx ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n int ret ; \n ret = ff_v4l2_context_set_status ( & s -> output , VIDIOC_STREAMOFF ) ; \n if ( ret ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> output . name ) ; \n ret = ff_v4l2_context_set_status ( & s -> capture , VIDIOC_STREAMOFF ) ; \n if ( ret ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> capture . name ) ; \n ff_v4l2_context_release ( & s -> output ) ; \n if ( atomic_load ( & s -> refcount ) ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ff_v4l2_context_release ( & s -> capture ) ; \n sem_destroy ( & s -> refsync ) ; \n if ( close ( s -> fd ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> devname , av_err2str ( AVERROR ( errno ) ) ) ; \n s -> fd = -1 ; \n return 0 ; \n }", "idx": 8828}
{"project": "FFmpeg", "commit_id": "9e2dabed4a7bf21e3e0c0f4ddc895f8ed90fa839", "target": 1, "func": "AVIOContext * avio_alloc_context ( \n unsigned char * buffer , \n int buffer_size , \n int write_flag , \n void * opaque , \n int ( * read_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int ( * write_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int64_t ( * seek ) ( void * opaque , int64_t offset , int whence ) ) \n { \n AVIOContext * s = av_mallocz ( sizeof ( AVIOContext ) ) ; \n ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , \n read_packet , write_packet , seek ) ; \n return s ; \n }", "idx": 8867}
{"project": "FFmpeg", "commit_id": "c9fe0caf7a1abde7ca0b1a359f551103064867b1", "target": 0, "func": "static void FUNC ( transquant_bypass16x16 ) ( uint8_t * _dst , int16_t * coeffs , \n ptrdiff_t stride ) \n { \n int x , y ; \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n for ( x = 0 ; x < 16 ; x ++ ) { \n dst [ x ] += * coeffs ; \n coeffs ++ ; \n } \n dst += stride ; \n } \n }", "idx": 8877}
{"project": "FFmpeg", "commit_id": "e2193b53eab9f207544a75ebaf51871b7a1a7931", "target": 0, "func": "static void set_stream_info_from_input_stream ( AVStream * st , struct playlist * pls , AVStream * ist ) \n { \n avcodec_parameters_copy ( st -> codecpar , ist -> codecpar ) ; \n if ( pls -> is_id3_timestamped ) \n avpriv_set_pts_info ( st , 33 , 1 , MPEG_TIME_BASE ) ; \n else \n avpriv_set_pts_info ( st , ist -> pts_wrap_bits , ist -> time_base . num , ist -> time_base . den ) ; \n st -> internal -> need_context_update = 1 ; \n }", "idx": 8880}
{"project": "FFmpeg", "commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "target": 1, "func": "void ff_rtp_send_h264 ( AVFormatContext * s1 , const uint8_t * buf1 , int size ) \n { \n const uint8_t * r , * end = buf1 + size ; \n RTPMuxContext * s = s1 -> priv_data ; \n s -> timestamp = s -> cur_timestamp ; \n s -> buf_ptr = s -> buf ; \n if ( s -> nal_length_size ) \n r = ff_avc_mp4_find_startcode ( buf1 , end , s -> nal_length_size ) ? buf1 : end ; \n else \n r = ff_avc_find_startcode ( buf1 , end ) ; \n while ( r < end ) { \n const uint8_t * r1 ; \n if ( s -> nal_length_size ) { \n r1 = ff_avc_mp4_find_startcode ( r , end , s -> nal_length_size ) ; \n if ( ! r1 ) \n r1 = end ; \n r += s -> nal_length_size ; \n } else { \n while ( ! * ( r ++ ) ) ; \n r1 = ff_avc_find_startcode ( r , end ) ; \n } \n nal_send ( s1 , r , r1 - r , r1 == end ) ; \n r = r1 ; \n } \n flush_buffered ( s1 , 1 ) ; \n }", "idx": 8882}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void idct4col_put ( uint8_t * dest , int line_size , const DCTELEM * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 2 ] ; \n a2 = col [ 8 * 4 ] ; \n a3 = col [ 8 * 6 ] ; \n c0 = ( ( a0 + a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( ( a0 - a2 ) << ( CN_SHIFT - 1 ) ) + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = cm [ ( c0 + c1 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 + c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c2 - c3 ) >> C_SHIFT ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ ( c0 - c1 ) >> C_SHIFT ] ; \n }", "idx": 8883}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static inline void writer_print_string ( WriterContext * wctx , \n const char * key , const char * val ) \n { \n wctx -> writer -> print_string ( wctx , key , val ) ; \n wctx -> nb_item ++ ; \n }", "idx": 8886}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int cinvideo_decode_init ( AVCodecContext * avctx ) \n { \n CinVideoContext * cin = avctx -> priv_data ; \n unsigned int i ; \n cin -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n cin -> frame . data [ 0 ] = NULL ; \n cin -> bitmap_size = avctx -> width * avctx -> height ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n cin -> bitmap_table [ i ] = av_mallocz ( cin -> bitmap_size ) ; \n if ( ! cin -> bitmap_table [ i ] ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n return 0 ; \n }", "idx": 8887}
{"project": "FFmpeg", "commit_id": "8976ef7aec4c62e41a0abb50d2bf4dbfa3508e2a", "target": 0, "func": "static int add_file ( AVFormatContext * avf , char * filename , ConcatFile * * rfile , \n unsigned * nb_files_alloc ) \n { \n ConcatContext * cat = avf -> priv_data ; \n ConcatFile * file ; \n char * url ; \n size_t url_len ; \n url_len = strlen ( avf -> filename ) + strlen ( filename ) + 16 ; \n if ( ! ( url = av_malloc ( url_len ) ) ) \n return AVERROR ( ENOMEM ) ; \n ff_make_absolute_url ( url , url_len , avf -> filename , filename ) ; \n av_free ( filename ) ; \n if ( cat -> nb_files >= * nb_files_alloc ) { \n unsigned n = FFMAX ( * nb_files_alloc * 2 , 16 ) ; \n ConcatFile * new_files ; \n if ( n <= cat -> nb_files || n > SIZE_MAX / sizeof ( * cat -> files ) || \n ! ( new_files = av_realloc ( cat -> files , n * sizeof ( * cat -> files ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n cat -> files = new_files ; \n * nb_files_alloc = n ; \n } \n file = & cat -> files [ cat -> nb_files ++ ] ; \n memset ( file , 0 , sizeof ( * file ) ) ; \n * rfile = file ; \n file -> url = url ; \n file -> start_time = AV_NOPTS_VALUE ; \n file -> duration = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 8888}
{"project": "FFmpeg", "commit_id": "06f4b1e37a08f3fd269ecbfeb0181129e5bfc86e", "target": 1, "func": "static double compute_target_time ( double frame_current_pts , VideoState * is ) \n { \n double delay , sync_threshold , diff ; \n delay = frame_current_pts - is -> frame_last_pts ; \n if ( delay <= 0 || delay >= 10.0 ) { \n delay = is -> frame_last_delay ; \n } else { \n is -> frame_last_delay = delay ; \n } \n is -> frame_last_pts = frame_current_pts ; \n if ( ( ( is -> av_sync_type == AV_SYNC_AUDIO_MASTER && is -> audio_st ) || \n is -> av_sync_type == AV_SYNC_EXTERNAL_CLOCK ) ) { \n diff = get_video_clock ( is ) - get_master_clock ( is ) ; \n sync_threshold = FFMAX ( AV_SYNC_THRESHOLD , delay ) ; \n if ( fabs ( diff ) < AV_NOSYNC_THRESHOLD ) { \n if ( diff <= - sync_threshold ) \n delay = 0 ; \n else if ( diff >= sync_threshold ) \n delay = 2 * delay ; \n } \n } \n is -> frame_timer += delay ; \n av_log ( NULL , AV_LOG_TRACE , \" \\n \" , \n delay , frame_current_pts , - diff ) ; \n return is -> frame_timer ; \n }", "idx": 8890}
{"project": "FFmpeg", "commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "target": 1, "func": "static int tee_write_header ( AVFormatContext * avf ) \n { \n TeeContext * tee = avf -> priv_data ; \n unsigned nb_slaves = 0 , i ; \n const char * filename = avf -> filename ; \n char * slaves [ MAX_SLAVES ] ; \n int ret ; \n while ( * filename ) { \n if ( nb_slaves == MAX_SLAVES ) { \n av_log ( avf , AV_LOG_ERROR , \" \\n \" , \n MAX_SLAVES ) ; \n ret = AVERROR_PATCHWELCOME ; \n goto fail ; \n } \n if ( ! ( slaves [ nb_slaves ++ ] = av_get_token ( & filename , slave_delim ) ) ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( strspn ( filename , slave_delim ) ) \n filename ++ ; \n } \n for ( i = 0 ; i < nb_slaves ; i ++ ) { \n if ( ( ret = open_slave ( avf , slaves [ i ] , & tee -> slaves [ i ] ) ) < 0 ) \n goto fail ; \n log_slave ( & tee -> slaves [ i ] , avf , AV_LOG_VERBOSE ) ; \n av_freep ( & slaves [ i ] ) ; \n } \n tee -> nb_slaves = nb_slaves ; \n for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { \n int j , mapped = 0 ; \n for ( j = 0 ; j < tee -> nb_slaves ; j ++ ) \n mapped += tee -> slaves [ j ] . stream_map [ i ] >= 0 ; \n if ( ! mapped ) \n av_log ( avf , AV_LOG_WARNING , \" \" \n \" \\n \" , i ) ; \n } \n return 0 ; \n fail : \n for ( i = 0 ; i < nb_slaves ; i ++ ) \n av_freep ( & slaves [ i ] ) ; \n close_slaves ( avf ) ; \n return ret ; \n }", "idx": 8895}
{"project": "FFmpeg", "commit_id": "42b6805cc1989f759f19e9d253527311741cbd3a", "target": 1, "func": "static void decode_422_bitstream ( HYuvContext * s , int count ) \n { \n int i ; \n count /= 2 ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 31 * 4 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n } \n }", "idx": 8907}
{"project": "FFmpeg", "commit_id": "95165f7c1b533c121b890fa1e82e8ed596cfc108", "target": 0, "func": "static int mov_write_stts_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n MOVStts * stts_entries ; \n uint32_t entries = -1 ; \n uint32_t atom_size ; \n int i ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO && ! track -> audio_vbr ) { \n stts_entries = av_malloc ( sizeof ( * stts_entries ) ) ; \n if ( ! stts_entries ) \n return AVERROR ( ENOMEM ) ; \n stts_entries [ 0 ] . count = track -> sample_count ; \n stts_entries [ 0 ] . duration = 1 ; \n entries = 1 ; \n } else { \n stts_entries = track -> entry ? \n av_malloc_array ( track -> entry , sizeof ( * stts_entries ) ) : \n NULL ; \n if ( ! stts_entries ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < track -> entry ; i ++ ) { \n int duration = get_cluster_duration ( track , i ) ; \n if ( i && duration == stts_entries [ entries ] . duration ) { \n stts_entries [ entries ] . count ++ ; \n } else { \n entries ++ ; \n stts_entries [ entries ] . duration = duration ; \n stts_entries [ entries ] . count = 1 ; \n } \n } \n entries ++ ; \n } \n atom_size = 16 + ( entries * 8 ) ; \n avio_wb32 ( pb , atom_size ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , entries ) ; \n for ( i = 0 ; i < entries ; i ++ ) { \n avio_wb32 ( pb , stts_entries [ i ] . count ) ; \n avio_wb32 ( pb , stts_entries [ i ] . duration ) ; \n } \n av_free ( stts_entries ) ; \n return atom_size ; \n }", "idx": 8941}
{"project": "FFmpeg", "commit_id": "dabba0c676389b73c7b324fc999da7076fae149e", "target": 0, "func": "static int v410_encode_frame ( AVCodecContext * avctx , uint8_t * buf , \n int buf_size , void * data ) \n { \n AVFrame * pic = data ; \n uint8_t * dst = buf ; \n uint16_t * y , * u , * v ; \n uint32_t val ; \n int i , j ; \n int output_size = 0 ; \n if ( buf_size < avctx -> width * avctx -> height * 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> coded_frame -> reference = 0 ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> coded_frame -> pict_type = FF_I_TYPE ; \n y = ( uint16_t * ) pic -> data [ 0 ] ; \n u = ( uint16_t * ) pic -> data [ 1 ] ; \n v = ( uint16_t * ) pic -> data [ 2 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n for ( j = 0 ; j < avctx -> width ; j ++ ) { \n val = u [ j ] << 2 ; \n val |= y [ j ] << 12 ; \n val |= v [ j ] << 22 ; \n AV_WL32 ( dst , val ) ; \n dst += 4 ; \n output_size += 4 ; \n } \n y += pic -> linesize [ 0 ] >> 1 ; \n u += pic -> linesize [ 1 ] >> 1 ; \n v += pic -> linesize [ 2 ] >> 1 ; \n } \n return output_size ; \n }", "idx": 8952}
{"project": "FFmpeg", "commit_id": "e509df4bc8eb3aebdda71b826955d581e717fb0e", "target": 0, "func": "static int compand_nodelay ( AVFilterContext * ctx , AVFrame * frame ) \n { \n CompandContext * s = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n const int channels = inlink -> channels ; \n const int nb_samples = frame -> nb_samples ; \n AVFrame * out_frame ; \n int chan , i ; \n if ( av_frame_is_writable ( frame ) ) { \n out_frame = frame ; \n } else { \n out_frame = ff_get_audio_buffer ( inlink , nb_samples ) ; \n if ( ! out_frame ) { \n av_frame_free ( & frame ) ; \n return AVERROR ( ENOMEM ) ; \n } \n av_frame_copy_props ( out_frame , frame ) ; \n } \n for ( chan = 0 ; chan < channels ; chan ++ ) { \n const double * src = ( double * ) frame -> extended_data [ chan ] ; \n double * dst = ( double * ) out_frame -> extended_data [ chan ] ; \n ChanParam * cp = & s -> channels [ chan ] ; \n for ( i = 0 ; i < nb_samples ; i ++ ) { \n update_volume ( cp , fabs ( src [ i ] ) ) ; \n dst [ i ] = av_clipd ( src [ i ] * get_volume ( s , cp -> volume ) , -1 , 1 ) ; \n } \n } \n if ( frame != out_frame ) \n av_frame_free ( & frame ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; \n }", "idx": 8974}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int mpl2_probe ( AVProbeData * p ) \n { \n int i ; \n char c ; \n int64_t start , end ; \n const unsigned char * ptr = p -> buf ; \n const unsigned char * ptr_end = ptr + p -> buf_size ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( sscanf ( ptr , \" \" SCNd64 \" \" SCNd64 \" \" , & start , & end , & c ) != 3 && \n sscanf ( ptr , \" \" SCNd64 \" \" , & start , & c ) != 2 ) \n return 0 ; \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n if ( ptr >= ptr_end ) \n return 0 ; \n } \n return AVPROBE_SCORE_MAX ; \n }", "idx": 9005}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static void toright ( unsigned char * dst [ 3 ] , unsigned char * src [ 3 ] , \n int dststride [ 3 ] , int srcstride [ 3 ] , \n int w , int h , struct vf_priv_s * p ) \n { \n int k ; \n for ( k = 0 ; k < 3 ; k ++ ) { \n unsigned char * fromL = src [ k ] ; \n unsigned char * fromR = src [ k ] ; \n unsigned char * to = dst [ k ] ; \n int src = srcstride [ k ] ; \n int dst = dststride [ k ] ; \n int ss ; \n unsigned int dd ; \n int i ; \n if ( k > 0 ) { \n i = h / 4 - p -> skipline / 2 ; \n ss = src * ( h / 4 + p -> skipline / 2 ) ; \n dd = w / 4 ; \n } else { \n i = h / 2 - p -> skipline ; \n ss = src * ( h / 2 + p -> skipline ) ; \n dd = w / 2 ; \n } \n fromR += ss ; \n for ( ; i > 0 ; i -- ) { \n int j ; \n unsigned char * t = to ; \n unsigned char * sL = fromL ; \n unsigned char * sR = fromR ; \n if ( p -> scalew == 1 ) { \n for ( j = dd ; j > 0 ; j -- ) { \n * t ++ = ( sL [ 0 ] + sL [ 1 ] ) / 2 ; \n sL += 2 ; \n } \n for ( j = dd ; j > 0 ; j -- ) { \n * t ++ = ( sR [ 0 ] + sR [ 1 ] ) / 2 ; \n sR += 2 ; \n } \n } else { \n for ( j = dd * 2 ; j > 0 ; j -- ) \n * t ++ = * sL ++ ; \n for ( j = dd * 2 ; j > 0 ; j -- ) \n * t ++ = * sR ++ ; \n } \n if ( p -> scaleh == 1 ) { \n fast_memcpy ( to + dst , to , dst ) ; \n to += dst ; \n } \n to += dst ; \n fromL += src ; \n fromR += src ; \n } \n } \n }", "idx": 9009}
{"project": "FFmpeg", "commit_id": "4b51437dccd62fc5491280db44e3c21b44aeeb3f", "target": 1, "func": "static int xan_huffman_decode ( uint8_t * dest , int dest_len , \n const uint8_t * src , int src_len ) \n { \n uint8_t byte = * src ++ ; \n uint8_t ival = byte + 0x16 ; \n const uint8_t * ptr = src + byte * 2 ; \n int ptr_len = src_len - 1 - byte * 2 ; \n uint8_t val = ival ; \n uint8_t * dest_end = dest + dest_len ; \n uint8_t * dest_start = dest ; \n int ret ; \n GetBitContext gb ; \n if ( ( ret = init_get_bits8 ( & gb , ptr , ptr_len ) ) < 0 ) \n return ret ; \n while ( val != 0x16 ) { \n unsigned idx = val - 0x17 + get_bits1 ( & gb ) * byte ; \n if ( idx >= 2 * byte ) \n return AVERROR_INVALIDDATA ; \n val = src [ idx ] ; \n if ( val < 0x16 ) { \n if ( dest >= dest_end ) \n return dest_len ; \n * dest ++ = val ; \n val = ival ; \n } \n } \n return dest - dest_start ; \n }", "idx": 9010}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_chpl ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n int64_t start ; \n int i , nb_chapters , str_len , version ; \n char str [ 256 + 1 ] ; \n if ( ( atom . size -= 5 ) < 0 ) \n return 0 ; \n version = avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n if ( version ) \n avio_rb32 ( pb ) ; \n nb_chapters = avio_r8 ( pb ) ; \n for ( i = 0 ; i < nb_chapters ; i ++ ) { \n if ( atom . size < 9 ) \n return 0 ; \n start = avio_rb64 ( pb ) ; \n str_len = avio_r8 ( pb ) ; \n if ( ( atom . size -= 9 + str_len ) < 0 ) \n return 0 ; \n avio_read ( pb , str , str_len ) ; \n str [ str_len ] = 0 ; \n avpriv_new_chapter ( c -> fc , i , ( AVRational ) { 1 , 10000000 } , start , AV_NOPTS_VALUE , str ) ; \n } \n return 0 ; \n }", "idx": 9018}
{"project": "FFmpeg", "commit_id": "78016694706776fbfe4be9533704be3180b31623", "target": 1, "func": "static av_cold int vtenc_close ( AVCodecContext * avctx ) \n { \n VTEncContext * vtctx = avctx -> priv_data ; \n if ( ! vtctx -> session ) return 0 ; \n VTCompressionSessionInvalidate ( vtctx -> session ) ; \n pthread_cond_destroy ( & vtctx -> cv_sample_sent ) ; \n pthread_mutex_destroy ( & vtctx -> lock ) ; \n CFRelease ( vtctx -> session ) ; \n vtctx -> session = NULL ; \n return 0 ; \n }", "idx": 9021}
{"project": "FFmpeg", "commit_id": "4fd21d58a72c38ab63c3a4483b420db260fa7b8d", "target": 1, "func": "static int apply_color_indexing_transform ( WebPContext * s ) \n { \n ImageContext * img ; \n ImageContext * pal ; \n int i , x , y ; \n uint8_t * p , * pi ; \n img = & s -> image [ IMAGE_ROLE_ARGB ] ; \n pal = & s -> image [ IMAGE_ROLE_COLOR_INDEXING ] ; \n if ( pal -> size_reduction > 0 ) { \n GetBitContext gb_g ; \n uint8_t * line ; \n int pixel_bits = 8 >> pal -> size_reduction ; \n line = av_malloc ( img -> frame -> linesize [ 0 ] ) ; \n if ( ! line ) \n return AVERROR ( ENOMEM ) ; \n for ( y = 0 ; y < img -> frame -> height ; y ++ ) { \n p = GET_PIXEL ( img -> frame , 0 , y ) ; \n memcpy ( line , p , img -> frame -> linesize [ 0 ] ) ; \n init_get_bits ( & gb_g , line , img -> frame -> linesize [ 0 ] * 8 ) ; \n skip_bits ( & gb_g , 16 ) ; \n i = 0 ; \n for ( x = 0 ; x < img -> frame -> width ; x ++ ) { \n p = GET_PIXEL ( img -> frame , x , y ) ; \n p [ 2 ] = get_bits ( & gb_g , pixel_bits ) ; \n i ++ ; \n if ( i == 1 << pal -> size_reduction ) { \n skip_bits ( & gb_g , 24 ) ; \n i = 0 ; \n } \n } \n } \n av_free ( line ) ; \n } \n for ( y = 0 ; y < img -> frame -> height ; y ++ ) { \n for ( x = 0 ; x < img -> frame -> width ; x ++ ) { \n p = GET_PIXEL ( img -> frame , x , y ) ; \n i = p [ 2 ] ; \n if ( i >= pal -> frame -> width ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n pi = GET_PIXEL ( pal -> frame , i , 0 ) ; \n AV_COPY32 ( p , pi ) ; \n } \n } \n return 0 ; \n }", "idx": 9023}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_compose97i_dy ( dwt_compose_t * cs , DWTELEM * buffer , int width , int height , int stride ) { \n int y = cs -> y ; \n DWTELEM * b0 = cs -> b0 ; \n DWTELEM * b1 = cs -> b1 ; \n DWTELEM * b2 = cs -> b2 ; \n DWTELEM * b3 = cs -> b3 ; \n DWTELEM * b4 = buffer + mirror ( y + 3 , height - 1 ) * stride ; \n DWTELEM * b5 = buffer + mirror ( y + 4 , height - 1 ) * stride ; \n if ( stride == width && y + 4 < height && 0 ) { \n int x ; \n for ( x = 0 ; x < width / 2 ; x ++ ) \n b5 [ x ] += 64 * 2 ; \n for ( ; x < width ; x ++ ) \n b5 [ x ] += 169 * 2 ; \n } \n { START_TIMER \n if ( b3 <= b5 )  vertical_compose97iL1 ( b3 , b4 , b5 , width ) ; \n if ( b2 <= b4 ) vertical_compose97iH1 ( b2 , b3 , b4 , width ) ; \n if ( b1 <= b3 ) vertical_compose97iL0 ( b1 , b2 , b3 , width ) ; \n if ( b0 <= b2 ) vertical_compose97iH0 ( b0 , b1 , b2 , width ) ; \n if ( width > 400 ) { \n STOP_TIMER ( \" \" )  } } \n { START_TIMER \n if ( y -1 >= 0 )  horizontal_compose97i ( b0 , width ) ; \n if ( b0 <= b2 ) horizontal_compose97i ( b1 , width ) ; \n if ( width > 400 && b0 <= b2 ) { \n STOP_TIMER ( \" \" )  } } \n cs -> b0 = b2 ; \n cs -> b1 = b3 ; \n cs -> b2 = b4 ; \n cs -> b3 = b5 ; \n cs -> y += 2 ; \n }", "idx": 9080}
{"project": "FFmpeg", "commit_id": "9db353bc4727d2a184778c110cf4ea0b9d1616cb", "target": 1, "func": "static av_cold int avisynth_load_library ( void ) { \n avs_library = av_mallocz ( sizeof ( AviSynthLibrary ) ) ; \n if ( ! avs_library ) \n return AVERROR_UNKNOWN ; \n avs_library -> library = LoadLibrary ( AVISYNTH_LIB ) ; \n if ( ! avs_library -> library ) \n goto init_fail ; \n #define LOAD_AVS_FUNC ( name , continue_on_fail )  \\ \n  \n  { \n avs_library -> name = ( void * ) GetProcAddress ( avs_library -> library , #name ) ; \n if ( ! continue_on_fail && ! avs_library -> name ) \n goto fail ; \n } \n LOAD_AVS_FUNC ( avs_bit_blt , 0 ) ; \n LOAD_AVS_FUNC ( avs_clip_get_error , 0 ) ; \n LOAD_AVS_FUNC ( avs_create_script_environment , 0 ) ; \n LOAD_AVS_FUNC ( avs_delete_script_environment , 0 ) ; \n LOAD_AVS_FUNC ( avs_get_audio , 0 ) ; \n LOAD_AVS_FUNC ( avs_get_error , 1 ) ; \n LOAD_AVS_FUNC ( avs_get_frame , 0 ) ; \n LOAD_AVS_FUNC ( avs_get_video_info , 0 ) ; \n LOAD_AVS_FUNC ( avs_invoke , 0 ) ; \n LOAD_AVS_FUNC ( avs_release_clip , 0 ) ; \n LOAD_AVS_FUNC ( avs_release_value , 0 ) ; \n LOAD_AVS_FUNC ( avs_release_video_frame , 0 ) ; \n LOAD_AVS_FUNC ( avs_take_clip , 0 ) ; \n #undef  LOAD_AVS_FUNC  \n  \n  \n  \n  atexit ( avisynth_atexit_handler ) ; \n return 0 ; \n fail : \n FreeLibrary ( avs_library -> library ) ; \n init_fail : \n av_freep ( & avs_library ) ; \n return AVERROR_UNKNOWN ; \n }", "idx": 9097}
{"project": "FFmpeg", "commit_id": "0008afc59c240271827d8a0fc747179da905050f", "target": 1, "func": "static int dv_write_header ( AVFormatContext * s ) \n { \n s -> priv_data = dv_init_mux ( s ) ; \n if ( ! s -> priv_data ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 9099}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_h_loop_filter_chroma422_msa ( uint8_t * src , \n int32_t stride , \n int32_t alpha_in , \n int32_t beta_in , \n int8_t * tc0 ) \n { \n int32_t col , tc_val ; \n int16_t out0 , out1 , out2 , out3 ; \n v16u8 alpha , beta , res ; \n alpha = ( v16u8 ) __msa_fill_b ( alpha_in ) ; \n beta = ( v16u8 ) __msa_fill_b ( beta_in ) ; \n for ( col = 0 ; col < 4 ; col ++ ) { \n tc_val = ( tc0 [ col ] - 1 ) + 1 ; \n if ( tc_val <= 0 ) { \n src += ( 4 * stride ) ; \n continue ; \n } \n AVC_LPF_H_CHROMA_422 ( src , stride , tc_val , alpha , beta , res ) ; \n out0 = __msa_copy_s_h ( ( v8i16 ) res , 0 ) ; \n out1 = __msa_copy_s_h ( ( v8i16 ) res , 1 ) ; \n out2 = __msa_copy_s_h ( ( v8i16 ) res , 2 ) ; \n out3 = __msa_copy_s_h ( ( v8i16 ) res , 3 ) ; \n STORE_HWORD ( ( src - 1 ) , out0 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out1 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out2 ) ; \n src += stride ; \n STORE_HWORD ( ( src - 1 ) , out3 ) ; \n src += stride ; \n } \n }", "idx": 9102}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_dmac_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const double * v1 , const double * src0 , double scale ) \n { \n LOCAL_ALIGNED ( 32 , double , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , double , odst ,  [ LEN ] ) ; \n int ret ; \n memcpy ( cdst , v1 , LEN * sizeof ( * v1 ) ) ; \n memcpy ( odst , v1 , LEN * sizeof ( * v1 ) ) ; \n cdsp -> vector_dmac_scalar ( cdst , src0 , scale , LEN ) ; \n fdsp -> vector_dmac_scalar ( odst , src0 , scale , LEN ) ; \n if ( ret = compare_doubles ( cdst , odst , LEN , ARBITRARY_DMAC_SCALAR_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 9103}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "static int http_connect ( URLContext * h , const char * path , const char * hoststr ) \n { \n HTTPContext * s = h -> priv_data ; \n int post , err , ch ; \n char line [ 1024 ] , * q ; \n post = h -> flags & URL_WRONLY ; \n snprintf ( s -> buffer , sizeof ( s -> buffer ) , \n \" \\r \\n \" \n \" \\r \\n \" \n \" \n * r\\ n \" \n \" \\r \\n \" \n \" \\r \\n \" , \n post ? \" \" : \" \" , \n path , \n LIBAVFORMAT_IDENT , \n hoststr ) ; \n if ( http_write ( h , s -> buffer , strlen ( s -> buffer ) ) < 0 ) \n return AVERROR_IO ; \n s -> buf_ptr = s -> buffer ; \n s -> buf_end = s -> buffer ; \n s -> line_count = 0 ; \n s -> location [ 0 ] = ' \\0 ' ; \n if ( post ) { \n sleep ( 1 ) ; \n return 0 ; \n } \n q = line ; \n for ( ; ; ) { \n ch = http_getc ( s ) ; \n if ( ch < 0 ) \n return AVERROR_IO ; \n if ( ch == ' \\n ' ) { \n if ( q > line && q [ -1 ] == ' \\r ' ) \n q -- ; \n * q = ' \\0 ' ; \n #ifdef DEBUG \n printf ( \" \\n \" , line ) ; \n #endif \n err = process_line ( s , line , s -> line_count ) ; \n if ( err < 0 ) \n return err ; \n if ( err == 0 ) \n return 0 ; \n s -> line_count ++ ; \n q = line ; \n } else { \n if ( ( q - line ) < sizeof ( line ) - 1 ) \n * q ++ = ch ; \n } \n } \n }", "idx": 9112}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "func": "static void decodeplane8 ( uint8_t * dst , const uint8_t * const buf , int buf_size , int bps , int plane ) \n { \n GetBitContext gb ; \n int i , b ; \n init_get_bits ( & gb , buf , buf_size * 8 ) ; \n for ( i = 0 ; i < ( buf_size * 8 + bps - 1 ) / bps ; i ++ ) { \n for ( b = 0 ; b < bps ; b ++ ) { \n dst [ i * bps + b ] |= get_bits1 ( & gb ) << plane ; \n } \n } \n }", "idx": 9113}
{"project": "FFmpeg", "commit_id": "baced9f5986a466c957456f5cf32a722d8b35512", "target": 0, "func": "static void mpeg_decode_sequence_extension ( MpegEncContext * s ) \n { \n int horiz_size_ext , vert_size_ext ; \n int bit_rate_ext ; \n int level , profile ; \n skip_bits ( & s -> gb , 1 ) ; \n profile = get_bits ( & s -> gb , 3 ) ; \n level = get_bits ( & s -> gb , 4 ) ; \n s -> progressive_sequence = get_bits1 ( & s -> gb ) ; \n s -> chroma_format = get_bits ( & s -> gb , 2 ) ; \n horiz_size_ext = get_bits ( & s -> gb , 2 ) ; \n vert_size_ext = get_bits ( & s -> gb , 2 ) ; \n s -> width |= ( horiz_size_ext << 12 ) ; \n s -> height |= ( vert_size_ext << 12 ) ; \n bit_rate_ext = get_bits ( & s -> gb , 12 ) ; \n s -> bit_rate += ( bit_rate_ext << 12 ) * 400 ; \n skip_bits1 ( & s -> gb ) ; \n s -> avctx -> rc_buffer_size += get_bits ( & s -> gb , 8 ) * 1024 * 16 << 10 ; \n s -> low_delay = get_bits1 ( & s -> gb ) ; \n if ( s -> flags & CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; \n s -> frame_rate_ext_n = get_bits ( & s -> gb , 2 ) ; \n s -> frame_rate_ext_d = get_bits ( & s -> gb , 5 ) ; \n dprintf ( \" \\n \" ) ; \n s -> codec_id = s -> avctx -> codec_id = CODEC_ID_MPEG2VIDEO ; \n s -> avctx -> sub_id = 2 ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , \n profile , level , s -> avctx -> rc_buffer_size , s -> bit_rate ) ; \n }", "idx": 9114}
{"project": "FFmpeg", "commit_id": "3992526b3c43278945d00fac6e2ba5cb8f810ef3", "target": 0, "func": "static void vc1_loop_filter_iblk ( MpegEncContext * s , int pq ) \n { \n int i , j ; \n if ( ! s -> first_slice_line ) \n s -> dsp . vc1_loop_filter ( s -> dest [ 0 ] , 1 , s -> linesize , 16 , pq ) ; \n s -> dsp . vc1_loop_filter ( s -> dest [ 0 ] + 8 * s -> linesize , 1 , s -> linesize , 16 , pq ) ; \n for ( i = ! s -> mb_x * 8 ; i < 16 ; i += 8 ) \n s -> dsp . vc1_loop_filter ( s -> dest [ 0 ] + i , s -> linesize , 1 , 16 , pq ) ; \n for ( j = 0 ; j < 2 ; j ++ ) { \n if ( ! s -> first_slice_line ) \n s -> dsp . vc1_loop_filter ( s -> dest [ j + 1 ] , 1 , s -> uvlinesize , 8 , pq ) ; \n if ( s -> mb_x ) \n s -> dsp . vc1_loop_filter ( s -> dest [ j + 1 ] , s -> uvlinesize , 1 , 8 , pq ) ; \n } \n }", "idx": 9116}
{"project": "FFmpeg", "commit_id": "6f1ccca4ae3b93b6a2a820a7a0e72081ab35767c", "target": 0, "func": "static int dnxhd_decode_dct_block_10 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n return dnxhd_decode_dct_block ( ctx , row , n , 6 , 8 , 4 ) ; \n }", "idx": 9117}
{"project": "FFmpeg", "commit_id": "ed412d285078c167a3a5326bcb16b2169b488943", "target": 1, "func": "static void set_sar ( TiffContext * s , unsigned tag , unsigned num , unsigned den ) \n { \n int offset = tag == TIFF_YRES ? 2 : 0 ; \n s -> res [ offset ++ ] = num ; \n s -> res [ offset ] = den ; \n if ( s -> res [ 0 ] && s -> res [ 1 ] && s -> res [ 2 ] && s -> res [ 3 ] ) \n av_reduce ( & s -> avctx -> sample_aspect_ratio . num , & s -> avctx -> sample_aspect_ratio . den , \n s -> res [ 2 ] * ( uint64_t ) s -> res [ 1 ] , s -> res [ 0 ] * ( uint64_t ) s -> res [ 3 ] , INT32_MAX ) ; \n }", "idx": 9120}
{"project": "FFmpeg", "commit_id": "423047ea3167db5dc7d7b69165e1930710adb878", "target": 1, "func": "static int glyph_enu_free ( void * opaque , void * elem ) \n { \n av_free ( elem ) ; \n return 0 ; \n }", "idx": 9123}
{"project": "FFmpeg", "commit_id": "f69f9b387624bb5e3749e74c180bd092e0dcd20c", "target": 1, "func": "static void encode_scale_factors ( AVCodecContext * avctx , AACEncContext * s , \n SingleChannelElement * sce ) \n { \n int off = sce -> sf_idx [ 0 ] , diff ; \n int i , w ; \n for ( w = 0 ; w < sce -> ics . num_windows ; w += sce -> ics . group_len [ w ] ) { \n for ( i = 0 ; i < sce -> ics . max_sfb ; i ++ ) { \n if ( ! sce -> zeroes [ w * 16 + i ] ) { \n diff = sce -> sf_idx [ w * 16 + i ] - off + SCALE_DIFF_ZERO ; \n if ( diff < 0 || diff > 120 ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n off = sce -> sf_idx [ w * 16 + i ] ; \n put_bits ( & s -> pb , ff_aac_scalefactor_bits [ diff ] , ff_aac_scalefactor_code [ diff ] ) ; \n } \n } \n } \n }", "idx": 9124}
{"project": "FFmpeg", "commit_id": "dcd913d9ed6c15ea53882894baa343695575abcd", "target": 1, "func": "static void mpegts_close_filter ( MpegTSContext * ts , MpegTSFilter * filter ) \n { \n int pid ; \n pid = filter -> pid ; \n if ( filter -> type == MPEGTS_SECTION ) \n av_freep ( & filter -> u . section_filter . section_buf ) ; \n av_free ( filter ) ; \n ts -> pids [ pid ] = NULL ; ", "idx": 9125}
{"project": "FFmpeg", "commit_id": "21c6438f2c353b4e0a5bb16bb5861fb8a799e121", "target": 0, "func": "static int ffm_is_avail_data ( AVFormatContext * s , int size ) \n { \n FFMContext * ffm = s -> priv_data ; \n int64_t pos , avail_size ; \n int len ; \n len = ffm -> packet_end - ffm -> packet_ptr ; \n if ( size <= len ) \n return 1 ; \n pos = url_ftell ( s -> pb ) ; \n if ( ! ffm -> write_index ) { \n if ( pos == ffm -> file_size ) ; \n return AVERROR_EOF ; \n avail_size = ffm -> file_size - pos ; \n } else { \n if ( pos == ffm -> write_index ) { \n return AVERROR ( EAGAIN ) ; \n } else if ( pos < ffm -> write_index ) { \n avail_size = ffm -> write_index - pos ; \n } else { \n avail_size = ( ffm -> file_size - pos ) + ( ffm -> write_index - FFM_PACKET_SIZE ) ; \n } \n } \n avail_size = ( avail_size / ffm -> packet_size ) * ( ffm -> packet_size - FFM_HEADER_SIZE ) + len ; \n if ( size <= avail_size ) \n return 1 ; \n else \n return AVERROR ( EAGAIN ) ; \n }", "idx": 9128}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_stsc ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stsc_data ) ) \n return -1 ; \n sc -> stsc_data = av_malloc ( entries * sizeof ( * sc -> stsc_data ) ) ; \n if ( ! sc -> stsc_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stsc_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> stsc_data [ i ] . first = get_be32 ( pb ) ; \n sc -> stsc_data [ i ] . count = get_be32 ( pb ) ; \n sc -> stsc_data [ i ] . id = get_be32 ( pb ) ; \n } \n return 0 ; \n }", "idx": 9129}
{"project": "FFmpeg", "commit_id": "3715d841a619f1cbc4776d9b00575dae6fb6534a", "target": 0, "func": "WINDOW_FUNC ( eight_short ) \n { \n const float * swindow = sce -> ics . use_kb_window [ 0 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n const float * pwindow = sce -> ics . use_kb_window [ 1 ] ? ff_aac_kbd_short_128 : ff_sine_128 ; \n const float * in = audio + 448 ; \n float * out = sce -> ret ; \n for ( int w = 0 ; w < 8 ; w ++ ) { \n dsp -> vector_fmul ( out , in , w ? pwindow : swindow , 128 ) ; \n out += 128 ; \n in += 128 ; \n dsp -> vector_fmul_reverse ( out , in , swindow , 128 ) ; \n out += 128 ; \n } \n }", "idx": 9133}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int udp_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVFormatContext * ic ; \n AVStream * st ; \n RTSPStream * rtsp_st ; \n fd_set rfds ; \n int fd1 , fd2 , fd_max , n , i , ret ; \n char buf [ RTP_MAX_PACKET_LENGTH ] ; \n struct timeval tv ; \n for ( ; ; ) { \n if ( rtsp_abort_req ) \n return - EIO ; \n FD_ZERO ( & rfds ) ; \n fd_max = -1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n rtsp_st = st -> priv_data ; \n ic = rtsp_st -> ic ; \n rtp_get_file_handles ( url_fileno ( & ic -> pb ) , & fd1 , & fd2 ) ; \n if ( fd1 > fd_max ) \n fd_max = fd1 ; \n FD_SET ( fd1 , & rfds ) ; \n } \n tv . tv_sec = 0 ; \n tv . tv_usec = 500000 ; \n n = select ( fd_max + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n > 0 ) { \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n rtsp_st = st -> priv_data ; \n ic = rtsp_st -> ic ; \n rtp_get_file_handles ( url_fileno ( & ic -> pb ) , & fd1 , & fd2 ) ; \n if ( FD_ISSET ( fd1 , & rfds ) ) { \n ret = url_read ( url_fileno ( & ic -> pb ) , buf , sizeof ( buf ) ) ; \n if ( ret >= 0 && \n rtp_parse_packet ( ic , pkt , buf , ret ) == 0 ) { \n pkt -> stream_index = i ; \n return ret ; \n } \n } \n } \n } \n } \n }", "idx": 9135}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void libschroedinger_handle_first_access_unit ( AVCodecContext * avctx ) \n { \n SchroDecoderParams * p_schro_params = avctx -> priv_data ; \n SchroDecoder * decoder = p_schro_params -> decoder ; \n p_schro_params -> format = schro_decoder_get_video_format ( decoder ) ; \n if ( av_image_check_size ( p_schro_params -> format -> width , \n p_schro_params -> format -> height , 0 , avctx ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n p_schro_params -> format -> width , p_schro_params -> format -> height ) ; \n avctx -> height = avctx -> width = 0 ; \n return ; \n } \n avctx -> height = p_schro_params -> format -> height ; \n avctx -> width = p_schro_params -> format -> width ; \n avctx -> pix_fmt = get_chroma_format ( p_schro_params -> format -> chroma_format ) ; \n if ( ff_get_schro_frame_format ( p_schro_params -> format -> chroma_format , \n & p_schro_params -> frame_format ) == -1 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n return ; \n } \n avctx -> framerate . num = p_schro_params -> format -> frame_rate_numerator ; \n avctx -> framerate . den = p_schro_params -> format -> frame_rate_denominator ; \n }", "idx": 9140}
{"project": "FFmpeg", "commit_id": "6dc7dd7af45aa1e341b471fd054f85ae2747775b", "target": 1, "func": "static av_cold int atrac1_decode_end ( AVCodecContext * avctx ) { \n AT1Ctx * q = avctx -> priv_data ; \n av_freep ( & q -> out_samples [ 0 ] ) ; \n ff_mdct_end ( & q -> mdct_ctx [ 0 ] ) ; \n ff_mdct_end ( & q -> mdct_ctx [ 1 ] ) ; \n ff_mdct_end ( & q -> mdct_ctx [ 2 ] ) ; \n return 0 ; \n }", "idx": 9141}
{"project": "FFmpeg", "commit_id": "7cbb32e461cdbe8b745d560c1700c711ba5933cc", "target": 1, "func": "static double block_angle ( int x , int y , int cx , int cy , MotionVector * shift ) \n { \n double a1 , a2 , diff ; \n a1 = atan2 ( y - cy , x - cx ) ; \n a2 = atan2 ( y - cy + shift -> y , x - cx + shift -> x ) ; \n diff = a2 - a1 ; \n return ( diff > M_PI ) ? diff - 2 * M_PI : \n ( diff < - M_PI ) ? diff + 2 * M_PI : \n diff ; \n }", "idx": 9143}
{"project": "FFmpeg", "commit_id": "109d30e9f1fbe4de416fcdbcc1442aaf43f85d00", "target": 0, "func": "int inet_aton ( const char * str , struct in_addr * add ) \n { \n const char * pch = str ; \n unsigned int add1 = 0 , add2 = 0 , add3 = 0 , add4 = 0 ; \n add1 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) return 0 ; \n add2 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) return 0 ; \n add3 = atoi ( pch ) ; \n pch = strpbrk ( pch , \" \" ) ; \n if ( pch == 0 || ++ pch == 0 ) return 0 ; \n add4 = atoi ( pch ) ; \n if ( ! add1 || ( add1 | add2 | add3 | add4 ) > 255 ) return 0 ; \n add -> s_addr = ( add4 << 24 ) + ( add3 << 16 ) + ( add2 << 8 ) + add1 ; \n return 1 ; \n }", "idx": 9145}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static void cdg_load_palette ( CDGraphicsContext * cc , uint8_t * data , int low ) \n { \n uint8_t r , g , b ; \n uint16_t color ; \n int i ; \n int array_offset = low ? 0 : 8 ; \n uint32_t * palette = ( uint32_t * ) cc -> frame . data [ 1 ] ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n color = ( data [ 2 * i ] << 6 ) + ( data [ 2 * i + 1 ] & 0x3F ) ; \n r = ( ( color >> 8 ) & 0x000F ) * 17 ; \n g = ( ( color >> 4 ) & 0x000F ) * 17 ; \n b = ( ( color ) & 0x000F ) * 17 ; \n palette [ i + array_offset ] = 0xFF << 24 | r << 16 | g << 8 | b ; \n } \n cc -> frame . palette_has_changed = 1 ; \n }", "idx": 9148}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred4x4_horizontal_vp8_c ( uint8_t * src , const uint8_t * topright , int stride ) { \n const int lt = src [ -1 - 1 * stride ] ; \n LOAD_LEFT_EDGE \n AV_WN32A ( src +0 * stride ,  ( ( lt + 2 * l0 + l1 + 2 ) >> 2 ) * 0x01010101 ) ; \n AV_WN32A ( src + 1 * stride , ( ( l0 + 2 * l1 + l2 + 2 ) >> 2 ) * 0x01010101 ) ; \n AV_WN32A ( src + 2 * stride , ( ( l1 + 2 * l2 + l3 + 2 ) >> 2 ) * 0x01010101 ) ; \n AV_WN32A ( src + 3 * stride , ( ( l2 + 2 * l3 + l3 + 2 ) >> 2 ) * 0x01010101 ) ; \n }", "idx": 9155}
{"project": "FFmpeg", "commit_id": "6e9bb5aa3ed0b56c484ba96bf1bb3bdd8a9741f3", "target": 1, "func": "static int packed_16bpc_bswap ( SwsContext * c , const uint8_t * src [ ] , \n int srcStride [ ] , int srcSliceY , int srcSliceH , \n uint8_t * dst [ ] , int dstStride [ ] ) \n { \n int i , j ; \n int srcstr = srcStride [ 0 ] >> 1 ; \n int dststr = dstStride [ 0 ] >> 1 ; \n uint16_t * dstPtr = ( uint16_t * ) dst [ 0 ] ; \n const uint16_t * srcPtr = ( const uint16_t * ) src [ 0 ] ; \n for ( i = 0 ; i < srcSliceH ; i ++ ) { \n for ( j = 0 ; j < srcstr ; j ++ ) { \n dstPtr [ j ] = av_bswap16 ( srcPtr [ j ] ) ; \n } \n srcPtr += srcstr ; \n dstPtr += dststr ; \n } \n return srcSliceH ; \n }", "idx": 9158}
{"project": "FFmpeg", "commit_id": "a7ba3244131d96d9ab7a99ef30dc7276efd05cc7", "target": 1, "func": "static int aac_parse_packet ( AVFormatContext * ctx , PayloadContext * data , \n AVStream * st , AVPacket * pkt , uint32_t * timestamp , \n const uint8_t * buf , int len , uint16_t seq , \n int flags ) \n { \n int ret ; \n if ( rtp_parse_mp4_au ( data , buf ) ) \n return -1 ; \n buf += data -> au_headers_length_bytes + 2 ; \n len -= data -> au_headers_length_bytes + 2 ; \n if ( ( ret = av_new_packet ( pkt , data -> au_headers [ 0 ] . size ) ) < 0 ) \n return ret ; \n memcpy ( pkt -> data , buf , data -> au_headers [ 0 ] . size ) ; \n pkt -> stream_index = st -> index ; \n return 0 ; \n }", "idx": 9164}
{"project": "FFmpeg", "commit_id": "b04bbe6b869581d572fe6b1dc351a2fd8e134cc1", "target": 1, "func": "static void RENAME ( mix6to2 ) ( SAMPLE * * out , const SAMPLE * * in , COEFF * coeffp , integer len ) { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n INTER t = in [ 2 ] [ i ] * coeffp [ 0 * 6 + 2 ] + in [ 3 ] [ i ] * coeffp [ 0 * 6 + 3 ] ; \n out [ 0 ] [ i ] = R ( t + in [ 0 ] [ i ] * ( INTER ) coeffp [ 0 * 6 + 0 ] + in [ 4 ] [ i ] * ( INTER ) coeffp [ 0 * 6 + 4 ] ) ; \n out [ 1 ] [ i ] = R ( t + in [ 1 ] [ i ] * ( INTER ) coeffp [ 1 * 6 + 1 ] + in [ 5 ] [ i ] * ( INTER ) coeffp [ 1 * 6 + 5 ] ) ; \n } \n }", "idx": 9167}
{"project": "FFmpeg", "commit_id": "5683de00e99e4be87419a97d521887f94acc937a", "target": 1, "func": "int av_strerror ( int errnum , char * errbuf , size_t errbuf_size ) \n { \n int ret = 0 , i ; \n struct error_entry * entry = NULL ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( error_entries ) ; i ++ ) { \n if ( errnum == error_entries [ i ] . num ) { \n entry = & error_entries [ i ] ; \n break ; \n } \n } \n if ( entry ) { \n av_strlcpy ( errbuf , entry -> str , errbuf_size ) ; \n } else { \n #if HAVE_STRERROR_R  \n  \n  ret = strerror_r ( AVUNERROR ( errnum ) , errbuf , errbuf_size ) ; \n #else \n ret = -1 ; \n #endif \n if ( ret < 0 ) \n snprintf ( errbuf , errbuf_size , \" \" , errnum ) ; \n } \n return ret ; \n }", "idx": 9173}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr24 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n } \n }", "idx": 9177}
{"project": "FFmpeg", "commit_id": "0c2aaa882d124f05b7bf0a4a4abba3293f4d6d84", "target": 1, "func": "static int encode_end ( AVCodecContext * avctx ) \n { \n FFV1Context * s = avctx -> priv_data ; \n common_end ( s ) ; \n return 0 ; \n }", "idx": 9183}
{"project": "FFmpeg", "commit_id": "d150a147dac67faeaf6b1f25a523ae330168ee1e", "target": 0, "func": "static void parse_presentation_segment ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n PGSSubContext * ctx = avctx -> priv_data ; \n int x , y ; \n int w = bytestream_get_be16 ( & buf ) ; \n int h = bytestream_get_be16 ( & buf ) ; \n av_dlog ( avctx , \" \\n \" , \n w , h ) ; \n if ( av_image_check_size ( w , h , 0 , avctx ) >= 0 ) \n avcodec_set_dimensions ( avctx , w , h ) ; \n buf ++ ; \n ctx -> presentation . id_number = bytestream_get_be16 ( & buf ) ; \n buf += 3 ; \n ctx -> presentation . object_number = bytestream_get_byte ( & buf ) ; \n if ( ! ctx -> presentation . object_number ) \n return ; \n buf += 4 ; \n x = bytestream_get_be16 ( & buf ) ; \n y = bytestream_get_be16 ( & buf ) ; \n av_dlog ( avctx , \" \\n \" , x , y ) ; \n if ( x > avctx -> width || y > avctx -> height ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n x , y , avctx -> width , avctx -> height ) ; \n x = 0 ; y = 0 ; \n } \n ctx -> presentation . x = x ; \n ctx -> presentation . y = y ; \n }", "idx": 9190}
{"project": "FFmpeg", "commit_id": "14e4e26559697cfdea584767be4e68474a0a9c7f", "target": 1, "func": "static int t37 ( InterplayACMContext * s , unsigned ind , unsigned col ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned i , b ; \n int n1 , n2 ; \n for ( i = 0 ; i < s -> rows ; i ++ ) { \n b = get_bits ( gb , 7 ) ; \n n1 = ( mul_2x11 [ b ] & 0x0F ) - 5 ; \n n2 = ( ( mul_2x11 [ b ] >> 4 ) & 0x0F ) - 5 ; \n set_pos ( s , i ++ , col , n1 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i , col , n2 ) ; \n return 0 ;", "idx": 9197}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( rgb24to32 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n #ifdef HAVE_MMX \n const uint8_t * mm_end ; \n #endif \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 23 ; \n __asm __volatile ( \" \" :: \" \" ( mask32 ) : \" \" ) ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * dest ) \n : \" m \" ( * s ) \n : \" memory \" ) ; \n dest += 32 ; \n s += 24 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n while ( s < end ) \n { \n #ifdef WORDS_BIGENDIAN \n * dest ++ = 0 ; \n * dest ++ = s [ 2 ] ; \n * dest ++ = s [ 1 ] ; \n * dest ++ = s [ 0 ] ; \n s += 3 ; \n #else \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = 0 ; \n #endif \n } \n }", "idx": 9199}
{"project": "FFmpeg", "commit_id": "2cc51d5025c976aa268a854df1eec86014512c8c", "target": 0, "func": "int ff_v4l2_context_set_status ( V4L2Context * ctx , int cmd ) \n { \n int type = ctx -> type ; \n int ret ; \n ret = ioctl ( ctx_to_m2mctx ( ctx ) -> fd , cmd , & type ) ; \n if ( ret < 0 ) \n return AVERROR ( errno ) ; \n ctx -> streamon = ( cmd == VIDIOC_STREAMON ) ; \n return 0 ; \n }", "idx": 9213}
{"project": "FFmpeg", "commit_id": "d468ff0fdfdd3ff8f54adea3dd1ef4b94cb8538d", "target": 1, "func": "uint32_t av_crc ( const AVCRC * ctx , uint32_t crc , const uint8_t * buffer , size_t length ) { \n const uint8_t * end = buffer + length ; \n #if ! CONFIG_SMALL  \n  \n  if ( ! ctx [ 256 ] ) \n while ( buffer < end - 3 ) { \n crc ^= le2me_32 ( * ( const uint32_t * ) buffer ) ; buffer += 4 ; \n crc = ctx [ 3 * 256 + ( crc & 0xFF ) ] \n ^ ctx [ 2 * 256 + ( ( crc >> 8 ) & 0xFF ) ] \n ^ ctx [ 1 * 256 + ( ( crc >> 16 ) & 0xFF ) ] \n ^ ctx [ 0 * 256 + ( ( crc >> 24 ) ) ] ; \n } \n #endif \n while ( buffer < end ) \n crc = ctx [ ( ( uint8_t ) crc ) ^ * buffer ++ ] ^ ( crc >> 8 ) ; \n return crc ; \n }", "idx": 9230}
{"project": "FFmpeg", "commit_id": "64b164f44abc232dbb125b36e2d00b54e1531ba7", "target": 1, "func": "static AVFilterContext * create_filter ( AVFilterGraph * ctx , int index , \n const char * name , const char * args , \n AVClass * log_ctx ) \n { \n AVFilterContext * filt ; \n AVFilter * filterdef ; \n char inst_name [ 30 ] ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , index ) ; \n filterdef = avfilter_get_by_name ( name ) ; \n if ( ! filterdef ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n filt = avfilter_open ( filterdef , inst_name ) ; \n if ( ! filt ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name ) ; \n return NULL ; \n } \n if ( avfilter_graph_add_filter ( ctx , filt ) < 0 ) \n return NULL ; \n if ( avfilter_init_filter ( filt , args , NULL ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , name , args ) ; \n return NULL ; \n } \n return filt ; \n }", "idx": 9237}
{"project": "FFmpeg", "commit_id": "502d6c0a234b10f65acb0a203aedf14de70dc555", "target": 1, "func": "static int find_tag ( ByteIOContext * pb , uint32_t tag1 ) \n { \n unsigned int tag ; \n int size ; \n for ( ; ; ) { \n if ( url_feof ( pb ) ) \n return -1 ; \n tag = get_le32 ( pb ) ; \n size = get_le32 ( pb ) ; \n if ( tag == tag1 ) \n break ; \n url_fseek ( pb , size , SEEK_CUR ) ; \n } \n if ( size < 0 ) \n size = 0x7fffffff ; \n return size ; \n }", "idx": 9239}
{"project": "FFmpeg", "commit_id": "8b47058c61af83c28231b860d46ee754ed7a9310", "target": 0, "func": "static int ass_split ( ASSSplitContext * ctx , const char * buf ) \n { \n char c , section [ 16 ] ; \n int i ; \n if ( ctx -> current_section >= 0 ) \n buf = ass_split_section ( ctx , buf ) ; \n while ( buf && * buf ) { \n if ( sscanf ( buf , \" \" , section , & c ) == 2 ) { \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ass_sections ) ; i ++ ) \n if ( ! strcmp ( section , ass_sections [ i ] . section ) ) { \n ctx -> current_section = i ; \n buf = ass_split_section ( ctx , buf ) ; \n } \n } else \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n } \n return buf ? 0 : AVERROR_INVALIDDATA ; \n }", "idx": 9245}
{"project": "FFmpeg", "commit_id": "1b539fbfe36c450a6f45706e740fd4e205b8be16", "target": 1, "func": "static int plot_cqt ( AVFilterContext * ctx ) \n { \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n ShowCQTContext * s = ctx -> priv ; \n int ret ; \n memcpy ( s -> fft_result , s -> fft_data , s -> fft_len * sizeof ( * s -> fft_data ) ) ; \n av_fft_permute ( s -> fft_ctx , s -> fft_result ) ; \n av_fft_calc ( s -> fft_ctx , s -> fft_result ) ; \n s -> fft_result [ s -> fft_len ] = s -> fft_result [ 0 ] ; \n s -> cqt_calc ( s -> cqt_result , s -> fft_result , s -> coeffs , s -> cqt_len , s -> fft_len ) ; \n process_cqt ( s ) ; \n if ( s -> sono_h ) \n s -> update_sono ( s -> sono_frame , s -> c_buf , s -> sono_idx ) ; \n if ( ! s -> sono_count ) { \n AVFrame * out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; \n if ( ! out ) \n return AVERROR ( ENOMEM ) ; \n if ( s -> bar_h ) \n s -> draw_bar ( out , s -> h_buf , s -> rcp_h_buf , s -> c_buf , s -> bar_h ) ; \n if ( s -> axis_h ) \n s -> draw_axis ( out , s -> axis_frame , s -> c_buf , s -> bar_h ) ; \n if ( s -> sono_h ) \n s -> draw_sono ( out , s -> sono_frame , s -> bar_h + s -> axis_h , s -> sono_idx ) ; \n out -> pts = s -> frame_count ; \n ret = ff_filter_frame ( outlink , out ) ; \n s -> frame_count ++ ; \n } \n s -> sono_count = ( s -> sono_count + 1 ) % s -> count ; \n if ( s -> sono_h ) \n s -> sono_idx = ( s -> sono_idx + s -> sono_h - 1 ) % s -> sono_h ; \n return ret ; \n }", "idx": 9281}
{"project": "FFmpeg", "commit_id": "347cb14b7cba7560e53f4434b419b9d8800253e7", "target": 1, "func": "static int mov_read_keys ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n uint32_t count ; \n uint32_t i ; \n if ( atom . size < 8 ) \n return 0 ; \n avio_skip ( pb , 4 ) ; \n count = avio_rb32 ( pb ) ; \n if ( count > UINT_MAX / sizeof ( * c -> meta_keys ) ) { \n av_log ( c -> fc , AV_LOG_ERROR , \n \" \\n \" , count ) ; \n return AVERROR_INVALIDDATA ; \n } \n c -> meta_keys_count = count + 1 ; \n c -> meta_keys = av_mallocz ( c -> meta_keys_count * sizeof ( * c -> meta_keys ) ) ; \n if ( ! c -> meta_keys ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 1 ; i <= count ; ++ i ) { \n uint32_t key_size = avio_rb32 ( pb ) ; \n uint32_t type = avio_rl32 ( pb ) ; \n if ( key_size < 8 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \n \" \\n \" , i , key_size ) ; \n return AVERROR_INVALIDDATA ; \n } \n key_size -= 8 ; \n if ( type != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n avio_skip ( pb , key_size ) ; \n } \n c -> meta_keys [ i ] = av_mallocz ( key_size + 1 ) ; \n if ( ! c -> meta_keys [ i ] ) \n return AVERROR ( ENOMEM ) ; \n avio_read ( pb , c -> meta_keys [ i ] , key_size ) ; \n } \n return 0 ; \n }", "idx": 9288}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static void chomp6 ( ChannelData * ctx , int16_t * output , uint8_t val , \n const uint16_t tab1 [ ] , \n const int16_t * tab2 , int tab2_stride , \n uint32_t numChannels ) \n { \n int16_t current ; \n current = tab2 [ ( ( ctx -> index & 0x7f0 ) >> 4 ) * tab2_stride + val ] ; \n if ( ( ctx -> previous ^ current ) >= 0 ) { \n ctx -> factor = FFMIN ( ctx -> factor + 506 , 32767 ) ; \n } else { \n if ( ctx -> factor - 314 < -32768 ) \n ctx -> factor = -32767 ; \n else \n ctx -> factor -= 314 ; \n } \n current = mace_broken_clip_int16 ( current + ctx -> level ) ; \n ctx -> level = ( ( current * ctx -> factor ) >> 15 ) ; \n current >>= 1 ; \n output [ 0 ] = QT_8S_2_16S ( ctx -> previous + ctx -> prev2 - \n ( ( ctx -> prev2 - current ) >> 2 ) ) ; \n output [ numChannels ] = QT_8S_2_16S ( ctx -> previous + current + \n ( ( ctx -> prev2 - current ) >> 2 ) ) ; \n ctx -> prev2 = ctx -> previous ; \n ctx -> previous = current ; \n if ( ( ctx -> index += tab1 [ val ] - ( ctx -> index >> 5 ) ) < 0 ) \n ctx -> index = 0 ; \n }", "idx": 9290}
{"project": "FFmpeg", "commit_id": "12987f89007ee82b9d3a6090085dfaef8461ab8b", "target": 1, "func": "static int gxf_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) { \n int res = 0 ; \n uint64_t pos ; \n uint64_t maxlen = 100 * 1024 * 1024 ; \n AVStream * st = s -> streams [ 0 ] ; \n int64_t start_time = s -> streams [ stream_index ] -> start_time ; \n int64_t found ; \n int idx ; \n if ( timestamp < start_time ) timestamp = start_time ; \n idx = av_index_search_timestamp ( st , timestamp - start_time , \n AVSEEK_FLAG_ANY | AVSEEK_FLAG_BACKWARD ) ; \n if ( idx < 0 ) \n return -1 ; \n pos = st -> index_entries [ idx ] . pos ; \n if ( idx < st -> nb_index_entries - 2 ) \n maxlen = st -> index_entries [ idx + 2 ] . pos - pos ; \n maxlen = FFMAX ( maxlen , 200 * 1024 ) ; \n res = avio_seek ( s -> pb , pos , SEEK_SET ) ; \n if ( res < 0 ) \n return res ; \n found = gxf_resync_media ( s , maxlen , -1 , timestamp ) ; \n if ( FFABS ( found - timestamp ) > 4 ) \n return -1 ; \n return 0 ; \n }", "idx": 9302}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "static int match_format ( const char * name , const char * names ) \n { \n const char * p ; \n int len , namelen ; \n if ( ! name || ! names ) \n return 0 ; \n namelen = strlen ( name ) ; \n while ( ( p = strchr ( names , ' ' ) ) ) { \n len = FFMAX ( p - names , namelen ) ; \n if ( ! av_strncasecmp ( name , names , len ) ) \n return 1 ; \n names = p + 1 ; \n } \n return ! av_strcasecmp ( name , names ) ; \n }", "idx": 9308}
{"project": "FFmpeg", "commit_id": "e90820d4f815c15796e642467cdddbad755212a2", "target": 1, "func": "int ff_rtp_get_payload_type ( AVFormatContext * fmt , \n AVCodecContext * codec , int idx ) \n { \n int i ; \n AVOutputFormat * ofmt = fmt ? fmt -> oformat : NULL ; \n if ( ofmt && ofmt -> priv_class && fmt -> priv_data ) { \n int64_t payload_type ; \n if ( av_opt_get_int ( fmt -> priv_data , \" \" , 0 , & payload_type ) >= 0 && \n payload_type >= 0 ) \n return ( int ) payload_type ; \n } \n for ( i = 0 ; rtp_payload_types [ i ] . pt >= 0 ; ++ i ) \n if ( rtp_payload_types [ i ] . codec_id == codec -> codec_id ) { \n if ( codec -> codec_id == AV_CODEC_ID_H263 && ( ! fmt || \n ! fmt -> oformat -> priv_class || \n ! av_opt_flag_is_set ( fmt -> priv_data , \" \" , \" \" ) ) ) \n continue ; \n if ( codec -> codec_id == AV_CODEC_ID_ADPCM_G722 && \n codec -> sample_rate == 16000 && codec -> channels == 1 ) \n return rtp_payload_types [ i ] . pt ; \n if ( codec -> codec_type == AVMEDIA_TYPE_AUDIO && \n ( ( rtp_payload_types [ i ] . clock_rate > 0 && \n codec -> sample_rate != rtp_payload_types [ i ] . clock_rate ) || \n ( rtp_payload_types [ i ] . audio_channels > 0 && \n codec -> channels != rtp_payload_types [ i ] . audio_channels ) ) ) \n continue ; \n return rtp_payload_types [ i ] . pt ; \n } \n if ( idx < 0 ) \n idx = codec -> codec_type == AVMEDIA_TYPE_AUDIO ; \n return RTP_PT_PRIVATE + idx ; \n }", "idx": 9337}
{"project": "FFmpeg", "commit_id": "bdb31942174c4673c7f212378951366e0704668d", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n QPContext * s = ctx -> priv ; \n AVBufferRef * out_qp_table_buf ; \n AVFrame * out ; \n const int8_t * in_qp_table ; \n int type , stride , ret ; \n if ( ! s -> qp_expr_str || ctx -> is_disabled ) \n return ff_filter_frame ( outlink , in ) ; \n out_qp_table_buf = av_buffer_alloc ( s -> h * s -> qstride ) ; \n if ( ! out_qp_table_buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n out = av_frame_clone ( in ) ; \n if ( ! out ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n in_qp_table = av_frame_get_qp_table ( in , & stride , & type ) ; \n av_frame_set_qp_table ( out , out_qp_table_buf , s -> qstride , type ) ; \n if ( in_qp_table ) { \n int y , x ; \n for ( y = 0 ; y < s -> h ; y ++ ) \n for ( x = 0 ; x < s -> qstride ; x ++ ) \n out_qp_table_buf -> data [ x + s -> qstride * y ] = s -> lut [ 129 + \n ( ( int8_t ) in_qp_table [ x + stride * y ] ) ] ; \n } else { \n int y , x , qp = s -> lut [ 0 ] ; \n for ( y = 0 ; y < s -> h ; y ++ ) \n for ( x = 0 ; x < s -> qstride ; x ++ ) \n out_qp_table_buf -> data [ x + s -> qstride * y ] = qp ; \n } \n ret = ff_filter_frame ( outlink , out ) ; \n fail : \n av_frame_free ( & in ) ; \n return ret ; \n }", "idx": 9339}
{"project": "FFmpeg", "commit_id": "cab39afb1a9c8a86a00485fbba12a9ba26bea57d", "target": 0, "func": "static int mov_write_source_reference_tag ( AVIOContext * pb , MOVTrack * track , const char * reel_name ) { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb16 ( pb , strlen ( reel_name ) ) ; \n avio_wb16 ( pb , track -> language ) ; \n avio_write ( pb , reel_name , strlen ( reel_name ) ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 9341}
{"project": "FFmpeg", "commit_id": "7846418bdb346c344fe9ff9801a820f0cd470212", "target": 1, "func": "static int decode_subframe_fixed ( FLACContext * s , int channel , int pred_order ) \n { \n const int blocksize = s -> blocksize ; \n int32_t * decoded = s -> decoded [ channel ] ; \n int a , b , c , d , i ; \n for ( i = 0 ; i < pred_order ; i ++ ) { \n decoded [ i ] = get_sbits ( & s -> gb , s -> curr_bps ) ; \n } \n if ( decode_residuals ( s , channel , pred_order ) < 0 ) \n return -1 ; \n if ( pred_order > 0 ) \n a = decoded [ pred_order - 1 ] ; \n if ( pred_order > 1 ) \n b = a - decoded [ pred_order - 2 ] ; \n if ( pred_order > 2 ) \n c = b - decoded [ pred_order - 2 ] + decoded [ pred_order - 3 ] ; \n if ( pred_order > 3 ) \n d = c - decoded [ pred_order - 2 ] + 2 * decoded [ pred_order - 3 ] - decoded [ pred_order - 4 ] ; \n switch ( pred_order ) { \n case 0 : \n break ; \n case 1 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += decoded [ i ] ; \n break ; \n case 2 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += b += decoded [ i ] ; \n break ; \n case 3 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += b += c += decoded [ i ] ; \n break ; \n case 4 : \n for ( i = pred_order ; i < blocksize ; i ++ ) \n decoded [ i ] = a += b += c += d += decoded [ i ] ; \n break ; \n default : \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , pred_order ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 9344}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_qmax ( const char * arg ) \n { \n video_qmax = atoi ( arg ) ; \n if ( video_qmax < 0 || \n video_qmax > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 9353}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static int init_opaque_surf ( QSVContext * qsv ) \n { \n AVQSVContext * hwctx_enc = qsv -> ost -> enc_ctx -> hwaccel_context ; \n mfxFrameSurface1 * surfaces ; \n int i ; \n qsv -> nb_surfaces = hwctx_enc -> nb_opaque_surfaces ; \n qsv -> opaque_surfaces_buf = av_buffer_ref ( hwctx_enc -> opaque_surfaces ) ; \n qsv -> surface_ptrs = av_mallocz_array ( qsv -> nb_surfaces , sizeof ( * qsv -> surface_ptrs ) ) ; \n qsv -> surface_used = av_mallocz_array ( qsv -> nb_surfaces , sizeof ( * qsv -> surface_used ) ) ; \n if ( ! qsv -> opaque_surfaces_buf || ! qsv -> surface_ptrs || ! qsv -> surface_used ) \n return AVERROR ( ENOMEM ) ; \n surfaces = ( mfxFrameSurface1 * ) qsv -> opaque_surfaces_buf -> data ; \n for ( i = 0 ; i < qsv -> nb_surfaces ; i ++ ) \n qsv -> surface_ptrs [ i ] = surfaces + i ; \n qsv -> opaque_alloc . Out . Surfaces = qsv -> surface_ptrs ; \n qsv -> opaque_alloc . Out . NumSurface = qsv -> nb_surfaces ; \n qsv -> opaque_alloc . Out . Type = hwctx_enc -> opaque_alloc_type ; \n qsv -> opaque_alloc . Header . BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION ; \n qsv -> opaque_alloc . Header . BufferSz = sizeof ( qsv -> opaque_alloc ) ; \n qsv -> ext_buffers [ 0 ] = ( mfxExtBuffer * ) & qsv -> opaque_alloc ; \n return 0 ; \n }", "idx": 9355}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "int avpriv_vsnprintf ( char * restrict s , size_t n , const char * restrict fmt , \n va_list ap ) \n { \n int ret ; \n if ( n == 0 ) \n return 0 ; \n else if ( n > INT_MAX ) \n return AVERROR ( EINVAL ) ; \n memset ( s , 0 , n ) ; \n ret = vsnprintf ( s , n - 1 , fmt , ap ) ; \n if ( ret == -1 ) \n ret = n ; \n return ret ; \n }", "idx": 9360}
{"project": "FFmpeg", "commit_id": "1a974679d097e878401cc1a425c3ed612be1581e", "target": 0, "func": "static int qdm2_get_vlc ( GetBitContext * gb , VLC * vlc , int flag , int depth ) \n { \n int value ; \n value = get_vlc2 ( gb , vlc -> table , vlc -> bits , depth ) ; \n if ( value -- == 0 ) \n value = get_bits ( gb , get_bits ( gb , 3 ) + 1 ) ; \n if ( flag ) { \n int tmp = vlc_stage3_values [ value ] ; \n if ( ( value & ~ 3 ) > 0 ) \n tmp += get_bits ( gb , ( value >> 2 ) ) ; \n value = tmp ; \n } \n return value ; \n }", "idx": 9361}
{"project": "FFmpeg", "commit_id": "e1219cdaf9fb4bc8cea410e1caf802373c1bfe51", "target": 0, "func": "static char * doubles2str ( double * dp , int count , const char * sep ) \n { \n int i ; \n char * ap , * ap0 ; \n int component_len ; \n if ( ! sep ) sep = \" \" ; \n component_len = 15 + strlen ( sep ) ; \n ap = av_malloc ( component_len * count ) ; \n if ( ! ap ) \n return NULL ; \n ap0 = ap ; \n ap [ 0 ] = ' \\0 ' ; \n for ( i = 0 ; i < count ; i ++ ) { \n unsigned l = snprintf ( ap , component_len , \" \" , dp [ i ] , sep ) ; \n if ( l >= component_len ) { \n av_free ( ap0 ) ; \n return NULL ; \n } \n ap += l ; \n } \n ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = ' \\0 ' ; \n return ap0 ; \n }", "idx": 9364}
{"project": "FFmpeg", "commit_id": "1eb1f6f281eb6036d363e0317c1500be4a2708f2", "target": 1, "func": "static int dot_product ( const int16_t * a , const int16_t * b , int length ) \n { \n int i , sum = 0 ; \n for ( i = 0 ; i < length ; i ++ ) { \n int64_t prod = av_clipl_int32 ( MUL64 ( a [ i ] , b [ i ] ) << 1 ) ; \n sum = av_clipl_int32 ( sum + prod ) ; \n } \n return sum ; \n }", "idx": 9368}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef * avfilter_get_audio_buffer_ref_from_frame ( const AVFrame * frame , \n int perms ) \n { \n AVFilterBufferRef * samplesref = \n avfilter_get_audio_buffer_ref_from_arrays ( ( uint8_t * * ) frame -> data , frame -> linesize [ 0 ] , perms , \n frame -> nb_samples , frame -> format , \n av_frame_get_channel_layout ( frame ) ) ; \n if ( ! samplesref ) \n return NULL ; \n avfilter_copy_frame_props ( samplesref , frame ) ; \n return samplesref ; \n }", "idx": 9371}
{"project": "FFmpeg", "commit_id": "0493e42eb2f9fbf42d0aee0b48a84f81f19fb7fa", "target": 0, "func": "static void DEF ( put , pixels8_y2 ) ( uint8_t * block , const uint8_t * pixels , ptrdiff_t line_size , int h ) \n { \n MOVQ_BFE ( mm6 ) ; \n __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGBP ( % % mm1 , % % mm0 , % % mm4 , % % mm2 , % % mm1 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGBP ( % % mm1 , % % mm2 , % % mm4 , % % mm0 , % % mm1 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( h ) , \" \" ( pixels ) , \" \" ( block ) \n : \" \" ( ( x86_reg ) line_size ) \n : REG_a , \" \" ) ; \n }", "idx": 9383}
{"project": "FFmpeg", "commit_id": "29fb49194bedc74ac9be0b49b6b42dcfeb6222d9", "target": 0, "func": "void av_set_cpu_flags_mask ( int mask ) \n { \n checked = 0 ; \n flags = av_get_cpu_flags ( ) & mask ; \n checked = 1 ; \n }", "idx": 9394}
{"project": "FFmpeg", "commit_id": "124eb7e476f7e3f66dcdc30f780a45b378751219", "target": 1, "func": "static void pop_output_configuration ( AACContext * ac ) { \n if ( ac -> oc [ 1 ] . status != OC_LOCKED ) { \n if ( ac -> oc [ 0 ] . status == OC_LOCKED ) { \n ac -> oc [ 1 ] = ac -> oc [ 0 ] ; \n ac -> avctx -> channels = ac -> oc [ 1 ] . channels ; \n ac -> avctx -> channel_layout = ac -> oc [ 1 ] . channel_layout ; \n } else { \n ac -> avctx -> channels = 0 ; \n ac -> avctx -> channel_layout = 0 ; \n } \n } \n }", "idx": 9403}
{"project": "FFmpeg", "commit_id": "d8fb170da2e7edbfd250c1d8e1de6b1a0e965170", "target": 1, "func": "int ff_vbv_update ( MpegEncContext * s , int frame_size ) \n { \n RateControlContext * rcc = & s -> rc_context ; \n const double fps = get_fps ( s -> avctx ) ; \n const int buffer_size = s -> avctx -> rc_buffer_size ; \n const double min_rate = s -> avctx -> rc_min_rate / fps ; \n const double max_rate = s -> avctx -> rc_max_rate / fps ; \n av_dlog ( s , \" \\n \" , \n buffer_size , rcc -> buffer_index , frame_size , min_rate , max_rate ) ; \n if ( buffer_size ) { \n int left ; \n rcc -> buffer_index -= frame_size ; \n if ( rcc -> buffer_index < 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n rcc -> buffer_index = 0 ; \n left = buffer_size - rcc -> buffer_index - 1 ; \n rcc -> buffer_index += av_clip ( left , min_rate , max_rate ) ; \n if ( rcc -> buffer_index > buffer_size ) { \n int stuffing = ceil ( ( rcc -> buffer_index - buffer_size ) / 8 ) ; \n if ( stuffing < 4 && s -> codec_id == AV_CODEC_ID_MPEG4 ) \n stuffing = 4 ; \n rcc -> buffer_index -= 8 * stuffing ; \n if ( s -> avctx -> debug & FF_DEBUG_RC ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , stuffing ) ; \n return stuffing ; \n return 0 ;", "idx": 9417}
{"project": "FFmpeg", "commit_id": "55188278169c3a1838334d7aa47a1f7a40741690", "target": 1, "func": "static int xan_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n XanContext * s = avctx -> priv_data ; \n int ftype ; \n int ret ; \n s -> pic . reference = 1 ; \n s -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | \n FF_BUFFER_HINTS_PRESERVE | \n FF_BUFFER_HINTS_REUSABLE ; \n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> pic ) ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n ftype = AV_RL32 ( avpkt -> data ) ; \n switch ( ftype ) { \n case 0 : \n ret = xan_decode_frame_type0 ( avctx , avpkt ) ; \n break ; \n case 1 : \n ret = xan_decode_frame_type1 ( avctx , avpkt ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ftype ) ; \n return -1 ; \n } \n if ( ret ) \n return ret ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> pic ; \n return avpkt -> size ; \n }", "idx": 9423}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static void decode_rowskip ( uint8_t * plane , int width , int height , int stride , VC9Context * v ) { \n int x , y ; \n GetBitContext * gb = & v -> s . gb ; \n for ( y = 0 ; y < height ; y ++ ) { \n if ( ! get_bits ( gb , 1 ) ) \n memset ( plane , 0 , width ) ; \n else \n for ( x = 0 ; x < width ; x ++ ) \n plane [ x ] = get_bits ( gb , 1 ) ; \n plane += stride ; \n } \n }", "idx": 9424}
{"project": "FFmpeg", "commit_id": "abf669479c0098ab5eb184a167e57a70aabb942b", "target": 0, "func": "int ff_mov_read_esds ( AVFormatContext * fc , AVIOContext * pb ) \n { \n AVStream * st ; \n int tag ; \n if ( fc -> nb_streams < 1 ) \n return 0 ; \n st = fc -> streams [ fc -> nb_streams - 1 ] ; \n avio_rb32 ( pb ) ; \n ff_mp4_read_descr ( fc , pb , & tag ) ; \n if ( tag == MP4ESDescrTag ) { \n ff_mp4_parse_es_descr ( pb , NULL ) ; \n } else \n avio_rb16 ( pb ) ; \n ff_mp4_read_descr ( fc , pb , & tag ) ; \n if ( tag == MP4DecConfigDescrTag ) \n ff_mp4_read_dec_config_descr ( fc , st , pb ) ; \n return 0 ; \n }", "idx": 9430}
{"project": "FFmpeg", "commit_id": "746cb9bc53f71ed8d67827c4518deecc4ba2a75d", "target": 0, "func": "void ff_atrac_iqmf ( float * inlo , float * inhi , unsigned int nIn , float * pOut , float * delayBuf , float * temp ) \n { \n int i , j ; \n float * p1 , * p3 ; \n memcpy ( temp , delayBuf , 46 * sizeof ( float ) ) ; \n p3 = temp + 46 ; \n for ( i = 0 ; i < nIn ; i += 2 ) { \n p3 [ 2 * i + 0 ] = inlo [ i ] + inhi [ i ] ; \n p3 [ 2 * i + 1 ] = inlo [ i ] - inhi [ i ] ; \n p3 [ 2 * i + 2 ] = inlo [ i + 1 ] + inhi [ i + 1 ] ; \n p3 [ 2 * i + 3 ] = inlo [ i + 1 ] - inhi [ i + 1 ] ; \n } \n p1 = temp ; \n for ( j = nIn ; j != 0 ; j -- ) { \n float s1 = 0.0 ; \n float s2 = 0.0 ; \n for ( i = 0 ; i < 48 ; i += 2 ) { \n s1 += p1 [ i ] * qmf_window [ i ] ; \n s2 += p1 [ i + 1 ] * qmf_window [ i + 1 ] ; \n } \n pOut [ 0 ] = s2 ; \n pOut [ 1 ] = s1 ; \n p1 += 2 ; \n pOut += 2 ; \n } \n memcpy ( delayBuf , temp + nIn * 2 , 46 * sizeof ( float ) ) ; \n }", "idx": 9431}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int read_rle_sgi ( unsigned char * out_buf , const uint8_t * in_buf , \n const uint8_t * in_end , SgiState * s ) \n { \n uint8_t * dest_row ; \n unsigned int len = s -> height * s -> depth * 4 ; \n const uint8_t * start_table = in_buf ; \n unsigned int y , z ; \n unsigned int start_offset ; \n if ( len * 2 > in_end - in_buf ) { \n return AVERROR_INVALIDDATA ; \n } \n in_buf -= SGI_HEADER_SIZE ; \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n dest_row = out_buf ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n dest_row -= s -> linesize ; \n start_offset = bytestream_get_be32 ( & start_table ) ; \n if ( start_offset > in_end - in_buf ) { \n return AVERROR_INVALIDDATA ; \n } \n if ( expand_rle_row ( in_buf + start_offset , in_end , dest_row + z , \n dest_row + FFABS ( s -> linesize ) , s -> depth ) != s -> width ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 9433}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( rgb15to16 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n register const uint8_t * s = src ; \n register uint8_t * d = dst ; \n register const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \n __asm __volatile ( \" \" :: \" \" ( mask15s ) ) ; \n mm_end = end - 15 ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" \" ( * d ) \n : \" \" ( * s ) \n ) ; \n d += 16 ; \n s += 16 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n mm_end = end - 3 ; \n while ( s < mm_end ) \n { \n register unsigned x = * ( ( uint32_t * ) s ) ; \n * ( ( uint32_t * ) d ) = ( x & 0x7FFF7FFF ) + ( x & 0x7FE07FE0 ) ; \n d += 4 ; \n s += 4 ; \n } \n if ( s < end ) \n { \n register unsigned short x = * ( ( uint16_t * ) s ) ; \n * ( ( uint16_t * ) d ) = ( x & 0x7FFF ) + ( x & 0x7FE0 ) ; \n } \n }", "idx": 9436}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void vp8_mc_luma ( VP8Context * s , VP8ThreadData * td , uint8_t * dst , \n ThreadFrame * ref , const VP56mv * mv , \n int x_off , int y_off , int block_w , int block_h , \n int width , int height , int linesize , \n vp8_mc_func mc_func [ 3 ] [ 3 ] ) \n { \n uint8_t * src = ref -> f -> data [ 0 ] ; \n if ( AV_RN32A ( mv ) ) { \n int mx = ( mv -> x << 1 ) & 7 , mx_idx = subpel_idx [ 0 ] [ mx ] ; \n int my = ( mv -> y << 1 ) & 7 , my_idx = subpel_idx [ 0 ] [ my ] ; \n x_off += mv -> x >> 2 ; \n y_off += mv -> y >> 2 ; \n ff_thread_await_progress ( ref , ( 3 + y_off + block_h + subpel_idx [ 2 ] [ my ] ) >> 4 , 0 ) ; \n src += y_off * linesize + x_off ; \n if ( x_off < mx_idx || x_off >= width - block_w - subpel_idx [ 2 ] [ mx ] || \n y_off < my_idx || y_off >= height - block_h - subpel_idx [ 2 ] [ my ] ) { \n s -> vdsp . emulated_edge_mc ( td -> edge_emu_buffer , src - my_idx * linesize - mx_idx , linesize , \n block_w + subpel_idx [ 1 ] [ mx ] , block_h + subpel_idx [ 1 ] [ my ] , \n x_off - mx_idx , y_off - my_idx , width , height ) ; \n src = td -> edge_emu_buffer + mx_idx + linesize * my_idx ; \n } \n mc_func [ my_idx ] [ mx_idx ] ( dst , linesize , src , linesize , block_h , mx , my ) ; \n } else { \n ff_thread_await_progress ( ref , ( 3 + y_off + block_h ) >> 4 , 0 ) ; \n mc_func [ 0 ] [ 0 ] ( dst , linesize , src + y_off * linesize + x_off , linesize , block_h , 0 , 0 ) ; \n } \n }", "idx": 9440}
{"project": "FFmpeg", "commit_id": "3e0e1634585b1a26b7d753aa42c7f350636927ae", "target": 0, "func": "int ff_nvdec_frame_params ( AVCodecContext * avctx , \n AVBufferRef * hw_frames_ctx , \n int dpb_size ) \n { \n AVHWFramesContext * frames_ctx = ( AVHWFramesContext * ) hw_frames_ctx -> data ; \n const AVPixFmtDescriptor * sw_desc ; \n int cuvid_codec_type , cuvid_chroma_format ; \n sw_desc = av_pix_fmt_desc_get ( avctx -> sw_pix_fmt ) ; \n if ( ! sw_desc ) \n return AVERROR_BUG ; \n cuvid_codec_type = map_avcodec_id ( avctx -> codec_id ) ; \n if ( cuvid_codec_type < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_BUG ; \n } \n cuvid_chroma_format = map_chroma_format ( avctx -> sw_pix_fmt ) ; \n if ( cuvid_chroma_format < 0 ) { \n av_log ( avctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( avctx -> thread_type & FF_THREAD_FRAME ) \n dpb_size += avctx -> thread_count ; \n frames_ctx -> format = AV_PIX_FMT_CUDA ; \n frames_ctx -> width = avctx -> coded_width ; \n frames_ctx -> height = avctx -> coded_height ; \n frames_ctx -> sw_format = sw_desc -> comp [ 0 ] . depth > 8 ? \n AV_PIX_FMT_P010 : AV_PIX_FMT_NV12 ; \n frames_ctx -> initial_pool_size = dpb_size ; \n return 0 ; \n }", "idx": 9447}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel16_mc10_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_16w_msa ( src - 2 , stride , dst , stride , 16 , 0 ) ; \n }", "idx": 9449}
{"project": "FFmpeg", "commit_id": "328e203ca9b5e5afcd0769dae149075735150346", "target": 1, "func": "static int mpegts_audio_write ( void * opaque , uint8_t * buf , int size ) \n { \n MpegTSWriteStream * ts_st = ( MpegTSWriteStream * ) opaque ; \n if ( ts_st -> adata_pos + size > ts_st -> adata_size ) \n return AVERROR ( EIO ) ; \n memcpy ( ts_st -> adata + ts_st -> adata_pos , buf , size ) ; \n ts_st -> adata_pos += size ; \n return 0 ; \n }", "idx": 9455}
{"project": "FFmpeg", "commit_id": "9257692ac15eff7b07540c1f61cebde0d8823fbd", "target": 1, "func": "AVFormatContext * avformat_alloc_context ( void ) \n { \n AVFormatContext * ic ; \n ic = av_malloc ( sizeof ( AVFormatContext ) ) ; \n if ( ! ic ) return ic ; \n avformat_get_context_defaults ( ic ) ; \n ic -> internal = av_mallocz ( sizeof ( * ic -> internal ) ) ; \n if ( ! ic -> internal ) { \n avformat_free_context ( ic ) ; \n return NULL ; \n } \n return ic ; \n }", "idx": 9456}
{"project": "FFmpeg", "commit_id": "76d7c327eba042106b729e9d671b6f85f515b1af", "target": 1, "func": "static void gif_put_bits_rev ( PutBitContext * s , int n , unsigned int value ) \n { \n unsigned int bit_buf ; \n int bit_cnt ; \n assert ( n == 32 || value < ( 1U << n ) ) ; \n bit_buf = s -> bit_buf ; \n bit_cnt = 32 - s -> bit_left ; \n if ( n < ( 32 - bit_cnt ) ) { \n bit_buf |= value << ( bit_cnt ) ; \n bit_cnt += n ; \n } else { \n bit_buf |= value << ( bit_cnt ) ; \n * s -> buf_ptr = bit_buf & 0xff ; \n s -> buf_ptr [ 1 ] = ( bit_buf >> 8 ) & 0xff ; \n s -> buf_ptr [ 2 ] = ( bit_buf >> 16 ) & 0xff ; \n s -> buf_ptr [ 3 ] = ( bit_buf >> 24 ) & 0xff ; \n s -> buf_ptr += 4 ; \n if ( s -> buf_ptr >= s -> buf_end ) \n puts ( \" \" ) ; \n bit_cnt = bit_cnt + n - 32 ; \n if ( bit_cnt == 0 ) { \n bit_buf = 0 ; \n } else { \n bit_buf = value >> ( n - bit_cnt ) ; \n } \n } \n s -> bit_buf = bit_buf ; \n s -> bit_left = 32 - bit_cnt ; \n }", "idx": 9468}
{"project": "FFmpeg", "commit_id": "224afddc7c869472caa57fc571aaf979a85d24ef", "target": 0, "func": "static int get_video_private_data ( struct VideoFile * vf , AVCodecContext * codec ) \n { \n AVIOContext * io = NULL ; \n uint16_t sps_size , pps_size ; \n int err = AVERROR ( EINVAL ) ; \n if ( codec -> codec_id == AV_CODEC_ID_VC1 ) \n return get_private_data ( vf , codec ) ; \n avio_open_dyn_buf ( & io ) ; \n if ( codec -> extradata_size < 11 || codec -> extradata [ 0 ] != 1 ) \n goto fail ; \n sps_size = AV_RB16 ( & codec -> extradata [ 6 ] ) ; \n if ( 11 + sps_size > codec -> extradata_size ) \n goto fail ; \n avio_wb32 ( io , 0x00000001 ) ; \n avio_write ( io , & codec -> extradata [ 8 ] , sps_size ) ; \n pps_size = AV_RB16 ( & codec -> extradata [ 9 + sps_size ] ) ; \n if ( 11 + sps_size + pps_size > codec -> extradata_size ) \n goto fail ; \n avio_wb32 ( io , 0x00000001 ) ; \n avio_write ( io , & codec -> extradata [ 11 + sps_size ] , pps_size ) ; \n err = 0 ; \n fail : \n vf -> codec_private_size = avio_close_dyn_buf ( io , & vf -> codec_private ) ; \n return err ; \n }", "idx": 9478}
{"project": "FFmpeg", "commit_id": "c77b858c4cafe74cd663bdd1bc9d96a487b20e14", "target": 0, "func": "static void FUNCC ( pred8x8l_horizontal ) ( uint8_t * p_src , int has_topleft , int has_topright , int p_stride ) \n { \n pixel * src = ( pixel * ) p_src ; \n int stride = p_stride >> ( sizeof ( pixel ) - 1 ) ; \n PREDICT_8x8_LOAD_LEFT ; \n #define ROW ( y )  ((pixel4*)(src+y*stride))[0] =\\ \n   \n  ( ( pixel4 * ) ( src + y * stride ) ) [ 1 ] = PIXEL_SPLAT_X4 ( l # #y )  \n ROW ( 0 ) ; ROW ( 1 ) ; ROW ( 2 ) ; ROW ( 3 ) ; ROW ( 4 ) ; ROW ( 5 ) ; ROW ( 6 ) ; ROW ( 7 ) ; \n #undef  ROW  \n  \n  }", "idx": 9479}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static int ffmmal_fill_input_port ( AVCodecContext * avctx ) \n { \n MMALDecodeContext * ctx = avctx -> priv_data ; \n while ( ctx -> waiting_buffers ) { \n MMAL_BUFFER_HEADER_T * mbuffer ; \n FFBufferEntry * buffer ; \n MMAL_STATUS_T status ; \n mbuffer = mmal_queue_get ( ctx -> pool_in -> queue ) ; \n if ( ! mbuffer ) \n return 0 ; \n buffer = ctx -> waiting_buffers ; \n mmal_buffer_header_reset ( mbuffer ) ; \n mbuffer -> cmd = 0 ; \n mbuffer -> pts = buffer -> pts ; \n mbuffer -> dts = buffer -> dts ; \n mbuffer -> flags = buffer -> flags ; \n mbuffer -> data = buffer -> data ; \n mbuffer -> length = buffer -> length ; \n mbuffer -> user_data = buffer -> ref ; \n mbuffer -> alloc_size = ctx -> decoder -> input [ 0 ] -> buffer_size ; \n if ( ( status = mmal_port_send_buffer ( ctx -> decoder -> input [ 0 ] , mbuffer ) ) ) { \n mmal_buffer_header_release ( mbuffer ) ; \n av_buffer_unref ( & buffer -> ref ) ; \n } \n ctx -> waiting_buffers = buffer -> next ; \n if ( ctx -> waiting_buffers_tail == buffer ) \n ctx -> waiting_buffers_tail = NULL ; \n av_free ( buffer ) ; \n if ( status ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ( int ) status ) ; \n return AVERROR_UNKNOWN ; \n } \n } \n return 0 ; \n }", "idx": 9484}
{"project": "FFmpeg", "commit_id": "6fea8454acff29735ea46184cb183ca6ff42e514", "target": 1, "func": "static test_speed ( int step )  \n { \n const struct pix_func * pix = pix_func ; \n const int linesize = 720 ; \n char empty [ 32768 ] ; \n char * bu = ( char * ) ( ( ( long ) empty + 32 ) & ~ 0xf ) ; \n int sum = 0 ; \n while ( pix -> name ) \n { \n int i ; \n uint64_t te , ts ; \n op_pixels_func func = pix -> func ; \n char * im = bu ; \n if ( ! ( pix -> mm_flags & mm_flags ) ) \n continue ; \n printf ( \" \" , pix -> name ) ; \n fflush ( stdout ) ; \n ts = rdtsc ( ) ; \n for ( i = 0 ; i < 100000 ; i ++ ) { \n func ( im , im + 1000 , linesize , 16 ) ; \n im += step ; \n if ( im > bu + 20000 ) \n im = bu ; \n } \n te = rdtsc ( ) ; \n emms ( ) ; \n printf ( \" \\n \" , ( int ) ( te - ts ) ) ; \n sum += ( te - ts ) / 100000 ; \n if ( pix -> mm_flags & PAD ) \n puts ( \" \" ) ; \n pix ++ ; \n } \n printf ( \" \\n \" , sum ) ; \n }", "idx": 9486}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static void writer_print_ts ( WriterContext * wctx , const char * key , int64_t ts , int is_duration ) \n { \n if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { \n writer_print_string ( wctx , key , \" \" , 1 ) ; \n } else { \n writer_print_integer ( wctx , key , ts ) ; \n } \n }", "idx": 9487}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add4_sse2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 4 ) { \n int nnz = nnzc [ scan8 [ i ] ] ; \n if ( nnz ) { \n if ( nnz == 1 && block [ i * 16 ] ) ff_h264_idct8_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else ff_h264_idct8_add_sse2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n } \n }", "idx": 9488}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_16x16_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , \n dst , stride ) ; \n }", "idx": 9489}
{"project": "FFmpeg", "commit_id": "6ffa87d3254dd8bdc31b50b378e1cf59c5dc13e5", "target": 0, "func": "int av_tempfile ( char * prefix , char * * filename ) { \n int fd = -1 ; \n #ifdef __MINGW32__ \n * filename = tempnam ( \" \" , prefix ) ; \n #else \n size_t len = strlen ( prefix ) + 12 ; \n * filename = av_malloc ( len ) ; \n #endif \n if ( * filename == NULL ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n #ifdef __MINGW32__ \n fd = open ( * filename , _O_RDWR | _O_BINARY | _O_CREAT , 0444 ) ; \n #else \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n if ( fd < 0 ) { \n snprintf ( * filename , len , \" \" , prefix ) ; \n fd = mkstemp ( * filename ) ; \n } \n #endif \n if ( fd < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , * filename ) ; \n return -1 ; \n } \n return fd ; \n }", "idx": 9490}
{"project": "FFmpeg", "commit_id": "fb7a2bf6956173eda6f9caceef8599fa4f83500d", "target": 0, "func": "unsigned int codec_get_tag ( const CodecTag * tags , int id ) \n { \n while ( tags -> id != 0 ) { \n if ( tags -> id == id ) \n return tags -> tag ; \n tags ++ ; \n } \n return 0 ; \n }", "idx": 9492}
{"project": "FFmpeg", "commit_id": "f19442c069929727b19c948619488370d279e177", "target": 1, "func": "static inline uint32_t celt_icwrsi ( uint32_t N , uint32_t K , const int * y ) \n { \n int i , idx = 0 , sum = 0 ; \n for ( i = N - 1 ; i >= 0 ; i -- ) { \n const uint32_t i_s = CELT_PVQ_U ( N - i , sum + FFABS ( y [ i ] ) + 1 ) ; \n idx += CELT_PVQ_U ( N - i , sum ) + ( y [ i ] < 0 ) * i_s ; \n sum += FFABS ( y [ i ] ) ; \n } \n av_assert0 ( sum == K ) ; \n return idx ; \n }", "idx": 9497}
{"project": "FFmpeg", "commit_id": "1d0817d56b66797118880358ea7d7a2acfdca429", "target": 1, "func": "static float voice_factor ( float * p_vector , float p_gain , \n float * f_vector , float f_gain , \n CELPMContext * ctx ) \n { \n double p_ener = ( double ) ctx -> dot_productf ( p_vector , p_vector , \n AMRWB_SFR_SIZE ) * \n p_gain * p_gain ; \n double f_ener = ( double ) ctx -> dot_productf ( f_vector , f_vector , \n AMRWB_SFR_SIZE ) * \n f_gain * f_gain ; \n return ( p_ener - f_ener ) / ( p_ener + f_ener ) ; \n }", "idx": 9500}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int shall_we_drop ( AVFormatContext * s ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n static const uint8_t dropscore [ ] = { 62 , 75 , 87 , 100 } ; \n const int ndropscores = FF_ARRAY_ELEMS ( dropscore ) ; \n unsigned int buffer_fullness = ( ctx -> curbufsize * 100 ) / s -> max_picture_buffer ; \n if ( dropscore [ ++ ctx -> video_frame_num % ndropscores ] <= buffer_fullness ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" , buffer_fullness ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 9506}
{"project": "FFmpeg", "commit_id": "0d0d24af0159ff08f396ad04cd63ce5655b1fc60", "target": 1, "func": "static void decode_profile_tier_level ( HEVCContext * s , PTLCommon * ptl ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n ptl -> profile_space = get_bits ( gb , 2 ) ; \n ptl -> tier_flag = get_bits1 ( gb ) ; \n ptl -> profile_idc = get_bits ( gb , 5 ) ; \n if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN_10 ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN_STILL_PICTURE ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_REXT ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" , ptl -> profile_idc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) \n ptl -> profile_compatibility_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> progressive_source_flag = get_bits1 ( gb ) ; \n ptl -> interlaced_source_flag = get_bits1 ( gb ) ; \n ptl -> non_packed_constraint_flag = get_bits1 ( gb ) ; \n ptl -> frame_only_constraint_flag = get_bits1 ( gb ) ; \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 12 ) ; \n }", "idx": 9511}
{"project": "FFmpeg", "commit_id": "9425dc3dba0bd1209aa7a788ea8f3c194fc7c7c5", "target": 1, "func": "static void float_to_int16_stride_altivec ( int16_t * dst , const float * src , \n long len , int stride ) \n { \n int i , j ; \n vector signed  short d , s ; \n for ( i = 0 ; i < len - 7 ; i += 8 ) { \n d = float_to_int16_one_altivec ( src + i ) ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n s = vec_splat ( d , j ) ; \n vec_ste ( s , 0 , dst ) ; \n dst += stride ; \n } \n } \n }", "idx": 9517}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static void vp8_h_loop_filter_simple_c ( uint8_t * dst , ptrdiff_t stride , int flim ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n if ( simple_limit ( dst + i * stride , 1 , flim ) ) \n filter_common ( dst + i * stride , 1 , 1 ) ; \n }", "idx": 9520}
{"project": "FFmpeg", "commit_id": "1eb1f6f281eb6036d363e0317c1500be4a2708f2", "target": 1, "func": "static void gain_scale ( G723_1_Context * p , int16_t * buf , int energy ) \n { \n int num , denom , gain , bits1 , bits2 ; \n int i ; \n num = energy ; \n denom = 0 ; \n for ( i = 0 ; i < SUBFRAME_LEN ; i ++ ) { \n int64_t temp = buf [ i ] >> 2 ; \n temp = av_clipl_int32 ( MUL64 ( temp , temp ) << 1 ) ; \n denom = av_clipl_int32 ( denom + temp ) ; \n } \n if ( num && denom ) { \n bits1 = normalize_bits ( num , 31 ) ; \n bits2 = normalize_bits ( denom , 31 ) ; \n num = num << bits1 >> 1 ; \n denom <<= bits2 ; \n bits2 = 5 + bits1 - bits2 ; \n bits2 = FFMAX ( 0 , bits2 ) ; \n gain = ( num >> 1 ) / ( denom >> 16 ) ; \n gain = square_root ( gain << 16 >> bits2 ) ; \n } else { \n gain = 1 << 12 ; \n } \n for ( i = 0 ; i < SUBFRAME_LEN ; i ++ ) { \n p -> pf_gain = ( 15 * p -> pf_gain + gain + ( 1 << 3 ) ) >> 4 ; \n buf [ i ] = av_clip_int16 ( ( buf [ i ] * ( p -> pf_gain + ( p -> pf_gain >> 4 ) ) + \n ( 1 << 10 ) ) >> 11 ) ; \n } \n }", "idx": 9521}
{"project": "FFmpeg", "commit_id": "224944895efe6ac23e3b8f9d35abfee9f5c6c440", "target": 0, "func": "static int64_t update_scr ( AVFormatContext * ctx , int stream_index , int64_t pts ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n int64_t scr ; \n if ( s -> is_vcd ) \n scr = 36000 + s -> packet_number * 1200 ; \n else { \n if ( stream_index == s -> scr_stream_index \n && pts != AV_NOPTS_VALUE ) \n scr = pts ; \n else \n scr = s -> last_scr ; \n } \n s -> last_scr = scr ; \n return scr ; \n }", "idx": 9556}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static int decode_cabac_field_decoding_flag ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n const int mb_x = s -> mb_x ; \n const int mb_y = s -> mb_y & ~ 1 ; \n const int mba_xy = mb_x - 1 + mb_y * s -> mb_stride ; \n const int mbb_xy = mb_x + ( mb_y - 2 ) * s -> mb_stride ; \n unsigned int ctx = 0 ; \n if ( h -> slice_table [ mba_xy ] == h -> slice_num && IS_INTERLACED ( s -> current_picture . mb_type [ mba_xy ] ) ) { \n ctx += 1 ; \n } \n if ( h -> slice_table [ mbb_xy ] == h -> slice_num && IS_INTERLACED ( s -> current_picture . mb_type [ mbb_xy ] ) ) { \n ctx += 1 ; \n } \n return get_cabac ( & h -> cabac , & h -> cabac_state [ 70 + ctx ] ) ; \n }", "idx": 9590}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16_mmx ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] ) \n ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 9592}
{"project": "FFmpeg", "commit_id": "74dc728a2c2cc353da20cdc09b8cdfbbe14b7be8", "target": 1, "func": "static void generate_2_noise_channels ( MLPDecodeContext * m , unsigned int substr ) \n { \n SubStream * s = & m -> substream [ substr ] ; \n unsigned int i ; \n uint32_t seed = s -> noisegen_seed ; \n unsigned int maxchan = s -> max_matrix_channel ; \n for ( i = 0 ; i < s -> blockpos ; i ++ ) { \n uint16_t seed_shr7 = seed >> 7 ; \n m -> sample_buffer [ i ] [ maxchan + 1 ] = ( ( int8_t ) ( seed >> 15 ) ) << s -> noise_shift ; \n m -> sample_buffer [ i ] [ maxchan + 2 ] = ( ( int8_t ) seed_shr7 ) << s -> noise_shift ; \n seed = ( seed << 16 ) ^ seed_shr7 ^ ( seed_shr7 << 5 ) ; \n } \n s -> noisegen_seed = seed ; \n }", "idx": 9596}
{"project": "FFmpeg", "commit_id": "142894d7202b5559d87f58df30baf48107a816f6", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n AudioEchoContext * s = ctx -> priv ; \n AVFrame * out_frame ; \n if ( av_frame_is_writable ( frame ) ) { \n out_frame = frame ; \n } else { \n out_frame = ff_get_audio_buffer ( inlink , frame -> nb_samples ) ; \n if ( ! out_frame ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( out_frame , frame ) ; \n } \n s -> echo_samples ( s , s -> delayptrs , frame -> extended_data , out_frame -> extended_data , \n frame -> nb_samples , inlink -> channels ) ; \n s -> next_pts = frame -> pts + av_rescale_q ( frame -> nb_samples , ( AVRational ) { 1 , inlink -> sample_rate } , inlink -> time_base ) ; \n if ( frame != out_frame ) \n av_frame_free ( & frame ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) ; \n }", "idx": 9597}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void encode_frame ( VC2EncContext * s , const AVFrame * frame , \n const char * aux_data , int field ) \n { \n int i ; \n encode_parse_info ( s , DIRAC_PCODE_SEQ_HEADER ) ; \n encode_seq_header ( s ) ; \n if ( aux_data ) { \n encode_parse_info ( s , DIRAC_PCODE_AUX ) ; \n avpriv_put_string ( & s -> pb , aux_data , 1 ) ; \n } \n encode_parse_info ( s , DIRAC_PCODE_PICTURE_HQ ) ; \n encode_picture_start ( s ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n s -> transform_args [ i ] . ctx = s ; \n s -> transform_args [ i ] . field = field ; \n s -> transform_args [ i ] . plane = & s -> plane [ i ] ; \n s -> transform_args [ i ] . idata = frame -> data [ i ] ; \n s -> transform_args [ i ] . istride = frame -> linesize [ i ] ; \n } \n s -> avctx -> execute ( s -> avctx , dwt_plane , s -> transform_args , NULL , 3 , \n sizeof ( TransformArgs ) ) ; \n calc_slice_sizes ( s ) ; \n encode_slices ( s ) ; \n encode_parse_info ( s , DIRAC_PCODE_END_SEQ ) ; \n }", "idx": 9601}
{"project": "FFmpeg", "commit_id": "8630b2cd36c57918acfe18302fe77d1ceefbd676", "target": 1, "func": "static inline av_flatten int get_symbol_inline ( RangeCoder * c , uint8_t * state , \n int is_signed ) \n { \n if ( get_rac ( c , state + 0 ) ) \n return 0 ; \n else { \n int i , e , a ; \n e = 0 ; \n while ( get_rac ( c , state + 1 + FFMIN ( e , 9 ) ) ) { \n e ++ ; \n if ( e > 31 ) \n return AVERROR_INVALIDDATA ; \n } \n a = 1 ; \n for ( i = e - 1 ; i >= 0 ; i -- ) \n a += a + get_rac ( c , state + 22 + FFMIN ( i , 9 ) ) ; \n e = - ( is_signed && get_rac ( c , state + 11 + FFMIN ( e , 10 ) ) ) ; \n return ( a ^ e ) - e ; \n } \n }", "idx": 9603}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_end ( AVFormatContext * ctx ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n StreamInfo * stream ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) { \n stream = ctx -> streams [ i ] -> priv_data ; \n while ( stream -> buffer_ptr > 0 ) { \n flush_packet ( ctx , i , AV_NOPTS_VALUE , AV_NOPTS_VALUE , s -> last_scr ) ; \n } \n } \n for ( i = 0 ; i < ctx -> nb_streams ; i ++ ) \n av_freep ( & ctx -> streams [ i ] -> priv_data ) ; \n return 0 ; \n }", "idx": 9604}
{"project": "FFmpeg", "commit_id": "f927c5b753f2ec1f037ad38cb55b4407dd7a9d79", "target": 1, "func": "theora_gptopts ( AVFormatContext * ctx , int idx , uint64_t gp , int64_t * dts )  \n { \n struct ogg * ogg = ctx -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n struct theora_params * thp = os -> private ; \n uint64_t iframe = gp >> thp -> gpshift ; \n uint64_t pframe = gp & thp -> gpmask ; \n if ( thp -> version < 0x030201 ) \n iframe ++ ; \n if ( ! pframe ) \n os -> pflags |= AV_PKT_FLAG_KEY ; \n if ( dts ) \n * dts = iframe + pframe ; \n return iframe + pframe ; \n }", "idx": 9606}
{"project": "FFmpeg", "commit_id": "ad2296ab3a131d3560c385e43437841987166804", "target": 1, "func": "static av_always_inline SoftFloat autocorr_calc ( int64_t accu ) \n { \n int nz , mant , expo , round ; \n int i = ( int ) ( accu >> 32 ) ; \n if ( i == 0 ) { \n nz = 1 ; \n } else { \n nz = 0 ; \n while ( FFABS ( i ) < 0x40000000 ) { \n i <<= 1 ; \n nz ++ ; \n } \n nz = 32 - nz ; \n } \n round = 1 << ( nz - 1 ) ; \n mant = ( int ) ( ( accu + round ) >> nz ) ; \n mant = ( mant + 0x40 ) >> 7 ; \n mant <<= 6 ; \n expo = nz + 15 ; \n return av_int2sf ( mant , 30 - expo ) ; \n }", "idx": 9610}
{"project": "FFmpeg", "commit_id": "f4e814f787d050ac65f507b1304dcdc4ffa56f29", "target": 1, "func": "struct SwrContext * swr_alloc_set_opts ( struct SwrContext * s , \n int64_t out_ch_layout , enum AVSampleFormat out_sample_fmt , int out_sample_rate , \n int64_t in_ch_layout , enum AVSampleFormat in_sample_fmt , int in_sample_rate , \n int log_offset , void * log_ctx ) { \n if ( ! s ) s = swr_alloc ( ) ; \n if ( ! s ) return NULL ; \n s -> log_level_offset = log_offset ; \n s -> log_ctx = log_ctx ; \n av_opt_set_int ( s , \" \" , out_ch_layout , 0 ) ; \n av_opt_set_int ( s , \" \" , out_sample_fmt , 0 ) ; \n av_opt_set_int ( s , \" \" , out_sample_rate , 0 ) ; \n av_opt_set_int ( s , \" \" , in_ch_layout , 0 ) ; \n av_opt_set_int ( s , \" \" , in_sample_fmt , 0 ) ; \n av_opt_set_int ( s , \" \" , in_sample_rate , 0 ) ; \n av_opt_set_int ( s , \" \" , AV_SAMPLE_FMT_NONE , 0 ) ; \n av_opt_set_int ( s , \" \" , av_get_channel_layout_nb_channels ( s -> in_ch_layout ) , 0 ) ; \n av_opt_set_int ( s , \" \" , av_get_channel_layout_nb_channels ( s -> out_ch_layout ) , 0 ) ; \n av_opt_set_int ( s , \" \" , 0 , 0 ) ; \n return s ; \n }", "idx": 9614}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int decode_frame_header ( bit_buffer_t * bitbuf , MpegEncContext * s ) { \n int frame_size_code ; \n get_bits ( bitbuf , 8 ) ; \n s -> pict_type = get_bits ( bitbuf , 2 ) ; \n if ( s -> pict_type == 3 ) \n return -1 ; \n if ( s -> pict_type == SVQ1_FRAME_INTRA ) { \n if ( s -> f_code == 0x50 || s -> f_code == 0x60 ) { \n get_bits ( bitbuf , 16 ) ; \n } \n if ( ( s -> f_code ^ 0x10 ) >= 0x50 ) { \n skip_bits ( bitbuf , 8 * get_bits ( bitbuf , 8 ) ) ; \n } \n get_bits ( bitbuf , 2 ) ; \n get_bits ( bitbuf , 2 ) ; \n get_bits ( bitbuf , 1 ) ; \n frame_size_code = get_bits ( bitbuf , 3 ) ; \n if ( frame_size_code == 7 ) { \n s -> width = get_bits ( bitbuf , 12 ) ; \n s -> height = get_bits ( bitbuf , 12 ) ; \n if ( ! s -> width || ! s -> height ) \n return -1 ; \n } else { \n s -> width = frame_size_table [ frame_size_code ] . width ; \n s -> height = frame_size_table [ frame_size_code ] . height ; \n } \n } \n if ( get_bits ( bitbuf , 1 ) == 1 ) { \n get_bits ( bitbuf , 1 ) ; \n get_bits ( bitbuf , 1 ) ; \n if ( get_bits ( bitbuf , 2 ) != 0 ) \n return -1 ; \n } \n if ( get_bits ( bitbuf , 1 ) == 1 ) { \n get_bits ( bitbuf , 1 ) ; \n get_bits ( bitbuf , 4 ) ; \n get_bits ( bitbuf , 1 ) ; \n get_bits ( bitbuf , 2 ) ; \n while ( get_bits ( bitbuf , 1 ) == 1 ) { \n get_bits ( bitbuf , 8 ) ; \n } \n } \n return 0 ; \n }", "idx": 9622}
{"project": "FFmpeg", "commit_id": "e49780f749b2ce8e229fb8257cd01f60e0661b54", "target": 0, "func": "int avcodec_default_reget_buffer ( AVCodecContext * s , AVFrame * pic ) { \n AVFrame temp_pic ; \n int i ; \n assert ( s -> codec_type == AVMEDIA_TYPE_VIDEO ) ; \n if ( pic -> data [ 0 ] && ( pic -> width != s -> width || pic -> height != s -> height || pic -> format != s -> pix_fmt ) ) { \n av_log ( s , AV_LOG_WARNING , \" \\n \" , \n pic -> width , pic -> height , av_get_pix_fmt_name ( pic -> format ) , s -> width , s -> height , av_get_pix_fmt_name ( s -> pix_fmt ) ) ; \n s -> release_buffer ( s , pic ) ; \n } \n if ( pic -> data [ 0 ] == NULL ) { \n pic -> buffer_hints |= FF_BUFFER_HINTS_READABLE ; \n return s -> get_buffer ( s , pic ) ; \n } \n if ( pic -> type == FF_BUFFER_TYPE_INTERNAL ) { \n if ( s -> pkt ) pic -> pkt_pts = s -> pkt -> pts ; \n else pic -> pkt_pts = AV_NOPTS_VALUE ; \n pic -> reordered_opaque = s -> reordered_opaque ; \n return 0 ; \n } \n temp_pic = * pic ; \n for ( i = 0 ; i < AV_NUM_DATA_POINTERS ; i ++ ) \n pic -> data [ i ] = pic -> base [ i ] = NULL ; \n pic -> opaque = NULL ; \n if ( s -> get_buffer ( s , pic ) ) \n return -1 ; \n av_picture_copy ( ( AVPicture * ) pic , ( AVPicture * ) & temp_pic , s -> pix_fmt , s -> width , \n s -> height ) ; \n s -> release_buffer ( s , & temp_pic ) ; \n return 0 ; \n }", "idx": 9644}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static av_always_inline int vc1_filter_line ( uint8_t * src , int stride , int pq ) { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int a0 = ( 2 * ( src [ -2 * stride ] - src [ 1 * stride ] ) - 5 * ( src [ -1 * stride ] - src [ 0 * stride ] ) + 4 ) >> 3 ; \n int a0_sign = a0 >> 31 ; \n a0 = ( a0 ^ a0_sign ) - a0_sign ; \n if ( a0 < pq ) { \n int a1 = FFABS ( ( 2 * ( src [ -4 * stride ] - src [ -1 * stride ] ) - 5 * ( src [ -3 * stride ] - src [ -2 * stride ] ) + 4 ) >> 3 ) ; \n int a2 = FFABS ( ( 2 * ( src [ 0 * stride ] - src [ 3 * stride ] ) - 5 * ( src [ 1 * stride ] - src [ 2 * stride ] ) + 4 ) >> 3 ) ; \n if ( a1 < a0 || a2 < a0 ) { \n int clip = src [ -1 * stride ] - src [ 0 * stride ] ; \n int clip_sign = clip >> 31 ; \n clip = ( ( clip ^ clip_sign ) - clip_sign ) >> 1 ; \n if ( clip ) { \n int a3 = FFMIN ( a1 , a2 ) ; \n int d = 5 * ( a3 - a0 ) ; \n int d_sign = ( d >> 31 ) ; \n d = ( ( d ^ d_sign ) - d_sign ) >> 3 ; \n d_sign ^= a0_sign ; \n if ( d_sign ^ clip_sign ) \n d = 0 ; \n else { \n d = FFMIN ( d , clip ) ; \n d = ( d ^ d_sign ) - d_sign ; \n src [ -1 * stride ] = cm [ src [ -1 * stride ] - d ] ; \n src [ 0 * stride ] = cm [ src [ 0 * stride ] + d ] ; \n } \n return 1 ; \n } \n } \n } \n return 0 ; \n }", "idx": 9652}
{"project": "FFmpeg", "commit_id": "1b648c7cdbee335c642bd2c05fe624fc195b85e6", "target": 0, "func": "static AVCodec * choose_codec ( OptionsContext * o , AVFormatContext * s , AVStream * st , enum AVMediaType type ) \n { \n char * codec_name = NULL ; \n MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , st ) ; \n if ( ! codec_name ) { \n if ( s -> oformat ) { \n st -> codec -> codec_id = av_guess_codec ( s -> oformat , NULL , s -> filename , NULL , type ) ; \n return avcodec_find_encoder ( st -> codec -> codec_id ) ; \n } \n } else if ( ! strcmp ( codec_name , \" \" ) ) \n st -> stream_copy = 1 ; \n else { \n st -> codec -> codec_id = find_codec_or_die ( codec_name , type , s -> iformat == NULL ) ; \n return s -> oformat ? avcodec_find_encoder_by_name ( codec_name ) : \n avcodec_find_decoder_by_name ( codec_name ) ; \n } \n return NULL ; \n }", "idx": 9653}
{"project": "FFmpeg", "commit_id": "699201ac0ef64baee261bc6fc587d00724f195af", "target": 0, "func": "static void test_copy ( const AVCodec * c1 , const AVCodec * c2 ) \n { \n AVCodecContext * ctx1 , * ctx2 ; \n printf ( \" \\n \\n \" , c1 ? c1 -> name : \" \" , c2 ? c2 -> name : \" \" ) ; \n ctx1 = avcodec_alloc_context3 ( c1 ) ; \n ctx2 = avcodec_alloc_context3 ( c2 ) ; \n ctx1 -> width = ctx1 -> height = 128 ; \n if ( ctx2 -> codec && ctx2 -> codec -> priv_class && ctx2 -> codec -> priv_data_size ) { \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n } \n avcodec_copy_context ( ctx2 , ctx1 ) ; \n test_copy_print_codec ( ctx1 ) ; \n test_copy_print_codec ( ctx2 ) ; \n if ( ctx1 -> codec ) { \n printf ( \" \\n \" ) ; \n avcodec_open2 ( ctx1 , ctx1 -> codec , NULL ) ; \n if ( ctx2 -> codec && ctx2 -> codec -> priv_class && ctx2 -> codec -> priv_data_size ) { \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n av_opt_set ( ctx2 -> priv_data , \" \" , \" \" , 0 ) ; \n } \n avcodec_copy_context ( ctx2 , ctx1 ) ; \n test_copy_print_codec ( ctx1 ) ; \n test_copy_print_codec ( ctx2 ) ; \n avcodec_close ( ctx1 ) ; \n } \n avcodec_free_context ( & ctx1 ) ; \n avcodec_free_context ( & ctx2 ) ; \n }", "idx": 9662}
{"project": "FFmpeg", "commit_id": "033e58941e684ac7190d6d1b06f31a677be4539f", "target": 0, "func": "static void search_for_pns ( AACEncContext * s , AVCodecContext * avctx , SingleChannelElement * sce ) \n { \n int start = 0 , w , w2 , g ; \n const float lambda = s -> lambda ; \n const float freq_mult = avctx -> sample_rate / ( 1024.0f / sce -> ics . num_windows ) / 2.0f ; \n const float spread_threshold = NOISE_SPREAD_THRESHOLD * ( lambda / 120.f ) ; \n const float thr_mult = NOISE_LAMBDA_NUMERATOR / lambda ; \n for ( w = 0 ; w < sce -> ics . num_windows ; w += sce -> ics . group_len [ w ] ) { \n start = 0 ; \n for ( g = 0 ; g < sce -> ics . num_swb ; g ++ ) { \n if ( start * freq_mult > NOISE_LOW_LIMIT * ( lambda / 170.0f ) ) { \n float energy = 0.0f , threshold = 0.0f , spread = 0.0f ; \n for ( w2 = 0 ; w2 < sce -> ics . group_len [ w ] ; w2 ++ ) { \n FFPsyBand * band = & s -> psy . ch [ s -> cur_channel + 0 ] . psy_bands [ ( w + w2 ) * 16 + g ] ; \n energy += band -> energy ; \n threshold += band -> threshold ; \n spread += band -> spread ; \n } \n if ( spread > spread_threshold * sce -> ics . group_len [ w ] && \n ( ( sce -> zeroes [ w * 16 + g ] && energy >= threshold ) || \n energy < threshold * thr_mult * sce -> ics . group_len [ w ] ) ) { \n sce -> band_type [ w * 16 + g ] = NOISE_BT ; \n sce -> pns_ener [ w * 16 + g ] = energy / sce -> ics . group_len [ w ] ; \n sce -> zeroes [ w * 16 + g ] = 0 ; \n } \n } \n start += sce -> ics . swb_sizes [ g ] ; \n } \n } \n }", "idx": 9665}
{"project": "FFmpeg", "commit_id": "4c9080a7ef18ad71fb0a75c8d1c1803edd780edd", "target": 0, "func": "static void default_end_frame ( AVFilterLink * inlink ) \n { \n AVFilterLink * outlink = NULL ; \n if ( inlink -> dst -> nb_outputs ) \n outlink = inlink -> dst -> outputs [ 0 ] ; \n if ( outlink ) { \n if ( outlink -> out_buf ) { \n avfilter_unref_buffer ( outlink -> out_buf ) ; \n outlink -> out_buf = NULL ; \n } \n ff_end_frame ( outlink ) ; \n } \n }", "idx": 9674}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_stereo_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 256 ] ; \n samples [ i + 256 ] = 0 ; \n } \n }", "idx": 9690}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "static int thread_execute2 ( AVCodecContext * avctx , action_func2 * func2 , void * arg , int * ret , int job_count ) \n { \n ThreadContext * c = avctx -> thread_opaque ; \n c -> func2 = func2 ; \n return thread_execute ( avctx , NULL , arg , ret , job_count , 0 ) ; \n }", "idx": 9691}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_section_header ( WriterContext * wctx ) \n { \n FlatContext * flat = wctx -> priv ; \n AVBPrint * buf = & flat -> section_header [ wctx -> level ] ; \n int i ; \n av_bprint_clear ( buf ) ; \n for ( i = 1 ; i <= wctx -> level ; i ++ ) { \n if ( flat -> hierarchical || \n ! ( wctx -> section [ i ] -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) \n av_bprintf ( buf , \" \" , wctx -> section [ i ] -> name , flat -> sep_str ) ; \n } \n }", "idx": 9692}
{"project": "FFmpeg", "commit_id": "269fc8e04906ffd965aa19425ca90980b23c6508", "target": 0, "func": "static int write_header ( AVFormatContext * s ) \n { \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n if ( s -> nb_streams > 1 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( codec -> codec_id != AV_CODEC_ID_WAVPACK ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( codec -> extradata_size > 0 ) { \n avpriv_report_missing_feature ( s , \" \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avpriv_set_pts_info ( s -> streams [ 0 ] , 64 , 1 , codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 9693}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int default_start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterLink * outlink = NULL ; \n if ( inlink -> dst -> nb_outputs ) \n outlink = inlink -> dst -> outputs [ 0 ] ; \n if ( outlink ) { \n outlink -> out_buf = ff_get_video_buffer ( outlink , AV_PERM_WRITE , outlink -> w , outlink -> h ) ; \n if ( ! outlink -> out_buf ) \n return AVERROR ( ENOMEM ) ; \n avfilter_copy_buffer_ref_props ( outlink -> out_buf , picref ) ; \n return ff_start_frame ( outlink , avfilter_ref_buffer ( outlink -> out_buf , ~ 0 ) ) ; \n } \n return 0 ; \n }", "idx": 9694}
{"project": "FFmpeg", "commit_id": "92fabca427ff2d8fffa4bd4f09839d8d3822ef31", "target": 0, "func": "static void DEF ( put , pixels8_x2 ) ( uint8_t * block , const uint8_t * pixels , ptrdiff_t line_size , int h ) \n { \n MOVQ_BFE ( mm6 ) ; \n __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGBP ( % % mm0 , % % mm1 , % % mm4 , % % mm2 , % % mm3 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PAVGBP ( % % mm0 , % % mm1 , % % mm4 , % % mm2 , % % mm3 , % % mm5 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( h ) , \" \" ( pixels ) , \" \" ( block ) \n : \" \" ( ( x86_reg ) line_size ) \n : REG_a , \" \" ) ; \n }", "idx": 9716}
{"project": "FFmpeg", "commit_id": "e3fc4481b6dd60acdb9f3e370ee9a1d1bd4ddd73", "target": 1, "func": "static int vqf_probe ( AVProbeData * probe_packet ) \n { \n if ( AV_RL32 ( probe_packet -> buf ) != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return 0 ; \n if ( ! memcmp ( probe_packet -> buf + 4 , \" \" , 8 ) ) \n return AVPROBE_SCORE_MAX ; \n if ( ! memcmp ( probe_packet -> buf + 4 , \" \" , 8 ) ) \n return AVPROBE_SCORE_MAX ; \n return AVPROBE_SCORE_EXTENSION ; \n }", "idx": 9718}
{"project": "FFmpeg", "commit_id": "0c46e958d1fd3817b8e9fa048d0450d509c80378", "target": 1, "func": "static int mxf_get_d10_aes3_packet ( AVIOContext * pb , AVStream * st , AVPacket * pkt , int64_t length ) \n { \n const uint8_t * buf_ptr , * end_ptr ; \n uint8_t * data_ptr ; \n int i ; \n if ( length > 61444 ) \n return -1 ; \n av_new_packet ( pkt , length ) ; \n avio_read ( pb , pkt -> data , length ) ; \n data_ptr = pkt -> data ; \n end_ptr = pkt -> data + length ; \n buf_ptr = pkt -> data + 4 ; \n for ( ; buf_ptr < end_ptr ; ) { \n for ( i = 0 ; i < st -> codec -> channels ; i ++ ) { \n uint32_t sample = bytestream_get_le32 ( & buf_ptr ) ; \n if ( st -> codec -> bits_per_coded_sample == 24 ) \n bytestream_put_le24 ( & data_ptr , ( sample >> 4 ) & 0xffffff ) ; \n else \n bytestream_put_le16 ( & data_ptr , ( sample >> 12 ) & 0xffff ) ; \n } \n buf_ptr += 32 - st -> codec -> channels * 4 ; \n } \n pkt -> size = data_ptr - pkt -> data ; \n return 0 ; \n }", "idx": 9723}
{"project": "FFmpeg", "commit_id": "34a8dcd031d637273cdea021e5a79cf720c4c51c", "target": 0, "func": "static int decode_end ( AVCodecContext * avctx ) \n { \n SmackVContext * const smk = ( SmackVContext * ) avctx -> priv_data ; \n if ( smk -> mmap_tbl ) \n av_free ( smk -> mmap_tbl ) ; \n if ( smk -> mclr_tbl ) \n av_free ( smk -> mclr_tbl ) ; \n if ( smk -> full_tbl ) \n av_free ( smk -> full_tbl ) ; \n if ( smk -> type_tbl ) \n av_free ( smk -> type_tbl ) ; \n if ( smk -> pic . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & smk -> pic ) ; \n return 0 ; \n }", "idx": 9725}
{"project": "FFmpeg", "commit_id": "3d3243577cfdca6dec39a8c4e75feefd2a170f90", "target": 0, "func": "static void test_sum_square ( void ) \n { \n INTFLOAT res0 ; \n INTFLOAT res1 ; \n LOCAL_ALIGNED_16 ( INTFLOAT , src ,  [ 256 ] ,  [ 2 ] ) ; \n declare_func ( INTFLOAT , INTFLOAT ( * x ) [ 2 ] , int n ) ; \n randomize ( ( INTFLOAT * ) src , 256 * 2 ) ; \n res0 = call_ref ( src , 256 ) ; \n res1 = call_new ( src , 256 ) ; \n if ( ! float_near_abs_eps ( res0 , res1 , EPS ) ) \n fail ( ) ; \n bench_new ( src , 256 ) ; \n }", "idx": 9726}
{"project": "FFmpeg", "commit_id": "aabdc4618788a90c4a2b64a569f560d5b7378271", "target": 1, "func": "static void idcin_decode_vlcs ( IdcinContext * s ) \n { \n hnode_t * hnodes ; \n long x , y ; \n int prev ; \n unsigned char v = 0 ; \n int bit_pos , node_num , dat_pos ; \n prev = bit_pos = dat_pos = 0 ; \n for ( y = 0 ; y < ( s -> frame . linesize [ 0 ] * s -> avctx -> height ) ; \n y += s -> frame . linesize [ 0 ] ) { \n for ( x = y ; x < y + s -> avctx -> width ; x ++ ) { \n node_num = s -> num_huff_nodes [ prev ] ; \n hnodes = s -> huff_nodes [ prev ] ; \n while ( node_num >= HUF_TOKENS ) { \n if ( ! bit_pos ) { \n if ( dat_pos > s -> size ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n bit_pos = 8 ; \n v = s -> buf [ dat_pos ++ ] ; \n } \n node_num = hnodes [ node_num ] . children [ v & 0x01 ] ; \n v = v >> 1 ; \n bit_pos -- ; \n } \n s -> frame . data [ 0 ] [ x ] = node_num ; \n prev = node_num ; \n } \n } \n }", "idx": 9762}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int dshow_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n AVPacketList * pktl = NULL ; \n while ( ! ctx -> eof && ! pktl ) { \n WaitForSingleObject ( ctx -> mutex , INFINITE ) ; \n pktl = ctx -> pktl ; \n if ( pktl ) { \n * pkt = pktl -> pkt ; \n ctx -> pktl = ctx -> pktl -> next ; \n av_free ( pktl ) ; \n ctx -> curbufsize -= pkt -> size ; \n } \n ResetEvent ( ctx -> event [ 1 ] ) ; \n ReleaseMutex ( ctx -> mutex ) ; \n if ( ! pktl ) { \n if ( dshow_check_event_queue ( ctx -> media_event ) < 0 ) { \n ctx -> eof = 1 ; \n } else if ( s -> flags & AVFMT_FLAG_NONBLOCK ) { \n return AVERROR ( EAGAIN ) ; \n } else { \n WaitForMultipleObjects ( 2 , ctx -> event , 0 , INFINITE ) ; \n } \n } \n } \n return ctx -> eof ? AVERROR ( EIO ) : pkt -> size ; \n }", "idx": 9767}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_encode_frame ( AVCodecContext * avctx , \n unsigned char * frame , int buf_size , const void * data ) \n { \n ADXContext * c = avctx -> priv_data ; \n const short * samples = data ; \n unsigned char * dst = frame ; \n int rest = avctx -> frame_size ; \n if ( ! c -> header_parsed ) { \n int hdrsize = adx_encode_header ( avctx , dst , buf_size ) ; \n dst += hdrsize ; \n c -> header_parsed = 1 ; \n } \n if ( avctx -> channels == 1 ) { \n while ( rest >= 32 ) { \n adx_encode ( dst , samples , c -> prev ) ; \n dst += 18 ; \n samples += 32 ; \n rest -= 32 ; \n } \n } else { \n while ( rest >= 32 * 2 ) { \n short tmpbuf [ 32 * 2 ] ; \n int i ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n tmpbuf [ i ] = samples [ i * 2 ] ; \n tmpbuf [ i + 32 ] = samples [ i * 2 + 1 ] ; \n } \n adx_encode ( dst , tmpbuf , c -> prev ) ; \n adx_encode ( dst + 18 , tmpbuf + 32 , c -> prev + 1 ) ; \n dst += 18 * 2 ; \n samples += 32 * 2 ; \n rest -= 32 * 2 ; \n } \n } \n return dst - frame ; \n }", "idx": 9769}
{"project": "FFmpeg", "commit_id": "6c0107822d3ed7588fa857c3ed1ee886b4ba62e9", "target": 1, "func": "static int diff_C ( unsigned char * old , unsigned char * new , int os , int ns ) \n { \n int x , y , d = 0 ; \n for ( y = 8 ; y ; y -- ) { \n for ( x = 8 ; x ; x -- ) { \n d += abs ( new [ x ] - old [ x ] ) ; \n } \n new += ns ; \n old += os ; \n } \n return d ; \n }", "idx": 9782}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "void ff_id3v1_read ( AVFormatContext * s ) \n { \n int ret ; \n uint8_t buf [ ID3v1_TAG_SIZE ] ; \n int64_t filesize , position = avio_tell ( s -> pb ) ; \n if ( s -> pb -> seekable ) { \n filesize = avio_size ( s -> pb ) ; \n if ( filesize > 128 ) { \n avio_seek ( s -> pb , filesize - 128 , SEEK_SET ) ; \n ret = avio_read ( s -> pb , buf , ID3v1_TAG_SIZE ) ; \n if ( ret == ID3v1_TAG_SIZE ) { \n parse_tag ( s , buf ) ; \n } \n avio_seek ( s -> pb , position , SEEK_SET ) ; \n } \n } \n }", "idx": 9796}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int dvvideo_encode_init ( AVCodecContext * avctx ) \n { \n DVVideoContext * s = avctx -> priv_data ; \n FDCTDSPContext fdsp ; \n MECmpContext mecc ; \n PixblockDSPContext pdsp ; \n int ret ; \n s -> sys = av_dv_codec_profile ( avctx -> width , avctx -> height , avctx -> pix_fmt ) ; \n if ( ! s -> sys ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" , \n avctx -> width , avctx -> height , av_get_pix_fmt_name ( avctx -> pix_fmt ) ) ; \n ff_dv_print_profiles ( avctx , AV_LOG_ERROR ) ; \n return AVERROR ( EINVAL ) ; \n } \n ret = ff_dv_init_dynamic_tables ( s , s -> sys ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n dv_vlc_map_tableinit ( ) ; \n ff_fdctdsp_init ( & fdsp , avctx ) ; \n ff_me_cmp_init ( & mecc , avctx ) ; \n ff_pixblockdsp_init ( & pdsp , avctx ) ; \n ff_set_cmp ( & mecc , mecc . ildct_cmp , avctx -> ildct_cmp ) ; \n s -> get_pixels = pdsp . get_pixels ; \n s -> ildct_cmp = mecc . ildct_cmp [ 5 ] ; \n s -> fdct [ 0 ] = fdsp . fdct ; \n s -> fdct [ 1 ] = fdsp . fdct248 ; \n return ff_dvvideo_init ( avctx ) ; \n }", "idx": 9797}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb48_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n const uint8_t * r = ( const uint8_t * ) c -> table_rV [ V ] , \n * g = ( const uint8_t * ) ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = ( const uint8_t * ) c -> table_bU [ U ] ; \n dest [ 0 ] = dest [ 1 ] = r_b [ Y1 ] ; \n dest [ 2 ] = dest [ 3 ] = g [ Y1 ] ; \n dest [ 4 ] = dest [ 5 ] = b_r [ Y1 ] ; \n dest [ 6 ] = dest [ 7 ] = r_b [ Y2 ] ; \n dest [ 8 ] = dest [ 9 ] = g [ Y2 ] ; \n dest [ 10 ] = dest [ 11 ] = b_r [ Y2 ] ; \n dest += 12 ; \n } \n }", "idx": 9798}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "int av_cold ff_celt_pvq_init ( CeltPVQ * * pvq , int encode ) \n { \n CeltPVQ * s = av_malloc ( sizeof ( CeltPVQ ) ) ; \n if ( ! s ) \n return AVERROR ( ENOMEM ) ; \n s -> pvq_search = ppp_pvq_search_c ; \n s -> quant_band = encode ? pvq_encode_band : pvq_decode_band ; \n s -> band_cost = pvq_band_cost ; \n if ( ARCH_X86 ) \n ff_opus_dsp_init_x86 ( s ) ; \n * pvq = s ; \n return 0 ; \n }", "idx": 9811}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static void update ( NUTContext * nut , int stream_index , int64_t frame_start , int frame_type , int frame_code , int key_frame , int size , int64_t pts ) { \n StreamContext * stream = & nut -> stream [ stream_index ] ; \n stream -> last_key_frame = key_frame ; \n nut -> last_frame_start [ frame_type ] = frame_start ; \n update_lru ( stream -> lru_pts_delta , pts - stream -> last_pts , 3 ) ; \n update_lru ( stream -> lru_size , size , 2 ) ; \n stream -> last_pts = pts ; \n if ( nut -> frame_code [ frame_code ] . flags & FLAG_PTS \n && nut -> frame_code [ frame_code ] . flags & FLAG_FULL_PTS ) \n stream -> last_full_pts = pts ; \n }", "idx": 9819}
{"project": "FFmpeg", "commit_id": "507dce2536fea4b78a9f4973f77e1fa20cfe1b81", "target": 0, "func": "void ff_rv34dsp_init_neon ( RV34DSPContext * c , DSPContext * dsp ) \n { \n c -> rv34_inv_transform = ff_rv34_inv_transform_noround_neon ; \n c -> rv34_inv_transform_dc = ff_rv34_inv_transform_noround_dc_neon ; \n c -> rv34_idct_add = ff_rv34_idct_add_neon ; \n c -> rv34_idct_dc_add = ff_rv34_idct_dc_add_neon ; \n }", "idx": 9820}
{"project": "FFmpeg", "commit_id": "15e9c4afdc8efbf8da86bb3f7eaf374310b44bf8", "target": 0, "func": "static int request_samples ( AVFilterContext * ctx , int min_samples ) \n { \n MixContext * s = ctx -> priv ; \n int i , ret ; \n av_assert0 ( s -> nb_inputs > 1 ) ; \n for ( i = 1 ; i < s -> nb_inputs ; i ++ ) { \n ret = 0 ; \n if ( ! ( s -> input_state [ i ] & INPUT_ON ) ) \n continue ; \n if ( av_audio_fifo_size ( s -> fifos [ i ] ) >= min_samples ) \n continue ; \n ret = ff_request_frame ( ctx -> inputs [ i ] ) ; \n if ( ret == AVERROR_EOF ) { \n s -> input_state [ i ] |= INPUT_EOF ; \n if ( av_audio_fifo_size ( s -> fifos [ i ] ) == 0 ) { \n s -> input_state [ i ] = 0 ; \n continue ; \n } \n } else if ( ret < 0 ) \n return ret ; \n } \n return output_frame ( ctx -> outputs [ 0 ] , 1 ) ; \n }", "idx": 9821}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_dc_add_c ( uint8_t * dest \n , int line_size , const DCTELEM * block \n ) { \n int i , dc = ( block [ 0 ] + 15 ) >> 5 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = av_clip_uint8 ( dest [ 0 ] + dc ) ; \n dest [ 1 ] = av_clip_uint8 ( dest [ 1 ] + dc ) ; \n dest [ 2 ] = av_clip_uint8 ( dest [ 2 ] + dc ) ; \n dest [ 3 ] = av_clip_uint8 ( dest [ 3 ] + dc ) ; \n dest [ 4 ] = av_clip_uint8 ( dest [ 4 ] + dc ) ; \n dest [ 5 ] = av_clip_uint8 ( dest [ 5 ] + dc ) ; \n dest [ 6 ] = av_clip_uint8 ( dest [ 6 ] + dc ) ; \n dest [ 7 ] = av_clip_uint8 ( dest [ 7 ] + dc ) ; \n dest += line_size ; \n } \n }", "idx": 9822}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "static enum AVPixelFormat mpeg_get_pixelformat ( AVCodecContext * avctx ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n const enum AVPixelFormat * pix_fmts ; \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( avctx -> xvmc_acceleration )  \n return ff_get_format ( avctx , pixfmt_xvmc_mpg2_420 ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( s -> chroma_format < 2 ) \n pix_fmts = mpeg12_hwaccel_pixfmt_list_420 ; \n else if ( s -> chroma_format == 2 ) \n pix_fmts = mpeg12_pixfmt_list_422 ; \n else \n pix_fmts = mpeg12_pixfmt_list_444 ; \n return ff_get_format ( avctx , pix_fmts ) ; \n }", "idx": 9823}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int advanced_decode_picture_secondary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int index , status = 0 ; \n switch ( v -> s . pict_type ) \n { \n case P_TYPE : status = decode_p_picture_secondary_header ( v ) ; break ; \n case B_TYPE : status = decode_b_picture_secondary_header ( v ) ; break ; \n case BI_TYPE : \n case I_TYPE : status = decode_i_picture_secondary_header ( v ) ; break ; \n } \n if ( status < 0 ) return FRAME_SKIPED ; \n v -> ac_table_level = decode012 ( gb ) ; \n if ( v -> s . pict_type == I_TYPE || v -> s . pict_type == BI_TYPE ) \n { \n v -> ac2_table_level = decode012 ( gb ) ; \n } \n index = decode012 ( gb ) ; \n v -> luma_dc_vlc = & ff_msmp4_dc_luma_vlc [ index ] ; \n v -> chroma_dc_vlc = & ff_msmp4_dc_chroma_vlc [ index ] ; \n return 0 ; \n }", "idx": 9830}
{"project": "FFmpeg", "commit_id": "5b8009f4c80d8fd96523c8c163441ad4011ad472", "target": 1, "func": "static inline void range_dec_normalize ( APEContext * ctx ) \n { \n while ( ctx -> rc . range <= BOTTOM_VALUE ) { \n ctx -> rc . buffer <<= 8 ; \n if ( ctx -> ptr < ctx -> data_end ) \n ctx -> rc . buffer += * ctx -> ptr ; \n ctx -> ptr ++ ; \n ctx -> rc . low = ( ctx -> rc . low << 8 ) | ( ( ctx -> rc . buffer >> 1 ) & 0xFF ) ; \n ctx -> rc . range <<= 8 ; \n } \n }", "idx": 9833}
{"project": "FFmpeg", "commit_id": "b2a7c017336b19afc045e8a7385999c1896d4b45", "target": 0, "func": "void ff_mpc_dequantize_and_synth ( MPCContext * c , int maxband , void * data , int channels ) \n { \n int i , j , ch ; \n Band * bands = c -> bands ; \n int off ; \n float mul ; \n memset ( c -> sb_samples , 0 , sizeof ( c -> sb_samples ) ) ; \n off = 0 ; \n for ( i = 0 ; i <= maxband ; i ++ , off += SAMPLES_PER_BAND ) { \n for ( ch = 0 ; ch < 2 ; ch ++ ) { \n if ( bands [ i ] . res [ ch ] ) { \n j = 0 ; \n mul = mpc_CC [ bands [ i ] . res [ ch ] ] * mpc_SCF [ bands [ i ] . scf_idx [ ch ] [ 0 ] & 0xFF ] ; \n for ( ; j < 12 ; j ++ ) \n c -> sb_samples [ ch ] [ j ] [ i ] = mul * c -> Q [ ch ] [ j + off ] ; \n mul = mpc_CC [ bands [ i ] . res [ ch ] ] * mpc_SCF [ bands [ i ] . scf_idx [ ch ] [ 1 ] & 0xFF ] ; \n for ( ; j < 24 ; j ++ ) \n c -> sb_samples [ ch ] [ j ] [ i ] = mul * c -> Q [ ch ] [ j + off ] ; \n mul = mpc_CC [ bands [ i ] . res [ ch ] ] * mpc_SCF [ bands [ i ] . scf_idx [ ch ] [ 2 ] & 0xFF ] ; \n for ( ; j < 36 ; j ++ ) \n c -> sb_samples [ ch ] [ j ] [ i ] = mul * c -> Q [ ch ] [ j + off ] ; \n } \n } \n if ( bands [ i ] . msf ) { \n int t1 , t2 ; \n for ( j = 0 ; j < SAMPLES_PER_BAND ; j ++ ) { \n t1 = c -> sb_samples [ 0 ] [ j ] [ i ] ; \n t2 = c -> sb_samples [ 1 ] [ j ] [ i ] ; \n c -> sb_samples [ 0 ] [ j ] [ i ] = t1 + t2 ; \n c -> sb_samples [ 1 ] [ j ] [ i ] = t1 - t2 ; \n } \n } \n } \n mpc_synth ( c , data , channels ) ; \n }", "idx": 9868}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static int decode_slice_luma ( AVCodecContext * avctx , SliceContext * slice , \n uint16_t * dst , int dst_stride , \n const uint8_t * buf , unsigned buf_size , \n const int16_t * qmat ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n LOCAL_ALIGNED_16 ( int16_t , blocks ,  [ 8 * 4 * 64 ] ) ; \n int16_t * block ; \n GetBitContext gb ; \n int i , blocks_per_slice = slice -> mb_count << 2 ; \n int ret ; \n for ( i = 0 ; i < blocks_per_slice ; i ++ ) \n ctx -> bdsp . clear_block ( blocks + ( i << 6 ) ) ; \n init_get_bits ( & gb , buf , buf_size << 3 ) ; \n decode_dc_coeffs ( & gb , blocks , blocks_per_slice ) ; \n if ( ( ret = decode_ac_coeffs ( avctx , & gb , blocks , blocks_per_slice ) ) < 0 ) \n return ret ; \n block = blocks ; \n for ( i = 0 ; i < slice -> mb_count ; i ++ ) { \n ctx -> prodsp . idct_put ( dst , dst_stride , block + ( 0 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 8 , dst_stride , block + ( 1 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 4 * dst_stride , dst_stride , block + ( 2 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 4 * dst_stride + 8 , dst_stride , block + ( 3 << 6 ) , qmat ) ; \n block += 4 * 64 ; \n dst += 16 ; \n } \n return 0 ; \n }", "idx": 9877}
{"project": "FFmpeg", "commit_id": "44f110f509d0ab4fc73b9f2363a97c6577d3850f", "target": 1, "func": "static int read_uncompressed_sgi ( const SGIInfo * si , \n AVPicture * pict , ByteIOContext * f ) \n { \n int x , y , z , chan_offset , ret = 0 ; \n uint8_t * dest_row , * tmp_row = NULL ; \n tmp_row = av_malloc ( si -> xsize ) ; \n url_fseek ( f , SGI_HEADER_SIZE , SEEK_SET ) ; \n pict -> linesize [ 0 ] = si -> xsize ; \n for ( z = 0 ; z < si -> zsize ; z ++ ) { \n #ifndef WORDS_BIGENDIAN \n if ( si -> zsize == 4 && z != 3 ) \n chan_offset = 2 - z ; \n else \n #endif \n chan_offset = z ; \n for ( y = si -> ysize - 1 ; y >= 0 ; y -- ) { \n dest_row = pict -> data [ 0 ] + ( y * si -> xsize * si -> zsize ) ; \n if ( ! get_buffer ( f , tmp_row , si -> xsize ) ) { \n ret = -1 ; \n goto cleanup ; \n } \n for ( x = 0 ; x < si -> xsize ; x ++ ) { \n dest_row [ chan_offset ] = tmp_row [ x ] ; \n dest_row += si -> zsize ; \n } \n } \n } \n cleanup : \n av_free ( tmp_row ) ; \n return ret ; \n }", "idx": 9878}
{"project": "FFmpeg", "commit_id": "ee715f49a06bf3898246d01b056284a9bb1bcbb9", "target": 1, "func": "static av_cold int dfa_decode_init ( AVCodecContext * avctx ) \n { \n DfaContext * s = avctx -> priv_data ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n s -> frame_buf = av_mallocz ( avctx -> width * avctx -> height + AV_LZO_OUTPUT_PADDING ) ; \n if ( ! s -> frame_buf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 9886}
{"project": "FFmpeg", "commit_id": "b9d2005ea5d6837917a69bc2b8e98f5695f54e39", "target": 1, "func": "static void free_stream ( AVStream * * pst ) \n { \n AVStream * st = * pst ; \n int i ; \n if ( ! st ) \n return ; \n for ( i = 0 ; i < st -> nb_side_data ; i ++ ) \n av_freep ( & st -> side_data [ i ] . data ) ; \n av_freep ( & st -> side_data ) ; \n if ( st -> parser ) \n av_parser_close ( st -> parser ) ; \n if ( st -> attached_pic . data ) \n av_packet_unref ( & st -> attached_pic ) ; \n if ( st -> internal ) { \n avcodec_free_context ( & st -> internal -> avctx ) ; \n for ( i = 0 ; i < st -> internal -> nb_bsfcs ; i ++ ) { \n av_bsf_free ( & st -> internal -> bsfcs [ i ] ) ; \n av_freep ( & st -> internal -> bsfcs ) ; \n } \n av_bsf_free ( & st -> internal -> extract_extradata . bsf ) ; \n av_packet_free ( & st -> internal -> extract_extradata . pkt ) ; \n } \n av_freep ( & st -> internal ) ; \n av_dict_free ( & st -> metadata ) ; \n avcodec_parameters_free ( & st -> codecpar ) ; \n av_freep ( & st -> probe_data . buf ) ; \n av_freep ( & st -> index_entries ) ; \n #if FF_API_LAVF_AVCTX  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n av_freep ( & st -> codec -> extradata ) ; \n av_freep ( & st -> codec -> subtitle_header ) ; \n av_freep ( & st -> codec ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n av_freep ( & st -> priv_data ) ; \n if ( st -> info ) \n av_freep ( & st -> info -> duration_error ) ; \n av_freep ( & st -> info ) ; \n av_freep ( & st -> recommended_encoder_configuration ) ; \n av_freep ( & st -> priv_pts ) ; \n av_freep ( pst ) ; \n }", "idx": 9903}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred16x16_horizontal ) ( uint8_t * _src , int stride ) { \n int i ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 2 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 3 ] = PIXEL_SPLAT_X4 ( src [ -1 + i * stride ] ) ; \n } \n }", "idx": 9905}
{"project": "FFmpeg", "commit_id": "1546d487cf12da37d90a080813f8d57ac33036bf", "target": 1, "func": "static int get_dimension ( GetBitContext * gb , const int * dim ) \n { \n int t = get_bits ( gb , 3 ) ; \n int val = dim [ t ] ; \n if ( val < 0 ) \n val = dim [ get_bits1 ( gb ) - val ] ; \n if ( ! val ) { \n do { \n t = get_bits ( gb , 8 ) ; \n val += t << 2 ; \n } while ( t == 0xFF ) ; \n } \n return val ; \n }", "idx": 9915}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avformat_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 9918}
{"project": "FFmpeg", "commit_id": "29b5f3115d9f217758bebd1d00e541aa3e739d2a", "target": 0, "func": "int ff_framesync_dualinput_get_writable ( FFFrameSync * fs , AVFrame * * f0 , AVFrame * * f1 ) \n { \n int ret ; \n ret = ff_framesync_dualinput_get ( fs , f0 , f1 ) ; \n if ( ret < 0 ) \n return ret ; \n ret = ff_inlink_make_frame_writable ( fs -> parent -> inputs [ 0 ] , f0 ) ; \n if ( ret < 0 ) { \n av_frame_free ( f0 ) ; \n av_frame_free ( f1 ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 9920}
{"project": "FFmpeg", "commit_id": "8ef9dcf1d74aea55bf39f1e479fe67e98d973954", "target": 1, "func": "void ff_mpeg_set_erpic ( ERPicture * dst , Picture * src ) \n { \n int i ; \n if ( ! src ) \n return ; \n dst -> f = & src -> f ; \n dst -> tf = & src -> tf ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n dst -> motion_val [ i ] = src -> motion_val [ i ] ; \n dst -> ref_index [ i ] = src -> ref_index [ i ] ; \n } \n dst -> mb_type = src -> mb_type ; \n dst -> field_picture = src -> field_picture ; \n }", "idx": 9924}
{"project": "FFmpeg", "commit_id": "b5eab66e9fe6c93056e414b0b4a70a34948843e1", "target": 1, "func": "void avfilter_default_start_frame ( AVFilterLink * link , AVFilterPicRef * picref ) \n { \n AVFilterLink * out = NULL ; \n if ( link -> dst -> output_count ) \n out = link -> dst -> outputs [ 0 ] ; \n if ( out ) { \n out -> outpic = avfilter_get_video_buffer ( out , AV_PERM_WRITE , link -> w , link -> h ) ; \n out -> outpic -> pts = picref -> pts ; \n avfilter_start_frame ( out , avfilter_ref_pic ( out -> outpic , ~ 0 ) ) ; \n } \n }", "idx": 9930}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void choose_sample_fmt ( AVStream * st , AVCodec * codec ) \n { \n if ( codec && codec -> sample_fmts ) { \n const enum AVSampleFormat * p = codec -> sample_fmts ; \n for ( ; * p != -1 ; p ++ ) { \n if ( * p == st -> codec -> sample_fmt ) \n break ; \n } \n if ( * p == -1 ) { \n av_log ( NULL , AV_LOG_WARNING , \n \" \\n \" , \n av_get_sample_fmt_name ( st -> codec -> sample_fmt ) , \n codec -> name , \n av_get_sample_fmt_name ( codec -> sample_fmts [ 0 ] ) ) ; \n st -> codec -> sample_fmt = codec -> sample_fmts [ 0 ] ; \n } \n } \n }", "idx": 9933}
{"project": "FFmpeg", "commit_id": "d23b28c78b56f53f3f0e74edb0f15a3b451207ad", "target": 0, "func": "static inline void decode_hrd_parameters ( H264Context * h , SPS * sps ) { \n MpegEncContext * const s = & h -> s ; \n int cpb_count , i ; \n cpb_count = get_ue_golomb ( & s -> gb ) + 1 ; \n get_bits ( & s -> gb , 4 ) ; \n get_bits ( & s -> gb , 4 ) ; \n for ( i = 0 ; i < cpb_count ; i ++ ) { \n get_ue_golomb ( & s -> gb ) ; \n get_ue_golomb ( & s -> gb ) ; \n get_bits1 ( & s -> gb ) ; \n } \n get_bits ( & s -> gb , 5 ) ; \n sps -> cpb_removal_delay_length = get_bits ( & s -> gb , 5 ) + 1 ; \n sps -> dpb_output_delay_length = get_bits ( & s -> gb , 5 ) + 1 ; \n sps -> time_offset_length = get_bits ( & s -> gb , 5 ) ; \n }", "idx": 9951}
{"project": "FFmpeg", "commit_id": "ee7f2609a0dcac4008759f20ab9558a68d759821", "target": 0, "func": "static void reanalyze ( MpegTSContext * ts ) { \n AVIOContext * pb = ts -> stream -> pb ; \n int64_t pos = avio_tell ( pb ) ; \n if ( pos < 0 ) \n return ; \n pos += ts -> raw_packet_size - ts -> pos47_full ; \n if ( pos == TS_PACKET_SIZE ) { \n ts -> size_stat [ 0 ] ++ ; \n } else if ( pos == TS_DVHS_PACKET_SIZE ) { \n ts -> size_stat [ 1 ] ++ ; \n } else if ( pos == TS_FEC_PACKET_SIZE ) { \n ts -> size_stat [ 2 ] ++ ; \n } \n ts -> size_stat_count ++ ; \n if ( ts -> size_stat_count > SIZE_STAT_THRESHOLD ) { \n int newsize = 0 ; \n if ( ts -> size_stat [ 0 ] > SIZE_STAT_THRESHOLD ) { \n newsize = TS_PACKET_SIZE ; \n } else if ( ts -> size_stat [ 1 ] > SIZE_STAT_THRESHOLD ) { \n newsize = TS_DVHS_PACKET_SIZE ; \n } else if ( ts -> size_stat [ 2 ] > SIZE_STAT_THRESHOLD ) { \n newsize = TS_FEC_PACKET_SIZE ; \n } \n if ( newsize ) { \n av_log ( ts -> stream , AV_LOG_WARNING , \" \\n \" , newsize ) ; \n ts -> raw_packet_size = newsize ; \n } \n ts -> size_stat_count = 0 ; \n memset ( ts -> size_stat , 0 , sizeof ( ts -> size_stat ) ) ; \n } \n }", "idx": 9966}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int svq1_encode_frame ( AVCodecContext * avctx , unsigned char * buf , \n int buf_size , void * data ) \n { \n SVQ1Context * const s = avctx -> priv_data ; \n AVFrame * pict = data ; \n AVFrame * const p = ( AVFrame * ) & s -> picture ; \n AVFrame temp ; \n int i ; \n if ( avctx -> pix_fmt != PIX_FMT_YUV410P ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( ! s -> current_picture . data [ 0 ] ) { \n avctx -> get_buffer ( avctx , & s -> current_picture ) ; \n avctx -> get_buffer ( avctx , & s -> last_picture ) ; \n } \n temp = s -> current_picture ; \n s -> current_picture = s -> last_picture ; \n s -> last_picture = temp ; \n init_put_bits ( & s -> pb , buf , buf_size ) ; \n * p = * pict ; \n p -> pict_type = avctx -> frame_number % avctx -> gop_size ? P_TYPE : I_TYPE ; \n p -> key_frame = p -> pict_type == I_TYPE ; \n svq1_write_header ( s , p -> pict_type ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n svq1_encode_plane ( s , i , \n s -> picture . data [ i ] , s -> last_picture . data [ i ] , s -> current_picture . data [ i ] , \n s -> frame_width / ( i ? 4 : 1 ) , s -> frame_height / ( i ? 4 : 1 ) , \n s -> picture . linesize [ i ] , s -> current_picture . linesize [ i ] ) ; \n } \n while ( put_bits_count ( & s -> pb ) & 31 ) \n put_bits ( & s -> pb , 1 , 0 ) ; \n flush_put_bits ( & s -> pb ) ; \n return ( put_bits_count ( & s -> pb ) / 8 ) ; \n }", "idx": 9985}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src - 2 , \n src - ( stride * 2 ) , stride , dst , stride , 16 ) ; \n }", "idx": 9988}
{"project": "FFmpeg", "commit_id": "be42c0b8d57fe2ea769892d102ffd5561dc18709", "target": 0, "func": "static int rm_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n RMDemuxContext * rm = s -> priv_data ; \n AVStream * st ; \n int i , len , res , seq = 1 ; \n int64_t timestamp , pos ; \n int flags ; \n for ( ; ; ) { \n if ( rm -> audio_pkt_cnt ) { \n st = s -> streams [ rm -> audio_stream_num ] ; \n ff_rm_retrieve_cache ( s , s -> pb , st , st -> priv_data , pkt ) ; \n flags = 0 ; \n } else { \n if ( rm -> old_format ) { \n RMStream * ast ; \n st = s -> streams [ 0 ] ; \n ast = st -> priv_data ; \n timestamp = AV_NOPTS_VALUE ; \n len = ! ast -> audio_framesize ? RAW_PACKET_SIZE : \n ast -> coded_framesize * ast -> sub_packet_h / 2 ; \n flags = ( seq ++ == 1 ) ? 2 : 0 ; \n pos = avio_tell ( s -> pb ) ; \n } else { \n len = sync ( s , & timestamp , & flags , & i , & pos ) ; \n if ( len > 0 ) \n st = s -> streams [ i ] ; \n } \n if ( len < 0 || s -> pb -> eof_reached ) \n return AVERROR ( EIO ) ; \n res = ff_rm_parse_packet ( s , s -> pb , st , st -> priv_data , len , pkt , \n & seq , flags , timestamp ) ; \n if ( ( flags & 2 ) && ( seq & 0x7F ) == 1 ) \n av_add_index_entry ( st , pos , timestamp , 0 , 0 , AVINDEX_KEYFRAME ) ; \n if ( res ) \n continue ; \n } \n if ( ( st -> discard >= AVDISCARD_NONKEY && ! ( flags & 2 ) ) \n || st -> discard >= AVDISCARD_ALL ) { \n av_free_packet ( pkt ) ; \n } else \n break ; \n } \n return 0 ; \n }", "idx": 9990}
{"project": "FFmpeg", "commit_id": "ee7a642b0e5da1730cfc66008d2f2976fa37a692", "target": 0, "func": "static int analyze ( const uint8_t * buf , int size , int packet_size , int * index , \n int probe ) \n { \n int stat [ TS_MAX_PACKET_SIZE ] ; \n int stat_all = 0 ; \n int i ; \n int best_score = 0 ; \n memset ( stat , 0 , packet_size * sizeof ( * stat ) ) ; \n for ( i = 0 ; i < size - 3 ; i ++ ) { \n if ( buf [ i ] == 0x47 && \n ( ! probe || ( ! ( buf [ i + 1 ] & 0x80 ) && buf [ i + 3 ] != 0x47 ) ) ) { \n int x = i % packet_size ; \n stat [ x ] ++ ; \n stat_all ++ ; \n if ( stat [ x ] > best_score ) { \n best_score = stat [ x ] ; \n if ( index ) \n * index = x ; \n } \n } \n } \n return best_score - FFMAX ( stat_all - 10 * best_score , 0 ) / 10 ; \n }", "idx": 9992}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_dc_add8_mmx2 ( uint8_t * dst , int16_t * block , int stride ) \n { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" m \" ( block [ 0 ] ) , \n \" \" ( block [ 16 ] ) , \n \" \" ( ff_pw_32 ) \n ) ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + m \" \n \" + m \" \n \" + m \" \n \" + m \" \n ) ; \n }", "idx": 9993}
{"project": "FFmpeg", "commit_id": "d319064465e148b8adb53d1ea5d38c09f987056e", "target": 0, "func": "void uninit_opts ( void ) \n { \n int i ; \n for ( i = 0 ; i < AVMEDIA_TYPE_NB ; i ++ ) \n av_freep ( & avcodec_opts [ i ] ) ; \n av_freep ( & avformat_opts -> key ) ; \n av_freep ( & avformat_opts ) ; \n #if CONFIG_SWSCALE  \n  \n  av_freep ( & sws_opts ) ; \n #endif \n for ( i = 0 ; i < opt_name_count ; i ++ ) { \n if ( opt_values [ i ] ) { \n av_freep ( & opt_names [ i ] ) ; \n av_freep ( & opt_values [ i ] ) ; \n } \n } \n av_freep ( & opt_names ) ; \n av_freep ( & opt_values ) ; \n }", "idx": 9994}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_send_command ( FTPContext * s , const char * command , \n const int response_codes [ ] , char * * response ) \n { \n int err ; \n if ( ( err = ftp_flush_control_input ( s ) ) < 0 ) \n return err ; \n s -> conn_control_block_flag = 0 ; \n if ( ( err = ffurl_write ( s -> conn_control , command , strlen ( command ) ) ) < 0 ) \n return err ; \n if ( ! err ) \n return -1 ; \n if ( response_codes ) { \n return ftp_status ( s , response , response_codes ) ; \n } \n return 0 ; \n }", "idx": 9995}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int get_aac_sample_rates ( AVFormatContext * s , AVCodecParameters * par , \n int * sample_rate , int * output_sample_rate ) \n { \n MPEG4AudioConfig mp4ac ; \n if ( avpriv_mpeg4audio_get_config ( & mp4ac , par -> extradata , \n par -> extradata_size * 8 , 1 ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n * sample_rate = mp4ac . sample_rate ; \n * output_sample_rate = mp4ac . ext_sample_rate ; \n return 0 ; \n }", "idx": 10005}
{"project": "FFmpeg", "commit_id": "4a6a29a7fbf023b19797c38a86099d9f81d25524", "target": 0, "func": "static int amr_wb_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AMRWBContext * s = avctx -> priv_data ; \n int mode ; \n int packet_size ; \n static const uint8_t block_size [ 16 ] = { 18 , 24 , 33 , 37 , 41 , 47 , 51 , 59 , 61 , 6 , 6 , 0 , 0 , 0 , 1 , 1 } ; \n mode = ( buf [ 0 ] >> 3 ) & 0x000F ; \n packet_size = block_size [ mode ] ; \n if ( packet_size > buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n buf_size , packet_size + 1 ) ; \n return AVERROR_INVALIDDATA ; \n } \n D_IF_decode ( s -> state , buf , data , _good_frame ) ; \n * data_size = 320 * 2 ; \n return packet_size ; \n }", "idx": 10016}
{"project": "FFmpeg", "commit_id": "d00bff20b2b48796e4bd2d0b83819c159f60a25f", "target": 0, "func": "static int qdm2_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n QDM2Context * s = avctx -> priv_data ; \n if ( ( buf == NULL ) || ( buf_size < s -> checksum_size ) ) \n return 0 ; \n * data_size = s -> channels * s -> frame_size * sizeof ( int16_t ) ; \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , \n buf_size , buf , s -> checksum_size , data , * data_size ) ; \n qdm2_decode ( s , buf , data ) ; \n if ( s -> sub_packet == 0 ) { \n return s -> checksum_size ; \n } \n return 0 ; \n }", "idx": 10029}
{"project": "FFmpeg", "commit_id": "3deb4b54a24f8cddce463d9f5751b01efeb976af", "target": 0, "func": "static int parse_packet_header ( WMAVoiceContext * s ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned int res ; \n if ( get_bits_left ( gb ) < 11 ) \n return 1 ; \n skip_bits ( gb , 4 ) ; \n s -> has_residual_lsps = get_bits1 ( gb ) ; \n do { \n res = get_bits ( gb , 6 ) ; \n if ( get_bits_left ( gb ) < 6 * ( res == 0x3F ) + s -> spillover_bitsize ) \n return 1 ; \n } while ( res == 0x3F ) ; \n s -> spillover_nbits = get_bits ( gb , s -> spillover_bitsize ) ; \n return 0 ; \n }", "idx": 10042}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_422_bitstream ( HYuvContext * s , int count ) \n { \n int i ; \n count /= 2 ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 31 * 4 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n for ( ; i < count ; i ++ ) \n s -> temp [ 0 ] [ 2 * i ] = s -> temp [ 1 ] [ i ] = \n s -> temp [ 0 ] [ 2 * i + 1 ] = s -> temp [ 2 ] [ i ] = 128 ; \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 1 ] [ i ] , 1 ) ; \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i + 1 ] , s -> temp [ 2 ] [ i ] , 2 ) ; \n } \n } \n }", "idx": 10047}
{"project": "FFmpeg", "commit_id": "f880199375ee661c22128febd531a7faa122ff0f", "target": 0, "func": "static int rtp_write_header ( AVFormatContext * s1 ) \n { \n RTPDemuxContext * s = s1 -> priv_data ; \n int payload_type , max_packet_size , n ; \n AVStream * st ; \n if ( s1 -> nb_streams != 1 ) \n return -1 ; \n st = s1 -> streams [ 0 ] ; \n payload_type = rtp_get_payload_type ( st -> codec ) ; \n if ( payload_type < 0 ) \n payload_type = RTP_PT_PRIVATE ; \n s -> payload_type = payload_type ; \n s -> base_timestamp = random ( ) ; \n s -> timestamp = s -> base_timestamp ; \n s -> ssrc = random ( ) ; \n s -> first_packet = 1 ; \n max_packet_size = url_fget_max_packet_size ( & s1 -> pb ) ; \n if ( max_packet_size <= 12 ) \n return AVERROR_IO ; \n s -> max_payload_size = max_packet_size - 12 ; \n switch ( st -> codec -> codec_id ) { \n case CODEC_ID_MP2 : \n case CODEC_ID_MP3 : \n s -> buf_ptr = s -> buf + 4 ; \n s -> cur_timestamp = 0 ; \n break ; \n case CODEC_ID_MPEG1VIDEO : \n s -> cur_timestamp = 0 ; \n break ; \n case CODEC_ID_MPEG2TS : \n n = s -> max_payload_size / TS_PACKET_SIZE ; \n if ( n < 1 ) \n n = 1 ; \n s -> max_payload_size = n * TS_PACKET_SIZE ; \n s -> buf_ptr = s -> buf ; \n break ; \n default : \n s -> buf_ptr = s -> buf ; \n break ; \n } \n return 0 ; \n }", "idx": 10073}
{"project": "FFmpeg", "commit_id": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8", "target": 0, "func": "int ff_v4l2_context_dequeue_packet ( V4L2Context * ctx , AVPacket * pkt ) \n { \n V4L2Buffer * avbuf = NULL ; \n avbuf = v4l2_dequeue_v4l2buf ( ctx , ctx_to_m2mctx ( ctx ) -> draining ? 200 : -1 ) ; \n if ( ! avbuf ) { \n if ( ctx -> done ) \n return AVERROR_EOF ; \n return AVERROR ( EAGAIN ) ; \n } \n return ff_v4l2_buffer_buf_to_avpkt ( pkt , avbuf ) ; \n }", "idx": 10074}
{"project": "FFmpeg", "commit_id": "0e4b185a8df12c7b42642699a8df45e0de48de07", "target": 1, "func": "void rtp_parse_close ( RTPDemuxContext * s ) \n { \n if ( ! strcmp ( ff_rtp_enc_name ( s -> payload_type ) , \" \" ) ) { \n ff_mpegts_parse_close ( s -> ts ) ; \n } \n av_free ( s ) ; \n }", "idx": 10100}
{"project": "FFmpeg", "commit_id": "32ac63ee10ca5daa149344a75d736c1b98177392", "target": 1, "func": "static inline int decode_mb ( MDECContext * a , DCTELEM block [ 6 ] [ 64 ] ) { \n int i ; \n const int block_index [ 6 ] = { 5 , 4 , 0 , 1 , 2 , 3 } ; \n a -> dsp . clear_blocks ( block [ 0 ] ) ; \n for ( i = 0 ; i < 6 ; i ++ ) { \n if ( mdec_decode_block_intra ( a , block [ block_index [ i ] ] , block_index [ i ] ) < 0 ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 10107}
{"project": "FFmpeg", "commit_id": "4aca716a531b0bc1f05c96209cf30577d6e48baa", "target": 1, "func": "static int scale_vector ( int16_t * vector , int length ) \n { \n int bits , max = 0 ; \n int64_t scale ; \n int i ; \n for ( i = 0 ; i < length ; i ++ ) \n max = FFMAX ( max , FFABS ( vector [ i ] ) ) ; \n max = FFMIN ( max , 0x7FFF ) ; \n bits = normalize_bits ( max , 15 ) ; \n scale = ( bits == 15 ) ? 0x7FFF : ( 1 << bits ) ; \n for ( i = 0 ; i < length ; i ++ ) \n vector [ i ] = av_clipl_int32 ( vector [ i ] * scale << 1 ) >> 4 ; \n return bits - 3 ; \n }", "idx": 10112}
{"project": "FFmpeg", "commit_id": "7888ae8266d8f721cc443fe3aa627d350ca01204", "target": 0, "func": "static av_cold int cfhd_decode_init ( AVCodecContext * avctx ) \n { \n CFHDContext * s = avctx -> priv_data ; \n avctx -> bits_per_raw_sample = 10 ; \n s -> avctx = avctx ; \n avctx -> width = 0 ; \n avctx -> height = 0 ; \n return ff_cfhd_init_vlcs ( s ) ; \n }", "idx": 10120}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 768 ] ) ; \n samples [ i + 256 ] = ( samples [ i + 512 ] + samples [ i + 1024 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = samples [ i + 1024 ] = 0 ; \n } \n }", "idx": 10129}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int smacker_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && p -> buf [ 2 ] == ' ' \n && ( p -> buf [ 3 ] == ' ' || p -> buf [ 3 ] == ' ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 10143}
{"project": "FFmpeg", "commit_id": "1c0e205fab4bd5bbfa0399af2cd5e281b414b3d5", "target": 1, "func": "void audio_encode_example ( const char * filename ) \n { \n AVCodec * codec ; \n AVCodecContext * c = NULL ; \n int frame_size , i , j , out_size , outbuf_size ; \n FILE * f ; \n short * samples ; \n float t , tincr ; \n uint8_t * outbuf ; \n printf ( \" \\n \" ) ; \n codec = avcodec_find_encoder ( CODEC_ID_MP2 ) ; \n if ( ! codec ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n c = avcodec_alloc_context ( ) ; \n c -> bit_rate = 64000 ; \n c -> sample_rate = 44100 ; \n c -> channels = 2 ; \n if ( avcodec_open ( c , codec ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n frame_size = c -> frame_size ; \n samples = malloc ( frame_size * 2 * c -> channels ) ; \n outbuf_size = 10000 ; \n outbuf = malloc ( outbuf_size ) ; \n f = fopen ( filename , \" \" ) ; \n if ( ! f ) { \n fprintf ( stderr , \" \\n \" , filename ) ; \n exit ( 1 ) ; \n } \n t = 0 ; \n tincr = 2 * M_PI * 440.0 / c -> sample_rate ; \n for ( i = 0 ; i < 200 ; i ++ ) { \n for ( j = 0 ; j < frame_size ; j ++ ) { \n samples [ 2 * j ] = ( int ) ( sin ( t ) * 10000 ) ; \n samples [ 2 * j + 1 ] = samples [ 2 * j ] ; \n t += tincr ; \n } \n out_size = avcodec_encode_audio ( c , outbuf , outbuf_size , samples ) ; \n fwrite ( outbuf , 1 , out_size , f ) ; \n } \n fclose ( f ) ; \n free ( outbuf ) ; \n free ( samples ) ; \n avcodec_close ( c ) ; \n free ( c ) ; \n }", "idx": 10145}
{"project": "FFmpeg", "commit_id": "68e75e4dec6b5f46a190118eecbba1e95c396e3d", "target": 0, "func": "static void floor_fit ( venc_context_t * venc , floor_t * fc , float * coeffs , int * posts , int samples ) { \n int range = 255 / fc -> multiplier + 1 ; \n int i ; \n for ( i = 0 ; i < fc -> values ; i ++ ) { \n int position = fc -> list [ fc -> list [ i ] . sort ] . x ; \n int begin = fc -> list [ fc -> list [ FFMAX ( i - 1 , 0 ) ] . sort ] . x ; \n int end = fc -> list [ fc -> list [ FFMIN ( i + 1 , fc -> values - 1 ) ] . sort ] . x ; \n int j ; \n float average = 0 ; \n begin = ( position + begin ) / 2 ; \n end = ( position + end ) / 2 ; \n assert ( end <= samples ) ; \n for ( j = begin ; j < end ; j ++ ) average += fabs ( coeffs [ j ] ) ; \n average /= end - begin ; \n average /= 32 ; \n for ( j = 0 ; j < range - 1 ; j ++ ) if ( floor1_inverse_db_table [ j * fc -> multiplier ] > average ) break ; \n posts [ fc -> list [ i ] . sort ] = j ; \n } \n }", "idx": 10148}
{"project": "FFmpeg", "commit_id": "b6267901c466c482b2f1af3578b0a6d88265d144", "target": 1, "func": "static int mp3_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , \n int flags ) \n { \n MP3Context * mp3 = s -> priv_data ; \n AVIndexEntry * ie ; \n AVStream * st = s -> streams [ 0 ] ; \n int64_t ret = av_index_search_timestamp ( st , timestamp , flags ) ; \n uint32_t header = 0 ; \n if ( ! mp3 -> xing_toc ) { \n st -> skip_samples = timestamp <= 0 ? mp3 -> start_pad + 528 + 1 : 0 ; \n return -1 ; \n } \n if ( ret < 0 ) \n return ret ; \n ie = & st -> index_entries [ ret ] ; \n ret = avio_seek ( s -> pb , ie -> pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n while ( ! s -> pb -> eof_reached ) { \n header = ( header << 8 ) + avio_r8 ( s -> pb ) ; \n if ( ff_mpa_check_header ( header ) >= 0 ) { \n ff_update_cur_dts ( s , st , ie -> timestamp ) ; \n ret = avio_seek ( s -> pb , -4 , SEEK_CUR ) ; \n st -> skip_samples = ie -> timestamp <= 0 ? mp3 -> start_pad + 528 + 1 : 0 ; \n return ( ret >= 0 ) ? 0 : ret ; \n } \n } \n return AVERROR_EOF ; \n }", "idx": 10153}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_sprite_flush ( AVCodecContext * avctx ) \n { \n VC1Context * v = avctx -> priv_data ; \n MpegEncContext * s = & v -> s ; \n AVFrame * f = & s -> current_picture . f ; \n int plane , i ; \n if ( f -> data [ 0 ] ) \n for ( plane = 0 ; plane < ( s -> flags & CODEC_FLAG_GRAY ? 1 : 3 ) ; plane ++ ) \n for ( i = 0 ; i < v -> sprite_height >> ! ! plane ; i ++ ) \n memset ( f -> data [ plane ] + i * f -> linesize [ plane ] , \n plane ? 128 : 0 , f -> linesize [ plane ] ) ; \n }", "idx": 10157}
{"project": "FFmpeg", "commit_id": "9da369604ecf31d9dce2dee21ed214b8c43264c6", "target": 0, "func": "static int process_command ( AVFilterContext * ctx , const char * cmd , const char * args , \n char * res , int res_len , int flags ) \n { \n OverlayContext * over = ctx -> priv ; \n int ret ; \n if ( ! strcmp ( cmd , \" \" ) ) \n ret = set_expr ( & over -> x_pexpr , args , ctx ) ; \n else if ( ! strcmp ( cmd , \" \" ) ) \n ret = set_expr ( & over -> y_pexpr , args , ctx ) ; \n else if ( ! strcmp ( cmd , \" \" ) ) \n ret = set_expr ( & over -> enable_pexpr , args , ctx ) ; \n else \n ret = AVERROR ( ENOSYS ) ; \n if ( ret < 0 ) \n return ret ; \n if ( over -> eval_mode == EVAL_MODE_INIT ) { \n eval_expr ( ctx , EVAL_ALL ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , \n over -> var_values [ VAR_X ] , over -> x , \n over -> var_values [ VAR_Y ] , over -> y , \n over -> enable ) ; \n } \n return ret ; \n }", "idx": 10160}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_420 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , \n uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y ; \n int width = frame -> width ; \n int ystride = frame -> linesize [ 0 ] ; \n int ustride = frame -> linesize [ 1 ] ; \n int vstride = frame -> linesize [ 2 ] ; \n uint8_t * Y = frame -> data [ 0 ] + ystride * line ; \n uint8_t * U = frame -> data [ 1 ] + ( ustride >> 1 ) * line ; \n uint8_t * V = frame -> data [ 2 ] + ( vstride >> 1 ) * line ; \n for ( y = 0 ; y < left - 1 && get_bits_left ( gb ) > 16 ; y += 2 ) { \n for ( x = 0 ; x < width ; x += 2 ) { \n Y [ x + 0 + 0 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n Y [ x + 1 + 0 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n Y [ x + 0 + 1 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n Y [ x + 1 + 1 * ystride ] = decode_sym ( gb , lru [ 0 ] ) ; \n U [ x >> 1 ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; \n V [ x >> 1 ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; \n } \n Y += ystride << 1 ; \n U += ustride ; \n V += vstride ; \n } \n return y ; \n }", "idx": 10172}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr16ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x07E0F81F ) ; \n int dh = ( ( d0 >> 5 ) & 0x07C0F83F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int b = d & 0x7F ; \n int r = ( d >> 11 ) & 0x7F ; \n int g = d >> 21 ; \n dstU [ i ] = ( ( 2 * RU * r + GU * g + 2 * BU * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n dstV [ i ] = ( ( 2 * RV * r + GV * g + 2 * BV * b ) >> ( RGB2YUV_SHIFT + 1 - 2 ) ) + 128 ; \n } \n }", "idx": 10173}
{"project": "FFmpeg", "commit_id": "d65b9114f35c1afe2a7061f0a1ec957d33ba02b5", "target": 0, "func": "static int file_close_dir ( URLContext * h ) \n { \n #if HAVE_DIRENT_H  \n  \n  FileContext * c = h -> priv_data ; \n closedir ( c -> dir ) ; \n return 0 ; \n #else \n return AVERROR ( ENOSYS ) ; \n #endif \n }", "idx": 10174}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int sdp_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPStream * rtsp_st ; \n int size , i , err ; \n char * content ; \n char url [ 1024 ] ; \n content = av_malloc ( SDP_MAX_SIZE ) ; \n size = get_buffer ( s -> pb , content , SDP_MAX_SIZE - 1 ) ; \n if ( size <= 0 ) { \n av_free ( content ) ; \n return AVERROR_INVALIDDATA ; \n } \n content [ size ] = ' \\0 ' ; \n sdp_parse ( s , content ) ; \n av_free ( content ) ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n snprintf ( url , sizeof ( url ) , \" \n inet_ntoa ( rtsp_st -> sdp_ip ) , \n rtsp_st -> sdp_port , \n rtsp_st -> sdp_port , \n rtsp_st -> sdp_ttl ) ; \n if ( url_open ( & rtsp_st -> rtp_handle , url , URL_RDWR ) < 0 ) { \n err = AVERROR_INVALIDDATA ; \n goto fail ; \n } \n if ( ( err = rtsp_open_transport_ctx ( s , rtsp_st ) ) ) \n goto fail ; \n } \n return 0 ; \n fail : \n rtsp_close_streams ( rt ) ; \n return err ; \n }", "idx": 10176}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16intra_mmx2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] ) ff_h264_idct_add_mmx ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] ) ff_h264_idct_dc_add_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 10177}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( bgr24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src1 [ 3 * i + 0 ] ; \n int g = src1 [ 3 * i + 1 ] ; \n int r = src1 [ 3 * i + 2 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n } \n #endif \n assert ( src1 == src2 ) ; \n }", "idx": 10202}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "int qsv_init ( AVCodecContext * s ) \n { \n InputStream * ist = s -> opaque ; \n QSVContext * qsv = ist -> hwaccel_ctx ; \n AVQSVContext * hwctx_dec ; \n int ret ; \n if ( ! qsv ) { \n av_log ( NULL , AV_LOG_ERROR , \" \" \n \" \" \n \" \\n \" ) ; \n return AVERROR_BUG ; \n } \n ret = init_opaque_surf ( qsv ) ; \n if ( ret < 0 ) \n return ret ; \n hwctx_dec = av_qsv_alloc_context ( ) ; \n if ( ! hwctx_dec ) \n return AVERROR ( ENOMEM ) ; \n hwctx_dec -> session = qsv -> session ; \n hwctx_dec -> iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY ; \n hwctx_dec -> ext_buffers = qsv -> ext_buffers ; \n hwctx_dec -> nb_ext_buffers = FF_ARRAY_ELEMS ( qsv -> ext_buffers ) ; \n av_freep ( & s -> hwaccel_context ) ; \n s -> hwaccel_context = hwctx_dec ; \n ist -> hwaccel_get_buffer = qsv_get_buffer ; \n ist -> hwaccel_uninit = qsv_uninit ; \n return 0 ; \n }", "idx": 10276}
{"project": "FFmpeg", "commit_id": "35ee72b1d72a4c8fc0ae4e76ad00a71e831b8dbe", "target": 0, "func": "static void float_to_int16_sse ( int16_t * dst , const float * src , long len ) { \n int i ; \n for ( i = 0 ; i < len ; i += 4 ) { \n asm volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( dst [ i ] ) \n : \" \" ( src [ i ] ) , \" \" ( src [ i + 2 ] ) \n ) ; \n } \n asm volatile ( \" \" ) ; \n }", "idx": 10287}
{"project": "FFmpeg", "commit_id": "403ee835e7913eb9536b22c2b22edfdd700166a9", "target": 0, "func": "AVFormatContext * ff_rtp_chain_mux_open ( AVFormatContext * s , AVStream * st , \n URLContext * handle , int packet_size ) \n { \n AVFormatContext * rtpctx ; \n int ret ; \n AVOutputFormat * rtp_format = av_guess_format ( \" \" , NULL , NULL ) ; \n if ( ! rtp_format ) \n return NULL ; \n rtpctx = avformat_alloc_context ( ) ; \n if ( ! rtpctx ) \n return NULL ; \n rtpctx -> oformat = rtp_format ; \n if ( ! av_new_stream ( rtpctx , 0 ) ) { \n av_free ( rtpctx ) ; \n return NULL ; \n } \n rtpctx -> max_delay = s -> max_delay ; \n rtpctx -> streams [ 0 ] -> sample_aspect_ratio = st -> sample_aspect_ratio ; \n rtpctx -> start_time_realtime = s -> start_time_realtime ; \n avcodec_copy_context ( rtpctx -> streams [ 0 ] -> codec , st -> codec ) ; \n if ( handle ) { \n url_fdopen ( & rtpctx -> pb , handle ) ; \n } else \n url_open_dyn_packet_buf ( & rtpctx -> pb , packet_size ) ; \n ret = av_write_header ( rtpctx ) ; \n if ( ret ) { \n if ( handle ) { \n avio_close ( rtpctx -> pb ) ; \n } else { \n uint8_t * ptr ; \n avio_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } \n avformat_free_context ( rtpctx ) ; \n return NULL ; \n } \n return rtpctx ; \n }", "idx": 10307}
{"project": "FFmpeg", "commit_id": "c7384664ba0cbb12d882effafbc6d321ae706cff", "target": 0, "func": "static av_cold int avs_decode_init ( AVCodecContext * avctx ) \n { \n AvsContext * s = avctx -> priv_data ; \n s -> frame = av_frame_alloc ( ) ; \n if ( ! s -> frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n ff_set_dimensions ( avctx , 318 , 198 ) ; \n return 0 ; \n }", "idx": 10309}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int raw_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 10310}
{"project": "FFmpeg", "commit_id": "b12e4d3bb8df994f042ff1216fb8de2b967aab9e", "target": 0, "func": "int avio_close_dyn_buf ( AVIOContext * s , uint8_t * * pbuffer ) \n { \n DynBuffer * d ; \n int size ; \n static const char padbuf [ AV_INPUT_BUFFER_PADDING_SIZE ] = { 0 } ; \n int padding = 0 ; \n if ( ! s ) { \n * pbuffer = NULL ; \n return 0 ; \n } \n if ( ! s -> max_packet_size ) { \n avio_write ( s , padbuf , sizeof ( padbuf ) ) ; \n padding = AV_INPUT_BUFFER_PADDING_SIZE ; \n } \n avio_flush ( s ) ; \n d = s -> opaque ; \n * pbuffer = d -> buffer ; \n size = d -> size ; \n av_free ( d ) ; \n av_free ( s ) ; \n return size - padding ; \n }", "idx": 10311}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int decode_motion_vector ( bit_buffer_t * bitbuf , svq1_pmv_t * mv , svq1_pmv_t * * pmv ) { \n uint32_t bit_cache ; \n vlc_code_t * vlc ; \n int diff , sign ; \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n bit_cache = get_bit_cache ( bitbuf ) ; \n if ( ! ( bit_cache & 0xFFE00000 ) ) \n return -1 ; \n if ( bit_cache & 0x80000000 ) { \n diff = 0 ; \n skip_bits ( bitbuf , 1 ) ; \n } else { \n if ( bit_cache >= 0x06000000 ) { \n vlc = & motion_table_0 [ ( bit_cache >> ( 32 - 7 ) ) - 3 ] ; \n } else { \n vlc = & motion_table_1 [ ( bit_cache >> ( 32 - 12 ) ) - 2 ] ; \n } \n sign = ( int ) ( bit_cache << ( vlc -> length - 1 ) ) >> 31 ; \n diff = ( vlc -> value ^ sign ) - sign ; \n skip_bits ( bitbuf , vlc -> length ) ; \n } \n if ( i == 1 ) \n mv -> y = ( ( diff + MEDIAN ( pmv [ 0 ] -> y , pmv [ 1 ] -> y , pmv [ 2 ] -> y ) ) << 26 ) >> 26 ; \n else \n mv -> x = ( ( diff + MEDIAN ( pmv [ 0 ] -> x , pmv [ 1 ] -> x , pmv [ 2 ] -> x ) ) << 26 ) >> 26 ; \n } \n return 0 ; \n }", "idx": 10335}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "long check_dcbzl_effect ( void ) \n { \n register char * fakedata = ( char * ) av_malloc ( 1024 ) ; \n register char * fakedata_middle ; \n register long zero = 0 ; \n register long i = 0 ; \n long count = 0 ; \n if ( ! fakedata ) \n { \n return 0L ; \n } \n fakedata_middle = ( fakedata + 512 ) ; \n memset ( fakedata , 0xFF , 1024 ) ; \n asm volatile ( \" \" : : \" \" ( fakedata_middle ) , \" \" ( zero ) ) ; \n for ( i = 0 ; i < 1024 ; i ++ ) \n { \n if ( fakedata [ i ] == ( char ) 0 ) \n count ++ ; \n } \n av_free ( fakedata ) ; \n return count ; \n }", "idx": 10348}
{"project": "FFmpeg", "commit_id": "da35797359cec148f3fe59894c62727b0422d75a", "target": 1, "func": "static inline void comp_block ( MadContext * t , int mb_x , int mb_y , \n int j , int mv_x , int mv_y , int add ) \n { \n MpegEncContext * s = & t -> s ; \n if ( j < 4 ) { \n comp ( t -> frame . data [ 0 ] + ( mb_y * 16 + ( ( j & 2 ) << 2 ) ) * t -> frame . linesize [ 0 ] + mb_x * 16 + ( ( j & 1 ) << 3 ) , \n t -> frame . linesize [ 0 ] , \n t -> last_frame . data [ 0 ] + ( mb_y * 16 + ( ( j & 2 ) << 2 ) + mv_y ) * t -> last_frame . linesize [ 0 ] + mb_x * 16 + ( ( j & 1 ) << 3 ) + mv_x , \n t -> last_frame . linesize [ 0 ] , add ) ; \n } else if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) { \n int index = j - 3 ; \n comp ( t -> frame . data [ index ] + ( mb_y * 8 ) * t -> frame . linesize [ index ] + mb_x * 8 , \n t -> frame . linesize [ index ] , \n t -> last_frame . data [ index ] + ( mb_y * 8 + ( mv_y / 2 ) ) * t -> last_frame . linesize [ index ] + mb_x * 8 + ( mv_x / 2 ) , \n t -> last_frame . linesize [ index ] , add ) ; \n } \n }", "idx": 10352}
{"project": "FFmpeg", "commit_id": "9286de045968ad456d4e752651eec22de5e89060", "target": 0, "func": "static int mov_open_dref ( AVIOContext * * pb , char * src , MOVDref * ref , \n AVIOInterruptCB * int_cb ) \n { \n if ( ref -> nlvl_to > 0 && ref -> nlvl_from > 0 ) { \n char filename [ 1024 ] ; \n char * src_path ; \n int i , l ; \n src_path = strrchr ( src , ' ' ) ; \n if ( src_path ) \n src_path ++ ; \n else \n src_path = src ; \n for ( i = 0 , l = strlen ( ref -> path ) - 1 ; l >= 0 ; l -- ) \n if ( ref -> path [ l ] == ' ' ) { \n if ( i == ref -> nlvl_to - 1 ) \n break ; \n else \n i ++ ; \n } \n if ( i == ref -> nlvl_to - 1 && src_path - src < sizeof ( filename ) ) { \n memcpy ( filename , src , src_path - src ) ; \n filename [ src_path - src ] = 0 ; \n for ( i = 1 ; i < ref -> nlvl_from ; i ++ ) \n av_strlcat ( filename , \" \" , 1024 ) ; \n av_strlcat ( filename , ref -> path + l + 1 , 1024 ) ; \n if ( ! avio_open2 ( pb , filename , AVIO_FLAG_READ , int_cb , NULL ) ) \n return 0 ; \n } \n } \n return AVERROR ( ENOENT ) ; \n }", "idx": 10360}
{"project": "FFmpeg", "commit_id": "ca390e727d165bf80445035c4b67a7239fdc87c0", "target": 0, "func": "pp_context_t * pp_get_context ( int width , int height , int cpuCaps ) { \n PPContext * c = memalign ( 32 , sizeof ( PPContext ) ) ; \n int i ; \n int stride = ( width + 15 ) & ( ~ 15 ) ; \n memset ( c , 0 , sizeof ( PPContext ) ) ; \n c -> cpuCaps = cpuCaps ; \n if ( cpuCaps & PP_FORMAT ) { \n c -> hChromaSubSample = cpuCaps & 0x3 ; \n c -> vChromaSubSample = ( cpuCaps >> 4 ) & 0x3 ; \n } else { \n c -> hChromaSubSample = 1 ; \n c -> vChromaSubSample = 1 ; \n } \n reallocBuffers ( c , width , height , stride ) ; \n c -> frameNum = -1 ; \n return c ; \n }", "idx": 10371}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int xvid_ff_2pass_after ( struct xvid_context * ref , \n xvid_plg_data_t * param ) { \n char * log = ref -> twopassbuffer ; \n const char * frame_types = \" \" ; \n char frame_type ; \n if ( log == NULL ) \n return XVID_ERR_FAIL ; \n if ( param -> type < 5 && param -> type > 0 ) { \n frame_type = frame_types [ param -> type ] ; \n } else { \n return XVID_ERR_FAIL ; \n } \n snprintf ( BUFFER_CAT ( log ) , BUFFER_REMAINING ( log ) , \n \" \\n \" , \n frame_type , param -> stats . quant , param -> stats . kblks , param -> stats . mblks , \n param -> stats . ublks , param -> stats . length , param -> stats . hlength ) ; \n return 0 ; \n }", "idx": 10395}
{"project": "FFmpeg", "commit_id": "5405584b7b54ca889c341743de1d58792449830d", "target": 0, "func": "static CheckasmFunc * get_func ( const char * name , int length ) \n { \n CheckasmFunc * f , * * f_ptr = & state . funcs ; \n while ( ( f = * f_ptr ) ) { \n int cmp = cmp_func_names ( name , f -> name ) ; \n if ( ! cmp ) \n return f ; \n f_ptr = & f -> child [ ( cmp > 0 ) ] ; \n } \n f = * f_ptr = checkasm_malloc ( sizeof ( CheckasmFunc ) + length ) ; \n memcpy ( f -> name , name , length + 1 ) ; \n return f ; \n }", "idx": 10397}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "static void unref_picture ( H264Context * h , Picture * pic ) \n { \n int off = offsetof ( Picture , tf ) + sizeof ( pic -> tf ) ; \n int i ; \n if ( ! pic -> f . data [ 0 ] ) \n return ; \n ff_thread_release_buffer ( h -> avctx , & pic -> tf ) ; \n av_buffer_unref ( & pic -> hwaccel_priv_buf ) ; \n av_buffer_unref ( & pic -> qscale_table_buf ) ; \n av_buffer_unref ( & pic -> mb_type_buf ) ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n av_buffer_unref ( & pic -> motion_val_buf [ i ] ) ; \n av_buffer_unref ( & pic -> ref_index_buf [ i ] ) ; \n } \n memset ( ( uint8_t * ) pic + off , 0 , sizeof ( * pic ) - off ) ; \n }", "idx": 10398}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void ff_free_parser_state ( AVFormatContext * s , AVParserState * state ) \n { \n int i ; \n AVParserStreamState * ss ; \n if ( ! state ) \n return ; \n for ( i = 0 ; i < state -> nb_streams ; i ++ ) { \n ss = & state -> stream_states [ i ] ; \n if ( ss -> parser ) \n av_parser_close ( ss -> parser ) ; \n av_free_packet ( & ss -> cur_pkt ) ; \n } \n free_packet_list ( state -> packet_buffer ) ; \n free_packet_list ( state -> raw_packet_buffer ) ; \n av_free ( state -> stream_states ) ; \n av_free ( state ) ; \n }", "idx": 10400}
{"project": "FFmpeg", "commit_id": "e33943728e775ef9f3239fe950f3be4fa405d1f2", "target": 1, "func": "static int mjpeg_decode_com ( MJpegDecodeContext * s ) \n { \n int len = get_bits ( & s -> gb , 16 ) ; \n if ( len >= 2 && len < 32768 ) { \n uint8_t * cbuf = av_malloc ( len - 1 ) ; \n if ( cbuf ) { \n int i ; \n for ( i = 0 ; i < len - 2 ; i ++ ) \n cbuf [ i ] = get_bits ( & s -> gb , 8 ) ; \n if ( i > 0 && cbuf [ i - 1 ] == ' \\n ' ) \n cbuf [ i - 1 ] = 0 ; \n else \n cbuf [ i ] = 0 ; \n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) \n av_log ( s -> avctx , AV_LOG_INFO , \" \\n \" , cbuf ) ; \n if ( ! strcmp ( cbuf , \" \" ) ) \n { \n s -> buggy_avid = 1 ; \n } \n else if ( ! strcmp ( cbuf , \" \" ) ) { \n s -> cs_itu601 = 1 ; \n } \n av_free ( cbuf ) ; \n } \n } \n return 0 ; \n }", "idx": 10401}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yv12toyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n unsigned int width , unsigned int height , \n int lumStride , int chromStride , int dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 10408}
{"project": "FFmpeg", "commit_id": "ea98507db018c7b0ea7a167281a210ba1328dde7", "target": 0, "func": "static int decode_residuals ( FLACContext * s , int channel , int pred_order ) \n { \n int i , tmp , partition , method_type , rice_order ; \n int sample = 0 , samples ; \n method_type = get_bits ( & s -> gb , 2 ) ; \n if ( method_type > 1 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n method_type ) ; \n return -1 ; \n } \n rice_order = get_bits ( & s -> gb , 4 ) ; \n samples = s -> blocksize >> rice_order ; \n if ( pred_order > samples ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n pred_order , samples ) ; \n return -1 ; \n } \n sample = \n i = pred_order ; \n for ( partition = 0 ; partition < ( 1 << rice_order ) ; partition ++ ) { \n tmp = get_bits ( & s -> gb , method_type == 0 ? 4 : 5 ) ; \n if ( tmp == ( method_type == 0 ? 15 : 31 ) ) { \n tmp = get_bits ( & s -> gb , 5 ) ; \n for ( ; i < samples ; i ++ , sample ++ ) \n s -> decoded [ channel ] [ sample ] = get_sbits_long ( & s -> gb , tmp ) ; \n } else { \n for ( ; i < samples ; i ++ , sample ++ ) { \n s -> decoded [ channel ] [ sample ] = get_sr_golomb_flac ( & s -> gb , tmp , INT_MAX , 0 ) ; \n } \n } \n i = 0 ; \n } \n return 0 ; \n }", "idx": 10411}
{"project": "FFmpeg", "commit_id": "44e6eeb30de8e2d20db56284984da4615763525c", "target": 1, "func": "static int print_device_sinks ( AVOutputFormat * fmt , AVDictionary * opts ) \n { \n int ret , i ; \n AVFormatContext * dev = NULL ; \n AVDeviceInfoList * device_list = NULL ; \n AVDictionary * tmp_opts = NULL ; \n if ( ! fmt || ! fmt -> priv_class || ! AV_IS_OUTPUT_DEVICE ( fmt -> priv_class -> category ) ) \n return AVERROR ( EINVAL ) ; \n printf ( \" \\n \" , fmt -> name ) ; \n if ( ! fmt -> get_device_list ) { \n ret = AVERROR ( ENOSYS ) ; \n printf ( \" \\n \" ) ; \n goto fail ; \n } \n if ( ( ret = avformat_alloc_output_context2 ( & dev , fmt , NULL , NULL ) ) < 0 ) { \n printf ( \" \\n \" , fmt -> name ) ; \n goto fail ; \n } \n av_dict_copy ( & tmp_opts , opts , 0 ) ; \n av_opt_set_dict2 ( dev , & tmp_opts , AV_OPT_SEARCH_CHILDREN ) ; \n if ( ( ret = avdevice_list_devices ( dev , & device_list ) ) < 0 ) { \n printf ( \" \\n \" ) ; \n goto fail ; \n } \n for ( i = 0 ; i < device_list -> nb_devices ; i ++ ) { \n printf ( \" \\n \" , device_list -> default_device == i ? \" \" : \" \" , \n device_list -> devices [ i ] -> device_name , device_list -> devices [ i ] -> device_description ) ; \n } \n fail : \n av_dict_free ( & tmp_opts ) ; \n avdevice_free_list_devices ( & device_list ) ; \n avformat_free_context ( dev ) ; \n return ret ; \n }", "idx": 10413}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void add_pixels_clamped4_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n pixels [ 0 ] = cm [ pixels [ 0 ] + block [ 0 ] ] ; \n pixels [ 1 ] = cm [ pixels [ 1 ] + block [ 1 ] ] ; \n pixels [ 2 ] = cm [ pixels [ 2 ] + block [ 2 ] ] ; \n pixels [ 3 ] = cm [ pixels [ 3 ] + block [ 3 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 10419}
{"project": "FFmpeg", "commit_id": "db56a7507ee7c1e095d2eef451d5a487f614edff", "target": 1, "func": "static inline void drawbox ( AVFilterBufferRef * picref , unsigned int x , unsigned int y , \n unsigned int width , unsigned int height , \n uint8_t * line [ 4 ] , int pixel_step [ 4 ] , uint8_t color [ 4 ] , \n int hsub , int vsub , int is_rgba_packed , uint8_t rgba_map [ 4 ] ) \n { \n int i , j , alpha ; \n if ( color [ 3 ] != 0xFF ) { \n if ( is_rgba_packed ) { \n uint8_t * p ; \n for ( j = 0 ; j < height ; j ++ ) \n for ( i = 0 ; i < width ; i ++ ) \n SET_PIXEL_RGB ( picref , color , 255 , i + x , y + j , pixel_step [ 0 ] , \n rgba_map [ 0 ] , rgba_map [ 1 ] , rgba_map [ 2 ] , rgba_map [ 3 ] ) ; \n } else { \n unsigned int luma_pos , chroma_pos1 , chroma_pos2 ; \n for ( j = 0 ; j < height ; j ++ ) \n for ( i = 0 ; i < width ; i ++ ) \n SET_PIXEL_YUV ( picref , color , 255 , i + x , y + j , hsub , vsub ) ; \n } \n } else { \n ff_draw_rectangle ( picref -> data , picref -> linesize , \n line , pixel_step , hsub , vsub , \n x , y , width , height ) ; \n } \n }", "idx": 10424}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add8_mmx ( uint8_t * * dest , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 16 ; i < 16 + 8 ; i ++ ) { \n if ( nnzc [ scan8 [ i ] ] || block [ i * 16 ] ) \n ff_h264_idct_add_mmx ( dest [ ( i & 4 ) >> 2 ] + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 10432}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "static int dxva2_vc1_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n const VC1Context * v = avctx -> priv_data ; \n AVDXVAContext * ctx = avctx -> hwaccel_context ; \n struct dxva2_picture_context * ctx_pic = v -> s . current_picture_ptr -> hwaccel_picture_private ; \n if ( ! DXVA_CONTEXT_VALID ( avctx , ctx ) ) \n return -1 ; \n assert ( ctx_pic ) ; \n fill_picture_parameters ( avctx , ctx , v , & ctx_pic -> pp ) ; \n ctx_pic -> bitstream_size = 0 ; \n ctx_pic -> bitstream = NULL ; \n return 0 ; \n }", "idx": 10441}
{"project": "FFmpeg", "commit_id": "0ac0703107c12bc78ea2853877a38a2a7384789a", "target": 0, "func": "static void write_frame ( AVFormatContext * s , AVPacket * pkt , AVCodecContext * avctx , AVBitStreamFilterContext * bsfc ) { \n while ( bsfc ) { \n AVPacket new_pkt = * pkt ; \n int a = av_bitstream_filter_filter ( bsfc , avctx , NULL , \n & new_pkt . data , & new_pkt . size , \n pkt -> data , pkt -> size , \n pkt -> flags & PKT_FLAG_KEY ) ; \n if ( a ) { \n av_free_packet ( pkt ) ; \n new_pkt . destruct = av_destruct_packet ; \n } \n * pkt = new_pkt ; \n bsfc = bsfc -> next ; \n } \n av_interleaved_write_frame ( s , pkt ) ; \n }", "idx": 10442}
{"project": "FFmpeg", "commit_id": "bda1c56c474c137957c261dcf9df4fd3232a8b43", "target": 0, "func": "static inline void h264_loop_filter_luma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( tc0 [ i ] < 0 ) { \n pix += 4 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 4 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int p2 = pix [ -3 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n const int q2 = pix [ 2 * xstride ] ; \n if ( ABS ( p0 - q0 ) < alpha && \n ABS ( p1 - p0 ) < beta && \n ABS ( q1 - q0 ) < beta ) { \n int tc = tc0 [ i ] ; \n int i_delta ; \n if ( ABS ( p2 - p0 ) < beta ) { \n pix [ -2 * xstride ] = p1 + clip ( ( p2 + ( ( p0 + q0 + 1 ) >> 1 ) - ( p1 << 1 ) ) >> 1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n if ( ABS ( q2 - q0 ) < beta ) { \n pix [ xstride ] = q1 + clip ( ( q2 + ( ( p0 + q0 + 1 ) >> 1 ) - ( q1 << 1 ) ) >> 1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n i_delta = clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = clip_uint8 ( p0 + i_delta ) ; \n pix [ 0 ] = clip_uint8 ( q0 - i_delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 10443}
{"project": "FFmpeg", "commit_id": "0e8b68a2c4031e25082603ad88711be12210d41f", "target": 0, "func": "int64_t av_gettime_relative ( void ) \n { \n #if HAVE_CLOCK_GETTIME && defined ( CLOCK_MONOTONIC )  \n  \n  struct timespec ts ; \n clock_gettime ( CLOCK_MONOTONIC , & ts ) ; \n return ( int64_t ) ts . tv_sec * 1000000 + ts . tv_nsec / 1000 ; \n #else \n return av_gettime ( ) + 42 * 60 * 60 * INT64_C ( 1000000 ) ; \n #endif \n }", "idx": 10444}
{"project": "FFmpeg", "commit_id": "bbcc09518e0d1efc189a43ff0120c1a31f51c802", "target": 0, "func": "static void update_odml_entry ( AVFormatContext * s , int stream_index , int64_t ix ) \n { \n AVIOContext * pb = s -> pb ; \n AVIContext * avi = s -> priv_data ; \n AVIStream * avist = s -> streams [ stream_index ] -> priv_data ; \n int64_t pos ; \n int au_byterate , au_ssize , au_scale ; \n avio_flush ( pb ) ; \n pos = avio_tell ( pb ) ; \n avio_seek ( pb , avist -> indexes . indx_start - 8 , SEEK_SET ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_skip ( pb , 8 ) ; \n avio_wl32 ( pb , avi -> riff_id ) ; \n avio_skip ( pb , 16 * avi -> riff_id ) ; \n avio_wl64 ( pb , ix ) ; \n avio_wl32 ( pb , pos - ix ) ; \n ff_parse_specific_params ( s -> streams [ stream_index ] , & au_byterate , & au_ssize , & au_scale ) ; \n if ( s -> streams [ stream_index ] -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && au_ssize > 0 ) { \n uint32_t audio_segm_size = ( avist -> audio_strm_length - avist -> indexes . audio_strm_offset ) ; \n if ( ( audio_segm_size % au_ssize > 0 ) && ! avist -> sample_requested ) { \n avpriv_request_sample ( s , \" \" ) ; \n avist -> sample_requested = 1 ; \n } \n avio_wl32 ( pb , audio_segm_size / au_ssize ) ; \n } else \n avio_wl32 ( pb , avist -> indexes . entry ) ; \n avio_seek ( pb , pos , SEEK_SET ) ; \n }", "idx": 10445}
{"project": "FFmpeg", "commit_id": "1c6183233d56fb27a4a154e7e64ecab98bd877f1", "target": 0, "func": "av_cold void ff_msmpeg4_encode_init ( MpegEncContext * s ) \n { \n static int init_done = 0 ; \n int i ; \n ff_msmpeg4_common_init ( s ) ; \n if ( s -> msmpeg4_version >= 4 ) { \n s -> min_qcoeff = -255 ; \n s -> max_qcoeff = 255 ; \n } \n if ( ! init_done ) { \n init_done = 1 ; \n init_mv_table ( & ff_mv_tables [ 0 ] ) ; \n init_mv_table ( & ff_mv_tables [ 1 ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) \n ff_init_rl ( & ff_rl_table [ i ] , ff_static_rl_table_store [ i ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) { \n int level ; \n for ( level = 1 ; level <= MAX_LEVEL ; level ++ ) { \n int run ; \n for ( run = 0 ; run <= MAX_RUN ; run ++ ) { \n int last ; \n for ( last = 0 ; last < 2 ; last ++ ) { \n rl_length [ i ] [ level ] [ run ] [ last ] = get_size_of_code ( s , & ff_rl_table [ i ] , last , run , level , 0 ) ; \n } \n } \n } \n } \n } \n }", "idx": 10446}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static void filter_mb_edgecv ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 4 ] , int qp ) { \n const int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = ( alpha_table + 52 ) [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = ( tc0_table + 52 ) [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> s . dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 10448}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "av_cold int ff_rdft_init ( RDFTContext * s , int nbits , enum RDFTransformType trans ) \n { \n int n = 1 << nbits ; \n int ret ; \n s -> nbits = nbits ; \n s -> inverse = trans == IDFT_C2R || trans == DFT_C2R ; \n s -> sign_convention = trans == IDFT_R2C || trans == DFT_C2R ? 1 : -1 ; \n if ( nbits < 4 || nbits > 16 ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = ff_fft_init ( & s -> fft , nbits - 1 , trans == IDFT_C2R || trans == IDFT_R2C ) ) < 0 ) \n return ret ; \n ff_init_ff_cos_tabs ( nbits ) ; \n s -> tcos = ff_cos_tabs [ nbits ] ; \n s -> tsin = ff_sin_tabs [ nbits ] + ( trans == DFT_R2C || trans == DFT_C2R ) * ( n >> 2 ) ; \n #if ! CONFIG_HARDCODED_TABLES  \n  \n  { \n int i ; \n const double theta = ( trans == DFT_R2C || trans == DFT_C2R ? -1 : 1 ) * 2 * M_PI / n ; \n for ( i = 0 ; i < ( n >> 2 ) ; i ++ ) \n s -> tsin [ i ] = sin ( i * theta ) ; \n } \n #endif \n s -> rdft_calc = rdft_calc_c ; \n if ( ARCH_ARM ) ff_rdft_init_arm ( s ) ; \n return 0 ; \n }", "idx": 10452}
{"project": "FFmpeg", "commit_id": "d0dafebb753f34da61058adf956663de39a815b4", "target": 1, "func": "static inline int GET_TOK ( TM2Context * ctx , int type ) { \n if ( ctx -> tok_ptrs [ type ] >= ctx -> tok_lens [ type ] ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , type , ctx -> tok_ptrs [ type ] , ctx -> tok_lens [ type ] ) ; \n return 0 ; \n } \n if ( type <= TM2_MOT ) \n return ctx -> deltas [ type ] [ ctx -> tokens [ type ] [ ctx -> tok_ptrs [ type ] ++ ] ] ; \n return ctx -> tokens [ type ] [ ctx -> tok_ptrs [ type ] ++ ] ; \n }", "idx": 10459}
{"project": "FFmpeg", "commit_id": "b12e4d3bb8df994f042ff1216fb8de2b967aab9e", "target": 0, "func": "int ffio_close_null_buf ( AVIOContext * s ) \n { \n DynBuffer * d = s -> opaque ; \n int size ; \n avio_flush ( s ) ; \n size = d -> size ; \n av_free ( d ) ; \n av_free ( s ) ; \n return size ; \n }", "idx": 10472}
{"project": "FFmpeg", "commit_id": "463705bd1c644bbdded7bcf9f619bcb4203d562f", "target": 0, "func": "static int udp_read ( URLContext * h , uint8_t * buf , int size ) \n { \n UDPContext * s = h -> priv_data ; \n int ret ; \n int avail ; \n #if HAVE_PTHREADS  \n  \n  if ( s -> fifo ) { \n pthread_mutex_lock ( & s -> mutex ) ; \n do { \n avail = av_fifo_size ( s -> fifo ) ; \n if ( avail ) { \n uint8_t tmp [ 4 ] ; \n pthread_mutex_unlock ( & s -> mutex ) ; \n av_fifo_generic_read ( s -> fifo , tmp , 4 , NULL ) ; \n avail = AV_RL32 ( tmp ) ; \n if ( avail > size ) { \n av_log ( h , AV_LOG_WARNING , \" \\n \" ) ; \n avail = size ; \n } \n av_fifo_generic_read ( s -> fifo , buf , avail , NULL ) ; \n av_fifo_drain ( s -> fifo , AV_RL32 ( tmp ) - avail ) ; \n return avail ; \n } else if ( s -> circular_buffer_error ) { \n pthread_mutex_unlock ( & s -> mutex ) ; \n return s -> circular_buffer_error ; \n } else if ( h -> flags & AVIO_FLAG_NONBLOCK ) { \n pthread_mutex_unlock ( & s -> mutex ) ; \n return AVERROR ( EAGAIN ) ; \n } \n else { \n pthread_cond_wait ( & s -> cond , & s -> mutex ) ; \n } \n } while ( 1 ) ; \n } \n #endif \n if ( ! ( h -> flags & AVIO_FLAG_NONBLOCK ) ) { \n ret = ff_network_wait_fd ( s -> udp_fd , 0 ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ret = recv ( s -> udp_fd , buf , size , 0 ) ; \n return ret < 0 ? ff_neterrno ( ) : ret ; \n }", "idx": 10490}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int bmp_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 10499}
{"project": "FFmpeg", "commit_id": "d9a3501c33a1f88350c935785dbf5435e9ffabe6", "target": 1, "func": "int av_opt_set_dict ( void * obj , AVDictionary * * options ) \n { \n AVDictionaryEntry * t = NULL ; \n AVDictionary * tmp = NULL ; \n int ret = 0 ; \n while ( ( t = av_dict_get ( * options , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) { \n ret = av_opt_set ( obj , t -> key , t -> value , 0 ) ; \n if ( ret == AVERROR_OPTION_NOT_FOUND ) \n av_dict_set ( & tmp , t -> key , t -> value , 0 ) ; \n else if ( ret < 0 ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , t -> key , t -> value ) ; \n break ; \n } \n ret = 0 ; \n } \n av_dict_free ( options ) ; \n * options = tmp ; \n return ret ; \n }", "idx": 10511}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int mdct_init ( AVCodecContext * avctx , AC3MDCTContext * mdct , \n int nbits ) \n { \n int i , n , n4 , ret ; \n n = 1 << nbits ; \n n4 = n >> 2 ; \n mdct -> nbits = nbits ; \n ret = fft_init ( avctx , mdct , nbits - 2 ) ; \n if ( ret ) \n return ret ; \n mdct -> window = ff_ac3_window ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> xcos1 , n4 * sizeof ( * mdct -> xcos1 ) , mdct_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> xsin1 , n4 * sizeof ( * mdct -> xsin1 ) , mdct_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> rot_tmp , n * sizeof ( * mdct -> rot_tmp ) , mdct_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> cplx_tmp , n4 * sizeof ( * mdct -> cplx_tmp ) , mdct_alloc_fail ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n float alpha = 2.0 * M_PI * ( i + 1.0 / 8.0 ) / n ; \n mdct -> xcos1 [ i ] = FIX15 ( - cos ( alpha ) ) ; \n mdct -> xsin1 [ i ] = FIX15 ( - sin ( alpha ) ) ; \n } \n return 0 ; \n mdct_alloc_fail : \n mdct_end ( mdct ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 10512}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int png_decode_idat ( PNGDecContext * s , int length ) \n { \n int ret ; \n s -> zstream . avail_in = FFMIN ( length , bytestream2_get_bytes_left ( & s -> gb ) ) ; \n s -> zstream . next_in = ( unsigned char * ) s -> gb . buffer ; \n bytestream2_skip ( & s -> gb , length ) ; \n while ( s -> zstream . avail_in > 0 ) { \n ret = inflate ( & s -> zstream , Z_PARTIAL_FLUSH ) ; \n if ( ret != Z_OK && ret != Z_STREAM_END ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , ret ) ; \n return AVERROR_EXTERNAL ; \n } \n if ( s -> zstream . avail_out == 0 ) { \n if ( ! ( s -> state & PNG_ALLIMAGE ) ) { \n png_handle_row ( s ) ; \n } \n s -> zstream . avail_out = s -> crow_size ; \n s -> zstream . next_out = s -> crow_buf ; \n } \n if ( ret == Z_STREAM_END && s -> zstream . avail_in > 0 ) { \n av_log ( NULL , AV_LOG_WARNING , \n \" \\n \" , s -> zstream . avail_in ) ; \n return 0 ; \n } \n } \n return 0 ; \n }", "idx": 10517}
{"project": "FFmpeg", "commit_id": "582368626188c070d4300913c6da5efa4c24cfb2", "target": 1, "func": "static int mpeg_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_output , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n Mpeg1Context * s = avctx -> priv_data ; \n AVFrame * picture = data ; \n MpegEncContext * s2 = & s -> mpeg_enc_ctx ; \n av_dlog ( avctx , \" \\n \" ) ; \n if ( buf_size == 0 || ( buf_size == 4 && AV_RB32 ( buf ) == SEQ_END_CODE ) ) { \n if ( s2 -> low_delay == 0 && s2 -> next_picture_ptr ) { \n * picture = s2 -> next_picture_ptr -> f ; \n s2 -> next_picture_ptr = NULL ; \n * got_output = 1 ; \n } \n return buf_size ; \n } \n if ( s2 -> flags & CODEC_FLAG_TRUNCATED ) { \n int next = ff_mpeg1_find_frame_end ( & s2 -> parse_context , buf , buf_size , NULL ) ; \n if ( ff_combine_frame ( & s2 -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) \n return buf_size ; \n } \n if ( s -> mpeg_enc_ctx_allocated == 0 && avctx -> codec_tag == AV_RL32 ( \" \" ) ) \n vcr2_init_sequence ( avctx ) ; \n s -> slice_count = 0 ; \n if ( avctx -> extradata && ! avctx -> frame_number ) { \n int ret = decode_chunks ( avctx , picture , got_output , avctx -> extradata , avctx -> extradata_size ) ; \n if ( ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) \n return ret ; \n } \n return decode_chunks ( avctx , picture , got_output , buf , buf_size ) ; \n }", "idx": 10519}
{"project": "FFmpeg", "commit_id": "92dad6687f59a6e599834218626e524eb8a5bdae", "target": 1, "func": "av_cold void ff_fft_fixed_init_arm ( FFTContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_neon ( cpu_flags ) ) { \n s -> fft_permutation = FF_FFT_PERM_SWAP_LSBS ; \n s -> fft_calc = ff_fft_fixed_calc_neon ; \n #if CONFIG_MDCT  \n  \n  if ( ! s -> inverse && s -> mdct_bits >= 5 ) { \n s -> mdct_permutation = FF_MDCT_PERM_INTERLEAVE ; \n s -> mdct_calc = ff_mdct_fixed_calc_neon ; \n s -> mdct_calcw = ff_mdct_fixed_calcw_neon ; \n } \n #endif \n } \n }", "idx": 10521}
{"project": "FFmpeg", "commit_id": "a38469e1da7b4829a2fba4279d8420a33f96832e", "target": 0, "func": "int read_ffserver_streams ( AVFormatContext * s , const char * filename ) \n { \n int i ; \n AVFormatContext * ic ; \n ic = av_open_input_file ( filename , FFM_PACKET_SIZE ) ; \n if ( ! ic ) \n return - EIO ; \n s -> nb_streams = ic -> nb_streams ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n AVStream * st ; \n st = av_mallocz ( sizeof ( AVFormatContext ) ) ; \n memcpy ( st , ic -> streams [ i ] , sizeof ( AVStream ) ) ; \n s -> streams [ i ] = st ; \n } \n av_close_input_file ( ic ) ; \n return 0 ; \n }", "idx": 10545}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void ff_restore_parser_state ( AVFormatContext * s , AVParserState * state ) \n { \n int i ; \n AVStream * st ; \n AVParserStreamState * ss ; \n ff_read_frame_flush ( s ) ; \n if ( ! state ) \n return ; \n avio_seek ( s -> pb , state -> fpos , SEEK_SET ) ; \n s -> cur_st = state -> cur_st ; \n s -> packet_buffer = state -> packet_buffer ; \n s -> raw_packet_buffer = state -> raw_packet_buffer ; \n s -> raw_packet_buffer_remaining_size = state -> raw_packet_buffer_remaining_size ; \n for ( i = 0 ; i < state -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n ss = & state -> stream_states [ i ] ; \n st -> parser = ss -> parser ; \n st -> last_IP_pts = ss -> last_IP_pts ; \n st -> cur_dts = ss -> cur_dts ; \n st -> reference_dts = ss -> reference_dts ; \n st -> cur_ptr = ss -> cur_ptr ; \n st -> cur_len = ss -> cur_len ; \n st -> probe_packets = ss -> probe_packets ; \n st -> cur_pkt = ss -> cur_pkt ; \n } \n av_free ( state -> stream_states ) ; \n av_free ( state ) ; \n }", "idx": 10546}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int dnxhd_init_rc ( DNXHDEncContext * ctx ) \n { \n CHECKED_ALLOCZ ( ctx -> mb_rc , 8160 * ctx -> m . avctx -> qmax * sizeof ( RCEntry ) ) ; \n if ( ctx -> m . avctx -> mb_decision != FF_MB_DECISION_RD ) \n CHECKED_ALLOCZ ( ctx -> mb_cmp , ctx -> m . mb_num * sizeof ( RCCMPEntry ) ) ; \n ctx -> frame_bits = ( ctx -> cid_table -> coding_unit_size - 640 - 4 ) * 8 ; \n ctx -> qscale = 1 ; \n ctx -> lambda = 2 << LAMBDA_FRAC_BITS ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 10550}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_picture ( AVCodecContext * avctx , \n UINT8 * buf , int buf_size ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n int ref , f_code ; \n init_get_bits ( & s -> gb , buf , buf_size ) ; \n ref = get_bits ( & s -> gb , 10 ) ; \n s -> pict_type = get_bits ( & s -> gb , 3 ) ; \n dprintf ( \" \\n \" , s -> pict_type , s -> picture_number ) ; \n skip_bits ( & s -> gb , 16 ) ; \n if ( s -> pict_type == P_TYPE || s -> pict_type == B_TYPE ) { \n s -> full_pel [ 0 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 0 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 0 ] [ 1 ] = f_code ; \n } \n if ( s -> pict_type == B_TYPE ) { \n s -> full_pel [ 1 ] = get_bits1 ( & s -> gb ) ; \n f_code = get_bits ( & s -> gb , 3 ) ; \n if ( f_code == 0 ) \n return -1 ; \n s -> mpeg_f_code [ 1 ] [ 0 ] = f_code ; \n s -> mpeg_f_code [ 1 ] [ 1 ] = f_code ; \n } \n s -> current_picture . pict_type = s -> pict_type ; \n s -> current_picture . key_frame = s -> pict_type == I_TYPE ; \n s -> y_dc_scale = 8 ; \n s -> c_dc_scale = 8 ; \n s -> first_slice = 1 ; \n return 0 ; \n }", "idx": 10551}
{"project": "FFmpeg", "commit_id": "bb463d81020a2f3c5cf3403e18f980171773f48a", "target": 0, "func": "static int mpeg1_find_frame_end ( MpegEncContext * s , uint8_t * buf , int buf_size ) { \n ParseContext * pc = & s -> parse_context ; \n int i ; \n uint32_t state ; \n state = pc -> state ; \n i = 0 ; \n if ( ! pc -> frame_start_found ) { \n for ( i = 0 ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE ) { \n i ++ ; \n pc -> frame_start_found = 1 ; \n break ; \n } \n } \n } \n if ( pc -> frame_start_found ) { \n for ( ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( ( state & 0xFFFFFF00 ) == 0x100 ) { \n if ( state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE ) { \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n return i - 3 ; \n } \n } \n } \n } \n pc -> state = state ; \n return -1 ; \n }", "idx": 10552}
{"project": "FFmpeg", "commit_id": "ab61b79b1c707a9ea0512238d837ea3e8b8395ed", "target": 0, "func": "static int mov_read_mvhd ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n int i ; \n int64_t creation_time ; \n int version = avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n if ( version == 1 ) { \n creation_time = avio_rb64 ( pb ) ; \n avio_rb64 ( pb ) ; \n } else { \n creation_time = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n } \n mov_metadata_creation_time ( & c -> fc -> metadata , creation_time ) ; \n c -> time_scale = avio_rb32 ( pb ) ; \n if ( c -> time_scale <= 0 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" , c -> time_scale ) ; \n return AVERROR_INVALIDDATA ; \n } \n av_log ( c -> fc , AV_LOG_TRACE , \" \\n \" , c -> time_scale ) ; \n c -> duration = ( version == 1 ) ? avio_rb64 ( pb ) : avio_rb32 ( pb ) ; \n if ( c -> time_scale > 0 && ! c -> trex_data ) \n c -> fc -> duration = av_rescale ( c -> duration , AV_TIME_BASE , c -> time_scale ) ; \n avio_rb32 ( pb ) ; \n avio_rb16 ( pb ) ; \n avio_skip ( pb , 10 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n c -> movie_display_matrix [ i ] [ 0 ] = avio_rb32 ( pb ) ; \n c -> movie_display_matrix [ i ] [ 1 ] = avio_rb32 ( pb ) ; \n c -> movie_display_matrix [ i ] [ 2 ] = avio_rb32 ( pb ) ; \n } \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n return 0 ; \n }", "idx": 10553}
{"project": "FFmpeg", "commit_id": "b1ade3d1821a29174963b28cd0caa5f7ed394998", "target": 0, "func": "void ff_celp_lp_synthesis_filterf ( float * out , \n const float * filter_coeffs , \n const float * in , \n int buffer_length , \n int filter_length ) \n { \n int i , n ; \n filter_length ++ ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n out [ n ] = in [ n ] ; \n for ( i = 1 ; i < filter_length ; i ++ ) \n out [ n ] -= filter_coeffs [ i - 1 ] * out [ n - i ] ; \n } \n }", "idx": 10559}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n BinkDemuxContext * bink = s -> priv_data ; \n AVStream * vst = s -> streams [ 0 ] ; \n if ( ! s -> pb -> seekable ) \n return -1 ; \n if ( avio_seek ( s -> pb , vst -> index_entries [ 0 ] . pos , SEEK_SET ) < 0 ) \n return -1 ; \n bink -> video_pts = 0 ; \n memset ( bink -> audio_pts , 0 , sizeof ( bink -> audio_pts ) ) ; \n bink -> current_track = -1 ; \n return 0 ; \n }", "idx": 10560}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "func": "static int audio_read_header ( AVFormatContext * s1 , AVFormatParameters * ap ) \n { \n AudioData * s = s1 -> priv_data ; \n AVStream * st ; \n int ret ; \n if ( ! ap || ap -> sample_rate <= 0 || ap -> channels <= 0 ) \n return -1 ; \n st = av_new_stream ( s1 , 0 ) ; \n if ( ! st ) { \n return - ENOMEM ; \n } \n s -> sample_rate = ap -> sample_rate ; \n s -> channels = ap -> channels ; \n ret = audio_open ( s , 0 , ap -> device ) ; \n if ( ret < 0 ) { \n av_free ( st ) ; \n return AVERROR_IO ; \n } \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = s -> codec_id ; \n st -> codec -> sample_rate = s -> sample_rate ; \n st -> codec -> channels = s -> channels ; \n av_set_pts_info ( st , 64 , 1 , 1000000 ) ; \n return 0 ; \n }", "idx": 10562}
{"project": "FFmpeg", "commit_id": "0ccabeeaef77e240f2a44f78271a8914a23e239b", "target": 0, "func": "char * ff_get_ref_perms_string ( char * buf , size_t buf_size , int perms ) \n { \n snprintf ( buf , buf_size , \" \" , \n perms & AV_PERM_READ ? \" \" : \" \" , \n perms & AV_PERM_WRITE ? \" \" : \" \" , \n perms & AV_PERM_PRESERVE ? \" \" : \" \" , \n perms & AV_PERM_REUSE ? \" \" : \" \" , \n perms & AV_PERM_REUSE2 ? \" \" : \" \" ) ; \n return buf ; \n }", "idx": 10563}
{"project": "FFmpeg", "commit_id": "c10350358da58600884292c08a8690289b81de29", "target": 0, "func": "static void gif_copy_img_rect ( const uint32_t * src , uint32_t * dst , \n int linesize , int l , int t , int w , int h ) \n { \n const int y_start = t * linesize ; \n const uint32_t * src_px , * src_pr , \n * src_py = src + y_start , \n * dst_py = dst + y_start ; \n const uint32_t * src_pb = src_py + t * linesize ; \n uint32_t * dst_px ; \n for ( ; src_py < src_pb ; src_py += linesize , dst_py += linesize ) { \n src_px = src_py + l ; \n dst_px = ( uint32_t * ) dst_py + l ; \n src_pr = src_px + w ; \n for ( ; src_px < src_pr ; src_px ++ , dst_px ++ ) \n * dst_px = * src_px ; \n } \n }", "idx": 10565}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int alac_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n AlacEncodeContext * s = avctx -> priv_data ; \n int out_bytes , max_frame_size , ret ; \n s -> frame_size = frame -> nb_samples ; \n if ( frame -> nb_samples < DEFAULT_FRAME_SIZE ) \n max_frame_size = get_max_frame_size ( s -> frame_size , avctx -> channels , \n avctx -> bits_per_raw_sample ) ; \n else \n max_frame_size = s -> max_coded_frame_size ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , 2 * max_frame_size ) ) ) \n return ret ; \n if ( s -> compression_level ) { \n s -> verbatim = 0 ; \n s -> extra_bits = avctx -> bits_per_raw_sample - 16 ; \n } else { \n s -> verbatim = 1 ; \n s -> extra_bits = 0 ; \n } \n out_bytes = write_frame ( s , avpkt , frame -> extended_data ) ; \n if ( out_bytes > max_frame_size ) { \n s -> verbatim = 1 ; \n s -> extra_bits = 0 ; \n out_bytes = write_frame ( s , avpkt , frame -> extended_data ) ; \n } \n avpkt -> size = out_bytes ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 10566}
{"project": "FFmpeg", "commit_id": "77693c541a541661357a0edd5bbaae69c64b2039", "target": 0, "func": "static int xan_decode_frame_type1 ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n uint8_t * ybuf , * src = s -> scratch_buffer ; \n int cur , last ; \n int i , j ; \n int ret ; \n if ( ( ret = xan_decode_chroma ( avctx , bytestream2_get_le32 ( & s -> gb ) ) ) != 0 ) \n return ret ; \n bytestream2_seek ( & s -> gb , 16 , SEEK_SET ) ; \n ret = xan_unpack_luma ( s , src , \n s -> buffer_size >> 1 ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n ybuf = s -> y_buffer ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n last = ( ybuf [ 0 ] + ( * src ++ << 1 ) ) & 0x3F ; \n ybuf [ 0 ] = last ; \n for ( j = 1 ; j < avctx -> width - 1 ; j += 2 ) { \n cur = ( ybuf [ j + 1 ] + ( * src ++ << 1 ) ) & 0x3F ; \n ybuf [ j ] = ( last + cur ) >> 1 ; \n ybuf [ j + 1 ] = cur ; \n last = cur ; \n } \n ybuf [ j ] = last ; \n ybuf += avctx -> width ; \n } \n src = s -> y_buffer ; \n ybuf = s -> pic . data [ 0 ] ; \n for ( j = 0 ; j < avctx -> height ; j ++ ) { \n for ( i = 0 ; i < avctx -> width ; i ++ ) \n ybuf [ i ] = ( src [ i ] << 2 ) | ( src [ i ] >> 3 ) ; \n src += avctx -> width ; \n ybuf += s -> pic . linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 10577}
{"project": "FFmpeg", "commit_id": "158b39126d59f07069e0da07e0658111967c6179", "target": 0, "func": "static int aac_sync ( uint64_t state , AACAC3ParseContext * hdr_info , \n int * need_next_header , int * new_frame_start ) \n { \n GetBitContext bits ; \n int size , rdb , ch , sr ; \n union { \n uint64_t u64 ; \n uint8_t u8 [ 8 ] ; \n } tmp ; \n tmp . u64 = be2me_64 ( state ) ; \n init_get_bits ( & bits , tmp . u8 + 8 - AAC_HEADER_SIZE , AAC_HEADER_SIZE * 8 ) ; \n if ( get_bits ( & bits , 12 ) != 0xfff ) \n return 0 ; \n skip_bits1 ( & bits ) ; \n skip_bits ( & bits , 2 ) ; \n skip_bits1 ( & bits ) ; \n skip_bits ( & bits , 2 ) ; \n sr = get_bits ( & bits , 4 ) ; \n if ( ! ff_mpeg4audio_sample_rates [ sr ] ) \n return 0 ; \n skip_bits1 ( & bits ) ; \n ch = get_bits ( & bits , 3 ) ; \n if ( ! ff_mpeg4audio_channels [ ch ] ) \n return 0 ; \n skip_bits1 ( & bits ) ; \n skip_bits1 ( & bits ) ; \n skip_bits1 ( & bits ) ; \n skip_bits1 ( & bits ) ; \n size = get_bits ( & bits , 13 ) ; \n if ( size < AAC_HEADER_SIZE ) \n return 0 ; \n skip_bits ( & bits , 11 ) ; \n rdb = get_bits ( & bits , 2 ) ; \n hdr_info -> channels = ff_mpeg4audio_channels [ ch ] ; \n hdr_info -> sample_rate = ff_mpeg4audio_sample_rates [ sr ] ; \n hdr_info -> samples = ( rdb + 1 ) * 1024 ; \n hdr_info -> bit_rate = size * 8 * hdr_info -> sample_rate / hdr_info -> samples ; \n * need_next_header = 0 ; \n * new_frame_start = 1 ; \n return size ; \n }", "idx": 10588}
{"project": "FFmpeg", "commit_id": "1dc19729e92a96620000e09eba8e58cb458c9486", "target": 1, "func": "static void asfrtp_close_context ( PayloadContext * asf ) \n { \n ffio_free_dyn_buf ( & asf -> pktbuf ) ; \n av_freep ( & asf -> buf ) ; \n av_free ( asf ) ; \n }", "idx": 10595}
{"project": "FFmpeg", "commit_id": "f16a6f667c993a158643b52815ec42961508b0a9", "target": 1, "func": "static av_cold int dilate_init ( AVFilterContext * ctx , const char * args ) \n { \n OCVContext * ocv = ctx -> priv ; \n DilateContext * dilate = ocv -> priv ; \n char default_kernel_str [ ] = \" \" ; \n char * kernel_str ; \n const char * buf = args ; \n int ret ; \n dilate -> nb_iterations = 1 ; \n if ( args ) \n kernel_str = av_get_token ( & buf , \" \" ) ; \n if ( ( ret = parse_iplconvkernel ( & dilate -> kernel , \n * kernel_str ? kernel_str : default_kernel_str , \n ctx ) ) < 0 ) \n return ret ; \n av_free ( kernel_str ) ; \n sscanf ( buf , \" \" , & dilate -> nb_iterations ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , dilate -> nb_iterations ) ; \n if ( dilate -> nb_iterations <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n dilate -> nb_iterations ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 10597}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr32ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n const int a = ( ( uint32_t * ) src1 ) [ 2 * i + 0 ] ; \n const int e = ( ( uint32_t * ) src1 ) [ 2 * i + 1 ] ; \n const int l = ( a & 0xFF00FF ) + ( e & 0xFF00FF ) ; \n const int h = ( a & 0x00FF00 ) + ( e & 0x00FF00 ) ; \n const int b = l & 0x3FF ; \n const int g = h >> 8 ; \n const int r = l >> 16 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n } \n }", "idx": 10600}
{"project": "FFmpeg", "commit_id": "266649a52fe258c09bbe5d2e222431c6a864af3f", "target": 1, "func": "static void do_subtitle_out ( AVFormatContext * s , \n AVOutputStream * ost , \n AVInputStream * ist , \n AVSubtitle * sub , \n int64_t pts ) \n { \n static uint8_t * subtitle_out = NULL ; \n int subtitle_out_max_size = 65536 ; \n int subtitle_out_size , nb , i ; \n AVCodecContext * enc ; \n AVPacket pkt ; \n if ( pts == AV_NOPTS_VALUE ) { \n fprintf ( stderr , \" \\n \" ) ; \n if ( exit_on_error ) \n return ; \n enc = ost -> st -> codec ; \n if ( ! subtitle_out ) { \n subtitle_out = av_malloc ( subtitle_out_max_size ) ; \n if ( enc -> codec_id == CODEC_ID_DVB_SUBTITLE ) \n nb = 2 ; \n else \n nb = 1 ; \n for ( i = 0 ; i < nb ; i ++ ) { \n sub -> pts = av_rescale_q ( pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; \n subtitle_out_size = avcodec_encode_subtitle ( enc , subtitle_out , \n subtitle_out_max_size , sub ) ; \n av_init_packet ( & pkt ) ; \n pkt . stream_index = ost -> index ; \n pkt . data = subtitle_out ; \n pkt . size = subtitle_out_size ; \n pkt . pts = av_rescale_q ( pts , ist -> st -> time_base , ost -> st -> time_base ) ; \n if ( enc -> codec_id == CODEC_ID_DVB_SUBTITLE ) { \n if ( i == 0 ) \n pkt . pts += 90 * sub -> start_display_time ; \n else \n pkt . pts += 90 * sub -> end_display_time ; \n write_frame ( s , & pkt , ost -> st -> codec , bitstream_filters [ ost -> file_index ] [ pkt . stream_index ] ) ;", "idx": 10605}
{"project": "FFmpeg", "commit_id": "c46400ddecab3a47e8f1aec9a405bbe2a321b06a", "target": 1, "func": "static int caf_write_trailer ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n if ( pb -> seekable ) { \n CAFContext * caf = s -> priv_data ; \n int64_t file_size = avio_tell ( pb ) ; \n avio_seek ( pb , caf -> data , SEEK_SET ) ; \n avio_wb64 ( pb , file_size - caf -> data - 8 ) ; \n avio_seek ( pb , file_size , SEEK_SET ) ; \n if ( ! enc -> block_align ) { \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb64 ( pb , caf -> size_entries_used + 24 ) ; \n avio_wb64 ( pb , caf -> packets ) ; \n avio_wb64 ( pb , caf -> packets * samples_per_packet ( enc -> codec_id , enc -> channels ) ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_write ( pb , caf -> pkt_sizes , caf -> size_entries_used ) ; \n av_freep ( & caf -> pkt_sizes ) ; \n caf -> size_buffer_size = 0 ; \n } \n avio_flush ( pb ) ; \n } \n return 0 ; \n }", "idx": 10614}
{"project": "FFmpeg", "commit_id": "16a0d75c769a7df6f457b2200dbc9a7cc73798c6", "target": 1, "func": "static int find_marker ( const uint8_t * * pbuf_ptr , const uint8_t * buf_end ) \n { \n const uint8_t * buf_ptr ; \n unsigned int v , v2 ; \n int val ; \n int skipped = 0 ; \n buf_ptr = * pbuf_ptr ; \n while ( buf_ptr < buf_end ) { \n v = * buf_ptr ++ ; \n v2 = * buf_ptr ; \n if ( ( v == 0xff ) && ( v2 >= 0xc0 ) && ( v2 <= 0xfe ) && buf_ptr < buf_end ) { \n val = * buf_ptr ++ ; \n goto found ; \n } \n skipped ++ ; \n } \n val = -1 ; \n found : \n av_dlog ( NULL , \" \\n \" , skipped ) ; \n * pbuf_ptr = buf_ptr ; \n return val ; \n }", "idx": 10616}
{"project": "FFmpeg", "commit_id": "6a744d261930f8101132bc6d207b6eac41d9cf18", "target": 0, "func": "static void update_md5_sum ( FlacEncodeContext * s , const int16_t * samples ) \n { \n #if HAVE_BIGENDIAN  \n  \n  int i ; \n for ( i = 0 ; i < s -> frame . blocksize * s -> channels ; i ++ ) { \n int16_t smp = av_le2ne16 ( samples [ i ] ) ; \n av_md5_update ( s -> md5ctx , ( uint8_t * ) & smp , 2 ) ; \n } \n #else \n av_md5_update ( s -> md5ctx , ( const uint8_t * ) samples , s -> frame . blocksize * s -> channels * 2 ) ; \n #endif \n }", "idx": 10619}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_0lt_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 , src1 , src2 = 0 , src3 ; \n uint32_t out0 , out1 , out2 , out3 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( src_top , src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n src0 = __msa_copy_u_w ( ( v4i32 ) sum , 0 ) ; \n src1 = __msa_copy_u_w ( ( v4i32 ) sum , 1 ) ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src2 += src [ ( 4 + lp_cnt ) * stride - 1 ] ; \n } \n src0 = ( src0 + 2 ) >> 2 ; \n src3 = ( src1 + src2 + 4 ) >> 3 ; \n src1 = ( src1 + 2 ) >> 2 ; \n src2 = ( src2 + 2 ) >> 2 ; \n out0 = src0 * 0x01010101 ; \n out1 = src1 * 0x01010101 ; \n out2 = src2 * 0x01010101 ; \n out3 = src3 * 0x01010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SW ( out0 , src ) ; \n SW ( out1 , src + 4 ) ; \n SW ( out2 , src + stride * 4 ) ; \n SW ( out3 , src + stride * 4 + 4 ) ; \n src += stride ; \n } \n }", "idx": 10623}
{"project": "FFmpeg", "commit_id": "05340be97bc395ca0b544c6d856469894ecbf5eb", "target": 0, "func": "static int img_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n VideoDemuxData * s1 = s -> priv_data ; \n if ( timestamp < 0 || timestamp > s1 -> img_last - s1 -> img_first ) \n return -1 ; \n s1 -> img_number = timestamp + s1 -> img_first ; \n return 0 ; \n }", "idx": 10624}
{"project": "FFmpeg", "commit_id": "392f227393f479ab9a461aba68ae4c6b6da685a4", "target": 0, "func": "struct tm * brktimegm ( time_t secs , struct tm * tm ) \n { \n int days , y , ny , m ; \n int md [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; \n days = secs / 86400 ; \n secs %= 86400 ; \n tm -> tm_hour = secs / 3600 ; \n tm -> tm_min = ( secs % 3600 ) / 60 ; \n tm -> tm_sec = secs % 60 ; \n y = 1970 ; \n while ( days >= ( ISLEAP ( y ) ? 366 : 365 ) ) { \n ny = ( y + days / 366 ) ; \n days -= ( ny - y ) * 365 + LEAPS_COUNT ( ny - 1 ) - LEAPS_COUNT ( y - 1 ) ; \n y = ny ; \n } \n md [ 1 ] = ISLEAP ( y ) ? 29 : 28 ; \n for ( m = 0 ; days >= md [ m ] ; m ++ ) \n days -= md [ m ] ; \n tm -> tm_year = y ; \n tm -> tm_mon = m + 1 ; \n tm -> tm_mday = days + 1 ; \n return tm ; \n }", "idx": 10627}
{"project": "FFmpeg", "commit_id": "b52ae27edf392e5a0df95054d394d850b8e57d35", "target": 0, "func": "int avio_put_str16le ( AVIOContext * s , const char * str ) \n { \n const uint8_t * q = str ; \n int ret = 0 ; \n while ( * q ) { \n uint32_t ch ; \n uint16_t tmp ; \n GET_UTF8 ( ch , * q ++ , break ; )  \n PUT_UTF16 ( ch , tmp , avio_wl16 ( s , tmp )  ; ret += 2 ; ) \n } \n avio_wl16 ( s , 0 ) ; \n ret += 2 ; \n return ret ; \n }", "idx": 10631}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "void init_get_bits ( GetBitContext * s , \n UINT8 * buffer , int buffer_size ) \n { \n s -> buffer = buffer ; \n s -> size = buffer_size ; \n s -> buffer_end = buffer + buffer_size ; \n #ifdef ALT_BITSTREAM_READER \n s -> index = 0 ; \n #elif defined LIBMPEG2_BITSTREAM_READER  \n  \n  s -> buffer_ptr = buffer ; \n s -> bit_count = 16 ; \n s -> cache = 0 ; \n #elif defined A32_BITSTREAM_READER  \n  \n  s -> buffer_ptr = ( uint32_t * ) buffer ; \n s -> bit_count = 32 ; \n s -> cache0 = 0 ; \n s -> cache1 = 0 ; \n #endif \n { \n OPEN_READER ( re , s )  \n UPDATE_CACHE ( re , s )  \n CLOSE_READER ( re , s )  \n } \n #ifdef A32_BITSTREAM_READER \n s -> cache1 = 0 ; \n #endif \n }", "idx": 10632}
{"project": "FFmpeg", "commit_id": "97437bd17a8c5d4135b2f3b1b299bd7bb72ce02c", "target": 1, "func": "void ff_aac_coder_init_mips ( AACEncContext * c ) { \n #if HAVE_INLINE_ASM  \n  \n  AACCoefficientsEncoder * e = c -> coder ; \n int option = c -> options . aac_coder ; \n if ( option == 2 ) { \n e -> quantize_and_encode_band = quantize_and_encode_band_mips ; \n e -> encode_window_bands_info = codebook_trellis_rate ; \n #if HAVE_MIPSFPU  \n  \n  e -> search_for_quantizers = search_for_quantizers_twoloop ; \n #endif \n } \n #if HAVE_MIPSFPU  \n  \n  e -> search_for_ms = search_for_ms_mips ; \n #endif \n #endif \n }", "idx": 10636}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_cox ( J2kDecoderContext * s , J2kCodingStyle * c ) \n { \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n c -> nreslevels = bytestream_get_byte ( & s -> buf ) + 1 ; \n c -> log2_cblk_width = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> log2_cblk_height = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> cblk_style = bytestream_get_byte ( & s -> buf ) ; \n if ( c -> cblk_style != 0 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" , c -> cblk_style ) ; \n } \n c -> transform = bytestream_get_byte ( & s -> buf ) ; \n if ( c -> csty & J2K_CSTY_PREC ) { \n int i ; \n for ( i = 0 ; i < c -> nreslevels ; i ++ ) \n bytestream_get_byte ( & s -> buf ) ; \n } \n return 0 ; \n }", "idx": 10639}
{"project": "FFmpeg", "commit_id": "a9f8587e152c16e943c645ff295e015384ccd76d", "target": 0, "func": "static void write_streaminfo ( FlacEncodeContext * s , uint8_t * header ) \n { \n PutBitContext pb ; \n memset ( header , 0 , FLAC_STREAMINFO_SIZE ) ; \n init_put_bits ( & pb , header , FLAC_STREAMINFO_SIZE ) ; \n put_bits ( & pb , 16 , s -> avctx -> frame_size ) ; \n put_bits ( & pb , 16 , s -> avctx -> frame_size ) ; \n put_bits ( & pb , 24 , 0 ) ; \n put_bits ( & pb , 24 , s -> max_framesize ) ; \n put_bits ( & pb , 20 , s -> samplerate ) ; \n put_bits ( & pb , 3 , s -> channels - 1 ) ; \n put_bits ( & pb , 5 , 15 ) ; \n put_bits ( & pb , 24 , ( s -> sample_count & 0xFFFFFF000LL ) >> 12 ) ; \n put_bits ( & pb , 12 , s -> sample_count & 0x000000FFFLL ) ; \n flush_put_bits ( & pb ) ; \n }", "idx": 10647}
{"project": "FFmpeg", "commit_id": "14b6adfd4627421223894c6909476d229cb6d07d", "target": 1, "func": "static void dequantize_slice_buffered ( SnowContext * s , slice_buffer * sb , SubBand * b , IDWTELEM * src , int stride , int start_y , int end_y ) { \n const int w = b -> width ; \n const int qlog = av_clip ( s -> qlog + b -> qlog , 0 , QROOT * 16 ) ; \n const int qmul = ff_qexp [ qlog & ( QROOT - 1 ) ] << ( qlog >> QSHIFT ) ; \n const int qadd = ( s -> qbias * qmul ) >> QBIAS_SHIFT ; \n int x , y ; \n if ( s -> qlog == LOSSLESS_QLOG ) return ; \n for ( y = start_y ; y < end_y ; y ++ ) { \n IDWTELEM * line = slice_buffer_get_line ( sb , ( y * b -> stride_line ) + b -> buf_y_offset ) + b -> buf_x_offset ; \n for ( x = 0 ; x < w ; x ++ ) { \n int i = line [ x ] ; \n if ( i < 0 ) { \n line [ x ] = - ( ( - i * qmul + qadd ) >> ( QEXPSHIFT ) ) ; \n } else if ( i > 0 ) { \n line [ x ] = ( ( i * qmul + qadd ) >> ( QEXPSHIFT ) ) ; \n } \n } \n } \n }", "idx": 10651}
{"project": "FFmpeg", "commit_id": "8d0786ec6d066f892f29da6593e99e73a7dfd014", "target": 0, "func": "static int wav_write_header ( AVFormatContext * s ) \n { \n WAVContext * wav = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int64_t fmt , fact ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wl32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n fmt = ff_start_tag ( pb , \" \" ) ; \n if ( ff_put_wav_header ( pb , s -> streams [ 0 ] -> codec ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n s -> streams [ 0 ] -> codec -> codec ? s -> streams [ 0 ] -> codec -> codec -> name : \" \" ) ; \n av_free ( wav ) ; \n return -1 ; \n } \n ff_end_tag ( pb , fmt ) ; \n if ( s -> streams [ 0 ] -> codec -> codec_tag != 0x01 \n && s -> pb -> seekable ) { \n fact = ff_start_tag ( pb , \" \" ) ; \n avio_wl32 ( pb , 0 ) ; \n ff_end_tag ( pb , fact ) ; \n } \n av_set_pts_info ( s -> streams [ 0 ] , 64 , 1 , s -> streams [ 0 ] -> codec -> sample_rate ) ; \n wav -> maxpts = wav -> last_duration = 0 ; \n wav -> minpts = INT64_MAX ; \n wav -> data = ff_start_tag ( pb , \" \" ) ; \n avio_flush ( pb ) ; \n return 0 ; \n }", "idx": 10655}
{"project": "FFmpeg", "commit_id": "438f884fc48b4b956fa713df2a722bd484f5646b", "target": 0, "func": "void ff_llviddsp_init_x86 ( LLVidDSPContext * c ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n #if HAVE_INLINE_ASM && HAVE_7REGS && ARCH_X86_32  \n  \n  if ( cpu_flags & AV_CPU_FLAG_CMOV ) \n c -> add_median_pred = add_median_pred_cmov ; \n #endif \n if ( ARCH_X86_32 && EXTERNAL_MMX ( cpu_flags ) ) { \n c -> add_bytes = ff_add_bytes_mmx ; \n } \n if ( ARCH_X86_32 && EXTERNAL_MMXEXT ( cpu_flags ) ) { \n if ( ! ( cpu_flags & AV_CPU_FLAG_3DNOW ) ) \n c -> add_median_pred = ff_add_median_pred_mmxext ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n c -> add_bytes = ff_add_bytes_sse2 ; \n c -> add_median_pred = ff_add_median_pred_sse2 ; \n } \n if ( EXTERNAL_SSSE3 ( cpu_flags ) ) { \n c -> add_left_pred = ff_add_left_pred_ssse3 ; \n c -> add_left_pred_int16 = ff_add_left_pred_int16_ssse3 ; \n c -> add_gradient_pred = ff_add_gradient_pred_ssse3 ; \n } \n if ( EXTERNAL_SSSE3_FAST ( cpu_flags ) ) { \n c -> add_left_pred = ff_add_left_pred_unaligned_ssse3 ; \n } \n if ( EXTERNAL_SSE4 ( cpu_flags ) ) { \n c -> add_left_pred_int16 = ff_add_left_pred_int16_sse4 ; \n } \n if ( EXTERNAL_AVX2_FAST ( cpu_flags ) ) { \n c -> add_bytes = ff_add_bytes_avx2 ; \n c -> add_left_pred = ff_add_left_pred_unaligned_avx2 ; \n c -> add_gradient_pred = ff_add_gradient_pred_avx2 ; \n } \n }", "idx": 10656}
{"project": "FFmpeg", "commit_id": "ff1e30c059386db05131fe2f5bca1f35e1f5ac7e", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s , AVFrame * frame ) \n { \n int x , y ; \n unsigned char P [ 8 ] ; \n int flags = 0 ; \n bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ; \n if ( P [ 0 ] <= P [ 1 ] ) { \n for ( y = 0 ; y < 16 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n if ( y ) bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ; \n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ; \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } else { \n int vert ; \n uint64_t flags = bytestream2_get_le64 ( & s -> stream_ptr ) ; \n bytestream2_get_buffer ( & s -> stream_ptr , P + 4 , 4 ) ; \n vert = P [ 4 ] <= P [ 5 ] ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ , flags >>= 2 ) \n * s -> pixel_ptr ++ = P [ flags & 0x03 ] ; \n if ( vert ) { \n s -> pixel_ptr += s -> stride - 4 ; \n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ; \n } else if ( y & 1 ) s -> pixel_ptr += s -> line_inc ; \n if ( y == 7 ) { \n memcpy ( P , P + 4 , 4 ) ; \n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ; \n return 0 ;", "idx": 10663}
{"project": "FFmpeg", "commit_id": "46e75617d9700be8840a843237f8571061a63a8e", "target": 1, "func": "static av_cold int truemotion1_decode_init ( AVCodecContext * avctx ) \n { \n TrueMotion1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> frame = av_frame_alloc ( ) ; \n if ( ! s -> frame ) \n return AVERROR ( ENOMEM ) ; \n av_fast_malloc ( & s -> vert_pred , & s -> vert_pred_size , s -> avctx -> width * sizeof ( unsigned int ) ) ; \n if ( ! s -> vert_pred ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 10664}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_ZERO_mips ( struct AACEncContext * s , \n PutBitContext * pb , const float * in , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits ) \n { \n int i ; \n float cost = 0 ; \n for ( i = 0 ; i < size ; i += 4 ) { \n cost += in [ i ] * in [ i ] ; \n cost += in [ i + 1 ] * in [ i + 1 ] ; \n cost += in [ i + 2 ] * in [ i + 2 ] ; \n cost += in [ i + 3 ] * in [ i + 3 ] ; \n } \n if ( bits ) \n * bits = 0 ; \n return cost * lambda ; \n }", "idx": 10676}
{"project": "FFmpeg", "commit_id": "d445a7e9cc31b94ab1eceb228a7634c79d37496e", "target": 1, "func": "static void extract_mpeg4_header ( AVFormatContext * infile ) \n { \n int mpeg4_count , i , size ; \n AVPacket pkt ; \n AVStream * st ; \n const uint8_t * p ; \n mpeg4_count = 0 ; \n for ( i = 0 ; i < infile -> nb_streams ; i ++ ) { \n st = infile -> streams [ i ] ; \n if ( st -> codec . codec_id == CODEC_ID_MPEG4 && \n st -> codec . extradata_size == 0 ) { \n mpeg4_count ++ ; \n } \n } \n if ( ! mpeg4_count ) \n return ; \n printf ( \" \\n \" ) ; \n while ( mpeg4_count > 0 ) { \n if ( av_read_packet ( infile , & pkt ) < 0 ) \n break ; \n st = infile -> streams [ pkt . stream_index ] ; \n if ( st -> codec . codec_id == CODEC_ID_MPEG4 && \n st -> codec . extradata_size == 0 ) { \n av_freep ( & st -> codec . extradata ) ; \n p = pkt . data ; \n while ( p < pkt . data + pkt . size - 4 ) { \n if ( p [ 0 ] == 0x00 && p [ 1 ] == 0x00 && \n p [ 2 ] == 0x01 && p [ 3 ] == 0xb6 ) { \n size = p - pkt . data ; \n st -> codec . extradata = av_malloc ( size ) ; \n st -> codec . extradata_size = size ; \n memcpy ( st -> codec . extradata , pkt . data , size ) ; \n break ; \n } \n p ++ ; \n } \n mpeg4_count -- ; \n } \n av_free_packet ( & pkt ) ; \n } \n }", "idx": 10690}
{"project": "FFmpeg", "commit_id": "6fb2fd895e858ab93f46e656a322778ee181c307", "target": 1, "func": "void avfilter_unref_buffer ( AVFilterBufferRef * ref ) \n { \n if ( ! ref ) \n return ; \n av_assert0 ( ref -> buf -> refcount > 0 ) ; \n if ( ! ( -- ref -> buf -> refcount ) ) { \n if ( ! ref -> buf -> free ) { \n store_in_pool ( ref ) ; \n return ; \n } \n ref -> buf -> free ( ref -> buf ) ; \n } \n if ( ref -> extended_data != ref -> data ) \n av_freep ( & ref -> extended_data ) ; \n if ( ref -> video ) \n av_freep ( & ref -> video -> qp_table ) ; \n av_freep ( & ref -> video ) ; \n av_freep ( & ref -> audio ) ; \n av_free ( ref ) ; \n }", "idx": 10691}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void FUNC ( idctSparseColAdd ) ( pixel * dest , int line_size , \n DCTELEM * col ) \n { \n int a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; \n INIT_CLIP ; \n IDCT_COLS ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a0 + b0 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a1 + b1 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a2 + b2 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a3 + b3 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a3 - b3 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a2 - b2 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a1 - b1 ) >> COL_SHIFT ) ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( dest [ 0 ] + ( ( a0 - b0 ) >> COL_SHIFT ) ) ; \n }", "idx": 10695}
{"project": "FFmpeg", "commit_id": "640a2427aafa774b83316b7a8c5c2bdc28bfd269", "target": 1, "func": "static int bfi_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n BFIContext * bfi = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int ret , audio_offset , video_offset , chunk_size , audio_size = 0 ; \n if ( bfi -> nframes == 0 || pb -> eof_reached ) { \n return AVERROR ( EIO ) ; \n if ( ! bfi -> avflag ) { \n uint32_t state = 0 ; \n while ( state != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n if ( pb -> eof_reached ) \n return AVERROR ( EIO ) ; \n state = 256 * state + avio_r8 ( pb ) ; \n chunk_size = avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n audio_offset = avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n video_offset = avio_rl32 ( pb ) ; \n audio_size = video_offset - audio_offset ; \n bfi -> video_size = chunk_size - video_offset ; \n ret = av_get_packet ( pb , pkt , audio_size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pts = bfi -> audio_frame ; \n bfi -> audio_frame += ret ; \n } else if ( bfi -> video_size > 0 ) { \n ret = av_get_packet ( pb , pkt , bfi -> video_size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> pts = bfi -> video_frame ; \n bfi -> video_frame += ret / bfi -> video_size ; \n bfi -> nframes -- ; \n } else { \n ret = AVERROR ( EAGAIN ) ; \n bfi -> avflag = ! bfi -> avflag ; \n pkt -> stream_index = bfi -> avflag ; \n return ret ;", "idx": 10696}
{"project": "FFmpeg", "commit_id": "f63166f8dff65942c633adf32da9847ee1da3a47", "target": 1, "func": "static void qpeg_decode_intra ( uint8_t * src , uint8_t * dst , int size , \n int stride , int width , int height ) \n { \n int i ; \n int code ; \n int c0 , c1 ; \n int run , copy ; \n int filled = 0 ; \n height -- ; \n dst = dst + height * stride ; \n while ( size > 0 ) { \n code = * src ++ ; \n size -- ; \n run = copy = 0 ; \n if ( code == 0xFC ) \n break ; \n if ( code >= 0xF8 ) { \n c0 = * src ++ ; \n c1 = * src ++ ; \n size -= 2 ; \n run = ( ( code & 0x7 ) << 16 ) + ( c0 << 8 ) + c1 + 2 ; \n } else if ( code >= 0xF0 ) { \n c0 = * src ++ ; \n size -- ; \n run = ( ( code & 0xF ) << 8 ) + c0 + 2 ; \n } else if ( code >= 0xE0 ) { \n run = ( code & 0x1F ) + 2 ; \n } else if ( code >= 0xC0 ) { \n c0 = * src ++ ; \n c1 = * src ++ ; \n size -= 2 ; \n copy = ( ( code & 0x3F ) << 16 ) + ( c0 << 8 ) + c1 + 1 ; \n } else if ( code >= 0x80 ) { \n c0 = * src ++ ; \n size -- ; \n copy = ( ( code & 0x7F ) << 8 ) + c0 + 1 ; \n } else { \n copy = code + 1 ; \n } \n if ( run ) { \n int p ; \n p = * src ++ ; \n size -- ; \n for ( i = 0 ; i < run ; i ++ ) { \n dst [ filled ++ ] = p ; \n if ( filled >= width ) { \n filled = 0 ; \n dst -= stride ; \n } \n } \n } else { \n for ( i = 0 ; i < copy ; i ++ ) { \n dst [ filled ++ ] = * src ++ ; \n if ( filled >= width ) { \n filled = 0 ; \n dst -= stride ; \n } \n } \n size -= copy ; \n } \n } \n }", "idx": 10698}
{"project": "FFmpeg", "commit_id": "6369ba3c9cc74becfaad2a8882dff3dd3e7ae3c0", "target": 0, "func": "av_cold void ff_dnxhdenc_init_x86 ( DNXHDEncContext * ctx ) \n { \n #if HAVE_SSE2_INLINE  \n  \n  if ( av_get_cpu_flags ( ) & AV_CPU_FLAG_SSE2 ) { \n if ( ctx -> cid_table -> bit_depth == 8 ) \n ctx -> get_pixels_8x4_sym = get_pixels_8x4_sym_sse2 ; \n } \n #endif \n }", "idx": 10707}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static int delta_decode ( uint8_t * dst , const uint8_t * src , int src_size , \n unsigned val , const int8_t * table ) \n { \n uint8_t * dst0 = dst ; \n while ( src_size -- ) { \n uint8_t d = * src ++ ; \n val = av_clip_uint8 ( val + table [ d & 0xF ] ) ; \n * dst ++ = val ; \n val = av_clip_uint8 ( val + table [ d >> 4 ] ) ; \n * dst ++ = val ; \n } \n return dst - dst0 ; \n }", "idx": 10718}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void find_peaks ( DCAEncContext * c ) \n { \n int band , ch ; \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) { \n int sample ; \n int32_t m = 0 ; \n for ( sample = 0 ; sample < SUBBAND_SAMPLES ; sample ++ ) { \n int32_t s = abs ( c -> subband [ sample ] [ band ] [ ch ] ) ; \n if ( m < s ) \n m = s ; \n } \n c -> peak_cb [ band ] [ ch ] = get_cb ( m ) ; \n } \n if ( c -> lfe_channel ) { \n int sample ; \n int32_t m = 0 ; \n for ( sample = 0 ; sample < DCA_LFE_SAMPLES ; sample ++ ) \n if ( m < abs ( c -> downsampled_lfe [ sample ] ) ) \n m = abs ( c -> downsampled_lfe [ sample ] ) ; \n c -> lfe_peak_cb = get_cb ( m ) ; \n } \n }", "idx": 10737}
{"project": "FFmpeg", "commit_id": "2c21d34ea44d38835f85b90de3cbbf54abb894be", "target": 1, "func": "void av_free ( void * ptr ) \n { \n #if CONFIG_MEMALIGN_HACK  \n  \n  if ( ptr ) \n free ( ( char * ) ptr - ( ( char * ) ptr ) [ -1 ] ) ; \n #elif HAVE_ALIGNED_MALLOC  \n  \n  _aligned_free ( ptr ) ; \n #else \n free ( ptr ) ; \n #endif \n }", "idx": 10740}
{"project": "FFmpeg", "commit_id": "e54165aa392322bbeeb823fc33a17336e465b7b5", "target": 1, "func": "static int tta_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n TTAContext * c = s -> priv_data ; \n AVStream * st = s -> streams [ stream_index ] ; \n int index = av_index_search_timestamp ( st , timestamp , flags ) ; \n if ( index < 0 ) \n return -1 ; \n c -> currentframe = index ; \n avio_seek ( s -> pb , st -> index_entries [ index ] . pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 10745}
{"project": "FFmpeg", "commit_id": "780dba01f9aed8c9b6ba05eceac2fe3eac71198b", "target": 1, "func": "void ff_aac_update_ltp ( AACEncContext * s , SingleChannelElement * sce ) \n { \n int i , j , lag ; \n float corr , s0 , s1 , max_corr = 0.0f ; \n float * samples = & s -> planar_samples [ s -> cur_channel ] [ 1024 ] ; \n float * pred_signal = & sce -> ltp_state [ 0 ] ; \n int samples_num = 2048 ; \n if ( s -> profile != FF_PROFILE_AAC_LTP ) \n return ; \n for ( i = 0 ; i < samples_num ; i ++ ) { \n s0 = s1 = 0.0f ; \n for ( j = 0 ; j < samples_num ; j ++ ) { \n if ( j + 1024 < i ) \n continue ; \n s0 += samples [ j ] * pred_signal [ j - i + 1024 ] ; \n s1 += pred_signal [ j - i + 1024 ] * pred_signal [ j - i + 1024 ] ; \n } \n corr = s1 > 0.0f ? s0 / sqrt ( s1 ) : 0.0f ; \n if ( corr > max_corr ) { \n max_corr = corr ; \n lag = i ; \n } \n } \n lag = av_clip ( lag , 0 , 2048 ) ; \n if ( ! lag ) { \n sce -> ics . ltp . lag = lag ; \n return ; \n } \n s0 = s1 = 0.0f ; \n for ( i = 0 ; i < lag ; i ++ ) { \n s0 += samples [ i ] ; \n s1 += pred_signal [ i - lag + 1024 ] ; \n } \n sce -> ics . ltp . coef_idx = quant_array_idx ( s0 / s1 , ltp_coef , 8 ) ; \n sce -> ics . ltp . coef = ltp_coef [ sce -> ics . ltp . coef_idx ] ; \n if ( lag < 1024 ) \n samples_num = lag + 1024 ; \n for ( i = 0 ; i < samples_num ; i ++ ) \n pred_signal [ i + 1024 ] = sce -> ics . ltp . coef * pred_signal [ i - lag + 1024 ] ; \n memset ( & pred_signal [ samples_num ] , 0 , ( 2048 - samples_num ) * sizeof ( float ) ) ; \n sce -> ics . ltp . lag = lag ; \n }", "idx": 10747}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel16_mc20_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_16w_msa ( src - 2 , stride , dst , stride , 16 ) ; \n }", "idx": 10749}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void avformat_free_context ( AVFormatContext * s ) \n { \n int i ; \n AVStream * st ; \n av_opt_free ( s ) ; \n if ( s -> iformat && s -> iformat -> priv_class && s -> priv_data ) \n av_opt_free ( s -> priv_data ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( st -> parser ) { \n av_parser_close ( st -> parser ) ; \n av_free_packet ( & st -> cur_pkt ) ; \n } \n if ( st -> attached_pic . data ) \n av_free_packet ( & st -> attached_pic ) ; \n av_dict_free ( & st -> metadata ) ; \n av_free ( st -> index_entries ) ; \n av_free ( st -> codec -> extradata ) ; \n av_free ( st -> codec -> subtitle_header ) ; \n av_free ( st -> codec ) ; \n av_free ( st -> priv_data ) ; \n av_free ( st -> info ) ; \n av_free ( st ) ; \n } \n for ( i = s -> nb_programs - 1 ; i >= 0 ; i -- ) { \n av_dict_free ( & s -> programs [ i ] -> metadata ) ; \n av_freep ( & s -> programs [ i ] -> stream_index ) ; \n av_freep ( & s -> programs [ i ] ) ; \n } \n av_freep ( & s -> programs ) ; \n av_freep ( & s -> priv_data ) ; \n while ( s -> nb_chapters -- ) { \n av_dict_free ( & s -> chapters [ s -> nb_chapters ] -> metadata ) ; \n av_free ( s -> chapters [ s -> nb_chapters ] ) ; \n } \n av_freep ( & s -> chapters ) ; \n av_dict_free ( & s -> metadata ) ; \n av_freep ( & s -> streams ) ; \n av_free ( s ) ; \n }", "idx": 10752}
{"project": "FFmpeg", "commit_id": "6fbb21d6858b9d0152f89e1b30ffe683a9d33948", "target": 0, "func": "static int vsink_query_formats ( AVFilterContext * ctx ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterFormats * formats = NULL ; \n unsigned i ; \n int ret ; \n if ( buf -> pixel_fmts_size % sizeof ( * buf -> pixel_fmts ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( buf -> pixel_fmts_size ) { \n for ( i = 0 ; i < NB_ITEMS ( buf -> pixel_fmts ) ; i ++ ) \n if ( ( ret = ff_add_format ( & formats , buf -> pixel_fmts [ i ] ) ) < 0 ) \n return ret ; \n ff_set_common_formats ( ctx , formats ) ; \n } else { \n ff_default_query_formats ( ctx ) ; \n } \n return 0 ; \n }", "idx": 10755}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "av_cold void ff_vp56_init ( AVCodecContext * avctx , int flip , int has_alpha ) \n { \n VP56Context * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = has_alpha ? PIX_FMT_YUVA420P : PIX_FMT_YUV420P ; \n if ( avctx -> idct_algo == FF_IDCT_AUTO ) \n avctx -> idct_algo = FF_IDCT_VP3 ; \n ff_dsputil_init ( & s -> dsp , avctx ) ; \n ff_vp56dsp_init ( & s -> vp56dsp , avctx -> codec -> id ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> scantable , ff_zigzag_direct ) ; \n for ( i = 0 ; i < 4 ; i ++ ) \n s -> framep [ i ] = & s -> frames [ i ] ; \n s -> framep [ VP56_FRAME_UNUSED ] = s -> framep [ VP56_FRAME_GOLDEN ] ; \n s -> framep [ VP56_FRAME_UNUSED2 ] = s -> framep [ VP56_FRAME_GOLDEN2 ] ; \n s -> edge_emu_buffer_alloc = NULL ; \n s -> above_blocks = NULL ; \n s -> macroblocks = NULL ; \n s -> quantizer = -1 ; \n s -> deblock_filtering = 1 ; \n s -> filter = NULL ; \n s -> has_alpha = has_alpha ; \n if ( flip ) { \n s -> flip = -1 ; \n s -> frbi = 2 ; \n s -> srbi = 0 ; \n } else { \n s -> flip = 1 ; \n s -> frbi = 0 ; \n s -> srbi = 2 ; \n } \n }", "idx": 10756}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int rso_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int bps = av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) ; \n int ret = av_get_packet ( s -> pb , pkt , BLOCK_SIZE * bps >> 3 ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = 0 ; \n pkt -> size = ret ; \n return 0 ; \n }", "idx": 10758}
{"project": "FFmpeg", "commit_id": "b1ade3d1821a29174963b28cd0caa5f7ed394998", "target": 0, "func": "void ff_celp_lp_zero_synthesis_filterf ( float * out , \n const float * filter_coeffs , \n const float * in , \n int buffer_length , \n int filter_length ) \n { \n int i , n ; \n filter_length ++ ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n out [ n ] = in [ n ] ; \n for ( i = 1 ; i < filter_length ; i ++ ) \n out [ n ] += filter_coeffs [ i - 1 ] * in [ n - i ] ; \n } \n }", "idx": 10763}
{"project": "FFmpeg", "commit_id": "16f753f43fba3b9b16cb9fa62e99f481aaa29ae9", "target": 0, "func": "static int flac_probe ( AVProbeData * p ) \n { \n uint8_t * bufptr = p -> buf ; \n if ( ff_id3v2_match ( bufptr ) ) \n bufptr += ff_id3v2_tag_len ( bufptr ) ; \n if ( memcmp ( bufptr , \" \" , 4 ) ) return 0 ; \n else return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 10769}
{"project": "FFmpeg", "commit_id": "006508032057824a371bec4e629b66f8cbb26c47", "target": 0, "func": "static av_always_inline void decode_dc_coeffs ( GetBitContext * gb , DCTELEM * out , \n int blocks_per_slice ) \n { \n DCTELEM prev_dc ; \n int code , i , sign ; \n OPEN_READER ( re , gb ) ; \n DECODE_CODEWORD ( code , FIRST_DC_CB ) ; \n prev_dc = TOSIGNED ( code ) ; \n out [ 0 ] = prev_dc ; \n out += 64 ; \n code = 5 ; \n sign = 0 ; \n for ( i = 1 ; i < blocks_per_slice ; i ++ , out += 64 ) { \n DECODE_CODEWORD ( code , dc_codebook [ FFMIN ( code , 6 ) ] ) ; \n if ( code ) sign ^= - ( code & 1 ) ; \n else sign = 0 ; \n prev_dc += ( ( ( code + 1 ) >> 1 ) ^ sign ) - sign ; \n out [ 0 ] = prev_dc ; \n } \n CLOSE_READER ( re , gb ) ; \n }", "idx": 10770}
{"project": "FFmpeg", "commit_id": "d565fef1b83b6c5f8afb32229260b79f67c68109", "target": 1, "func": "int av_vdpau_bind_context ( AVCodecContext * avctx , VdpDevice device , \n VdpGetProcAddress * get_proc , unsigned flags ) \n { \n VDPAUHWContext * hwctx ; \n if ( flags != 0 ) \n return AVERROR ( EINVAL ) ; \n if ( av_reallocp ( & avctx -> hwaccel_context , sizeof ( * hwctx ) ) ) \n return AVERROR ( ENOMEM ) ; \n hwctx = avctx -> hwaccel_context ; \n memset ( hwctx , 0 , sizeof ( * hwctx ) ) ; \n hwctx -> context . decoder = VDP_INVALID_HANDLE ; \n hwctx -> device = device ; \n hwctx -> get_proc_address = get_proc ; \n hwctx -> reset = 1 ; \n return 0 ; \n }", "idx": 10771}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgeh ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_v_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 10777}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int mov_read_stss ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = ( MOVStreamContext * ) st -> priv_data ; \n int entries , i ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; get_byte ( pb ) ; \n entries = get_be32 ( pb ) ; \n sc -> keyframe_count = entries ; \n #ifdef DEBUG \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , sc -> keyframe_count ) ; \n #endif \n sc -> keyframes = ( long * ) av_malloc ( entries * sizeof ( long ) ) ; \n if ( ! sc -> keyframes ) \n return -1 ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> keyframes [ i ] = get_be32 ( pb ) ; \n #ifdef DEBUG \n #endif \n } \n return 0 ; \n }", "idx": 10782}
{"project": "FFmpeg", "commit_id": "aeccb522ebb6fb0378bccd6393f1d0c1ca40fdd4", "target": 1, "func": "static int concat_read_packet ( AVFormatContext * avf , AVPacket * pkt ) \n { \n ConcatContext * cat = avf -> priv_data ; \n int ret ; \n int64_t delta ; \n while ( 1 ) { \n if ( ( ret = av_read_frame ( cat -> avf , pkt ) ) != AVERROR_EOF || \n ( ret = open_next_file ( avf ) ) < 0 ) \n break ; \n } \n delta = av_rescale_q ( cat -> cur_file -> start_time - cat -> avf -> start_time , \n AV_TIME_BASE_Q , \n cat -> avf -> streams [ pkt -> stream_index ] -> time_base ) ; \n if ( pkt -> pts != AV_NOPTS_VALUE ) \n pkt -> pts += delta ; \n if ( pkt -> dts != AV_NOPTS_VALUE ) \n pkt -> dts += delta ; \n }", "idx": 10784}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( rgb24ToY ) ( uint8_t * dst , const uint8_t * src , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToY_mmx ) ( dst , src , width , PIX_FMT_RGB24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int b = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n #endif \n }", "idx": 10786}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb16to32 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n const uint16_t * end ; \n const uint16_t * mm_end ; \n uint8_t * d = dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n mm_end = end - 3 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PACK_RGB32 \n : \" \" ( * d ) \n : \" \" ( * s ) , \" \" ( mask16b ) , \" \" ( mask16g ) , \" \" ( mask16r ) \n : \" \" ) ; \n d += 16 ; \n s += 4 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n while ( s < end ) { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = 255 ; \n } \n }", "idx": 10787}
{"project": "FFmpeg", "commit_id": "cc40c056d01a95b0a57950d4d8aec9e86060c6b6", "target": 0, "func": "static av_cold int adx_encode_init ( AVCodecContext * avctx ) \n { \n ADXContext * c = avctx -> priv_data ; \n if ( avctx -> channels > 2 ) \n return -1 ; \n avctx -> frame_size = 32 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n avctx -> coded_frame -> key_frame = 1 ; \n c -> cutoff = 500 ; \n ff_adx_calculate_coeffs ( c -> cutoff , avctx -> sample_rate , COEFF_BITS , c -> coeff ) ; \n return 0 ; \n }", "idx": 10789}
{"project": "FFmpeg", "commit_id": "cc04af3481438e74278fff4532a0956363155708", "target": 0, "func": "static int mpegps_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n MpegDemuxContext * m = s -> priv_data ; \n uint8_t buffer [ 8192 ] ; \n char * p ; \n m -> header_state = 0xff ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n get_buffer ( & s -> pb , buffer , sizeof ( buffer ) ) ; \n if ( ( p = memchr ( buffer , ' ' , sizeof ( buffer ) ) ) ) \n if ( ! memcmp ( p , \" \" , 6 ) ) \n m -> sofdec = 1 ; \n url_fseek ( & s -> pb , - sizeof ( buffer ) , SEEK_CUR ) ; \n return 0 ; \n }", "idx": 10790}
{"project": "FFmpeg", "commit_id": "22b37f5d3200cfe4c15eded883663cf0612093c1", "target": 0, "func": "int get_frame_filename ( char * buf , int buf_size , \n const char * path , int number ) \n { \n const char * p ; \n char * q , buf1 [ 20 ] ; \n int nd , len , c , percentd_found ; \n q = buf ; \n p = path ; \n percentd_found = 0 ; \n for ( ; ; ) { \n c = * p ++ ; \n if ( c == ' \\0 ' ) \n break ; \n if ( c == ' ' ) { \n do { \n nd = 0 ; \n while ( isdigit ( * p ) ) { \n nd = nd * 10 + * p ++ - ' ' ; \n } \n c = * p ++ ; \n if ( c == ' ' && nd > 0 ) { \n number = number % nd ; \n c = * p ++ ; \n nd = 0 ; \n } \n } while ( isdigit ( c ) ) ; \n switch ( c ) { \n case ' ' : \n goto addchar ; \n case ' ' : \n if ( percentd_found ) \n goto fail ; \n percentd_found = 1 ; \n snprintf ( buf1 , sizeof ( buf1 ) , \" \" , nd , number ) ; \n len = strlen ( buf1 ) ; \n if ( ( q - buf + len ) > buf_size - 1 ) \n goto fail ; \n memcpy ( q , buf1 , len ) ; \n q += len ; \n break ; \n default : \n goto fail ; \n } \n } else { \n addchar : \n if ( ( q - buf ) < buf_size - 1 ) \n * q ++ = c ; \n } \n } \n if ( ! percentd_found ) \n goto fail ; \n * q = ' \\0 ' ; \n return 0 ; \n fail : \n * q = ' \\0 ' ; \n return -1 ; \n }", "idx": 10791}
{"project": "FFmpeg", "commit_id": "69c23e6f33c38ebc03ce7f51fcb963deaff7383b", "target": 0, "func": "static void decode ( Real288_internal * glob , float gain , int cb_coef ) \n { \n unsigned int x , y ; \n float f ; \n double sum , sumsum ; \n float * p1 , * p2 ; \n float buffer [ 5 ] ; \n for ( x = 36 ; x -- ; glob -> sb [ x + 5 ] = glob -> sb [ x ] ) ; \n for ( x = 5 ; x -- ; ) { \n p1 = glob -> sb + x ; \n p2 = glob -> pr1 ; \n for ( sum = 0 , y = 36 ; y -- ; sum -= ( * ( ++ p1 ) ) * ( * ( p2 ++ ) ) ) ; \n glob -> sb [ x ] = sum ; \n } \n for ( sum = 32 , x = 10 ; x -- ; sum -= glob -> pr2 [ x ] * glob -> lhist [ x ] ) ; \n if ( sum < 0 ) \n sum = 0 ; \n else if ( sum > 60 ) \n sum = 60 ; \n sumsum = exp ( sum * 0.1151292546497 ) * gain ; \n for ( sum = 0 , x = 5 ; x -- ; ) { \n buffer [ x ] = codetable [ cb_coef ] [ x ] * sumsum ; \n sum += buffer [ x ] * buffer [ x ] ; \n } \n if ( ( sum /= 5 ) < 1 ) \n sum = 1 ; \n for ( x = 10 ; -- x ; glob -> lhist [ x ] = glob -> lhist [ x - 1 ] ) ; \n * glob -> lhist = glob -> history [ glob -> phase ] = 10 * log10 ( sum ) - 32 ; \n for ( x = 1 ; x < 5 ; x ++ ) \n for ( y = x ; y -- ; buffer [ x ] -= glob -> pr1 [ x - y - 1 ] * buffer [ y ] ) ; \n for ( x = 0 ; x < 5 ; x ++ ) { \n f = glob -> sb [ 4 - x ] + buffer [ x ] ; \n if ( f > 4095 ) \n f = 4095 ; \n else if ( f < -4095 ) \n f = -4095 ; \n glob -> output [ glob -> phasep + x ] = glob -> sb [ 4 - x ] = f ; \n } \n }", "idx": 10804}
{"project": "FFmpeg", "commit_id": "403ee835e7913eb9536b22c2b22edfdd700166a9", "target": 0, "func": "int url_open_dyn_packet_buf ( AVIOContext * * s , int max_packet_size ) \n { \n if ( max_packet_size <= 0 ) \n return -1 ; \n return url_open_dyn_buf_internal ( s , max_packet_size ) ; \n }", "idx": 10805}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int a64multi_close_encoder ( AVCodecContext * avctx ) \n { \n A64Context * c = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n av_free ( c -> mc_meta_charset ) ; \n av_free ( c -> mc_best_cb ) ; \n av_free ( c -> mc_charset ) ; \n av_free ( c -> mc_charmap ) ; \n av_free ( c -> mc_colram ) ; \n return 0 ; \n }", "idx": 10812}
{"project": "FFmpeg", "commit_id": "ef2b64f04c7269fe59dab0491784e06ade7892ca", "target": 1, "func": "int avcodec_close ( AVCodecContext * avctx ) \n { \n entangled_thread_counter ++ ; \n if ( entangled_thread_counter != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n entangled_thread_counter -- ; \n return -1 ; \n } \n if ( ENABLE_THREADS && avctx -> thread_opaque ) \n avcodec_thread_free ( avctx ) ; \n if ( avctx -> codec -> close ) \n avctx -> codec -> close ( avctx ) ; \n avcodec_default_free_buffers ( avctx ) ; \n av_freep ( & avctx -> priv_data ) ; \n avctx -> codec = NULL ; \n entangled_thread_counter -- ; \n return 0 ; \n }", "idx": 10817}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vp8_idct_add_c ( uint8_t * dst , DCTELEM block [ 16 ] , ptrdiff_t stride ) \n { \n int i , t0 , t1 , t2 , t3 ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n DCTELEM tmp [ 16 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t0 = block [ 0 * 4 + i ] + block [ 2 * 4 + i ] ; \n t1 = block [ 0 * 4 + i ] - block [ 2 * 4 + i ] ; \n t2 = MUL_35468 ( block [ 1 * 4 + i ] ) - MUL_20091 ( block [ 3 * 4 + i ] ) ; \n t3 = MUL_20091 ( block [ 1 * 4 + i ] ) + MUL_35468 ( block [ 3 * 4 + i ] ) ; \n block [ 0 * 4 + i ] = 0 ; \n block [ 1 * 4 + i ] = 0 ; \n block [ 2 * 4 + i ] = 0 ; \n block [ 3 * 4 + i ] = 0 ; \n tmp [ i * 4 + 0 ] = t0 + t3 ; \n tmp [ i * 4 + 1 ] = t1 + t2 ; \n tmp [ i * 4 + 2 ] = t1 - t2 ; \n tmp [ i * 4 + 3 ] = t0 - t3 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n t0 = tmp [ 0 * 4 + i ] + tmp [ 2 * 4 + i ] ; \n t1 = tmp [ 0 * 4 + i ] - tmp [ 2 * 4 + i ] ; \n t2 = MUL_35468 ( tmp [ 1 * 4 + i ] ) - MUL_20091 ( tmp [ 3 * 4 + i ] ) ; \n t3 = MUL_20091 ( tmp [ 1 * 4 + i ] ) + MUL_35468 ( tmp [ 3 * 4 + i ] ) ; \n dst [ 0 ] = cm [ dst [ 0 ] + ( ( t0 + t3 + 4 ) >> 3 ) ] ; \n dst [ 1 ] = cm [ dst [ 1 ] + ( ( t1 + t2 + 4 ) >> 3 ) ] ; \n dst [ 2 ] = cm [ dst [ 2 ] + ( ( t1 - t2 + 4 ) >> 3 ) ] ; \n dst [ 3 ] = cm [ dst [ 3 ] + ( ( t0 - t3 + 4 ) >> 3 ) ] ; \n dst += stride ; \n } \n }", "idx": 10819}
{"project": "FFmpeg", "commit_id": "a59505ca76718549dfc51b9622e2d88cb60f33b5", "target": 1, "func": "static inline int gsm_mult ( int a , int b ) \n { \n return ( a * b + ( 1 << 14 ) ) >> 15 ; \n }", "idx": 10827}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int tcp_read_packet ( AVFormatContext * s , RTSPStream * * prtsp_st , \n uint8_t * buf , int buf_size ) \n { \n RTSPState * rt = s -> priv_data ; \n int id , len , i , ret ; \n RTSPStream * rtsp_st ; \n #ifdef DEBUG_RTP_TCP \n dprintf ( s , \" \\n \" ) ; \n #endif \n redo : \n for ( ; ; ) { \n RTSPMessageHeader reply ; \n ret = rtsp_read_reply ( s , & reply , NULL , 1 ) ; \n if ( ret == -1 ) \n return -1 ; \n if ( ret == 1 ) \n break ; \n if ( rt -> state != RTSP_STATE_PLAYING ) \n return 0 ; \n } \n ret = url_read_complete ( rt -> rtsp_hd , buf , 3 ) ; \n if ( ret != 3 ) \n return -1 ; \n id = buf [ 0 ] ; \n len = AV_RB16 ( buf + 1 ) ; \n #ifdef DEBUG_RTP_TCP \n dprintf ( s , \" \\n \" , id , len ) ; \n #endif \n if ( len > buf_size || len < 12 ) \n goto redo ; \n ret = url_read_complete ( rt -> rtsp_hd , buf , len ) ; \n if ( ret != len ) \n return -1 ; \n if ( rt -> transport == RTSP_TRANSPORT_RDT && \n ff_rdt_parse_header ( buf , len , & id , NULL , NULL , NULL , NULL ) < 0 ) \n return -1 ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( id >= rtsp_st -> interleaved_min && \n id <= rtsp_st -> interleaved_max ) \n goto found ; \n } \n goto redo ; \n found : \n * prtsp_st = rtsp_st ; \n return len ; \n }", "idx": 10834}
{"project": "FFmpeg", "commit_id": "1ea3c03743ec6a7c33312896de3bbdbe7f60d0f5", "target": 1, "func": "static int read_ts ( const char * s , int64_t * start , int * duration ) \n { \n int64_t end ; \n int hh1 , mm1 , ss1 , ms1 ; \n int hh2 , mm2 , ss2 , ms2 ; \n if ( sscanf ( s , \" \" , \n & hh1 , & mm1 , & ss1 , & ms1 , & hh2 , & mm2 , & ss2 , & ms2 ) == 8 ) { \n end = ( hh2 * 3600 + mm2 * 60 + ss2 ) * 100 + ms2 ; \n * start = ( hh1 * 3600 + mm1 * 60 + ss1 ) * 100 + ms1 ; \n * duration = end - * start ; \n return 0 ; \n } \n return -1 ; \n }", "idx": 10837}
{"project": "FFmpeg", "commit_id": "a9d4a6ef3437d316450c2e30b9ed6a8fd4df4804", "target": 1, "func": "static int rm_read_header_old ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n RMContext * rm = s -> priv_data ; \n AVStream * st ; \n rm -> old_format = 1 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n goto fail ; \n rm_read_audio_stream_info ( s , st , 1 ) ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 10838}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static const uint8_t * pcx_rle_decode ( const uint8_t * src , uint8_t * dst , \n unsigned int bytes_per_scanline , int compressed ) { \n unsigned int i = 0 ; \n unsigned char run , value ; \n if ( compressed ) { \n while ( i < bytes_per_scanline ) { \n run = 1 ; \n value = * src ++ ; \n if ( value >= 0xc0 ) { \n run = value & 0x3f ; \n value = * src ++ ; \n } \n while ( i < bytes_per_scanline && run -- ) \n dst [ i ++ ] = value ; \n } \n } else { \n memcpy ( dst , src , bytes_per_scanline ) ; \n src += bytes_per_scanline ; \n } \n return src ; \n }", "idx": 10845}
{"project": "FFmpeg", "commit_id": "7a961a46ba28e49f88ff0e81b96395c96b424634", "target": 1, "func": "void register_avcodec ( AVCodec * codec ) \n { \n AVCodec * * p ; \n p = & first_avcodec ; \n while ( * p != NULL ) p = & ( * p ) -> next ; \n * p = codec ; \n codec -> next = NULL ; \n }", "idx": 10852}
{"project": "FFmpeg", "commit_id": "e6aed5f404a0983b2971c90e9022f6964a75de0b", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , \n uint8_t * buf , int buf_size , \n void * data ) \n { \n int tileno , ret ; \n J2kEncoderContext * s = avctx -> priv_data ; \n s -> buf = s -> buf_start = buf ; \n s -> buf_end = buf + buf_size ; \n s -> picture = data ; \n s -> lambda = s -> picture -> quality * LAMBDA_SCALE ; \n copy_frame ( s ) ; \n reinit ( s ) ; \n if ( s -> buf_end - s -> buf < 2 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , J2K_SOC ) ; \n if ( ret = put_siz ( s ) ) \n return ret ; \n if ( ret = put_cod ( s ) ) \n return ret ; \n if ( ret = put_qcd ( s , 0 ) ) \n return ret ; \n for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { \n uint8_t * psotptr ; \n if ( ( psotptr = put_sot ( s , tileno ) ) < 0 ) \n return psotptr ; \n if ( s -> buf_end - s -> buf < 2 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , J2K_SOD ) ; \n if ( ret = encode_tile ( s , s -> tile + tileno , tileno ) ) \n return ret ; \n bytestream_put_be32 ( & psotptr , s -> buf - psotptr + 6 ) ; \n } \n if ( s -> buf_end - s -> buf < 2 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , J2K_EOC ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return s -> buf - s -> buf_start ; \n }", "idx": 10859}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "int decode_luma_intra_block ( VC9Context * v , int mquant ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int dcdiff ; \n dcdiff = get_vlc2 ( gb , v -> luma_dc_vlc -> table , \n DC_VLC_BITS , 2 ) ; \n if ( dcdiff ) \n { \n if ( dcdiff == 119 \n ) \n { \n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ; \n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ; \n else dcdiff = get_bits ( gb , 8 ) ; \n } \n else \n { \n if ( mquant == 1 ) \n dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ; \n else if ( mquant == 2 ) \n dcdiff = ( dcdiff << 1 ) + get_bits ( gb , 1 ) - 1 ; \n } \n if ( get_bits ( gb , 1 ) ) \n dcdiff = - dcdiff ; \n } \n return 0 ; \n }", "idx": 10864}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_new_extradata ( void ) \n { \n PayloadContext * rdt = av_mallocz ( sizeof ( PayloadContext ) ) ; \n av_open_input_stream ( & rdt -> rmctx , NULL , \" \" , & rdt_demuxer , NULL ) ; \n return rdt ; \n }", "idx": 10891}
{"project": "FFmpeg", "commit_id": "5a3a906ba29b53fa34d3047af78d9f8fd7678256", "target": 1, "func": "static int vqa_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n VqaContext * s = avctx -> priv_data ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( s -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> frame ) ; \n if ( avctx -> get_buffer ( avctx , & s -> frame ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n vqa_decode_chunk ( s ) ; \n memcpy ( s -> frame . data [ 1 ] , s -> palette , PALETTE_COUNT * 4 ) ; \n s -> frame . palette_has_changed = 1 ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 10910}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "static av_cold int jpg_init ( AVCodecContext * avctx , JPGContext * c ) \n { \n int ret ; \n ret = build_vlc ( & c -> dc_vlc [ 0 ] , avpriv_mjpeg_bits_dc_luminance , \n avpriv_mjpeg_val_dc , 12 , 0 ) ; \n if ( ret ) \n return ret ; \n ret = build_vlc ( & c -> dc_vlc [ 1 ] , avpriv_mjpeg_bits_dc_chrominance , \n avpriv_mjpeg_val_dc , 12 , 0 ) ; \n if ( ret ) \n return ret ; \n ret = build_vlc ( & c -> ac_vlc [ 0 ] , avpriv_mjpeg_bits_ac_luminance , \n avpriv_mjpeg_val_ac_luminance , 251 , 1 ) ; \n if ( ret ) \n return ret ; \n ret = build_vlc ( & c -> ac_vlc [ 1 ] , avpriv_mjpeg_bits_ac_chrominance , \n avpriv_mjpeg_val_ac_chrominance , 251 , 1 ) ; \n if ( ret ) \n return ret ; \n ff_blockdsp_init ( & c -> bdsp , avctx ) ; \n ff_idctdsp_init ( & c -> idsp , avctx ) ; \n ff_init_scantable ( c -> idsp . idct_permutation , & c -> scantable , \n ff_zigzag_direct ) ; \n return 0 ; \n }", "idx": 10915}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int msvideo1_decode_init ( AVCodecContext * avctx ) \n { \n Msvideo1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( s -> avctx -> bits_per_coded_sample == 8 ) { \n s -> mode_8bit = 1 ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n } else { \n s -> mode_8bit = 0 ; \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 10917}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "static void avc_luma_hv_qrt_16w_msa ( const uint8_t * src_x , const uint8_t * src_y , \n int32_t src_stride , uint8_t * dst , \n int32_t dst_stride , int32_t height ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_hv_qrt_8w_msa ( src_x , src_y , src_stride , dst , dst_stride , \n height ) ; \n src_x += 8 ; \n src_y += 8 ; \n dst += 8 ; \n } \n }", "idx": 10918}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_luma_c ( uint8_t * pix , int stride , int alpha , int beta , int8_t * tc0 ) \n { \n h264_loop_filter_luma_c ( pix , 1 , stride , alpha , beta , tc0 ) ; \n }", "idx": 10996}
{"project": "FFmpeg", "commit_id": "6e8d4a7afbf40c0eb4bd70a6e7724d22ce7a6239", "target": 0, "func": "static av_cold int g726_decode_init ( AVCodecContext * avctx ) \n { \n G726Context * c = avctx -> priv_data ; \n if ( avctx -> sample_rate <= 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n c -> code_size = avctx -> bits_per_coded_sample ; \n if ( c -> code_size < 2 || c -> code_size > 5 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , c -> code_size ) ; \n return AVERROR ( EINVAL ) ; \n } \n g726_reset ( c , c -> code_size - 2 ) ; \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n return 0 ; \n }", "idx": 11000}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 768 ] ) ; \n samples [ i + 256 ] += ( samples [ i + 512 ] + samples [ i + 768 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 11020}
{"project": "FFmpeg", "commit_id": "4ce03a95e27d618a2c65b1ed134a72b48bbbff00", "target": 0, "func": "static int lmlm4_read_packet ( AVFormatContext * s , AVPacket * pkt ) { \n AVIOContext * pb = s -> pb ; \n int ret ; \n unsigned int frame_type , packet_size , padding , frame_size ; \n avio_rb16 ( pb ) ; \n frame_type = avio_rb16 ( pb ) ; \n packet_size = avio_rb32 ( pb ) ; \n padding = - packet_size & 511 ; \n frame_size = packet_size - 8 ; \n if ( frame_type > LMLM4_MPEG1L2 || frame_type == LMLM4_INVALID ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n } \n if ( packet_size > LMLM4_MAX_PACKET_SIZE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n } \n if ( ( ret = av_get_packet ( pb , pkt , frame_size ) ) <= 0 ) \n return AVERROR ( EIO ) ; \n avio_skip ( pb , padding ) ; \n switch ( frame_type ) { \n case LMLM4_I_FRAME : \n pkt -> flags = AV_PKT_FLAG_KEY ; \n case LMLM4_P_FRAME : \n case LMLM4_B_FRAME : \n pkt -> stream_index = 0 ; \n break ; \n case LMLM4_MPEG1L2 : \n pkt -> stream_index = 1 ; \n break ; \n } \n return ret ; \n }", "idx": 11021}
{"project": "FFmpeg", "commit_id": "91f4a44ff4fa55e0a48f71c432a1dc3158d662b9", "target": 0, "func": "static int packed_16bpc_bswap ( SwsContext * c , const uint8_t * src [ ] , \n int srcStride [ ] , int srcSliceY , int srcSliceH , \n uint8_t * dst [ ] , int dstStride [ ] ) \n { \n int i , j , p ; \n for ( p = 0 ; p < 4 ; p ++ ) { \n int srcstr = srcStride [ p ] >> 1 ; \n int dststr = dstStride [ p ] >> 1 ; \n uint16_t * dstPtr = ( uint16_t * ) dst [ p ] ; \n const uint16_t * srcPtr = ( const uint16_t * ) src [ p ] ; \n int min_stride = FFMIN ( srcstr , dststr ) ; \n if ( ! dstPtr || ! srcPtr ) \n continue ; \n for ( i = 0 ; i < ( srcSliceH >> c -> chrDstVSubSample ) ; i ++ ) { \n for ( j = 0 ; j < min_stride ; j ++ ) { \n dstPtr [ j ] = av_bswap16 ( srcPtr [ j ] ) ; \n } \n srcPtr += srcstr ; \n dstPtr += dststr ; \n } \n } \n return srcSliceH ; \n }", "idx": 11024}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "URLProtocol * ffurl_protocol_next ( const URLProtocol * prev ) \n { \n return prev ? prev -> next : first_protocol ; \n }", "idx": 11029}
{"project": "FFmpeg", "commit_id": "8de3458a07376b0a96772e586b6dba5e93432f52", "target": 0, "func": "static av_cold int nvenc_recalc_surfaces ( AVCodecContext * avctx ) \n { \n NvencContext * ctx = avctx -> priv_data ; \n int nb_surfaces = 0 ; \n if ( ctx -> rc_lookahead > 0 ) { \n nb_surfaces = ctx -> rc_lookahead + ( ( ctx -> encode_config . frameIntervalP > 0 ) ? ctx -> encode_config . frameIntervalP : 0 ) + 1 + 4 ; \n if ( ctx -> nb_surfaces < nb_surfaces ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \" \n \" \\n \" , ctx -> nb_surfaces , nb_surfaces ) ; \n ctx -> nb_surfaces = nb_surfaces ; \n } \n } \n ctx -> nb_surfaces = FFMAX ( 1 , FFMIN ( MAX_REGISTERED_FRAMES , ctx -> nb_surfaces ) ) ; \n ctx -> async_depth = FFMIN ( ctx -> async_depth , ctx -> nb_surfaces - 1 ) ; \n return 0 ; \n }", "idx": 11031}
{"project": "FFmpeg", "commit_id": "f0ff9eb49394d4ba06eff30e0dac2f3ce590e311", "target": 0, "func": "static void probe_codec ( AVFormatContext * s , AVStream * st , const AVPacket * pkt ) \n { \n if ( st -> codec -> codec_id == CODEC_ID_PROBE ) { \n AVProbeData * pd = & st -> probe_data ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index ) ; \n -- st -> probe_packets ; \n pd -> buf = av_realloc ( pd -> buf , pd -> buf_size + pkt -> size + AVPROBE_PADDING_SIZE ) ; \n memcpy ( pd -> buf + pd -> buf_size , pkt -> data , pkt -> size ) ; \n pd -> buf_size += pkt -> size ; \n memset ( pd -> buf + pd -> buf_size , 0 , AVPROBE_PADDING_SIZE ) ; \n if ( av_log2 ( pd -> buf_size ) != av_log2 ( pd -> buf_size - pkt -> size ) ) { \n set_codec_from_probe_data ( s , st , pd , st -> probe_packets > 0 ? AVPROBE_SCORE_MAX / 4 : 0 ) ; \n if ( st -> codec -> codec_id != CODEC_ID_PROBE ) { \n pd -> buf_size = 0 ; \n av_freep ( & pd -> buf ) ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , st -> index ) ; \n } \n } \n } \n }", "idx": 11033}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int * DEC_UPAIR ( int * dst , unsigned idx , unsigned sign ) \n { \n dst [ 0 ] = ( idx & 15 ) * ( 1 - ( sign & 0xFFFFFFFE ) ) ; \n dst [ 1 ] = ( idx >> 4 & 15 ) * ( 1 - ( ( sign & 1 ) << 1 ) ) ; \n return dst + 2 ; \n }", "idx": 11036}
{"project": "FFmpeg", "commit_id": "a625e13208ad0ebf1554aa73c9bf41452520f176", "target": 0, "func": "static void av_always_inline filter_mb_edgech ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 11037}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_horizontal ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 0 * stride ] ) ; \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 1 * stride ] ) ; \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 2 * stride ] ) ; \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( src [ -1 + 3 * stride ] ) ; \n }", "idx": 11050}
{"project": "FFmpeg", "commit_id": "f9d8658d67cfb478e5e36ce1d2795eabdb201bcb", "target": 1, "func": "static inline void horizX1Filter ( uint8_t * src , int stride , int QP ) \n { \n int y ; \n static uint64_t * lut = NULL ; \n if ( lut == NULL ) \n { \n int i ; \n lut = av_malloc ( 256 * 8 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) \n { \n int v = i < 128 ? 2 * i : 2 * ( i - 256 ) ; \n uint64_t a = ( v / 16 ) & 0xFF ; \n uint64_t b = ( v * 3 / 16 ) & 0xFF ; \n uint64_t c = ( v * 5 / 16 ) & 0xFF ; \n uint64_t d = ( 7 * v / 16 ) & 0xFF ; \n uint64_t A = ( 0x100 - a ) & 0xFF ; \n uint64_t B = ( 0x100 - b ) & 0xFF ; \n uint64_t C = ( 0x100 - c ) & 0xFF ; \n uint64_t D = ( 0x100 - c ) & 0xFF ; \n lut [ i ] = ( a << 56 ) | ( b << 48 ) | ( c << 40 ) | ( d << 32 ) | \n ( D << 24 ) | ( C << 16 ) | ( B << 8 ) | ( A ) ; \n } \n } \n for ( y = 0 ; y < BLOCK_SIZE ; y ++ ) { \n int a = src [ 1 ] - src [ 2 ] ; \n int b = src [ 3 ] - src [ 4 ] ; \n int c = src [ 5 ] - src [ 6 ] ; \n int d = FFMAX ( FFABS ( b ) - ( FFABS ( a ) + FFABS ( c ) ) / 2 , 0 ) ; \n if ( d < QP ) { \n int v = d * FFSIGN ( - b ) ; \n src [ 1 ] += v / 8 ; \n src [ 2 ] += v / 4 ; \n src [ 3 ] += 3 * v / 8 ; \n src [ 4 ] -= 3 * v / 8 ; \n src [ 5 ] -= v / 4 ; \n src [ 6 ] -= v / 8 ; \n } \n src += stride ; \n } \n }", "idx": 11052}
{"project": "FFmpeg", "commit_id": "85ff33948963257d418abe7d8975b4c9c4641223", "target": 0, "func": "AVCodecParserContext * av_parser_init ( int codec_id ) \n { \n AVCodecParserContext * s ; \n AVCodecParser * parser ; \n int ret ; \n if ( codec_id == CODEC_ID_NONE ) \n return NULL ; \n for ( parser = av_first_parser ; parser != NULL ; parser = parser -> next ) { \n if ( parser -> codec_ids [ 0 ] == codec_id || \n parser -> codec_ids [ 1 ] == codec_id || \n parser -> codec_ids [ 2 ] == codec_id || \n parser -> codec_ids [ 3 ] == codec_id || \n parser -> codec_ids [ 4 ] == codec_id ) \n goto found ; \n } \n return NULL ; \n found : \n s = av_mallocz ( sizeof ( AVCodecParserContext ) ) ; \n if ( ! s ) \n return NULL ; \n s -> parser = parser ; \n if ( parser -> priv_data_size ) { \n s -> priv_data = av_mallocz ( parser -> priv_data_size ) ; \n if ( ! s -> priv_data ) { \n av_free ( s ) ; \n return NULL ; \n } \n } \n if ( parser -> parser_init ) { \n ret = parser -> parser_init ( s ) ; \n if ( ret != 0 ) { \n av_free ( s -> priv_data ) ; \n av_free ( s ) ; \n return NULL ; \n } \n } \n s -> fetch_timestamp = 1 ; \n s -> pict_type = FF_I_TYPE ; \n s -> key_frame = -1 ; \n s -> convergence_duration = 0 ; \n s -> dts_sync_point = INT_MIN ; \n s -> dts_ref_dts_delta = INT_MIN ; \n s -> pts_dts_delta = INT_MIN ; \n return s ; \n }", "idx": 11053}
{"project": "FFmpeg", "commit_id": "933aa91e31d5cbf9dbc0cf416a988e6011bc4a40", "target": 1, "func": "static void cabac_init_decoder ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n skip_bits ( gb , 1 ) ; \n align_get_bits ( gb ) ; \n ff_init_cabac_decoder ( & s -> HEVClc -> cc , \n gb -> buffer + get_bits_count ( gb ) / 8 , \n ( get_bits_left ( gb ) + 7 ) / 8 ) ; \n }", "idx": 11059}
{"project": "FFmpeg", "commit_id": "0ccddbad200c1d9439c5a836501917d515cddf76", "target": 1, "func": "static int smacker_decode_bigtree ( BitstreamContext * bc , HuffContext * hc , \n DBCtx * ctx ) \n { \n if ( hc -> current + 1 >= hc -> length ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ! bitstream_read_bit ( bc ) ) { \n int val , i1 , i2 ; \n i1 = ctx -> v1 -> table ? bitstream_read_vlc ( bc , ctx -> v1 -> table , SMKTREE_BITS , 3 ) : 0 ; \n i2 = ctx -> v2 -> table ? bitstream_read_vlc ( bc , ctx -> v2 -> table , SMKTREE_BITS , 3 ) : 0 ; \n if ( i1 < 0 || i2 < 0 ) \n return AVERROR_INVALIDDATA ; \n val = ctx -> recode1 [ i1 ] | ( ctx -> recode2 [ i2 ] << 8 ) ; \n if ( val == ctx -> escapes [ 0 ] ) { \n ctx -> last [ 0 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 1 ] ) { \n ctx -> last [ 1 ] = hc -> current ; \n val = 0 ; \n } else if ( val == ctx -> escapes [ 2 ] ) { \n ctx -> last [ 2 ] = hc -> current ; \n val = 0 ; \n } \n hc -> values [ hc -> current ++ ] = val ; \n return 1 ; \n } else { \n int r = 0 , r_new , t ; \n t = hc -> current ++ ; \n r = smacker_decode_bigtree ( bc , hc , ctx ) ; \n if ( r < 0 ) \n return r ; \n hc -> values [ t ] = SMK_NODE | r ; \n r ++ ; \n r_new = smacker_decode_bigtree ( bc , hc , ctx ) ; \n if ( r_new < 0 ) \n return r_new ; \n return r + r_new ; \n } \n }", "idx": 11062}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int qtrle_encode_end ( AVCodecContext * avctx ) \n { \n QtrleEncContext * s = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n avpicture_free ( & s -> previous_frame ) ; \n av_free ( s -> rlecode_table ) ; \n av_free ( s -> length_table ) ; \n av_free ( s -> skip_table ) ; \n return 0 ; \n }", "idx": 11063}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pcx_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n return 0 ; \n }", "idx": 11064}
{"project": "FFmpeg", "commit_id": "1c088632e98af96f9cbe8129c5d7eb7274f8d4ed", "target": 0, "func": "static void hevc_parser_close ( AVCodecParserContext * s ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n int i ; \n #if ADVANCED_PARSER  \n  \n  HEVCContext * h = & ctx -> h ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> ps . vps_list ) ; i ++ ) \n av_buffer_unref ( & h -> ps . vps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> ps . sps_list ) ; i ++ ) \n av_buffer_unref ( & h -> ps . sps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> ps . pps_list ) ; i ++ ) \n av_buffer_unref ( & h -> ps . pps_list [ i ] ) ; \n h -> ps . sps = NULL ; \n av_freep ( & h -> HEVClc ) ; \n #endif \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ctx -> ps . vps_list ) ; i ++ ) \n av_buffer_unref ( & ctx -> ps . vps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ctx -> ps . sps_list ) ; i ++ ) \n av_buffer_unref ( & ctx -> ps . sps_list [ i ] ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( ctx -> ps . pps_list ) ; i ++ ) \n av_buffer_unref ( & ctx -> ps . pps_list [ i ] ) ; \n ctx -> ps . sps = NULL ; \n ff_h2645_packet_uninit ( & ctx -> pkt ) ; \n av_freep ( & ctx -> pc . buffer ) ; \n }", "idx": 11067}
{"project": "FFmpeg", "commit_id": "26c0cc154e06cb0064b3a3da49447ac44d82444f", "target": 1, "func": "static int mv_read_packet ( AVFormatContext * avctx , AVPacket * pkt ) \n { \n MvContext * mv = avctx -> priv_data ; \n AVIOContext * pb = avctx -> pb ; \n AVStream * st = avctx -> streams [ mv -> stream_index ] ; \n const AVIndexEntry * index ; \n int frame = mv -> frame [ mv -> stream_index ] ; \n int ret ; \n uint64_t pos ; \n if ( frame < st -> nb_index_entries ) { \n index = & st -> index_entries [ frame ] ; \n pos = avio_tell ( pb ) ; \n if ( index -> pos > pos ) \n avio_skip ( pb , index -> pos - pos ) ; \n else if ( index -> pos < pos ) { \n if ( ! pb -> seekable ) \n return AVERROR ( EIO ) ; \n ret = avio_seek ( pb , index -> pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ret = av_get_packet ( pb , pkt , index -> size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = mv -> stream_index ; \n pkt -> pts = index -> timestamp ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n mv -> frame [ mv -> stream_index ] ++ ; \n mv -> eof_count = 0 ; \n } else { \n mv -> eof_count ++ ; \n if ( mv -> eof_count >= avctx -> nb_streams ) \n return AVERROR_EOF ; \n return AVERROR ( EAGAIN ) ; \n } \n mv -> stream_index ++ ; \n if ( mv -> stream_index >= avctx -> nb_streams ) \n mv -> stream_index = 0 ; \n return 0 ; \n }", "idx": 11068}
{"project": "FFmpeg", "commit_id": "d9f4dc52a0fe3edb93f153cf13e750f7c46243d1", "target": 1, "func": "static av_cold int prores_encode_close ( AVCodecContext * avctx ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n av_freep ( & avctx -> coded_frame ) ; \n av_free ( ctx -> fill_y ) ; \n av_free ( ctx -> fill_u ) ; \n av_free ( ctx -> fill_v ) ; \n return 0 ; \n }", "idx": 11071}
{"project": "FFmpeg", "commit_id": "9487fb4dea3498eb4711eb023f43199f68701b1e", "target": 1, "func": "yuv2rgb_2_c_template ( SwsContext * c , const int16_t * buf [ 2 ] , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf [ 2 ] , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target , int hasAlpha )  \n { \n const int16_t * buf0 = buf [ 0 ] , * buf1 = buf [ 1 ] , \n * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] , \n * vbuf0 = vbuf [ 0 ] , * vbuf1 = vbuf [ 1 ] , \n * abuf0 = hasAlpha ? abuf [ 0 ] : NULL , \n * abuf1 = hasAlpha ? abuf [ 1 ] : NULL ; \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n int A1 , A2 ; \n const void * r = c -> table_rV [ V ] , \n * g = ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = c -> table_bU [ U ] ; \n if ( hasAlpha ) { \n A1 = ( abuf0 [ i * 2 ] * yalpha1 + abuf1 [ i * 2 ] * yalpha ) >> 19 ; \n A2 = ( abuf0 [ i * 2 + 1 ] * yalpha1 + abuf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n } \n yuv2rgb_write ( dest , i , Y1 , Y2 , hasAlpha ? A1 : 0 , hasAlpha ? A2 : 0 , \n r , g , b , y , target , hasAlpha ) ; \n } \n }", "idx": 11074}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void dequantization_int ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j , idx ; \n int32_t * datap = \n ( int32_t * ) & comp -> data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * y + x ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) \n for ( i = 0 ; i < ( cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ) ; ++ i ) { \n idx = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * j + i ; \n datap [ idx ] = \n ( ( int32_t ) ( t1 -> data [ j ] [ i ] ) * band -> i_stepsize + ( 1 << 15 ) ) >> 16 ; \n } \n }", "idx": 11077}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 ) \n { \n LOCAL_ALIGNED ( 32 , float , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , float , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_fmul ( cdst , v1 , v2 , LEN ) ; \n fdsp -> vector_fmul ( odst , v1 , v2 , LEN ) ; \n if ( ret = compare_floats ( cdst , odst , LEN , FLT_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 11085}
{"project": "FFmpeg", "commit_id": "40a7700b82aec0036622f8673ce64e070a520891", "target": 0, "func": "static int flac_write_block_comment ( AVIOContext * pb , AVDictionary * * m , \n int last_block , int bitexact ) \n { \n const char * vendor = bitexact ? \" \" : LIBAVFORMAT_IDENT ; \n unsigned int len ; \n uint8_t * p , * p0 ; \n ff_metadata_conv ( m , ff_vorbiscomment_metadata_conv , NULL ) ; \n len = ff_vorbiscomment_length ( * m , vendor ) ; \n p0 = av_malloc ( len + 4 ) ; \n if ( ! p0 ) \n return AVERROR ( ENOMEM ) ; \n p = p0 ; \n bytestream_put_byte ( & p , last_block ? 0x84 : 0x04 ) ; \n bytestream_put_be24 ( & p , len ) ; \n ff_vorbiscomment_write ( & p , m , vendor ) ; \n avio_write ( pb , p0 , len + 4 ) ; \n av_freep ( & p0 ) ; \n p = NULL ; \n return 0 ; \n }", "idx": 11088}
{"project": "FFmpeg", "commit_id": "559c244d42be7a02c23976216b47fd63b80d6c7f", "target": 1, "func": "static void qmf_32_subbands ( DCAContext * s , int chans , \n float samples_in [ 32 ] [ 8 ] , float * samples_out , \n float scale ) \n { \n const float * prCoeff ; \n int i ; \n int sb_act = s -> subband_activity [ chans ] ; \n int subindex ; \n scale *= sqrt ( 1 / 8.0 ) ; \n if ( ! s -> multirate_inter ) \n prCoeff = fir_32bands_nonperfect ; \n else \n prCoeff = fir_32bands_perfect ; \n for ( i = sb_act ; i < 32 ; i ++ ) \n s -> raXin [ i ] = 0.0 ; \n for ( subindex = 0 ; subindex < 8 ; subindex ++ ) { \n for ( i = 0 ; i < sb_act ; i ++ ) { \n uint32_t v = AV_RN32A ( & samples_in [ i ] [ subindex ] ) ^ ( ( i - 1 ) & 2 ) << 30 ; \n AV_WN32A ( & s -> raXin [ i ] , v ) ; \n } \n s -> synth . synth_filter_float ( & s -> imdct , \n s -> subband_fir_hist [ chans ] , & s -> hist_index [ chans ] , \n s -> subband_fir_noidea [ chans ] , prCoeff , \n samples_out , s -> raXin , scale ) ; \n samples_out += 32 ; \n } \n }", "idx": 11100}
{"project": "FFmpeg", "commit_id": "e7834d29f2a8f572a5bdf173d56b5a9b5af16043", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * inpicref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n SeparateFieldsContext * sf = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFrame * second ; \n int i , ret ; \n inpicref -> height = outlink -> h ; \n inpicref -> interlaced_frame = 0 ; \n second = av_frame_clone ( inpicref ) ; \n if ( ! second ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < sf -> nb_planes ; i ++ ) { \n if ( ! inpicref -> top_field_first ) \n inpicref -> data [ i ] = inpicref -> data [ i ] + inpicref -> linesize [ i ] ; \n else \n second -> data [ i ] = second -> data [ i ] + second -> linesize [ i ] ; \n inpicref -> linesize [ i ] *= 2 ; \n second -> linesize [ i ] *= 2 ; \n } \n inpicref -> pts = outlink -> frame_count * sf -> ts_unit ; \n ret = ff_filter_frame ( outlink , inpicref ) ; \n if ( ret < 0 ) \n return ret ; \n second -> pts = outlink -> frame_count * sf -> ts_unit ; \n return ff_filter_frame ( outlink , second ) ; \n }", "idx": 11101}
{"project": "FFmpeg", "commit_id": "a8f171151f0f027abb06f72e48c44929616a84cb", "target": 0, "func": "static int file_write ( URLContext * h , const unsigned char * buf , int size ) \n { \n FileContext * c = h -> priv_data ; \n int r = write ( c -> fd , buf , size ) ; \n return ( -1 == r ) ? AVERROR ( errno ) : r ; \n }", "idx": 11103}
{"project": "FFmpeg", "commit_id": "3b6c5ad2f67cc8eeeec89fb9d497ec79c1f3948a", "target": 0, "func": "static void calc_transform_coeffs_cpl ( AC3DecodeContext * s ) \n { \n int bin , band , ch , band_end ; \n bin = s -> start_freq [ CPL_CH ] ; \n for ( band = 0 ; band < s -> num_cpl_bands ; band ++ ) { \n band_end = bin + s -> cpl_band_sizes [ band ] ; \n for ( ; bin < band_end ; bin ++ ) { \n for ( ch = 1 ; ch <= s -> fbw_channels ; ch ++ ) { \n if ( s -> channel_in_cpl [ ch ] ) { \n s -> fixed_coeffs [ ch ] [ bin ] = ( ( int64_t ) s -> fixed_coeffs [ CPL_CH ] [ bin ] * \n ( int64_t ) s -> cpl_coords [ ch ] [ band ] ) >> 23 ; \n if ( ch == 2 && s -> phase_flags [ band ] ) \n s -> fixed_coeffs [ ch ] [ bin ] = - s -> fixed_coeffs [ ch ] [ bin ] ; \n } \n } \n } \n } \n }", "idx": 11104}
{"project": "FFmpeg", "commit_id": "f41e37b84f3d57c29d4a2a21f9337159135b981d", "target": 0, "func": "int ff_dirac_golomb_read_16bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int16_t * dst = ( int16_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res ) ; \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n SET_RESIDUE ( res , 0 , 0 ) ; \n } \n for ( i = 0 ; i < LUT_BITS ; i ++ ) \n dst [ c_idx + i ] = l -> ready [ i ] ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 11105}
{"project": "FFmpeg", "commit_id": "494bce6224c7da6a174fb16a49ed26e5aab32af1", "target": 1, "func": "static int init_ralf_vlc ( VLC * vlc , const uint8_t * data , int elems ) \n { \n uint8_t lens [ MAX_ELEMS ] ; \n uint16_t codes [ MAX_ELEMS ] ; \n int counts [ 17 ] , prefixes [ 18 ] ; \n int i , cur_len ; \n int max_bits = 0 ; \n GetBitContext gb ; \n init_get_bits ( & gb , data , elems * 4 ) ; \n for ( i = 0 ; i <= 16 ; i ++ ) \n counts [ i ] = 0 ; \n for ( i = 0 ; i < elems ; i ++ ) { \n cur_len = get_bits ( & gb , 4 ) + 1 ; \n counts [ cur_len ] ++ ; \n max_bits = FFMAX ( max_bits , cur_len ) ; \n lens [ i ] = cur_len ; \n } \n prefixes [ 1 ] = 0 ; \n for ( i = 1 ; i <= 16 ; i ++ ) \n prefixes [ i + 1 ] = ( prefixes [ i ] + counts [ i ] ) << 1 ; \n for ( i = 0 ; i < elems ; i ++ ) \n codes [ i ] = prefixes [ lens [ i ] ] ++ ; \n return ff_init_vlc_sparse ( vlc , FFMIN ( max_bits , 9 ) , elems , \n lens , 1 , 1 , codes , 2 , 2 , NULL , 0 , 0 , 0 ) ; \n }", "idx": 11110}
{"project": "FFmpeg", "commit_id": "0bb5ad7a06ebcda9102357f8755d18b63f56aa29", "target": 1, "func": "static inline void asv2_put_level ( PutBitContext * pb , int level ) \n { \n unsigned int index = level + 31 ; \n if ( index <= 62 ) { \n put_bits ( pb , ff_asv2_level_tab [ index ] [ 1 ] , ff_asv2_level_tab [ index ] [ 0 ] ) ; \n } else { \n put_bits ( pb , ff_asv2_level_tab [ 31 ] [ 1 ] , ff_asv2_level_tab [ 31 ] [ 0 ] ) ; \n asv2_put_bits ( pb , 8 , level & 0xFF ) ; \n } \n }", "idx": 11116}
{"project": "FFmpeg", "commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "target": 1, "func": "static int subtitle_thread ( void * arg ) \n { \n VideoState * is = arg ; \n Frame * sp ; \n int got_subtitle ; \n double pts ; \n int i , j ; \n int r , g , b , y , u , v , a ; \n for ( ; ; ) { \n while ( is -> paused && ! is -> subtitleq . abort_request ) { \n SDL_Delay ( 10 ) ; \n } \n if ( ! ( sp = frame_queue_peek_writable ( & is -> subpq ) ) ) \n return 0 ; \n if ( ( got_subtitle = decoder_decode_frame ( & is -> subdec , & sp -> sub ) ) < 0 ) \n break ; \n pts = 0 ; \n if ( got_subtitle && sp -> sub . format == 0 ) { \n if ( sp -> sub . pts != AV_NOPTS_VALUE ) \n pts = sp -> sub . pts / ( double ) AV_TIME_BASE ; \n sp -> pts = pts ; \n sp -> serial = is -> subdec . pkt_serial ; \n for ( i = 0 ; i < sp -> sub . num_rects ; i ++ ) \n { \n for ( j = 0 ; j < sp -> sub . rects [ i ] -> nb_colors ; j ++ ) \n { \n RGBA_IN ( r , g , b , a , ( uint32_t * ) sp -> sub . rects [ i ] -> pict . data [ 1 ] + j ) ; \n y = RGB_TO_Y_CCIR ( r , g , b ) ; \n u = RGB_TO_U_CCIR ( r , g , b , 0 ) ; \n v = RGB_TO_V_CCIR ( r , g , b , 0 ) ; \n YUVA_OUT ( ( uint32_t * ) sp -> sub . rects [ i ] -> pict . data [ 1 ] + j , y , u , v , a ) ; \n } \n } \n frame_queue_push ( & is -> subpq ) ; \n } else if ( got_subtitle ) { \n avsubtitle_free ( & sp -> sub ) ; \n } \n } \n return 0 ; \n }", "idx": 11119}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static const HWAccel * get_hwaccel ( enum AVPixelFormat pix_fmt , enum HWAccelID selected_hwaccel_id ) \n { \n int i ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) \n if ( hwaccels [ i ] . pix_fmt == pix_fmt && \n ( ! selected_hwaccel_id || selected_hwaccel_id == HWACCEL_AUTO || hwaccels [ i ] . id == selected_hwaccel_id ) ) \n return & hwaccels [ i ] ; \n return NULL ; \n }", "idx": 11156}
{"project": "FFmpeg", "commit_id": "92a26261d1ccc02c4fbdae2031e279009804c159", "target": 0, "func": "static int rsd_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n int ret , size = 1024 ; \n if ( avio_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n if ( codec -> codec_id == AV_CODEC_ID_ADPCM_IMA_RAD || \n codec -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { \n ret = av_get_packet ( s -> pb , pkt , codec -> block_align ) ; \n } else if ( codec -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && \n codec -> channels > 1 ) { \n int i , ch ; \n av_new_packet ( pkt , codec -> block_align ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n for ( ch = 0 ; ch < codec -> channels ; ch ++ ) { \n pkt -> data [ ch * 8 + i * 2 + 0 ] = avio_r8 ( s -> pb ) ; \n pkt -> data [ ch * 8 + i * 2 + 1 ] = avio_r8 ( s -> pb ) ; \n } \n } \n ret = 0 ; \n } else { \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n } \n pkt -> stream_index = 0 ; \n return ret ; \n }", "idx": 11159}
{"project": "FFmpeg", "commit_id": "3b55429d5692dd782d8b3ce6a19819305157d1b8", "target": 1, "func": "void av_fast_malloc ( void * ptr , unsigned int * size , size_t min_size ) \n { \n void * * p = ptr ; \n if ( min_size < * size ) \n return ; \n min_size = FFMAX ( 17 * min_size / 16 + 32 , min_size ) ; \n av_free ( * p ) ; \n * p = av_malloc ( min_size ) ; \n if ( ! * p ) min_size = 0 ; \n * size = min_size ; \n }", "idx": 11162}
{"project": "FFmpeg", "commit_id": "7f4ec4364bc4a73036660c1c6a3c4801db524e9e", "target": 0, "func": "static int mov_read_dec3 ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n enum AVAudioServiceType * ast ; \n int eac3info , acmod , lfeon , bsmod ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n ast = ( enum AVAudioServiceType * ) ff_stream_new_side_data ( st , AV_PKT_DATA_AUDIO_SERVICE_TYPE , \n sizeof ( * ast ) ) ; \n if ( ! ast ) \n return AVERROR ( ENOMEM ) ; \n avio_rb16 ( pb ) ; \n eac3info = avio_rb24 ( pb ) ; \n bsmod = ( eac3info >> 12 ) & 0x1f ; \n acmod = ( eac3info >> 9 ) & 0x7 ; \n lfeon = ( eac3info >> 8 ) & 0x1 ; \n st -> codec -> channel_layout = avpriv_ac3_channel_layout_tab [ acmod ] ; \n if ( lfeon ) \n st -> codec -> channel_layout |= AV_CH_LOW_FREQUENCY ; \n st -> codec -> channels = av_get_channel_layout_nb_channels ( st -> codec -> channel_layout ) ; \n * ast = bsmod ; \n if ( st -> codec -> channels > 1 && bsmod == 0x7 ) \n * ast = AV_AUDIO_SERVICE_TYPE_KARAOKE ; \n st -> codec -> audio_service_type = * ast ; \n return 0 ; \n }", "idx": 11183}
{"project": "FFmpeg", "commit_id": "66c1c9b2774968dc26017269ac175b356592f878", "target": 1, "func": "void ff_xface_generate_face ( uint8_t * dst , uint8_t * const src ) \n { \n int h , i , j , k , l , m ; \n for ( j = 0 ; j < XFACE_HEIGHT ; j ++ ) { \n for ( i = 0 ; i < XFACE_WIDTH ; i ++ ) { \n h = i + j * XFACE_WIDTH ; \n k = 0 ; \n for ( l = i - 2 ; l <= i + 2 ; l ++ ) { \n for ( m = j - 2 ; m <= j ; m ++ ) { \n if ( l >= i && m == j ) \n continue ; \n if ( l > 0 && l <= XFACE_WIDTH && m > 0 ) \n k = 2 * k + src [ l + m * XFACE_WIDTH ] ; \n } \n } \n #define GEN ( table )  dst[h] ^= (table[k>>3]>>(7-(k&7)))&1  \n  \n  \n  \n  switch ( i ) { \n case 1 : \n switch ( j ) { \n case 1 : GEN ( g_22 ) ; break ; \n case 2 : GEN ( g_21 ) ; break ; \n default : GEN ( g_20 ) ; break ; \n } \n break ; \n case 2 : \n switch ( j ) { \n case 1 : GEN ( g_12 ) ; break ; \n case 2 : GEN ( g_11 ) ; break ; \n default : GEN ( g_10 ) ; break ; \n } \n break ; \n case XFACE_WIDTH - 1 : \n switch ( j ) { \n case 1 : GEN ( g_42 ) ; break ; \n case 2 : GEN ( g_41 ) ; break ; \n default : GEN ( g_40 ) ; break ; \n } \n break ; \n case XFACE_WIDTH : \n switch ( j ) { \n case 1 : GEN ( g_32 ) ; break ; \n case 2 : GEN ( g_31 ) ; break ; \n default : GEN ( g_30 ) ; break ; \n } \n break ; \n default : \n switch ( j ) { \n case 1 : GEN ( g_02 ) ; break ; \n case 2 : GEN ( g_01 ) ; break ; \n default : GEN ( g_00 ) ; break ; \n } \n break ; \n } \n } \n } \n }", "idx": 11198}
{"project": "FFmpeg", "commit_id": "0b940c95b2171cb1035c79b85492f5f6cdb060a6", "target": 1, "func": "static av_cold int decimate_init ( AVFilterContext * ctx ) \n { \n DecimateContext * dm = ctx -> priv ; \n AVFilterPad pad = { \n . name = av_strdup ( \" \" ) , \n . type = AVMEDIA_TYPE_VIDEO , \n . filter_frame = filter_frame , \n . config_props = config_input , \n } ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_inpad ( ctx , INPUT_MAIN , & pad ) ; \n if ( dm -> ppsrc ) { \n pad . name = av_strdup ( \" \" ) ; \n pad . config_props = NULL ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_inpad ( ctx , INPUT_CLEANSRC , & pad ) ; \n } \n if ( ( dm -> blockx & ( dm -> blockx - 1 ) ) || \n ( dm -> blocky & ( dm -> blocky - 1 ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n dm -> start_pts = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 11200}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_qcc ( J2kDecoderContext * s , int n , J2kQuantStyle * q , uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n properties [ compno ] |= HAD_QCC ; \n return get_qcx ( s , n - 1 , q + compno ) ; \n }", "idx": 11201}
{"project": "FFmpeg", "commit_id": "0372e73f917e72c40b09270f771046fc142be4a7", "target": 0, "func": "av_cold void ff_intrax8_common_init ( IntraX8Context * w , MpegEncContext * const s ) \n { \n w -> s = s ; \n x8_vlc_init ( ) ; \n assert ( s -> mb_width > 0 ) ; \n w -> prediction_table = av_mallocz ( s -> mb_width * 2 * 2 ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> scantable [ 0 ] , \n ff_wmv1_scantable [ 0 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> scantable [ 1 ] , \n ff_wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> scantable [ 2 ] , \n ff_wmv1_scantable [ 3 ] ) ; \n ff_intrax8dsp_init ( & w -> dsp ) ; \n }", "idx": 11205}
{"project": "FFmpeg", "commit_id": "143685a42bbc8861b626457ce4cb8b1ce4b0c436", "target": 0, "func": "static av_cold int ffat_close_encoder ( AVCodecContext * avctx ) \n { \n ATDecodeContext * at = avctx -> priv_data ; \n AudioConverterDispose ( at -> converter ) ; \n av_frame_unref ( & at -> new_in_frame ) ; \n av_frame_unref ( & at -> in_frame ) ; \n ff_af_queue_close ( & at -> afq ) ; \n return 0 ; \n }", "idx": 11206}
{"project": "FFmpeg", "commit_id": "e55376a1fd5abebbb0a082aa20739d58c2260a37", "target": 1, "func": "static int append_flv_data ( RTMPContext * rt , RTMPPacket * pkt , int skip ) \n { \n int old_flv_size , ret ; \n PutByteContext pbc ; \n const uint8_t * data = pkt -> data + skip ; \n const int size = pkt -> size - skip ; \n uint32_t ts = pkt -> timestamp ; \n if ( pkt -> type == RTMP_PT_AUDIO ) { \n rt -> has_audio = 1 ; \n } else if ( pkt -> type == RTMP_PT_VIDEO ) { \n rt -> has_video = 1 ; \n } \n old_flv_size = update_offset ( rt , size + 15 ) ; \n if ( ( ret = av_reallocp ( & rt -> flv_data , rt -> flv_size ) ) < 0 ) { \n rt -> flv_size = rt -> flv_off = 0 ; \n return ret ; \n } \n bytestream2_init_writer ( & pbc , rt -> flv_data , rt -> flv_size ) ; \n bytestream2_skip_p ( & pbc , old_flv_size ) ; \n bytestream2_put_byte ( & pbc , pkt -> type ) ; \n bytestream2_put_be24 ( & pbc , size ) ; \n bytestream2_put_be24 ( & pbc , ts ) ; \n bytestream2_put_byte ( & pbc , ts >> 24 ) ; \n bytestream2_put_be24 ( & pbc , 0 ) ; \n bytestream2_put_buffer ( & pbc , data , size ) ; \n bytestream2_put_be32 ( & pbc , 0 ) ; \n return 0 ; \n }", "idx": 11210}
{"project": "FFmpeg", "commit_id": "9ea242962c4093a5523deef124a98193bbb36730", "target": 1, "func": "Jpeg2000TgtNode * ff_j2k_tag_tree_init ( int w , int h ) \n { \n int pw = w , ph = h ; \n Jpeg2000TgtNode * res , * t , * t2 ; \n int32_t tt_size ; \n tt_size = tag_tree_size ( w , h ) ; \n t = res = av_mallocz ( tt_size , sizeof ( * t ) ) ; \n if ( ! res ) \n return NULL ; \n while ( w > 1 || h > 1 ) { \n int i , j ; \n pw = w ; \n ph = h ; \n w = ( w + 1 ) >> 1 ; \n h = ( h + 1 ) >> 1 ; \n t2 = t + pw * ph ; \n for ( i = 0 ; i < ph ; i ++ ) \n for ( j = 0 ; j < pw ; j ++ ) \n t [ i * pw + j ] . parent = & t2 [ ( i >> 1 ) * w + ( j >> 1 ) ] ; \n t = t2 ; \n } \n t [ 0 ] . parent = NULL ; \n return res ; \n }", "idx": 11222}
{"project": "FFmpeg", "commit_id": "d98364edcedb71662cb1761bd30d67053d60a3c6", "target": 1, "func": "static int smush_read_packet ( AVFormatContext * ctx , AVPacket * pkt ) \n { \n SMUSHContext * smush = ctx -> priv_data ; \n AVIOContext * pb = ctx -> pb ; \n int done = 0 ; \n while ( ! done ) { \n uint32_t sig , size ; \n if ( url_feof ( pb ) ) \n return AVERROR_EOF ; \n sig = avio_rb32 ( pb ) ; \n size = avio_rb32 ( pb ) ; \n switch ( sig ) { \n case MKBETAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( smush -> version ) \n break ; \n if ( av_get_packet ( pb , pkt , size ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = smush -> video_stream_index ; \n done = 1 ; \n break ; \n case MKBETAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( av_get_packet ( pb , pkt , size ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = smush -> video_stream_index ; \n pkt -> duration = 1 ; \n done = 1 ; \n break ; \n case MKBETAG ( ' ' , ' ' , ' ' , ' ' ) : \n if ( size < 13 ) \n return AVERROR_INVALIDDATA ; \n if ( av_get_packet ( pb , pkt , size ) < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = smush -> audio_stream_index ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> duration = AV_RB32 ( pkt -> data ) ; \n if ( pkt -> duration == 0xFFFFFFFFu ) \n pkt -> duration = AV_RB32 ( pkt -> data + 8 ) ; \n done = 1 ; \n break ; \n default : \n avio_skip ( pb , size ) ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 11224}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_dualmono_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float tmp ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n tmp = output [ 1 ] [ i ] + output [ 2 ] [ i ] ; \n output [ 1 ] [ i ] = output [ 2 ] [ i ] = tmp ; \n } \n }", "idx": 11225}
{"project": "FFmpeg", "commit_id": "143685a42bbc8861b626457ce4cb8b1ce4b0c436", "target": 0, "func": "static OSStatus ffat_encode_callback ( AudioConverterRef converter , UInt32 * nb_packets , \n AudioBufferList * data , \n AudioStreamPacketDescription * * packets , \n void * inctx ) \n { \n AVCodecContext * avctx = inctx ; \n ATDecodeContext * at = avctx -> priv_data ; \n if ( at -> eof ) { \n * nb_packets = 0 ; \n return 0 ; \n } \n av_frame_unref ( & at -> in_frame ) ; \n av_frame_move_ref ( & at -> in_frame , & at -> new_in_frame ) ; \n if ( ! at -> in_frame . data [ 0 ] ) { \n * nb_packets = 0 ; \n return 1 ; \n } \n data -> mNumberBuffers = 1 ; \n data -> mBuffers [ 0 ] . mNumberChannels = avctx -> channels ; \n data -> mBuffers [ 0 ] . mDataByteSize = at -> in_frame . nb_samples * \n av_get_bytes_per_sample ( avctx -> sample_fmt ) * \n avctx -> channels ; \n data -> mBuffers [ 0 ] . mData = at -> in_frame . data [ 0 ] ; \n if ( * nb_packets > at -> in_frame . nb_samples ) \n * nb_packets = at -> in_frame . nb_samples ; \n return 0 ; \n }", "idx": 11226}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb16tobgr16 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x3F ) << 5 ) | ( ( r & 0x1F ) << 11 ) ; \n } \n }", "idx": 11227}
{"project": "FFmpeg", "commit_id": "c6a905b91d935f78f5c33f6ce2dbe294b3353b77", "target": 1, "func": "static av_cold int dnxhd_decode_init ( AVCodecContext * avctx ) \n { \n DNXHDContext * ctx = avctx -> priv_data ; \n ctx -> avctx = avctx ; \n ctx -> cid = -1 ; \n avctx -> colorspace = AVCOL_SPC_BT709 ; \n avctx -> coded_width = FFALIGN ( avctx -> width , 16 ) ; \n avctx -> coded_height = FFALIGN ( avctx -> height , 16 ) ; \n ctx -> rows = av_mallocz_array ( avctx -> thread_count , sizeof ( RowContext ) ) ; \n if ( ! ctx -> rows ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 11237}
{"project": "FFmpeg", "commit_id": "1e3f77b53a803a6c63fa64829f1be557b8226288", "target": 1, "func": "static void RENAME ( uyvytoyuv422 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n int width , int height , \n int lumStride , int chromStride , int srcStride ) \n { \n int y ; \n const int chromWidth = FF_CEIL_RSHIFT ( width , 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src + 1 , ydst , width ) ; \n RENAME ( extract_even2 ) ( src , udst , vdst , chromWidth ) ; \n src += srcStride ; \n ydst += lumStride ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n }", "idx": 11240}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void ape_unpack_mono ( APEContext * ctx , int count ) \n { \n if ( ctx -> frameflags & APE_FRAMECODE_STEREO_SILENCE ) { \n av_log ( ctx -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return ; \n } \n entropy_decode ( ctx , count , 0 ) ; \n ape_apply_filters ( ctx , ctx -> decoded [ 0 ] , NULL , count ) ; \n predictor_decode_mono ( ctx , count ) ; \n if ( ctx -> channels == 2 ) { \n memcpy ( ctx -> decoded [ 1 ] , ctx -> decoded [ 0 ] , count * sizeof ( * ctx -> decoded [ 1 ] ) ) ; \n } \n }", "idx": 11250}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( rgb32tobgr32 ) ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" \" REG_a \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n PREFETCH \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \"  MANGLE ( mask32r )  \" \\n \\t \" \n \" \"  MANGLE ( mask32g )  \" \\n \\t \" \n \" \"  MANGLE ( mask32b )  \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n :: \" r \" ( src ) , \" \" ( dst ) , \" \" ( ( long ) src_size - 7 ) \n : \" % \" \n ) ; \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #else \n unsigned i ; \n unsigned num_pixels = src_size >> 2 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 4 * i + 1 ] = src [ 4 * i + 3 ] ; \n dst [ 4 * i + 2 ] = src [ 4 * i + 2 ] ; \n dst [ 4 * i + 3 ] = src [ 4 * i + 1 ] ; \n #else \n dst [ 4 * i + 0 ] = src [ 4 * i + 2 ] ; \n dst [ 4 * i + 1 ] = src [ 4 * i + 1 ] ; \n dst [ 4 * i + 2 ] = src [ 4 * i + 0 ] ; \n #endif \n } \n #endif \n }", "idx": 11256}
{"project": "FFmpeg", "commit_id": "125cf771f6d17b9b9db7588cbf8f36619bc41f35", "target": 0, "func": "static int read_channel_params ( MLPDecodeContext * m , unsigned int substr , \n GetBitContext * gbp , unsigned int ch ) \n { \n ChannelParams * cp = & m -> channel_params [ ch ] ; \n FilterParams * fir = & cp -> filter_params [ FIR ] ; \n FilterParams * iir = & cp -> filter_params [ IIR ] ; \n SubStream * s = & m -> substream [ substr ] ; \n if ( s -> param_presence_flags & PARAM_FIR ) \n if ( get_bits1 ( gbp ) ) \n if ( read_filter_params ( m , gbp , ch , FIR ) < 0 ) \n return -1 ; \n if ( s -> param_presence_flags & PARAM_IIR ) \n if ( get_bits1 ( gbp ) ) \n if ( read_filter_params ( m , gbp , ch , IIR ) < 0 ) \n return -1 ; \n if ( fir -> order && iir -> order && \n fir -> shift != iir -> shift ) { \n av_log ( m -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n if ( ! fir -> order && iir -> order ) \n fir -> shift = iir -> shift ; \n if ( s -> param_presence_flags & PARAM_HUFFOFFSET ) \n if ( get_bits1 ( gbp ) ) \n cp -> huff_offset = get_sbits ( gbp , 15 ) ; \n cp -> codebook = get_bits ( gbp , 2 ) ; \n cp -> huff_lsbs = get_bits ( gbp , 5 ) ; \n cp -> sign_huff_offset = calculate_sign_huff ( m , substr , ch ) ; \n return 0 ; \n }", "idx": 11279}
{"project": "FFmpeg", "commit_id": "7e4111cfe2f5d03af8d608757e897145aa252af8", "target": 0, "func": "static int64_t rm_read_dts ( AVFormatContext * s , int stream_index , \n int64_t * ppos , int64_t pos_limit ) \n { \n RMDemuxContext * rm = s -> priv_data ; \n int64_t pos , dts ; \n int stream_index2 , flags , len , h ; \n pos = * ppos ; \n if ( rm -> old_format ) \n return AV_NOPTS_VALUE ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n rm -> remaining_len = 0 ; \n for ( ; ; ) { \n int seq = 1 ; \n AVStream * st ; \n len = sync ( s , & dts , & flags , & stream_index2 , & pos ) ; \n if ( len < 0 ) \n return AV_NOPTS_VALUE ; \n st = s -> streams [ stream_index2 ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n h = avio_r8 ( s -> pb ) ; len -- ; \n if ( ! ( h & 0x40 ) ) { \n seq = avio_r8 ( s -> pb ) ; len -- ; \n } \n } \n if ( ( flags & 2 ) && ( seq & 0x7F ) == 1 ) { \n av_add_index_entry ( st , pos , dts , 0 , 0 , AVINDEX_KEYFRAME ) ; \n if ( stream_index2 == stream_index ) \n break ; \n } \n avio_skip ( s -> pb , len ) ; \n } \n * ppos = pos ; \n return dts ; \n }", "idx": 11280}
{"project": "FFmpeg", "commit_id": "09f59d6adfa19d1ad5049416c1d0fbc996f509fd", "target": 0, "func": "static int gif_image_write_header ( AVIOContext * pb , int width , int height , \n int loop_count , uint32_t * palette ) \n { \n int i ; \n avio_write ( pb , \" \" , 3 ) ; \n avio_write ( pb , \" \" , 3 ) ; \n avio_wl16 ( pb , width ) ; \n avio_wl16 ( pb , height ) ; \n if ( palette ) { \n avio_w8 ( pb , 0xf7 ) ; \n avio_w8 ( pb , 0x1f ) ; \n avio_w8 ( pb , 0 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n const uint32_t v = palette [ i ] & 0xffffff ; \n avio_wb24 ( pb , v ) ; \n } \n } else { \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n avio_w8 ( pb , 0 ) ; \n } \n avio_w8 ( pb , 0x21 ) ; \n avio_w8 ( pb , 0xff ) ; \n avio_w8 ( pb , 0x0b ) ; \n avio_write ( pb , \" \" , sizeof ( \" \" ) - 1 ) ; \n avio_w8 ( pb , 0x03 ) ; \n avio_w8 ( pb , 0x01 ) ; \n avio_wl16 ( pb , ( uint16_t ) loop_count ) ; \n avio_w8 ( pb , 0x00 ) ; \n return 0 ; \n }", "idx": 11281}
{"project": "FFmpeg", "commit_id": "ffc58b2ce27e140b47900d1ead304663f7b385ae", "target": 1, "func": "static int check_pkt ( AVFormatContext * s , AVPacket * pkt ) \n { \n MOVMuxContext * mov = s -> priv_data ; \n MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; \n int64_t ref ; \n uint64_t duration ; \n if ( trk -> entry ) { \n ref = trk -> cluster [ trk -> entry - 1 ] . dts ; \n } else if ( trk -> start_dts != AV_NOPTS_VALUE \n && ! trk -> frag_discont ) { \n ref = trk -> start_dts + trk -> track_duration ; \n } else \n ref = pkt -> dts ; \n duration = pkt -> dts - ref ; \n if ( pkt -> dts < ref || duration >= INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \" PRId64 \" \\n \" , \n duration , pkt -> dts \n ) ; \n pkt -> dts = ref + 1 ; \n pkt -> pts = AV_NOPTS_VALUE ; \n if ( pkt -> duration < 0 || pkt -> duration > INT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , pkt -> duration ) ; \n return AVERROR ( EINVAL ) ; \n return 0 ;", "idx": 11283}
{"project": "FFmpeg", "commit_id": "2c00b373024054e0779ef67fc54b763d624db3e8", "target": 1, "func": "int av_packet_unpack_dictionary ( const uint8_t * data , int size , AVDictionary * * dict ) \n { \n const uint8_t * end = data + size ; \n int ret = 0 ; \n if ( ! dict || ! data || ! size ) \n return ret ; \n if ( size && end [ -1 ] ) \n return AVERROR_INVALIDDATA ; \n while ( data < end ) { \n const uint8_t * key = data ; \n const uint8_t * val = data + strlen ( key ) + 1 ; \n if ( val >= end ) \n return AVERROR_INVALIDDATA ; \n ret = av_dict_set ( dict , key , val , 0 ) ; \n if ( ret < 0 ) \n break ; \n data = val + strlen ( val ) + 1 ; \n } \n return ret ; \n }", "idx": 11285}
{"project": "FFmpeg", "commit_id": "1f95fb58137951941d8d74bd47b1635b6d2399ec", "target": 1, "func": "static int yuv4_write_header ( AVFormatContext * s ) \n { \n int * first_pkt = s -> priv_data ; \n if ( s -> nb_streams != 1 ) \n return AVERROR ( EIO ) ; \n if ( s -> streams [ 0 ] -> codec -> pix_fmt == PIX_FMT_YUV411P ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n else if ( ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_YUV420P ) && \n ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_YUV422P ) && \n ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_GRAY8 ) && \n ( s -> streams [ 0 ] -> codec -> pix_fmt != PIX_FMT_YUV444P ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EIO ) ; \n * first_pkt = 1 ; \n return 0 ;", "idx": 11290}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget_long ( const uint8_t * * p , int le ) \n { \n unsigned v = le ? AV_RL32 ( * p ) : AV_RB32 ( * p ) ; \n * p += 4 ; \n return v ; \n }", "idx": 11299}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_smi ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return -1 ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + 0x5a + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = 0x5a + atom . size ; \n memcpy ( st -> codec -> extradata , \" \" , 4 ) ; \n get_buffer ( pb , st -> codec -> extradata + 0x5a , atom . size ) ; \n dprintf ( c -> fc , \" \" PRId64 \" \\n \" , atom . size , st -> codec -> extradata + 0x5a ) ; \n return 0 ; \n }", "idx": 11310}
{"project": "FFmpeg", "commit_id": "7fb92be7e50ea4ba5712804326c6814ae02dd190", "target": 1, "func": "static void qtrle_decode_24bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned char r , g , b ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n while ( lines_to_change -- ) { \n CHECK_STREAM_PTR ( 2 ) ; \n pixel_ptr = row_ptr + ( s -> buf [ stream_ptr ++ ] - 1 ) * 3 ; \n while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != -1 ) { \n if ( rle_code == 0 ) { \n CHECK_STREAM_PTR ( 1 ) ; \n pixel_ptr += ( s -> buf [ stream_ptr ++ ] - 1 ) * 3 ; \n } else if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 3 ) ; \n r = s -> buf [ stream_ptr ++ ] ; \n g = s -> buf [ stream_ptr ++ ] ; \n b = s -> buf [ stream_ptr ++ ] ; \n CHECK_PIXEL_PTR ( rle_code * 3 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = r ; \n rgb [ pixel_ptr ++ ] = g ; \n rgb [ pixel_ptr ++ ] = b ; \n } \n } else { \n CHECK_STREAM_PTR ( rle_code * 3 ) ; \n CHECK_PIXEL_PTR ( rle_code * 3 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n } \n } \n } \n row_ptr += row_inc ; \n } \n }", "idx": 11327}
{"project": "FFmpeg", "commit_id": "e58c05bb3c8b7bd3b93d264facbf290aeae4c483", "target": 1, "func": "static int xiph_parse_sdp_line ( AVFormatContext * s , int st_index , \n PayloadContext * data , const char * line ) \n { \n const char * p ; \n char * value ; \n char attr [ 25 ] ; \n int value_size = strlen ( line ) , attr_size = sizeof ( attr ) , res = 0 ; \n AVCodecContext * codec = s -> streams [ st_index ] -> codec ; \n assert ( codec -> id == CODEC_ID_THEORA ) ; \n assert ( data ) ; \n if ( ! ( value = av_malloc ( value_size ) ) ) { \n av_log ( codec , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( av_strstart ( line , \" \" , & p ) ) { \n while ( * p && * p == ' ' ) p ++ ; \n while ( * p && * p != ' ' ) p ++ ; \n while ( * p && * p == ' ' ) p ++ ; \n while ( ff_rtsp_next_attr_and_value ( & p , \n attr , attr_size , \n value , value_size ) ) { \n res = xiph_parse_fmtp_pair ( codec , data , attr , value ) ; \n if ( res < 0 && res != AVERROR_PATCHWELCOME ) \n return res ; \n } \n } \n av_free ( value ) ; \n return 0 ; \n }", "idx": 11329}
{"project": "FFmpeg", "commit_id": "4819446eae451a6e58d6ae41faefb5529af4e783", "target": 1, "func": "static int webvtt_event_to_ass ( AVBPrint * buf , const char * p ) \n { \n int i , again , skip = 0 ; \n while ( * p ) { \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( webvtt_tag_replace ) ; i ++ ) { \n const char * from = webvtt_tag_replace [ i ] . from ; \n const size_t len = strlen ( from ) ; \n if ( ! strncmp ( p , from , len ) ) { \n av_bprintf ( buf , \" \" , webvtt_tag_replace [ i ] . to ) ; \n p += len ; \n again = 1 ; \n break ; \n } \n } \n if ( ! * p ) \n break ; \n if ( again ) { \n again = 0 ; \n skip = 0 ; \n continue ; \n } \n if ( * p == ' ' ) \n skip = 1 ; \n else if ( * p == ' ' ) \n skip = 0 ; \n else if ( p [ 0 ] == ' \\n ' && p [ 1 ] ) \n av_bprintf ( buf , \" \\\\ \" ) ; \n else if ( ! skip && * p != ' \\r ' ) \n av_bprint_chars ( buf , * p , 1 ) ; \n p ++ ; \n } \n return 0 ; \n }", "idx": 11333}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int nuv_probe ( AVProbeData * p ) { \n if ( p -> buf_size < 12 ) \n return 0 ; \n if ( ! memcmp ( p -> buf , \" \" , 12 ) ) \n return AVPROBE_SCORE_MAX ; \n if ( ! memcmp ( p -> buf , \" \" , 12 ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 11335}
{"project": "FFmpeg", "commit_id": "527224830aad6aaf5fc5ed9ff6c5f12c80ff906c", "target": 1, "func": "static int idcin_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n IdcinContext * s = avctx -> priv_data ; \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( s -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> frame ) ; \n if ( avctx -> get_buffer ( avctx , & s -> frame ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n idcin_decode_vlcs ( s ) ; \n if ( pal ) { \n s -> frame . palette_has_changed = 1 ; \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n } \n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 11340}
{"project": "FFmpeg", "commit_id": "5a571d324129ce367584ad9d92aae1d286f389a2", "target": 1, "func": "static void h264_free_context ( PayloadContext * data ) \n { \n #ifdef DEBUG \n int ii ; \n for ( ii = 0 ; ii < 32 ; ii ++ ) { \n if ( data -> packet_types_received [ ii ] ) \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , \n data -> packet_types_received [ ii ] , ii ) ; \n } \n #endif \n assert ( data ) ; \n assert ( data -> cookie == MAGIC_COOKIE ) ; \n data -> cookie = DEAD_COOKIE ; \n av_free ( data ) ; \n }", "idx": 11348}
{"project": "FFmpeg", "commit_id": "07ef7b1a303680b73fc4a014f74a6d5089725184", "target": 1, "func": "static int find_image_range ( int * pfirst_index , int * plast_index , \n const char * path , int start_index ) \n { \n char buf [ 1024 ] ; \n int range , last_index , range1 , first_index ; \n for ( first_index = start_index ; first_index < start_index + 5 ; first_index ++ ) { \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , first_index ) < 0 ) { \n * pfirst_index = \n * plast_index = 1 ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n return 0 ; \n return -1 ; \n } \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n break ; \n } \n if ( first_index == 5 ) \n goto fail ; \n last_index = first_index ; \n for ( ; ; ) { \n range = 0 ; \n for ( ; ; ) { \n if ( ! range ) \n range1 = 1 ; \n else \n range1 = 2 * range ; \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , \n last_index + range1 ) < 0 ) \n goto fail ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) <= 0 ) \n break ; \n range = range1 ; \n if ( range >= ( 1 << 30 ) ) \n goto fail ; \n } \n if ( ! range ) \n break ; \n last_index += range ; \n } \n * pfirst_index = first_index ; \n * plast_index = last_index ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 11351}
{"project": "FFmpeg", "commit_id": "c363843a53553cbda6d42d98e8fbd165eda193fb", "target": 0, "func": "static int filter_packet ( void * log_ctx , AVPacket * pkt , \n AVFormatContext * fmt_ctx , AVBitStreamFilterContext * bsf_ctx ) \n { \n AVCodecContext * enc_ctx = fmt_ctx -> streams [ pkt -> stream_index ] -> codec ; \n int ret = 0 ; \n while ( bsf_ctx ) { \n AVPacket new_pkt = * pkt ; \n ret = av_bitstream_filter_filter ( bsf_ctx , enc_ctx , NULL , \n & new_pkt . data , & new_pkt . size , \n pkt -> data , pkt -> size , \n pkt -> flags & AV_PKT_FLAG_KEY ) ; \n if ( ret == 0 && new_pkt . data != pkt -> data && new_pkt . destruct ) { \n if ( ( ret = av_copy_packet ( & new_pkt , pkt ) ) < 0 ) \n break ; \n ret = 1 ; \n } \n if ( ret > 0 ) { \n av_free_packet ( pkt ) ; \n new_pkt . buf = av_buffer_create ( new_pkt . data , new_pkt . size , \n av_buffer_default_free , NULL , 0 ) ; \n if ( ! new_pkt . buf ) \n break ; \n } \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , \n bsf_ctx -> filter -> name , pkt -> stream_index , fmt_ctx -> filename , \n avcodec_get_name ( enc_ctx -> codec_id ) ) ; \n } \n * pkt = new_pkt ; \n bsf_ctx = bsf_ctx -> next ; \n } \n return ret ; \n }", "idx": 11353}
{"project": "FFmpeg", "commit_id": "99684f3ae752fc8bfb44a2dd1482f8d7a3d8536d", "target": 0, "func": "int avio_close ( AVIOContext * s ) \n { \n AVIOInternal * internal ; \n URLContext * h ; \n if ( ! s ) \n return 0 ; \n avio_flush ( s ) ; \n internal = s -> opaque ; \n h = internal -> h ; \n av_opt_free ( internal ) ; \n av_freep ( & internal -> protocols ) ; \n av_freep ( & s -> opaque ) ; \n av_freep ( & s -> buffer ) ; \n av_free ( s ) ; \n return ffurl_close ( h ) ; \n }", "idx": 11356}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb32tobgr24 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n uint8_t * dest = dst ; \n const uint8_t * s = src ; \n const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n mm_end = end - 31 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n STORE_BGR24_MMX \n : \" \" ( * dest ) \n : \" \" ( * s ) \n : \" \" ) ; \n dest += 24 ; \n s += 32 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n while ( s < end ) { \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n * dest ++ = * s ++ ; \n s ++ ; \n } \n }", "idx": 11365}
{"project": "FFmpeg", "commit_id": "3511d4fc9784d5fbb024dce68ca7a0d7fdd74663", "target": 1, "func": "static void slice_thread_park_workers ( ThreadContext * c ) \n { \n pthread_cond_wait ( & c -> last_job_cond , & c -> current_job_lock ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n }", "idx": 11366}
{"project": "FFmpeg", "commit_id": "e3faad811e429002d549562db4e0fc30c08dc6a4", "target": 0, "func": "static int quantize_coefs ( double * coef , int * idx , float * lpc , int order ) \n { \n int i ; \n uint8_t u_coef ; \n const float * quant_arr = tns_tmp2_map [ TNS_Q_BITS == 4 ] ; \n const double iqfac_p = ( ( 1 << ( TNS_Q_BITS - 1 ) ) - 0.5 ) / ( M_PI / 2.0 ) ; \n const double iqfac_m = ( ( 1 << ( TNS_Q_BITS - 1 ) ) + 0.5 ) / ( M_PI / 2.0 ) ; \n for ( i = 0 ; i < order ; i ++ ) { \n idx [ i ] = ceilf ( asin ( coef [ i ] ) * ( ( coef [ i ] >= 0 ) ? iqfac_p : iqfac_m ) ) ; \n u_coef = ( idx [ i ] ) & ( ~ ( ~ 0 << TNS_Q_BITS ) ) ; \n lpc [ i ] = quant_arr [ u_coef ] ; \n } \n return order ; \n }", "idx": 11376}
{"project": "FFmpeg", "commit_id": "3748b2b8e8bcedba2de7fe826c4094169a885840", "target": 1, "func": "int avfilter_graph_add_filter ( AVFilterGraph * graph , AVFilterContext * filter ) \n { \n graph -> filters = av_realloc ( graph -> filters , \n sizeof ( AVFilterContext * ) * ++ graph -> filter_count ) ; \n if ( ! graph -> filters ) \n return AVERROR ( ENOMEM ) ; \n graph -> filters [ graph -> filter_count - 1 ] = filter ; \n return 0 ; \n }", "idx": 11379}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int truemotion1_decode_init ( AVCodecContext * avctx ) \n { \n TrueMotion1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> frame . data [ 0 ] = NULL ; \n av_fast_malloc ( & s -> vert_pred , & s -> vert_pred_size , s -> avctx -> width * sizeof ( unsigned int ) ) ; \n return 0 ; \n }", "idx": 11387}
{"project": "FFmpeg", "commit_id": "900f39692ca0337a98a7cf047e4e2611071810c2", "target": 1, "func": "static int mxf_read_index_entry_array ( AVIOContext * pb , MXFIndexTableSegment * segment ) \n { \n int i , length ; \n segment -> nb_index_entries = avio_rb32 ( pb ) ; \n length = avio_rb32 ( pb ) ; \n if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || \n ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || \n ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) { \n av_freep ( & segment -> temporal_offset_entries ) ; \n av_freep ( & segment -> flag_entries ) ; \n return AVERROR ( ENOMEM ) ; \n } \n for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { \n if ( avio_feof ( pb ) ) \n segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ; \n avio_r8 ( pb ) ; \n segment -> flag_entries [ i ] = avio_r8 ( pb ) ; \n segment -> stream_offset_entries [ i ] = avio_rb64 ( pb ) ; \n avio_skip ( pb , length - 11 ) ; \n } \n return 0 ; \n }", "idx": 11392}
{"project": "FFmpeg", "commit_id": "371946bc27bd1e874e0302699550ab9926249950", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , uint8_t * buf , \n int buf_size , void * data ) \n { \n AVFrame * pic = data ; \n int i , j ; \n int aligned_width = FFALIGN ( avctx -> width , 64 ) ; \n uint8_t * src_line ; \n uint8_t * dst = buf ; \n if ( buf_size < 4 * aligned_width * avctx -> height ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> coded_frame -> reference = 0 ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n src_line = pic -> data [ 0 ] ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n uint16_t * src = ( uint16_t * ) src_line ; \n for ( j = 0 ; j < avctx -> width ; j ++ ) { \n uint32_t pixel ; \n uint16_t r = * src ++ >> 6 ; \n uint16_t g = * src ++ >> 6 ; \n uint16_t b = * src ++ >> 4 ; \n if ( avctx -> codec_id == CODEC_ID_R210 ) \n pixel = ( r << 20 ) | ( g << 10 ) | b >> 2 ; \n else \n pixel = ( r << 22 ) | ( g << 12 ) | b ; \n if ( avctx -> codec_id == CODEC_ID_AVRP ) \n bytestream_put_le32 ( & dst , pixel ) ; \n else \n bytestream_put_be32 ( & dst , pixel ) ; \n } \n dst += ( aligned_width - avctx -> width ) * 4 ; \n src_line += pic -> linesize [ 0 ] ; \n } \n return 4 * aligned_width * avctx -> height ; \n }", "idx": 11397}
{"project": "FFmpeg", "commit_id": "f495fbe76a2665cdea092999ca2dbb603d13280c", "target": 0, "func": "int avio_check ( const char * url , int flags ) \n { \n URLContext * h ; \n int ret = ffurl_alloc ( & h , url , flags , NULL ) ; \n if ( ret ) \n return ret ; \n if ( h -> prot -> url_check ) { \n ret = h -> prot -> url_check ( h , flags ) ; \n } else { \n ret = ffurl_connect ( h , NULL ) ; \n if ( ret >= 0 ) \n ret = flags ; \n } \n ffurl_close ( h ) ; \n return ret ; \n }", "idx": 11416}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x8_horizontal_add ) ( uint8_t * pix , const int * block_offset , \n const int16_t * block , \n ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) \n FUNCC ( pred4x4_horizontal_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 11420}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "void init_checksum ( ByteIOContext * s , unsigned long ( * update_checksum ) ( unsigned long c , const uint8_t * p , unsigned int len ) , unsigned long checksum ) { \n s -> update_checksum = update_checksum ; \n s -> checksum = s -> update_checksum ( checksum , NULL , 0 ) ; \n s -> checksum_ptr = s -> buf_ptr ; \n }", "idx": 11421}
{"project": "FFmpeg", "commit_id": "fa0f62c37d90c0760bddccba2054578e2c61ae1a", "target": 0, "func": "static int mpeg_mux_write_packet ( AVFormatContext * ctx , int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n AVStream * st = ctx -> streams [ stream_index ] ; \n StreamInfo * stream = st -> priv_data ; \n int len ; \n while ( size > 0 ) { \n if ( stream -> start_pts == -1 ) { \n stream -> start_pts = pts ; \n } \n len = s -> packet_data_max_size - stream -> buffer_ptr ; \n if ( len > size ) \n len = size ; \n memcpy ( stream -> buffer + stream -> buffer_ptr , buf , len ) ; \n stream -> buffer_ptr += len ; \n buf += len ; \n size -= len ; \n while ( stream -> buffer_ptr >= s -> packet_data_max_size ) { \n if ( stream -> start_pts == -1 ) \n stream -> start_pts = pts ; \n flush_packet ( ctx , stream_index , 0 ) ; \n } \n } \n return 0 ; \n }", "idx": 11424}
{"project": "FFmpeg", "commit_id": "13c56e9a9cf18f33bcbc2dc1a5cf2a5f98ca9702", "target": 0, "func": "static int decode_i_block ( FourXContext * f , int16_t * block ) \n { \n int code , i , j , level , val ; \n if ( get_bits_left ( & f -> gb ) < 2 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" , get_bits_left ( & f -> gb ) ) ; \n return -1 ; \n } \n val = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ; \n if ( val >> 4 ) \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( val ) \n val = get_xbits ( & f -> gb , val ) ; \n val = val * dequant_table [ 0 ] + f -> last_dc ; \n f -> last_dc = block [ 0 ] = val ; \n i = 1 ; \n for ( ; ; ) { \n code = get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) ; \n if ( code == 0 ) \n break ; \n if ( code == 0xf0 ) { \n i += 16 ; \n } else { \n level = get_xbits ( & f -> gb , code & 0xf ) ; \n i += code >> 4 ; \n if ( i >= 64 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return 0 ; \n } \n j = ff_zigzag_direct [ i ] ; \n block [ j ] = level * dequant_table [ j ] ; \n i ++ ; \n if ( i >= 64 ) \n break ; \n } \n } \n return 0 ; \n }", "idx": 11425}
{"project": "FFmpeg", "commit_id": "a8f171151f0f027abb06f72e48c44929616a84cb", "target": 0, "func": "static int file_read ( URLContext * h , unsigned char * buf , int size ) \n { \n FileContext * c = h -> priv_data ; \n int r = read ( c -> fd , buf , size ) ; \n return ( -1 == r ) ? AVERROR ( errno ) : r ; \n }", "idx": 11431}
{"project": "FFmpeg", "commit_id": "bc38e83793be5f7a184c88be55e556453a25224b", "target": 1, "func": "int ff_mpegts_parse_packet ( MpegTSContext * ts , AVPacket * pkt , \n const uint8_t * buf , int len ) \n { \n int len1 ; \n len1 = len ; \n ts -> pkt = pkt ; \n ts -> stop_parse = 0 ; \n for ( ; ; ) { \n if ( ts -> stop_parse > 0 ) \n break ; \n if ( len < TS_PACKET_SIZE ) \n return -1 ; \n if ( buf [ 0 ] != 0x47 ) { \n buf ++ ; \n len -- ; \n } else { \n handle_packet ( ts , buf ) ; \n buf += TS_PACKET_SIZE ; \n len -= TS_PACKET_SIZE ; \n } \n } \n return len1 - len ; \n }", "idx": 11434}
{"project": "FFmpeg", "commit_id": "c31b81216619e6b3d986ce63c82357993e10e8e9", "target": 1, "func": "static int mszh_decomp ( unsigned char * srcptr , int srclen , unsigned char * destptr ) \n { \n unsigned char * destptr_bak = destptr ; \n unsigned char mask = 0 ; \n unsigned char maskbit = 0 ; \n unsigned int ofs , cnt ; \n while ( srclen > 0 ) { \n if ( maskbit == 0 ) { \n mask = * ( srcptr ++ ) ; \n maskbit = 8 ; \n srclen -- ; \n continue ; \n } \n if ( ( mask & ( 1 << ( -- maskbit ) ) ) == 0 ) { \n * ( int * ) destptr = * ( int * ) srcptr ; \n srclen -= 4 ; \n destptr += 4 ; \n srcptr += 4 ; \n } else { \n ofs = * ( srcptr ++ ) ; \n cnt = * ( srcptr ++ ) ; \n ofs += cnt * 256 ; ; \n cnt = ( ( cnt >> 3 ) & 0x1f ) + 1 ; \n ofs &= 0x7ff ; \n srclen -= 2 ; \n cnt *= 4 ; \n for ( ; cnt > 0 ; cnt -- ) { \n * ( destptr ) = * ( destptr - ofs ) ; \n destptr ++ ; \n } \n } \n } \n return ( destptr - destptr_bak ) ; \n }", "idx": 11435}
{"project": "FFmpeg", "commit_id": "58720ebd9e671f654d89d8e401d0b4dffb79122b", "target": 1, "func": "int ff_split_xiph_headers ( uint8_t * extradata , int extradata_size , \n int first_header_size , uint8_t * header_start [ 3 ] , \n int header_len [ 3 ] ) \n { \n int i , j ; \n if ( AV_RB16 ( extradata ) == first_header_size ) { \n for ( i = 0 ; i < 3 ; i ++ ) { \n header_len [ i ] = AV_RB16 ( extradata ) ; \n extradata += 2 ; \n header_start [ i ] = extradata ; \n extradata += header_len [ i ] ; \n } \n } else if ( extradata [ 0 ] == 2 ) { \n for ( i = 0 , j = 1 ; i < 2 ; i ++ , j ++ ) { \n header_len [ i ] = 0 ; \n for ( ; j < extradata_size && extradata [ j ] == 0xff ; j ++ ) { \n header_len [ i ] += 0xff ; \n } \n if ( j >= extradata_size ) \n return -1 ; \n header_len [ i ] += extradata [ j ] ; \n } \n header_len [ 2 ] = extradata_size - header_len [ 0 ] - header_len [ 1 ] - j ; \n extradata += j ; \n header_start [ 0 ] = extradata ; \n header_start [ 1 ] = header_start [ 0 ] + header_len [ 0 ] ; \n header_start [ 2 ] = header_start [ 1 ] + header_len [ 1 ] ; \n } else { \n return -1 ; \n } \n return 0 ; \n }", "idx": 11436}
{"project": "FFmpeg", "commit_id": "d8245c3bcdd162891825a52cf55e4e8173d85a18", "target": 1, "func": "static av_cold int cinvideo_decode_end ( AVCodecContext * avctx ) \n { \n CinVideoContext * cin = avctx -> priv_data ; \n int i ; \n if ( cin -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & cin -> frame ) ; \n for ( i = 0 ; i < 3 ; ++ i ) \n av_free ( cin -> bitmap_table [ i ] ) ; \n return 0 ; \n }", "idx": 11454}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static uint64_t get_vb ( ByteIOContext * bc ) { \n uint64_t val = 0 ; \n int i = get_v ( bc ) ; \n if ( i > 8 ) \n return UINT64_MAX ; \n while ( i -- ) \n val = ( val << 8 ) + get_byte ( bc ) ; \n return val ; \n }", "idx": 11463}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_fft_init_mmx ( FFTContext * s ) \n { \n #if HAVE_YASM  \n  \n  int has_vectors = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( has_vectors & AV_CPU_FLAG_3DNOW && HAVE_AMD3DNOW ) { \n s -> imdct_calc = ff_imdct_calc_3dnow ; \n s -> imdct_half = ff_imdct_half_3dnow ; \n s -> fft_calc = ff_fft_calc_3dnow ; \n } \n if ( has_vectors & AV_CPU_FLAG_3DNOWEXT && HAVE_AMD3DNOWEXT ) { \n s -> imdct_calc = ff_imdct_calc_3dnowext ; \n s -> imdct_half = ff_imdct_half_3dnowext ; \n s -> fft_calc = ff_fft_calc_3dnowext ; \n } \n #endif \n if ( has_vectors & AV_CPU_FLAG_SSE && HAVE_SSE ) { \n s -> imdct_calc = ff_imdct_calc_sse ; \n s -> imdct_half = ff_imdct_half_sse ; \n s -> fft_permute = ff_fft_permute_sse ; \n s -> fft_calc = ff_fft_calc_sse ; \n s -> fft_permutation = FF_FFT_PERM_SWAP_LSBS ; \n } \n if ( has_vectors & AV_CPU_FLAG_AVX && HAVE_AVX && s -> nbits >= 5 ) { \n s -> imdct_half = ff_imdct_half_avx ; \n s -> fft_calc = ff_fft_calc_avx ; \n s -> fft_permutation = FF_FFT_PERM_AVX ; \n } \n #endif \n }", "idx": 11470}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe_samples ( DCAEncContext * c , int ss , int band , int ch ) \n { \n if ( c -> abits [ band ] [ ch ] <= 7 ) { \n int sum , i , j ; \n for ( i = 0 ; i < 8 ; i += 4 ) { \n sum = 0 ; \n for ( j = 3 ; j >= 0 ; j -- ) { \n sum *= ff_dca_quant_levels [ c -> abits [ band ] [ ch ] ] ; \n sum += c -> quantized [ ss * 8 + i + j ] [ band ] [ ch ] ; \n sum += ( ff_dca_quant_levels [ c -> abits [ band ] [ ch ] ] - 1 ) / 2 ; \n } \n put_bits ( & c -> pb , bit_consumption [ c -> abits [ band ] [ ch ] ] / 4 , sum ) ; \n } \n } else { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n int bits = bit_consumption [ c -> abits [ band ] [ ch ] ] / 16 ; \n put_sbits ( & c -> pb , bits , c -> quantized [ ss * 8 + i ] [ band ] [ ch ] ) ; \n } \n } \n }", "idx": 11472}
{"project": "FFmpeg", "commit_id": "0ceca269b66ec12a23bf0907bd2c220513cdbf16", "target": 0, "func": "static void read_const_block_data ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n ALSSpecificConfig * sconf = & ctx -> sconf ; \n AVCodecContext * avctx = ctx -> avctx ; \n GetBitContext * gb = & ctx -> gb ; \n * bd -> raw_samples = 0 ; \n * bd -> const_block = get_bits1 ( gb ) ; \n bd -> js_blocks = get_bits1 ( gb ) ; \n skip_bits ( gb , 5 ) ; \n if ( * bd -> const_block ) { \n unsigned int const_val_bits = sconf -> floating ? 24 : avctx -> bits_per_raw_sample ; \n * bd -> raw_samples = get_sbits_long ( gb , const_val_bits ) ; \n } \n * bd -> const_block = 1 ; \n }", "idx": 11480}
{"project": "FFmpeg", "commit_id": "2083648383d93917d482e69dd33e46cbd8404d31", "target": 0, "func": "static int MP3lame_encode_frame ( AVCodecContext * avctx , \n unsigned char * frame , int buf_size , void * data ) \n { \n Mp3AudioContext * s = avctx -> priv_data ; \n int len ; \n int lame_result ; \n if ( data ) { \n if ( s -> stereo ) { \n lame_result = lame_encode_buffer_interleaved ( \n s -> gfp , \n data , \n avctx -> frame_size , \n s -> buffer + s -> buffer_index , \n BUFFER_SIZE - s -> buffer_index \n ) ; \n } else { \n lame_result = lame_encode_buffer ( \n s -> gfp , \n data , \n data , \n avctx -> frame_size , \n s -> buffer + s -> buffer_index , \n BUFFER_SIZE - s -> buffer_index \n ) ; \n } \n } else { \n lame_result = lame_encode_flush ( \n s -> gfp , \n s -> buffer + s -> buffer_index , \n BUFFER_SIZE - s -> buffer_index \n ) ; \n } \n if ( lame_result == -1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , s -> buffer_index , BUFFER_SIZE - s -> buffer_index ) ; \n return 0 ; \n } \n s -> buffer_index += lame_result ; \n if ( s -> buffer_index < 4 ) \n return 0 ; \n len = mp3len ( s -> buffer , NULL , NULL ) ; \n if ( len <= s -> buffer_index ) { \n memcpy ( frame , s -> buffer , len ) ; \n s -> buffer_index -= len ; \n memmove ( s -> buffer , s -> buffer + len , s -> buffer_index ) ; \n return len ; \n } else \n return 0 ; \n }", "idx": 11481}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int vf_open ( vf_instance_t * vf , char * args ) \n { \n vf -> config = config ; \n vf -> query_format = query_format ; \n vf -> put_image = put_image ; \n vf -> uninit = uninit ; \n vf -> priv = calloc ( 1 , sizeof ( struct vf_priv_s ) ) ; \n vf -> priv -> skipline = 0 ; \n vf -> priv -> scalew = 1 ; \n vf -> priv -> scaleh = 2 ; \n if ( args ) sscanf ( args , \" \" , & vf -> priv -> skipline , & vf -> priv -> scalew , & vf -> priv -> scaleh ) ; \n return 1 ; \n }", "idx": 11485}
{"project": "FFmpeg", "commit_id": "4b0e0f31bf0f618a634dcfdca45e72cdfb0b48b5", "target": 1, "func": "av_cold void ff_lpc_end ( LPCContext * s ) \n { \n av_freep ( & s -> windowed_samples ) ; \n }", "idx": 11495}
{"project": "FFmpeg", "commit_id": "e774c41cab765f5d12ecfb31e5fa30df41230de0", "target": 0, "func": "static inline void update_rice ( APERice * rice , int x ) \n { \n rice -> ksum += ( ( x + 1 ) / 2 ) - ( ( rice -> ksum + 16 ) >> 5 ) ; \n if ( rice -> k == 0 ) \n rice -> k = 1 ; \n else if ( rice -> ksum < ( 1 << ( rice -> k + 4 ) ) ) \n rice -> k -- ; \n else if ( rice -> ksum >= ( 1 << ( rice -> k + 5 ) ) ) \n rice -> k ++ ; \n }", "idx": 11500}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp78_decode_mv_mb_modes ( AVCodecContext * avctx , VP8Frame * curframe , \n VP8Frame * prev_frame , int is_vp7 ) \n { \n VP8Context * s = avctx -> priv_data ; \n int mb_x , mb_y ; \n s -> mv_min . y = - MARGIN ; \n s -> mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; \n for ( mb_y = 0 ; mb_y < s -> mb_height ; mb_y ++ ) { \n VP8Macroblock * mb = s -> macroblocks_base + \n ( ( s -> mb_width + 1 ) * ( mb_y + 1 ) + 1 ) ; \n int mb_xy = mb_y * s -> mb_width ; \n AV_WN32A ( s -> intra4x4_pred_mode_left , DC_PRED * 0x01010101 ) ; \n s -> mv_min . x = - MARGIN ; \n s -> mv_max . x = ( ( s -> mb_width - 1 ) << 6 ) + MARGIN ; \n for ( mb_x = 0 ; mb_x < s -> mb_width ; mb_x ++ , mb_xy ++ , mb ++ ) { \n if ( mb_y == 0 ) \n AV_WN32A ( ( mb - s -> mb_width - 1 ) -> intra4x4_pred_mode_top , \n DC_PRED * 0x01010101 ) ; \n decode_mb_mode ( s , mb , mb_x , mb_y , curframe -> seg_map -> data + mb_xy , \n prev_frame && prev_frame -> seg_map ? \n prev_frame -> seg_map -> data + mb_xy : NULL , 1 , is_vp7 ) ; \n s -> mv_min . x -= 64 ; \n s -> mv_max . x -= 64 ; \n } \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n } \n }", "idx": 11508}
{"project": "FFmpeg", "commit_id": "3abde1a3b49cf299f2aae4eaae6b6cb5270bdc22", "target": 1, "func": "static const uint8_t * pcx_rle_decode ( const uint8_t * src , uint8_t * dst , \n unsigned int bytes_per_scanline , \n int compressed ) \n { \n unsigned int i = 0 ; \n unsigned char run , value ; \n if ( compressed ) { \n while ( i < bytes_per_scanline ) { \n run = 1 ; \n value = * src ++ ; \n if ( value >= 0xc0 ) { \n run = value & 0x3f ; \n value = * src ++ ; \n } \n while ( i < bytes_per_scanline && run -- ) \n dst [ i ++ ] = value ; \n } \n } else { \n memcpy ( dst , src , bytes_per_scanline ) ; \n src += bytes_per_scanline ; \n } \n return src ; \n }", "idx": 11525}
{"project": "FFmpeg", "commit_id": "f467fc02b475cd45b68aa5fb5f7c78286110ba86", "target": 0, "func": "void checkasm_check_h264pred ( void ) \n { \n static const struct { \n void ( * func ) ( H264PredContext * , uint8_t * , uint8_t * , int , int , int ) ; \n const char * name ; \n } tests [ ] = { \n { check_pred4x4 , \" \" } , \n { check_pred8x8 , \" \" } , \n { check_pred16x16 , \" \" } , \n { check_pred8x8l , \" \" } , \n } ; \n DECLARE_ALIGNED ( 16 , uint8_t , buf0 ) [ BUF_SIZE ] ; \n DECLARE_ALIGNED ( 16 , uint8_t , buf1 ) [ BUF_SIZE ] ; \n H264PredContext h ; \n int test , codec , chroma_format , bit_depth ; \n for ( test = 0 ; test < FF_ARRAY_ELEMS ( tests ) ; test ++ ) { \n for ( codec = 0 ; codec < 4 ; codec ++ ) { \n int codec_id = codec_ids [ codec ] ; \n for ( bit_depth = 8 ; bit_depth <= ( codec_id == AV_CODEC_ID_H264 ? 10 : 8 ) ; bit_depth ++ ) \n for ( chroma_format = 1 ; chroma_format <= ( codec_id == AV_CODEC_ID_H264 ? 2 : 1 ) ; chroma_format ++ ) { \n ff_h264_pred_init ( & h , codec_id , bit_depth , chroma_format ) ; \n tests [ test ] . func ( & h , buf0 , buf1 , codec , chroma_format , bit_depth ) ; \n } \n } \n report ( \" \" , tests [ test ] . name ) ; \n } \n }", "idx": 11526}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) \n { \n if ( pic -> f -> buf [ 0 ] == NULL ) \n return 1 ; \n if ( pic -> needs_realloc && ! ( pic -> reference & DELAYED_PIC_REF ) ) \n return 1 ; \n return 0 ; \n }", "idx": 11537}
{"project": "FFmpeg", "commit_id": "9959a52b14bcfa3e5baeb3fc8a86c04bbc0d3d5d", "target": 1, "func": "static int ast_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n uint32_t type , size ; \n int64_t pos ; \n int ret ; \n if ( avio_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n pos = avio_tell ( s -> pb ) ; \n type = avio_rl32 ( s -> pb ) ; \n size = avio_rb32 ( s -> pb ) ; \n if ( size > INT_MAX / s -> streams [ 0 ] -> codecpar -> channels ) \n return AVERROR_INVALIDDATA ; \n size *= s -> streams [ 0 ] -> codecpar -> channels ; \n if ( ( ret = avio_skip ( s -> pb , 24 ) ) < 0 ) \n return ret ; \n if ( type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n pkt -> pos = pos ; \n } else { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , type ) ; \n avio_skip ( s -> pb , size ) ; \n ret = AVERROR_INVALIDDATA ; \n } \n return ret ; \n }", "idx": 11550}
{"project": "FFmpeg", "commit_id": "f3fdef108eb06b1e71b29152bf6822519e787efe", "target": 1, "func": "static void do_apply_filter ( APEContext * ctx , int version , APEFilter * f , \n int32_t * data , int count , int order , int fracbits ) \n { \n int res ; \n int absres ; \n while ( count -- ) { \n res = ctx -> adsp . scalarproduct_and_madd_int16 ( f -> coeffs , \n f -> delay - order , \n f -> adaptcoeffs - order , \n order , APESIGN ( * data ) ) ; \n res = ( res + ( 1 << ( fracbits - 1 ) ) ) >> fracbits ; \n res += * data ; \n * data ++ = res ; \n * f -> delay ++ = av_clip_int16 ( res ) ; \n if ( version < 3980 ) { \n f -> adaptcoeffs [ 0 ] = ( res == 0 ) ? 0 : ( ( res >> 28 ) & 8 ) - 4 ; \n f -> adaptcoeffs [ -4 ] >>= 1 ; \n f -> adaptcoeffs [ -8 ] >>= 1 ; \n } else { \n absres = FFABS ( res ) ; \n if ( absres ) \n * f -> adaptcoeffs = ( ( res & ( -1 << 31 ) ) ^ ( -1 << 30 ) ) >> \n ( 25 + ( absres <= f -> avg * 3 ) + ( absres <= f -> avg * 4 / 3 ) ) ; \n else \n * f -> adaptcoeffs = 0 ; \n f -> avg += ( absres - f -> avg ) / 16 ; \n f -> adaptcoeffs [ -1 ] >>= 1 ; \n f -> adaptcoeffs [ -2 ] >>= 1 ; \n f -> adaptcoeffs [ -8 ] >>= 1 ; \n } \n f -> adaptcoeffs ++ ; \n if ( f -> delay == f -> historybuffer + HISTORY_SIZE + ( order * 2 ) ) { \n memmove ( f -> historybuffer , f -> delay - ( order * 2 ) , \n ( order * 2 ) * sizeof ( * f -> historybuffer ) ) ; \n f -> delay = f -> historybuffer + order * 2 ; \n f -> adaptcoeffs = f -> historybuffer + order ; \n } \n } \n }", "idx": 11551}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_init_lls_x86 ( LLSModel * m ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n m -> update_lls = ff_update_lls_sse2 ; \n if ( m -> indep_count >= 4 ) \n m -> evaluate_lls = ff_evaluate_lls_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n m -> update_lls = ff_update_lls_avx ; \n } \n }", "idx": 11554}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( c -> flags & SWS_ACCURATE_RND ) { \n if ( uDest ) { \n YSCALEYUV2YV12X_ACCURATE ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X_ACCURATE ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X_ACCURATE ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } else { \n if ( uDest ) { \n YSCALEYUV2YV12X ( 0 , CHR_MMX_FILTER_OFFSET , uDest , chrDstW )  \n YSCALEYUV2YV12X ( 4096 , CHR_MMX_FILTER_OFFSET , vDest , chrDstW )  \n } \n YSCALEYUV2YV12X ( 0 , LUM_MMX_FILTER_OFFSET , dest , dstW )  \n } \n #else \n #ifdef HAVE_ALTIVEC \n yuv2yuvX_altivec_real ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #else \n yuv2yuvXinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , vDest , dstW , chrDstW ) ; \n #endif \n #endif \n }", "idx": 11555}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( yv12touyvy ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartouyvy ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 11561}
{"project": "FFmpeg", "commit_id": "94d05ff15985d17aba070eaec82acd21c0da3d86", "target": 1, "func": "static int read_audio_mux_element ( struct LATMContext * latmctx , \n GetBitContext * gb ) \n { \n int err ; \n uint8_t use_same_mux = get_bits ( gb , 1 ) ; \n if ( ! use_same_mux ) { \n if ( ( err = read_stream_mux_config ( latmctx , gb ) ) < 0 ) \n return err ; \n } else if ( ! latmctx -> aac_ctx . avctx -> extradata ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_DEBUG , \n \" \\n \" ) ; \n return AVERROR ( EAGAIN ) ; \n } \n if ( latmctx -> audio_mux_version_A == 0 ) { \n int mux_slot_length_bytes = read_payload_length_info ( latmctx , gb ) ; \n if ( mux_slot_length_bytes * 8 > get_bits_left ( gb ) ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } else if ( mux_slot_length_bytes * 8 + 256 < get_bits_left ( gb ) ) { \n av_log ( latmctx -> aac_ctx . avctx , AV_LOG_ERROR , \n \" \\n \" , \n mux_slot_length_bytes * 8 , get_bits_left ( gb ) ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 11565}
{"project": "FFmpeg", "commit_id": "b3eb4f54c0d091ed518b38a5b90183d0d55fa729", "target": 0, "func": "static int flashsv2_prime ( FlashSVContext * s , uint8_t * src , \n int size , int unp_size ) \n { \n z_stream zs ; \n int zret ; \n zs . zalloc = NULL ; \n zs . zfree = NULL ; \n zs . opaque = NULL ; \n s -> zstream . next_in = src ; \n s -> zstream . avail_in = size ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n deflateInit ( & zs , 0 ) ; \n zs . next_in = s -> tmpblock ; \n zs . avail_in = s -> block_size * 3 - s -> zstream . avail_out ; \n zs . next_out = s -> deflate_block ; \n zs . avail_out = s -> deflate_block_size ; \n deflate ( & zs , Z_SYNC_FLUSH ) ; \n deflateEnd ( & zs ) ; \n if ( ( zret = inflateReset ( & s -> zstream ) ) != Z_OK ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , zret ) ; \n return AVERROR_UNKNOWN ; \n } \n s -> zstream . next_in = s -> deflate_block ; \n s -> zstream . avail_in = s -> deflate_block_size - zs . avail_out ; \n s -> zstream . next_out = s -> tmpblock ; \n s -> zstream . avail_out = s -> block_size * 3 ; \n inflate ( & s -> zstream , Z_SYNC_FLUSH ) ; \n return 0 ; \n }", "idx": 11573}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_qcc ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q , \n uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n properties [ compno ] |= HAD_QCC ; \n return get_qcx ( s , n - 1 , q + compno ) ; \n }", "idx": 11575}
{"project": "FFmpeg", "commit_id": "eabbc64728c2fdb74f565aededec2ab023d20699", "target": 0, "func": "static int mkv_write_tracks ( AVFormatContext * s ) \n { \n MatroskaMuxContext * mkv = s -> priv_data ; \n AVIOContext * dyn_cp , * pb = s -> pb ; \n ebml_master tracks ; \n int i , ret , default_stream_exists = 0 ; \n ret = mkv_add_seekhead_entry ( mkv -> main_seekhead , MATROSKA_ID_TRACKS , avio_tell ( pb ) ) ; \n if ( ret < 0 ) \n return ret ; \n ret = start_ebml_master_crc32 ( pb , & dyn_cp , & tracks , MATROSKA_ID_TRACKS , 0 ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n default_stream_exists |= st -> disposition & AV_DISPOSITION_DEFAULT ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n ret = mkv_write_track ( s , mkv , i , dyn_cp , default_stream_exists ) ; \n if ( ret < 0 ) \n return ret ; \n } \n end_ebml_master_crc32 ( pb , & dyn_cp , mkv , tracks ) ; \n return 0 ; \n }", "idx": 11576}
{"project": "FFmpeg", "commit_id": "7d88586e4728e97349f98e07ff782bb168ab96c3", "target": 1, "func": "static void FUNC ( put_hevc_epel_bi_w_v ) ( uint8_t * _dst , ptrdiff_t _dststride , uint8_t * _src , ptrdiff_t _srcstride , \n int16_t * src2 , \n int height , int denom , int wx0 , int wx1 , \n int ox0 , int ox1 , intptr_t mx , intptr_t my , int width ) \n { \n int x , y ; \n pixel * src = ( pixel * ) _src ; \n ptrdiff_t srcstride = _srcstride / sizeof ( pixel ) ; \n const int8_t * filter = ff_hevc_epel_filters [ my - 1 ] ; \n pixel * dst = ( pixel * ) _dst ; \n ptrdiff_t dststride = _dststride / sizeof ( pixel ) ; \n int shift = 14 + 1 - BIT_DEPTH ; \n int log2Wd = denom + shift - 1 ; \n ox0 = ox0 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n ox1 = ox1 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) \n dst [ x ] = av_clip_pixel ( ( ( EPEL_FILTER ( src , srcstride ) >> ( BIT_DEPTH - 8 ) ) * wx1 + src2 [ x ] * wx0 + \n ( ( ox0 + ox1 + 1 ) << log2Wd ) ) >> ( log2Wd + 1 ) ) ; \n src += srcstride ; \n dst += dststride ; \n src2 += MAX_PB_SIZE ; \n } \n }", "idx": 11582}
{"project": "FFmpeg", "commit_id": "bb99ae3ae924c942a634bec7711ec7ee11c38eb9", "target": 1, "func": "static int init_input ( AVFormatContext * s , const char * filename ) \n { \n int ret ; \n AVProbeData pd = { filename , NULL , 0 } ; \n if ( s -> pb ) { \n s -> flags |= AVFMT_FLAG_CUSTOM_IO ; \n if ( ! s -> iformat ) \n return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , 0 ) ; \n else if ( s -> iformat -> flags & AVFMT_NOFILE ) \n av_log ( s , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n } \n if ( ( s -> iformat && s -> iformat -> flags & AVFMT_NOFILE ) || \n ( ! s -> iformat && ( s -> iformat = av_probe_input_format ( & pd , 0 ) ) ) ) \n if ( ( ret = avio_open ( & s -> pb , filename , AVIO_FLAG_READ ) ) < 0 ) \n return ret ; \n if ( s -> iformat ) \n return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , 0 ) ; \n }", "idx": 11585}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_extension ( GifState * s ) \n { \n ByteIOContext * f = s -> f ; \n int ext_code , ext_len , i , gce_flags , gce_transparent_index ; \n ext_code = get_byte ( f ) ; \n ext_len = get_byte ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , ext_code , ext_len ) ; \n #endif \n switch ( ext_code ) { \n case 0xf9 : \n if ( ext_len != 4 ) \n goto discard_ext ; \n s -> transparent_color_index = -1 ; \n gce_flags = get_byte ( f ) ; \n s -> gce_delay = get_le16 ( f ) ; \n gce_transparent_index = get_byte ( f ) ; \n if ( gce_flags & 0x01 ) \n s -> transparent_color_index = gce_transparent_index ; \n else \n s -> transparent_color_index = -1 ; \n s -> gce_disposal = ( gce_flags >> 2 ) & 0x7 ; \n #ifdef DEBUG \n printf ( \" \\n \" , \n gce_flags , s -> gce_delay , \n s -> transparent_color_index , s -> gce_disposal ) ; \n #endif \n ext_len = get_byte ( f ) ; \n break ; \n } \n discard_ext : \n while ( ext_len != 0 ) { \n for ( i = 0 ; i < ext_len ; i ++ ) \n get_byte ( f ) ; \n ext_len = get_byte ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , ext_len ) ; \n #endif \n } \n return 0 ; \n }", "idx": 11587}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "static HTTPContext * find_rtp_session_with_url ( const char * url , \n const char * session_id ) \n { \n HTTPContext * rtp_c ; \n char path1 [ 1024 ] ; \n const char * path ; \n char buf [ 1024 ] ; \n int s ; \n rtp_c = find_rtp_session ( session_id ) ; \n if ( ! rtp_c ) \n return NULL ; \n url_split ( NULL , 0 , NULL , 0 , NULL , path1 , sizeof ( path1 ) , url ) ; \n path = path1 ; \n if ( * path == ' ' ) \n path ++ ; \n if ( ! strcmp ( path , rtp_c -> stream -> filename ) ) return rtp_c ; \n for ( s = 0 ; s < rtp_c -> stream -> nb_streams ; ++ s ) { \n snprintf ( buf , sizeof ( buf ) , \" \" , \n rtp_c -> stream -> filename , s ) ; \n if ( ! strncmp ( path , buf , sizeof ( buf ) ) ) { \n return rtp_c ; \n } \n } \n return NULL ; \n }", "idx": 11590}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static unsigned tget_long ( const uint8_t * * p , int le ) \n { \n unsigned v = le ? AV_RL32 ( * p ) : AV_RB32 ( * p ) ; \n * p += 4 ; \n return v ; \n }", "idx": 11594}
{"project": "FFmpeg", "commit_id": "ee408eadbadbc629c9ef06f62ddf63643defe541", "target": 0, "func": "static void vertical_filter ( unsigned char * first_pixel , int stride , \n int * bounding_values ) \n { \n int i ; \n int filter_value ; \n for ( i = 0 ; i < 8 ; i ++ , first_pixel ++ ) { \n filter_value = \n ( first_pixel [ - ( 2 * stride ) ] * 1 ) - \n ( first_pixel [ - ( 1 * stride ) ] * 3 ) + \n ( first_pixel [ ( 0 ) ] * 3 ) - \n ( first_pixel [ ( 1 * stride ) ] * 1 ) ; \n filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; \n first_pixel [ - ( 1 * stride ) ] = SATURATE_U8 ( first_pixel [ - ( 1 * stride ) ] + filter_value ) ; \n first_pixel [ 0 ] = SATURATE_U8 ( first_pixel [ 0 ] - filter_value ) ; \n } \n }", "idx": 11632}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel4_mc20_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_4w_msa ( src - 2 , stride , dst , stride , 4 ) ; \n }", "idx": 11643}
{"project": "FFmpeg", "commit_id": "4977e467a50a690a46af5988d568eaab2e5933c7", "target": 0, "func": "static int raw_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n TAKDemuxContext * tc = s -> priv_data ; \n int ret ; \n if ( tc -> mlast_frame ) { \n AVIOContext * pb = s -> pb ; \n int64_t size , left ; \n left = tc -> data_end - avio_tell ( s -> pb ) ; \n size = FFMIN ( left , 1024 ) ; \n if ( size <= 0 ) \n return AVERROR_EOF ; \n ret = av_get_packet ( pb , pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = 0 ; \n } else { \n ret = ff_raw_read_partial_packet ( s , pkt ) ; \n } \n return ret ; \n }", "idx": 11645}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel16_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_16w_msa ( src - ( stride * 2 ) , stride , dst , stride , 16 ) ; \n }", "idx": 11653}
{"project": "FFmpeg", "commit_id": "60b433d905c582ed3656c120b3ffffd0119d5377", "target": 0, "func": "static int mov_write_wave_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n if ( track -> enc -> codec_id != AV_CODEC_ID_QDM2 ) { \n avio_wb32 ( pb , 12 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wl32 ( pb , track -> tag ) ; \n } \n if ( track -> enc -> codec_id == AV_CODEC_ID_AAC ) { \n avio_wb32 ( pb , 12 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n mov_write_esds_tag ( pb , track ) ; \n } else if ( mov_pcm_le_gt16 ( track -> enc -> codec_id ) ) { \n mov_write_enda_tag ( pb ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_AMR_NB ) { \n mov_write_amr_tag ( pb , track ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_AC3 ) { \n mov_write_ac3_tag ( pb , track ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_ALAC || \n track -> enc -> codec_id == AV_CODEC_ID_QDM2 ) { \n mov_write_extradata_tag ( pb , track ) ; \n } else if ( track -> enc -> codec_id == AV_CODEC_ID_ADPCM_MS || \n track -> enc -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { \n mov_write_ms_tag ( pb , track ) ; \n } \n avio_wb32 ( pb , 8 ) ; \n avio_wb32 ( pb , 0 ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 11664}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_stereo ( APEContext * ctx , int count ) \n { \n APEPredictor * p = & ctx -> predictor ; \n int32_t * decoded0 = ctx -> decoded [ 0 ] ; \n int32_t * decoded1 = ctx -> decoded [ 1 ] ; \n while ( count -- ) { \n * decoded0 = predictor_update_filter ( p , * decoded0 , 0 , YDELAYA , YDELAYB , \n YADAPTCOEFFSA , YADAPTCOEFFSB ) ; \n decoded0 ++ ; \n * decoded1 = predictor_update_filter ( p , * decoded1 , 1 , XDELAYA , XDELAYB , \n XADAPTCOEFFSA , XADAPTCOEFFSB ) ; \n decoded1 ++ ; \n p -> buf ++ ; \n if ( p -> buf == p -> historybuffer + HISTORY_SIZE ) { \n memmove ( p -> historybuffer , p -> buf , \n PREDICTOR_SIZE * sizeof ( * p -> historybuffer ) ) ; \n p -> buf = p -> historybuffer ; \n } \n } \n }", "idx": 11677}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice_row ( AVCodecContext * avctx , void * arg , int jobnr , int threadnr ) \n { \n int i ; \n DiracContext * s = avctx -> priv_data ; \n DiracSlice * slices = ( ( DiracSlice * ) arg ) + s -> num_x * jobnr ; \n for ( i = 0 ; i < s -> num_x ; i ++ ) \n decode_hq_slice ( avctx , & slices [ i ] ) ; \n return 0 ; \n }", "idx": 11701}
{"project": "FFmpeg", "commit_id": "0041cdba98d5b636a8d912352dd3d8ca72bba4ce", "target": 0, "func": "int avformat_seek_file ( AVFormatContext * s , int stream_index , int64_t min_ts , int64_t ts , int64_t max_ts , int flags ) \n { \n if ( min_ts > ts || max_ts < ts ) \n return -1 ; \n ff_read_frame_flush ( s ) ; \n if ( s -> iformat -> read_seek2 ) \n return s -> iformat -> read_seek2 ( s , stream_index , min_ts , ts , max_ts , flags ) ; \n if ( s -> iformat -> read_timestamp ) { \n } \n if ( s -> iformat -> read_seek || 1 ) \n return av_seek_frame ( s , stream_index , ts , flags | ( ts - min_ts > ( uint64_t ) ( max_ts - ts ) ? AVSEEK_FLAG_BACKWARD : 0 ) ) ; \n }", "idx": 11706}
{"project": "FFmpeg", "commit_id": "da66b6313e61a861321b7d62a3d12a38877784bb", "target": 1, "func": "static void quantize ( SnowContext * s , SubBand * b , DWTELEM * src , int stride , int bias ) { \n const int level = b -> level ; \n const int w = b -> width ; \n const int h = b -> height ; \n const int qlog = clip ( s -> qlog + b -> qlog , 0 , 128 ) ; \n const int qmul = qexp [ qlog & 7 ] << ( qlog >> 3 ) ; \n int x , y ; \n assert ( QROOT == 8 ) ; \n bias = bias ? 0 : ( 3 * qmul ) >> 3 ; \n if ( ! bias ) { \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n int i = src [ x + y * stride ] ; \n if ( i >= 0 ) { \n i <<= QEXPSHIFT ; \n i /= qmul ; \n src [ x + y * stride ] = i ; \n } else { \n i = - i ; \n i <<= QEXPSHIFT ; \n i /= qmul ; \n src [ x + y * stride ] = - i ; \n } \n } \n } \n } else { \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n int i = src [ x + y * stride ] ; \n if ( i >= 0 ) { \n i <<= QEXPSHIFT ; \n i = ( i + bias ) / qmul ; \n src [ x + y * stride ] = i ; \n } else { \n i = - i ; \n i <<= QEXPSHIFT ; \n i = ( i + bias ) / qmul ; \n src [ x + y * stride ] = - i ; \n } \n } \n } \n } \n }", "idx": 11709}
{"project": "FFmpeg", "commit_id": "1b3b018aa4e43d7bf87df5cdf28c69a9ad5a6cbc", "target": 1, "func": "static inline int get16 ( const uint8_t * * pp , const uint8_t * p_end ) \n { \n const uint8_t * p ; \n int c ; \n p = * pp ; \n if ( ( p + 1 ) >= p_end ) \n return AVERROR_INVALIDDATA ; \n c = AV_RB16 ( p ) ; \n p += 2 ; \n * pp = p ; \n return c ; \n }", "idx": 11722}
{"project": "FFmpeg", "commit_id": "29d1df66adb3723d1e7f2d363984b50792fb7c11", "target": 0, "func": "static inline int l3_unscale ( int value , int exponent ) \n { \n unsigned int m ; \n int e ; \n e = table_4_3_exp [ 4 * value + ( exponent & 3 ) ] ; \n m = table_4_3_value [ 4 * value + ( exponent & 3 ) ] ; \n e -= exponent >> 2 ; \n assert ( e >= 1 ) ; \n if ( e > 31 ) \n return 0 ; \n m = ( m + ( 1 << ( e - 1 ) ) ) >> e ; \n return m ; \n }", "idx": 11727}
{"project": "FFmpeg", "commit_id": "172865931951d73f1ac60f4b56cdb4da77f37f1d", "target": 0, "func": "static int wsaud_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVIOContext * pb = s -> pb ; \n unsigned char preamble [ AUD_CHUNK_PREAMBLE_SIZE ] ; \n unsigned int chunk_size ; \n int ret = 0 ; \n AVStream * st = s -> streams [ 0 ] ; \n if ( avio_read ( pb , preamble , AUD_CHUNK_PREAMBLE_SIZE ) != \n AUD_CHUNK_PREAMBLE_SIZE ) \n return AVERROR ( EIO ) ; \n if ( AV_RL32 ( & preamble [ 4 ] ) != AUD_CHUNK_SIGNATURE ) \n return AVERROR_INVALIDDATA ; \n chunk_size = AV_RL16 ( & preamble [ 0 ] ) ; \n if ( st -> codec -> codec_id == AV_CODEC_ID_WESTWOOD_SND1 ) { \n int out_size = AV_RL16 ( & preamble [ 2 ] ) ; \n if ( ( ret = av_new_packet ( pkt , chunk_size + 4 ) ) ) \n return ret ; \n if ( ( ret = avio_read ( pb , & pkt -> data [ 4 ] , chunk_size ) ) != chunk_size ) \n return ret < 0 ? ret : AVERROR ( EIO ) ; \n AV_WL16 ( & pkt -> data [ 0 ] , out_size ) ; \n AV_WL16 ( & pkt -> data [ 2 ] , chunk_size ) ; \n pkt -> duration = out_size ; \n } else { \n ret = av_get_packet ( pb , pkt , chunk_size ) ; \n if ( ret != chunk_size ) \n return AVERROR ( EIO ) ; \n pkt -> duration = ( chunk_size * 2 ) / st -> codec -> channels ; \n } \n pkt -> stream_index = st -> index ; \n return ret ; \n }", "idx": 11728}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int write_skip_frames ( AVFormatContext * s , int stream_index , int64_t dts ) \n { \n AVIStream * avist = s -> streams [ stream_index ] -> priv_data ; \n AVCodecContext * enc = s -> streams [ stream_index ] -> codec ; \n av_dlog ( s , \" \\n \" , av_ts2str ( dts ) , avist -> packet_count , stream_index ) ; \n while ( enc -> block_align == 0 && dts != AV_NOPTS_VALUE && \n dts > avist -> packet_count && enc -> codec_id != AV_CODEC_ID_XSUB && avist -> packet_count ) { \n AVPacket empty_packet ; \n if ( dts - avist -> packet_count > 60000 ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRId64 \" \\n \" , dts - avist -> packet_count ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_init_packet ( & empty_packet ) ; \n empty_packet . size = 0 ; \n empty_packet . data = NULL ; \n empty_packet . stream_index = stream_index ; \n avi_write_packet ( s , & empty_packet ) ; \n av_dlog ( s , \" \\n \" , av_ts2str ( dts ) , avist -> packet_count ) ; \n } \n return 0 ; \n }", "idx": 11730}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static void convert_matrix ( int * qmat , UINT16 * qmat16 , const UINT16 * quant_matrix , int qscale ) \n { \n int i ; \n if ( av_fdct == jpeg_fdct_ifast ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n qmat [ block_permute_op ( i ) ] = ( int ) ( ( UINT64_C ( 1 ) << ( QMAT_SHIFT + 11 ) ) / \n ( aanscales [ i ] * qscale * quant_matrix [ block_permute_op ( i ) ] ) ) ; \n } \n } else { \n for ( i = 0 ; i < 64 ; i ++ ) { \n qmat [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ i ] ) ; \n qmat16 [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ block_permute_op ( i ) ] ) ; \n } \n } \n }", "idx": 11734}
{"project": "FFmpeg", "commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "target": 1, "func": "static int g2m_init_buffers ( G2MContext * c ) \n { \n int aligned_height ; \n if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { \n c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; \n aligned_height = FFALIGN ( c -> height , 16 ) ; \n av_free ( c -> framebuf ) ; \n c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; \n if ( ! c -> framebuf ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n c -> old_tile_w < c -> tile_width || \n c -> old_tile_h < c -> tile_height ) { \n c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; \n aligned_height = FFALIGN ( c -> tile_height , 16 ) ; \n av_free ( c -> synth_tile ) ; \n av_free ( c -> jpeg_tile ) ; \n av_free ( c -> kempf_buf ) ; \n av_free ( c -> kempf_flags ) ; \n c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; \n c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height \n + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; \n if ( ! c -> synth_tile || ! c -> jpeg_tile || \n ! c -> kempf_buf || ! c -> kempf_flags ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 11737}
{"project": "FFmpeg", "commit_id": "70259737cbad1136d942fa0cca5d55be1ca37e0a", "target": 1, "func": "static void celt_pvq_search ( float * X , int * y , int K , int N ) \n { \n int i ; \n float res = 0.0f , y_norm = 0.0f , xy_norm = 0.0f ; \n for ( i = 0 ; i < N ; i ++ ) \n res += FFABS ( X [ i ] ) ; \n res = K / res ; \n for ( i = 0 ; i < N ; i ++ ) { \n y [ i ] = lrintf ( res * X [ i ] ) ; \n y_norm += y [ i ] * y [ i ] ; \n xy_norm += y [ i ] * X [ i ] ; \n K -= FFABS ( y [ i ] ) ; \n } \n while ( K ) { \n int max_idx = 0 , phase = FFSIGN ( K ) ; \n float max_den = 1.0f , max_num = 0.0f ; \n y_norm += 1.0f ; \n for ( i = 0 ; i < N ; i ++ ) { \n const int ca = 1 ^ ( ( y [ i ] == 0 ) & ( phase < 0 ) ) ; \n float xy_new = xy_norm + 1 * phase * FFABS ( X [ i ] ) ; \n float y_new = y_norm + 2 * phase * FFABS ( y [ i ] ) ; \n xy_new = xy_new * xy_new ; \n if ( ca && ( max_den * xy_new ) > ( y_new * max_num ) ) { \n max_den = y_new ; \n max_num = xy_new ; \n max_idx = i ; \n } \n } \n K -= phase ; \n phase *= FFSIGN ( X [ max_idx ] ) ; \n xy_norm += 1 * phase * X [ max_idx ] ; \n y_norm += 2 * phase * y [ max_idx ] ; \n y [ max_idx ] += phase ; \n } \n }", "idx": 11750}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static int my_log2 ( unsigned int i ) \n { \n unsigned int iLog2 = 0 ; \n while ( ( i >> iLog2 ) > 1 ) \n iLog2 ++ ; \n return iLog2 ; \n }", "idx": 11755}
{"project": "FFmpeg", "commit_id": "ba80b8d29b2adc7fd74324c9bd50cd0be7ab2c21", "target": 0, "func": "static void decode_hrd ( HEVCContext * s , int common_inf_present , \n int max_sublayers ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n int nal_params_present = 0 , vcl_params_present = 0 ; \n int subpic_params_present = 0 ; \n int i ; \n if ( common_inf_present ) { \n nal_params_present = get_bits1 ( gb ) ; \n vcl_params_present = get_bits1 ( gb ) ; \n if ( nal_params_present || vcl_params_present ) { \n subpic_params_present = get_bits1 ( gb ) ; \n if ( subpic_params_present ) { \n skip_bits ( gb , 8 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 1 ) ; \n skip_bits ( gb , 5 ) ; \n } \n skip_bits ( gb , 4 ) ; \n skip_bits ( gb , 4 ) ; \n if ( subpic_params_present ) \n skip_bits ( gb , 4 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 5 ) ; \n } \n } \n for ( i = 0 ; i < max_sublayers ; i ++ ) { \n int low_delay = 0 ; \n unsigned int nb_cpb = 1 ; \n int fixed_rate = get_bits1 ( gb ) ; \n if ( ! fixed_rate ) \n fixed_rate = get_bits1 ( gb ) ; \n if ( fixed_rate ) \n get_ue_golomb_long ( gb ) ; \n else \n low_delay = get_bits1 ( gb ) ; \n if ( ! low_delay ) \n nb_cpb = get_ue_golomb_long ( gb ) + 1 ; \n if ( nal_params_present ) \n decode_sublayer_hrd ( s , nb_cpb , subpic_params_present ) ; \n if ( vcl_params_present ) \n decode_sublayer_hrd ( s , nb_cpb , subpic_params_present ) ; \n } \n }", "idx": 11758}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_16w_msa ( src + stride - 2 , \n src - ( stride * 2 ) , stride , dst , stride , 16 ) ; \n }", "idx": 11775}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static void h261_encode_motion ( H261Context * h , int val ) { \n MpegEncContext * const s = & h -> s ; \n int sign , code ; \n if ( val == 0 ) { \n code = 0 ; \n put_bits ( & s -> pb , h261_mv_tab [ code ] [ 1 ] , h261_mv_tab [ code ] [ 0 ] ) ; \n } \n else { \n if ( val > 16 ) \n val -= 32 ; \n if ( val < -16 ) \n val += 32 ; \n sign = val < 0 ; \n code = sign ? - val : val ; \n put_bits ( & s -> pb , h261_mv_tab [ code ] [ 1 ] , h261_mv_tab [ code ] [ 0 ] ) ; \n put_bits ( & s -> pb , 1 , sign ) ; \n } \n }", "idx": 11783}
{"project": "FFmpeg", "commit_id": "aac46e088d67a390489af686b846dea4987d8ffb", "target": 0, "func": "static void autocorrelate ( const float x [ 40 ] [ 2 ] , float phi [ 3 ] [ 2 ] [ 2 ] , int lag ) \n { \n int i ; \n float real_sum = 0.0f ; \n float imag_sum = 0.0f ; \n if ( lag ) { \n for ( i = 1 ; i < 38 ; i ++ ) { \n real_sum += x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] + x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ; \n imag_sum += x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] - x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ; \n } \n phi [ 2 - lag ] [ 1 ] [ 0 ] = real_sum + x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] + x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ; \n phi [ 2 - lag ] [ 1 ] [ 1 ] = imag_sum + x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] - x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ; \n if ( lag == 1 ) { \n phi [ 0 ] [ 0 ] [ 0 ] = real_sum + x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] + x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ; \n phi [ 0 ] [ 0 ] [ 1 ] = imag_sum + x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] - x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ; \n } \n } else { \n for ( i = 1 ; i < 38 ; i ++ ) { \n real_sum += x [ i ] [ 0 ] * x [ i ] [ 0 ] + x [ i ] [ 1 ] * x [ i ] [ 1 ] ; \n } \n phi [ 2 ] [ 1 ] [ 0 ] = real_sum + x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] + x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ; \n phi [ 1 ] [ 0 ] [ 0 ] = real_sum + x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] + x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ; \n } \n }", "idx": 11788}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_4w_msa ( src - 2 , src - ( stride * 2 ) , stride , dst , stride , 4 ) ; \n }", "idx": 11789}
{"project": "FFmpeg", "commit_id": "a7f6bfdc185a04a703bedd712ee306435372af12", "target": 0, "func": "static void lowpass_line_complex_c ( uint8_t * dstp , ptrdiff_t linesize , \n const uint8_t * srcp , \n ptrdiff_t mref , ptrdiff_t pref ) \n { \n const uint8_t * srcp_above = srcp + mref ; \n const uint8_t * srcp_below = srcp + pref ; \n const uint8_t * srcp_above2 = srcp + mref * 2 ; \n const uint8_t * srcp_below2 = srcp + pref * 2 ; \n int i ; \n for ( i = 0 ; i < linesize ; i ++ ) { \n dstp [ i ] = av_clip_uint8 ( ( 4 + ( srcp [ i ] << 2 ) \n + ( ( srcp [ i ] + srcp_above [ i ] + srcp_below [ i ] ) << 1 ) \n - srcp_above2 [ i ] - srcp_below2 [ i ] ) >> 3 ) ; \n } \n }", "idx": 11790}
{"project": "FFmpeg", "commit_id": "05db409c280acc22362c2e79ea67abe3873043a5", "target": 0, "func": "static int vc1t_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n ByteIOContext * pb = s -> pb ; \n AVStream * st ; \n int fps , frames ; \n frames = get_le24 ( pb ) ; \n if ( get_byte ( pb ) != 0xC5 || get_le32 ( pb ) != 4 ) \n return -1 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return -1 ; \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n st -> codec -> codec_id = CODEC_ID_WMV3 ; \n st -> codec -> extradata = av_malloc ( VC1_EXTRADATA_SIZE ) ; \n st -> codec -> extradata_size = VC1_EXTRADATA_SIZE ; \n get_buffer ( pb , st -> codec -> extradata , VC1_EXTRADATA_SIZE ) ; \n st -> codec -> height = get_le32 ( pb ) ; \n st -> codec -> width = get_le32 ( pb ) ; \n if ( get_le32 ( pb ) != 0xC ) \n return -1 ; \n url_fskip ( pb , 8 ) ; \n fps = get_le32 ( pb ) ; \n if ( fps == -1 ) \n av_set_pts_info ( st , 32 , 1 , 1000 ) ; \n else { \n av_set_pts_info ( st , 24 , 1 , fps ) ; \n st -> duration = frames ; \n } \n return 0 ; \n }", "idx": 11792}
{"project": "FFmpeg", "commit_id": "49e617f9565b6528fe707bae7ea4b62b10c771a5", "target": 0, "func": "static void filter_line_c ( uint8_t * dst , \n uint8_t * prev , uint8_t * cur , uint8_t * next , \n int w , int prefs , int mrefs , int parity , int mode ) \n { \n int x ; \n uint8_t * prev2 = parity ? prev : cur ; \n uint8_t * next2 = parity ? cur : next ; \n for ( x = 0 ; x < w ; x ++ ) { \n int c = cur [ mrefs ] ; \n int d = ( prev2 [ 0 ] + next2 [ 0 ] ) >> 1 ; \n int e = cur [ prefs ] ; \n int temporal_diff0 = FFABS ( prev2 [ 0 ] - next2 [ 0 ] ) ; \n int temporal_diff1 = ( FFABS ( prev [ mrefs ] - c ) + FFABS ( prev [ prefs ] - e ) ) >> 1 ; \n int temporal_diff2 = ( FFABS ( next [ mrefs ] - c ) + FFABS ( next [ prefs ] - e ) ) >> 1 ; \n int diff = FFMAX3 ( temporal_diff0 >> 1 , temporal_diff1 , temporal_diff2 ) ; \n int spatial_pred = ( c + e ) >> 1 ; \n int spatial_score = FFABS ( cur [ mrefs - 1 ] - cur [ prefs - 1 ] ) + FFABS ( c - e ) \n + FFABS ( cur [ mrefs + 1 ] - cur [ prefs + 1 ] ) - 1 ; \n #define CHECK ( j ) \\ \n  \n  { int score = FFABS ( cur [ mrefs - 1 + j ] - cur [ prefs - 1 - j ] ) \n + FFABS ( cur [ mrefs + j ] - cur [ prefs - j ] ) \n + FFABS ( cur [ mrefs + 1 + j ] - cur [ prefs + 1 - j ] ) ; \n if ( score < spatial_score ) { \n spatial_score = score ; \n spatial_pred = ( cur [ mrefs + j ] + cur [ prefs - j ] ) >> 1 ; \n CHECK ( -1 )  CHECK ( -2 )  } } } }", "idx": 11794}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static void qsv_uninit ( AVCodecContext * s ) \n { \n InputStream * ist = s -> opaque ; \n QSVContext * qsv = ist -> hwaccel_ctx ; \n av_freep ( & qsv -> ost -> enc_ctx -> hwaccel_context ) ; \n av_freep ( & s -> hwaccel_context ) ; \n av_buffer_unref ( & qsv -> opaque_surfaces_buf ) ; \n av_freep ( & qsv -> surface_used ) ; \n av_freep ( & qsv -> surface_ptrs ) ; \n av_freep ( & qsv ) ; \n }", "idx": 11796}
{"project": "FFmpeg", "commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "target": 1, "func": "static int hevc_decode_extradata ( HEVCContext * s , uint8_t * buf , int length ) \n { \n int ret , i ; \n ret = ff_hevc_decode_extradata ( buf , length , & s -> ps , & s -> sei , & s -> is_nalff , \n & s -> nal_length_size , s -> avctx -> err_recognition , \n s -> apply_defdispwin , s -> avctx ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> ps . sps_list ) ; i ++ ) { \n if ( s -> ps . sps_list [ i ] ) { \n const HEVCSPS * sps = ( const HEVCSPS * ) s -> ps . sps_list [ i ] -> data ; \n export_stream_params ( s -> avctx , & s -> ps , sps ) ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 11798}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb15 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 11799}
{"project": "FFmpeg", "commit_id": "c780b543e72141393ae3c0b0cb2654f9a5e35f73", "target": 1, "func": "void ff_id3v2_free_extra_meta ( ID3v2ExtraMeta * * extra_meta ) \n { \n ID3v2ExtraMeta * current = * extra_meta , * next ; \n void ( * free_func ) ( ID3v2ExtraMeta * ) ; \n while ( current ) { \n if ( ( free_func = get_extra_meta_func ( current -> tag , 1 ) -> free ) ) \n free_func ( current -> data ) ; \n next = current -> next ; \n av_freep ( & current ) ; \n current = next ; \n } \n }", "idx": 11808}
{"project": "FFmpeg", "commit_id": "c0628919b8c5761d64b1169e8de7584544d15ebf", "target": 0, "func": "static int flv_read_header ( AVFormatContext * s ) \n { \n int flags ; \n FLVContext * flv = s -> priv_data ; \n int offset ; \n avio_skip ( s -> pb , 4 ) ; \n flags = avio_r8 ( s -> pb ) ; \n flv -> missing_streams = flags & ( FLV_HEADER_FLAG_HASVIDEO | FLV_HEADER_FLAG_HASAUDIO ) ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n offset = avio_rb32 ( s -> pb ) ; \n avio_seek ( s -> pb , offset , SEEK_SET ) ; \n avio_skip ( s -> pb , 4 ) ; \n s -> start_time = 0 ; \n flv -> sum_flv_tag_size = 0 ; \n flv -> last_keyframe_stream_index = -1 ; \n return 0 ; \n }", "idx": 11822}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_2r_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 3 ] [ i ] + output [ 4 ] [ i ] + output [ 5 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n memset ( output [ 5 ] , 0 , sizeof ( output [ 5 ] ) ) ; \n }", "idx": 11823}
{"project": "FFmpeg", "commit_id": "7439475e69f333541c3647f6b9eb5b5af073cb64", "target": 0, "func": "int ff_listen_connect ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout , URLContext * h , \n int will_try_next ) \n { \n struct pollfd p = { fd , POLLOUT , 0 } ; \n int ret ; \n socklen_t optlen ; \n ff_socket_nonblock ( fd , 1 ) ; \n while ( ( ret = connect ( fd , addr , addrlen ) ) ) { \n ret = ff_neterrno ( ) ; \n switch ( ret ) { \n case AVERROR ( EINTR ) : \n if ( ff_check_interrupt ( & h -> interrupt_callback ) ) \n return AVERROR_EXIT ; \n continue ; \n case AVERROR ( EINPROGRESS ) : \n case AVERROR ( EAGAIN ) : \n ret = ff_poll_interrupt ( & p , 1 , timeout , & h -> interrupt_callback ) ; \n if ( ret < 0 ) \n return ret ; \n optlen = sizeof ( ret ) ; \n if ( getsockopt ( fd , SOL_SOCKET , SO_ERROR , & ret , & optlen ) ) \n ret = AVUNERROR ( ff_neterrno ( ) ) ; \n if ( ret != 0 ) { \n char errbuf [ 100 ] ; \n ret = AVERROR ( ret ) ; \n av_strerror ( ret , errbuf , sizeof ( errbuf ) ) ; \n if ( will_try_next ) \n av_log ( h , AV_LOG_WARNING , \n \" \\n \" , \n h -> filename , errbuf ) ; \n else \n av_log ( h , AV_LOG_ERROR , \" \\n \" , \n h -> filename , errbuf ) ; \n } \n default : \n return ret ; \n } \n } \n return ret ; \n }", "idx": 11827}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void entropy_decode ( APEContext * ctx , int blockstodecode , int stereo ) \n { \n int32_t * decoded0 = ctx -> decoded [ 0 ] ; \n int32_t * decoded1 = ctx -> decoded [ 1 ] ; \n while ( blockstodecode -- ) { \n * decoded0 ++ = ape_decode_value ( ctx , & ctx -> riceY ) ; \n if ( stereo ) \n * decoded1 ++ = ape_decode_value ( ctx , & ctx -> riceX ) ; \n } \n }", "idx": 11835}
{"project": "FFmpeg", "commit_id": "7ceb9e6b11824ff18f424a35e41fbddf545d1238", "target": 0, "func": "int ff_default_query_formats ( AVFilterContext * ctx ) \n { \n return default_query_formats_common ( ctx , ff_all_channel_layouts ) ; \n }", "idx": 11857}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int uncouple_channels ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int ch , sbnd , bin ; \n int index ; \n float ( * samples ) [ 256 ] ; \n int16_t mantissa ; \n samples = ( float ( * ) [ 256 ] ) ( ( ctx -> bsi . flags & AC3_BSI_LFEON ) ? ( ctx -> samples + 256 ) : ( ctx -> samples ) ) ; \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ab -> chincpl & ( 1 << ch ) ) \n for ( sbnd = ab -> cplbegf ; sbnd < 3 + ab -> cplendf ; sbnd ++ ) \n for ( bin = 0 ; bin < 12 ; bin ++ ) { \n index = sbnd * 12 + bin + 37 ; \n samples [ ch ] [ index ] = ab -> cplcoeffs [ index ] * ab -> cplco [ ch ] [ sbnd ] * ab -> chcoeffs [ ch ] ; \n } \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ( ab -> chincpl & ( 1 << ch ) ) && ( ab -> dithflag & ( 1 << ch ) ) ) \n for ( index = 0 ; index < ab -> endmant [ ch ] ; index ++ ) \n if ( ! ab -> bap [ ch ] [ index ] ) { \n mantissa = dither_int16 ( & ctx -> state ) ; \n samples [ ch ] [ index ] = to_float ( ab -> dexps [ ch ] [ index ] , mantissa ) * ab -> chcoeffs [ ch ] ; \n } \n return 0 ; \n }", "idx": 11858}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void probe_group_enter ( const char * name , int type ) \n { \n int64_t count = -1 ; \n octx . prefix = \n av_realloc ( octx . prefix , sizeof ( PrintElement ) * ( octx . level + 1 ) ) ; \n if ( ! octx . prefix || ! name ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( octx . level ) { \n PrintElement * parent = octx . prefix + octx . level - 1 ; \n if ( parent -> type == ARRAY ) \n count = parent -> nb_elems ; \n parent -> nb_elems ++ ; \n } \n octx . prefix [ octx . level ++ ] = ( PrintElement ) { name , type , count , 0 } ; \n }", "idx": 11862}
{"project": "FFmpeg", "commit_id": "1c02a9732aa2e5ec0eaf83e65044704af05e8400", "target": 1, "func": "static void wmv2_add_block ( Wmv2Context * w , DCTELEM * block1 , uint8_t * dst , int stride , int n ) { \n MpegEncContext * const s = & w -> s ; \n switch ( w -> abt_type_table [ n ] ) { \n case 0 : \n if ( s -> block_last_index [ n ] >= 0 ) { \n s -> dsp . idct_add ( dst , stride , block1 ) ; \n } \n break ; \n case 1 : \n simple_idct84_add ( dst , stride , block1 ) ; \n simple_idct84_add ( dst + 4 * stride , stride , w -> abt_block2 [ n ] ) ; \n memset ( w -> abt_block2 [ n ] , 0 , 64 * sizeof ( DCTELEM ) ) ; \n break ; \n case 2 : \n simple_idct48_add ( dst , stride , block1 ) ; \n simple_idct48_add ( dst + 4 , stride , w -> abt_block2 [ n ] ) ; \n memset ( w -> abt_block2 [ n ] , 0 , 64 * sizeof ( DCTELEM ) ) ; \n break ; \n default : \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n }", "idx": 11866}
{"project": "FFmpeg", "commit_id": "875efafac8afe22971c87fc7dfee83d27364ab50", "target": 0, "func": "static int msrle_decode_init ( AVCodecContext * avctx ) \n { \n MsrleContext * s = ( MsrleContext * ) avctx -> priv_data ; \n int i , j ; \n unsigned char * palette ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n avctx -> has_b_frames = 0 ; \n s -> frame . data [ 0 ] = s -> prev_frame . data [ 0 ] = NULL ; \n palette = ( unsigned char * ) s -> avctx -> extradata ; \n memset ( s -> palette , 0 , 256 * 4 ) ; \n for ( i = 0 , j = 0 ; i < s -> avctx -> extradata_size / 4 ; i ++ , j += 4 ) \n s -> palette [ i ] = \n ( palette [ j + 2 ] << 16 ) | \n ( palette [ j + 1 ] << 8 ) | \n ( palette [ j + 0 ] << 0 ) ; \n return 0 ; \n }", "idx": 11867}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static void mpeg_decode_extension ( AVCodecContext * avctx , \n UINT8 * buf , int buf_size ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n int ext_type ; \n init_get_bits ( & s -> gb , buf , buf_size ) ; \n ext_type = get_bits ( & s -> gb , 4 ) ; \n switch ( ext_type ) { \n case 0x1 : \n mpeg_decode_sequence_extension ( s ) ; \n break ; \n case 0x3 : \n mpeg_decode_quant_matrix_extension ( s ) ; \n break ; \n case 0x8 : \n mpeg_decode_picture_coding_extension ( s ) ; \n break ; \n } \n }", "idx": 11868}
{"project": "FFmpeg", "commit_id": "7fd5aeb3e57389198681a8ab2d5cd5d83a0c5a5f", "target": 0, "func": "static int mp3_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n AVStream * st ; \n int64_t off ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = CODEC_ID_MP3 ; \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n st -> start_time = 0 ; \n ff_id3v1_read ( s ) ; \n ff_id3v2_read ( s ) ; \n off = url_ftell ( s -> pb ) ; \n if ( mp3_parse_vbr_tags ( s , st , off ) < 0 ) \n url_fseek ( s -> pb , off , SEEK_SET ) ; \n return 0 ; \n }", "idx": 11870}
{"project": "FFmpeg", "commit_id": "7ceb9e6b11824ff18f424a35e41fbddf545d1238", "target": 0, "func": "int ff_query_formats_all ( AVFilterContext * ctx ) \n { \n return default_query_formats_common ( ctx , ff_all_channel_counts ) ; \n }", "idx": 11872}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "static void put_pixels_clamped_c ( const int16_t * block , uint8_t * av_restrict pixels , \n ptrdiff_t line_size ) \n { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixels [ 0 ] = av_clip_uint8 ( block [ 0 ] ) ; \n pixels [ 1 ] = av_clip_uint8 ( block [ 1 ] ) ; \n pixels [ 2 ] = av_clip_uint8 ( block [ 2 ] ) ; \n pixels [ 3 ] = av_clip_uint8 ( block [ 3 ] ) ; \n pixels [ 4 ] = av_clip_uint8 ( block [ 4 ] ) ; \n pixels [ 5 ] = av_clip_uint8 ( block [ 5 ] ) ; \n pixels [ 6 ] = av_clip_uint8 ( block [ 6 ] ) ; \n pixels [ 7 ] = av_clip_uint8 ( block [ 7 ] ) ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 11873}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void sws_rgb2rgb_init ( int flags ) { \n #if ( defined ( HAVE_MMX2 ) || defined ( HAVE_3DNOW ) || defined ( HAVE_MMX ) ) && defined ( CONFIG_GPL )  \n  \n  if ( flags & SWS_CPU_CAPS_MMX2 ) \n rgb2rgb_init_MMX2 ( ) ; \n else if ( flags & SWS_CPU_CAPS_3DNOW ) \n rgb2rgb_init_3DNOW ( ) ; \n else if ( flags & SWS_CPU_CAPS_MMX ) \n rgb2rgb_init_MMX ( ) ; \n else \n #endif \n rgb2rgb_init_C ( ) ; \n }", "idx": 11876}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int cmp_intervals ( const void * a , const void * b ) \n { \n const Interval * i1 = a ; \n const Interval * i2 = b ; \n int64_t ts_diff = i1 -> start_ts - i2 -> start_ts ; \n int ret ; \n ret = ts_diff > 0 ? 1 : ts_diff < 0 ? -1 : 0 ; \n return ret == 0 ? i1 -> index - i2 -> index : ret ; \n }", "idx": 11889}
{"project": "FFmpeg", "commit_id": "1b3b018aa4e43d7bf87df5cdf28c69a9ad5a6cbc", "target": 1, "func": "static char * getstr8 ( const uint8_t * * pp , const uint8_t * p_end ) \n { \n int len ; \n const uint8_t * p ; \n char * str ; \n p = * pp ; \n len = get8 ( & p , p_end ) ; \n if ( len < 0 ) \n return NULL ; \n if ( ( p + len ) > p_end ) \n return NULL ; \n str = av_malloc ( len + 1 ) ; \n if ( ! str ) \n return NULL ; \n memcpy ( str , p , len ) ; \n str [ len ] = ' \\0 ' ; \n p += len ; \n * pp = p ; \n return str ; \n }", "idx": 11890}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "func": "int av_buffersrc_add_frame ( AVFilterContext * ctx , AVFrame * frame ) \n { \n BufferSourceContext * s = ctx -> priv ; \n AVFrame * copy ; \n int ret ; \n if ( ! frame ) { \n s -> eof = 1 ; \n return 0 ; \n } else if ( s -> eof ) \n return AVERROR ( EINVAL ) ; \n switch ( ctx -> outputs [ 0 ] -> type ) { \n case AVMEDIA_TYPE_VIDEO : \n CHECK_VIDEO_PARAM_CHANGE ( ctx , s , frame -> width , frame -> height , \n frame -> format ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n CHECK_AUDIO_PARAM_CHANGE ( ctx , s , frame -> sample_rate , frame -> channel_layout , \n frame -> format ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n if ( ! av_fifo_space ( s -> fifo ) && \n ( ret = av_fifo_realloc2 ( s -> fifo , av_fifo_size ( s -> fifo ) + \n sizeof ( copy ) ) ) < 0 ) \n return ret ; \n if ( ! ( copy = av_frame_alloc ( ) ) ) \n return AVERROR ( ENOMEM ) ; \n av_frame_move_ref ( copy , frame ) ; \n if ( ( ret = av_fifo_generic_write ( s -> fifo , & copy , sizeof ( copy ) , NULL ) ) < 0 ) { \n av_frame_move_ref ( frame , copy ) ; \n av_frame_free ( & copy ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 11892}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int flashsv_encode_end ( AVCodecContext * avctx ) \n { \n FlashSVContext * s = avctx -> priv_data ; \n deflateEnd ( & s -> zstream ) ; \n av_free ( s -> encbuffer ) ; \n av_free ( s -> previous_frame ) ; \n av_free ( s -> tmpblock ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 11896}
{"project": "FFmpeg", "commit_id": "a625e13208ad0ebf1554aa73c9bf41452520f176", "target": 0, "func": "static void av_always_inline filter_mb_edgev ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 11898}
{"project": "FFmpeg", "commit_id": "35f9d8c20a26a7d383d3d36796e64a4b8987d743", "target": 0, "func": "static int tta_get_unary ( GetBitContext * gb ) \n { \n int ret = 0 ; \n while ( get_bits1 ( gb ) ) \n ret ++ ; \n return ret ; \n }", "idx": 11902}
{"project": "FFmpeg", "commit_id": "56ee3f9de7b9f6090d599a27d33a392890a2f7b8", "target": 0, "func": "static int copy_chapters ( InputFile * ifile , OutputFile * ofile , int copy_metadata ) \n { \n AVFormatContext * is = ifile -> ctx ; \n AVFormatContext * os = ofile -> ctx ; \n AVChapter * * tmp ; \n int i ; \n tmp = av_realloc ( os -> chapters , sizeof ( * os -> chapters ) * ( is -> nb_chapters + os -> nb_chapters ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n os -> chapters = tmp ; \n for ( i = 0 ; i < is -> nb_chapters ; i ++ ) { \n AVChapter * in_ch = is -> chapters [ i ] , * out_ch ; \n int64_t ts_off = av_rescale_q ( ofile -> start_time - ifile -> ts_offset , \n AV_TIME_BASE_Q , in_ch -> time_base ) ; \n int64_t rt = ( ofile -> recording_time == INT64_MAX ) ? INT64_MAX : \n av_rescale_q ( ofile -> recording_time , AV_TIME_BASE_Q , in_ch -> time_base ) ; \n if ( in_ch -> end < ts_off ) \n continue ; \n if ( rt != INT64_MAX && in_ch -> start > rt + ts_off ) \n break ; \n out_ch = av_mallocz ( sizeof ( AVChapter ) ) ; \n if ( ! out_ch ) \n return AVERROR ( ENOMEM ) ; \n out_ch -> id = in_ch -> id ; \n out_ch -> time_base = in_ch -> time_base ; \n out_ch -> start = FFMAX ( 0 , in_ch -> start - ts_off ) ; \n out_ch -> end = FFMIN ( rt , in_ch -> end - ts_off ) ; \n if ( copy_metadata ) \n av_dict_copy ( & out_ch -> metadata , in_ch -> metadata , 0 ) ; \n os -> chapters [ os -> nb_chapters ++ ] = out_ch ; \n } \n return 0 ; \n }", "idx": 11913}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_vlcs ( FourXContext * f ) { \n static int done = 0 ; \n int i ; \n if ( ! done ) { \n done = 1 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n init_vlc ( & block_type_vlc [ i ] , BLOCK_TYPE_VLC_BITS , 7 , \n & block_type_tab [ i ] [ 0 ] [ 1 ] , 2 , 1 , \n & block_type_tab [ i ] [ 0 ] [ 0 ] , 2 , 1 ) ; \n } \n } \n }", "idx": 11942}
{"project": "FFmpeg", "commit_id": "db56a7507ee7c1e095d2eef451d5a487f614edff", "target": 1, "func": "static inline int draw_glyph_yuv ( AVFilterBufferRef * picref , FT_Bitmap * bitmap , unsigned int x , \n unsigned int y , unsigned int width , unsigned int height , \n const uint8_t yuva_color [ 4 ] , int hsub , int vsub ) \n { \n int r , c , alpha ; \n unsigned int luma_pos , chroma_pos1 , chroma_pos2 ; \n uint8_t src_val ; \n for ( r = 0 ; r < bitmap -> rows && r + y < height ; r ++ ) { \n for ( c = 0 ; c < bitmap -> width && c + x < width ; c ++ ) { \n src_val = GET_BITMAP_VAL ( r , c ) ; \n if ( ! src_val ) \n continue ; \n SET_PIXEL_YUV ( picref , yuva_color , src_val , c + x , y + r , hsub , vsub ) ; \n } \n } \n return 0 ; \n }", "idx": 11943}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "void MPV_frame_end ( MpegEncContext * s ) \n { \n if ( s -> pict_type != B_TYPE && ! s -> intra_only ) { \n if ( s -> avctx == NULL || s -> avctx -> codec -> id != CODEC_ID_MPEG4 || s -> divx_version == 500 ) { \n draw_edges ( s -> current_picture [ 0 ] , s -> linesize , s -> mb_width * 16 , s -> mb_height * 16 , EDGE_WIDTH ) ; \n draw_edges ( s -> current_picture [ 1 ] , s -> linesize / 2 , s -> mb_width * 8 , s -> mb_height * 8 , EDGE_WIDTH / 2 ) ; \n draw_edges ( s -> current_picture [ 2 ] , s -> linesize / 2 , s -> mb_width * 8 , s -> mb_height * 8 , EDGE_WIDTH / 2 ) ; \n } else { \n draw_edges ( s -> current_picture [ 0 ] , s -> linesize , s -> width , s -> height , EDGE_WIDTH ) ; \n draw_edges ( s -> current_picture [ 1 ] , s -> linesize / 2 , s -> width / 2 , s -> height / 2 , EDGE_WIDTH / 2 ) ; \n draw_edges ( s -> current_picture [ 2 ] , s -> linesize / 2 , s -> width / 2 , s -> height / 2 , EDGE_WIDTH / 2 ) ; \n } \n } \n emms_c ( ) ; \n if ( s -> pict_type != B_TYPE ) { \n s -> last_non_b_pict_type = s -> pict_type ; \n s -> last_non_b_qscale = s -> qscale ; \n s -> last_non_b_mc_mb_var = s -> mc_mb_var ; \n s -> num_available_buffers ++ ; \n if ( s -> num_available_buffers > 2 ) s -> num_available_buffers = 2 ; \n } \n }", "idx": 11982}
{"project": "FFmpeg", "commit_id": "28358e466d4f4bc54f8137e0597057f33100b236", "target": 1, "func": "int ff_http_do_new_request ( URLContext * h , const char * uri ) \n { \n HTTPContext * s = h -> priv_data ; \n AVDictionary * options = NULL ; \n int ret ; \n ret = http_shutdown ( h , h -> flags ) ; \n if ( ret < 0 ) \n return ret ; \n s -> end_chunked_post = 0 ; \n s -> chunkend = 0 ; \n s -> off = 0 ; \n s -> icy_data_read = 0 ; \n av_free ( s -> location ) ; \n s -> location = av_strdup ( uri ) ; \n if ( ! s -> location ) \n return AVERROR ( ENOMEM ) ; \n ret = http_open_cnx ( h , & options ) ; \n av_dict_free ( & options ) ; \n return ret ; ", "idx": 11990}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline int dv_rl2vlc_size ( int run , int l ) \n { \n int level = ( l ^ ( l >> 8 ) ) - ( l >> 8 ) ; \n int size ; \n if ( run < DV_VLC_MAP_RUN_SIZE && level < DV_VLC_MAP_LEV_SIZE ) { \n size = dv_vlc_map [ run ] [ level ] . size ; \n } \n else { \n size = ( level < DV_VLC_MAP_LEV_SIZE ) ? dv_vlc_map [ 0 ] [ level ] . size : 16 ; \n if ( run ) { \n size += ( run < 16 ) ? dv_vlc_map [ run - 1 ] [ 0 ] . size : 13 ; \n } \n } \n return size ; \n }", "idx": 12007}
{"project": "FFmpeg", "commit_id": "5650e331a733711b809bc27f968500f0f5530126", "target": 0, "func": "static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) \n { \n uint8_t byte ; \n if ( s -> buf_end - s -> buf < 5 ) \n return AVERROR ( EINVAL ) ; \n c -> nreslevels = bytestream_get_byte ( & s -> buf ) + 1 ; \n if ( c -> nreslevels < s -> reduction_factor ) \n c -> nreslevels2decode = 1 ; \n else \n c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; \n c -> log2_cblk_width = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> log2_cblk_height = bytestream_get_byte ( & s -> buf ) + 2 ; \n c -> cblk_style = bytestream_get_byte ( & s -> buf ) ; \n if ( c -> cblk_style != 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n c -> transform = bytestream_get_byte ( & s -> buf ) ; \n if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) \n c -> transform = FF_DWT97_INT ; \n if ( c -> csty & JPEG2000_CSTY_PREC ) { \n int i ; \n for ( i = 0 ; i < c -> nreslevels ; i ++ ) { \n byte = bytestream_get_byte ( & s -> buf ) ; \n c -> log2_prec_widths [ i ] = byte & 0x0F ; \n c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; \n } \n } \n return 0 ; \n }", "idx": 12010}
{"project": "FFmpeg", "commit_id": "18c6bd098baba1ace8fea946e4bc0c60098f49d4", "target": 0, "func": "static void start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TInterlaceContext * tinterlace = ctx -> priv ; \n if ( tinterlace -> cur ) \n avfilter_unref_buffer ( tinterlace -> cur ) ; \n tinterlace -> cur = tinterlace -> next ; \n tinterlace -> next = picref ; \n }", "idx": 12011}
{"project": "FFmpeg", "commit_id": "26c208cf0ff59efd7786528884a64d35fc42e9bf", "target": 0, "func": "static double compute_target_delay ( double delay , VideoState * is ) \n { \n double sync_threshold , diff ; \n if ( get_master_sync_type ( is ) != AV_SYNC_VIDEO_MASTER ) { \n diff = get_video_clock ( is ) - get_master_clock ( is ) ; \n sync_threshold = FFMAX ( AV_SYNC_THRESHOLD , delay ) ; \n if ( fabs ( diff ) < AV_NOSYNC_THRESHOLD ) { \n if ( diff <= - sync_threshold ) \n delay = 0 ; \n else if ( diff >= sync_threshold ) \n delay = 2 * delay ; \n } \n } \n av_dlog ( NULL , \" \\n \" , \n delay , - diff ) ; \n return delay ; \n }", "idx": 12015}
{"project": "FFmpeg", "commit_id": "8bc396fc0e8769a056375c1c211f389ce0e3ecc5", "target": 1, "func": "static int vp5_parse_header ( VP56Context * s , const uint8_t * buf , int buf_size , \n int * golden_frame ) \n { \n VP56RangeCoder * c = & s -> c ; \n int rows , cols ; \n ff_vp56_init_range_decoder ( & s -> c , buf , buf_size ) ; \n s -> framep [ VP56_FRAME_CURRENT ] -> key_frame = ! vp56_rac_get ( c ) ; \n vp56_rac_get ( c ) ; \n ff_vp56_init_dequant ( s , vp56_rac_gets ( c , 6 ) ) ; \n if ( s -> framep [ VP56_FRAME_CURRENT ] -> key_frame ) \n { \n vp56_rac_gets ( c , 8 ) ; \n if ( vp56_rac_gets ( c , 5 ) > 5 ) \n vp56_rac_gets ( c , 2 ) ; \n if ( vp56_rac_get ( c ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n rows = vp56_rac_gets ( c , 8 ) ; \n cols = vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 8 ) ; \n vp56_rac_gets ( c , 2 ) ; \n if ( ! s -> macroblocks || \n 16 * cols != s -> avctx -> coded_width || \n 16 * rows != s -> avctx -> coded_height ) { \n avcodec_set_dimensions ( s -> avctx , 16 * cols , 16 * rows ) ; \n return 2 ; \n } else if ( ! s -> macroblocks ) \n return 1 ;", "idx": 12063}
{"project": "FFmpeg", "commit_id": "85f477935cd6b34e6ec2716b20e15ce748277a89", "target": 1, "func": "static av_cold int avs_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n return 0 ; \n }", "idx": 12065}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int read_block ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n GetBitContext * gb = & ctx -> gb ; \n * bd -> shift_lsbs = 0 ; \n if ( get_bits1 ( gb ) ) { \n if ( read_var_block_data ( ctx , bd ) ) \n return -1 ; \n } else { \n read_const_block_data ( ctx , bd ) ; \n } \n return 0 ; \n }", "idx": 12067}
{"project": "FFmpeg", "commit_id": "7faafe606fb25e3c8b3091ea0565b01622c87dd2", "target": 1, "func": "static int ftp_passive_mode ( FTPContext * s ) \n { \n char * res = NULL , * start , * end ; \n int i ; \n const char * command = \" \\r \\n \" ; \n const int pasv_codes [ ] = { 227 , 501 , 0 } ; \n if ( ftp_send_command ( s , command , pasv_codes , & res ) != 227 || ! res ) \n goto fail ; \n start = NULL ; \n for ( i = 0 ; i < strlen ( res ) ; ++ i ) { \n if ( res [ i ] == ' ' ) { \n start = res + i + 1 ; \n } else if ( res [ i ] == ' ' ) { \n end = res + i ; \n break ; \n } \n } \n if ( ! start || ! end ) \n goto fail ; \n * end = ' \\0 ' ; \n if ( ! av_strtok ( start , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n start = av_strtok ( end , \" \" , & end ) ; \n if ( ! start ) goto fail ; \n s -> server_data_port = atoi ( start ) * 256 ; \n start = av_strtok ( end , \" \" , & end ) ; \n if ( ! start ) goto fail ; \n s -> server_data_port += atoi ( start ) ; \n av_dlog ( s , \" \\n \" , s -> server_data_port ) ; \n av_free ( res ) ; \n return 0 ; \n fail : \n av_free ( res ) ; \n s -> server_data_port = -1 ; \n return AVERROR ( EIO ) ; \n }", "idx": 12074}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static int swf_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n ByteIOContext * pb = & s -> pb ; \n int nbits , len , frame_rate , tag , v ; \n AVStream * st ; \n if ( ( get_be32 ( pb ) & 0xffffff00 ) != MKBETAG ( ' ' , ' ' , ' ' , 0 ) ) \n return - EIO ; \n get_le32 ( pb ) ; \n nbits = get_byte ( pb ) >> 3 ; \n len = ( 4 * nbits - 3 + 7 ) / 8 ; \n url_fskip ( pb , len ) ; \n frame_rate = get_le16 ( pb ) ; \n get_le16 ( pb ) ; \n for ( ; ; ) { \n tag = get_swf_tag ( pb , & len ) ; \n if ( tag < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return - EIO ; \n } \n if ( tag == TAG_STREAMHEAD ) { \n get_byte ( pb ) ; \n v = get_byte ( pb ) ; \n get_le16 ( pb ) ; \n if ( len != 4 ) \n url_fskip ( pb , len - 4 ) ; \n if ( ( v & 0x20 ) != 0 ) { \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return - ENOMEM ; \n if ( v & 0x01 ) \n st -> codec . channels = 2 ; \n else \n st -> codec . channels = 1 ; \n switch ( ( v >> 2 ) & 0x03 ) { \n case 1 : \n st -> codec . sample_rate = 11025 ; \n break ; \n case 2 : \n st -> codec . sample_rate = 22050 ; \n break ; \n case 3 : \n st -> codec . sample_rate = 44100 ; \n break ; \n default : \n av_free ( st ) ; \n return - EIO ; \n } \n st -> codec . codec_type = CODEC_TYPE_AUDIO ; \n st -> codec . codec_id = CODEC_ID_MP2 ; \n break ; \n } \n } else { \n url_fskip ( pb , len ) ; \n } \n } \n return 0 ; \n }", "idx": 12081}
{"project": "FFmpeg", "commit_id": "3019b4f6480a5d8c38e0e32ef75dabe6e0f3ae98", "target": 0, "func": "static int crystalhd_receive_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n BC_STATUS bc_ret ; \n BC_DTS_STATUS decoder_status = { 0 , } ; \n CopyRet rec_ret ; \n CHDContext * priv = avctx -> priv_data ; \n HANDLE dev = priv -> dev ; \n int got_frame = 0 ; \n av_log ( avctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n bc_ret = DtsGetDriverStatus ( dev , & decoder_status ) ; \n if ( bc_ret != BC_STS_SUCCESS ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( decoder_status . ReadyListCount == 0 ) { \n av_log ( avctx , AV_LOG_INFO , \" \\n \" ) ; \n return AVERROR ( EAGAIN ) ; \n } \n rec_ret = receive_frame ( avctx , frame , & got_frame ) ; \n if ( rec_ret == RET_ERROR ) { \n return -1 ; \n } else if ( got_frame == 0 ) { \n return AVERROR ( EAGAIN ) ; \n } else { \n return 0 ; \n } \n }", "idx": 12084}
{"project": "FFmpeg", "commit_id": "fd09cd08c0ad059ee41ccafc6836a285c1b35c45", "target": 0, "func": "static int seqvideo_decode ( SeqVideoContext * seq , const unsigned char * data , int data_size ) \n { \n const unsigned char * data_end = data + data_size ; \n GetBitContext gb ; \n int flags , i , j , x , y , op ; \n unsigned char c [ 3 ] ; \n unsigned char * dst ; \n uint32_t * palette ; \n flags = * data ++ ; \n if ( flags & 1 ) { \n palette = ( uint32_t * ) seq -> frame . data [ 1 ] ; \n if ( data_end - data < 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < 3 ; j ++ , data ++ ) \n c [ j ] = ( * data << 2 ) | ( * data >> 4 ) ; \n palette [ i ] = AV_RB24 ( c ) ; \n } \n seq -> frame . palette_has_changed = 1 ; \n } \n if ( flags & 2 ) { \n if ( data_end - data < 128 ) \n return AVERROR_INVALIDDATA ; \n init_get_bits ( & gb , data , 128 * 8 ) ; data += 128 ; \n for ( y = 0 ; y < 128 ; y += 8 ) \n for ( x = 0 ; x < 256 ; x += 8 ) { \n dst = & seq -> frame . data [ 0 ] [ y * seq -> frame . linesize [ 0 ] + x ] ; \n op = get_bits ( & gb , 2 ) ; \n switch ( op ) { \n case 1 : \n data = seq_decode_op1 ( seq , data , data_end , dst ) ; \n break ; \n case 2 : \n data = seq_decode_op2 ( seq , data , data_end , dst ) ; \n break ; \n case 3 : \n data = seq_decode_op3 ( seq , data , data_end , dst ) ; \n break ; \n } \n if ( ! data ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 12104}
{"project": "FFmpeg", "commit_id": "22b37f5d3200cfe4c15eded883663cf0612093c1", "target": 0, "func": "static int img_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n VideoData * s = s1 -> priv_data ; \n char filename [ 1024 ] ; \n int ret ; \n ByteIOContext f1 , * f ; \n if ( ! s -> is_pipe ) { \n if ( get_frame_filename ( filename , sizeof ( filename ) , \n s -> path , s -> img_number ) < 0 ) \n return - EIO ; \n f = & f1 ; \n if ( url_fopen ( f , filename , URL_RDONLY ) < 0 ) \n return - EIO ; \n } else { \n f = & s1 -> pb ; \n if ( url_feof ( f ) ) \n return - EIO ; \n } \n av_new_packet ( pkt , s -> img_size ) ; \n pkt -> stream_index = 0 ; \n s -> ptr = pkt -> data ; \n ret = av_read_image ( f , filename , s -> img_fmt , read_packet_alloc_cb , s ) ; \n if ( ! s -> is_pipe ) { \n url_fclose ( f ) ; \n } \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return - EIO ; \n } else { \n pkt -> pts = av_rescale ( ( int64_t ) s -> img_number * s1 -> streams [ 0 ] -> codec . frame_rate_base , s1 -> pts_den , s1 -> streams [ 0 ] -> codec . frame_rate ) / s1 -> pts_num ; \n s -> img_number ++ ; \n return 0 ; \n } \n }", "idx": 12154}
{"project": "FFmpeg", "commit_id": "6706a2986c48e3f20f1274b24345e6555d8f0f48", "target": 1, "func": "static void store_slice_c ( uint8_t * dst , const uint16_t * src , \n int dst_linesize , int src_linesize , \n int width , int height , int log2_scale , \n const uint8_t dither [ 8 ] [ 8 ] ) \n { \n int y , x ; \n #define STORE ( pos )  do {                                                     \\ \n   \n  temp = ( ( src [ x + y * src_linesize + pos ] << log2_scale ) + d [ pos ] ) >> 6 ; \n if ( temp & 0x100 ) \n temp = ~ ( temp >> 31 ) ; \n dst [ x + y * dst_linesize + pos ] = temp ; \n } while ( 0 ) \n for ( y = 0 ; y < height ; y ++ ) { \n const uint8_t * d = dither [ y ] ; \n for ( x = 0 ; x < width ; x += 8 ) { \n int temp ; \n STORE ( 0 ) ; \n STORE ( 1 ) ; \n STORE ( 2 ) ; \n STORE ( 3 ) ; \n STORE ( 4 ) ; \n STORE ( 5 ) ; \n STORE ( 6 ) ; \n STORE ( 7 ) ; \n } \n } \n }", "idx": 12157}
{"project": "FFmpeg", "commit_id": "2ef0f392711445e173a56b2c073dedb021ae3783", "target": 1, "func": "static int rac_get_model_sym ( RangeCoder * c , Model * m ) \n { \n int prob , prob2 , helper , val ; \n int end , end2 ; \n prob = 0 ; \n prob2 = c -> range ; \n c -> range >>= MODEL_SCALE ; \n val = 0 ; \n end = m -> num_syms >> 1 ; \n end2 = m -> num_syms ; \n do { \n helper = m -> freqs [ end ] * c -> range ; \n if ( helper <= c -> low ) { \n val = end ; \n prob = helper ; \n } else { \n end2 = end ; \n prob2 = helper ; \n } \n end = ( end2 + val ) >> 1 ; \n } while ( end != val ) ; \n c -> low -= prob ; \n c -> range = prob2 - prob ; \n if ( c -> range < RAC_BOTTOM ) \n rac_normalise ( c ) ; \n model_update ( m , val ) ; \n return val ; \n }", "idx": 12172}
{"project": "FFmpeg", "commit_id": "84c202cc37024bd78261e4222e46631ea73c48dd", "target": 1, "func": "static int read_len_table ( uint8_t * dst , GetBitContext * gb ) { \n int i , val , repeat ; \n for ( i = 0 ; i < 256 ; ) { \n repeat = get_bits ( gb , 3 ) ; \n val = get_bits ( gb , 5 ) ; \n if ( repeat == 0 ) \n repeat = get_bits ( gb , 8 ) ; \n if ( i + repeat > 256 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n while ( repeat -- ) \n dst [ i ++ ] = val ; \n } \n return 0 ; \n }", "idx": 12179}
{"project": "FFmpeg", "commit_id": "357f2316a08478a4442e8051978c7b161e10281c", "target": 1, "func": "void ff_ivi_inverse_haar_4x4 ( const int32_t * in , int16_t * out , ptrdiff_t pitch , \n const uint8_t * flags ) \n { \n int i , shift , sp1 , sp2 ; \n const int32_t * src ; \n int32_t * dst ; \n int tmp [ 16 ] ; \n int t0 , t1 , t2 , t3 , t4 ; \n #define COMPENSATE ( x )  (x)  \n  \n  src = in ; \n dst = tmp ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( flags [ i ] ) { \n shift = ! ( i & 2 ) ; \n sp1 = src [ 0 ] << shift ; \n sp2 = src [ 4 ] << shift ; \n INV_HAAR4 ( sp1 , sp2 , src [ 8 ] , src [ 12 ] , \n dst [ 0 ] , dst [ 4 ] , dst [ 8 ] , dst [ 12 ] , \n t0 , t1 , t2 , t3 , t4 ) ; \n } else \n dst [ 0 ] = dst [ 4 ] = dst [ 8 ] = dst [ 12 ] = 0 ; \n src ++ ; \n dst ++ ; \n } \n #undef   COMPENSATE  \n  \n  \n  \n  \n  \n  #define COMPENSATE ( x )  (x)  \n  \n  src = tmp ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( ! src [ 0 ] && ! src [ 1 ] && ! src [ 2 ] && ! src [ 3 ] ) { \n memset ( out , 0 , 4 * sizeof ( out [ 0 ] ) ) ; \n } else { \n INV_HAAR4 ( src [ 0 ] , src [ 1 ] , src [ 2 ] , src [ 3 ] , \n out [ 0 ] , out [ 1 ] , out [ 2 ] , out [ 3 ] , \n t0 , t1 , t2 , t3 , t4 ) ; \n } \n src += 4 ; \n out += pitch ; \n } \n #undef   COMPENSATE  \n  \n  }", "idx": 12181}
{"project": "FFmpeg", "commit_id": "6665938ca8b7ad8b7ec77c23e611bb8224e88a90", "target": 0, "func": "static int ty_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n TYDemuxContext * ty = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n TyRecHdr * rec ; \n int64_t rec_size = 0 ; \n int ret = 0 ; \n if ( avio_feof ( pb ) ) \n return AVERROR_EOF ; \n while ( ret <= 0 ) { \n if ( ty -> first_chunk || ty -> cur_rec >= ty -> num_recs ) { \n if ( get_chunk ( s ) < 0 || ty -> num_recs == 0 ) \n return AVERROR_EOF ; \n } \n rec = & ty -> rec_hdrs [ ty -> cur_rec ] ; \n rec_size = rec -> rec_size ; \n ty -> cur_rec ++ ; \n if ( rec_size <= 0 ) \n continue ; \n if ( ty -> cur_chunk_pos + rec -> rec_size > CHUNK_SIZE ) \n return AVERROR_INVALIDDATA ; \n if ( avio_feof ( pb ) ) \n return AVERROR_EOF ; \n switch ( rec -> rec_type ) { \n case VIDEO_ID : \n ret = demux_video ( s , rec , pkt ) ; \n break ; \n case AUDIO_ID : \n ret = demux_audio ( s , rec , pkt ) ; \n break ; \n default : \n ff_dlog ( s , \" \\n \" , rec -> rec_type ) ; \n case 0x01 : \n case 0x02 : \n case 0x03 : \n case 0x05 : \n ty -> cur_chunk_pos += rec -> rec_size ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 12184}
{"project": "FFmpeg", "commit_id": "470de55aa17cb933a21f7e4c4015202eaba7277f", "target": 0, "func": "static inline int check_for_slice ( AVSContext * h ) { \n GetBitContext * gb = & h -> s . gb ; \n int align ; \n if ( h -> mbx ) \n return 0 ; \n align = ( - get_bits_count ( gb ) ) & 7 ; \n if ( ! align && ( show_bits ( gb , 8 ) == 0x80 ) ) \n get_bits ( gb , 8 ) ; \n if ( ( show_bits_long ( gb , 24 + align ) & 0xFFFFFF ) == 0x000001 ) { \n skip_bits_long ( gb , 24 + align ) ; \n h -> stc = get_bits ( gb , 8 ) ; \n decode_slice_header ( h , gb ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 12186}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_display_orientation ( H264Context * h ) \n { \n h -> sei_display_orientation_present = ! get_bits1 ( & h -> gb ) ; \n if ( h -> sei_display_orientation_present ) { \n h -> sei_hflip = get_bits1 ( & h -> gb ) ; \n h -> sei_vflip = get_bits1 ( & h -> gb ) ; \n h -> sei_anticlockwise_rotation = get_bits ( & h -> gb , 16 ) ; \n get_ue_golomb ( & h -> gb ) ; \n skip_bits1 ( & h -> gb ) ; \n } \n return 0 ; \n }", "idx": 12187}
{"project": "FFmpeg", "commit_id": "719dbe86ea0e85b3b89f492c69e10bb0e733bcbb", "target": 0, "func": "static int h261_decode_gob_header ( H261Context * h ) \n { \n unsigned int val ; \n MpegEncContext * const s = & h -> s ; \n if ( ! h -> gob_start_code_skipped ) { \n val = show_bits ( & s -> gb , 15 ) ; \n if ( val ) \n return -1 ; \n skip_bits ( & s -> gb , 16 ) ; \n } \n h -> gob_start_code_skipped = 0 ; \n h -> gob_number = get_bits ( & s -> gb , 4 ) ; \n s -> qscale = get_bits ( & s -> gb , 5 ) ; \n if ( s -> mb_height == 18 ) { \n if ( ( h -> gob_number <= 0 ) || ( h -> gob_number > 12 ) ) \n return -1 ; \n } else { \n if ( ( h -> gob_number != 1 ) && ( h -> gob_number != 3 ) && \n ( h -> gob_number != 5 ) ) \n return -1 ; \n } \n while ( get_bits1 ( & s -> gb ) != 0 ) \n skip_bits ( & s -> gb , 8 ) ; \n if ( s -> qscale == 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( s -> avctx -> err_recognition & ( AV_EF_BITSTREAM | AV_EF_COMPLIANT ) ) \n return -1 ; \n } \n h -> current_mba = 0 ; \n h -> mba_diff = 0 ; \n return 0 ; \n }", "idx": 12191}
{"project": "FFmpeg", "commit_id": "38a4be3fa7a7bb83f0a553577427e916a7bda390", "target": 0, "func": "static int has_decode_delay_been_guessed ( AVStream * st ) \n { \n return st -> codec -> codec_id != CODEC_ID_H264 || \n st -> codec_info_nb_frames >= 6 + st -> codec -> has_b_frames ; \n }", "idx": 12193}
{"project": "FFmpeg", "commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "target": 1, "func": "static int64_t scene_sad8 ( FrameRateContext * s , uint8_t * p1 , int p1_linesize , uint8_t * p2 , int p2_linesize , int height ) \n { \n int64_t sad ; \n int x , y ; \n for ( sad = y = 0 ; y < height ; y += 8 ) { \n for ( x = 0 ; x < p1_linesize ; x += 8 ) { \n sad += s -> sad ( p1 + y * p1_linesize + x , \n p1_linesize , \n p2 + y * p2_linesize + x , \n p2_linesize ) ; \n } \n } \n emms_c ( ) ; \n return sad ; \n }", "idx": 12195}
{"project": "FFmpeg", "commit_id": "8696f254444c2ec24daa570f26feadbd3df911e4", "target": 1, "func": "static int get_slice_offset ( AVCodecContext * avctx , const uint8_t * buf , int n ) \n { \n if ( avctx -> slice_count ) return avctx -> slice_offset [ n ] ; \n else return AV_RL32 ( buf + n * 8 - 4 ) == 1 ? AV_RL32 ( buf + n * 8 ) : AV_RB32 ( buf + n * 8 ) ; \n }", "idx": 12201}
{"project": "FFmpeg", "commit_id": "9c8922acadb5187c274250d6cde653b7bad2559e", "target": 1, "func": "static int tls_read ( URLContext * h , uint8_t * buf , int size ) \n { \n TLSContext * c = h -> priv_data ; \n size_t processed = 0 ; \n int ret = SSLRead ( c -> ssl_context , buf , size , & processed ) ; \n ret = map_ssl_error ( ret , processed ) ; \n if ( ret > 0 ) \n return ret ; \n if ( ret == 0 ) \n return AVERROR_EOF ; \n return print_tls_error ( h , ret ) ; \n }", "idx": 12202}
{"project": "FFmpeg", "commit_id": "4df8bdeef3c8042659147daafad34bd76ad09096", "target": 1, "func": "int ff_wma_run_level_decode ( AVCodecContext * avctx , GetBitContext * gb , \n VLC * vlc , \n const uint16_t * level_table , const uint16_t * run_table , \n int version , WMACoef * ptr , int offset , \n int num_coefs , int block_len , int frame_len_bits , \n int coef_nb_bits ) \n { \n int code , run , level , sign ; \n WMACoef * eptr = ptr + num_coefs ; \n ptr += offset ; \n for ( ; ; ) { \n code = get_vlc2 ( gb , vlc -> table , VLCBITS , VLCMAX ) ; \n if ( code < 0 ) \n return -1 ; \n if ( code == 1 ) { \n break ; \n } else if ( code == 0 ) { \n if ( ! version ) { \n level = get_bits ( gb , coef_nb_bits ) ; \n run = get_bits ( gb , frame_len_bits ) ; \n } else { \n level = ff_wma_get_large_val ( gb ) ; \n if ( get_bits1 ( gb ) ) { \n if ( get_bits1 ( gb ) ) { \n if ( get_bits1 ( gb ) ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } else \n run = get_bits ( gb , frame_len_bits ) + 4 ; \n } else \n run = get_bits ( gb , 2 ) + 1 ; \n } else \n run = 0 ; \n } \n } else { \n run = run_table [ code ] ; \n level = level_table [ code ] ; \n } \n sign = get_bits1 ( gb ) ; \n if ( ! sign ) \n level = - level ; \n ptr += run ; \n if ( ptr >= eptr ) \n { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n break ; \n } \n * ptr ++ = level ; \n if ( ptr >= eptr ) \n break ; \n } \n return 0 ; \n }", "idx": 12206}
{"project": "FFmpeg", "commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "target": 1, "func": "static void blend_frames_c ( BLEND_FUNC_PARAMS ) \n { \n int line , pixel ; \n for ( line = 0 ; line < height ; line ++ ) { \n for ( pixel = 0 ; pixel < width ; pixel ++ ) { \n dst [ pixel ] = ( ( src1 [ pixel ] * factor1 ) + ( src2 [ pixel ] * factor2 ) + 128 ) >> 8 ; \n } \n src1 += src1_linesize ; \n src2 += src2_linesize ; \n dst += dst_linesize ; \n } \n }", "idx": 12208}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void ff_jref_idct1_add ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n dest [ 0 ] = cm [ dest [ 0 ] + ( ( block [ 0 ] + 4 ) >> 3 ) ] ; \n }", "idx": 12214}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int init_file ( AVFormatContext * s , OutputStream * os , int64_t start_ts ) \n { \n int ret , i ; \n ret = avio_open2 ( & os -> out , os -> temp_filename , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n avio_wb32 ( os -> out , 0 ) ; \n avio_wl32 ( os -> out , MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) ; \n for ( i = 0 ; i < os -> nb_extra_packets ; i ++ ) { \n AV_WB24 ( os -> extra_packets [ i ] + 4 , start_ts ) ; \n os -> extra_packets [ i ] [ 7 ] = ( start_ts >> 24 ) & 0x7f ; \n avio_write ( os -> out , os -> extra_packets [ i ] , os -> extra_packet_sizes [ i ] ) ; \n } \n return 0 ; \n }", "idx": 12219}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "static inline void log_input_change ( void * ctx , AVFilterLink * link , AVFilterBufferRef * ref ) \n { \n char old_layout_str [ 16 ] , new_layout_str [ 16 ] ; \n av_get_channel_layout_string ( old_layout_str , sizeof ( old_layout_str ) , \n -1 , link -> channel_layout ) ; \n av_get_channel_layout_string ( new_layout_str , sizeof ( new_layout_str ) , \n -1 , ref -> audio -> channel_layout ) ; \n av_log ( ctx , AV_LOG_INFO , \n \" \" \n \" \" PRId64 \" \\n \" , \n av_get_sample_fmt_name ( link -> format ) , \n old_layout_str , link -> sample_rate , \n av_get_sample_fmt_name ( ref -> format ) , \n new_layout_str , ref -> audio -> sample_rate ) ; \n }", "idx": 12220}
{"project": "FFmpeg", "commit_id": "ca00a7e809a4b9c9fb146403d278964b88d16b85", "target": 1, "func": "static int decode_mime_header ( AMRWBContext * ctx , const uint8_t * buf ) \n { \n ctx -> fr_cur_mode = buf [ 0 ] >> 3 & 0x0F ; \n ctx -> fr_quality = ( buf [ 0 ] & 0x4 ) != 0x4 ; \n return 1 ; \n }", "idx": 12221}
{"project": "FFmpeg", "commit_id": "a4c32c9a63142b602820800742f2d543b58cd278", "target": 1, "func": "static void init_entropy_decoder ( APEContext * ctx ) \n { \n ctx -> CRC = bytestream_get_be32 ( & ctx -> ptr ) ; \n ctx -> frameflags = 0 ; \n if ( ( ctx -> fileversion > 3820 ) && ( ctx -> CRC & 0x80000000 ) ) { \n ctx -> CRC &= ~ 0x80000000 ; \n ctx -> frameflags = bytestream_get_be32 ( & ctx -> ptr ) ; \n } \n ctx -> blocksdecoded = 0 ; \n ctx -> riceX . k = 10 ; \n ctx -> riceX . ksum = ( 1 << ctx -> riceX . k ) * 16 ; \n ctx -> riceY . k = 10 ; \n ctx -> riceY . ksum = ( 1 << ctx -> riceY . k ) * 16 ; \n ctx -> ptr ++ ; \n range_start_decoding ( ctx ) ; \n }", "idx": 12222}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static void get_sub_picture ( CinepakEncContext * s , int x , int y , AVPicture * in , AVPicture * out ) \n { \n out -> data [ 0 ] = in -> data [ 0 ] + x + y * in -> linesize [ 0 ] ; \n out -> linesize [ 0 ] = in -> linesize [ 0 ] ; \n if ( s -> pix_fmt == AV_PIX_FMT_YUV420P ) { \n out -> data [ 1 ] = in -> data [ 1 ] + ( x >> 1 ) + ( y >> 1 ) * in -> linesize [ 1 ] ; \n out -> linesize [ 1 ] = in -> linesize [ 1 ] ; \n out -> data [ 2 ] = in -> data [ 2 ] + ( x >> 1 ) + ( y >> 1 ) * in -> linesize [ 2 ] ; \n out -> linesize [ 2 ] = in -> linesize [ 2 ] ; \n } \n }", "idx": 12227}
{"project": "FFmpeg", "commit_id": "963f76144897d3f7684d82ec21e51dd50ea1106e", "target": 1, "func": "static av_always_inline int even ( uint64_t layout ) \n { \n return ( ! layout || ( layout & ( layout - 1 ) ) ) ; \n }", "idx": 12236}
{"project": "FFmpeg", "commit_id": "44729bc0204fd8bdc29c234fc663229e44420b09", "target": 1, "func": "static int64_t mkv_write_seekhead ( AVIOContext * pb , mkv_seekhead * seekhead ) \n { \n ebml_master metaseek , seekentry ; \n int64_t currentpos ; \n int i ; \n currentpos = avio_tell ( pb ) ; \n if ( seekhead -> reserved_size > 0 ) \n if ( avio_seek ( pb , seekhead -> filepos , SEEK_SET ) < 0 ) \n return -1 ; \n metaseek = start_ebml_master ( pb , MATROSKA_ID_SEEKHEAD , seekhead -> reserved_size ) ; \n for ( i = 0 ; i < seekhead -> num_entries ; i ++ ) { \n mkv_seekhead_entry * entry = & seekhead -> entries [ i ] ; \n seekentry = start_ebml_master ( pb , MATROSKA_ID_SEEKENTRY , MAX_SEEKENTRY_SIZE ) ; \n put_ebml_id ( pb , MATROSKA_ID_SEEKID ) ; \n put_ebml_num ( pb , ebml_id_size ( entry -> elementid ) , 0 ) ; \n put_ebml_id ( pb , entry -> elementid ) ; \n put_ebml_uint ( pb , MATROSKA_ID_SEEKPOSITION , entry -> segmentpos ) ; \n end_ebml_master ( pb , seekentry ) ; \n } \n end_ebml_master ( pb , metaseek ) ; \n if ( seekhead -> reserved_size > 0 ) { \n uint64_t remaining = seekhead -> filepos + seekhead -> reserved_size - avio_tell ( pb ) ; \n put_ebml_void ( pb , remaining ) ; \n avio_seek ( pb , currentpos , SEEK_SET ) ; \n currentpos = seekhead -> filepos ; \n } \n av_free ( seekhead -> entries ) ; \n av_free ( seekhead ) ; \n return currentpos ; \n }", "idx": 12238}
{"project": "FFmpeg", "commit_id": "c2a016ad4d9c29285813ba5806189e63e063e0fb", "target": 1, "func": "static int wavpack_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n WavpackContext * s = avctx -> priv_data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n int frame_size ; \n int samplecount = 0 ; \n s -> block = 0 ; \n s -> samples_left = 0 ; \n s -> ch_offset = 0 ; \n if ( s -> mkv_mode ) { \n s -> samples = AV_RL32 ( buf ) ; buf += 4 ; \n } \n while ( buf_size > 0 ) { \n if ( ! s -> multichannel ) { \n frame_size = buf_size ; \n } else { \n if ( ! s -> mkv_mode ) { \n frame_size = AV_RL32 ( buf ) - 12 ; buf += 4 ; buf_size -= 4 ; \n } else { \n if ( buf_size < 12 ) \n break ; \n frame_size = AV_RL32 ( buf + 8 ) + 12 ; \n } \n } \n if ( frame_size < 0 || frame_size > buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n s -> block , frame_size , buf_size ) ; \n return -1 ; \n } \n if ( ( samplecount = wavpack_decode_block ( avctx , s -> block , data , \n data_size , buf , frame_size ) ) < 0 ) \n return -1 ; \n s -> block ++ ; \n buf += frame_size ; buf_size -= frame_size ; \n } \n * data_size = samplecount * avctx -> channels ; \n return s -> samples_left > 0 ? 0 : avpkt -> size ; \n }", "idx": 12239}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int get_bits ( J2kDecoderContext * s , int n ) \n { \n int res = 0 ; \n if ( s -> buf_end - s -> buf < ( ( n - s -> bit_index ) >> 8 ) ) \n return AVERROR ( EINVAL ) ; \n while ( -- n >= 0 ) { \n res <<= 1 ; \n if ( s -> bit_index == 0 ) { \n s -> bit_index = 7 + ( * s -> buf != 0xff ) ; \n s -> buf ++ ; \n } \n s -> bit_index -- ; \n res |= ( * s -> buf >> s -> bit_index ) & 1 ; \n } \n return res ; \n }", "idx": 12240}
{"project": "FFmpeg", "commit_id": "19e95b88459e879d3e67a66350d937c32ed762ca", "target": 1, "func": "static inline void xan_wc3_copy_pixel_run ( XanContext * s , \n int x , int y , int pixel_count , int motion_x , int motion_y ) \n { \n int stride ; \n int line_inc ; \n int curframe_index , prevframe_index ; \n int curframe_x , prevframe_x ; \n int width = s -> avctx -> width ; \n unsigned char * palette_plane , * prev_palette_plane ; \n palette_plane = s -> current_frame . data [ 0 ] ; \n prev_palette_plane = s -> last_frame . data [ 0 ] ; \n stride = s -> current_frame . linesize [ 0 ] ; \n line_inc = stride - width ; \n curframe_index = y * stride + x ; \n curframe_x = x ; \n prevframe_index = ( y + motion_y ) * stride + x + motion_x ; \n prevframe_x = x + motion_x ; \n while ( pixel_count && ( curframe_index < s -> frame_size ) ) { \n int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ; \n memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ; \n pixel_count -= count ; \n curframe_index += count ; \n prevframe_index += count ; \n curframe_x += count ; \n prevframe_x += count ; \n if ( curframe_x >= width ) { \n curframe_index += line_inc ; \n curframe_x = 0 ; \n } \n if ( prevframe_x >= width ) { \n prevframe_index += line_inc ; \n prevframe_x = 0 ; \n } \n } \n }", "idx": 12246}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block ( GetBitContext * gb , DCTELEM * block , const uint8_t * scan , \n const uint32_t * quant ) { \n int coeff , i , n ; \n int8_t ac ; \n uint8_t dc = get_bits ( gb , 8 ) ; \n if ( dc == 255 ) \n coeff = get_bits ( gb , 6 ) ; \n memset ( block , 0 , 64 * sizeof ( DCTELEM ) ) ; \n while ( coeff ) { \n ac = get_sbits ( gb , 2 ) ; \n if ( ac == -2 ) \n break ; \n PUT_COEFF ( ac ) ; \n } \n ALIGN ( 4 ) ; \n if ( get_bits_count ( gb ) + ( coeff << 2 ) >= gb -> size_in_bits ) \n while ( coeff ) { \n ac = get_sbits ( gb , 4 ) ; \n if ( ac == -8 ) \n break ; \n PUT_COEFF ( ac ) ; \n } \n ALIGN ( 8 ) ; \n if ( get_bits_count ( gb ) + ( coeff << 3 ) >= gb -> size_in_bits ) \n while ( coeff ) { \n ac = get_sbits ( gb , 8 ) ; \n PUT_COEFF ( ac ) ; \n } \n PUT_COEFF ( dc ) ; \n return 1 ; \n }", "idx": 12249}
{"project": "FFmpeg", "commit_id": "6bde1e9d14ff1e0ecff74b8ff59607f545c6f2ec", "target": 0, "func": "static int can_merge_formats ( AVFilterFormats * a_arg , \n AVFilterFormats * b_arg , \n enum AVMediaType type , \n int is_sample_rate ) \n { \n AVFilterFormats * a , * b , * ret ; \n if ( a == b ) \n return 1 ; \n a = clone_filter_formats ( a_arg ) ; \n b = clone_filter_formats ( b_arg ) ; \n if ( is_sample_rate ) { \n ret = ff_merge_samplerates ( a , b ) ; \n } else { \n ret = ff_merge_formats ( a , b , type ) ; \n } \n if ( ret ) { \n av_freep ( & ret -> formats ) ; \n av_freep ( & ret ) ; \n return 1 ; \n } else { \n av_freep ( & a -> formats ) ; \n av_freep ( & b -> formats ) ; \n av_freep ( & a ) ; \n av_freep ( & b ) ; \n return 0 ; \n } \n }", "idx": 12251}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static uint8_t get_sot ( J2kDecoderContext * s ) \n { \n if ( s -> buf_end - s -> buf < 4 ) \n return AVERROR ( EINVAL ) ; \n s -> curtileno = bytestream_get_be16 ( & s -> buf ) ; \n if ( ( unsigned ) s -> curtileno >= s -> numXtiles * s -> numYtiles ) { \n s -> curtileno = 0 ; \n return AVERROR ( EINVAL ) ; \n } \n s -> buf += 4 ; \n if ( ! bytestream_get_byte ( & s -> buf ) ) { \n J2kTile * tile = s -> tile + s -> curtileno ; \n memcpy ( tile -> codsty , s -> codsty , s -> ncomponents * sizeof ( J2kCodingStyle ) ) ; \n memcpy ( tile -> qntsty , s -> qntsty , s -> ncomponents * sizeof ( J2kQuantStyle ) ) ; \n } \n bytestream_get_byte ( & s -> buf ) ; \n return 0 ; \n }", "idx": 12254}
{"project": "FFmpeg", "commit_id": "eae63e3c156f784ee0612422f0c95131ea913c14", "target": 1, "func": "static int get_qcc ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q , \n uint8_t * properties ) \n { \n int compno ; \n if ( bytestream2_get_bytes_left ( & s -> g ) < 1 ) \n return AVERROR_INVALIDDATA ; \n compno = bytestream2_get_byteu ( & s -> g ) ; \n properties [ compno ] |= HAD_QCC ; \n return get_qcx ( s , n - 1 , q + compno ) ; \n }", "idx": 12274}
{"project": "FFmpeg", "commit_id": "5e1bf9d8c0d2cdbbf17b06a5dfdf87a635b3203b", "target": 1, "func": "static int copy_packet_data ( AVPacket * pkt , const AVPacket * src , int dup ) \n { \n pkt -> data = NULL ; \n pkt -> side_data = NULL ; \n if ( pkt -> buf ) { \n AVBufferRef * ref = av_buffer_ref ( src -> buf ) ; \n if ( ! ref ) \n return AVERROR ( ENOMEM ) ; \n pkt -> buf = ref ; \n pkt -> data = ref -> data ; \n } else { \n DUP_DATA ( pkt -> data , src -> data , pkt -> size , 1 , ALLOC_BUF ) ; \n } \n if ( pkt -> side_data_elems && dup ) \n pkt -> side_data = src -> side_data ; \n if ( pkt -> side_data_elems && ! dup ) { \n return av_copy_packet_side_data ( pkt , src ) ; \n } \n return 0 ; \n failed_alloc : \n av_packet_unref ( pkt ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 12282}
{"project": "FFmpeg", "commit_id": "928cfc7e4f42aa283bb1bd9a50f0b3caa5a0f7a5", "target": 1, "func": "static void ffm_seek1 ( AVFormatContext * s , int64_t pos1 ) \n { \n FFMContext * ffm = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int64_t pos ; \n pos = FFMIN ( pos1 , ffm -> file_size - FFM_PACKET_SIZE ) ; \n pos = FFMAX ( pos , FFM_PACKET_SIZE ) ; \n av_dlog ( s , \" \" PRIx64 \" \" PRIx64 \" \\n \" , pos1 , pos ) ; \n avio_seek ( pb , pos , SEEK_SET ) ; \n }", "idx": 12283}
{"project": "FFmpeg", "commit_id": "2bd8eb05d21b582d627a93852b59cb3cfc305dae", "target": 1, "func": "static inline void dxt5_block_internal ( uint8_t * dst , ptrdiff_t stride , \n const uint8_t * block ) \n { \n int x , y ; \n uint32_t colors [ 4 ] ; \n uint8_t alpha_indices [ 16 ] ; \n uint16_t color0 = AV_RL16 ( block + 8 ) ; \n uint16_t color1 = AV_RL16 ( block + 10 ) ; \n uint32_t code = AV_RL32 ( block + 12 ) ; \n uint8_t alpha0 = * ( block ) ; \n uint8_t alpha1 = * ( block + 1 ) ; \n decompress_indices ( alpha_indices , block + 2 ) ; \n extract_color ( colors , color0 , color1 , 1 , 0 ) ; \n for ( y = 0 ; y < 4 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ ) { \n int alpha_code = alpha_indices [ x + y * 4 ] ; \n uint32_t pixel ; \n uint8_t alpha ; \n if ( alpha_code == 0 ) { \n alpha = alpha0 ; \n } else if ( alpha_code == 1 ) { \n alpha = alpha1 ; \n } else { \n if ( alpha0 > alpha1 ) { \n alpha = ( uint8_t ) ( ( ( 8 - alpha_code ) * alpha0 + \n ( alpha_code - 1 ) * alpha1 ) / 7 ) ; \n } else { \n if ( alpha_code == 6 ) { \n alpha = 0 ; \n } else if ( alpha_code == 7 ) { \n alpha = 255 ; \n } else { \n alpha = ( uint8_t ) ( ( ( 6 - alpha_code ) * alpha0 + \n ( alpha_code - 1 ) * alpha1 ) / 5 ) ; \n } \n } \n } \n pixel = colors [ code & 3 ] | ( alpha << 24 ) ; \n code >>= 2 ; \n AV_WL32 ( dst + x * 4 , pixel ) ; \n } \n dst += stride ; \n } \n }", "idx": 12285}
{"project": "FFmpeg", "commit_id": "1693336aed3988e0c13ad1ff880257d80d6ae69d", "target": 1, "func": "static double lfo_get_value ( SimpleLFO * lfo ) \n { \n double phs = FFMIN ( 100 , lfo -> phase / FFMIN ( 1.99 , FFMAX ( 0.01 , lfo -> pwidth ) ) + lfo -> offset ) ; \n double val ; \n if ( phs > 1 ) \n phs = fmod ( phs , 1. ) ; \n switch ( lfo -> mode ) { \n case SINE : \n val = sin ( phs * 2 * M_PI ) ; \n break ; \n case TRIANGLE : \n if ( phs > 0.75 ) \n val = ( phs - 0.75 ) * 4 - 1 ; \n else if ( phs > 0.25 ) \n val = -4 * phs + 2 ; \n else \n val = phs * 4 ; \n break ; \n case SQUARE : \n val = phs < 0.5 ? -1 : +1 ; \n break ; \n case SAWUP : \n val = phs * 2 - 1 ; \n break ; \n case SAWDOWN : \n val = 1 - phs * 2 ; \n break ; \n } \n return val * lfo -> amount ; \n }", "idx": 12291}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_get_duration ( uint8_t * * buf ) \n { \n int i , duration = 0 ; \n for ( i = 0 ; i < 2 && ! duration ; i ++ ) { \n int s_hour , s_min , s_sec , s_hsec , e_hour , e_min , e_sec , e_hsec ; \n if ( sscanf ( * buf , \" \" , \n & s_hour , & s_min , & s_sec , & s_hsec , \n & e_hour , & e_min , & e_sec , & e_hsec ) == 8 ) { \n s_min += 60 * s_hour ; e_min += 60 * e_hour ; \n s_sec += 60 * s_min ; e_sec += 60 * e_min ; \n s_hsec += 1000 * s_sec ; e_hsec += 1000 * e_sec ; \n duration = e_hsec - s_hsec ; \n } \n * buf += strcspn ( * buf , \" \\n \" ) + 1 ; \n } \n return duration ; \n }", "idx": 12292}
{"project": "FFmpeg", "commit_id": "d574e22659bd51cdf16723a204fef65a9e783f1d", "target": 0, "func": "static int hdcd_scan ( HDCDContext * ctx , hdcd_state_t * state , const int32_t * samples , int max , int stride ) \n { \n int cdt_active = 0 ; \n int result ; \n if ( state -> sustain > 0 ) { \n cdt_active = 1 ; \n if ( state -> sustain <= max ) { \n state -> control = 0 ; \n max = state -> sustain ; \n } \n state -> sustain -= max ; \n } \n result = 0 ; \n while ( result < max ) { \n int flag ; \n int consumed = hdcd_integrate ( ctx , state , & flag , samples , max - result , stride ) ; \n result += consumed ; \n if ( flag > 0 ) { \n hdcd_sustain_reset ( state ) ; \n break ; \n } \n samples += consumed * stride ; \n } \n if ( cdt_active && state -> sustain == 0 ) \n state -> count_sustain_expired ++ ; \n return result ; \n }", "idx": 12294}
{"project": "FFmpeg", "commit_id": "d3e18ad02795f9761b7e5a5c018dfef786046acf", "target": 0, "func": "static int swf_write_audio ( AVFormatContext * s , \n AVCodecContext * enc , const uint8_t * buf , int size ) \n { \n SWFContext * swf = s -> priv_data ; \n int c = 0 ; \n if ( swf -> swf_frame_number >= 16000 ) { \n return 0 ; \n } \n if ( enc -> codec_id == CODEC_ID_MP3 ) { \n for ( c = 0 ; c < size ; c ++ ) { \n swf -> audio_fifo [ ( swf -> audio_out_pos + c ) % AUDIO_FIFO_SIZE ] = buf [ c ] ; \n } \n swf -> audio_size += size ; \n swf -> audio_out_pos += size ; \n swf -> audio_out_pos %= AUDIO_FIFO_SIZE ; \n } \n if ( swf -> video_type == 0 ) { \n swf_write_video ( s , enc , 0 , 0 ) ; \n } \n return 0 ; \n }", "idx": 12295}
{"project": "FFmpeg", "commit_id": "de1b1a7da9e6ddf42447271e519099a88b389e4a", "target": 0, "func": "static int64_t mp3_sync ( AVFormatContext * s , int64_t target_pos , int flags ) \n { \n int dir = ( flags & AVSEEK_FLAG_BACKWARD ) ? -1 : 1 ; \n int64_t best_pos ; \n int best_score , i , j ; \n int64_t ret ; \n avio_seek ( s -> pb , FFMAX ( target_pos - SEEK_WINDOW , 0 ) , SEEK_SET ) ; \n ret = avio_seek ( s -> pb , target_pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n #define MIN_VALID  3  \n  \n  best_pos = target_pos ; \n best_score = 999 ; \n for ( i = 0 ; i < SEEK_WINDOW ; i ++ ) { \n int64_t pos = target_pos + ( dir > 0 ? i - SEEK_WINDOW / 4 : - i ) ; \n int64_t candidate = -1 ; \n int score = 999 ; \n if ( pos < 0 ) \n continue ; \n for ( j = 0 ; j < MIN_VALID ; j ++ ) { \n ret = check ( s -> pb , pos ) ; \n if ( ret < 0 ) \n break ; \n if ( ( target_pos - pos ) * dir <= 0 && abs ( MIN_VALID / 2 - j ) < score ) { \n candidate = pos ; \n score = abs ( MIN_VALID / 2 - j ) ; \n } \n pos += ret ; \n } \n if ( best_score > score && j == MIN_VALID ) { \n best_pos = candidate ; \n best_score = score ; \n if ( score == 0 ) \n break ; \n } \n } \n return avio_seek ( s -> pb , best_pos , SEEK_SET ) ; \n }", "idx": 12296}
{"project": "FFmpeg", "commit_id": "3ebc7e04dea6072400d91c1c90eb3911754cee06", "target": 0, "func": "static void filter_mb_edgecv ( H264Context * h , uint8_t * pix , int stride , int bS [ 4 ] , int qp ) { \n int i , d ; \n const int index_a = clip ( qp + h -> slice_alpha_c0_offset , 0 , 51 ) ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ clip ( qp + h -> slice_beta_offset , 0 , 51 ) ] ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( bS [ i ] == 0 ) { \n pix += 2 * stride ; \n continue ; \n } \n for ( d = 0 ; d < 2 ; d ++ ) \n { \n const uint8_t p0 = pix [ -1 ] ; \n const uint8_t p1 = pix [ -2 ] ; \n const uint8_t q0 = pix [ 0 ] ; \n const uint8_t q1 = pix [ 1 ] ; \n if ( abs ( p0 - q0 ) >= alpha || \n abs ( p1 - p0 ) >= beta || \n abs ( q1 - q0 ) >= beta ) { \n pix += stride ; \n continue ; \n } \n if ( bS [ i ] < 4 ) { \n const int tc = tc0_table [ index_a ] [ bS [ i ] - 1 ] + 1 ; \n const int i_delta = clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ -1 ] = clip ( p0 + i_delta , 0 , 255 ) ; \n pix [ 0 ] = clip ( q0 - i_delta , 0 , 255 ) ; \n } else { \n pix [ -1 ] = ( 2 * p1 + p0 + q1 + 2 ) >> 2 ; \n pix [ 0 ] = ( 2 * q1 + q0 + p1 + 2 ) >> 2 ; \n } \n pix += stride ; \n } \n } \n }", "idx": 12316}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xbm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n return 0 ; \n }", "idx": 12332}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { \n long i ; \n for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { \n long a = * ( long * ) ( src + i ) ; \n long b = * ( long * ) ( dst + i ) ; \n * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; \n } \n for ( ; i < w ; i ++ ) \n dst [ i + 0 ] += src [ i + 0 ] ; \n }", "idx": 12336}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_audio ( DBEContext * s , int start , int end , int seg_id ) \n { \n int ch , ret , key = parse_key ( s ) ; \n for ( ch = start ; ch < end ; ch ++ ) { \n if ( ! s -> ch_size [ ch ] ) { \n s -> channels [ seg_id ] [ ch ] . nb_groups = 0 ; \n continue ; \n } \n if ( ( ret = convert_input ( s , s -> ch_size [ ch ] , key ) ) < 0 ) \n return ret ; \n if ( ( ret = parse_channel ( s , ch , seg_id ) ) < 0 ) { \n if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) \n return ret ; \n s -> channels [ seg_id ] [ ch ] . nb_groups = 0 ; \n } \n skip_input ( s , s -> ch_size [ ch ] ) ; \n } \n skip_input ( s , 1 ) ; \n return 0 ; \n }", "idx": 12338}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgecv ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = 52 + qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> s . dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 12341}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vc1_end_frame ( AVCodecContext * avctx ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n int ret = ff_nvdec_end_frame ( avctx ) ; \n ctx -> bitstream = NULL ; \n return ret ; \n }", "idx": 12350}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int qtrle_decode_init ( AVCodecContext * avctx ) \n { \n QtrleContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n switch ( avctx -> bits_per_sample ) { \n case 1 : \n case 2 : \n case 4 : \n case 8 : \n case 33 : \n case 34 : \n case 36 : \n case 40 : \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n break ; \n case 16 : \n avctx -> pix_fmt = PIX_FMT_RGB555 ; \n break ; \n case 24 : \n avctx -> pix_fmt = PIX_FMT_RGB24 ; \n break ; \n case 32 : \n avctx -> pix_fmt = PIX_FMT_RGB32 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> bits_per_sample ) ; \n break ; \n } \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 12354}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc_part ( VP8Context * s , uint8_t * dst [ 3 ] , \n AVFrame * ref_frame , int x_off , int y_off , \n int bx_off , int by_off , \n int block_w , int block_h , \n int width , int height , VP56mv * mv ) \n { \n VP56mv uvmv = * mv ; \n vp8_mc ( s , 1 , dst [ 0 ] + by_off * s -> linesize + bx_off , \n ref_frame -> data [ 0 ] , mv , x_off + bx_off , y_off + by_off , \n block_w , block_h , width , height , s -> linesize , \n s -> put_pixels_tab [ block_w == 8 ] ) ; \n if ( s -> profile == 3 ) { \n uvmv . x &= ~ 7 ; \n uvmv . y &= ~ 7 ; \n } \n x_off >>= 1 ; y_off >>= 1 ; \n bx_off >>= 1 ; by_off >>= 1 ; \n width >>= 1 ; height >>= 1 ; \n block_w >>= 1 ; block_h >>= 1 ; \n vp8_mc ( s , 0 , dst [ 1 ] + by_off * s -> uvlinesize + bx_off , \n ref_frame -> data [ 1 ] , & uvmv , x_off + bx_off , y_off + by_off , \n block_w , block_h , width , height , s -> uvlinesize , \n s -> put_pixels_tab [ 1 + ( block_w == 4 ) ] ) ; \n vp8_mc ( s , 0 , dst [ 2 ] + by_off * s -> uvlinesize + bx_off , \n ref_frame -> data [ 2 ] , & uvmv , x_off + bx_off , y_off + by_off , \n block_w , block_h , width , height , s -> uvlinesize , \n s -> put_pixels_tab [ 1 + ( block_w == 4 ) ] ) ; \n }", "idx": 12355}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline int halfpel_motion_search ( MpegEncContext * s , \n int * mx_ptr , int * my_ptr , int dmin , \n int xmin , int ymin , int xmax , int ymax , \n int pred_x , int pred_y , uint8_t * ref_picture ) \n { \n UINT16 * mv_penalty = s -> mv_penalty [ s -> f_code ] + MAX_MV ; \n const int quant = s -> qscale ; \n int pen_x , pen_y ; \n int mx , my , mx1 , my1 , d , xx , yy , dminh ; \n UINT8 * pix , * ptr ; \n mx = * mx_ptr ; \n my = * my_ptr ; \n ptr = ref_picture + ( my * s -> linesize ) + mx ; \n xx = 16 * s -> mb_x ; \n yy = 16 * s -> mb_y ; \n pix = s -> new_picture [ 0 ] + ( yy * s -> linesize ) + xx ; \n dminh = dmin ; \n if ( mx > xmin && mx < xmax && \n my > ymin && my < ymax ) { \n mx = mx1 = 2 * ( mx - xx ) ; \n my = my1 = 2 * ( my - yy ) ; \n if ( dmin < Z_THRESHOLD && mx == 0 && my == 0 ) { \n * mx_ptr = 0 ; \n * my_ptr = 0 ; \n return dmin ; \n } \n pen_x = pred_x + mx ; \n pen_y = pred_y + my ; \n ptr -= s -> linesize ; \n CHECK_HALF_MV ( xy2 , -1 , -1 )  \n CHECK_HALF_MV ( y2 , 0 , -1 )  \n CHECK_HALF_MV ( xy2 , +1 , -1 )  \n ptr += s -> linesize ; \n CHECK_HALF_MV ( x2 , -1 , 0 )  \n CHECK_HALF_MV ( x2 , +1 , 0 )  \n CHECK_HALF_MV ( xy2 , -1 , +1 )  \n CHECK_HALF_MV ( y2 , 0 , +1 )  \n CHECK_HALF_MV ( xy2 , +1 , +1 )  \n } else { \n mx = 2 * ( mx - xx ) ; \n my = 2 * ( my - yy ) ; \n } \n * mx_ptr = mx ; \n * my_ptr = my ; \n return dminh ; \n }", "idx": 12358}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_and_aver_dst_16x16_msa ( src - ( stride * 2 ) , stride , dst , stride ) ; \n }", "idx": 12359}
{"project": "FFmpeg", "commit_id": "2ab65b652dc5e69fb738f1afdc55f7a2f9cbc0e0", "target": 0, "func": "void * checkasm_check_func ( void * func , const char * name , ... ) \n { \n char name_buf [ 256 ] ; \n void * ref = func ; \n CheckasmFuncVersion * v ; \n int name_length ; \n va_list arg ; \n va_start ( arg , name ) ; \n name_length = vsnprintf ( name_buf , sizeof ( name_buf ) , name , arg ) ; \n va_end ( arg ) ; \n if ( ! func || name_length <= 0 || name_length >= sizeof ( name_buf ) ) \n return NULL ; \n state . current_func = get_func ( name_buf , name_length ) ; \n v = & state . current_func -> versions ; \n if ( v -> func ) { \n CheckasmFuncVersion * prev ; \n do { \n if ( v -> func == func ) \n return NULL ; \n if ( v -> ok ) \n ref = v -> func ; \n prev = v ; \n } while ( ( v = v -> next ) ) ; \n v = prev -> next = checkasm_malloc ( sizeof ( CheckasmFuncVersion ) ) ; \n } \n v -> func = func ; \n v -> ok = 1 ; \n v -> cpu = state . cpu_flag ; \n state . current_func_ver = v ; \n if ( state . cpu_flag ) \n state . num_checked ++ ; \n return ref ; \n }", "idx": 12361}
{"project": "FFmpeg", "commit_id": "7abf394814d818973db562102f21ab9d10540840", "target": 0, "func": "static int mov_probe ( AVProbeData * p ) \n { \n int64_t offset ; \n uint32_t tag ; \n int score = 0 ; \n offset = 0 ; \n for ( ; ; ) { \n if ( ( offset + 8 ) > ( unsigned int ) p -> buf_size ) \n return score ; \n tag = AV_RL32 ( p -> buf + offset + 4 ) ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n return AVPROBE_SCORE_MAX ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n return AVPROBE_SCORE_MAX - 5 ; \n case MKTAG ( 0x82 , 0x82 , 0x7f , 0x7d ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n offset = AV_RB32 ( p -> buf + offset ) + offset ; \n score = AVPROBE_SCORE_MAX - 50 ; \n break ; \n default : \n return score ; \n } \n } \n }", "idx": 12394}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int source_request_frame ( AVFilterLink * outlink ) \n { \n Frei0rContext * frei0r = outlink -> src -> priv ; \n AVFilterBufferRef * picref = ff_get_video_buffer ( outlink , AV_PERM_WRITE , outlink -> w , outlink -> h ) ; \n int ret ; \n picref -> video -> pixel_aspect = ( AVRational ) { 1 , 1 } ; \n picref -> pts = frei0r -> pts ++ ; \n picref -> pos = -1 ; \n ret = ff_start_frame ( outlink , avfilter_ref_buffer ( picref , ~ 0 ) ) ; \n if ( ret < 0 ) \n goto fail ; \n frei0r -> update ( frei0r -> instance , av_rescale_q ( picref -> pts , frei0r -> time_base , ( AVRational ) { 1 , 1000 } ) , \n NULL , ( uint32_t * ) picref -> data [ 0 ] ) ; \n ret = ff_draw_slice ( outlink , 0 , outlink -> h , 1 ) ; \n if ( ret < 0 ) \n goto fail ; \n ret = ff_end_frame ( outlink ) ; \n fail : \n avfilter_unref_buffer ( picref ) ; \n return ret ; \n }", "idx": 12400}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_ocl_device_desc ( const void * a , const void * b ) \n { \n return ( ( const OpenCLDeviceBenchmark * ) a ) -> runtime - ( ( const OpenCLDeviceBenchmark * ) b ) -> runtime ; \n }", "idx": 12410}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int ffv1_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n ffv1_close ( avctx ) ; \n return 0 ; \n }", "idx": 12413}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static inline void conv_to_float ( float * arr , int32_t * cof , int num ) \n { \n int i ; \n for ( i = 0 ; i < num ; i ++ ) \n arr [ i ] = ( float ) cof [ i ] / INT32_MAX ; \n }", "idx": 12414}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel4_mc23_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_4w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 4 , 1 ) ; \n }", "idx": 12416}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int start_frame ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * outpicref = NULL ; \n int ret = 0 ; \n if ( inpicref -> perms & AV_PERM_PRESERVE ) { \n outpicref = ff_get_video_buffer ( outlink , AV_PERM_WRITE , \n outlink -> w , outlink -> h ) ; \n if ( ! outpicref ) \n return AVERROR ( ENOMEM ) ; \n avfilter_copy_buffer_ref_props ( outpicref , inpicref ) ; \n outpicref -> video -> w = outlink -> w ; \n outpicref -> video -> h = outlink -> h ; \n } else { \n outpicref = avfilter_ref_buffer ( inpicref , ~ 0 ) ; \n if ( ! outpicref ) \n return AVERROR ( ENOMEM ) ; \n } \n ret = ff_start_frame ( outlink , avfilter_ref_buffer ( outpicref , ~ 0 ) ) ; \n if ( ret < 0 ) { \n avfilter_unref_bufferp ( & outpicref ) ; \n return ret ; \n } \n outlink -> out_buf = outpicref ; \n return 0 ; \n }", "idx": 12417}
{"project": "FFmpeg", "commit_id": "cccb45751e93142d71be78f6bb90bbfb50ee13be", "target": 1, "func": "static void fill_gv_table ( int table [ 256 + 2 * YUVRGB_TABLE_HEADROOM ] , const int elemsize , const int inc ) \n { \n int i ; \n int off = - ( inc >> 9 ) ; \n for ( i = 0 ; i < 256 + 2 * YUVRGB_TABLE_HEADROOM ; i ++ ) { \n int64_t cb = av_clip ( i - YUVRGB_TABLE_HEADROOM , 0 , 255 ) * inc ; \n table [ i ] = elemsize * ( off + ( cb >> 16 ) ) ; \n } \n }", "idx": 12421}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_program ( WriterContext * w , AVFormatContext * fmt_ctx , AVProgram * program ) \n { \n int i ; \n writer_print_section_header ( w , SECTION_ID_PROGRAM ) ; \n print_int ( \" \" , program -> id ) ; \n print_int ( \" \" , program -> program_num ) ; \n print_int ( \" \" , program -> nb_stream_indexes ) ; \n print_int ( \" \" , program -> pmt_pid ) ; \n print_int ( \" \" , program -> pcr_pid ) ; \n print_ts ( \" \" , program -> start_time ) ; \n print_time ( \" \" , program -> start_time , & AV_TIME_BASE_Q ) ; \n print_ts ( \" \" , program -> end_time ) ; \n print_time ( \" \" , program -> end_time , & AV_TIME_BASE_Q ) ; \n show_tags ( w , program -> metadata , SECTION_ID_PROGRAM_TAGS ) ; \n writer_print_section_header ( w , SECTION_ID_PROGRAM_STREAMS ) ; \n for ( i = 0 ; i < program -> nb_stream_indexes ; i ++ ) { \n if ( selected_streams [ program -> stream_index [ i ] ] ) \n show_stream ( w , fmt_ctx , program -> stream_index [ i ] , 1 ) ; \n } \n writer_print_section_footer ( w ) ; \n writer_print_section_footer ( w ) ; \n }", "idx": 12432}
{"project": "FFmpeg", "commit_id": "61138c43e08b7bb039fbcf50f1e71d6e735e04a5", "target": 0, "func": "AVStream * av_new_stream ( AVFormatContext * s , int id ) \n { \n AVStream * st ; \n int i ; \n #if LIBAVFORMAT_VERSION_MAJOR >= 53  \n  \n  AVStream * * streams ; \n if ( s -> nb_streams >= INT_MAX / sizeof ( * streams ) ) \n return NULL ; \n streams = av_realloc ( s -> streams , ( s -> nb_streams + 1 ) * sizeof ( * streams ) ) ; \n if ( ! streams ) \n return NULL ; \n s -> streams = streams ; \n #else \n if ( s -> nb_streams >= MAX_STREAMS ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return NULL ; \n } \n #endif \n st = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! st ) \n return NULL ; \n st -> codec = avcodec_alloc_context ( ) ; \n if ( s -> iformat ) { \n st -> codec -> bit_rate = 0 ; \n } \n st -> index = s -> nb_streams ; \n st -> id = id ; \n st -> start_time = AV_NOPTS_VALUE ; \n st -> duration = AV_NOPTS_VALUE ; \n st -> cur_dts = 0 ; \n st -> first_dts = AV_NOPTS_VALUE ; \n st -> probe_packets = MAX_PROBE_PACKETS ; \n av_set_pts_info ( st , 33 , 1 , 90000 ) ; \n st -> last_IP_pts = AV_NOPTS_VALUE ; \n for ( i = 0 ; i < MAX_REORDER_DELAY + 1 ; i ++ ) \n st -> pts_buffer [ i ] = AV_NOPTS_VALUE ; \n st -> reference_dts = AV_NOPTS_VALUE ; \n st -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n s -> streams [ s -> nb_streams ++ ] = st ; \n return st ; \n }", "idx": 12439}
{"project": "FFmpeg", "commit_id": "8731c86d03d062ad19f098b77ab1f1bc4ad7c406", "target": 1, "func": "static int a64_write_trailer ( struct AVFormatContext * s ) \n { \n A64MuxerContext * c = s -> priv_data ; \n AVPacket pkt ; \n if ( c -> interleaved ) a64_write_packet ( s , & pkt ) ; \n return 0 ; \n }", "idx": 12458}
{"project": "FFmpeg", "commit_id": "b0c7f5a9d82feb7f4c4cdf77f1537193670ab58b", "target": 0, "func": "int av_write_frame ( AVFormatContext * s , int stream_index , const uint8_t * buf , \n int size ) \n { \n AVStream * st ; \n int64_t pts_mask ; \n int ret , frame_size ; \n st = s -> streams [ stream_index ] ; \n pts_mask = ( 1LL << s -> pts_wrap_bits ) - 1 ; \n ret = s -> oformat -> write_packet ( s , stream_index , buf , size , \n st -> pts . val & pts_mask ) ; \n if ( ret < 0 ) \n return ret ; \n switch ( st -> codec . codec_type ) { \n case CODEC_TYPE_AUDIO : \n frame_size = get_audio_frame_size ( & st -> codec , size ) ; \n if ( frame_size >= 0 && ( size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) ) { \n av_frac_add ( & st -> pts , \n ( int64_t ) s -> pts_den * frame_size ) ; \n } \n break ; \n case CODEC_TYPE_VIDEO : \n av_frac_add ( & st -> pts , \n ( int64_t ) s -> pts_den * st -> codec . frame_rate_base ) ; \n break ; \n default : \n break ; \n } \n return ret ; \n }", "idx": 12461}
{"project": "FFmpeg", "commit_id": "04001767728fd4ed8b4f9d2ebbb9f9a8c9a7be0d", "target": 0, "func": "static int config ( struct vf_instance * vf , \n int width , int height , int d_width , int d_height , \n unsigned int flags , unsigned int outfmt ) \n { \n switch ( vf -> priv -> mode ) { \n case 0 : \n case 3 : \n return ff_vf_next_config ( vf , width , height * 2 , d_width , d_height * 2 , flags , outfmt ) ; \n case 1 : \n case 2 : \n case 4 : \n return ff_vf_next_config ( vf , width , height , d_width , d_height , flags , outfmt ) ; \n } \n return 0 ; \n }", "idx": 12463}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2mono_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n const uint8_t * const d128 = dither_8x8_220 [ y & 7 ] ; \n uint8_t * g = c -> table_gU [ 128 ] + c -> table_gV [ 128 ] ; \n int yalpha1 = 4095 - yalpha ; \n int i ; \n for ( i = 0 ; i < dstW - 7 ; i += 8 ) { \n int acc = g [ ( ( buf0 [ i ] * yalpha1 + buf1 [ i ] * yalpha ) >> 19 ) + d128 [ 0 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 1 ] * yalpha1 + buf1 [ i + 1 ] * yalpha ) >> 19 ) + d128 [ 1 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 2 ] * yalpha1 + buf1 [ i + 2 ] * yalpha ) >> 19 ) + d128 [ 2 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 3 ] * yalpha1 + buf1 [ i + 3 ] * yalpha ) >> 19 ) + d128 [ 3 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 4 ] * yalpha1 + buf1 [ i + 4 ] * yalpha ) >> 19 ) + d128 [ 4 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 5 ] * yalpha1 + buf1 [ i + 5 ] * yalpha ) >> 19 ) + d128 [ 5 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 6 ] * yalpha1 + buf1 [ i + 6 ] * yalpha ) >> 19 ) + d128 [ 6 ] ] ; \n acc += acc + g [ ( ( buf0 [ i + 7 ] * yalpha1 + buf1 [ i + 7 ] * yalpha ) >> 19 ) + d128 [ 7 ] ] ; \n output_pixel ( * dest ++ , acc ) ; \n } \n }", "idx": 12475}
{"project": "FFmpeg", "commit_id": "a5cbf1991c3d04b0be3c23ee0a7096b5a365cc85", "target": 1, "func": "static int mov_read_extradata ( MOVContext * c , AVIOContext * pb , MOVAtom atom , \n enum AVCodecID codec_id ) \n { \n AVStream * st ; \n uint64_t size ; \n uint8_t * buf ; \n int err ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( st -> codec -> codec_id != codec_id ) \n return 0 ; \n size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE ; \n if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX ) \n return AVERROR_INVALIDDATA ; \n if ( ( err = av_reallocp ( & st -> codec -> extradata , size ) ) < 0 ) \n return err ; \n buf = st -> codec -> extradata + st -> codec -> extradata_size ; \n st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE ; \n AV_WB32 ( buf , atom . size + 8 ) ; \n AV_WL32 ( buf + 4 , atom . type ) ; \n avio_read ( pb , buf + 8 , atom . size ) ; \n return 0 ; \n }", "idx": 12500}
{"project": "FFmpeg", "commit_id": "2c6cf1394096d08396faadc6e7c0b404fd6df006", "target": 1, "func": "static void wavpack_decode_flush ( AVCodecContext * avctx ) \n { \n WavpackContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> fdec_num ; i ++ ) \n wv_reset_saved_context ( s -> fdec [ i ] ) ; \n }", "idx": 12505}
{"project": "FFmpeg", "commit_id": "d1cf45911935cc4fed9afd3a37d99616d31eb9da", "target": 1, "func": "void avcodec_flush_buffers ( AVCodecContext * avctx ) \n { \n if ( HAVE_PTHREADS && avctx -> active_thread_type & FF_THREAD_FRAME ) \n ff_thread_flush ( avctx ) ; \n if ( avctx -> codec -> flush ) \n avctx -> codec -> flush ( avctx ) ; \n }", "idx": 12509}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x5 ( IpvideoContext * s ) \n { \n signed char x , y ; \n CHECK_STREAM_PTR ( 2 ) ; \n x = * s -> stream_ptr ++ ; \n y = * s -> stream_ptr ++ ; \n debug_interplay ( \" \\n \" , x , y ) ; \n return copy_from ( s , & s -> last_frame , x , y ) ; \n }", "idx": 12510}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8tobgr32 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 3 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 2 ] ; \n #else \n dst [ 0 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 2 ] ; \n #endif \n dst += 4 ; \n } \n }", "idx": 12523}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static void sdp_parse_fmtp_config ( AVCodecContext * codec , void * ctx , \n char * attr , char * value ) \n { \n switch ( codec -> codec_id ) { \n case CODEC_ID_MPEG4 : \n case CODEC_ID_AAC : \n if ( ! strcmp ( attr , \" \" ) ) { \n int len = hex_to_data ( NULL , value ) ; \n if ( codec -> extradata ) \n av_free ( codec -> extradata ) ; \n codec -> extradata = av_mallocz ( len + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! codec -> extradata ) \n return ; \n codec -> extradata_size = len ; \n hex_to_data ( codec -> extradata , value ) ; \n } \n break ; \n case CODEC_ID_VORBIS : \n ff_vorbis_parse_fmtp_config ( codec , ctx , attr , value ) ; \n break ; \n default : \n break ; \n } \n return ; \n }", "idx": 12531}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC ( ff_h264_idct_dc_add ) ( uint8_t * _dst , DCTELEM * block , int stride ) { \n int i , j ; \n int dc = ( ( ( dctcoef * ) block ) [ 0 ] + 32 ) >> 6 ; \n INIT_CLIP \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( j = 0 ; j < 4 ; j ++ ) \n { \n for ( i = 0 ; i < 4 ; i ++ ) \n dst [ i ] = CLIP ( dst [ i ] + dc ) ; \n dst += stride ; \n } \n }", "idx": 12547}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel16_mc03_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_16w_msa ( src - ( stride * 2 ) , stride , dst , stride , 16 , 1 ) ; \n }", "idx": 12555}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "av_cold void ff_schro_queue_init ( FFSchroQueue * queue ) \n { \n queue -> p_head = queue -> p_tail = NULL ; \n queue -> size = 0 ; \n }", "idx": 12561}
{"project": "FFmpeg", "commit_id": "c0323b9c9bcebe029df0b19a19a6f81deef94b3a", "target": 1, "func": "int avfilter_graph_send_command ( AVFilterGraph * graph , const char * target , const char * cmd , const char * arg , char * res , int res_len , int flags ) \n { \n int i , r = AVERROR ( ENOSYS ) ; \n if ( ! graph ) \n return r ; \n if ( ( flags & AVFILTER_CMD_FLAG_ONE ) && ! ( flags & AVFILTER_CMD_FLAG_FAST ) ) { \n r = avfilter_graph_send_command ( graph , target , cmd , arg , res , res_len , flags | AVFILTER_CMD_FLAG_FAST ) ; \n if ( r != AVERROR ( ENOSYS ) ) \n return r ; \n } \n if ( res_len && res ) \n res [ 0 ] = 0 ; \n for ( i = 0 ; i < graph -> filter_count ; i ++ ) { \n AVFilterContext * filter = graph -> filters [ i ] ; \n if ( ! strcmp ( target , \" \" ) || ! strcmp ( target , filter -> name ) || ! strcmp ( target , filter -> filter -> name ) ) { \n r = avfilter_process_command ( filter , cmd , arg , res , res_len , flags ) ; \n if ( r != AVERROR ( ENOSYS ) ) { \n if ( ( flags & AVFILTER_CMD_FLAG_ONE ) || r < 0 ) \n return r ; \n } \n } \n } \n return r ; \n }", "idx": 12564}
{"project": "FFmpeg", "commit_id": "a8475bbdb64e638bd8161df9647876fd23f8a29a", "target": 0, "func": "static int rtsp_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n RTSPState * rt = s -> priv_data ; \n RTSPStream * rtsp_st ; \n fd_set rfds ; \n int n , tcp_fd ; \n struct timeval tv ; \n AVFormatContext * rtpctx ; \n int ret ; \n tcp_fd = url_get_file_handle ( rt -> rtsp_hd ) ; \n while ( 1 ) { \n FD_ZERO ( & rfds ) ; \n FD_SET ( tcp_fd , & rfds ) ; \n tv . tv_sec = 0 ; \n tv . tv_usec = 0 ; \n n = select ( tcp_fd + 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n <= 0 ) \n break ; \n if ( FD_ISSET ( tcp_fd , & rfds ) ) { \n RTSPMessageHeader reply ; \n ret = ff_rtsp_read_reply ( s , & reply , NULL , 1 , NULL ) ; \n if ( ret < 0 ) \n return AVERROR ( EPIPE ) ; \n if ( ret == 1 ) \n ff_rtsp_skip_packet ( s ) ; \n if ( rt -> state != RTSP_STATE_STREAMING ) \n return AVERROR ( EPIPE ) ; \n } \n } \n if ( pkt -> stream_index < 0 || pkt -> stream_index >= rt -> nb_rtsp_streams ) \n return AVERROR_INVALIDDATA ; \n rtsp_st = rt -> rtsp_streams [ pkt -> stream_index ] ; \n rtpctx = rtsp_st -> transport_priv ; \n ret = ff_write_chained ( rtpctx , 0 , pkt , s ) ; \n if ( ! ret && rt -> lower_transport == RTSP_LOWER_TRANSPORT_TCP ) \n ret = tcp_write_packet ( s , rtsp_st ) ; \n return ret ; \n }", "idx": 12570}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int read_decode_block ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n int ret ; \n ret = read_block ( ctx , bd ) ; \n if ( ret ) \n return ret ; \n ret = decode_block ( ctx , bd ) ; \n return ret ; \n }", "idx": 12574}
{"project": "FFmpeg", "commit_id": "be8d812c9635f31f69c30dff9ebf565a07a7dab7", "target": 1, "func": "static av_cold int vorbis_encode_init ( AVCodecContext * avccontext ) \n { \n vorbis_enc_context * venc = avccontext -> priv_data ; \n if ( avccontext -> channels != 2 ) { \n av_log ( avccontext , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n create_vorbis_context ( venc , avccontext ) ; \n if ( avccontext -> flags & CODEC_FLAG_QSCALE ) \n venc -> quality = avccontext -> global_quality / ( float ) FF_QP2LAMBDA / 10. ; \n else \n venc -> quality = 0.03 ; \n venc -> quality *= venc -> quality ; \n avccontext -> extradata_size = put_main_header ( venc , ( uint8_t * * ) & avccontext -> extradata ) ; \n avccontext -> frame_size = 1 << ( venc -> log2_blocksize [ 0 ] - 1 ) ; \n avccontext -> coded_frame = avcodec_alloc_frame ( ) ; \n avccontext -> coded_frame -> key_frame = 1 ; \n return 0 ; \n }", "idx": 12582}
{"project": "FFmpeg", "commit_id": "64263dd526ec25ede1591fc1144715a20cc7bc4e", "target": 1, "func": "static const unsigned char * seq_decode_op1 ( SeqVideoContext * seq , const unsigned char * src , unsigned char * dst ) \n { \n const unsigned char * color_table ; \n int b , i , len , bits ; \n GetBitContext gb ; \n unsigned char block [ 8 * 8 ] ; \n len = * src ++ ; \n if ( len & 0x80 ) { \n switch ( len & 3 ) { \n case 1 : \n src = seq_unpack_rle_block ( src , block , sizeof ( block ) ) ; \n for ( b = 0 ; b < 8 ; b ++ ) { \n memcpy ( dst , & block [ b * 8 ] , 8 ) ; \n dst += seq -> frame . linesize [ 0 ] ; \n } \n break ; \n case 2 : \n src = seq_unpack_rle_block ( src , block , sizeof ( block ) ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n for ( b = 0 ; b < 8 ; b ++ ) \n dst [ b * seq -> frame . linesize [ 0 ] ] = block [ i * 8 + b ] ; \n ++ dst ; \n } \n break ; \n } \n } else { \n color_table = src ; \n src += len ; \n bits = ff_log2_tab [ len - 1 ] + 1 ; \n init_get_bits ( & gb , src , bits * 8 * 8 ) ; src += bits * 8 ; \n for ( b = 0 ; b < 8 ; b ++ ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = color_table [ get_bits ( & gb , bits ) ] ; \n dst += seq -> frame . linesize [ 0 ] ; \n } \n } \n return src ; \n }", "idx": 12591}
{"project": "FFmpeg", "commit_id": "bb6c67bb36b136de10256f0999128df4a42f9ffc", "target": 1, "func": "static int start_frame ( AVFilterLink * link , AVFilterBufferRef * picref ) \n { \n SliceContext * slice = link -> dst -> priv ; \n if ( slice -> use_random_h ) { \n slice -> lcg_state = slice -> lcg_state * 1664525 + 1013904223 ; \n slice -> h = 8 + ( uint64_t ) slice -> lcg_state * 25 / UINT32_MAX ; \n } \n slice -> h = FFMAX ( 8 , slice -> h & ( -1 << slice -> vshift ) ) ; \n av_log ( link -> dst , AV_LOG_DEBUG , \" \\n \" , slice -> h ) ; \n link -> cur_buf = NULL ; \n return ff_start_frame ( link -> dst -> outputs [ 0 ] , picref ) ; \n }", "idx": 12594}
{"project": "FFmpeg", "commit_id": "7328c2fc2184476235ebc9a9b9247a986bdea1cf", "target": 1, "func": "static void show_packets ( WriterContext * w , AVFormatContext * fmt_ctx ) \n { \n AVPacket pkt ; \n AVFrame frame ; \n int i = 0 ; \n av_init_packet ( & pkt ) ; \n while ( ! av_read_frame ( fmt_ctx , & pkt ) ) { \n if ( do_show_packets ) \n show_packet ( w , fmt_ctx , & pkt , i ++ ) ; \n if ( do_show_frames && \n get_video_frame ( fmt_ctx , & frame , & pkt ) ) { \n show_frame ( w , & frame , fmt_ctx -> streams [ pkt . stream_index ] ) ; \n av_destruct_packet ( & pkt ) ; \n } \n } \n av_init_packet ( & pkt ) ; \n pkt . data = NULL ; \n pkt . size = 0 ; \n for ( i = 0 ; i < fmt_ctx -> nb_streams ; i ++ ) { \n pkt . stream_index = i ; \n while ( get_video_frame ( fmt_ctx , & frame , & pkt ) ) \n show_frame ( w , & frame , fmt_ctx -> streams [ pkt . stream_index ] ) ; \n } \n }", "idx": 12604}
{"project": "FFmpeg", "commit_id": "5c4e97282f52d4045bd4498805f508ca50b313dd", "target": 1, "func": "X264_close ( AVCodecContext * avctx )  \n { \n X264Context * x4 = avctx -> priv_data ; \n if ( x4 -> enc ) \n x264_encoder_close ( x4 -> enc ) ; \n return 0 ; \n }", "idx": 12609}
{"project": "FFmpeg", "commit_id": "6cf31ef263d36f6b89d9b64f15ca81cef4f24901", "target": 1, "func": "static void use_high_update_speed ( WmallDecodeCtx * s , int ich ) \n { \n int ilms , recent , icoef ; \n s -> update_speed [ ich ] = 16 ; \n for ( ilms = s -> cdlms_ttl [ ich ] ; ilms >= 0 ; ilms -- ) { \n recent = s -> cdlms [ ich ] [ ilms ] . recent ; \n if ( s -> bV3RTM ) { \n for ( icoef = 0 ; icoef < s -> cdlms [ ich ] [ ilms ] . order ; icoef ++ ) \n s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef + recent ] *= 2 ; \n } else { \n for ( icoef = 0 ; icoef < s -> cdlms [ ich ] [ ilms ] . order ; icoef ++ ) \n s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef ] *= 2 ; \n } \n } \n }", "idx": 12615}
{"project": "FFmpeg", "commit_id": "6d71b3820759235c02493ac73ef5949b653ad29b", "target": 0, "func": "static inline int mpeg4_decode_dc ( MpegEncContext * s , int n , int * dir_ptr ) \n { \n int level , pred , code ; \n uint16_t * dc_val ; \n if ( n < 4 ) \n code = get_vlc2 ( & s -> gb , dc_lum . table , DC_VLC_BITS , 1 ) ; \n else \n code = get_vlc2 ( & s -> gb , dc_chrom . table , DC_VLC_BITS , 1 ) ; \n if ( code < 0 || code > 9 \n ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n if ( code == 0 ) { \n level = 0 ; \n } else { \n level = get_xbits ( & s -> gb , code ) ; \n if ( code > 8 ) { \n if ( get_bits1 ( & s -> gb ) == 0 ) { \n if ( s -> error_resilience >= 2 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n } \n } \n } \n pred = ff_mpeg4_pred_dc ( s , n , & dc_val , dir_ptr ) ; \n level += pred ; \n if ( level < 0 ) { \n if ( s -> error_resilience >= 3 ) { \n fprintf ( stderr , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n level = 0 ; \n } \n if ( n < 4 ) { \n * dc_val = level * s -> y_dc_scale ; \n } else { \n * dc_val = level * s -> c_dc_scale ; \n } \n if ( s -> error_resilience >= 3 ) { \n if ( * dc_val > 2048 + s -> y_dc_scale + s -> c_dc_scale ) { \n fprintf ( stderr , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n } \n return level ; \n }", "idx": 12620}
{"project": "FFmpeg", "commit_id": "515b69f8f8e9a24cfaee95d8c1f63f265d8582fe", "target": 0, "func": "static void check_pred8x8 ( H264PredContext * h , uint8_t * buf0 , uint8_t * buf1 , \n int codec , int chroma_format , int bit_depth ) \n { \n int pred_mode ; \n for ( pred_mode = 0 ; pred_mode < 11 ; pred_mode ++ ) { \n if ( check_pred_func ( h -> pred8x8 [ pred_mode ] , ( chroma_format == 2 ) ? \" \" : \" \" , \n pred8x8_modes [ codec ] [ pred_mode ] ) ) { \n randomize_buffers ( ) ; \n call_ref ( src0 , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n call_new ( src1 , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( src1 , ( ptrdiff_t ) 24 * SIZEOF_PIXEL ) ; \n } \n } \n }", "idx": 12621}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2bgr24_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2RGB ( % % REGBP , % 5 ) \n \" \\n \\t \" \n WRITEBGR24 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n }", "idx": 12629}
{"project": "FFmpeg", "commit_id": "ea60a11e8e2d818e8e56da4da3ff38e23a12bdff", "target": 0, "func": "static int mov_write_gmhd_tag ( AVIOContext * pb ) \n { \n avio_wb32 ( pb , 0x20 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0x18 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb16 ( pb , 0x40 ) ; \n avio_wb16 ( pb , 0x8000 ) ; \n avio_wb16 ( pb , 0x8000 ) ; \n avio_wb16 ( pb , 0x8000 ) ; \n avio_wb16 ( pb , 0 ) ; \n avio_wb16 ( pb , 0 ) ; \n return 0x20 ; \n }", "idx": 12640}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_dmul_scalar ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const double * v1 , double scale ) \n { \n LOCAL_ALIGNED ( 32 , double , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED ( 32 , double , odst ,  [ LEN ] ) ; \n int ret ; \n cdsp -> vector_dmul_scalar ( cdst , v1 , scale , LEN ) ; \n fdsp -> vector_dmul_scalar ( odst , v1 , scale , LEN ) ; \n if ( ret = compare_doubles ( cdst , odst , LEN , DBL_EPSILON ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 12657}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void decode_sigpass ( Jpeg2000T1Context * t1 , int width , int height , \n int bpno , int bandno , \n int vert_causal_ctx_csty_symbol ) \n { \n int mask = 3 << ( bpno - 1 ) , y0 , x , y ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) { \n int flags_mask = -1 ; \n if ( vert_causal_ctx_csty_symbol && y == y0 + 3 ) \n flags_mask &= ~ ( JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE | JPEG2000_T1_SGN_S ) ; \n if ( ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG_NB & flags_mask ) \n && ! ( t1 -> flags [ y + 1 ] [ x + 1 ] & ( JPEG2000_T1_SIG | JPEG2000_T1_VIS ) ) ) { \n if ( ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ff_jpeg2000_getsigctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] & flags_mask , bandno ) ) ) { \n int xorbit , ctxno = ff_jpeg2000_getsgnctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] & flags_mask , & xorbit ) ; \n if ( t1 -> mqc . raw ) \n t1 -> data [ y ] [ x ] = ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno ) ? - mask : mask ; \n else \n t1 -> data [ y ] [ x ] = ( ff_mqc_decode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno ) ^ xorbit ) ? \n - mask : mask ; \n ff_jpeg2000_set_significance ( t1 , x , y , \n t1 -> data [ y ] [ x ] < 0 ) ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_VIS ; \n } \n } \n }", "idx": 12659}
{"project": "FFmpeg", "commit_id": "d584533cf38141172e20bae5436629ee17c8ce50", "target": 0, "func": "static AVPacket * add_to_pktbuf ( AVPacketList * * packet_buffer , AVPacket * pkt , \n AVPacketList * * plast_pktl ) \n { \n AVPacketList * pktl = av_mallocz ( sizeof ( AVPacketList ) ) ; \n if ( ! pktl ) \n return NULL ; \n if ( * packet_buffer ) \n ( * plast_pktl ) -> next = pktl ; \n else \n * packet_buffer = pktl ; \n * plast_pktl = pktl ; \n pktl -> pkt = * pkt ; \n return & pktl -> pkt ; \n }", "idx": 12660}
{"project": "FFmpeg", "commit_id": "a0560d0477549eaaa7d002e013bd8376e80873e4", "target": 0, "func": "static int query_formats ( AVFilterContext * ctx ) \n { \n static const enum AVPixelFormat pix_fmts [ ] = { \n AV_PIX_FMT_GRAY8 , \n AV_PIX_FMT_YUV410P , AV_PIX_FMT_YUV411P , \n AV_PIX_FMT_YUV420P , AV_PIX_FMT_YUV422P , \n AV_PIX_FMT_YUV440P , AV_PIX_FMT_YUV444P , \n AV_PIX_FMT_YUVJ420P , AV_PIX_FMT_YUVJ422P , \n AV_PIX_FMT_YUVJ440P , AV_PIX_FMT_YUVJ444P , \n AV_PIX_FMT_YUVJ411P , \n AV_PIX_FMT_YUVA444P , AV_PIX_FMT_YUVA422P , AV_PIX_FMT_YUVA420P , \n AV_PIX_FMT_NONE \n } ; \n AVFilterFormats * fmts_list = ff_make_format_list ( pix_fmts ) ; \n if ( ! fmts_list ) \n return AVERROR ( ENOMEM ) ; \n ff_set_common_formats ( ctx , fmts_list ) ; \n return 0 ; \n }", "idx": 12669}
{"project": "FFmpeg", "commit_id": "55d53cb59380bebea79ae8f99d4e119b2b006629", "target": 1, "func": "int avfilter_graph_queue_command ( AVFilterGraph * graph , const char * target , const char * command , const char * arg , int flags , double ts ) \n { \n int i ; \n if ( ! graph ) \n return 0 ; \n for ( i = 0 ; i < graph -> nb_filters ; i ++ ) { \n AVFilterContext * filter = graph -> filters [ i ] ; \n if ( filter && ( ! strcmp ( target , \" \" ) || ! strcmp ( target , filter -> name ) || ! strcmp ( target , filter -> filter -> name ) ) ) { \n AVFilterCommand * * queue = & filter -> command_queue , * next ; \n while ( * queue && ( * queue ) -> time <= ts ) \n queue = & ( * queue ) -> next ; \n next = * queue ; \n * queue = av_mallocz ( sizeof ( AVFilterCommand ) ) ; \n ( * queue ) -> command = av_strdup ( command ) ; \n ( * queue ) -> arg = av_strdup ( arg ) ; \n ( * queue ) -> time = ts ; \n ( * queue ) -> flags = flags ; \n ( * queue ) -> next = next ; \n if ( flags & AVFILTER_CMD_FLAG_ONE ) \n return 0 ; \n } \n } \n return 0 ; \n }", "idx": 12695}
{"project": "FFmpeg", "commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "target": 1, "func": "static av_cold int hevc_decode_init ( AVCodecContext * avctx ) \n { \n HEVCContext * s = avctx -> priv_data ; \n int ret ; \n avctx -> internal -> allocate_progress = 1 ; \n ret = hevc_init_context ( avctx ) ; \n if ( ret < 0 ) \n return ret ; \n s -> enable_parallel_tiles = 0 ; \n s -> sei . picture_timing . picture_struct = 0 ; \n s -> eos = 1 ; \n atomic_init ( & s -> wpp_err , 0 ) ; \n if ( avctx -> active_thread_type & FF_THREAD_SLICE ) \n s -> threads_number = avctx -> thread_count ; \n else \n s -> threads_number = 1 ; \n if ( avctx -> extradata_size > 0 && avctx -> extradata ) { \n ret = hevc_decode_extradata ( s , avctx -> extradata , avctx -> extradata_size ) ; \n if ( ret < 0 ) { \n hevc_decode_free ( avctx ) ; \n return ret ; \n } \n } \n if ( ( avctx -> active_thread_type & FF_THREAD_FRAME ) && avctx -> thread_count > 1 ) \n s -> threads_type = FF_THREAD_FRAME ; \n else \n s -> threads_type = FF_THREAD_SLICE ; \n return 0 ; \n }", "idx": 12696}
{"project": "FFmpeg", "commit_id": "6ad1fa5a49320c101a62d24aa0e7df14c10d7612", "target": 1, "func": "void dsputil_init_armv4l ( DSPContext * c , AVCodecContext * avctx ) \n { \n const int idct_algo = avctx -> idct_algo ; \n ff_put_pixels_clamped = c -> put_pixels_clamped ; \n ff_add_pixels_clamped = c -> add_pixels_clamped ; \n if ( idct_algo == FF_IDCT_ARM ) { \n if ( idct_algo == FF_IDCT_AUTO || idct_algo == FF_IDCT_ARM ) { \n c -> idct_put = j_rev_dct_ARM_put ; \n c -> idct_add = j_rev_dct_ARM_add ; \n c -> idct = j_rev_dct_ARM ; \n c -> idct_permutation_type = FF_LIBMPEG2_IDCT_PERM ; \n } else if ( idct_algo == FF_IDCT_SIMPLEARM ) { \n c -> idct_put = simple_idct_ARM_put ; \n c -> idct_add = simple_idct_ARM_add ; \n c -> idct = simple_idct_ARM ; \n } \n } ", "idx": 12697}
{"project": "FFmpeg", "commit_id": "bc2d2757bb532fa260c373adb00f4e47766e3449", "target": 0, "func": "static void exponents_from_scale_factors ( MPADecodeContext * s , \n GranuleDef * g , \n int16_t * exponents ) \n { \n const uint8_t * bstab , * pretab ; \n int len , i , j , k , l , v0 , shift , gain , gains [ 3 ] ; \n int16_t * exp_ptr ; \n exp_ptr = exponents ; \n gain = g -> global_gain - 210 ; \n shift = g -> scalefac_scale + 1 ; \n bstab = band_size_long [ s -> sample_rate_index ] ; \n pretab = mpa_pretab [ g -> preflag ] ; \n for ( i = 0 ; i < g -> long_end ; i ++ ) { \n v0 = gain - ( ( g -> scale_factors [ i ] + pretab [ i ] ) << shift ) ; \n len = bstab [ i ] ; \n for ( j = len ; j > 0 ; j -- ) \n * exp_ptr ++ = v0 ; \n } \n if ( g -> short_start < 13 ) { \n bstab = band_size_short [ s -> sample_rate_index ] ; \n gains [ 0 ] = gain - ( g -> subblock_gain [ 0 ] << 3 ) ; \n gains [ 1 ] = gain - ( g -> subblock_gain [ 1 ] << 3 ) ; \n gains [ 2 ] = gain - ( g -> subblock_gain [ 2 ] << 3 ) ; \n k = g -> long_end ; \n for ( i = g -> short_start ; i < 13 ; i ++ ) { \n len = bstab [ i ] ; \n for ( l = 0 ; l < 3 ; l ++ ) { \n v0 = gains [ l ] - ( g -> scale_factors [ k ++ ] << shift ) ; \n for ( j = len ; j > 0 ; j -- ) \n * exp_ptr ++ = v0 ; \n } \n } \n } \n }", "idx": 12707}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_biweight_h264_pixels8_8_msa ( uint8_t * dst , uint8_t * src , \n int stride , int height , \n int log2_denom , int weight_dst , \n int weight_src , int offset ) \n { \n avc_biwgt_8width_msa ( src , stride , \n dst , stride , \n height , log2_denom , \n weight_src , weight_dst , offset ) ; \n }", "idx": 12729}
{"project": "FFmpeg", "commit_id": "8febd6afbca652b331ddd8e75e356656c153cad1", "target": 0, "func": "static av_cold int libgsm_close ( AVCodecContext * avctx ) { \n av_freep ( & avctx -> coded_frame ) ; \n gsm_destroy ( avctx -> priv_data ) ; \n avctx -> priv_data = NULL ; \n return 0 ; \n }", "idx": 12753}
{"project": "FFmpeg", "commit_id": "fb7b477a91feea1a5d1faf62e516878e388c3057", "target": 0, "func": "static void test_hybrid_analysis ( void ) \n { \n LOCAL_ALIGNED_16 ( INTFLOAT , dst0 ,  [ BUF_SIZE ] ,  [ 2 ] ) ; \n LOCAL_ALIGNED_16 ( INTFLOAT , dst1 ,  [ BUF_SIZE ] ,  [ 2 ] ) ; \n LOCAL_ALIGNED_16 ( INTFLOAT , in ,  [ 12 ] ,  [ 2 ] ) ; \n LOCAL_ALIGNED_16 ( INTFLOAT , filter ,  [ N ] ,  [ 8 ] [ 2 ] ) ; \n declare_func ( void , INTFLOAT ( * out ) [ 2 ] , INTFLOAT ( * in ) [ 2 ] , \n const INTFLOAT ( * filter ) [ 8 ] [ 2 ] , \n ptrdiff_t stride , int n ) ; \n randomize ( ( INTFLOAT * ) in , 12 * 2 ) ; \n randomize ( ( INTFLOAT * ) filter , N * 8 * 2 ) ; \n randomize ( ( INTFLOAT * ) dst0 , BUF_SIZE * 2 ) ; \n memcpy ( dst1 , dst0 , BUF_SIZE * 2 * sizeof ( INTFLOAT ) ) ; \n call_ref ( dst0 , in , filter , STRIDE , N ) ; \n call_new ( dst1 , in , filter , STRIDE , N ) ; \n if ( ! float_near_abs_eps_array ( ( float * ) dst0 , ( float * ) dst1 , EPS , BUF_SIZE * 2 ) ) \n fail ( ) ; \n bench_new ( dst1 , in , filter , STRIDE , N ) ; \n }", "idx": 12764}
{"project": "FFmpeg", "commit_id": "7f549b8338ed3775fec4bf10421ff5744e5866dd", "target": 1, "func": "static void parse_waveformatex ( AVIOContext * pb , AVCodecParameters * par ) \n { \n ff_asf_guid subformat ; \n par -> bits_per_coded_sample = avio_rl16 ( pb ) ; \n par -> channel_layout = avio_rl32 ( pb ) ; \n ff_get_guid ( pb , & subformat ) ; \n if ( ! memcmp ( subformat + 4 , \n ( const uint8_t [ ] ) { FF_MEDIASUBTYPE_BASE_GUID } , 12 ) ) { \n par -> codec_tag = AV_RL32 ( subformat ) ; \n par -> codec_id = ff_wav_codec_get_id ( par -> codec_tag , \n par -> bits_per_coded_sample ) ; \n } else { \n par -> codec_id = ff_codec_guid_get_id ( ff_codec_wav_guids , subformat ) ; \n if ( ! par -> codec_id ) \n av_log ( pb , AV_LOG_WARNING , \n \" \" FF_PRI_GUID \" \\n \" , \n FF_ARG_GUID ( subformat ) ) ; \n } \n }", "idx": 12783}
{"project": "FFmpeg", "commit_id": "c746f92a8e03d5a062359fba836eba4b3530687e", "target": 1, "func": "static void ict_int ( void * _src0 , void * _src1 , void * _src2 , int csize ) \n { \n int32_t * src0 = _src0 , * src1 = _src1 , * src2 = _src2 ; \n int32_t i0 , i1 , i2 ; \n int i ; \n for ( i = 0 ; i < csize ; i ++ ) { \n i0 = * src0 + ( ( ( i_ict_params [ 0 ] * * src2 ) + ( 1 << 15 ) ) >> 16 ) ; \n i1 = * src0 - ( ( ( i_ict_params [ 1 ] * * src1 ) + ( 1 << 15 ) ) >> 16 ) \n - ( ( ( i_ict_params [ 2 ] * * src2 ) + ( 1 << 15 ) ) >> 16 ) ; \n i2 = * src0 + ( ( ( i_ict_params [ 3 ] * * src1 ) + ( 1 << 15 ) ) >> 16 ) ; \n * src0 ++ = i0 ; \n * src1 ++ = i1 ; \n * src2 ++ = i2 ; \n } \n }", "idx": 12784}
{"project": "FFmpeg", "commit_id": "f28043d0a34aaf4ac7cf25bd0dddd868811c0ab2", "target": 1, "func": "static const char * search_keyval ( const TiffGeoTagKeyName * keys , int n , int id ) \n { \n return ( ( TiffGeoTagKeyName * ) bsearch ( & id , keys , n , sizeof ( keys [ 0 ] ) , cmp_id_key ) ) -> name ; \n }", "idx": 12795}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static void j2k_flush ( J2kDecoderContext * s ) \n { \n if ( * s -> buf == 0xff ) \n s -> buf ++ ; \n s -> bit_index = 8 ; \n s -> buf ++ ; \n }", "idx": 12800}
{"project": "FFmpeg", "commit_id": "225f78b7ef589e52bbbb19c97d36de5b27982702", "target": 1, "func": "av_cold int ff_ac3_encode_close ( AVCodecContext * avctx ) \n { \n int blk , ch ; \n AC3EncodeContext * s = avctx -> priv_data ; \n av_freep ( & s -> windowed_samples ) ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) \n av_freep ( & s -> planar_samples [ ch ] ) ; \n av_freep ( & s -> planar_samples ) ; \n av_freep ( & s -> bap_buffer ) ; \n av_freep ( & s -> bap1_buffer ) ; \n av_freep ( & s -> mdct_coef_buffer ) ; \n av_freep ( & s -> fixed_coef_buffer ) ; \n av_freep ( & s -> exp_buffer ) ; \n av_freep ( & s -> grouped_exp_buffer ) ; \n av_freep ( & s -> psd_buffer ) ; \n av_freep ( & s -> band_psd_buffer ) ; \n av_freep ( & s -> mask_buffer ) ; \n av_freep ( & s -> qmant_buffer ) ; \n av_freep ( & s -> cpl_coord_exp_buffer ) ; \n av_freep ( & s -> cpl_coord_mant_buffer ) ; \n for ( blk = 0 ; blk < s -> num_blocks ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n av_freep ( & block -> mdct_coef ) ; \n av_freep ( & block -> fixed_coef ) ; \n av_freep ( & block -> exp ) ; \n av_freep ( & block -> grouped_exp ) ; \n av_freep ( & block -> psd ) ; \n av_freep ( & block -> band_psd ) ; \n av_freep ( & block -> mask ) ; \n av_freep ( & block -> qmant ) ; \n av_freep ( & block -> cpl_coord_exp ) ; \n av_freep ( & block -> cpl_coord_mant ) ; \n } \n s -> mdct_end ( s ) ; \n return 0 ; \n }", "idx": 12802}
{"project": "FFmpeg", "commit_id": "d1cf45911935cc4fed9afd3a37d99616d31eb9da", "target": 1, "func": "void ff_thread_flush ( AVCodecContext * avctx ) \n { \n FrameThreadContext * fctx = avctx -> thread_opaque ; \n if ( ! avctx -> thread_opaque ) return ; \n park_frame_worker_threads ( fctx , avctx -> thread_count ) ; \n if ( fctx -> prev_thread ) \n update_context_from_thread ( fctx -> threads -> avctx , fctx -> prev_thread -> avctx , 0 ) ; \n fctx -> next_decoding = fctx -> next_finished = 0 ; \n fctx -> delaying = 1 ; \n fctx -> prev_thread = NULL ; \n }", "idx": 12818}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "void ff_j2k_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) \n { \n int reslevelno , bandno , precno ; \n for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { \n Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; \n for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { \n Jpeg2000Band * band = reslevel -> band + bandno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n Jpeg2000Prec * prec = band -> prec + precno ; \n av_freep ( & prec -> zerobits ) ; \n av_freep ( & prec -> cblkincl ) ; \n av_freep ( & prec -> cblk ) ; \n } \n av_freep ( & band -> prec ) ; \n } \n av_freep ( & reslevel -> band ) ; \n } \n ff_dwt_destroy ( & comp -> dwt ) ; \n av_freep ( & comp -> reslevel ) ; \n av_freep ( & comp -> data ) ; \n }", "idx": 12827}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x8l_horizontal_add ) ( uint8_t * _pix , const int16_t * _block , \n ptrdiff_t stride ) \n { \n int i ; \n pixel * pix = ( pixel * ) _pix ; \n const dctcoef * block = ( const dctcoef * ) _block ; \n stride >>= sizeof ( pixel ) - 1 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixel v = pix [ -1 ] ; \n pix [ 0 ] = v += block [ 0 ] ; \n pix [ 1 ] = v += block [ 1 ] ; \n pix [ 2 ] = v += block [ 2 ] ; \n pix [ 3 ] = v += block [ 3 ] ; \n pix [ 4 ] = v += block [ 4 ] ; \n pix [ 5 ] = v += block [ 5 ] ; \n pix [ 6 ] = v += block [ 6 ] ; \n pix [ 7 ] = v + block [ 7 ] ; \n pix += stride ; \n block += 8 ; \n } \n }", "idx": 12859}
{"project": "FFmpeg", "commit_id": "280beebd399b2d2c9bf58438c2aa2a22a0a53282", "target": 0, "func": "void ff_cavs_init_top_lines ( AVSContext * h ) { \n h -> top_qp = av_malloc ( h -> mb_width ) ; \n h -> top_mv [ 0 ] = av_malloc ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ; \n h -> top_mv [ 1 ] = av_malloc ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ; \n h -> top_pred_Y = av_malloc ( h -> mb_width * 2 * sizeof ( * h -> top_pred_Y ) ) ; \n h -> top_border_y = av_malloc ( ( h -> mb_width + 1 ) * 16 ) ; \n h -> top_border_u = av_malloc ( h -> mb_width * 10 ) ; \n h -> top_border_v = av_malloc ( h -> mb_width * 10 ) ; \n h -> col_mv = av_malloc ( h -> mb_width * h -> mb_height * 4 * sizeof ( cavs_vector ) ) ; \n h -> col_type_base = av_malloc ( h -> mb_width * h -> mb_height ) ; \n h -> block = av_mallocz ( 64 * sizeof ( DCTELEM ) ) ; \n }", "idx": 12864}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_sigpass ( Jpeg2000T1Context * t1 , int width , int height , int bandno , int * nmsedec , int bpno ) \n { \n int y0 , x , y , mask = 1 << ( bpno + NMSEDEC_FRACBITS ) ; \n for ( y0 = 0 ; y0 < height ; y0 += 4 ) \n for ( x = 0 ; x < width ; x ++ ) \n for ( y = y0 ; y < height && y < y0 + 4 ; y ++ ) { \n if ( ! ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG ) && ( t1 -> flags [ y + 1 ] [ x + 1 ] & JPEG2000_T1_SIG_NB ) ) { \n int ctxno = ff_jpeg2000_getsigctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , bandno ) , \n bit = t1 -> data [ y ] [ x ] & mask ? 1 : 0 ; \n ff_mqc_encode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno , bit ) ; \n if ( bit ) { \n int xorbit ; \n int ctxno = ff_jpeg2000_getsgnctxno ( t1 -> flags [ y + 1 ] [ x + 1 ] , & xorbit ) ; \n ff_mqc_encode ( & t1 -> mqc , t1 -> mqc . cx_states + ctxno , ( t1 -> flags [ y + 1 ] [ x + 1 ] >> 15 ) ^ xorbit ) ; \n * nmsedec += getnmsedec_sig ( t1 -> data [ y ] [ x ] , bpno + NMSEDEC_FRACBITS ) ; \n ff_jpeg2000_set_significance ( t1 , x , y , t1 -> flags [ y + 1 ] [ x + 1 ] >> 15 ) ; \n } \n t1 -> flags [ y + 1 ] [ x + 1 ] |= JPEG2000_T1_VIS ; \n } \n } \n }", "idx": 12874}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static void do_exit ( void ) \n { \n if ( cur_stream ) { \n stream_close ( cur_stream ) ; \n cur_stream = NULL ; \n } \n uninit_opts ( ) ; \n #if CONFIG_AVFILTER  \n  \n  avfilter_uninit ( ) ; \n #endif \n avformat_network_deinit ( ) ; \n if ( show_status ) \n printf ( \" \\n \" ) ; \n SDL_Quit ( ) ; \n av_log ( NULL , AV_LOG_QUIET , \" \" ) ; \n exit ( 0 ) ; \n }", "idx": 12896}
{"project": "FFmpeg", "commit_id": "252746d052652b48f7bc0652e7c1601b1e997d9c", "target": 1, "func": "void av_image_copy_plane ( uint8_t * dst , int dst_linesize , \n const uint8_t * src , int src_linesize , \n int bytewidth , int height ) \n { \n if ( ! dst || ! src ) \n return ; \n for ( ; height > 0 ; height -- ) { \n memcpy ( dst , src , bytewidth ) ; \n dst += dst_linesize ; \n src += src_linesize ; \n } \n }", "idx": 12902}
{"project": "FFmpeg", "commit_id": "d32547a24a3fcc8286b318353f43805838b84775", "target": 1, "func": "int attribute_align_arg avcodec_encode_video ( AVCodecContext * avctx , uint8_t * buf , int buf_size , \n const AVFrame * pict ) \n { \n AVPacket pkt ; \n int ret , got_packet = 0 ; \n if ( buf_size < FF_MIN_BUFFER_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n av_init_packet ( & pkt ) ; \n pkt . data = buf ; \n pkt . size = buf_size ; \n ret = avcodec_encode_video2 ( avctx , & pkt , pict , & got_packet ) ; \n if ( ! ret && got_packet && avctx -> coded_frame ) { \n avctx -> coded_frame -> pts = pkt . pts ; \n avctx -> coded_frame -> key_frame = ! ! ( pkt . flags & AV_PKT_FLAG_KEY ) ; \n } \n if ( pkt . side_data_elems > 0 ) { \n int i ; \n for ( i = 0 ; i < pkt . side_data_elems ; i ++ ) \n av_free ( pkt . side_data [ i ] . data ) ; \n av_freep ( & pkt . side_data ) ; \n pkt . side_data_elems = 0 ; \n } \n return ret ? ret : pkt . size ; \n }", "idx": 12905}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static void dxva2_uninit ( AVCodecContext * s ) \n { \n InputStream * ist = s -> opaque ; \n DXVA2Context * ctx = ist -> hwaccel_ctx ; \n ist -> hwaccel_uninit = NULL ; \n ist -> hwaccel_get_buffer = NULL ; \n ist -> hwaccel_retrieve_data = NULL ; \n if ( ctx -> decoder_service ) \n IDirectXVideoDecoderService_Release ( ctx -> decoder_service ) ; \n av_buffer_unref ( & ctx -> hw_frames_ctx ) ; \n av_buffer_unref ( & ctx -> hw_device_ctx ) ; \n av_frame_free ( & ctx -> tmp_frame ) ; \n av_freep ( & ist -> hwaccel_ctx ) ; \n av_freep ( & s -> hwaccel_context ) ; \n }", "idx": 12918}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xvid_encode_close ( AVCodecContext * avctx ) \n { \n struct xvid_context * x = avctx -> priv_data ; \n if ( x -> encoder_handle ) { \n xvid_encore ( x -> encoder_handle , XVID_ENC_DESTROY , NULL , NULL ) ; \n x -> encoder_handle = NULL ; \n } \n av_frame_free ( & avctx -> coded_frame ) ; \n av_freep ( & avctx -> extradata ) ; \n if ( x -> twopassbuffer ) { \n av_free ( x -> twopassbuffer ) ; \n av_free ( x -> old_twopassbuffer ) ; \n } \n av_free ( x -> twopassfile ) ; \n av_free ( x -> intra_matrix ) ; \n av_free ( x -> inter_matrix ) ; \n return 0 ; \n }", "idx": 12919}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void calculate_code_lengths ( uint8_t * lengths , uint32_t * counts ) \n { \n uint32_t nr_nodes , nr_heap , node1 , node2 ; \n int i , j ; \n int32_t k ; \n uint32_t weights [ 512 ] ; \n uint32_t heap [ 512 ] ; \n int32_t parents [ 512 ] ; \n for ( i = 0 ; i < 256 ; i ++ ) \n weights [ i + 1 ] = ( counts [ i ] ? counts [ i ] : 1 ) << 8 ; \n nr_nodes = 256 ; \n nr_heap = 0 ; \n heap [ 0 ] = 0 ; \n weights [ 0 ] = 0 ; \n parents [ 0 ] = -2 ; \n for ( i = 1 ; i <= 256 ; i ++ ) { \n parents [ i ] = -1 ; \n heap [ ++ nr_heap ] = i ; \n up_heap ( nr_heap , heap , weights ) ; \n } \n while ( nr_heap > 1 ) { \n node1 = heap [ 1 ] ; \n heap [ 1 ] = heap [ nr_heap -- ] ; \n down_heap ( nr_heap , heap , weights ) ; \n node2 = heap [ 1 ] ; \n heap [ 1 ] = heap [ nr_heap -- ] ; \n down_heap ( nr_heap , heap , weights ) ; \n nr_nodes ++ ; \n parents [ node1 ] = parents [ node2 ] = nr_nodes ; \n weights [ nr_nodes ] = add_weights ( weights [ node1 ] , weights [ node2 ] ) ; \n parents [ nr_nodes ] = -1 ; \n heap [ ++ nr_heap ] = nr_nodes ; \n up_heap ( nr_heap , heap , weights ) ; \n } \n for ( i = 1 ; i <= 256 ; i ++ ) { \n j = 0 ; \n k = i ; \n while ( parents [ k ] >= 0 ) { \n k = parents [ k ] ; \n j ++ ; \n } \n lengths [ i - 1 ] = j ; \n } \n }", "idx": 12922}
{"project": "FFmpeg", "commit_id": "0f55bc29d41585d110b126cb4ed4b395fd46d7ac", "target": 1, "func": "static int oma_read_seek ( struct AVFormatContext * s , \n int stream_index , int64_t timestamp , int flags ) \n { \n OMAContext * oc = s -> priv_data ; \n int err = ff_pcm_read_seek ( s , stream_index , timestamp , flags ) ; \n if ( ! oc -> encrypted ) \n return err ; \n if ( err || avio_tell ( s -> pb ) < oc -> content_start ) \n goto wipe ; \n if ( ( err = avio_seek ( s -> pb , -8 , SEEK_CUR ) ) < 0 ) \n goto wipe ; \n if ( ( err = avio_read ( s -> pb , oc -> iv , 8 ) ) < 8 ) { \n if ( err >= 0 ) \n err = AVERROR_EOF ; \n goto wipe ; \n } \n return 0 ; \n wipe : \n memset ( oc -> iv , 0 , 8 ) ; \n return err ; \n }", "idx": 12924}
{"project": "FFmpeg", "commit_id": "c043def91f92da398fe04874191c8d4d7b6cf0e0", "target": 0, "func": "static int ftp_open ( URLContext * h , const char * url , int flags ) \n { \n char proto [ 10 ] , path [ MAX_URL_SIZE ] ; \n int err ; \n FTPContext * s = h -> priv_data ; \n av_dlog ( h , \" \\n \" ) ; \n s -> state = DISCONNECTED ; \n s -> filesize = -1 ; \n s -> position = 0 ; \n av_url_split ( proto , sizeof ( proto ) , \n s -> credencials , sizeof ( s -> credencials ) , \n s -> hostname , sizeof ( s -> hostname ) , \n & s -> server_control_port , \n path , sizeof ( path ) , \n url ) ; \n if ( s -> server_control_port < 0 || s -> server_control_port > 65535 ) \n s -> server_control_port = 21 ; \n if ( ( err = ftp_connect_control_connection ( h ) ) < 0 ) \n goto fail ; \n if ( ( err = ftp_current_dir ( s ) ) < 0 ) \n goto fail ; \n av_strlcat ( s -> path , path , sizeof ( s -> path ) ) ; \n if ( ftp_restart ( s , 0 ) < 0 ) { \n h -> is_streamed = 1 ; \n } else { \n if ( ftp_file_size ( s ) < 0 && flags & AVIO_FLAG_READ ) \n h -> is_streamed = 1 ; \n if ( s -> write_seekable != 1 && flags & AVIO_FLAG_WRITE ) \n h -> is_streamed = 1 ; \n } \n return 0 ; \n fail : \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n ffurl_closep ( & s -> conn_control ) ; \n ffurl_closep ( & s -> conn_data ) ; \n return err ; \n }", "idx": 12928}
{"project": "FFmpeg", "commit_id": "473f0f75a16b4d37bdaa943f75e4ae249212c1ba", "target": 1, "func": "static int thread_execute ( AVFilterContext * ctx , avfilter_action_func * func , \n void * arg , int * ret , int nb_jobs ) \n { \n ThreadContext * c = ctx -> graph -> internal -> thread ; \n int dummy_ret ; \n if ( nb_jobs <= 0 ) \n return 0 ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n c -> current_job = c -> nb_threads ; \n c -> nb_jobs = nb_jobs ; \n c -> ctx = ctx ; \n c -> arg = arg ; \n c -> func = func ; \n if ( ret ) { \n c -> rets = ret ; \n c -> nb_rets = nb_jobs ; \n } else { \n c -> rets = & dummy_ret ; \n c -> nb_rets = 1 ; \n } \n c -> current_execute ++ ; \n pthread_cond_broadcast ( & c -> current_job_cond ) ; \n slice_thread_park_workers ( c ) ; \n return 0 ; \n }", "idx": 12930}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_dc_rv40_c ( uint8_t * src , int stride ) { \n int i ; \n int dc0 = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dc0 += src [ -1 + i * stride ] + src [ i - stride ] ; \n dc0 += src [ 4 + i - stride ] ; \n dc0 += src [ -1 + ( i + 4 ) * stride ] ; \n } \n dc0 = 0x01010101 * ( ( dc0 + 8 ) >> 4 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n ( ( uint32_t * ) ( src + i * stride ) ) [ 0 ] = dc0 ; \n ( ( uint32_t * ) ( src + i * stride ) ) [ 1 ] = dc0 ; \n } \n for ( i = 4 ; i < 8 ; i ++ ) { \n ( ( uint32_t * ) ( src + i * stride ) ) [ 0 ] = dc0 ; \n ( ( uint32_t * ) ( src + i * stride ) ) [ 1 ] = dc0 ; \n } \n }", "idx": 12932}
{"project": "FFmpeg", "commit_id": "9da369604ecf31d9dce2dee21ed214b8c43264c6", "target": 0, "func": "static int set_expr ( AVExpr * * pexpr , const char * expr , void * log_ctx ) \n { \n int ret ; \n AVExpr * old = NULL ; \n if ( * pexpr ) \n old = * pexpr ; \n ret = av_expr_parse ( pexpr , expr , var_names , \n NULL , NULL , NULL , NULL , 0 , log_ctx ) ; \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , expr ) ; \n * pexpr = old ; \n return ret ; \n } \n av_expr_free ( old ) ; \n return 0 ; \n }", "idx": 12933}
{"project": "FFmpeg", "commit_id": "c4e554701ec27b31b1b6396130b8bb2aaa0d4ad0", "target": 0, "func": "static int dv_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n RawDVContext * c = s -> priv_data ; \n c -> dv_demux = dv_init_demux ( s ) ; \n return c -> dv_demux ? 0 : -1 ; \n }", "idx": 12937}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "int ffio_read_indirect ( AVIOContext * s , unsigned char * buf , int size , unsigned char * * data ) \n { \n if ( s -> buf_end - s -> buf_ptr >= size && ! s -> write_flag ) { \n * data = s -> buf_ptr ; \n s -> buf_ptr += size ; \n return size ; \n } else { \n * data = buf ; \n return avio_read ( s , buf , size ) ; \n } \n }", "idx": 12947}
{"project": "FFmpeg", "commit_id": "afb2aa537954db537d54358997b68f46561fd5a7", "target": 1, "func": "static inline int vorbis_residue_decode ( vorbis_context * vc , vorbis_residue * vr , \n unsigned ch , \n uint8_t * do_not_decode , \n float * vec , unsigned vlen ) \n { \n if ( vr -> type == 2 ) \n return vorbis_residue_decode_internal ( vc , vr , ch , do_not_decode , vec , vlen , 2 ) ; \n else if ( vr -> type == 1 ) \n return vorbis_residue_decode_internal ( vc , vr , ch , do_not_decode , vec , vlen , 1 ) ; \n else if ( vr -> type == 0 ) \n return vorbis_residue_decode_internal ( vc , vr , ch , do_not_decode , vec , vlen , 0 ) ; \n else { \n av_log ( vc -> avccontext , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 12950}
{"project": "FFmpeg", "commit_id": "0c2aaa882d124f05b7bf0a4a4abba3293f4d6d84", "target": 1, "func": "static void common_end ( FFV1Context * s ) { \n int i ; \n for ( i = 0 ; i < s -> plane_count ; i ++ ) { \n PlaneContext * p = & s -> plane [ i ] ; \n av_freep ( & p -> state ) ; \n } \n }", "idx": 12952}
{"project": "FFmpeg", "commit_id": "7500781313d11b37772c05a28da20fbc112db478", "target": 1, "func": "static av_cold int ape_decode_close ( AVCodecContext * avctx ) \n { \n APEContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < APE_FILTER_LEVELS ; i ++ ) \n av_freep ( & s -> filterbuf [ i ] ) ; \n av_freep ( & s -> data ) ; \n return 0 ; \n }", "idx": 12953}
{"project": "FFmpeg", "commit_id": "704cc5e75df3a1dc68581d3857a06d502d8662b6", "target": 1, "func": "static void writer_close ( WriterContext * * wctx ) \n { \n int i ; \n if ( ! * wctx ) \n return ; \n if ( ( * wctx ) -> writer -> uninit ) \n ( * wctx ) -> writer -> uninit ( * wctx ) ; \n for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) \n av_bprint_finalize ( & ( * wctx ) -> section_pbuf [ i ] , NULL ) ; \n if ( ( * wctx ) -> writer -> priv_class ) \n av_opt_free ( ( * wctx ) -> priv ) ; \n av_freep ( & ( ( * wctx ) -> priv ) ) ; \n av_freep ( wctx ) ; \n }", "idx": 12956}
{"project": "FFmpeg", "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7", "target": 0, "func": "static int avi_read_tag ( AVFormatContext * s , AVStream * st , uint32_t tag , uint32_t size ) \n { \n AVIOContext * pb = s -> pb ; \n char key [ 5 ] = { 0 } , * value ; \n size += ( size & 1 ) ; \n if ( size == UINT_MAX ) \n return -1 ; \n value = av_malloc ( size + 1 ) ; \n if ( ! value ) \n return -1 ; \n avio_read ( pb , value , size ) ; \n value [ size ] = 0 ; \n AV_WL32 ( key , tag ) ; \n return av_dict_set ( st ? & st -> metadata : & s -> metadata , key , value , \n AV_DICT_DONT_STRDUP_VAL ) ; \n }", "idx": 12957}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void libschroedinger_flush ( AVCodecContext * avctx ) \n { \n SchroDecoderParams * p_schro_params = avctx -> priv_data ; \n ff_schro_queue_free ( & p_schro_params -> dec_frame_queue , \n libschroedinger_decode_frame_free ) ; \n ff_schro_queue_init ( & p_schro_params -> dec_frame_queue ) ; \n schro_decoder_reset ( p_schro_params -> decoder ) ; \n p_schro_params -> eos_pulled = 0 ; \n p_schro_params -> eos_signalled = 0 ; \n }", "idx": 12964}
{"project": "FFmpeg", "commit_id": "5eb273b2e767c86f78cc0e7e1a31bda4fedd2f56", "target": 1, "func": "int attribute_align_arg av_buffersink_get_frame_flags ( AVFilterContext * ctx , AVFrame * frame , int flags ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n int ret ; \n AVFrame * cur_frame ; \n if ( ! av_fifo_size ( buf -> fifo ) ) { \n if ( flags & AV_BUFFERSINK_FLAG_NO_REQUEST ) \n return AVERROR ( EAGAIN ) ; \n if ( ( ret = ff_request_frame ( inlink ) ) < 0 ) \n return ret ; \n } \n if ( ! av_fifo_size ( buf -> fifo ) ) \n return AVERROR ( EINVAL ) ; \n if ( flags & AV_BUFFERSINK_FLAG_PEEK ) { \n cur_frame = * ( ( AVFrame * * ) av_fifo_peek2 ( buf -> fifo , 0 ) ) ; \n av_frame_ref ( frame , cur_frame ) ; \n } else { \n av_fifo_generic_read ( buf -> fifo , & cur_frame , sizeof ( cur_frame ) , NULL ) ; \n av_frame_move_ref ( frame , cur_frame ) ; \n av_frame_free ( & cur_frame ) ; \n } \n return 0 ; \n }", "idx": 12983}
{"project": "FFmpeg", "commit_id": "64bde8056337bb656a11f3c9e2857c10b94e2871", "target": 0, "func": "static int ac3_eac3_probe ( AVProbeData * p , enum CodecID expected_codec_id ) \n { \n int max_frames , first_frames = 0 , frames ; \n uint8_t * buf , * buf2 , * end ; \n AC3HeaderInfo hdr ; \n GetBitContext gbc ; \n enum CodecID codec_id = CODEC_ID_AC3 ; \n max_frames = 0 ; \n buf = p -> buf ; \n end = buf + p -> buf_size ; \n for ( ; buf < end ; buf ++ ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n init_get_bits ( & gbc , buf2 , 54 ) ; \n if ( avpriv_ac3_parse_header ( & gbc , & hdr ) < 0 ) \n break ; \n if ( buf2 + hdr . frame_size > end || \n av_crc ( av_crc_get_table ( AV_CRC_16_ANSI ) , 0 , buf2 + 2 , hdr . frame_size - 2 ) ) \n break ; \n if ( hdr . bitstream_id > 10 ) \n codec_id = CODEC_ID_EAC3 ; \n buf2 += hdr . frame_size ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == p -> buf ) \n first_frames = frames ; \n } \n if ( codec_id != expected_codec_id ) return 0 ; \n if ( first_frames >= 4 ) return AVPROBE_SCORE_MAX / 2 + 1 ; \n else if ( max_frames > 500 ) return AVPROBE_SCORE_MAX / 2 ; \n else if ( max_frames >= 4 ) return AVPROBE_SCORE_MAX / 4 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 12986}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int h263_probe ( AVProbeData * p ) \n { \n int code ; \n const uint8_t * d ; \n if ( p -> buf_size < 6 ) \n return 0 ; \n d = p -> buf ; \n code = ( d [ 0 ] << 14 ) | ( d [ 1 ] << 6 ) | ( d [ 2 ] >> 2 ) ; \n if ( code == 0x20 ) { \n return 50 ; \n } \n return 0 ; \n }", "idx": 12987}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int cinepak_decode_init ( AVCodecContext * avctx ) \n { \n CinepakContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = ( avctx -> width + 3 ) & ~ 3 ; \n s -> height = ( avctx -> height + 3 ) & ~ 3 ; \n s -> sega_film_skip_bytes = -1 ; \n if ( ( avctx -> palctrl == NULL ) || ( avctx -> bits_per_sample == 40 ) ) { \n s -> palette_video = 0 ; \n avctx -> pix_fmt = PIX_FMT_YUV420P ; \n } else { \n s -> palette_video = 1 ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n } \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 12989}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static void h263_v_loop_filter_mmx ( uint8_t * src , int stride , int qscale ) \n { \n if ( CONFIG_H263_DECODER || CONFIG_H263_ENCODER ) { \n const int strength = ff_h263_loop_filter_strength [ qscale ] ; \n __asm__ volatile ( \n H263_LOOP_FILTER \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( * ( uint64_t * ) ( src - 2 * stride ) ) , \n \" \" ( * ( uint64_t * ) ( src - 1 * stride ) ) , \n \" \" ( * ( uint64_t * ) ( src + 0 * stride ) ) , \n \" \" ( * ( uint64_t * ) ( src + 1 * stride ) ) \n : \" \" ( 2 * strength ) , \" \" ( ff_pb_FC ) \n ) ; \n } \n }", "idx": 12994}
{"project": "FFmpeg", "commit_id": "e48ded8551172b58a78f30303a81dfce125344e0", "target": 0, "func": "static int64_t * concat_channels_lists ( const int64_t * layouts , const int * counts ) \n { \n int nb_layouts = 0 , nb_counts = 0 , i ; \n int64_t * list ; \n if ( layouts ) \n for ( ; layouts [ nb_layouts ] != -1 ; nb_layouts ++ ) ; \n if ( counts ) \n for ( ; counts [ nb_counts ] != -1 ; nb_counts ++ ) ; \n if ( nb_counts > INT_MAX - 1 - nb_layouts ) \n return NULL ; \n if ( ! ( list = av_calloc ( nb_layouts + nb_counts + 1 , sizeof ( * list ) ) ) ) \n return NULL ; \n for ( i = 0 ; i < nb_layouts ; i ++ ) \n list [ i ] = layouts [ i ] ; \n for ( i = 0 ; i < nb_counts ; i ++ ) \n list [ nb_layouts + i ] = FF_COUNT2LAYOUT ( counts [ i ] ) ; \n list [ nb_layouts + nb_counts ] = -1 ; \n return list ; \n }", "idx": 12995}
{"project": "FFmpeg", "commit_id": "d8870f120ea5f46940bac63a90424ca6a6000ad9", "target": 0, "func": "static void ac3_downmix ( AC3DecodeContext * s ) \n { \n int i , j ; \n float v0 , v1 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n v0 = v1 = 0.0f ; \n for ( j = 0 ; j < s -> fbw_channels ; j ++ ) { \n v0 += s -> output [ j ] [ i ] * s -> downmix_coeffs [ j ] [ 0 ] ; \n v1 += s -> output [ j ] [ i ] * s -> downmix_coeffs [ j ] [ 1 ] ; \n } \n v0 /= s -> downmix_coeff_sum [ 0 ] ; \n v1 /= s -> downmix_coeff_sum [ 1 ] ; \n if ( s -> output_mode == AC3_CHMODE_MONO ) { \n s -> output [ 0 ] [ i ] = ( v0 + v1 ) * LEVEL_MINUS_3DB ; \n } else if ( s -> output_mode == AC3_CHMODE_STEREO ) { \n s -> output [ 0 ] [ i ] = v0 ; \n s -> output [ 1 ] [ i ] = v1 ; \n } \n } \n }", "idx": 12998}
{"project": "FFmpeg", "commit_id": "45faf7fcd335b91e41b0e3ba4e397a9640d8c694", "target": 0, "func": "static int nsv_probe ( AVProbeData * p ) \n { \n int i ; \n av_dlog ( NULL , \" \\n \" , p -> buf_size ) ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && ( p -> buf [ 3 ] == ' ' || p -> buf [ 3 ] == ' ' ) ) \n return AVPROBE_SCORE_MAX ; \n for ( i = 1 ; i < p -> buf_size - 3 ; i ++ ) { \n if ( p -> buf [ i + 0 ] == ' ' && p -> buf [ i + 1 ] == ' ' && \n p -> buf [ i + 2 ] == ' ' && p -> buf [ i + 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX - 20 ; \n } \n if ( av_match_ext ( p -> filename , \" \" ) ) \n return AVPROBE_SCORE_MAX / 2 ; \n return 0 ; \n }", "idx": 13025}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "static int nvdec_hevc_decode_init ( AVCodecContext * avctx ) \n { \n const HEVCContext * s = avctx -> priv_data ; \n const HEVCSPS * sps = s -> ps . sps ; \n return ff_nvdec_decode_init ( avctx , sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering + 1 ) ; \n }", "idx": 13026}
{"project": "FFmpeg", "commit_id": "5a571d324129ce367584ad9d92aae1d286f389a2", "target": 1, "func": "static int parse_h264_sdp_line ( AVFormatContext * s , int st_index , \n PayloadContext * h264_data , const char * line ) \n { \n AVStream * stream ; \n AVCodecContext * codec ; \n const char * p = line ; \n if ( st_index < 0 ) \n return 0 ; \n stream = s -> streams [ st_index ] ; \n codec = stream -> codec ; \n assert ( h264_data -> cookie == MAGIC_COOKIE ) ; \n if ( av_strstart ( p , \" \" , & p ) ) { \n char buf1 [ 50 ] ; \n char * dst = buf1 ; \n while ( * p && * p == ' ' ) p ++ ; \n while ( * p && * p != ' ' ) p ++ ; \n while ( * p && * p == ' ' ) p ++ ; \n while ( * p && * p != ' ' && ( dst - buf1 ) < sizeof ( buf1 ) - 1 ) { \n * dst ++ = * p ++ ; \n } \n * dst = ' \\0 ' ; \n codec -> width = atoi ( buf1 ) ; \n codec -> height = atoi ( p + 1 ) ; \n codec -> pix_fmt = PIX_FMT_YUV420P ; \n } else if ( av_strstart ( p , \" \" , & p ) ) { \n return ff_parse_fmtp ( stream , h264_data , p , sdp_parse_fmtp_config_h264 ) ; \n } else if ( av_strstart ( p , \" \" , & p ) ) { \n } \n return 0 ; \n }", "idx": 13041}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_put_c ( uint8_t * dest \n , int line_size , DCTELEM * block \n ) { \n idct ( dest , line_size , block , 1 ) ; \n }", "idx": 13043}
{"project": "FFmpeg", "commit_id": "3df4939988ace682f7ac0366ef8fd700d207e6b6", "target": 0, "func": "int avpriv_dca_parse_core_frame_header ( DCACoreFrameHeader * h , const uint8_t * buf , int size ) \n { \n GetBitContext gb ; \n if ( init_get_bits8 ( & gb , buf , size ) < 0 ) \n return DCA_PARSE_ERROR_INVALIDDATA ; \n return ff_dca_parse_core_frame_header ( h , & gb ) ; \n }", "idx": 13065}
{"project": "FFmpeg", "commit_id": "ef0d779706c77ca9007527bd8d41e9400682f4e4", "target": 1, "func": "static int ogg_new_buf ( struct ogg * ogg , int idx ) \n { \n struct ogg_stream * os = ogg -> streams + idx ; \n uint8_t * nb = av_malloc ( os -> bufsize ) ; \n int size = os -> bufpos - os -> pstart ; \n if ( os -> buf ) { \n memcpy ( nb , os -> buf + os -> pstart , size ) ; \n av_free ( os -> buf ) ; \n } \n os -> buf = nb ; \n os -> bufpos = size ; \n os -> pstart = 0 ; \n return 0 ; \n }", "idx": 13069}
{"project": "FFmpeg", "commit_id": "e6b1ed693ae4098e6b9eabf938fc31ec0b09b120", "target": 0, "func": "av_cold int ff_mdct_init ( FFTContext * s , int nbits , int inverse , double scale ) \n { \n int n , n4 , i ; \n double alpha , theta ; \n int tstep ; \n memset ( s , 0 , sizeof ( * s ) ) ; \n n = 1 << nbits ; \n s -> mdct_bits = nbits ; \n s -> mdct_size = n ; \n n4 = n >> 2 ; \n s -> permutation = FF_MDCT_PERM_NONE ; \n if ( ff_fft_init ( s , s -> mdct_bits - 2 , inverse ) < 0 ) \n goto fail ; \n s -> tcos = av_malloc ( n / 2 * sizeof ( FFTSample ) ) ; \n if ( ! s -> tcos ) \n goto fail ; \n switch ( s -> permutation ) { \n case FF_MDCT_PERM_NONE : \n s -> tsin = s -> tcos + n4 ; \n tstep = 1 ; \n break ; \n case FF_MDCT_PERM_INTERLEAVE : \n s -> tsin = s -> tcos + 1 ; \n tstep = 2 ; \n break ; \n default : \n goto fail ; \n } \n theta = 1.0 / 8.0 + ( scale < 0 ? n4 : 0 ) ; \n scale = sqrt ( fabs ( scale ) ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n alpha = 2 * M_PI * ( i + theta ) / n ; \n s -> tcos [ i * tstep ] = - cos ( alpha ) * scale ; \n s -> tsin [ i * tstep ] = - sin ( alpha ) * scale ; \n } \n return 0 ; \n fail : \n ff_mdct_end ( s ) ; \n return -1 ; \n }", "idx": 13079}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_and_aver_dst_4x4_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride ) ; \n }", "idx": 13082}
{"project": "FFmpeg", "commit_id": "3d5822d9cf07d08bce82903e4715658f46b01b5c", "target": 1, "func": "void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) \n { \n int reslevelno , bandno , precno ; \n for ( reslevelno = 0 ; \n comp -> reslevel && reslevelno < codsty -> nreslevels ; \n reslevelno ++ ) { \n Jpeg2000ResLevel * reslevel ; \n if ( ! comp -> reslevel ) \n continue ; \n reslevel = comp -> reslevel + reslevelno ; \n for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { \n Jpeg2000Band * band ; \n if ( ! reslevel -> band ) \n continue ; \n band = reslevel -> band + bandno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n if ( band -> prec ) { \n Jpeg2000Prec * prec = band -> prec + precno ; \n av_freep ( & prec -> zerobits ) ; \n av_freep ( & prec -> cblkincl ) ; \n av_freep ( & prec -> cblk ) ; \n } \n } \n av_freep ( & band -> prec ) ; \n } \n av_freep ( & reslevel -> band ) ; \n } \n ff_dwt_destroy ( & comp -> dwt ) ; \n av_freep ( & comp -> reslevel ) ; \n av_freep ( & comp -> i_data ) ; \n av_freep ( & comp -> f_data ) ; \n }", "idx": 13089}
{"project": "FFmpeg", "commit_id": "c4e2a535b3a8b192c144acfaa9f1a7bc8b7f99f3", "target": 1, "func": "static void ff_mpeg4_init_direct_mv ( MpegEncContext * s ) { \n static const int tab_size = sizeof ( s -> direct_scale_mv [ 0 ] ) / sizeof ( int16_t ) ; \n static const int tab_bias = ( tab_size / 2 ) ; \n int i ; \n for ( i = 0 ; i < tab_size ; i ++ ) { \n s -> direct_scale_mv [ 0 ] [ i ] = ( i - tab_bias ) * s -> pb_time / s -> pp_time ; \n s -> direct_scale_mv [ 1 ] [ i ] = ( i - tab_bias ) * ( s -> pb_time - s -> pp_time ) / s -> pp_time ; \n } \n }", "idx": 13106}
{"project": "FFmpeg", "commit_id": "7e8fe4be5fb4c98aa3c6a4ed3cec999f4e3cc3aa", "target": 0, "func": "static int pad_count ( const AVFilterPad * pads ) \n { \n int count ; \n if ( ! pads ) \n return 0 ; \n for ( count = 0 ; pads -> name ; count ++ ) pads ++ ; \n return count ; \n }", "idx": 13108}
{"project": "FFmpeg", "commit_id": "9eb0d8bab1c475edf73c36146d1c3d31ea47f997", "target": 0, "func": "int av_fifo_generic_write ( AVFifoBuffer * f , void * src , int size , int ( * func ) ( void * , void * , int ) ) \n { \n int total = size ; \n do { \n int len = FFMIN ( f -> end - f -> wptr , size ) ; \n if ( func ) { \n if ( func ( src , f -> wptr , len ) <= 0 ) \n break ; \n } else { \n memcpy ( f -> wptr , src , len ) ; \n src = ( uint8_t * ) src + len ; \n } \n f -> wptr += len ; \n if ( f -> wptr >= f -> end ) \n f -> wptr = f -> buffer ; \n f -> wndx += len ; \n size -= len ; \n } while ( size > 0 ) ; \n return total - size ; \n }", "idx": 13111}
{"project": "FFmpeg", "commit_id": "ea37df2d528c15dc472e7272ac5278090f01f38e", "target": 0, "func": "int av_image_get_linesize ( enum AVPixelFormat pix_fmt , int width , int plane ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n int max_step [ 4 ] ; \n int max_step_comp [ 4 ] ; \n if ( ( unsigned ) pix_fmt >= AV_PIX_FMT_NB || desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) \n return AVERROR ( EINVAL ) ; \n av_image_fill_max_pixsteps ( max_step , max_step_comp , desc ) ; \n return image_get_linesize ( width , plane , max_step [ plane ] , max_step_comp [ plane ] , desc ) ; \n }", "idx": 13112}
{"project": "FFmpeg", "commit_id": "ab5f43e6342c4c07faf5c9ae87628d7d7c83abb6", "target": 0, "func": "static void vc1_put_ver_16b_shift2_mmx ( int16_t * dst , \n const uint8_t * src , x86_reg stride , \n int rnd , int64_t shift ) \n { \n __asm__ volatile ( \n \" \" REG_c \" \\n \\t \" \n LOAD_ROUNDER_MMX ( \" \" ) \n \" \" MANGLE ( ff_pw_9 ) \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n SHIFT2_LINE ( 0 , 1 , 2 , 3 , 4 )  \n SHIFT2_LINE ( 24 , 2 , 3 , 4 , 1 )  \n SHIFT2_LINE ( 48 , 3 , 4 , 1 , 2 )  \n SHIFT2_LINE ( 72 , 4 , 1 , 2 , 3 )  \n SHIFT2_LINE ( 96 , 1 , 2 , 3 , 4 )  \n SHIFT2_LINE ( 120 , 2 , 3 , 4 , 1 )  \n SHIFT2_LINE ( 144 , 3 , 4 , 1 , 2 )  \n SHIFT2_LINE ( 168 , 4 , 1 , 2 , 3 )  \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_c \" \\n \\t \" \n \" \\n \\t \" \n : \" + r \" \" + r \" \n : \" r \" \" r \" \n \" m \" \" m \" \" r \" \n NAMED_CONSTRAINTS_ADD ( ff_pw_9 ) \n : \" % \" \" memory \" \n ) ; \n }", "idx": 13138}
{"project": "FFmpeg", "commit_id": "3d040513a1de4797a4f81dde4984395f51db76b7", "target": 1, "func": "static AVBufferRef * dxva2_pool_alloc ( void * opaque , int size ) \n { \n AVHWFramesContext * ctx = ( AVHWFramesContext * ) opaque ; \n DXVA2FramesContext * s = ctx -> internal -> priv ; \n AVDXVA2FramesContext * hwctx = ctx -> hwctx ; \n if ( s -> nb_surfaces_used < hwctx -> nb_surfaces ) { \n s -> nb_surfaces_used ++ ; \n return av_buffer_create ( ( uint8_t * ) s -> surfaces_internal [ s -> nb_surfaces_used - 1 ] , \n sizeof ( * hwctx -> surfaces ) , NULL , 0 , 0 ) ; \n } \n return NULL ; \n }", "idx": 13141}
{"project": "FFmpeg", "commit_id": "99683a307776a7638ccce236a4ce5aa3e914e77d", "target": 1, "func": "void put_string ( PutBitContext * pbc , char * s ) \n { \n while ( * s ) { \n put_bits ( pbc , 8 , * s ) ; \n s ++ ; \n } \n put_bits ( pbc , 8 , 0 ) ; \n }", "idx": 13142}
{"project": "FFmpeg", "commit_id": "05b0337025f629d0a6c6321147f06d0da5e32a62", "target": 1, "func": "static void mp_decode_frame_helper ( MotionPixelsContext * mp , GetBitContext * gb ) \n { \n YuvPixel p ; \n int y , y0 ; \n for ( y = 0 ; y < mp -> avctx -> height ; ++ y ) { \n if ( mp -> changes_map [ y * mp -> avctx -> width ] != 0 ) { \n memset ( mp -> gradient_scale , 1 , sizeof ( mp -> gradient_scale ) ) ; \n p = mp_get_yuv_from_rgb ( mp , 0 , y ) ; \n } else { \n p . y += mp_gradient ( mp , 0 , mp_get_vlc ( mp , gb ) ) ; \n p . y = av_clip ( p . y , 0 , 31 ) ; \n if ( ( y & 3 ) == 0 ) { \n p . v += mp_gradient ( mp , 1 , mp_get_vlc ( mp , gb ) ) ; \n p . v = av_clip ( p . v , -32 , 31 ) ; \n p . u += mp_gradient ( mp , 2 , mp_get_vlc ( mp , gb ) ) ; \n p . u = av_clip ( p . u , -32 , 31 ) ; \n } \n mp -> vpt [ y ] = p ; \n mp_set_rgb_from_yuv ( mp , 0 , y , & p ) ; \n } \n } \n for ( y0 = 0 ; y0 < 2 ; ++ y0 ) \n for ( y = y0 ; y < mp -> avctx -> height ; y += 2 ) \n mp_decode_line ( mp , gb , y ) ; \n }", "idx": 13143}
{"project": "FFmpeg", "commit_id": "dd1a74d25decd6eaa7c78a7062fa12edb043efaf", "target": 1, "func": "static int find_start_code ( const uint8_t * * pbuf_ptr , const uint8_t * buf_end ) \n { \n const uint8_t * buf_ptr = * pbuf_ptr ; \n buf_ptr ++ ; \n buf_end -= 2 ; \n while ( buf_ptr < buf_end ) { \n if ( * buf_ptr == 0 ) { \n while ( buf_ptr < buf_end && buf_ptr [ 1 ] == 0 ) \n buf_ptr ++ ; \n if ( buf_ptr [ -1 ] == 0 && buf_ptr [ 1 ] == 1 ) { \n * pbuf_ptr = buf_ptr + 3 ; \n return buf_ptr [ 2 ] + 0x100 ; \n } \n } \n buf_ptr += 2 ; \n } \n buf_end += 2 ; \n * pbuf_ptr = buf_end ; \n return -1 ; \n }", "idx": 13144}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "av_cold int ff_nvenc_encode_init ( AVCodecContext * avctx ) \n { \n int ret ; \n if ( ( ret = nvenc_load_libraries ( avctx ) ) < 0 ) \n return ret ; \n if ( ( ret = nvenc_setup_device ( avctx ) ) < 0 ) \n return ret ; \n if ( ( ret = nvenc_setup_encoder ( avctx ) ) < 0 ) \n return ret ; \n if ( ( ret = nvenc_setup_surfaces ( avctx ) ) < 0 ) \n return ret ; \n if ( avctx -> flags & CODEC_FLAG_GLOBAL_HEADER ) { \n if ( ( ret = nvenc_setup_extradata ( avctx ) ) < 0 ) \n return ret ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 13146}
{"project": "FFmpeg", "commit_id": "9c856d62be91f9bf4c4c671ce5cea1feef4936c7", "target": 0, "func": "int avcodec_decode_audio2 ( AVCodecContext * avctx , int16_t * samples , \n int * frame_size_ptr , \n uint8_t * buf , int buf_size ) \n { \n int ret ; \n if ( * frame_size_ptr < AVCODEC_MAX_AUDIO_FRAME_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( * frame_size_ptr < FF_MIN_BUFFER_SIZE || \n * frame_size_ptr < avctx -> channels * avctx -> frame_size * sizeof ( int16_t ) || \n * frame_size_ptr < buf_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , * frame_size_ptr ) ; \n return -1 ; \n } \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || buf_size ) { \n ret = avctx -> codec -> decode ( avctx , samples , frame_size_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n } else { \n ret = 0 ; \n * frame_size_ptr = 0 ; \n } \n return ret ; \n }", "idx": 13151}
{"project": "FFmpeg", "commit_id": "71bc8c95d7cac552d3a2cb3120e41207dfb48e50", "target": 0, "func": "static int64_t ffm_read_write_index ( int fd ) \n { \n uint8_t buf [ 8 ] ; \n lseek ( fd , 8 , SEEK_SET ) ; \n if ( read ( fd , buf , 8 ) != 8 ) \n return AVERROR ( EIO ) ; \n return AV_RB64 ( buf ) ; \n }", "idx": 13152}
{"project": "FFmpeg", "commit_id": "b7581b5c839d1e293bb9dc34352a76df9d3158a9", "target": 0, "func": "static inline int decode_bytes ( const uint8_t * inbuffer , uint8_t * out , int bytes ) { \n int i , off ; \n uint32_t c ; \n const uint32_t * buf ; \n uint32_t * obuf = ( uint32_t * ) out ; \n off = ( intptr_t ) inbuffer & 3 ; \n buf = ( const uint32_t * ) ( inbuffer - off ) ; \n c = av_be2ne32 ( ( 0x37c511f2 >> ( off * 8 ) ) | ( 0x37c511f2 << ( 32 - ( off * 8 ) ) ) ) ; \n bytes += 3 + off ; \n for ( i = 0 ; i < bytes / 4 ; i ++ ) \n obuf [ i ] = c ^ buf [ i ] ; \n return off ; \n }", "idx": 13185}
{"project": "FFmpeg", "commit_id": "e22f2aaf99c59d788f292c4d7594493068eb4d69", "target": 1, "func": "ogg_get_length ( AVFormatContext * s )  \n { \n ogg_t * ogg = s -> priv_data ; \n int idx = -1 , i ; \n offset_t size , end ; \n if ( s -> pb . is_streamed ) \n return 0 ; \n if ( s -> duration != AV_NOPTS_VALUE ) \n return 0 ; \n size = url_fsize ( & s -> pb ) ; \n if ( size < 0 ) \n return 0 ; \n end = size > MAX_PAGE_SIZE ? size - MAX_PAGE_SIZE : size ; \n ogg_save ( s ) ; \n url_fseek ( & s -> pb , end , SEEK_SET ) ; \n while ( ! ogg_read_page ( s , & i ) ) { \n if ( ogg -> streams [ i ] . granule != -1 && ogg -> streams [ i ] . granule != 0 ) \n idx = i ; \n } \n if ( idx != -1 ) { \n s -> streams [ idx ] -> duration = \n ogg_gptopts ( s , idx , ogg -> streams [ idx ] . granule ) ; \n } \n ogg -> size = size ; \n ogg_restore ( s , 0 ) ; \n ogg_save ( s ) ; \n while ( ! ogg_read_page ( s , & i ) ) { \n if ( i == idx && ogg -> streams [ i ] . granule != -1 && ogg -> streams [ i ] . granule != 0 ) \n break ; \n } \n if ( i == idx ) { \n s -> streams [ idx ] -> start_time = ogg_gptopts ( s , idx , ogg -> streams [ idx ] . granule ) ; \n s -> streams [ idx ] -> duration -= s -> streams [ idx ] -> start_time ; \n } \n ogg_restore ( s , 0 ) ; \n return 0 ; \n }", "idx": 13190}
{"project": "FFmpeg", "commit_id": "755667eebc0b6303814faadef047870071ccb5c6", "target": 1, "func": "static int rm_write_header ( AVFormatContext * s ) \n { \n RMMuxContext * rm = s -> priv_data ; \n StreamInfo * stream ; \n int n ; \n AVCodecContext * codec ; \n for ( n = 0 ; n < s -> nb_streams ; n ++ ) { \n s -> streams [ n ] -> id = n ; \n codec = s -> streams [ n ] -> codec ; \n stream = & rm -> streams [ n ] ; \n memset ( stream , 0 , sizeof ( StreamInfo ) ) ; \n stream -> num = n ; \n stream -> bit_rate = codec -> bit_rate ; \n stream -> enc = codec ; \n switch ( codec -> codec_type ) { \n case AVMEDIA_TYPE_AUDIO : \n rm -> audio_stream = stream ; \n stream -> frame_rate = ( float ) codec -> sample_rate / ( float ) codec -> frame_size ; \n stream -> packet_max_size = 1024 ; \n stream -> nb_packets = 0 ; \n stream -> total_frames = stream -> nb_packets ; \n break ; \n case AVMEDIA_TYPE_VIDEO : \n rm -> video_stream = stream ; \n stream -> frame_rate = ( float ) codec -> time_base . den / ( float ) codec -> time_base . num ; \n stream -> packet_max_size = 4096 ; \n stream -> nb_packets = 0 ; \n stream -> total_frames = stream -> nb_packets ; \n break ; \n default : \n return -1 ; \n if ( rv10_write_header ( s , 0 , 0 ) ) \n return AVERROR_INVALIDDATA ; \n avio_flush ( s -> pb ) ; \n return 0 ;", "idx": 13194}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_stereo_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += output [ 2 ] [ i ] ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n }", "idx": 13195}
{"project": "FFmpeg", "commit_id": "81230e2612a9c88e5b35ed2f67d828450cc50abf", "target": 0, "func": "static int msmpeg4_decode_dc ( MpegEncContext * s , int n , int * dir_ptr ) \n { \n int level , pred ; \n if ( s -> msmpeg4_version <= 2 ) { \n if ( n < 4 ) { \n level = get_vlc2 ( & s -> gb , v2_dc_lum_vlc . table , DC_VLC_BITS , 3 ) ; \n } else { \n level = get_vlc2 ( & s -> gb , v2_dc_chroma_vlc . table , DC_VLC_BITS , 3 ) ; \n } \n if ( level < 0 ) \n return -1 ; \n level -= 256 ; \n } else { \n if ( n < 4 ) { \n level = get_vlc2 ( & s -> gb , ff_msmp4_dc_luma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ; \n } else { \n level = get_vlc2 ( & s -> gb , ff_msmp4_dc_chroma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ; \n } \n if ( level < 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( level == DC_MAX ) { \n level = get_bits ( & s -> gb , 8 ) ; \n if ( get_bits1 ( & s -> gb ) ) \n level = - level ; \n } else if ( level != 0 ) { \n if ( get_bits1 ( & s -> gb ) ) \n level = - level ; \n } \n } \n if ( s -> msmpeg4_version == 1 ) { \n int32_t * dc_val ; \n pred = msmpeg4v1_pred_dc ( s , n , & dc_val ) ; \n level += pred ; \n * dc_val = level ; \n } else { \n int16_t * dc_val ; \n pred = ff_msmpeg4_pred_dc ( s , n , & dc_val , dir_ptr ) ; \n level += pred ; \n if ( n < 4 ) { \n * dc_val = level * s -> y_dc_scale ; \n } else { \n * dc_val = level * s -> c_dc_scale ; \n } \n } \n return level ; \n }", "idx": 13196}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel16_mc21_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_16w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 16 , 0 ) ; \n }", "idx": 13197}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_content_storage ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFContext * mxf = arg ; \n switch ( tag ) { \n case 0x1901 : \n mxf -> packages_count = avio_rb32 ( pb ) ; \n if ( mxf -> packages_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n mxf -> packages_refs = av_malloc ( mxf -> packages_count * sizeof ( UID ) ) ; \n if ( ! mxf -> packages_refs ) \n return -1 ; \n avio_skip ( pb , 4 ) ; \n avio_read ( pb , ( uint8_t * ) mxf -> packages_refs , mxf -> packages_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 13199}
{"project": "FFmpeg", "commit_id": "fed50c4304eecb352e29ce789cdb96ea84d6162f", "target": 1, "func": "int av_get_cpu_flags ( void ) \n { \n int flags = cpu_flags ; \n if ( flags == -1 ) { \n flags = get_cpu_flags ( ) ; \n cpu_flags = flags ; \n } \n return flags ; \n }", "idx": 13207}
{"project": "FFmpeg", "commit_id": "3c27275c1309190f2d6ed69140b67d014215b6c9", "target": 0, "func": "static void add_entry ( TiffEncoderContext * s , enum TiffTags tag , \n enum TiffTypes type , int count , const void * ptr_val ) \n { \n uint8_t * entries_ptr = s -> entries + 12 * s -> num_entries ; \n assert ( s -> num_entries < TIFF_MAX_ENTRY ) ; \n bytestream_put_le16 ( & entries_ptr , tag ) ; \n bytestream_put_le16 ( & entries_ptr , type ) ; \n bytestream_put_le32 ( & entries_ptr , count ) ; \n if ( type_sizes [ type ] * count <= 4 ) { \n tnput ( & entries_ptr , count , ptr_val , type , 0 ) ; \n } else { \n bytestream_put_le32 ( & entries_ptr , * s -> buf - s -> buf_start ) ; \n check_size ( s , count * type_sizes2 [ type ] ) ; \n tnput ( s -> buf , count , ptr_val , type , 0 ) ; \n } \n s -> num_entries ++ ; \n }", "idx": 13214}
{"project": "FFmpeg", "commit_id": "a763d278274cfbda4e78e21b338b9b525fe22eab", "target": 1, "func": "static int set_hwframe_ctx ( AVCodecContext * ctx , AVBufferRef * hw_device_ctx ) \n { \n AVBufferRef * hw_frames_ref ; \n AVHWFramesContext * frames_ctx = NULL ; \n int err = 0 ; \n if ( ! ( hw_frames_ref = av_hwframe_ctx_alloc ( hw_device_ctx ) ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n frames_ctx = ( AVHWFramesContext * ) ( hw_frames_ref -> data ) ; \n frames_ctx -> format = AV_PIX_FMT_VAAPI ; \n frames_ctx -> sw_format = AV_PIX_FMT_NV12 ; \n frames_ctx -> width = width ; \n frames_ctx -> height = height ; \n frames_ctx -> initial_pool_size = 20 ; \n if ( ( err = av_hwframe_ctx_init ( hw_frames_ref ) ) < 0 ) { \n fprintf ( stderr , \" \" \n \" \\n \" , av_err2str ( err ) ) ; \n return err ; \n } \n ctx -> hw_frames_ctx = av_buffer_ref ( hw_frames_ref ) ; \n if ( ! ctx -> hw_frames_ctx ) \n err = AVERROR ( ENOMEM ) ; \n return err ; \n }", "idx": 13215}
{"project": "FFmpeg", "commit_id": "a99c273a3f91c3fd616b718c34a5848411ce0258", "target": 1, "func": "static int dnxhd_init_vlc ( DNXHDContext * ctx , int cid ) \n { \n if ( cid != ctx -> cid ) { \n int index ; \n if ( ( index = ff_dnxhd_get_cid_table ( cid ) ) < 0 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , cid ) ; \n return -1 ; \n } \n if ( ff_dnxhd_cid_table [ index ] . bit_depth != ctx -> bit_depth ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , ff_dnxhd_cid_table [ index ] . bit_depth , ctx -> bit_depth ) ; \n return AVERROR_INVALIDDATA ; \n } \n ctx -> cid_table = & ff_dnxhd_cid_table [ index ] ; \n ff_free_vlc ( & ctx -> ac_vlc ) ; \n ff_free_vlc ( & ctx -> dc_vlc ) ; \n ff_free_vlc ( & ctx -> run_vlc ) ; \n init_vlc ( & ctx -> ac_vlc , DNXHD_VLC_BITS , 257 , \n ctx -> cid_table -> ac_bits , 1 , 1 , \n ctx -> cid_table -> ac_codes , 2 , 2 , 0 ) ; \n init_vlc ( & ctx -> dc_vlc , DNXHD_DC_VLC_BITS , ctx -> bit_depth + 4 , \n ctx -> cid_table -> dc_bits , 1 , 1 , \n ctx -> cid_table -> dc_codes , 1 , 1 , 0 ) ; \n init_vlc ( & ctx -> run_vlc , DNXHD_VLC_BITS , 62 , \n ctx -> cid_table -> run_bits , 1 , 1 , \n ctx -> cid_table -> run_codes , 2 , 2 , 0 ) ; \n ff_init_scantable ( ctx -> dsp . idct_permutation , & ctx -> scantable , ff_zigzag_direct ) ; \n ctx -> cid = cid ; \n } \n return 0 ; \n }", "idx": 13216}
{"project": "FFmpeg", "commit_id": "c4ce8709676a6f0b41761093b0da08de72799ba9", "target": 1, "func": "static int flv_set_video_codec ( AVFormatContext * s , AVStream * vstream , int flv_codecid ) { \n AVCodecContext * vcodec = vstream -> codec ; \n switch ( flv_codecid ) { \n case FLV_CODECID_H263 : vcodec -> codec_id = CODEC_ID_FLV1 ; break ; \n case FLV_CODECID_REALH263 : vcodec -> codec_id = CODEC_ID_H263 ; break ; \n case FLV_CODECID_SCREEN : vcodec -> codec_id = CODEC_ID_FLASHSV ; break ; \n case FLV_CODECID_SCREEN2 : vcodec -> codec_id = CODEC_ID_FLASHSV2 ; break ; \n case FLV_CODECID_VP6 : vcodec -> codec_id = CODEC_ID_VP6F ; \n case FLV_CODECID_VP6A : \n if ( flv_codecid == FLV_CODECID_VP6A ) \n vcodec -> codec_id = CODEC_ID_VP6A ; \n if ( vcodec -> extradata_size != 1 ) { \n vcodec -> extradata_size = 1 ; \n vcodec -> extradata = av_malloc ( 1 ) ; \n } \n vcodec -> extradata [ 0 ] = avio_r8 ( s -> pb ) ; \n return 1 ; \n case FLV_CODECID_H264 : \n vcodec -> codec_id = CODEC_ID_H264 ; \n return 3 ; \n case FLV_CODECID_MPEG4 : \n vcodec -> codec_id = CODEC_ID_MPEG4 ; \n return 3 ; \n default : \n av_log ( s , AV_LOG_INFO , \" \\n \" , flv_codecid ) ; \n vcodec -> codec_tag = flv_codecid ; \n } \n return 0 ; \n }", "idx": 13217}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static void vc1_mspel_mc ( uint8_t * dst , const uint8_t * src , int stride , int mode , int rnd ) \n { \n int i , j ; \n uint8_t tmp [ 8 * 11 ] , * tptr ; \n int m , r ; \n m = ( mode & 3 ) ; \n r = rnd ; \n src -= stride ; \n tptr = tmp ; \n for ( j = 0 ; j < 11 ; j ++ ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n tptr [ i ] = vc1_mspel_filter ( src + i , 1 , m , r ) ; \n src += stride ; \n tptr += 8 ; \n } \n r = 1 - rnd ; \n m = ( mode >> 2 ) & 3 ; \n tptr = tmp + 8 ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = vc1_mspel_filter ( tptr + i , 8 , m , r ) ; \n dst += stride ; \n tptr += 8 ; \n } \n }", "idx": 13218}
{"project": "FFmpeg", "commit_id": "1a3d142f1f1e65f554cba84d8a515684ecb390d0", "target": 1, "func": "static av_cold int bfi_decode_init ( AVCodecContext * avctx ) \n { \n BFIContext * bfi = avctx -> priv_data ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n bfi -> dst = av_mallocz ( avctx -> width * avctx -> height ) ; \n return 0 ; \n }", "idx": 13219}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( rgb24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  assert ( src1 == src2 ) ; \n RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_RGB24 ) ; \n #else \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src1 [ 3 * i + 0 ] ; \n int g = src1 [ 3 * i + 1 ] ; \n int b = src1 [ 3 * i + 2 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n } \n #endif \n }", "idx": 13226}
{"project": "FFmpeg", "commit_id": "0852648301ad968bc7d79d000400e2b973bbb59a", "target": 1, "func": "static double get_scene_score ( AVFilterContext * ctx , AVFilterBufferRef * picref ) \n { \n double ret = 0 ; \n SelectContext * select = ctx -> priv ; \n AVFilterBufferRef * prev_picref = select -> prev_picref ; \n if ( prev_picref && \n picref -> video -> h == prev_picref -> video -> h && \n picref -> video -> w == prev_picref -> video -> w && \n picref -> linesize [ 0 ] == prev_picref -> linesize [ 0 ] ) { \n int x , y ; \n int64_t sad = 0 ; \n double mafd , diff ; \n uint8_t * p1 = picref -> data [ 0 ] ; \n uint8_t * p2 = prev_picref -> data [ 0 ] ; \n const int linesize = picref -> linesize [ 0 ] ; \n for ( y = 0 ; y < picref -> video -> h ; y += 8 ) \n for ( x = 0 ; x < linesize ; x += 8 ) \n sad += select -> c . sad [ 1 ] ( select , \n p1 + y * linesize + x , \n p2 + y * linesize + x , \n linesize , 8 ) ; \n emms_c ( ) ; \n mafd = sad / ( picref -> video -> h * picref -> video -> w * 3 ) ; \n diff = fabs ( mafd - select -> prev_mafd ) ; \n ret = av_clipf ( FFMIN ( mafd , diff ) / 100. , 0 , 1 ) ; \n select -> prev_mafd = mafd ; \n avfilter_unref_buffer ( prev_picref ) ; \n } \n select -> prev_picref = avfilter_ref_buffer ( picref , ~ 0 ) ; \n return ret ; \n }", "idx": 13229}
{"project": "FFmpeg", "commit_id": "5a4eb6aa275e4c1b80e1e125a7901903e35219f2", "target": 1, "func": "AVFilterBufferRef * avfilter_get_audio_buffer_ref_from_frame ( const AVFrame * frame , \n int perms ) \n { \n AVFilterBufferRef * samplesref = \n avfilter_get_audio_buffer_ref_from_arrays ( ( uint8_t * * ) frame -> data , frame -> linesize [ 0 ] , perms , \n frame -> nb_samples , frame -> format , \n av_frame_get_channel_layout ( frame ) ) ; \n if ( ! samplesref ) \n return NULL ; \n if ( avfilter_copy_frame_props ( samplesref , frame ) < 0 ) { \n samplesref -> buf -> data [ 0 ] = NULL ; \n avfilter_unref_bufferp ( & samplesref ) ; \n } \n return samplesref ; \n }", "idx": 13239}
{"project": "FFmpeg", "commit_id": "bfa0f96586fe2c257cfa574ffb991da493a54da1", "target": 1, "func": "static void vp8_decode_flush_impl ( AVCodecContext * avctx , int force , int is_close ) \n { \n VP8Context * s = avctx -> priv_data ; \n int i ; \n if ( ! avctx -> is_copy || force ) { \n for ( i = 0 ; i < 5 ; i ++ ) \n if ( s -> frames [ i ] . data [ 0 ] ) \n vp8_release_frame ( s , & s -> frames [ i ] , is_close ) ; \n } \n memset ( s -> framep , 0 , sizeof ( s -> framep ) ) ; \n free_buffers ( s ) ; \n s -> maps_are_invalid = 1 ; \n }", "idx": 13241}
{"project": "FFmpeg", "commit_id": "fd542b6f2026f1aa163882ee0283958598a97c31", "target": 0, "func": "int ff_unlock_avcodec ( const AVCodec * codec ) \n { \n _Bool exp = 1 ; \n if ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || ! codec -> init ) \n return 0 ; \n av_assert0 ( atomic_compare_exchange_strong ( & ff_avcodec_locked , & exp , 0 ) ) ; \n atomic_fetch_add ( & entangled_thread_counter , -1 ) ; \n if ( lockmgr_cb ) { \n if ( ( * lockmgr_cb ) ( & codec_mutex , AV_LOCK_RELEASE ) ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 13252}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void init_parse_context ( OptionParseContext * octx , \n const OptionGroupDef * groups , int nb_groups ) \n { \n static const OptionGroupDef global_group = { \" \" } ; \n int i ; \n memset ( octx , 0 , sizeof ( * octx ) ) ; \n octx -> nb_groups = nb_groups ; \n octx -> groups = av_mallocz ( sizeof ( * octx -> groups ) * octx -> nb_groups ) ; \n if ( ! octx -> groups ) \n exit ( 1 ) ; \n for ( i = 0 ; i < octx -> nb_groups ; i ++ ) \n octx -> groups [ i ] . group_def = & groups [ i ] ; \n octx -> global_opts . group_def = & global_group ; \n octx -> global_opts . arg = \" \" ; \n init_opts ( ) ; \n }", "idx": 13263}
{"project": "FFmpeg", "commit_id": "9afb7061f938831248942050cfdb449e014ed427", "target": 1, "func": "int ff_mov_read_chan ( AVFormatContext * s , AVStream * st , int64_t size ) \n { \n AVIOContext * pb = s -> pb ; \n uint32_t layout_tag , bitmap , num_descr , label_mask ; \n int i ; \n if ( size < 12 ) \n return AVERROR_INVALIDDATA ; \n layout_tag = avio_rb32 ( pb ) ; \n bitmap = avio_rb32 ( pb ) ; \n num_descr = avio_rb32 ( pb ) ; \n av_dlog ( s , \" \\n \" , \n layout_tag , bitmap , num_descr ) ; \n if ( size < 12ULL + num_descr * 20ULL ) \n return 0 ; \n label_mask = 0 ; \n for ( i = 0 ; i < num_descr ; i ++ ) { \n uint32_t label ; \n label = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n if ( layout_tag == 0 ) { \n uint32_t mask_incr = mov_get_channel_label ( label ) ; \n if ( mask_incr == 0 ) { \n label_mask = 0 ; \n break ; \n } \n label_mask |= mask_incr ; \n } \n } \n if ( layout_tag == 0 ) \n st -> codec -> channel_layout = label_mask ; \n else \n st -> codec -> channel_layout = ff_mov_get_channel_layout ( layout_tag , bitmap ) ; \n return 0 ; \n }", "idx": 13264}
{"project": "FFmpeg", "commit_id": "d62030ffcaf14dd801918fe26e670d68fdc21984", "target": 1, "func": "static void RENAME ( mix8to2 ) ( SAMPLE * * out , const SAMPLE * * in , COEFF * coeffp , integer len ) { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n INTER t = in [ 2 ] [ i ] * coeffp [ 0 * 8 + 2 ] + in [ 3 ] [ i ] * coeffp [ 0 * 8 + 3 ] ; \n out [ 0 ] [ i ] = R ( t + in [ 0 ] [ i ] * ( INTER ) coeffp [ 0 * 8 + 0 ] + in [ 4 ] [ i ] * ( INTER ) coeffp [ 0 * 8 + 4 ] + in [ 6 ] [ i ] * ( INTER ) coeffp [ 0 * 8 + 6 ] ) ; \n out [ 1 ] [ i ] = R ( t + in [ 1 ] [ i ] * ( INTER ) coeffp [ 1 * 8 + 1 ] + in [ 5 ] [ i ] * ( INTER ) coeffp [ 1 * 8 + 5 ] + in [ 7 ] [ i ] * ( INTER ) coeffp [ 1 * 8 + 7 ] ) ; \n } \n }", "idx": 13269}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "func": "static void put_audio_specific_config ( AVCodecContext * avctx ) \n { \n PutBitContext pb ; \n AACEncContext * s = avctx -> priv_data ; \n init_put_bits ( & pb , avctx -> extradata , avctx -> extradata_size * 8 ) ; \n put_bits ( & pb , 5 , 2 ) ; \n put_bits ( & pb , 4 , s -> samplerate_index ) ; \n put_bits ( & pb , 4 , s -> channels ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 1 , 0 ) ; \n put_bits ( & pb , 11 , 0x2b7 ) ; \n put_bits ( & pb , 5 , AOT_SBR ) ; \n put_bits ( & pb , 1 , 0 ) ; \n flush_put_bits ( & pb ) ; \n }", "idx": 13274}
{"project": "FFmpeg", "commit_id": "e7d4a2a721ae863488f6a3814f9dcdbc6e8f5166", "target": 1, "func": "AVBitStreamFilterContext * av_bitstream_filter_init ( const char * name ) { \n AVBitStreamFilter * bsf = first_bitstream_filter ; \n while ( bsf ) { \n if ( ! strcmp ( name , bsf -> name ) ) { \n AVBitStreamFilterContext * bsfc = av_mallocz ( sizeof ( AVBitStreamFilterContext ) ) ; \n bsfc -> filter = bsf ; \n bsfc -> priv_data = av_mallocz ( bsf -> priv_data_size ) ; \n return bsfc ; \n } \n bsf = bsf -> next ; \n } \n return NULL ; \n }", "idx": 13281}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_and_aver_dst_8w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 8 ) ; \n }", "idx": 13283}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int ac3_decode_init ( AVCodecContext * avctx ) \n { \n AC3DecodeContext * ctx = avctx -> priv_data ; \n ac3_common_init ( ) ; \n ff_mdct_init ( & ctx -> imdct_ctx_256 , 8 , 1 ) ; \n ff_mdct_init ( & ctx -> imdct_ctx_512 , 9 , 1 ) ; \n ctx -> samples = av_mallocz ( 6 * 256 * sizeof ( float ) ) ; \n if ( ! ctx -> samples ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n dither_seed ( & ctx -> state , 0 ) ; \n return 0 ; \n }", "idx": 13284}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int flashsv_encode_init ( AVCodecContext * avctx ) \n { \n FlashSVContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( avctx -> width > 4095 || avctx -> height > 4095 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n memset ( & s -> zstream , 0 , sizeof ( z_stream ) ) ; \n s -> last_key_frame = 0 ; \n s -> image_width = avctx -> width ; \n s -> image_height = avctx -> height ; \n s -> tmpblock = av_mallocz ( 3 * 256 * 256 ) ; \n s -> encbuffer = av_mallocz ( s -> image_width * s -> image_height * 3 ) ; \n if ( ! s -> tmpblock || ! s -> encbuffer ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) { \n flashsv_encode_end ( avctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 13285}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void pre_calc_cosmod ( DCAContext * s ) \n { \n int i , j , k ; \n static int cosmod_inited = 0 ; \n if ( cosmod_inited ) return ; \n for ( j = 0 , k = 0 ; k < 16 ; k ++ ) \n for ( i = 0 ; i < 16 ; i ++ ) \n cos_mod [ j ++ ] = cos ( ( 2 * i + 1 ) * ( 2 * k + 1 ) * M_PI / 64 ) ; \n for ( k = 0 ; k < 16 ; k ++ ) \n for ( i = 0 ; i < 16 ; i ++ ) \n cos_mod [ j ++ ] = cos ( ( i ) * ( 2 * k + 1 ) * M_PI / 32 ) ; \n for ( k = 0 ; k < 16 ; k ++ ) \n cos_mod [ j ++ ] = 0.25 / ( 2 * cos ( ( 2 * k + 1 ) * M_PI / 128 ) ) ; \n for ( k = 0 ; k < 16 ; k ++ ) \n cos_mod [ j ++ ] = -0.25 / ( 2.0 * sin ( ( 2 * k + 1 ) * M_PI / 128 ) ) ; \n cosmod_inited = 1 ; \n }", "idx": 13288}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_put_pixels_clamped_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixels [ 0 ] = cm [ block [ 0 ] ] ; \n pixels [ 1 ] = cm [ block [ 1 ] ] ; \n pixels [ 2 ] = cm [ block [ 2 ] ] ; \n pixels [ 3 ] = cm [ block [ 3 ] ] ; \n pixels [ 4 ] = cm [ block [ 4 ] ] ; \n pixels [ 5 ] = cm [ block [ 5 ] ] ; \n pixels [ 6 ] = cm [ block [ 6 ] ] ; \n pixels [ 7 ] = cm [ block [ 7 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 13290}
{"project": "FFmpeg", "commit_id": "b8659d94b76c9b90c0aff3c5c01bfd2be6324e93", "target": 1, "func": "int has_altivec ( void ) \n { \n #ifdef __AMIGAOS4__ \n ULONG result = 0 ; \n extern struct ExecIFace * IExec ; \n IExec -> GetCPUInfoTags ( GCIT_VectorUnit , & result , TAG_DONE ) ; \n if ( result == VECTORTYPE_ALTIVEC ) return 1 ; \n #elif __APPLE__  \n  \n  int sels [ 2 ] = { CTL_HW , HW_VECTORUNIT } ; \n int has_vu = 0 ; \n size_t len = sizeof ( has_vu ) ; \n int err ; \n err = sysctl ( sels , 2 , & has_vu , & len , NULL , 0 ) ; \n if ( err == 0 ) return ( has_vu != 0 ) ; \n #else \n #endif \n }", "idx": 13292}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_altivec ( DCTELEM block [ 64 ] ) \n { \n IDCT_START \n IDCT_1D ( NOP , NOP )  \n TRANSPOSE8 ( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 ) ; \n IDCT_1D ( ADD8 , SHIFT4 )  \n vec_st ( b0 , 0x00 , block ) ; \n vec_st ( b1 , 0x10 , block ) ; \n vec_st ( b2 , 0x20 , block ) ; \n vec_st ( b3 , 0x30 , block ) ; \n vec_st ( b4 , 0x40 , block ) ; \n vec_st ( b5 , 0x50 , block ) ; \n vec_st ( b6 , 0x60 , block ) ; \n vec_st ( b7 , 0x70 , block ) ; \n }", "idx": 13299}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8torgb24 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst += 3 ; \n } \n }", "idx": 13306}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_stss ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( int ) ) \n return -1 ; \n sc -> keyframes = av_malloc ( entries * sizeof ( int ) ) ; \n if ( ! sc -> keyframes ) \n return AVERROR ( ENOMEM ) ; \n sc -> keyframe_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> keyframes [ i ] = get_be32 ( pb ) ; \n } \n return 0 ; \n }", "idx": 13312}
{"project": "FFmpeg", "commit_id": "c7b08bc0a71f9e54e0d5036a8195648b41bd3933", "target": 1, "func": "static int r3d_seek ( AVFormatContext * s , int stream_index , int64_t sample_time , int flags ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n R3DContext * r3d = s -> priv_data ; \n int frame_num ; \n if ( ! st -> codec -> time_base . num || ! st -> time_base . den ) \n return -1 ; \n frame_num = sample_time * st -> codec -> time_base . den / \n ( ( int64_t ) st -> codec -> time_base . num * st -> time_base . den ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , \n frame_num , sample_time ) ; \n if ( frame_num < r3d -> video_offsets_count ) { \n avio_seek ( s -> pb , r3d -> video_offsets_count , SEEK_SET ) ; \n } else { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , frame_num ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 13314}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static inline int GetCode ( GifState * s ) \n { \n int c , sizbuf ; \n uint8_t * ptr ; \n while ( s -> bbits < s -> cursize ) { \n ptr = s -> pbuf ; \n if ( ptr >= s -> ebuf ) { \n if ( ! s -> eob_reached ) { \n sizbuf = get_byte ( s -> f ) ; \n s -> ebuf = s -> buf + sizbuf ; \n s -> pbuf = s -> buf ; \n if ( sizbuf > 0 ) { \n get_buffer ( s -> f , s -> buf , sizbuf ) ; \n } else { \n s -> eob_reached = 1 ; \n } \n } \n ptr = s -> pbuf ; \n } \n s -> bbuf |= ptr [ 0 ] << s -> bbits ; \n ptr ++ ; \n s -> pbuf = ptr ; \n s -> bbits += 8 ; \n } \n c = s -> bbuf & s -> curmask ; \n s -> bbuf >>= s -> cursize ; \n s -> bbits -= s -> cursize ; \n return c ; \n }", "idx": 13318}
{"project": "FFmpeg", "commit_id": "bfa0f96586fe2c257cfa574ffb991da493a54da1", "target": 1, "func": "static int vp8_alloc_frame ( VP8Context * s , AVFrame * f ) \n { \n int ret ; \n if ( ( ret = ff_thread_get_buffer ( s -> avctx , f ) ) < 0 ) \n return ret ; \n if ( ! s -> maps_are_invalid && s -> num_maps_to_be_freed ) { \n f -> ref_index [ 0 ] = s -> segmentation_maps [ -- s -> num_maps_to_be_freed ] ; \n } else if ( ! ( f -> ref_index [ 0 ] = av_mallocz ( s -> mb_width * s -> mb_height ) ) ) { \n ff_thread_release_buffer ( s -> avctx , f ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 13320}
{"project": "FFmpeg", "commit_id": "99a520000d376d60cd30fae97bfaaf13d50ee26c", "target": 1, "func": "static int64_t read_ts ( const char * s ) \n { \n int hh , mm , ss , ms ; \n if ( sscanf ( s , \" \" , & hh , & mm , & ss , & ms ) == 4 ) return ( hh * 3600 + mm * 60 + ss ) * 1000 + ms ; \n if ( sscanf ( s , \" \" , & mm , & ss , & ms ) == 3 ) return ( mm * 60 + ss ) * 1000 + ms ; \n return AV_NOPTS_VALUE ; \n }", "idx": 13321}
{"project": "FFmpeg", "commit_id": "2d15588124ab1d4c0612cab66f02a716f1509211", "target": 1, "func": "static int allocate_buffers ( ShortenContext * s ) \n { \n int i , chan , err ; \n for ( chan = 0 ; chan < s -> channels ; chan ++ ) { \n if ( FFMAX ( 1 , s -> nmean ) >= UINT_MAX / sizeof ( int32_t ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( s -> blocksize + s -> nwrap >= UINT_MAX / sizeof ( int32_t ) || \n s -> blocksize + s -> nwrap <= ( unsigned ) s -> nwrap ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( ( err = av_reallocp_array ( & s -> offset [ chan ] , \n sizeof ( int32_t ) , \n FFMAX ( 1 , s -> nmean ) ) ) < 0 ) \n return err ; \n if ( ( err = av_reallocp_array ( & s -> decoded_base [ chan ] , ( s -> blocksize + s -> nwrap ) , \n sizeof ( s -> decoded_base [ 0 ] [ 0 ] ) ) ) < 0 ) \n return err ; \n for ( i = 0 ; i < s -> nwrap ; i ++ ) \n s -> decoded_base [ chan ] [ i ] = 0 ; \n s -> decoded [ chan ] = s -> decoded_base [ chan ] + s -> nwrap ; \n } \n if ( ( err = av_reallocp_array ( & s -> coeffs , s -> nwrap , sizeof ( * s -> coeffs ) ) ) < 0 ) \n return err ; \n return 0 ; \n }", "idx": 13326}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline int rv40_loop_filter_strength ( uint8_t * src , \n int step , int stride , \n int beta , int beta2 , \n int edge , \n int * p1 , int * q1 ) \n { \n int sum_p1p0 = 0 , sum_q1q0 = 0 , sum_p1p2 = 0 , sum_q1q2 = 0 ; \n int strong0 = 0 , strong1 = 0 ; \n uint8_t * ptr ; \n int i ; \n for ( i = 0 , ptr = src ; i < 4 ; i ++ , ptr += stride ) { \n sum_p1p0 += ptr [ -2 * step ] - ptr [ -1 * step ] ; \n sum_q1q0 += ptr [ 1 * step ] - ptr [ 0 * step ] ; \n } \n * p1 = FFABS ( sum_p1p0 ) < ( beta << 2 ) ; \n * q1 = FFABS ( sum_q1q0 ) < ( beta << 2 ) ; \n if ( ! * p1 && ! * q1 ) \n return 0 ; \n if ( ! edge ) \n return 0 ; \n for ( i = 0 , ptr = src ; i < 4 ; i ++ , ptr += stride ) { \n sum_p1p2 += ptr [ -2 * step ] - ptr [ -3 * step ] ; \n sum_q1q2 += ptr [ 1 * step ] - ptr [ 2 * step ] ; \n } \n strong0 = * p1 && ( FFABS ( sum_p1p2 ) < beta2 ) ; \n strong1 = * q1 && ( FFABS ( sum_q1q2 ) < beta2 ) ; \n return strong0 && strong1 ; \n }", "idx": 13327}
{"project": "FFmpeg", "commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "target": 1, "func": "callback ( void * priv_data , int index , uint8_t * buf , int buf_size , int64_t time )  \n { \n AVFormatContext * s = priv_data ; \n struct dshow_ctx * ctx = s -> priv_data ; \n AVPacketList * * ppktl , * pktl_next ; \n WaitForSingleObject ( ctx -> mutex , INFINITE ) ; \n if ( shall_we_drop ( s , index ) ) \n goto fail ; \n pktl_next = av_mallocz ( sizeof ( AVPacketList ) ) ; \n if ( ! pktl_next ) \n goto fail ; \n if ( av_new_packet ( & pktl_next -> pkt , buf_size ) < 0 ) { \n av_free ( pktl_next ) ; \n goto fail ; \n } \n pktl_next -> pkt . stream_index = index ; \n pktl_next -> pkt . pts = time ; \n memcpy ( pktl_next -> pkt . data , buf , buf_size ) ; \n for ( ppktl = & ctx -> pktl ; * ppktl ; ppktl = & ( * ppktl ) -> next ) ; \n * ppktl = pktl_next ; \n ctx -> curbufsize [ index ] += buf_size ; \n SetEvent ( ctx -> event [ 1 ] ) ; \n ReleaseMutex ( ctx -> mutex ) ; \n return ; \n fail : \n ReleaseMutex ( ctx -> mutex ) ; \n return ; \n }", "idx": 13329}
{"project": "FFmpeg", "commit_id": "31fe3c4d23aab8b43614b1ea825603080775677e", "target": 1, "func": "int ff_mediacodec_dec_close ( AVCodecContext * avctx , MediaCodecDecContext * s ) \n { \n if ( s -> codec ) { \n ff_AMediaCodec_delete ( s -> codec ) ; \n s -> codec = NULL ; \n } \n if ( s -> format ) { \n ff_AMediaFormat_delete ( s -> format ) ; \n s -> format = NULL ; \n } \n return 0 ; \n }", "idx": 13341}
{"project": "FFmpeg", "commit_id": "816577716bc6170bccfea3b9e865618b69a4b426", "target": 1, "func": "static int append_to_cached_buf ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n DVDSubContext * ctx = avctx -> priv_data ; \n if ( ctx -> buf_size > 0xffff - buf_size ) { \n av_log ( avctx , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n av_freep ( & ctx -> buf ) ; \n return AVERROR_INVALIDDATA ; \n } \n ctx -> buf = av_realloc ( ctx -> buf , ctx -> buf_size + buf_size ) ; \n if ( ! ctx -> buf ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( ctx -> buf + ctx -> buf_size , buf , buf_size ) ; \n ctx -> buf_size += buf_size ; \n return 0 ; \n }", "idx": 13345}
{"project": "FFmpeg", "commit_id": "4cb6964244fd6c099383d8b7e99731e72cc844b9", "target": 0, "func": "av_cold void ff_dcadsp_init_x86 ( DCADSPContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE ( cpu_flags ) ) { \n #if ARCH_X86_32  \n  \n  s -> int8x8_fmul_int32 = ff_int8x8_fmul_int32_sse ; \n #endif \n s -> lfe_fir [ 0 ] = ff_dca_lfe_fir0_sse ; \n s -> lfe_fir [ 1 ] = ff_dca_lfe_fir1_sse ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n s -> int8x8_fmul_int32 = ff_int8x8_fmul_int32_sse2 ; \n } \n if ( EXTERNAL_SSE4 ( cpu_flags ) ) { \n s -> int8x8_fmul_int32 = ff_int8x8_fmul_int32_sse4 ; \n } \n }", "idx": 13350}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static int rm_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n if ( s -> streams [ pkt -> stream_index ] -> codec . codec_type == \n CODEC_TYPE_AUDIO ) \n return rm_write_audio ( s , pkt -> data , pkt -> size ) ; \n else \n return rm_write_video ( s , pkt -> data , pkt -> size ) ; \n }", "idx": 13383}
{"project": "FFmpeg", "commit_id": "2e59142fa9a0db5fab8aa2e676ba524f61280b83", "target": 0, "func": "static int sctp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n SCTPContext * s = h -> priv_data ; \n int ret ; \n if ( ! ( h -> flags & AVIO_FLAG_NONBLOCK ) ) { \n ret = sctp_wait_fd ( s -> fd , 1 ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( s -> max_streams ) { \n struct sctp_sndrcvinfo info = { 0 } ; \n info . sinfo_stream = AV_RB16 ( buf ) ; \n if ( info . sinfo_stream > s -> max_streams ) \n abort ( ) ; \n ret = ff_sctp_send ( s -> fd , buf + 2 , size - 2 , & info , MSG_EOR ) ; \n } else \n ret = send ( s -> fd , buf , size , 0 ) ; \n return ret < 0 ? ff_neterrno ( ) : ret ; \n }", "idx": 13386}
{"project": "FFmpeg", "commit_id": "631c56a8e46dea41585f3e7b3ef9c52b49faa385", "target": 0, "func": "int avformat_network_init ( void ) \n { \n #if CONFIG_NETWORK  \n  \n  int ret ; \n ff_network_inited_globally = 1 ; \n if ( ( ret = ff_network_init ( ) ) < 0 ) \n return ret ; \n if ( ( ret = ff_tls_init ( ) ) < 0 ) \n return ret ; \n #endif \n return 0 ; \n }", "idx": 13387}
{"project": "FFmpeg", "commit_id": "582552fb56ba6559cb1d094a7e7ae5dde3073c5c", "target": 0, "func": "static inline void cvtyuvtoRGB ( SwsContext * c , \n vector signed short Y , vector signed short U , vector signed short V , \n vector signed short * R , vector signed short * G , vector signed short * B ) \n { \n vector signed  short vx , ux , uvx ; \n Y = vec_mradds ( Y , c -> CY , c -> OY ) ; \n U = vec_sub ( U , ( vector signed short ) ( 128 ) ) ; \n V = vec_sub ( V , ( vector signed short ) ( 128 ) ) ; \n ux = vec_sl ( U , c -> CSHIFT ) ; \n * B = vec_mradds ( ux , c -> CBU , Y ) ; \n vx = vec_sl ( V , c -> CSHIFT ) ; \n * R = vec_mradds ( vx , c -> CRV , Y ) ; \n uvx = vec_mradds ( U , c -> CGU , Y ) ; \n * G = vec_mradds ( V , c -> CGV , uvx ) ; \n }", "idx": 13390}
{"project": "FFmpeg", "commit_id": "bfa0f96586fe2c257cfa574ffb991da493a54da1", "target": 1, "func": "static void vp8_release_frame ( VP8Context * s , AVFrame * f , int is_close ) \n { \n if ( ! is_close ) { \n if ( f -> ref_index [ 0 ] ) { \n assert ( s -> num_maps_to_be_freed < FF_ARRAY_ELEMS ( s -> segmentation_maps ) ) ; \n s -> segmentation_maps [ s -> num_maps_to_be_freed ++ ] = f -> ref_index [ 0 ] ; \n f -> ref_index [ 0 ] = NULL ; \n } \n } else { \n av_freep ( & f -> ref_index [ 0 ] ) ; \n } \n ff_thread_release_buffer ( s -> avctx , f ) ; \n }", "idx": 13397}
{"project": "FFmpeg", "commit_id": "0062869ae25007c8506517dcfcbe6f439dc6958a", "target": 1, "func": "static int smacker_probe ( AVProbeData * p ) \n { \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && p -> buf [ 2 ] == ' ' \n && ( p -> buf [ 3 ] == ' ' || p -> buf [ 3 ] == ' ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 13399}
{"project": "FFmpeg", "commit_id": "92ea249d7db4baf64680f412c6bd99ff85860723", "target": 0, "func": "static inline int round_sample ( int64_t * sum ) \n { \n int sum1 ; \n sum1 = ( int ) ( ( * sum ) >> OUT_SHIFT ) ; \n * sum &= ( 1 << OUT_SHIFT ) - 1 ; \n return av_clip ( sum1 , OUT_MIN , OUT_MAX ) ; \n }", "idx": 13403}
{"project": "FFmpeg", "commit_id": "4ff94558f23a5de43aed4ca3429963dd1d995250", "target": 1, "func": "static void cabac_reinit ( HEVCLocalContext * lc ) \n { \n skip_bytes ( & lc -> cc , 0 ) ; \n }", "idx": 13436}
{"project": "FFmpeg", "commit_id": "857cd1f33bcf86005529af2a77f861f884327be5", "target": 0, "func": "static int RENAME ( resample_linear ) ( ResampleContext * c , \n DELEM * dst , const DELEM * src , \n int n , int update_ctx ) \n { \n int dst_index ; \n int index = c -> index ; \n int frac = c -> frac ; \n int sample_index = index >> c -> phase_shift ; \n #if FILTER_SHIFT == 0  \n  \n  double inv_src_incr = 1.0 / c -> src_incr ; \n #endif \n index &= c -> phase_mask ; \n for ( dst_index = 0 ; dst_index < n ; dst_index ++ ) { \n FELEM * filter = ( ( FELEM * ) c -> filter_bank ) + c -> filter_alloc * index ; \n FELEM2 val = 0 , v2 = 0 ; \n int i ; \n for ( i = 0 ; i < c -> filter_length ; i ++ ) { \n val += src [ sample_index + i ] * ( FELEM2 ) filter [ i ] ; \n v2 += src [ sample_index + i ] * ( FELEM2 ) filter [ i + c -> filter_alloc ] ; \n } \n #ifdef FELEML \n val += ( v2 - val ) * ( FELEML ) frac / c -> src_incr ; \n #else \n #    if FILTER_SHIFT == 0  \n  \n  val += ( v2 - val ) * inv_src_incr * frac ; \n #    else \n val += ( v2 - val ) / c -> src_incr * frac ; \n #    endif \n #endif \n OUT ( dst [ dst_index ] , val ) ; \n frac += c -> dst_incr_mod ; \n index += c -> dst_incr_div ; \n if ( frac >= c -> src_incr ) { \n frac -= c -> src_incr ; \n index ++ ; \n } \n sample_index += index >> c -> phase_shift ; \n index &= c -> phase_mask ; \n } \n if ( update_ctx ) { \n c -> frac = frac ; \n c -> index = index ; \n } \n return sample_index ; \n }", "idx": 13441}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "int ff_h263_resync ( MpegEncContext * s ) { \n int left , ret ; \n if ( s -> codec_id == CODEC_ID_MPEG4 ) \n skip_bits1 ( & s -> gb ) ; \n align_get_bits ( & s -> gb ) ; \n if ( show_bits ( & s -> gb , 16 ) == 0 ) { \n if ( s -> codec_id == CODEC_ID_MPEG4 ) \n ret = mpeg4_decode_video_packet_header ( s ) ; \n else \n ret = h263_decode_gob_header ( s ) ; \n if ( ret >= 0 ) \n return 0 ; \n } \n s -> gb = s -> last_resync_gb ; \n align_get_bits ( & s -> gb ) ; \n left = s -> gb . size * 8 - get_bits_count ( & s -> gb ) ; \n for ( ; left > 16 + 1 + 5 + 5 ; left -= 8 ) { \n if ( show_bits ( & s -> gb , 16 ) == 0 ) { \n GetBitContext bak = s -> gb ; \n if ( s -> codec_id == CODEC_ID_MPEG4 ) \n ret = mpeg4_decode_video_packet_header ( s ) ; \n else \n ret = h263_decode_gob_header ( s ) ; \n if ( ret >= 0 ) \n return 0 ; \n s -> gb = bak ; \n } \n skip_bits ( & s -> gb , 8 ) ; \n } \n return -1 ; \n }", "idx": 13443}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void add_pixels_clamped2_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n pixels [ 0 ] = cm [ pixels [ 0 ] + block [ 0 ] ] ; \n pixels [ 1 ] = cm [ pixels [ 1 ] + block [ 1 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 13445}
{"project": "FFmpeg", "commit_id": "5e885275f1eda3f0281747d9c78d072adb8bc940", "target": 1, "func": "int ff_MPV_lowest_referenced_row ( MpegEncContext * s , int dir ) \n { \n int my_max = INT_MIN , my_min = INT_MAX , qpel_shift = ! s -> quarter_sample ; \n int my , off , i , mvs ; \n if ( s -> picture_structure != PICT_FRAME ) goto unhandled ; \n switch ( s -> mv_type ) { \n case MV_TYPE_16X16 : \n mvs = 1 ; \n break ; \n case MV_TYPE_16X8 : \n mvs = 2 ; \n break ; \n case MV_TYPE_8X8 : \n mvs = 4 ; \n break ; \n default : \n goto unhandled ; \n } \n for ( i = 0 ; i < mvs ; i ++ ) { \n my = s -> mv [ dir ] [ i ] [ 1 ] << qpel_shift ; \n my_max = FFMAX ( my_max , my ) ; \n my_min = FFMIN ( my_min , my ) ; \n } \n off = ( FFMAX ( - my_min , my_max ) + 63 ) >> 6 ; \n return FFMIN ( FFMAX ( s -> mb_y + off , 0 ) , s -> mb_height - 1 ) ; \n unhandled : \n return s -> mb_height - 1 ; \n }", "idx": 13451}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline int snake_search ( MpegEncContext * s , int * best , int dmin , \n UINT8 * new_pic , UINT8 * old_pic , int pic_stride , \n int pred_x , int pred_y , UINT16 * mv_penalty , int quant , \n int xmin , int ymin , int xmax , int ymax , int shift ) \n { \n int dir = 0 ; \n int c = 1 ; \n static int x_dir [ 8 ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; \n static int y_dir [ 8 ] = { 0 , 1 , 1 , 1 , 0 , -1 , -1 , -1 } ; \n int fails = 0 ; \n int last_d [ 2 ] = { dmin , dmin } ; \n for ( ; ; ) { \n int x = best [ 0 ] ; \n int y = best [ 1 ] ; \n int d ; \n x += x_dir [ dir ] ; \n y += y_dir [ dir ] ; \n if ( x >= xmin && x <= xmax && y >= ymin && y <= ymax ) { \n d = pix_abs16x16 ( new_pic , old_pic + ( x ) + ( y ) * pic_stride , pic_stride ) ; \n d += ( mv_penalty [ ( ( x ) << shift ) - pred_x ] + mv_penalty [ ( ( y ) << shift ) - pred_y ] ) * quant ; \n } else { \n d = dmin + 10000 ; \n } \n if ( d < dmin ) { \n best [ 0 ] = x ; \n best [ 1 ] = y ; \n dmin = d ; \n if ( last_d [ 1 ] - last_d [ 0 ] > last_d [ 0 ] - d ) c = - c ; \n dir += c ; \n fails = 0 ; \n last_d [ 1 ] = last_d [ 0 ] ; \n last_d [ 0 ] = d ; \n } else { \n if ( fails ) { \n if ( fails >= 3 ) return dmin ; \n } else { \n c = - c ; \n } \n dir += c * 2 ; \n fails ++ ; \n } \n dir &= 7 ; \n } \n }", "idx": 13452}
{"project": "FFmpeg", "commit_id": "c3b6454d801638b091b51fe62937e6831a3a37b2", "target": 1, "func": "AVFixedDSPContext * avpriv_alloc_fixed_dsp ( int bit_exact ) \n { \n AVFixedDSPContext * fdsp = av_malloc ( sizeof ( AVFixedDSPContext ) ) ; \n fdsp -> vector_fmul_window_scaled = vector_fmul_window_fixed_scaled_c ; \n fdsp -> vector_fmul_window = vector_fmul_window_fixed_c ; \n return fdsp ; \n }", "idx": 13454}
{"project": "FFmpeg", "commit_id": "a8dbe9514f865f6a8efb304a720025cb1ef9ae3f", "target": 0, "func": "void av_close_input_file ( AVFormatContext * s ) \n { \n int i ; \n if ( s -> iformat -> read_close ) \n s -> iformat -> read_close ( s ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n av_free ( s -> streams [ i ] ) ; \n } \n if ( s -> packet_buffer ) { \n AVPacketList * p , * p1 ; \n p = s -> packet_buffer ; \n while ( p != NULL ) { \n p1 = p -> next ; \n av_free_packet ( & p -> pkt ) ; \n av_free ( p ) ; \n p = p1 ; \n } \n s -> packet_buffer = NULL ; \n } \n if ( ! ( s -> iformat -> flags & AVFMT_NOFILE ) ) { \n url_fclose ( & s -> pb ) ; \n } \n av_free ( s -> priv_data ) ; \n av_free ( s ) ; \n }", "idx": 13461}
{"project": "FFmpeg", "commit_id": "cb08687180683a755d0fe9d425280d0e4d1e6db2", "target": 1, "func": "static int vqf_read_seek ( AVFormatContext * s , \n int stream_index , int64_t timestamp , int flags ) \n { \n VqfContext * c = s -> priv_data ; \n AVStream * st ; \n int ret ; \n int64_t pos ; \n st = s -> streams [ stream_index ] ; \n pos = av_rescale_rnd ( timestamp * st -> codec -> bit_rate , \n st -> time_base . num , \n st -> time_base . den * ( int64_t ) c -> frame_bit_len , \n ( flags & AVSEEK_FLAG_BACKWARD ) ? \n AV_ROUND_DOWN : AV_ROUND_UP ) ; \n pos *= c -> frame_bit_len ; \n st -> cur_dts = av_rescale ( pos , st -> time_base . den , \n st -> codec -> bit_rate * ( int64_t ) st -> time_base . num ) ; \n if ( ( ret = avio_seek ( s -> pb , ( ( pos - 7 ) >> 3 ) + s -> internal -> data_offset , SEEK_SET ) ) < 0 ) \n return ret ; \n c -> remaining_bits = -7 - ( ( pos - 7 ) & 7 ) ; \n return 0 ; \n }", "idx": 13469}
{"project": "FFmpeg", "commit_id": "cac8de2da5c4935773128335c11b806faa73e19d", "target": 1, "func": "static void copy_context_reset ( AVCodecContext * avctx ) \n { \n av_opt_free ( avctx ) ; \n av_freep ( & avctx -> rc_override ) ; \n av_freep ( & avctx -> intra_matrix ) ; \n av_freep ( & avctx -> inter_matrix ) ; \n av_freep ( & avctx -> extradata ) ; \n av_freep ( & avctx -> subtitle_header ) ; \n av_buffer_unref ( & avctx -> hw_frames_ctx ) ; \n avctx -> subtitle_header_size = 0 ; \n avctx -> extradata_size = 0 ; \n }", "idx": 13471}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb16ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d = ( ( uint16_t * ) src ) [ i ] ; \n int r = d & 0x1F ; \n int g = ( d >> 5 ) & 0x3F ; \n int b = ( d >> 11 ) & 0x1F ; \n dst [ i ] = ( ( 2 * RY * r + GY * g + 2 * BY * b ) >> ( RGB2YUV_SHIFT - 2 ) ) + 16 ; \n } \n }", "idx": 13473}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8tobgr16 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = bswap_16 ( ( ( uint16_t * ) palette ) [ src [ i ] ] ) ; \n }", "idx": 13475}
{"project": "FFmpeg", "commit_id": "67afcefb35932b420998f6f3fda46c7c85848a3f", "target": 0, "func": "static int vda_h264_decode_slice ( AVCodecContext * avctx , \n const uint8_t * buffer , \n uint32_t size ) \n { \n VDAContext * vda = avctx -> internal -> hwaccel_priv_data ; \n struct vda_context * vda_ctx = avctx -> hwaccel_context ; \n void * tmp ; \n if ( ! vda_ctx -> decoder ) \n return -1 ; \n tmp = av_fast_realloc ( vda -> bitstream , \n & vda -> allocated_size , \n vda -> bitstream_size + size + 4 ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n vda -> bitstream = tmp ; \n AV_WB32 ( vda -> bitstream + vda -> bitstream_size , size ) ; \n memcpy ( vda -> bitstream + vda -> bitstream_size + 4 , buffer , size ) ; \n vda -> bitstream_size += size + 4 ; \n return 0 ; \n }", "idx": 13476}
{"project": "FFmpeg", "commit_id": "3e8c4f96890294e1b7de2d22ab3cfec7e1d7c48f", "target": 0, "func": "static void print_tag ( const char * str , unsigned int tag , int size ) \n { \n dprintf ( NULL , \" \\n \" , \n str , tag & 0xff , \n ( tag >> 8 ) & 0xff , \n ( tag >> 16 ) & 0xff , \n ( tag >> 24 ) & 0xff , \n size ) ; \n }", "idx": 13477}
{"project": "FFmpeg", "commit_id": "b829b4ce29185625ab8cbcf0ce7a83cf8181ac3b", "target": 0, "func": "static void h264_loop_filter_strength_mmx2 ( int16_t bS [ 2 ] [ 4 ] [ 4 ] , uint8_t nnz [ 40 ] , int8_t ref [ 2 ] [ 40 ] , int16_t mv [ 2 ] [ 40 ] [ 2 ] , \n int bidir , int edges , int step , int mask_mv0 , int mask_mv1 , int field ) { \n __asm__ volatile ( \n \" \\n \" \n \" \\n \" \n :: \" \" ( ff_pb_1 ) , \" \" ( ff_pb_3 ) \n ) ; \n if ( field ) \n __asm__ volatile ( \n \" \\n \" \n :: \" \" ( ff_pb_3_1 ) \n ) ; \n __asm__ volatile ( \n \" \\n \" \n \" \\n \" \n : ) ; \n step <<= 3 ; \n edges <<= 3 ; \n h264_loop_filter_strength_iteration_mmx2 ( bS , nnz , ref , mv , bidir , edges , step , mask_mv1 , 1 , -8 , 0 ) ; \n h264_loop_filter_strength_iteration_mmx2 ( bS , nnz , ref , mv , bidir , 32 , 8 , mask_mv0 , 0 , -1 , -1 ) ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n TRANSPOSE4 ( % % mm0 , % % mm1 , % % mm2 , % % mm3 , % % mm4 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( bS [ 0 ] ) \n : \" \" \n ) ; \n }", "idx": 13478}
{"project": "FFmpeg", "commit_id": "91141f2a13bcb36b849335d1d10c01b596d773bb", "target": 1, "func": "int avfilter_copy_frame_props ( AVFilterBufferRef * dst , const AVFrame * src ) \n { \n dst -> pts = src -> pts ; \n dst -> pos = av_frame_get_pkt_pos ( src ) ; \n dst -> format = src -> format ; \n switch ( dst -> type ) { \n case AVMEDIA_TYPE_VIDEO : \n dst -> video -> w = src -> width ; \n dst -> video -> h = src -> height ; \n dst -> video -> sample_aspect_ratio = src -> sample_aspect_ratio ; \n dst -> video -> interlaced = src -> interlaced_frame ; \n dst -> video -> top_field_first = src -> top_field_first ; \n dst -> video -> key_frame = src -> key_frame ; \n dst -> video -> pict_type = src -> pict_type ; \n av_freep ( & dst -> video -> qp_table ) ; \n dst -> video -> qp_table_linesize = 0 ; \n if ( src -> qscale_table ) { \n int qsize = src -> qstride ? src -> qstride * ( ( src -> height + 15 ) / 16 ) : ( src -> width + 15 ) / 16 ; \n dst -> video -> qp_table = av_malloc ( qsize ) ; \n if ( ! dst -> video -> qp_table ) \n return AVERROR ( ENOMEM ) ; \n dst -> video -> qp_table_linesize = src -> qstride ; \n memcpy ( dst -> video -> qp_table , src -> qscale_table , qsize ) ; \n } \n break ; \n case AVMEDIA_TYPE_AUDIO : \n dst -> audio -> sample_rate = src -> sample_rate ; \n dst -> audio -> channel_layout = src -> channel_layout ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 13480}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_v_loop_filter_luma_c ( uint8_t * pix , int stride , int alpha , int beta , int8_t * tc0 ) \n { \n h264_loop_filter_luma_c ( pix , stride , 1 , alpha , beta , tc0 ) ; \n }", "idx": 13492}
{"project": "FFmpeg", "commit_id": "c9ff32215b433d505f251c1f212b1fa0a5e17b73", "target": 0, "func": "int av_opt_set_pixel_fmt ( void * obj , const char * name , enum AVPixelFormat fmt , int search_flags ) \n { \n return set_format ( obj , name , fmt , search_flags , AV_OPT_TYPE_PIXEL_FMT , \" \" , AV_PIX_FMT_NB - 1 ) ; \n }", "idx": 13503}
{"project": "FFmpeg", "commit_id": "3992526b3c43278945d00fac6e2ba5cb8f810ef3", "target": 0, "func": "static void vc1_loop_filter ( uint8_t * src , int step , int stride , int len , int pq ) \n { \n int i ; \n int filt3 ; \n for ( i = 0 ; i < len ; i += 4 ) { \n filt3 = vc1_filter_line ( src + 2 * step , stride , pq ) ; \n if ( filt3 ) { \n vc1_filter_line ( src + 0 * step , stride , pq ) ; \n vc1_filter_line ( src + 1 * step , stride , pq ) ; \n vc1_filter_line ( src + 3 * step , stride , pq ) ; \n } \n src += step * 4 ; \n } \n }", "idx": 13522}
{"project": "FFmpeg", "commit_id": "0d021cc8b30a6f81c27fbeca7f99f1ee7a20acf8", "target": 0, "func": "static av_cold int nvenc_open_session ( AVCodecContext * avctx ) \n { \n NvencContext * ctx = avctx -> priv_data ; \n NvencDynLoadFunctions * dl_fn = & ctx -> nvenc_dload_funcs ; \n NV_ENCODE_API_FUNCTION_LIST * p_nvenc = & dl_fn -> nvenc_funcs ; \n NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS encode_session_params = { 0 } ; \n NVENCSTATUS nv_status ; \n encode_session_params . version = NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER ; \n encode_session_params . apiVersion = NVENCAPI_VERSION ; \n encode_session_params . device = ctx -> cu_context ; \n encode_session_params . deviceType = NV_ENC_DEVICE_TYPE_CUDA ; \n nv_status = p_nvenc -> nvEncOpenEncodeSessionEx ( & encode_session_params , & ctx -> nvencoder ) ; \n if ( nv_status != NV_ENC_SUCCESS ) { \n ctx -> nvencoder = NULL ; \n return nvenc_print_error ( avctx , nv_status , \" \" ) ; \n } \n return 0 ; \n }", "idx": 13523}
{"project": "FFmpeg", "commit_id": "2c79288d4e0bcb8d3a8a908813fc9cc586dd7fdd", "target": 1, "func": "int ff_wma_end ( AVCodecContext * avctx ) \n { \n WMACodecContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> nb_block_sizes ; i ++ ) \n ff_mdct_end ( & s -> mdct_ctx [ i ] ) ; \n for ( i = 0 ; i < s -> nb_block_sizes ; i ++ ) \n av_free ( s -> windows [ i ] ) ; \n if ( s -> use_exp_vlc ) { \n free_vlc ( & s -> exp_vlc ) ; \n } \n if ( s -> use_noise_coding ) { \n free_vlc ( & s -> hgain_vlc ) ; \n } \n for ( i = 0 ; i < 2 ; i ++ ) { \n free_vlc ( & s -> coef_vlc [ i ] ) ; \n av_free ( s -> run_table [ i ] ) ; \n av_free ( s -> level_table [ i ] ) ; \n } \n return 0 ; \n }", "idx": 13534}
{"project": "FFmpeg", "commit_id": "ab87df9a47cd31bfcae9acd84c04705a149dfc14", "target": 1, "func": "static int check ( AVIOContext * pb , int64_t pos , uint32_t * ret_header ) \n { \n int64_t ret = avio_seek ( pb , pos , SEEK_SET ) ; \n uint8_t header_buf [ 4 ] ; \n unsigned header ; \n MPADecodeHeader sd ; \n if ( ret < 0 ) \n return CHECK_SEEK_FAILED ; \n ret = avio_read ( pb , & header_buf [ 0 ] , 4 ) ; \n if ( ret < 0 ) \n return CHECK_SEEK_FAILED ; \n header = AV_RB32 ( & header_buf [ 0 ] ) ; \n if ( ff_mpa_check_header ( header ) < 0 ) \n return CHECK_WRONG_HEADER ; \n if ( avpriv_mpegaudio_decode_header ( & sd , header ) == 1 ) \n return CHECK_WRONG_HEADER ; \n if ( ret_header ) \n * ret_header = header ; \n return sd . frame_size ; \n }", "idx": 13538}
{"project": "FFmpeg", "commit_id": "51da7d02748cc54b7d009115e76efa940b99a8ef", "target": 0, "func": "static void get_aac_sample_rates ( AVFormatContext * s , AVCodecContext * codec , \n int * sample_rate , int * output_sample_rate ) \n { \n MPEG4AudioConfig mp4ac ; \n if ( avpriv_mpeg4audio_get_config ( & mp4ac , codec -> extradata , \n codec -> extradata_size * 8 , 1 ) < 0 ) { \n av_log ( s , AV_LOG_WARNING , \n \" \\n \" ) ; \n return ; \n } \n * sample_rate = mp4ac . sample_rate ; \n * output_sample_rate = mp4ac . ext_sample_rate ; \n }", "idx": 13540}
{"project": "FFmpeg", "commit_id": "956c901c68eff78288f40e3c8f41ee2fa081d4a8", "target": 1, "func": "static void matroska_merge_packets ( AVPacket * out , AVPacket * in ) \n { \n out -> data = av_realloc ( out -> data , out -> size + in -> size ) ; \n memcpy ( out -> data + out -> size , in -> data , in -> size ) ; \n out -> size += in -> size ; \n av_destruct_packet ( in ) ; \n av_free ( in ) ; \n }", "idx": 13542}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static int decode_pal ( MSS12Context * ctx , ArithCoder * acoder ) \n { \n int i , ncol , r , g , b ; \n uint32_t * pal = ctx -> pal + 256 - ctx -> free_colours ; \n if ( ! ctx -> free_colours ) \n return 0 ; \n ncol = arith_get_number ( acoder , ctx -> free_colours + 1 ) ; \n for ( i = 0 ; i < ncol ; i ++ ) { \n r = arith_get_bits ( acoder , 8 ) ; \n g = arith_get_bits ( acoder , 8 ) ; \n b = arith_get_bits ( acoder , 8 ) ; \n * pal ++ = ( 0xFF << 24 ) | ( r << 16 ) | ( g << 8 ) | b ; \n } \n return ! ! ncol ; \n }", "idx": 13543}
{"project": "FFmpeg", "commit_id": "4fb311c804098d78e5ce5f527f9a9c37536d3a08", "target": 0, "func": "void av_free ( void * ptr ) \n { \n #if CONFIG_MEMALIGN_HACK  \n  \n  if ( ptr ) \n free ( ( char * ) ptr - ( ( char * ) ptr ) [ -1 ] ) ; \n #elif HAVE_ALIGNED_MALLOC  \n  \n  _aligned_free ( ptr ) ; \n #else \n free ( ptr ) ; \n #endif \n }", "idx": 13550}
{"project": "FFmpeg", "commit_id": "9eef2b77b29189606148e1fdf5d6c8d7b52b08b0", "target": 0, "func": "static int tcp_read ( URLContext * h , uint8_t * buf , int size ) \n { \n TCPContext * s = h -> priv_data ; \n int size1 , len , fd_max ; \n fd_set rfds ; \n struct timeval tv ; \n size1 = size ; \n while ( size > 0 ) { \n if ( url_interrupt_cb ( ) ) \n return - EINTR ; \n fd_max = s -> fd ; \n FD_ZERO ( & rfds ) ; \n FD_SET ( s -> fd , & rfds ) ; \n tv . tv_sec = 0 ; \n tv . tv_usec = 100 * 1000 ; \n select ( fd_max + 1 , & rfds , NULL , NULL , & tv ) ; \n #ifdef __BEOS__ \n len = recv ( s -> fd , buf , size , 0 ) ; \n #else \n len = read ( s -> fd , buf , size ) ; \n #endif \n if ( len < 0 ) { \n if ( errno != EINTR && errno != EAGAIN )  \n #ifdef __BEOS__ \n return errno ; \n #else \n return - errno ; \n #endif \n else \n continue ; \n } else if ( len == 0 ) { \n break ; \n } \n size -= len ; \n buf += len ; \n } \n return size1 - size ; \n }", "idx": 13594}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_weight_h264_pixels16_8_msa ( uint8_t * src , int stride , \n int height , int log2_denom , \n int weight_src , int offset ) \n { \n avc_wgt_16width_msa ( src , stride , \n height , log2_denom , weight_src , offset ) ; \n }", "idx": 13600}
{"project": "FFmpeg", "commit_id": "dc5d1515681b57a257443ba72bb81fb3e6e6621b", "target": 0, "func": "static int format_name ( char * buf , int buf_len , int index ) \n { \n const char * proto , * dir ; \n char * orig_buf_dup = NULL , * mod_buf_dup = NULL ; \n int ret = 0 ; \n if ( ! av_stristr ( buf , \" \" ) ) \n return ret ; \n orig_buf_dup = av_strdup ( buf ) ; \n if ( ! orig_buf_dup ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( replace_int_data_in_filename ( buf , buf_len , orig_buf_dup , ' ' , index ) < 1 ) { \n ret = AVERROR ( EINVAL ) ; \n goto fail ; \n } \n proto = avio_find_protocol_name ( orig_buf_dup ) ; \n dir = av_dirname ( orig_buf_dup ) ; \n if ( av_stristr ( dir , \" \" ) && proto && ! strcmp ( proto , \" \" ) ) { \n mod_buf_dup = av_strdup ( buf ) ; \n if ( ! mod_buf_dup ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n dir = av_dirname ( mod_buf_dup ) ; \n if ( mkdir_p ( dir ) == -1 && errno != EEXIST ) { \n ret = AVERROR ( errno ) ; \n goto fail ; \n } \n } \n fail : \n av_freep ( & orig_buf_dup ) ; \n av_freep ( & mod_buf_dup ) ; \n return ret ; \n }", "idx": 13602}
{"project": "FFmpeg", "commit_id": "6fae8c5443d4fa40fe65f67138f4dbb731f23d72", "target": 1, "func": "static av_cold int init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n UnsharpContext * unsharp = ctx -> priv ; \n int lmsize_x = 5 , cmsize_x = 0 ; \n int lmsize_y = 5 , cmsize_y = 0 ; \n double lamount = 1.0f , camount = 0.0f ; \n if ( args ) \n sscanf ( args , \" \" , & lmsize_x , & lmsize_y , & lamount , \n & cmsize_x , & cmsize_y , & camount ) ; \n if ( lmsize_x < 2 || lmsize_y < 2 || cmsize_x < 2 || cmsize_y < 2 ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n lmsize_x , lmsize_y , cmsize_x , cmsize_y ) ; \n return AVERROR ( EINVAL ) ; \n } \n set_filter_param ( & unsharp -> luma , lmsize_x , lmsize_y , lamount ) ; \n set_filter_param ( & unsharp -> chroma , cmsize_x , cmsize_y , camount ) ; \n return 0 ; \n }", "idx": 13611}
{"project": "FFmpeg", "commit_id": "41836c4e306e572ecf80d5a714aaec532c7ece60", "target": 1, "func": "static int libx265_encode_frame ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * pic , int * got_packet ) \n { \n libx265Context * ctx = avctx -> priv_data ; \n x265_picture x265pic ; \n x265_picture x265pic_out = { { 0 } } ; \n x265_nal * nal ; \n uint8_t * dst ; \n int payload = 0 ; \n int nnal ; \n int ret ; \n int i ; \n if ( pic ) { \n for ( i = 0 ; i < 3 ; i ++ ) { \n x265pic . planes [ i ] = pic -> data [ i ] ; \n x265pic . stride [ i ] = pic -> linesize [ i ] ; \n } \n x265pic . pts = pic -> pts ; \n } \n ret = x265_encoder_encode ( ctx -> encoder , & nal , & nnal , \n pic ? & x265pic : NULL , & x265pic_out ) ; \n if ( ret < 0 ) \n return AVERROR_UNKNOWN ; \n if ( ! nnal ) \n return 0 ; \n for ( i = 0 ; i < nnal ; i ++ ) \n payload += nal [ i ] . sizeBytes ; \n payload += ctx -> header_size ; \n ret = ff_alloc_packet ( pkt , payload ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n dst = pkt -> data ; \n if ( ctx -> header ) { \n memcpy ( dst , ctx -> header , ctx -> header_size ) ; \n dst += ctx -> header_size ; \n av_freep ( & ctx -> header ) ; \n ctx -> header_size = 0 ; \n } \n for ( i = 0 ; i < nnal ; i ++ ) { \n memcpy ( dst , nal [ i ] . payload , nal [ i ] . sizeBytes ) ; \n dst += nal [ i ] . sizeBytes ; \n if ( is_keyframe ( nal [ i ] . type ) ) \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n } \n pkt -> pts = x265pic_out . pts ; \n pkt -> dts = x265pic_out . dts ; \n * got_packet = 1 ; \n return 0 ; \n }", "idx": 13614}
{"project": "FFmpeg", "commit_id": "de1568a452d8348917fee533fe17517131dccf95", "target": 1, "func": "static int add_file ( AVFormatContext * avf , char * filename , ConcatFile * * rfile , \n unsigned * nb_files_alloc ) \n { \n ConcatContext * cat = avf -> priv_data ; \n ConcatFile * file ; \n char * url ; \n size_t url_len ; \n if ( cat -> safe > 0 && ! safe_filename ( filename ) ) { \n av_log ( avf , AV_LOG_ERROR , \" \\n \" , filename ) ; \n return AVERROR ( EPERM ) ; \n } \n url_len = strlen ( avf -> filename ) + strlen ( filename ) + 16 ; \n if ( ! ( url = av_malloc ( url_len ) ) ) \n return AVERROR ( ENOMEM ) ; \n ff_make_absolute_url ( url , url_len , avf -> filename , filename ) ; \n av_free ( filename ) ; \n if ( cat -> nb_files >= * nb_files_alloc ) { \n size_t n = FFMAX ( * nb_files_alloc * 2 , 16 ) ; \n ConcatFile * new_files ; \n if ( n <= cat -> nb_files || n > SIZE_MAX / sizeof ( * cat -> files ) || \n ! ( new_files = av_realloc ( cat -> files , n * sizeof ( * cat -> files ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n cat -> files = new_files ; \n * nb_files_alloc = n ; \n } \n file = & cat -> files [ cat -> nb_files ++ ] ; \n memset ( file , 0 , sizeof ( * file ) ) ; \n * rfile = file ; \n file -> url = url ; \n file -> start_time = AV_NOPTS_VALUE ; \n file -> duration = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 13618}
{"project": "FFmpeg", "commit_id": "6fb2fd895e858ab93f46e656a322778ee181c307", "target": 1, "func": "void avfilter_copy_buffer_ref_props ( AVFilterBufferRef * dst , AVFilterBufferRef * src ) \n { \n dst -> pts = src -> pts ; \n dst -> pos = src -> pos ; \n switch ( src -> type ) { \n case AVMEDIA_TYPE_VIDEO : { \n if ( dst -> video -> qp_table ) \n av_freep ( & dst -> video -> qp_table ) ; \n copy_video_props ( dst -> video , src -> video ) ; \n break ; \n } \n case AVMEDIA_TYPE_AUDIO : * dst -> audio = * src -> audio ; break ; \n default : break ; \n } \n }", "idx": 13619}
{"project": "FFmpeg", "commit_id": "3c11a27b440e27c3796592aa8fb7fed966386a21", "target": 1, "func": "int ff_find_unused_picture ( MpegEncContext * s , int shared ) { \n int i ; \n if ( shared ) { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . data [ 0 ] == NULL && s -> picture [ i ] . type == 0 ) return i ; \n } \n } else { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . data [ 0 ] == NULL && s -> picture [ i ] . type != 0 ) return i ; \n } \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . data [ 0 ] == NULL ) return i ; \n } \n } \n assert ( 0 ) ; \n return -1 ; \n }", "idx": 13621}
{"project": "FFmpeg", "commit_id": "8813d55fa5978660d9f4e7dbe1f50da9922be08d", "target": 0, "func": "static void destroy_buffers ( VADisplay display , VABufferID * buffers , unsigned int n_buffers ) \n { \n unsigned int i ; \n for ( i = 0 ; i < n_buffers ; i ++ ) { \n if ( buffers [ i ] ) { \n vaDestroyBuffer ( display , buffers [ i ] ) ; \n buffers [ i ] = 0 ; \n } \n } \n }", "idx": 13624}
{"project": "FFmpeg", "commit_id": "a566c952f905639456966413fee0b5701867ddcd", "target": 1, "func": "static void mpegts_insert_pcr_only ( AVFormatContext * s , AVStream * st ) \n { \n MpegTSWrite * ts = s -> priv_data ; \n MpegTSWriteStream * ts_st = st -> priv_data ; \n uint8_t * q ; \n uint8_t buf [ TS_PACKET_SIZE ] ; \n q = buf ; \n * q ++ = 0x47 ; \n * q ++ = ts_st -> pid >> 8 ; \n * q ++ = ts_st -> pid ; \n * q ++ = 0x20 | ts_st -> cc ; \n * q ++ = TS_PACKET_SIZE - 5 ; \n * q ++ = 0x10 ; \n q += write_pcr_bits ( q , get_pcr ( ts , s -> pb ) ) ; \n memset ( q , 0xFF , TS_PACKET_SIZE - ( q - buf ) ) ; \n mpegts_prefix_m2ts_header ( s ) ; \n avio_write ( s -> pb , buf , TS_PACKET_SIZE ) ; ", "idx": 13627}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int dxva2_mpeg2_end_frame ( AVCodecContext * avctx ) \n { \n struct MpegEncContext * s = avctx -> priv_data ; \n struct dxva2_picture_context * ctx_pic = \n s -> current_picture_ptr -> hwaccel_picture_private ; \n int ret ; \n if ( ctx_pic -> slice_count <= 0 || ctx_pic -> bitstream_size <= 0 ) \n return -1 ; \n ret = ff_dxva2_common_end_frame ( avctx , & s -> current_picture_ptr -> f , \n & ctx_pic -> pp , sizeof ( ctx_pic -> pp ) , \n & ctx_pic -> qm , sizeof ( ctx_pic -> qm ) , \n commit_bitstream_and_slice_buffer ) ; \n if ( ! ret ) \n ff_mpeg_draw_horiz_band ( s , 0 , avctx -> height ) ; \n return ret ; \n }", "idx": 13629}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "func": "static inline void bink_idct_col ( DCTELEM * dest , const DCTELEM * src ) \n { \n if ( ( src [ 8 ] | src [ 16 ] | src [ 24 ] | src [ 32 ] | src [ 40 ] | src [ 48 ] | src [ 56 ] ) == 0 ) { \n dest [ 0 ] = \n dest [ 8 ] = \n dest [ 16 ] = \n dest [ 24 ] = \n dest [ 32 ] = \n dest [ 40 ] = \n dest [ 48 ] = \n dest [ 56 ] = src [ 0 ] ; \n } else { \n IDCT_COL ( dest , src ) ; \n } \n }", "idx": 13631}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "static int quant_psnr8x8_c ( MpegEncContext * s , uint8_t * src1 , \n uint8_t * src2 , ptrdiff_t stride , int h ) \n { \n LOCAL_ALIGNED_16 ( int16_t , temp ,  [ 64 * 2 ] ) ; \n int16_t * const bak = temp + 64 ; \n int sum = 0 , i ; \n av_assert2 ( h == 8 ) ; \n s -> mb_intra = 0 ; \n s -> pdsp . diff_pixels ( temp , src1 , src2 , stride ) ; \n memcpy ( bak , temp , 64 * sizeof ( int16_t ) ) ; \n s -> block_last_index [ 0 \n ] = \n s -> fast_dct_quantize ( s , temp , 0 \n , s -> qscale , & i ) ; \n s -> dct_unquantize_inter ( s , temp , 0 , s -> qscale ) ; \n ff_simple_idct_8 ( temp ) ; \n for ( i = 0 ; i < 64 ; i ++ ) \n sum += ( temp [ i ] - bak [ i ] ) * ( temp [ i ] - bak [ i ] ) ; \n return sum ; \n }", "idx": 13634}
{"project": "FFmpeg", "commit_id": "f5ba67ee1342b7741200ff637fc3ea3387b68a1b", "target": 0, "func": "static uint64_t calc_rice_params ( RiceContext * rc , int pmin , int pmax , \n int32_t * data , int n , int pred_order ) \n { \n int i ; \n uint64_t bits [ MAX_PARTITION_ORDER + 1 ] ; \n int opt_porder ; \n RiceContext tmp_rc ; \n uint32_t * udata ; \n uint64_t sums [ MAX_PARTITION_ORDER + 1 ] [ MAX_PARTITIONS ] = { { 0 } } ; \n assert ( pmin >= 0 && pmin <= MAX_PARTITION_ORDER ) ; \n assert ( pmax >= 0 && pmax <= MAX_PARTITION_ORDER ) ; \n assert ( pmin <= pmax ) ; \n tmp_rc . coding_mode = rc -> coding_mode ; \n udata = av_malloc ( n * sizeof ( uint32_t ) ) ; \n for ( i = 0 ; i < n ; i ++ ) \n udata [ i ] = ( 2 * data [ i ] ) ^ ( data [ i ] >> 31 ) ; \n calc_sums ( pmin , pmax , udata , n , pred_order , sums ) ; \n opt_porder = pmin ; \n bits [ pmin ] = UINT32_MAX ; \n for ( i = pmin ; i <= pmax ; i ++ ) { \n bits [ i ] = calc_optimal_rice_params ( & tmp_rc , i , sums [ i ] , n , pred_order ) ; \n if ( bits [ i ] <= bits [ opt_porder ] ) { \n opt_porder = i ; \n * rc = tmp_rc ; \n } \n } \n av_freep ( & udata ) ; \n return bits [ opt_porder ] ; \n }", "idx": 13640}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "static int bands_dist ( OpusPsyContext * s , CeltFrame * f , float * total_dist ) \n { \n int i , tdist = 0.0f ; \n OpusRangeCoder dump ; \n ff_opus_rc_enc_init ( & dump ) ; \n ff_celt_enc_bitalloc ( f , & dump ) ; \n for ( i = 0 ; i < CELT_MAX_BANDS ; i ++ ) { \n float bits = 0.0f ; \n float dist = f -> pvq -> band_cost ( f -> pvq , f , & dump , i , & bits , s -> lambda ) ; \n tdist += dist ; \n } \n * total_dist = tdist ; \n return 0 ; \n }", "idx": 13650}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static inline void apply_motion_generic ( RoqContext * ri , int x , int y , int deltax , \n int deltay , int sz ) \n { \n int mx , my , cp ; \n mx = x + deltax ; \n my = y + deltay ; \n if ( ( mx < 0 ) || ( mx > ri -> width - sz ) || \n ( my < 0 ) || ( my > ri -> height - sz ) ) { \n av_log ( ri -> avctx , AV_LOG_ERROR , \" \\n \" , \n mx , my , ri -> width , ri -> height ) ; \n return ; \n } \n if ( ri -> last_frame -> data [ 0 ] == NULL ) { \n av_log ( ri -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n for ( cp = 0 ; cp < 3 ; cp ++ ) { \n int outstride = ri -> current_frame -> linesize [ cp ] ; \n int instride = ri -> last_frame -> linesize [ cp ] ; \n block_copy ( ri -> current_frame -> data [ cp ] + y * outstride + x , \n ri -> last_frame -> data [ cp ] + my * instride + mx , \n outstride , instride , sz ) ; \n } \n }", "idx": 13651}
{"project": "FFmpeg", "commit_id": "ea71a48c7e8a76ee447fa518cca087df9288288d", "target": 1, "func": "static int update_error_limit ( WavpackFrameContext * ctx ) \n { \n int i , br [ 2 ] , sl [ 2 ] ; \n for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { \n if ( ctx -> ch [ i ] . bitrate_acc > UINT_MAX - ctx -> ch [ i ] . bitrate_delta ) \n return AVERROR_INVALIDDATA ; \n ctx -> ch [ i ] . bitrate_acc += ctx -> ch [ i ] . bitrate_delta ; \n br [ i ] = ctx -> ch [ i ] . bitrate_acc >> 16 ; \n sl [ i ] = LEVEL_DECAY ( ctx -> ch [ i ] . slow_level ) ; \n } \n if ( ctx -> stereo_in && ctx -> hybrid_bitrate ) { \n int balance = ( sl [ 1 ] - sl [ 0 ] + br [ 1 ] + 1 ) >> 1 ; \n if ( balance > br [ 0 ] ) { \n br [ 1 ] = br [ 0 ] << 1 ; \n br [ 0 ] = 0 ; \n } else if ( - balance > br [ 0 ] ) { \n br [ 0 ] <<= 1 ; \n br [ 1 ] = 0 ; \n } else { \n br [ 1 ] = br [ 0 ] + balance ; \n br [ 0 ] = br [ 0 ] - balance ; \n } \n } \n for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { \n if ( ctx -> hybrid_bitrate ) { \n if ( sl [ i ] - br [ i ] > -0x100 ) \n ctx -> ch [ i ] . error_limit = wp_exp2 ( sl [ i ] - br [ i ] + 0x100 ) ; \n else \n ctx -> ch [ i ] . error_limit = 0 ; \n } else { \n ctx -> ch [ i ] . error_limit = wp_exp2 ( br [ i ] ) ; \n } \n } \n return 0 ; \n }", "idx": 13653}
{"project": "FFmpeg", "commit_id": "30f680ee0a2707af9a649a0aa3fd951d18a25c05", "target": 1, "func": "static int vc1_decode_sprites ( VC1Context * v , GetBitContext * gb ) \n { \n int ret ; \n MpegEncContext * s = & v -> s ; \n AVCodecContext * avctx = s -> avctx ; \n SpriteData sd ; \n memset ( & sd , 0 , sizeof ( sd ) ) ; \n ret = vc1_parse_sprites ( v , gb , & sd ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! s -> current_picture . f -> data [ 0 ] ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( v -> two_sprites && ( ! s -> last_picture_ptr || ! s -> last_picture . f -> data [ 0 ] ) ) { \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n v -> two_sprites = 0 ; \n } \n av_frame_unref ( v -> sprite_output_frame ) ; \n if ( ( ret = ff_get_buffer ( avctx , v -> sprite_output_frame , 0 ) ) < 0 ) \n return ret ; \n vc1_draw_sprites ( v , & sd ) ; \n return 0 ; \n }", "idx": 13668}
{"project": "FFmpeg", "commit_id": "e3ba817b95bbdc7c8aaf83b4a6804d1b49eb4de4", "target": 1, "func": "static void mxf_write_multi_descriptor ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n const uint8_t * ul ; \n int i ; \n mxf_write_metadata_key ( pb , 0x014400 ) ; \n PRINT_KEY ( s , \" \" , pb -> buf_ptr - 16 ) ; \n klv_encode_ber_length ( pb , 64 + 16 * s -> nb_streams ) ; \n mxf_write_local_tag ( pb , 16 , 0x3C0A ) ; \n mxf_write_uuid ( pb , MultipleDescriptor , 0 ) ; \n PRINT_KEY ( s , \" \" , pb -> buf_ptr - 16 ) ; \n mxf_write_local_tag ( pb , 8 , 0x3001 ) ; \n avio_wb32 ( pb , mxf -> time_base . den ) ; \n avio_wb32 ( pb , mxf -> time_base . num ) ; \n mxf_write_local_tag ( pb , 16 , 0x3004 ) ; \n if ( mxf -> essence_container_count > 1 ) \n ul = multiple_desc_ul ; \n else { \n MXFStreamContext * sc = s -> streams [ 0 ] -> priv_data ; \n ul = mxf_essence_container_uls [ sc -> index ] . container_ul ; \n } \n avio_write ( pb , ul , 16 ) ; \n mxf_write_local_tag ( pb , s -> nb_streams * 16 + 8 , 0x3F01 ) ; \n mxf_write_refs_count ( pb , s -> nb_streams ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n mxf_write_uuid ( pb , SubDescriptor , i ) ; \n }", "idx": 13674}
{"project": "FFmpeg", "commit_id": "e01b19deceaafa2b7a9d59717484d8831b00cd71", "target": 0, "func": "static int analyze ( const uint8_t * buf , int size , int packet_size , \n int probe ) \n { \n int stat [ TS_MAX_PACKET_SIZE ] ; \n int stat_all = 0 ; \n int i ; \n int best_score = 0 ; \n memset ( stat , 0 , packet_size * sizeof ( * stat ) ) ; \n for ( i = 0 ; i < size - 3 ; i ++ ) { \n if ( buf [ i ] == 0x47 && \n ( ! probe || ( buf [ i + 3 ] & 0x30 ) ) ) { \n int x = i % packet_size ; \n stat [ x ] ++ ; \n stat_all ++ ; \n if ( stat [ x ] > best_score ) { \n best_score = stat [ x ] ; \n } \n } \n } \n return best_score - FFMAX ( stat_all - 10 * best_score , 0 ) / 10 ; \n }", "idx": 13677}
{"project": "FFmpeg", "commit_id": "03a9e6ff303ad82e75b734edbe4917ca5fd60159", "target": 1, "func": "static void get_tree_codes ( uint32_t * bits , int16_t * lens , uint8_t * xlat , \n Node * nodes , int node , \n uint32_t pfx , int pl , int * pos ) \n { \n int s ; \n s = nodes [ node ] . sym ; \n if ( s != -1 ) { \n bits [ * pos ] = ( ~ pfx ) & ( ( 1U << FFMAX ( pl , 1 ) ) - 1 ) ; \n lens [ * pos ] = FFMAX ( pl , 1 ) ; \n xlat [ * pos ] = s + ( pl == 0 ) ; \n ( * pos ) ++ ; \n } else { \n pfx <<= 1 ; \n pl ++ ; \n get_tree_codes ( bits , lens , xlat , nodes , nodes [ node ] . l , pfx , pl , \n pos ) ; \n pfx |= 1 ; \n get_tree_codes ( bits , lens , xlat , nodes , nodes [ node ] . r , pfx , pl , \n pos ) ; \n } \n }", "idx": 13679}
{"project": "FFmpeg", "commit_id": "fb45de779c8db142b44bf7b00c535ea2eee4f148", "target": 0, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , unsigned size , \n const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint64_t pos ; \n uint32_t taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val || \n size < OMA_ENC_HEADER_SIZE + oc -> k_size + 4 ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( size < pos + 44 ) \n return -1 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n pos += 44 ; \n if ( size - pos < taglen ) \n return -1 ; \n pos += taglen ; \n if ( pos + ( ( ( uint64_t ) datalen ) << 4 ) > size ) \n return -1 ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , size , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 13680}
{"project": "FFmpeg", "commit_id": "3b9dd906d18f4cd801ceedd20d800a7e53074be9", "target": 0, "func": "static void fill_block ( uint16_t * pdest , uint16_t color , int block_size , int pitch ) \n { \n int x , y ; \n pitch -= block_size ; \n for ( y = 0 ; y != block_size ; y ++ , pdest += pitch ) \n for ( x = 0 ; x != block_size ; x ++ ) \n * pdest ++ = color ; \n }", "idx": 13681}
{"project": "FFmpeg", "commit_id": "74bd0cf49c9c0bee8d4f3d3a98a7343c2ff5b94c", "target": 0, "func": "static void ini_print_section_header ( WriterContext * wctx ) \n { \n INIContext * ini = wctx -> priv ; \n AVBPrint buf ; \n int i ; \n const struct section * section = wctx -> section [ wctx -> level ] ; \n const struct section * parent_section = wctx -> level ? \n wctx -> section [ wctx -> level - 1 ] : NULL ; \n av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; \n if ( wctx -> level == 0 ) { \n printf ( \" \\n \\n \" ) ; \n return ; \n } \n if ( wctx -> nb_item [ wctx -> level - 1 ] ) \n printf ( \" \\n \" ) ; \n for ( i = 1 ; i <= wctx -> level ; i ++ ) { \n if ( ini -> hierarchical || \n ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) \n av_bprintf ( & buf , \" \" , i > 1 ? \" \" : \" \" , wctx -> section [ i ] -> name ) ; \n } \n if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { \n int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? \n wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; \n av_bprintf ( & buf , \" \" , n ) ; \n } \n if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) \n printf ( \" \\n \" , buf . str ) ; \n av_bprint_finalize ( & buf , NULL ) ; \n }", "idx": 13682}
{"project": "FFmpeg", "commit_id": "42868ca569f33b91b0e61ecc3065e7199e9ca58a", "target": 1, "func": "static void init_band_stepsize ( AVCodecContext * avctx , \n Jpeg2000Band * band , \n Jpeg2000CodingStyle * codsty , \n Jpeg2000QuantStyle * qntsty , \n int bandno , int gbandno , int reslevelno , \n int cbps ) \n { \n switch ( qntsty -> quantsty ) { \n uint8_t gain ; \n case JPEG2000_QSTY_NONE : \n band -> f_stepsize = 1 ; \n break ; \n case JPEG2000_QSTY_SI : \n case JPEG2000_QSTY_SE : \n gain = cbps ; \n band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; \n band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; \n break ; \n default : \n band -> f_stepsize = 0 ; \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n break ; \n } \n if ( codsty -> transform != FF_DWT53 ) { \n int lband = 0 ; \n switch ( bandno + ( reslevelno > 0 ) ) { \n case 1 : \n case 2 : \n band -> f_stepsize *= F_LFTG_X * 2 ; \n lband = 1 ; \n break ; \n case 3 : \n band -> f_stepsize *= F_LFTG_X * F_LFTG_X * 4 ; \n break ; \n } \n if ( codsty -> transform == FF_DWT97 ) { \n band -> f_stepsize *= pow ( F_LFTG_K , 2 * ( codsty -> nreslevels2decode - reslevelno ) + lband - 2 ) ; \n } \n } \n band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; \n if ( ! av_codec_is_encoder ( avctx -> codec ) ) \n band -> f_stepsize *= 0.5 ; \n }", "idx": 13689}
{"project": "FFmpeg", "commit_id": "085ca7dcdbf9ab6c23e3a5397b1f6d4aa23f763d", "target": 1, "func": "static int teletext_init_decoder ( AVCodecContext * avctx ) \n { \n TeletextContext * ctx = avctx -> priv_data ; \n unsigned int maj , min , rev ; \n vbi_version ( & maj , & min , & rev ) ; \n if ( ! ( maj > 0 || min > 2 || min == 2 && rev >= 26 ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_EXTERNAL ; \n } \n if ( ctx -> format_id == 0 ) { \n avctx -> width = 41 * BITMAP_CHAR_WIDTH ; \n avctx -> height = 25 * BITMAP_CHAR_HEIGHT ; \n } \n ctx -> dx = NULL ; \n ctx -> vbi = NULL ; \n ctx -> pts = AV_NOPTS_VALUE ; \n #ifdef DEBUG \n { \n char * t ; \n ctx -> ex = vbi_export_new ( \" \" , & t ) ; \n } \n #endif \n av_log ( avctx , AV_LOG_VERBOSE , \" \\n \" , ctx -> pgno ) ; \n return ( ctx -> format_id == 1 ) ? ff_ass_subtitle_header_default ( avctx ) : 0 ; \n }", "idx": 13690}
{"project": "FFmpeg", "commit_id": "ea3abcd58f83673bf2fe28170339f19ddf683442", "target": 1, "func": "void ff_get_guid ( AVIOContext * s , ff_asf_guid * g ) \n { \n assert ( sizeof ( * g ) == 16 ) ; \n avio_read ( s , * g , sizeof ( * g ) ) ; \n }", "idx": 13694}
{"project": "FFmpeg", "commit_id": "09b23786b3986502ee88d4907356979127169bdd", "target": 1, "func": "static void pcx_palette ( const uint8_t * * src , uint32_t * dst , \n unsigned int pallen ) \n { \n unsigned int i ; \n for ( i = 0 ; i < pallen ; i ++ ) \n * dst ++ = bytestream_get_be24 ( src ) ; \n if ( pallen < 256 ) \n memset ( dst , 0 , ( 256 - pallen ) * sizeof ( * dst ) ) ; \n }", "idx": 13698}
{"project": "FFmpeg", "commit_id": "31a0ca9e75e4c91437c8681b9655a67f09b693dd", "target": 1, "func": "static void vda_decoder_callback ( void * vda_hw_ctx , \n CFDictionaryRef user_info , \n OSStatus status , \n uint32_t infoFlags , \n CVImageBufferRef image_buffer ) \n { \n struct vda_context * vda_ctx = vda_hw_ctx ; \n if ( ! image_buffer ) \n return ; \n if ( vda_ctx -> cv_pix_fmt_type != CVPixelBufferGetPixelFormatType ( image_buffer ) ) \n return ; \n vda_ctx -> cv_buffer = CVPixelBufferRetain ( image_buffer ) ; \n }", "idx": 13715}
{"project": "FFmpeg", "commit_id": "24ae353dfbe61019a86093a9c5cd15476aabef49", "target": 1, "func": "static int wc3_read_close ( AVFormatContext * s ) \n { \n Wc3DemuxContext * wc3 = s -> priv_data ; \n av_free ( wc3 -> palettes ) ; \n return 0 ; \n }", "idx": 13716}
{"project": "FFmpeg", "commit_id": "eed36075645ecc3d3ef202c94badb66818114c2c", "target": 1, "func": "int main ( void ) { \n int i , k ; \n AVTreeNode * root = NULL , * node = NULL ; \n for ( i = 0 ; i < 10000 ; i ++ ) { \n int j = ( random ( ) % 86294 ) ; \n if ( check ( root ) > 999 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , i ) ; \n print ( root , 0 ) ; \n return -1 ; \n } \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , j ) ; \n if ( ! node ) \n node = av_mallocz ( av_tree_node_size ) ; \n av_tree_insert ( & root , ( void * ) ( j + 1 ) , cmp , & node ) ; \n j = ( random ( ) % 86294 ) ; \n k = av_tree_find ( root , ( void * ) ( j + 1 ) , cmp , NULL ) ; \n if ( k ) { \n AVTreeNode * node2 = NULL ; \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , j ) ; \n av_tree_insert ( & root , ( void * ) ( j + 1 ) , cmp , & node2 ) ; \n k = av_tree_find ( root , ( void * ) ( j + 1 ) , cmp , NULL ) ; \n if ( k ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , i ) ; \n } \n } \n return 0 ; \n }", "idx": 13718}
{"project": "FFmpeg", "commit_id": "6359872877269fa0c1874587676e952d30f9b79f", "target": 1, "func": "ogm_dshow_header ( AVFormatContext * s , int idx )  \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n AVStream * st = s -> streams [ idx ] ; \n uint8_t * p = os -> buf + os -> pstart ; \n uint32_t t ; \n if ( ! ( * p & 1 ) ) \n return 0 ; \n if ( * p != 1 ) \n return 1 ; \n t = AV_RL32 ( p + 96 ) ; \n if ( t == 0x05589f80 ) { \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , AV_RL32 ( p + 68 ) ) ; \n avpriv_set_pts_info ( st , 64 , AV_RL64 ( p + 164 ) , 10000000 ) ; \n st -> codec -> width = AV_RL32 ( p + 176 ) ; \n st -> codec -> height = AV_RL32 ( p + 180 ) ; \n } else if ( t == 0x05589f81 ) { \n st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codec -> codec_id = ff_codec_get_id ( ff_codec_wav_tags , AV_RL16 ( p + 124 ) ) ; \n st -> codec -> channels = AV_RL16 ( p + 126 ) ; \n st -> codec -> sample_rate = AV_RL32 ( p + 128 ) ; \n st -> codec -> bit_rate = AV_RL32 ( p + 132 ) * 8 ; \n } \n return 1 ; \n }", "idx": 13723}
{"project": "FFmpeg", "commit_id": "23fe14bb20888038b91e62b16d50fe0b75043a10", "target": 1, "func": "static int vmd_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n VmdDemuxContext * vmd = ( VmdDemuxContext * ) s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n int ret = 0 ; \n vmd_frame_t * frame ; \n if ( vmd -> current_frame >= vmd -> frame_count ) \n return - EIO ; \n frame = & vmd -> frame_table [ vmd -> current_frame ] ; \n url_fseek ( pb , frame -> frame_offset , SEEK_SET ) ; \n if ( av_new_packet ( pkt , frame -> frame_size + BYTES_PER_FRAME_RECORD ) ) \n return AVERROR_NOMEM ; \n memcpy ( pkt -> data , frame -> frame_record , BYTES_PER_FRAME_RECORD ) ; \n ret = get_buffer ( pb , pkt -> data + BYTES_PER_FRAME_RECORD , \n frame -> frame_size ) ; \n if ( ret != frame -> frame_size ) \n ret = - EIO ; \n pkt -> stream_index = frame -> stream_index ; \n pkt -> pts = frame -> pts ; \n vmd -> current_frame ++ ; \n return ret ; \n }", "idx": 13731}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_get_short_seek ( URLContext * h ) \n { \n if ( ! h -> prot -> url_get_short_seek ) \n return AVERROR ( ENOSYS ) ; \n return h -> prot -> url_get_short_seek ( h ) ; \n }", "idx": 13744}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "void av_thread_message_queue_set_err_send ( AVThreadMessageQueue * mq , \n int err ) \n { \n #if HAVE_THREADS  \n  \n  pthread_mutex_lock ( & mq -> lock ) ; \n mq -> err_send = err ; \n pthread_cond_broadcast ( & mq -> cond ) ; \n pthread_mutex_unlock ( & mq -> lock ) ; \n #endif \n }", "idx": 13751}
{"project": "FFmpeg", "commit_id": "bbbc8c618884a838c00faaaa91898017dd431117", "target": 0, "func": "static AVIndexEntry * mov_find_next_sample ( AVFormatContext * s , AVStream * * st ) \n { \n AVIndexEntry * sample = NULL ; \n int64_t best_dts = INT64_MAX ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * avst = s -> streams [ i ] ; \n MOVStreamContext * msc = avst -> priv_data ; \n if ( msc -> pb && msc -> current_sample < avst -> nb_index_entries ) { \n AVIndexEntry * current_sample = & avst -> index_entries [ msc -> current_sample ] ; \n int64_t dts ; \n if ( msc -> ctts_data ) \n dts = av_rescale ( current_sample -> timestamp - msc -> dts_shift - msc -> ctts_data [ msc -> ctts_index ] . duration , \n AV_TIME_BASE , msc -> time_scale ) ; \n else \n dts = av_rescale ( current_sample -> timestamp , AV_TIME_BASE , msc -> time_scale ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , i , msc -> current_sample , dts ) ; \n if ( ! sample || ( ! s -> pb -> seekable && current_sample -> pos < sample -> pos ) || \n ( s -> pb -> seekable && \n ( ( msc -> pb != s -> pb && dts < best_dts ) || ( msc -> pb == s -> pb && \n ( ( FFABS ( best_dts - dts ) <= AV_TIME_BASE && current_sample -> pos < sample -> pos ) || \n ( FFABS ( best_dts - dts ) > AV_TIME_BASE && dts < best_dts ) ) ) ) ) ) { \n sample = current_sample ; \n best_dts = dts ; \n * st = avst ; \n } \n } \n } \n return sample ; \n }", "idx": 13755}
{"project": "FFmpeg", "commit_id": "511e6f17f493719058229630c7db4d8d7c05aeac", "target": 1, "func": "static inline int silk_is_lpc_stable ( const int16_t lpc [ 16 ] , int order ) \n { \n int k , j , DC_resp = 0 ; \n int32_t lpc32 [ 2 ] [ 16 ] ; \n int totalinvgain = 1 << 30 ; \n int32_t * row = lpc32 [ 0 ] , * prevrow ; \n for ( k = 0 ; k < order ; k ++ ) { \n DC_resp += lpc [ k ] ; \n row [ k ] = lpc [ k ] * 4096 ; \n } \n if ( DC_resp >= 4096 ) \n return 0 ; \n for ( k = order - 1 ; 1 ; k -- ) { \n int rc ; \n int gaindiv ; \n int gain ; \n int fbits ; \n int error ; \n if ( FFABS ( row [ k ] ) > 16773022 ) \n return 0 ; \n rc = - ( row [ k ] * 128 ) ; \n gaindiv = ( 1 << 30 ) - MULH ( rc , rc ) ; \n totalinvgain = MULH ( totalinvgain , gaindiv ) << 2 ; \n if ( k == 0 ) \n return ( totalinvgain >= 107374 ) ; \n fbits = opus_ilog ( gaindiv ) ; \n gain = ( ( 1 << 29 ) - 1 ) / ( gaindiv >> ( fbits + 1 - 16 ) ) ; \n error = ( 1 << 29 ) - MULL ( gaindiv << ( 15 + 16 - fbits ) , gain , 16 ) ; \n gain = ( ( gain << 16 ) + ( error * gain >> 13 ) ) ; \n prevrow = row ; \n row = lpc32 [ k & 1 ] ; \n for ( j = 0 ; j < k ; j ++ ) { \n int x = prevrow [ j ] - ROUND_MULL ( prevrow [ k - j - 1 ] , rc , 31 ) ; \n row [ j ] = ROUND_MULL ( x , gain , fbits ) ; \n } \n } \n }", "idx": 13775}
{"project": "FFmpeg", "commit_id": "53ea595eec984e3109310e8bb7ff4b5786d91057", "target": 1, "func": "static inline int mov_get_stsc_samples ( MOVStreamContext * sc , int index ) \n { \n int chunk_count ; \n if ( mov_stsc_index_valid ( index , sc -> stsc_count ) ) \n chunk_count = sc -> stsc_data [ index + 1 ] . first - sc -> stsc_data [ index ] . first ; \n else \n chunk_count = sc -> chunk_count - ( sc -> stsc_data [ index ] . first - 1 ) ; \n return sc -> stsc_data [ index ] . count * chunk_count ; \n }", "idx": 13776}
{"project": "FFmpeg", "commit_id": "0b357a8095e72b092cc5c2aacc2f806db75ecae3", "target": 0, "func": "static int write_number ( void * obj , const AVOption * o , void * dst , double num , int den , int64_t intnum ) \n { \n if ( o -> max * den < num * intnum || o -> min * den > num * intnum ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , \n num * intnum / den , o -> name ) ; \n return AVERROR ( ERANGE ) ; \n } \n switch ( o -> type ) { \n case AV_OPT_TYPE_FLAGS : \n case AV_OPT_TYPE_INT : * ( int * ) dst = llrint ( num / den ) * intnum ; break ; \n case AV_OPT_TYPE_INT64 : * ( int64_t * ) dst = llrint ( num / den ) * intnum ; break ; \n case AV_OPT_TYPE_FLOAT : * ( float * ) dst = num * intnum / den ; break ; \n case AV_OPT_TYPE_DOUBLE : * ( double * ) dst = num * intnum / den ; break ; \n case AV_OPT_TYPE_RATIONAL : \n if ( ( int ) num == num ) * ( AVRational * ) dst = ( AVRational ) { num * intnum , den } ; \n else * ( AVRational * ) dst = av_d2q ( num * intnum / den , 1 << 24 ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 13778}
{"project": "FFmpeg", "commit_id": "5ed5e90f2ae299cbec66996860d794771a85fee8", "target": 1, "func": "static void count_colors ( AVCodecContext * avctx , unsigned hits [ 33 ] , \n const AVSubtitleRect * r ) \n { \n DVDSubtitleContext * dvdc = avctx -> priv_data ; \n unsigned count [ 256 ] = { 0 } ; \n uint32_t * palette = ( uint32_t * ) r -> pict . data [ 1 ] ; \n uint32_t color ; \n int x , y , i , j , match , d , best_d , av_uninit ( best_j ) ; \n uint8_t * p = r -> pict . data [ 0 ] ; \n for ( y = 0 ; y < r -> h ; y ++ ) { \n for ( x = 0 ; x < r -> w ; x ++ ) \n count [ * ( p ++ ) ] ++ ; \n p += r -> pict . linesize [ 0 ] - r -> w ; \n } \n for ( i = 0 ; i < 256 ; i ++ ) { \n if ( ! count [ i ] ) \n continue ; \n color = palette [ i ] ; \n match = color < 0x33000000 ? 0 : color < 0xCC000000 ? 1 : 17 ; \n if ( match ) { \n best_d = INT_MAX ; \n for ( j = 0 ; j < 16 ; j ++ ) { \n d = color_distance ( color & 0xFFFFFF , dvdc -> global_palette [ j ] ) ; \n if ( d < best_d ) { \n best_d = d ; \n best_j = j ; \n } \n } \n match += best_j ; \n } \n hits [ match ] += count [ i ] ; \n } \n }", "idx": 13780}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb24ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int r = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int b = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; \n } \n }", "idx": 13785}
{"project": "FFmpeg", "commit_id": "49e5dcbce5f9e08ec375fd54c413148beb81f1d7", "target": 1, "func": "int h261_decode_picture_header ( H261Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int format , i ; \n static int h261_framecounter = 0 ; \n uint32_t startcode ; \n align_get_bits ( & s -> gb ) ; \n startcode = ( h -> last_bits << ( 12 - ( 8 - h -> bits_left ) ) ) | get_bits ( & s -> gb , 20 - 8 - ( 8 - h -> bits_left ) ) ; \n for ( i = s -> gb . size_in_bits - get_bits_count ( & s -> gb ) ; i > 24 ; i -= 1 ) { \n startcode = ( ( startcode << 1 ) | get_bits ( & s -> gb , 1 ) ) & 0x000FFFFF ; \n if ( startcode == 0x10 ) \n break ; \n } \n if ( startcode != 0x10 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> picture_number = get_bits ( & s -> gb , 5 ) ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits1 ( & s -> gb ) ; \n format = get_bits1 ( & s -> gb ) ; \n if ( format == 0 ) { \n s -> width = 176 ; \n s -> height = 144 ; \n s -> mb_width = 11 ; \n s -> mb_height = 9 ; \n } else { \n s -> width = 352 ; \n s -> height = 288 ; \n s -> mb_width = 22 ; \n s -> mb_height = 18 ; \n } \n s -> mb_num = s -> mb_width * s -> mb_height ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits1 ( & s -> gb ) ; \n while ( get_bits1 ( & s -> gb ) != 0 ) { \n skip_bits ( & s -> gb , 8 ) ; \n } \n if ( h261_framecounter > 1 ) \n s -> pict_type = P_TYPE ; \n else \n s -> pict_type = I_TYPE ; \n h261_framecounter ++ ; \n h -> gob_number = 0 ; \n return 0 ; \n }", "idx": 13798}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static void do_rematrixing ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n uint8_t bnd1 = 13 , bnd2 = 25 , bnd3 = 37 , bnd4 = 61 ; \n uint8_t bndend ; \n bndend = FFMIN ( ab -> endmant [ 0 ] , ab -> endmant [ 1 ] ) ; \n if ( ab -> rematflg & 1 ) \n _do_rematrixing ( ctx , bnd1 , bnd2 ) ; \n if ( ab -> rematflg & 2 ) \n _do_rematrixing ( ctx , bnd2 , bnd3 ) ; \n if ( ab -> rematflg & 4 ) { \n if ( ab -> cplbegf > 0 && ab -> cplbegf <= 2 && ( ab -> flags & AC3_AB_CPLINU ) ) \n _do_rematrixing ( ctx , bnd3 , bndend ) ; \n else { \n _do_rematrixing ( ctx , bnd3 , bnd4 ) ; \n if ( ab -> rematflg & 8 ) \n _do_rematrixing ( ctx , bnd4 , bndend ) ; \n } \n } \n }", "idx": 13810}
{"project": "FFmpeg", "commit_id": "c3299726874829e8eb7a937c247956ab3c2ccae6", "target": 0, "func": "static av_cold int decoder_init ( AVCodecContext * avctx ) \n { \n G729Context * ctx = avctx -> priv_data ; \n int i , k ; \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , avctx -> channels ) ; \n return AVERROR ( EINVAL ) ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n avctx -> frame_size = SUBFRAME_SIZE << 1 ; \n ctx -> gain_coeff = 16384 ; \n for ( k = 0 ; k < MA_NP + 1 ; k ++ ) { \n ctx -> past_quantizer_outputs [ k ] = ctx -> past_quantizer_output_buf [ k ] ; \n for ( i = 1 ; i < 11 ; i ++ ) \n ctx -> past_quantizer_outputs [ k ] [ i - 1 ] = ( 18717 * i ) >> 3 ; \n } \n ctx -> lsp [ 0 ] = ctx -> lsp_buf [ 0 ] ; \n ctx -> lsp [ 1 ] = ctx -> lsp_buf [ 1 ] ; \n memcpy ( ctx -> lsp [ 0 ] , lsp_init , 10 * sizeof ( int16_t ) ) ; \n ctx -> exc = & ctx -> exc_base [ PITCH_DELAY_MAX + INTERPOL_LEN ] ; \n ctx -> rand_value = 21845 ; \n for ( i = 0 ; i < 4 ; i ++ ) \n ctx -> quant_energy [ i ] = -14336 ; \n avctx -> dsp_mask = ~ AV_CPU_FLAG_FORCE ; \n dsputil_init ( & ctx -> dsp , avctx ) ; \n return 0 ; \n }", "idx": 13821}
{"project": "FFmpeg", "commit_id": "143685a42bbc8861b626457ce4cb8b1ce4b0c436", "target": 0, "func": "static av_cold void ffat_encode_flush ( AVCodecContext * avctx ) \n { \n ATDecodeContext * at = avctx -> priv_data ; \n AudioConverterReset ( at -> converter ) ; \n av_frame_unref ( & at -> new_in_frame ) ; \n av_frame_unref ( & at -> in_frame ) ; \n }", "idx": 13832}
{"project": "FFmpeg", "commit_id": "2c8cff2be4a044c66e4904efa156dafd0d332d25", "target": 1, "func": "static int asf_write_header ( AVFormatContext * s ) \n { \n ASFContext * asf = s -> priv_data ; \n s -> packet_size = PACKET_SIZE ; \n s -> max_interleave_delta = 0 ; \n asf -> nb_packets = 0 ; \n asf -> index_ptr = av_malloc ( sizeof ( ASFIndex ) * ASF_INDEX_BLOCK ) ; \n asf -> nb_index_memory_alloc = ASF_INDEX_BLOCK ; \n asf -> maximum_packet = 0 ; \n if ( asf_write_header1 ( s , 0 , DATA_HEADER_SIZE ) < 0 ) { \n return -1 ; \n } \n avio_flush ( s -> pb ) ; \n asf -> packet_nb_payloads = 0 ; \n asf -> packet_timestamp_start = -1 ; \n asf -> packet_timestamp_end = -1 ; \n ffio_init_context ( & asf -> pb , asf -> packet_buf , s -> packet_size , 1 , \n NULL , NULL , NULL , NULL ) ; \n if ( s -> avoid_negative_ts < 0 ) \n s -> avoid_negative_ts = 1 ; \n return 0 ; \n }", "idx": 13840}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static uint32_t parse_peak ( const uint8_t * peak ) \n { \n int64_t val = 0 ; \n int64_t scale = 1 ; \n if ( ! peak ) \n return 0 ; \n peak += strspn ( peak , \" \\t \" ) ; \n if ( peak [ 0 ] == ' ' && peak [ 1 ] == ' ' ) \n return UINT32_MAX ; \n else if ( ! ( peak [ 0 ] == ' ' && peak [ 1 ] == ' ' ) ) \n return 0 ; \n peak += 2 ; \n while ( av_isdigit ( * peak ) ) { \n int digit = * peak - ' ' ; \n if ( scale > INT64_MAX / 10 ) \n break ; \n val = 10 * val + digit ; \n scale *= 10 ; \n peak ++ ; \n } \n return av_rescale ( val , UINT32_MAX , scale ) ; \n }", "idx": 13846}
{"project": "FFmpeg", "commit_id": "adc39b28a5264591b9f8e5838a752c3d547e8110", "target": 1, "func": "void av_image_copy ( uint8_t * dst_data [ 4 ] , int dst_linesizes [ 4 ] , \n const uint8_t * src_data [ 4 ] , const int src_linesizes [ 4 ] , \n enum AVPixelFormat pix_fmt , int width , int height ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n if ( ! desc || desc -> flags & PIX_FMT_HWACCEL ) \n if ( desc -> flags & PIX_FMT_PAL || \n desc -> flags & PIX_FMT_PSEUDOPAL ) { \n av_image_copy_plane ( dst_data [ 0 ] , dst_linesizes [ 0 ] , \n src_data [ 0 ] , src_linesizes [ 0 ] , \n width , height ) ; \n memcpy ( dst_data [ 1 ] , src_data [ 1 ] , 4 * 256 ) ; \n } else { \n int i , planes_nb = 0 ; \n for ( i = 0 ; i < desc -> nb_components ; i ++ ) \n planes_nb = FFMAX ( planes_nb , desc -> comp [ i ] . plane + 1 ) ; \n for ( i = 0 ; i < planes_nb ; i ++ ) { \n int h = height ; \n int bwidth = av_image_get_linesize ( pix_fmt , width , i ) ; \n if ( i == 1 || i == 2 ) { \n h = - ( ( - height ) >> desc -> log2_chroma_h ) ; \n av_image_copy_plane ( dst_data [ i ] , dst_linesizes [ i ] , \n src_data [ i ] , src_linesizes [ i ] , \n bwidth , h ) ;", "idx": 13847}
{"project": "FFmpeg", "commit_id": "5aedee4facb2295cfdeaf322bc67fd15323862d9", "target": 1, "func": "static void gxf_read_index ( AVFormatContext * s , int pkt_len ) { \n AVIOContext * pb = s -> pb ; \n AVStream * st = s -> streams [ 0 ] ; \n uint32_t fields_per_map = avio_rl32 ( pb ) ; \n uint32_t map_cnt = avio_rl32 ( pb ) ; \n int i ; \n pkt_len -= 8 ; \n if ( s -> flags & AVFMT_FLAG_IGNIDX ) { \n avio_skip ( pb , pkt_len ) ; \n return ; \n } \n if ( map_cnt > 1000 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , map_cnt , map_cnt ) ; \n map_cnt = 1000 ; \n } \n if ( pkt_len < 4 * map_cnt ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n avio_skip ( pb , pkt_len ) ; \n return ; \n } \n pkt_len -= 4 * map_cnt ; \n av_add_index_entry ( st , 0 , 0 , 0 , 0 , 0 ) ; \n for ( i = 0 ; i < map_cnt ; i ++ ) \n av_add_index_entry ( st , ( uint64_t ) avio_rl32 ( pb ) * 1024 , \n i * ( uint64_t ) fields_per_map + 1 , 0 , 0 , 0 ) ; \n avio_skip ( pb , pkt_len ) ; \n }", "idx": 13849}
{"project": "FFmpeg", "commit_id": "b9dbaa409f51545a840929665fa0303b46e7e8a5", "target": 1, "func": "static void draw_char ( AVCodecContext * avctx , int c , int a ) \n { \n XbinContext * s = avctx -> priv_data ; \n if ( s -> y > avctx -> height - s -> font_height ) \n return ; \n ff_draw_pc_font ( s -> frame . data [ 0 ] + s -> y * s -> frame . linesize [ 0 ] + s -> x , \n s -> frame . linesize [ 0 ] , s -> font , s -> font_height , c , \n a & 0x0F , a >> 4 ) ; \n s -> x += FONT_WIDTH ; \n if ( s -> x >= avctx -> width ) { \n s -> x = 0 ; \n s -> y += s -> font_height ; \n } \n }", "idx": 13850}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_streams ( WriterContext * w , AVFormatContext * fmt_ctx ) \n { \n int i ; \n writer_print_section_header ( w , SECTION_ID_STREAMS ) ; \n for ( i = 0 ; i < fmt_ctx -> nb_streams ; i ++ ) \n if ( selected_streams [ i ] ) \n show_stream ( w , fmt_ctx , i , 0 ) ; \n writer_print_section_footer ( w ) ; \n }", "idx": 13865}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_hor_dc_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 = 0 , src1 = 0 ; \n uint64_t out0 , out1 ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src0 += src [ lp_cnt * stride - 1 ] ; \n src1 += src [ ( 4 + lp_cnt ) * stride - 1 ] ; \n } \n src0 = ( src0 + 2 ) >> 2 ; \n src1 = ( src1 + 2 ) >> 2 ; \n out0 = src0 * 0x0101010101010101 ; \n out1 = src1 * 0x0101010101010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SD ( out0 , src ) ; \n SD ( out1 , ( src + 4 * stride ) ) ; \n src += stride ; \n } \n }", "idx": 13868}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_v_weak_loop_filter ( uint8_t * src , const int stride , \n const int filter_p1 , const int filter_q1 , \n const int alpha , const int beta , \n const int lim_p0q0 , const int lim_q1 , \n const int lim_p1 ) \n { \n rv40_weak_loop_filter ( src , 1 , stride , filter_p1 , filter_q1 , \n alpha , beta , lim_p0q0 , lim_q1 , lim_p1 ) ; \n }", "idx": 13871}
{"project": "FFmpeg", "commit_id": "7a773d4d59c9a2e14cb84201f8d17cbf3edaede8", "target": 0, "func": "AVInputFormat * av_probe_input_format2 ( AVProbeData * pd , int is_opened , int * score_max ) \n { \n AVProbeData lpd = * pd ; \n AVInputFormat * fmt1 = NULL , * fmt ; \n int score , id3 = 0 ; \n if ( lpd . buf_size > 10 && ff_id3v2_match ( lpd . buf , ID3v2_DEFAULT_MAGIC ) ) { \n int id3len = ff_id3v2_tag_len ( lpd . buf ) ; \n if ( lpd . buf_size > id3len + 16 ) { \n lpd . buf += id3len ; \n lpd . buf_size -= id3len ; \n } \n id3 = 1 ; \n } \n fmt = NULL ; \n while ( ( fmt1 = av_iformat_next ( fmt1 ) ) ) { \n if ( ! is_opened == ! ( fmt1 -> flags & AVFMT_NOFILE ) ) \n continue ; \n score = 0 ; \n if ( fmt1 -> read_probe ) { \n score = fmt1 -> read_probe ( & lpd ) ; \n } else if ( fmt1 -> extensions ) { \n if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) ) { \n score = 50 ; \n } \n } \n if ( score > * score_max ) { \n * score_max = score ; \n fmt = fmt1 ; \n } else if ( score == * score_max ) \n fmt = NULL ; \n } \n if ( ! fmt && id3 && * score_max < AVPROBE_SCORE_MAX / 4 ) { \n while ( ( fmt = av_iformat_next ( fmt ) ) ) \n if ( fmt -> extensions && av_match_ext ( lpd . filename , fmt -> extensions ) ) { \n * score_max = AVPROBE_SCORE_MAX / 4 ; \n break ; \n } \n } \n return fmt ; \n }", "idx": 13874}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static void v4l2_free_buffer ( void * opaque , uint8_t * unused ) \n { \n V4L2Buffer * avbuf = opaque ; \n V4L2m2mContext * s = buf_to_m2mctx ( avbuf ) ; \n atomic_fetch_sub_explicit ( & s -> refcount , 1 , memory_order_acq_rel ) ; \n if ( s -> reinit ) { \n if ( ! atomic_load ( & s -> refcount ) ) \n sem_post ( & s -> refsync ) ; \n return ; \n } \n if ( avbuf -> context -> streamon ) { \n ff_v4l2_buffer_enqueue ( avbuf ) ; \n return ; \n } \n if ( ! atomic_load ( & s -> refcount ) ) \n ff_v4l2_m2m_codec_end ( s -> avctx ) ; \n }", "idx": 13875}
{"project": "FFmpeg", "commit_id": "09602dbe7a6400e12a66001be5223298f3dc7c56", "target": 1, "func": "static int64_t wav_seek_tag ( AVIOContext * s , int64_t offset , int whence ) \n { \n return avio_seek ( s , offset + ( offset & 1 ) , whence ) ; \n }", "idx": 13876}
{"project": "FFmpeg", "commit_id": "ed307e2659f2db81a434afece905383fdceb9b6e", "target": 1, "func": "rdt_new_context ( void ) \n { \n PayloadContext * rdt = av_mallocz ( sizeof ( PayloadContext ) ) ; \n avformat_open_input ( & rdt -> rmctx , \" \" , & ff_rdt_demuxer , NULL ) ; \n return rdt ; \n }", "idx": 13878}
{"project": "FFmpeg", "commit_id": "60a45713e7bc94b079f8cd39cfaa300e9c381f62", "target": 1, "func": "static av_cold int ipvideo_decode_init ( AVCodecContext * avctx ) \n { \n IpvideoContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> is_16bpp = avctx -> bits_per_coded_sample == 16 ; \n avctx -> pix_fmt = s -> is_16bpp ? AV_PIX_FMT_RGB555 : AV_PIX_FMT_PAL8 ; \n ff_hpeldsp_init ( & s -> hdsp , avctx -> flags ) ; \n s -> last_frame = av_frame_alloc ( ) ; \n s -> second_last_frame = av_frame_alloc ( ) ; \n s -> cur_decode_frame = av_frame_alloc ( ) ; \n s -> prev_decode_frame = av_frame_alloc ( ) ; \n if ( ! s -> last_frame || ! s -> second_last_frame || \n ! s -> cur_decode_frame || ! s -> prev_decode_frame ) { \n av_frame_free ( & s -> last_frame ) ; \n av_frame_free ( & s -> second_last_frame ) ; \n av_frame_free ( & s -> cur_decode_frame ) ; \n av_frame_free ( & s -> prev_decode_frame ) ; \n return AVERROR ( ENOMEM ) ; \n } \n s -> cur_decode_frame -> width = avctx -> width ; \n s -> prev_decode_frame -> width = avctx -> width ; \n s -> cur_decode_frame -> height = avctx -> height ; \n s -> prev_decode_frame -> height = avctx -> height ; \n s -> cur_decode_frame -> format = avctx -> pix_fmt ; \n s -> prev_decode_frame -> format = avctx -> pix_fmt ; \n ff_get_buffer ( avctx , s -> cur_decode_frame , 0 ) ; \n ff_get_buffer ( avctx , s -> prev_decode_frame , 0 ) ; \n return 0 ; \n }", "idx": 13883}
{"project": "FFmpeg", "commit_id": "721d6f2dc5437df21ae17923b29fa2be847764c7", "target": 0, "func": "av_cold int ff_dct_init ( DCTContext * s , int nbits , enum DCTTransformType inverse ) \n { \n int n = 1 << nbits ; \n int i ; \n s -> nbits = nbits ; \n s -> inverse = inverse ; \n ff_init_ff_cos_tabs ( nbits + 2 ) ; \n s -> costab = ff_cos_tabs [ nbits + 2 ] ; \n s -> csc2 = av_malloc ( n / 2 * sizeof ( FFTSample ) ) ; \n if ( ff_rdft_init ( & s -> rdft , nbits , inverse == DCT_III ) < 0 ) { \n av_free ( s -> csc2 ) ; \n return -1 ; \n } \n for ( i = 0 ; i < n / 2 ; i ++ ) \n s -> csc2 [ i ] = 0.5 / sin ( ( M_PI / ( 2 * n ) * ( 2 * i + 1 ) ) ) ; \n switch ( inverse ) { \n case DCT_I : s -> dct_calc = ff_dct_calc_I_c ; break ; \n case DCT_II : s -> dct_calc = ff_dct_calc_II_c ; break ; \n case DCT_III : s -> dct_calc = ff_dct_calc_III_c ; break ; \n case DST_I : s -> dct_calc = ff_dst_calc_I_c ; break ; \n } \n if ( inverse == DCT_II && nbits == 5 ) \n s -> dct_calc = dct32_func ; \n s -> dct32 = dct32 ; \n if ( HAVE_MMX ) ff_dct_init_mmx ( s ) ; \n return 0 ; \n }", "idx": 13894}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_mdhd ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n int version = get_byte ( pb ) ; \n char language [ 4 ] = { 0 } ; \n unsigned lang ; \n if ( version > 1 ) \n return -1 ; \n get_be24 ( pb ) ; \n if ( version == 1 ) { \n get_be64 ( pb ) ; \n get_be64 ( pb ) ; \n } else { \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n } \n sc -> time_scale = get_be32 ( pb ) ; \n st -> duration = ( version == 1 ) ? get_be64 ( pb ) : get_be32 ( pb ) ; \n lang = get_be16 ( pb ) ; \n if ( ff_mov_lang_to_iso639 ( lang , language ) ) \n av_metadata_set ( & st -> metadata , \" \" , language ) ; \n get_be16 ( pb ) ; \n return 0 ; \n }", "idx": 13895}
{"project": "FFmpeg", "commit_id": "c004de0b1c5b44849f9619910c173d1a2204c16e", "target": 1, "func": "static void gif_fill_rect ( AVFrame * picture , uint32_t color , int l , int t , int w , int h ) \n { \n const int linesize = picture -> linesize [ 0 ] / sizeof ( uint32_t ) ; \n const uint32_t * py = ( uint32_t * ) picture -> data [ 0 ] + t * linesize ; \n const uint32_t * pr , * pb = py + ( t + h ) * linesize ; \n uint32_t * px ; \n for ( ; py < pb ; py += linesize ) { \n px = ( uint32_t * ) py + l ; \n pr = px + w ; \n for ( ; px < pr ; px ++ ) \n * px = color ; \n } \n }", "idx": 13901}
{"project": "FFmpeg", "commit_id": "954d94dd5e13ba7a5e9e049d0f980bddced9644c", "target": 1, "func": "static void adx_decode ( ADXContext * c , int16_t * out , const uint8_t * in , int ch ) \n { \n ADXChannelState * prev = & c -> prev [ ch ] ; \n GetBitContext gb ; \n int scale = AV_RB16 ( in ) ; \n int i ; \n int s0 , s1 , s2 , d ; \n init_get_bits ( & gb , in + 2 , ( 18 - 2 ) * 8 ) ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n d = get_sbits ( & gb , 4 ) ; \n s0 = ( BASEVOL * d * scale + SCALE1 * s1 - SCALE2 * s2 ) >> 14 ; \n s2 = s1 ; \n s1 = av_clip_int16 ( s0 ) ; \n * out = s1 ; \n out += c -> channels ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n }", "idx": 13904}
{"project": "FFmpeg", "commit_id": "ec7f04c13a6e6e483cc86e576aff7700e42cd59e", "target": 1, "func": "static inline void rgtc_block_internal ( uint8_t * dst , ptrdiff_t stride , \n const uint8_t * block , \n const int * color_tab ) \n { \n uint8_t indices [ 16 ] ; \n int x , y ; \n decompress_indices ( indices , block + 2 ) ; \n for ( y = 0 ; y < 4 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ ) { \n int i = indices [ x + y * 4 ] ; \n int c = color_tab [ i ] ; \n uint32_t pixel = RGBA ( c , c , c , 255 ) ; \n AV_WL32 ( dst + x * 4 + y * stride , pixel ) ; \n } \n } \n }", "idx": 13911}
{"project": "FFmpeg", "commit_id": "9a697cfe716e2ed5f5ba183910c104c5ad783256", "target": 1, "func": "unsigned avutil_version ( void ) \n { \n av_assert0 ( AV_PIX_FMT_VDA_VLD == 81 ) ; \n av_assert0 ( AV_SAMPLE_FMT_DBLP == 9 ) ; \n av_assert0 ( AVMEDIA_TYPE_ATTACHMENT == 4 ) ; \n av_assert0 ( AV_PICTURE_TYPE_BI == 7 ) ; \n av_assert0 ( LIBAVUTIL_VERSION_MICRO >= 100 ) ; \n av_assert0 ( HAVE_MMX2 == HAVE_MMXEXT ) ; \n return LIBAVUTIL_VERSION_INT ; ", "idx": 13913}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_source_clip ( MXFStructuralComponent * source_clip , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x0202 : \n source_clip -> duration = get_be64 ( pb ) ; \n break ; \n case 0x1201 : \n source_clip -> start_position = get_be64 ( pb ) ; \n break ; \n case 0x1101 : \n url_fskip ( pb , 16 ) ; \n get_buffer ( pb , source_clip -> source_package_uid , 16 ) ; \n break ; \n case 0x1102 : \n source_clip -> source_track_id = get_be32 ( pb ) ; \n break ; \n } \n return 0 ; \n }", "idx": 13918}
{"project": "FFmpeg", "commit_id": "711781d7a1714ea4eb0217eb1ba04811978c43d1", "target": 0, "func": "static void check_pred16x16 ( H264PredContext * h , uint8_t * buf0 , uint8_t * buf1 , \n int codec , int chroma_format , int bit_depth ) \n { \n if ( chroma_format == 1 ) { \n int pred_mode ; \n declare_func ( void , uint8_t * src , ptrdiff_t stride ) ; \n for ( pred_mode = 0 ; pred_mode < 9 ; pred_mode ++ ) { \n if ( check_pred_func ( h -> pred16x16 [ pred_mode ] , \" \" , pred16x16_modes [ codec ] [ pred_mode ] ) ) { \n randomize_buffers ( ) ; \n call_ref ( src0 , 48 ) ; \n call_new ( src1 , 48 ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( src1 , 48 ) ; \n } \n } \n } \n }", "idx": 13921}
{"project": "FFmpeg", "commit_id": "47c9887ecaa764006cf661a6446b3533472f6a6e", "target": 0, "func": "int ff_alloc_packet2 ( AVCodecContext * avctx , AVPacket * avpkt , int size ) \n { \n if ( size < 0 || avpkt -> size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , size ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( avctx ) { \n av_assert0 ( ! avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer ) ; \n if ( ! avpkt -> data || avpkt -> size < size ) { \n av_fast_padded_malloc ( & avctx -> internal -> byte_buffer , & avctx -> internal -> byte_buffer_size , size ) ; \n avpkt -> data = avctx -> internal -> byte_buffer ; \n avpkt -> size = avctx -> internal -> byte_buffer_size ; \n avpkt -> destruct = NULL ; \n } \n } \n if ( avpkt -> data ) { \n AVBufferRef * buf = avpkt -> buf ; \n #if FF_API_DESTRUCT_PACKET  \n  \n  void * destruct = avpkt -> destruct ; \n #endif \n if ( avpkt -> size < size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , avpkt -> size , size ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_init_packet ( avpkt ) ; \n #if FF_API_DESTRUCT_PACKET  \n  \n  avpkt -> destruct = destruct ; \n #endif \n avpkt -> buf = buf ; \n avpkt -> size = size ; \n return 0 ; \n } else { \n int ret = av_new_packet ( avpkt , size ) ; \n if ( ret < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , size ) ; \n return ret ; \n } \n }", "idx": 13922}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void null_end_frame ( AVFilterLink * inlink ) { }", "idx": 13931}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void ff_wmv2_idct_add_c ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n ff_wmv2_idct_c ( block ) ; \n add_pixels_clamped_c ( block , dest , line_size ) ; \n }", "idx": 13942}
{"project": "FFmpeg", "commit_id": "05dfa21d47f35f394938653abcab8b3baa3bc999", "target": 0, "func": "static float ppp_pvq_search_c ( float * X , int * y , int K , int N ) \n { \n int i , y_norm = 0 ; \n float res = 0.0f , xy_norm = 0.0f ; \n for ( i = 0 ; i < N ; i ++ ) \n res += FFABS ( X [ i ] ) ; \n res = K / ( res + FLT_EPSILON ) ; \n for ( i = 0 ; i < N ; i ++ ) { \n y [ i ] = lrintf ( res * X [ i ] ) ; \n y_norm += y [ i ] * y [ i ] ; \n xy_norm += y [ i ] * X [ i ] ; \n K -= FFABS ( y [ i ] ) ; \n } \n while ( K ) { \n int max_idx = 0 , max_den = 1 , phase = FFSIGN ( K ) ; \n float max_num = 0.0f ; \n y_norm += 1.0f ; \n for ( i = 0 ; i < N ; i ++ ) { \n const int ca = 1 ^ ( ( y [ i ] == 0 ) & ( phase < 0 ) ) ; \n const int y_new = y_norm + 2 * phase * FFABS ( y [ i ] ) ; \n float xy_new = xy_norm + 1 * phase * FFABS ( X [ i ] ) ; \n xy_new = xy_new * xy_new ; \n if ( ca && ( max_den * xy_new ) > ( y_new * max_num ) ) { \n max_den = y_new ; \n max_num = xy_new ; \n max_idx = i ; \n } \n } \n K -= phase ; \n phase *= FFSIGN ( X [ max_idx ] ) ; \n xy_norm += 1 * phase * X [ max_idx ] ; \n y_norm += 2 * phase * y [ max_idx ] ; \n y [ max_idx ] += phase ; \n } \n return ( float ) y_norm ; \n }", "idx": 13945}
{"project": "FFmpeg", "commit_id": "526886e6069636a918c8c04db17e864e3d8151c1", "target": 1, "func": "static av_always_inline void decode_subband_internal ( DiracContext * s , SubBand * b , int is_arith ) \n { \n int cb_x , cb_y , left , right , top , bottom ; \n DiracArith c ; \n GetBitContext gb ; \n int cb_width = s -> codeblock [ b -> level + ( b -> orientation != subband_ll ) ] . width ; \n int cb_height = s -> codeblock [ b -> level + ( b -> orientation != subband_ll ) ] . height ; \n int blockcnt_one = ( cb_width + cb_height ) == 2 ; \n if ( ! b -> length ) \n return ; \n init_get_bits8 ( & gb , b -> coeff_data , b -> length ) ; \n if ( is_arith ) \n ff_dirac_init_arith_decoder ( & c , & gb , b -> length ) ; \n top = 0 ; \n for ( cb_y = 0 ; cb_y < cb_height ; cb_y ++ ) { \n bottom = ( b -> height * ( cb_y + 1 ) ) / cb_height ; \n left = 0 ; \n for ( cb_x = 0 ; cb_x < cb_width ; cb_x ++ ) { \n right = ( b -> width * ( cb_x + 1 ) ) / cb_width ; \n codeblock ( s , b , & gb , & c , left , right , top , bottom , blockcnt_one , is_arith ) ; \n left = right ; \n } \n top = bottom ; \n } \n if ( b -> orientation == subband_ll && s -> num_refs == 0 ) \n intra_dc_prediction ( b ) ; \n }", "idx": 13972}
{"project": "FFmpeg", "commit_id": "7c0b84d89911b2035161f5ef51aafbfcc84aa9e2", "target": 1, "func": "static int asf_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n ASFContext * asf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n ASFStream * stream ; \n AVCodecContext * codec ; \n uint32_t packet_number ; \n int64_t pts ; \n int start_sec ; \n int flags = pkt -> flags ; \n int ret ; \n uint64_t offset = avio_tell ( pb ) ; \n codec = s -> streams [ pkt -> stream_index ] -> codec ; \n stream = & asf -> streams [ pkt -> stream_index ] ; \n if ( codec -> codec_type == AVMEDIA_TYPE_AUDIO ) \n flags &= ~ AV_PKT_FLAG_KEY ; \n pts = ( pkt -> pts != AV_NOPTS_VALUE ) ? pkt -> pts : pkt -> dts ; \n av_assert0 ( pts != AV_NOPTS_VALUE ) ; \n pts *= 10000 ; \n asf -> duration = FFMAX ( asf -> duration , pts + pkt -> duration * 10000 ) ; \n packet_number = asf -> nb_packets ; \n put_frame ( s , stream , s -> streams [ pkt -> stream_index ] , \n pkt -> dts , pkt -> data , pkt -> size , flags ) ; \n start_sec = ( int ) ( ( PREROLL_TIME * 10000 + pts + ASF_INDEXED_INTERVAL - 1 ) \n / ASF_INDEXED_INTERVAL ) ; \n if ( ( ! asf -> is_streamed ) && ( flags & AV_PKT_FLAG_KEY ) ) { \n uint16_t packet_count = asf -> nb_packets - packet_number ; \n ret = update_index ( s , start_sec , packet_number , packet_count , offset ) ; \n if ( ret < 0 ) \n return ret ; \n asf -> end_sec = start_sec ; \n return 0 ;", "idx": 13981}
{"project": "FFmpeg", "commit_id": "770c934fa1635f4fadf5db4fc5cc5ad15d82455a", "target": 1, "func": "void ff_mdct_calc_c ( FFTContext * s , FFTSample * out , const FFTSample * input ) \n { \n int i , j , n , n8 , n4 , n2 , n3 ; \n FFTDouble re , im ; \n const uint16_t * revtab = s -> revtab ; \n const FFTSample * tcos = s -> tcos ; \n const FFTSample * tsin = s -> tsin ; \n FFTComplex * x = ( FFTComplex * ) out ; \n n = 1 << s -> mdct_bits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n n8 = n >> 3 ; \n n3 = 3 * n4 ; \n for ( i = 0 ; i < n8 ; i ++ ) { \n re = RSCALE ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ; \n im = RSCALE ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ; \n j = revtab [ i ] ; \n CMUL ( x [ j ] . re , x [ j ] . im , re , im , - tcos [ i ] , tsin [ i ] ) ; \n re = RSCALE ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ; \n im = RSCALE ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ; \n j = revtab [ n8 + i ] ; \n CMUL ( x [ j ] . re , x [ j ] . im , re , im , - tcos [ n8 + i ] , tsin [ n8 + i ] ) ; \n } \n s -> fft_calc ( s , x ) ; \n for ( i = 0 ; i < n8 ; i ++ ) { \n FFTSample r0 , i0 , r1 , i1 ; \n CMUL ( i1 , r0 , x [ n8 - i - 1 ] . re , x [ n8 - i - 1 ] . im , - tsin [ n8 - i - 1 ] , - tcos [ n8 - i - 1 ] ) ; \n CMUL ( i0 , r1 , x [ n8 + i ] . re , x [ n8 + i ] . im , - tsin [ n8 + i ] , - tcos [ n8 + i ] ) ; \n x [ n8 - i - 1 ] . re = r0 ; \n x [ n8 - i - 1 ] . im = i0 ; \n x [ n8 + i ] . re = r1 ; \n x [ n8 + i ] . im = i1 ; \n } \n }", "idx": 13986}
{"project": "FFmpeg", "commit_id": "ab3ff19f08b7a83e320c39ab066f289c242b8030", "target": 1, "func": "static int config_props ( AVFilterLink * inlink ) \n { \n FadeContext * s = inlink -> dst -> priv ; \n const AVPixFmtDescriptor * pixdesc = av_pix_fmt_desc_get ( inlink -> format ) ; \n s -> hsub = pixdesc -> log2_chroma_w ; \n s -> vsub = pixdesc -> log2_chroma_h ; \n s -> bpp = av_get_bits_per_pixel ( pixdesc ) >> 3 ; \n s -> alpha &= ! ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_ALPHA ) ; \n s -> is_packed_rgb = ff_fill_rgba_map ( s -> rgba_map , inlink -> format ) >= 0 ; \n s -> black_level = \n ff_fmt_is_in ( inlink -> format , studio_level_pix_fmts ) && ! s -> alpha ? 16 : 0 ; \n s -> black_level_scaled = ( s -> black_level << 16 ) + 32768 ; \n return 0 ; \n }", "idx": 13998}
{"project": "FFmpeg", "commit_id": "2469ed32c81ebf2347e6883091c566724b286167", "target": 1, "func": "static uint64_t calc_rice_params ( RiceContext * rc , \n uint32_t udata [ FLAC_MAX_BLOCKSIZE ] , \n uint64_t sums [ 32 ] [ MAX_PARTITIONS ] , \n int pmin , int pmax , \n const int32_t * data , int n , int pred_order , int exact ) \n { \n int i ; \n uint64_t bits [ MAX_PARTITION_ORDER + 1 ] ; \n int opt_porder ; \n RiceContext tmp_rc ; \n int kmax = ( 1 << rc -> coding_mode ) - 2 ; \n av_assert1 ( pmin >= 0 && pmin <= MAX_PARTITION_ORDER ) ; \n av_assert1 ( pmax >= 0 && pmax <= MAX_PARTITION_ORDER ) ; \n av_assert1 ( pmin <= pmax ) ; \n tmp_rc . coding_mode = rc -> coding_mode ; \n for ( i = 0 ; i < n ; i ++ ) \n udata [ i ] = ( 2 * data [ i ] ) ^ ( data [ i ] >> 31 ) ; \n calc_sum_top ( pmax , exact ? kmax : 0 , udata , n , pred_order , sums ) ; \n opt_porder = pmin ; \n bits [ pmin ] = UINT32_MAX ; \n for ( i = pmax ; ; ) { \n bits [ i ] = calc_optimal_rice_params ( & tmp_rc , i , sums , n , pred_order , kmax , exact ) ; \n if ( bits [ i ] < bits [ opt_porder ] ) { \n opt_porder = i ; \n * rc = tmp_rc ; \n } \n if ( i == pmin ) \n break ; \n calc_sum_next ( -- i , sums , exact ? kmax : 0 ) ; \n } \n return bits [ opt_porder ] ; \n }", "idx": 14005}
{"project": "FFmpeg", "commit_id": "56c182c4d716b8b72156ff57a0c8d72087db8549", "target": 1, "func": "void ff_nut_free_sp ( NUTContext * nut ) \n { \n av_tree_enumerate ( nut -> syncpoints , NULL , NULL , enu_free ) ; \n av_tree_destroy ( nut -> syncpoints ) ; \n }", "idx": 14010}
{"project": "FFmpeg", "commit_id": "936751b6527cff789ef077a4e43a04ae9e658232", "target": 1, "func": "static const struct URLProtocol * url_find_protocol ( const char * filename ) \n { \n const URLProtocol * * protocols ; \n char proto_str [ 128 ] , proto_nested [ 128 ] , * ptr ; \n size_t proto_len = strspn ( filename , URL_SCHEME_CHARS ) ; \n int i ; \n if ( filename [ proto_len ] != ' ' && \n ( strncmp ( filename , \" \" , 8 ) || ! strchr ( filename + proto_len + 1 , ' ' ) ) || \n is_dos_path ( filename ) ) \n strcpy ( proto_str , \" \" ) ; \n else \n av_strlcpy ( proto_str , filename , \n FFMIN ( proto_len + 1 , sizeof ( proto_str ) ) ) ; \n if ( ( ptr = strchr ( proto_str , ' ' ) ) ) \n * ptr = ' \\0 ' ; \n av_strlcpy ( proto_nested , proto_str , sizeof ( proto_nested ) ) ; \n if ( ( ptr = strchr ( proto_nested , ' ' ) ) ) \n * ptr = ' \\0 ' ; \n protocols = ffurl_get_protocols ( NULL , NULL ) ; \n for ( i = 0 ; protocols [ i ] ; i ++ ) { \n const URLProtocol * up = protocols [ i ] ; \n if ( ! strcmp ( proto_str , up -> name ) ) { \n av_freep ( & protocols ) ; \n return up ; \n } \n if ( up -> flags & URL_PROTOCOL_FLAG_NESTED_SCHEME && \n ! strcmp ( proto_nested , up -> name ) ) { \n av_freep ( & protocols ) ; \n return up ; \n } \n } \n av_freep ( & protocols ) ; \n }", "idx": 14017}
{"project": "FFmpeg", "commit_id": "43cd33be16b21b9a217025e208f4ffbf0bf81da4", "target": 1, "func": "static void postprocess_chroma ( AVFrame * frame , int w , int h , int depth ) \n { \n uint16_t * dstu = ( uint16_t * ) frame -> data [ 1 ] ; \n uint16_t * dstv = ( uint16_t * ) frame -> data [ 2 ] ; \n int16_t * srcu = ( int16_t * ) frame -> data [ 1 ] ; \n int16_t * srcv = ( int16_t * ) frame -> data [ 2 ] ; \n ptrdiff_t strideu = frame -> linesize [ 1 ] / 2 ; \n ptrdiff_t stridev = frame -> linesize [ 2 ] / 2 ; \n const int add = 1 << ( depth - 1 ) ; \n const int shift = 16 - depth ; \n int i , j ; \n for ( j = 0 ; j < h ; j ++ ) { \n for ( i = 0 ; i < w ; i ++ ) { \n dstu [ i ] = ( add + srcu [ i ] ) << shift ; \n dstv [ i ] = ( add + srcv [ i ] ) << shift ; \n } \n dstu += strideu ; \n dstv += stridev ; \n srcu += strideu ; \n srcv += stridev ; \n } \n }", "idx": 14020}
{"project": "FFmpeg", "commit_id": "37ec7d291eacedfacdce21332f4c719f2be79d12", "target": 1, "func": "static int mpeg4_decode_header ( AVCodecParserContext * s1 , AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n struct Mp4vParseContext * pc = s1 -> priv_data ; \n Mpeg4DecContext * dec_ctx = & pc -> dec_ctx ; \n MpegEncContext * s = & dec_ctx -> m ; \n GetBitContext gb1 , * gb = & gb1 ; \n int ret ; \n s -> avctx = avctx ; \n s -> current_picture_ptr = & s -> current_picture ; \n if ( avctx -> extradata_size && pc -> first_picture ) { \n init_get_bits ( gb , avctx -> extradata , avctx -> extradata_size * 8 ) ; \n ret = ff_mpeg4_decode_picture_header ( dec_ctx , gb ) ; \n } \n init_get_bits ( gb , buf , 8 * buf_size ) ; \n ret = ff_mpeg4_decode_picture_header ( dec_ctx , gb ) ; \n if ( s -> width && ( ! avctx -> width || ! avctx -> height || \n ! avctx -> coded_width || ! avctx -> coded_height ) ) { \n ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; \n return ret ; \n } \n if ( ( s1 -> flags & PARSER_FLAG_USE_CODEC_TS ) && s -> avctx -> time_base . den > 0 && ret >= 0 ) { \n av_assert1 ( s1 -> pts == AV_NOPTS_VALUE ) ; \n av_assert1 ( s1 -> dts == AV_NOPTS_VALUE ) ; \n s1 -> pts = av_rescale_q ( s -> time , ( AVRational ) { 1 , s -> avctx -> time_base . den } , ( AVRational ) { 1 , 1200000 } ) ; \n } \n s1 -> pict_type = s -> pict_type ; \n pc -> first_picture = 0 ; \n return ret ; \n }", "idx": 14029}
{"project": "FFmpeg", "commit_id": "190f6135b48a97dadd7586f154640bec6468df1b", "target": 0, "func": "callback ( void * priv_data , int index , uint8_t * buf , int buf_size , int64_t time )  \n { \n AVFormatContext * s = priv_data ; \n struct dshow_ctx * ctx = s -> priv_data ; \n AVPacketList * * ppktl , * pktl_next ; \n WaitForSingleObject ( ctx -> mutex , INFINITE ) ; \n if ( shall_we_drop ( s ) ) \n goto fail ; \n pktl_next = av_mallocz ( sizeof ( AVPacketList ) ) ; \n if ( ! pktl_next ) \n goto fail ; \n if ( av_new_packet ( & pktl_next -> pkt , buf_size ) < 0 ) { \n av_free ( pktl_next ) ; \n goto fail ; \n } \n pktl_next -> pkt . stream_index = index ; \n pktl_next -> pkt . pts = time ; \n memcpy ( pktl_next -> pkt . data , buf , buf_size ) ; \n for ( ppktl = & ctx -> pktl ; * ppktl ; ppktl = & ( * ppktl ) -> next ) ; \n * ppktl = pktl_next ; \n ctx -> curbufsize += buf_size ; \n SetEvent ( ctx -> event ) ; \n ReleaseMutex ( ctx -> mutex ) ; \n return ; \n fail : \n ReleaseMutex ( ctx -> mutex ) ; \n return ; \n }", "idx": 14039}
{"project": "FFmpeg", "commit_id": "b9c8388710a06544812739eedc0a40d3451491dc", "target": 1, "func": "static void * av_mallocz_static ( unsigned int size ) \n { \n void * ptr = av_mallocz ( size ) ; \n if ( ptr ) { \n array_static = av_fast_realloc ( array_static , & allocated_static , sizeof ( void * ) * ( last_static + 1 ) ) ; \n if ( ! array_static ) \n return NULL ; \n array_static [ last_static ++ ] = ptr ; \n } \n return ptr ; \n }", "idx": 14042}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_primer_pack ( MXFContext * mxf ) \n { \n ByteIOContext * pb = mxf -> fc -> pb ; \n int item_num = get_be32 ( pb ) ; \n int item_len = get_be32 ( pb ) ; \n if ( item_len != 18 ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( item_num > UINT_MAX / item_len ) \n return -1 ; \n mxf -> local_tags_count = item_num ; \n mxf -> local_tags = av_malloc ( item_num * item_len ) ; \n if ( ! mxf -> local_tags ) \n return -1 ; \n get_buffer ( pb , mxf -> local_tags , item_num * item_len ) ; \n return 0 ; \n }", "idx": 14045}
{"project": "FFmpeg", "commit_id": "d1f558b3628d3ab99fd93a98b5758ef1be45a5da", "target": 0, "func": "static int convert_bitstream ( const uint8_t * src , int src_size , uint8_t * dst , int max_size ) \n { \n switch ( AV_RB32 ( src ) ) { \n case DCA_SYNCWORD_CORE_BE : \n case DCA_SYNCWORD_SUBSTREAM : \n memcpy ( dst , src , src_size ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_LE : \n case DCA_SYNCWORD_CORE_14B_BE : \n case DCA_SYNCWORD_CORE_14B_LE : \n return avpriv_dca_convert_bitstream ( src , src_size , dst , max_size ) ; \n default : \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 14048}
{"project": "FFmpeg", "commit_id": "b8866783c6a855643a3869020ac5241b12f7d97a", "target": 0, "func": "int ff_scale_image ( uint8_t * dst_data [ 4 ] , int dst_linesize [ 4 ] , \n int dst_w , int dst_h , enum AVPixelFormat dst_pix_fmt , \n uint8_t * const src_data [ 4 ] , int src_linesize [ 4 ] , \n int src_w , int src_h , enum AVPixelFormat src_pix_fmt , \n void * log_ctx ) \n { \n int ret ; \n struct SwsContext * sws_ctx = sws_getContext ( src_w , src_h , src_pix_fmt , \n dst_w , dst_h , dst_pix_fmt , \n SWS_BILINEAR , NULL , NULL , NULL ) ; \n if ( ! sws_ctx ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n av_get_pix_fmt_name ( src_pix_fmt ) , src_w , src_h , \n av_get_pix_fmt_name ( dst_pix_fmt ) , dst_w , dst_h ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n if ( ( ret = av_image_alloc ( dst_data , dst_linesize , dst_w , dst_h , dst_pix_fmt , 16 ) ) < 0 ) \n goto end ; \n ret = 0 ; \n sws_scale ( sws_ctx , ( const uint8_t * const * ) src_data , src_linesize , 0 , src_h , dst_data , dst_linesize ) ; \n end : \n sws_freeContext ( sws_ctx ) ; \n return ret ; \n }", "idx": 14049}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static int v4l2_receive_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n V4L2Context * const capture = & s -> capture ; \n V4L2Context * const output = & s -> output ; \n AVPacket avpkt = { 0 } ; \n int ret ; \n ret = ff_decode_get_packet ( avctx , & avpkt ) ; \n if ( ret < 0 && ret != AVERROR_EOF ) \n return ret ; \n if ( s -> draining ) \n goto dequeue ; \n ret = ff_v4l2_context_enqueue_packet ( output , & avpkt ) ; \n if ( ret < 0 ) { \n if ( ret != AVERROR ( ENOMEM ) ) \n return ret ; \n } \n if ( avpkt . size ) { \n ret = v4l2_try_start ( avctx ) ; \n if ( ret ) \n return 0 ; \n } \n dequeue : \n return ff_v4l2_context_dequeue_frame ( capture , frame ) ; \n }", "idx": 14057}
{"project": "FFmpeg", "commit_id": "b7fa5c5abb39f819fbb42253711bc13e5cac0e81", "target": 1, "func": "static int read_random ( uint32_t * dst , const char * file ) \n { \n int fd = open ( file , O_RDONLY ) ; \n int err = -1 ; \n if ( fd == -1 ) \n return -1 ; \n #if HAVE_FCNTL && defined ( O_NONBLOCK )  \n  \n  if ( fcntl ( fd , F_SETFL , fcntl ( fd , F_GETFL ) | O_NONBLOCK ) != -1 )  \n #endif \n err = read ( fd , dst , sizeof ( * dst ) ) ; \n close ( fd ) ; \n return err ; \n }", "idx": 14060}
{"project": "FFmpeg", "commit_id": "bb6c67bb36b136de10256f0999128df4a42f9ffc", "target": 1, "func": "static int draw_slice ( AVFilterLink * link , int y , int h , int slice_dir ) \n { \n SliceContext * slice = link -> dst -> priv ; \n int y2 , ret = 0 ; \n if ( slice_dir == 1 ) { \n for ( y2 = y ; y2 + slice -> h <= y + h ; y2 += slice -> h ) { \n ret = ff_draw_slice ( link -> dst -> outputs [ 0 ] , y2 , slice -> h , slice_dir ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( y2 < y + h ) \n return ff_draw_slice ( link -> dst -> outputs [ 0 ] , y2 , y + h - y2 , slice_dir ) ; \n } else if ( slice_dir == -1 ) { \n for ( y2 = y + h ; y2 - slice -> h >= y ; y2 -= slice -> h ) { \n ret = ff_draw_slice ( link -> dst -> outputs [ 0 ] , y2 - slice -> h , slice -> h , slice_dir ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( y2 > y ) \n return ff_draw_slice ( link -> dst -> outputs [ 0 ] , y , y2 - y , slice_dir ) ; \n } \n return 0 ; \n }", "idx": 14068}
{"project": "FFmpeg", "commit_id": "cb48e245e6e770f146220fac0a8bd4dc1a5e006c", "target": 1, "func": "static int read_key ( void ) \n { \n #if HAVE_TERMIOS_H  \n  \n  int n = 1 ; \n unsigned char ch ; \n struct timeval tv ; \n fd_set rfds ; \n FD_ZERO ( & rfds ) ; \n FD_SET ( 0 , & rfds ) ; \n tv . tv_sec = 0 ; \n tv . tv_usec = 0 ; \n n = select ( 1 , & rfds , NULL , NULL , & tv ) ; \n if ( n > 0 ) { \n n = read ( 0 , & ch , 1 ) ; \n if ( n == 1 ) \n return ch ; \n return n ; \n } \n #elif HAVE_CONIO_H  \n  \n  if ( kbhit ( ) ) \n return ( getch ( ) ) ; \n #endif \n return -1 ; \n }", "idx": 14074}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_end ( AVCodecContext * avctx ) \n { \n LclEncContext * c = avctx -> priv_data ; \n av_freep ( & avctx -> extradata ) ; \n deflateEnd ( & c -> zstream ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 14084}
{"project": "FFmpeg", "commit_id": "c9fe0caf7a1abde7ca0b1a359f551103064867b1", "target": 0, "func": "static void FUNC ( transquant_bypass4x4 ) ( uint8_t * _dst , int16_t * coeffs , \n ptrdiff_t stride ) \n { \n int x , y ; \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( y = 0 ; y < 4 ; y ++ ) { \n for ( x = 0 ; x < 4 ; x ++ ) { \n dst [ x ] += * coeffs ; \n coeffs ++ ; \n } \n dst += stride ; \n } \n }", "idx": 14107}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_passive_mode ( FTPContext * s ) \n { \n char * res = NULL , * start , * end ; \n int i ; \n const char * command = \" \\r \\n \" ; \n const int pasv_codes [ ] = { 227 , 0 } ; \n if ( ! ftp_send_command ( s , command , pasv_codes , & res ) ) \n goto fail ; \n start = NULL ; \n for ( i = 0 ; i < strlen ( res ) ; ++ i ) { \n if ( res [ i ] == ' ' ) { \n start = res + i + 1 ; \n } else if ( res [ i ] == ' ' ) { \n end = res + i ; \n break ; \n } \n } \n if ( ! start || ! end ) \n goto fail ; \n * end = ' \\0 ' ; \n if ( ! av_strtok ( start , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n if ( ! av_strtok ( end , \" \" , & end ) ) goto fail ; \n start = av_strtok ( end , \" \" , & end ) ; \n if ( ! start ) goto fail ; \n s -> server_data_port = atoi ( start ) * 256 ; \n start = av_strtok ( end , \" \" , & end ) ; \n if ( ! start ) goto fail ; \n s -> server_data_port += atoi ( start ) ; \n av_dlog ( s , \" \\n \" , s -> server_data_port ) ; \n av_free ( res ) ; \n return 0 ; \n fail : \n av_free ( res ) ; \n s -> server_data_port = -1 ; \n return AVERROR ( EIO ) ; \n }", "idx": 14110}
{"project": "FFmpeg", "commit_id": "a9eb4f0899de04a3093a04f461611c6f0664398e", "target": 0, "func": "static enum CodecID find_codec_or_die ( const char * name , int type , int encoder , int strict ) \n { \n const char * codec_string = encoder ? \" \" : \" \" ; \n AVCodec * codec ; \n if ( ! name ) \n return CODEC_ID_NONE ; \n codec = encoder ? \n avcodec_find_encoder_by_name ( name ) : \n avcodec_find_decoder_by_name ( name ) ; \n if ( ! codec ) { \n fprintf ( stderr , \" \\n \" , codec_string , name ) ; \n ffmpeg_exit ( 1 ) ; \n } \n if ( codec -> type != type ) { \n fprintf ( stderr , \" \\n \" , codec_string , name ) ; \n ffmpeg_exit ( 1 ) ; \n } \n if ( codec -> capabilities & CODEC_CAP_EXPERIMENTAL && \n strict > FF_COMPLIANCE_EXPERIMENTAL ) { \n fprintf ( stderr , \" \" \n \" \\n \\n \" , \n codec_string , codec -> name ) ; \n codec = encoder ? \n avcodec_find_encoder ( codec -> id ) : \n avcodec_find_decoder ( codec -> id ) ; \n if ( ! ( codec -> capabilities & CODEC_CAP_EXPERIMENTAL ) ) \n fprintf ( stderr , \" \\n \" , \n codec_string , codec -> name ) ; \n ffmpeg_exit ( 1 ) ; \n } \n return codec -> id ; \n }", "idx": 14120}
{"project": "FFmpeg", "commit_id": "039341eb43945f02867cfe2fe2514eaec4b81ace", "target": 0, "func": "static int wv_read_header ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n WVContext * wc = s -> priv_data ; \n AVStream * st ; \n int ret ; \n wc -> block_parsed = 0 ; \n for ( ; ; ) { \n if ( ( ret = wv_read_block_header ( s , pb , 0 ) ) < 0 ) \n return ret ; \n if ( ! AV_RN32 ( wc -> extra ) ) \n avio_skip ( pb , wc -> blksize - 24 ) ; \n else \n break ; \n } \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codec -> codec_id = AV_CODEC_ID_WAVPACK ; \n st -> codec -> channels = wc -> chan ; \n st -> codec -> channel_layout = wc -> chmask ; \n st -> codec -> sample_rate = wc -> rate ; \n st -> codec -> bits_per_coded_sample = wc -> bpp ; \n avpriv_set_pts_info ( st , 64 , 1 , wc -> rate ) ; \n st -> start_time = 0 ; \n st -> duration = wc -> samples ; \n if ( s -> pb -> seekable ) { \n int64_t cur = avio_tell ( s -> pb ) ; \n wc -> apetag_start = ff_ape_parse_tag ( s ) ; \n if ( ! av_dict_get ( s -> metadata , \" \" , NULL , AV_DICT_IGNORE_SUFFIX ) ) \n ff_id3v1_read ( s ) ; \n avio_seek ( s -> pb , cur , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 14137}
{"project": "FFmpeg", "commit_id": "cbe84b4ffae4619417e119ed63d7c49826feac81", "target": 1, "func": "static int ast_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && \n AV_RB16 ( p -> buf + 10 ) && \n AV_RB16 ( p -> buf + 12 ) && \n AV_RB32 ( p -> buf + 16 ) ) \n return AVPROBE_SCORE_MAX / 3 * 2 ; \n return 0 ; \n }", "idx": 14145}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold void mdct_end ( AC3MDCTContext * mdct ) \n { \n mdct -> nbits = 0 ; \n av_freep ( & mdct -> costab ) ; \n av_freep ( & mdct -> sintab ) ; \n av_freep ( & mdct -> xcos1 ) ; \n av_freep ( & mdct -> xsin1 ) ; \n av_freep ( & mdct -> rot_tmp ) ; \n av_freep ( & mdct -> cplx_tmp ) ; \n }", "idx": 14157}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_weight_h264_pixels4_8_msa ( uint8_t * src , int stride , \n int height , int log2_denom , \n int weight_src , int offset ) \n { \n avc_wgt_4width_msa ( src , stride , \n height , log2_denom , weight_src , offset ) ; \n }", "idx": 14167}
{"project": "FFmpeg", "commit_id": "125acd215250ead008938266efcacd56743f3a2a", "target": 0, "func": "static int filter_query_formats ( AVFilterContext * ctx ) \n { \n int ret , i ; \n AVFilterFormats * formats ; \n AVFilterChannelLayouts * chlayouts ; \n AVFilterFormats * samplerates ; \n enum AVMediaType type = ctx -> inputs && ctx -> inputs [ 0 ] ? ctx -> inputs [ 0 ] -> type : \n ctx -> outputs && ctx -> outputs [ 0 ] ? ctx -> outputs [ 0 ] -> type : \n AVMEDIA_TYPE_VIDEO ; \n if ( ( ret = ctx -> filter -> query_formats ( ctx ) ) < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n ctx -> name , av_err2str ( ret ) ) ; \n return ret ; \n } \n for ( i = 0 ; i < ctx -> nb_inputs ; i ++ ) \n sanitize_channel_layouts ( ctx , ctx -> inputs [ i ] -> out_channel_layouts ) ; \n for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) \n sanitize_channel_layouts ( ctx , ctx -> outputs [ i ] -> in_channel_layouts ) ; \n formats = ff_all_formats ( type ) ; \n if ( ! formats ) \n return AVERROR ( ENOMEM ) ; \n ff_set_common_formats ( ctx , formats ) ; \n if ( type == AVMEDIA_TYPE_AUDIO ) { \n samplerates = ff_all_samplerates ( ) ; \n if ( ! samplerates ) \n return AVERROR ( ENOMEM ) ; \n ff_set_common_samplerates ( ctx , samplerates ) ; \n chlayouts = ff_all_channel_layouts ( ) ; \n if ( ! chlayouts ) \n return AVERROR ( ENOMEM ) ; \n ff_set_common_channel_layouts ( ctx , chlayouts ) ; \n } \n return 0 ; \n }", "idx": 14170}
{"project": "FFmpeg", "commit_id": "9f1473b304ae11ee09b7ae22016c951fdce31dd2", "target": 1, "func": "static int dca_convert_bitstream ( uint8_t * src , int src_size , uint8_t * dst , \n int max_size ) \n { \n uint32_t mrk ; \n int i , tmp ; \n uint16_t * ssrc = ( uint16_t * ) src , * sdst = ( uint16_t * ) dst ; \n PutBitContext pb ; \n mrk = AV_RB32 ( src ) ; \n switch ( mrk ) { \n case DCA_MARKER_RAW_BE : \n memcpy ( dst , src , FFMIN ( src_size , max_size ) ) ; \n return FFMIN ( src_size , max_size ) ; \n case DCA_MARKER_RAW_LE : \n for ( i = 0 ; i < ( FFMIN ( src_size , max_size ) + 1 ) >> 1 ; i ++ ) \n * sdst ++ = bswap_16 ( * ssrc ++ ) ; \n return FFMIN ( src_size , max_size ) ; \n case DCA_MARKER_14B_BE : \n case DCA_MARKER_14B_LE : \n init_put_bits ( & pb , dst , max_size ) ; \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ , src += 2 ) { \n tmp = ( ( mrk == DCA_MARKER_14B_BE ) ? AV_RB16 ( src ) : AV_RL16 ( src ) ) & 0x3FFF ; \n put_bits ( & pb , 14 , tmp ) ; \n } \n flush_put_bits ( & pb ) ; \n return ( put_bits_count ( & pb ) + 7 ) >> 3 ; \n default : \n } \n }", "idx": 14188}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static int show_hwaccels ( void * optctx , const char * opt , const char * arg ) \n { \n int i ; \n printf ( \" \\n \" ) ; \n for ( i = 0 ; hwaccels [ i ] . name ; i ++ ) { \n printf ( \" \\n \" , hwaccels [ i ] . name ) ; \n } \n printf ( \" \\n \" ) ; \n return 0 ; \n }", "idx": 14193}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int Faac_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n FaacAudioContext * s = avctx -> priv_data ; \n int bytes_written , ret ; \n int num_samples = frame ? frame -> nb_samples : 0 ; \n void * samples = frame ? frame -> data [ 0 ] : NULL ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , ( 7 + 768 ) * avctx -> channels ) ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n bytes_written = faacEncEncode ( s -> faac_handle , samples , \n num_samples * avctx -> channels , \n avpkt -> data , avpkt -> size ) ; \n if ( bytes_written < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return bytes_written ; \n } \n if ( frame ) { \n if ( ( ret = ff_af_queue_add ( & s -> afq , frame ) ) < 0 ) \n return ret ; \n } \n if ( ! bytes_written ) \n return 0 ; \n ff_af_queue_remove ( & s -> afq , avctx -> frame_size , & avpkt -> pts , \n & avpkt -> duration ) ; \n avpkt -> size = bytes_written ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 14195}
{"project": "FFmpeg", "commit_id": "26468148979842f2c76531b8646bfbcae23a9a74", "target": 0, "func": "static int check_mv ( H264Context * h , long b_idx , long bn_idx , int mvy_limit ) { \n int v ; \n v = h -> ref_cache [ 0 ] [ b_idx ] != h -> ref_cache [ 0 ] [ bn_idx ] | \n h -> mv_cache [ 0 ] [ b_idx ] [ 0 ] - h -> mv_cache [ 0 ] [ bn_idx ] [ 0 ] + 3 >= 7U | \n FFABS ( h -> mv_cache [ 0 ] [ b_idx ] [ 1 ] - h -> mv_cache [ 0 ] [ bn_idx ] [ 1 ] ) >= mvy_limit ; \n if ( h -> list_count == 2 ) { \n if ( ! v ) \n v = h -> ref_cache [ 1 ] [ b_idx ] != h -> ref_cache [ 1 ] [ bn_idx ] | \n h -> mv_cache [ 1 ] [ b_idx ] [ 0 ] - h -> mv_cache [ 1 ] [ bn_idx ] [ 0 ] + 3 >= 7U | \n FFABS ( h -> mv_cache [ 1 ] [ b_idx ] [ 1 ] - h -> mv_cache [ 1 ] [ bn_idx ] [ 1 ] ) >= mvy_limit ; \n if ( v ) { \n if ( h -> ref_cache [ 0 ] [ b_idx ] != h -> ref_cache [ 1 ] [ bn_idx ] | \n h -> ref_cache [ 1 ] [ b_idx ] != h -> ref_cache [ 0 ] [ bn_idx ] ) \n return 1 ; \n return \n h -> mv_cache [ 0 ] [ b_idx ] [ 0 ] - h -> mv_cache [ 1 ] [ bn_idx ] [ 0 ] + 3 >= 7U | \n FFABS ( h -> mv_cache [ 0 ] [ b_idx ] [ 1 ] - h -> mv_cache [ 1 ] [ bn_idx ] [ 1 ] ) >= mvy_limit | \n h -> mv_cache [ 1 ] [ b_idx ] [ 0 ] - h -> mv_cache [ 0 ] [ bn_idx ] [ 0 ] + 3 >= 7U | \n FFABS ( h -> mv_cache [ 1 ] [ b_idx ] [ 1 ] - h -> mv_cache [ 0 ] [ bn_idx ] [ 1 ] ) >= mvy_limit ; \n } \n } \n return v ; \n }", "idx": 14196}
{"project": "FFmpeg", "commit_id": "1cd9a6154bc1ac1193c703cea980ed21c3e53792", "target": 0, "func": "static int decode_band_types ( AACContext * ac , enum BandType band_type [ 120 ] , \n int band_type_run_end [ 120 ] , GetBitContext * gb , \n IndividualChannelStream * ics ) \n { \n int g , idx = 0 ; \n const int bits = ( ics -> window_sequence [ 0 ] == EIGHT_SHORT_SEQUENCE ) ? 3 : 5 ; \n for ( g = 0 ; g < ics -> num_window_groups ; g ++ ) { \n int k = 0 ; \n while ( k < ics -> max_sfb ) { \n uint8_t sect_end = k ; \n int sect_len_incr ; \n int sect_band_type = get_bits ( gb , 4 ) ; \n if ( sect_band_type == 12 ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n while ( ( sect_len_incr = get_bits ( gb , bits ) ) == ( 1 << bits ) - 1 ) \n sect_end += sect_len_incr ; \n sect_end += sect_len_incr ; \n if ( get_bits_left ( gb ) < 0 ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , overread_err ) ; \n return -1 ; \n } \n if ( sect_end > ics -> max_sfb ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n sect_end , ics -> max_sfb ) ; \n return -1 ; \n } \n for ( ; k < sect_end ; k ++ ) { \n band_type [ idx ] = sect_band_type ; \n band_type_run_end [ idx ++ ] = sect_end ; \n } \n } \n } \n return 0 ; \n }", "idx": 14197}
{"project": "FFmpeg", "commit_id": "650fd9c004e0093dacf928a015947f7490c0dfbf", "target": 1, "func": "static int avr_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return AVPROBE_SCORE_EXTENSION ; \n return 0 ; \n }", "idx": 14202}
{"project": "FFmpeg", "commit_id": "20a93ea8d489304d5c522283d79ea5f9c8fdc804", "target": 0, "func": "void checkasm_check_jpeg2000dsp ( void ) \n { \n LOCAL_ALIGNED_32 ( uint8_t , ref ,  [ BUF_SIZE * 3 ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , new ,  [ BUF_SIZE * 3 ] ) ; \n Jpeg2000DSPContext h ; \n ff_jpeg2000dsp_init ( & h ) ; \n if ( check_func ( h . mct_decode [ FF_DWT53 ] , \" \" ) ) \n check_mct ( & ref [ BUF_SIZE * 0 ] , & ref [ BUF_SIZE * 1 ] , & ref [ BUF_SIZE * 2 ] , \n & new [ BUF_SIZE * 0 ] , & new [ BUF_SIZE * 1 ] , & new [ BUF_SIZE * 2 ] ) ; \n report ( \" \" ) ; \n }", "idx": 14205}
{"project": "FFmpeg", "commit_id": "a75a3ca429e0c0f34a60c3fbd4653f6cd3ab94d7", "target": 0, "func": "static int skip_check ( MpegEncContext * s , Picture * p , Picture * ref ) { \n int x , y , plane ; \n int score = 0 ; \n int64_t score64 = 0 ; \n for ( plane = 0 ; plane < 3 ; plane ++ ) { \n const int stride = p -> linesize [ plane ] ; \n const int bw = plane ? 1 : 2 ; \n for ( y = 0 ; y < s -> mb_height * bw ; y ++ ) { \n for ( x = 0 ; x < s -> mb_width * bw ; x ++ ) { \n int v = s -> dsp . frame_skip_cmp [ 1 ] ( s , p -> data [ plane ] + 8 * ( x + y * stride ) , ref -> data [ plane ] + 8 * ( x + y * stride ) , stride , 8 ) ; \n switch ( s -> avctx -> frame_skip_exp ) { \n case 0 : score = FFMAX ( score , v ) ; break ; \n case 1 : score += ABS ( v ) ; break ; \n case 2 : score += v * v ; break ; \n case 3 : score64 += ABS ( v * v * ( int64_t ) v ) ; break ; \n case 4 : score64 += v * v * ( int64_t ) ( v * v ) ; break ; \n } \n } \n } \n } \n if ( score ) score64 = score ; \n if ( score64 < s -> avctx -> frame_skip_threshold ) \n return 1 ; \n if ( score64 < ( ( s -> avctx -> frame_skip_factor * ( int64_t ) s -> lambda ) >> 8 ) ) \n return 1 ; \n return 0 ; \n }", "idx": 14206}
{"project": "FFmpeg", "commit_id": "6260ab60a80fd8baebf79f9ce9299b0db72333b5", "target": 0, "func": "static void blend_image_rgb ( AVFilterContext * ctx , AVFrame * dst , const AVFrame * src , int x , int y ) \n { \n blend_image_packed_rgb ( ctx , dst , src , 0 , x , y , 0 ) ; \n }", "idx": 14217}
{"project": "FFmpeg", "commit_id": "4a722a5cab15d5aefbf4dd83baa8be5a046580ca", "target": 1, "func": "static av_cold void alloc_temp ( HYuvContext * s ) \n { \n int i ; \n if ( s -> bitstream_bpp < 24 ) { \n for ( i = 0 ; i < 3 ; i ++ ) { \n s -> temp [ i ] = av_malloc ( s -> width + 16 ) ; \n } \n } else { \n s -> temp [ 0 ] = av_mallocz ( 4 * s -> width + 16 ) ; \n } \n }", "idx": 14247}
{"project": "FFmpeg", "commit_id": "a071c0b515e5935b4e2d09899303f6d3c9fb158b", "target": 1, "func": "unsigned int avpriv_toupper4 ( unsigned int x ) \n { \n return av_toupper ( x & 0xFF ) + \n ( av_toupper ( ( x >> 8 ) & 0xFF ) << 8 ) + \n ( av_toupper ( ( x >> 16 ) & 0xFF ) << 16 ) + \n ( av_toupper ( ( x >> 24 ) & 0xFF ) << 24 ) ; \n }", "idx": 14250}
{"project": "FFmpeg", "commit_id": "fe2d6fe2359b153eee827906140e62f710496a37", "target": 0, "func": "int av_write_trailer ( AVFormatContext * s ) \n { \n int ret ; \n while ( s -> packet_buffer ) { \n int ret ; \n AVPacketList * pktl = s -> packet_buffer ; \n truncate_ts ( s -> streams [ pktl -> pkt . stream_index ] , & pktl -> pkt ) ; \n ret = s -> oformat -> write_packet ( s , & pktl -> pkt ) ; \n s -> packet_buffer = pktl -> next ; \n av_free_packet ( & pktl -> pkt ) ; \n av_freep ( & pktl ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ret = s -> oformat -> write_trailer ( s ) ; \n av_freep ( & s -> priv_data ) ; \n return ret ; \n }", "idx": 14252}
{"project": "FFmpeg", "commit_id": "b12d21733975f9001eecb480fc28e5e4473b1327", "target": 0, "func": "static int get_logical_cpus ( AVCodecContext * avctx ) \n { \n int ret , nb_cpus = 1 ; \n #if HAVE_SCHED_GETAFFINITY && defined ( CPU_COUNT )  \n  \n  cpu_set_t cpuset ; \n CPU_ZERO ( & cpuset ) ; \n ret = sched_getaffinity ( 0 , sizeof ( cpuset ) , & cpuset ) ; \n if ( ! ret ) { \n nb_cpus = CPU_COUNT ( & cpuset ) ; \n } \n #elif HAVE_GETSYSTEMINFO  \n  \n  SYSTEM_INFO sysinfo ; \n GetSystemInfo ( & sysinfo ) ; \n nb_cpus = sysinfo . dwNumberOfProcessors ; \n #elif HAVE_SYSCTL && defined ( HW_NCPU )  \n  \n  int mib [ 2 ] = { CTL_HW , HW_NCPU } ; \n size_t len = sizeof ( nb_cpus ) ; \n ret = sysctl ( mib , 2 , & nb_cpus , & len , NULL , 0 ) ; \n if ( ret == -1 ) \n nb_cpus = 0 ; \n #elif HAVE_SYSCONF && defined ( _SC_NPROC_ONLN )  \n  \n  nb_cpus = sysconf ( _SC_NPROC_ONLN ) ; \n #elif HAVE_SYSCONF && defined ( _SC_NPROCESSORS_ONLN )  \n  \n  nb_cpus = sysconf ( _SC_NPROCESSORS_ONLN ) ; \n #endif \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , nb_cpus ) ; \n return FFMIN ( nb_cpus , MAX_AUTO_THREADS ) ; \n }", "idx": 14258}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int ljpeg_encode_close ( AVCodecContext * avctx ) \n { \n LJpegEncContext * s = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n av_freep ( & s -> scratch ) ; \n return 0 ; \n }", "idx": 14259}
{"project": "FFmpeg", "commit_id": "4ace2d22192f3995911ec926940125dcb29d606a", "target": 1, "func": "int ff_g723_1_scale_vector ( int16_t * dst , const int16_t * vector , int length ) \n { \n int bits , max = 0 ; \n int i ; \n for ( i = 0 ; i < length ; i ++ ) \n max |= FFABS ( vector [ i ] ) ; \n bits = 14 - av_log2_16bit ( max ) ; \n bits = FFMAX ( bits , 0 ) ; \n for ( i = 0 ; i < length ; i ++ ) \n dst [ i ] = vector [ i ] << bits >> 3 ; \n return bits - 3 ; \n }", "idx": 14299}
{"project": "FFmpeg", "commit_id": "2d28950da9b2733e2630d3c5aa8a85fd4793f7f5", "target": 0, "func": "void sws_freeFilter ( SwsFilter * filter ) \n { \n if ( ! filter ) \n return ; \n if ( filter -> lumH ) \n sws_freeVec ( filter -> lumH ) ; \n if ( filter -> lumV ) \n sws_freeVec ( filter -> lumV ) ; \n if ( filter -> chrH ) \n sws_freeVec ( filter -> chrH ) ; \n if ( filter -> chrV ) \n sws_freeVec ( filter -> chrV ) ; \n av_free ( filter ) ; \n }", "idx": 14301}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "void add_codec ( FFStream * stream , AVCodecContext * av ) \n { \n AVStream * st ; \n switch ( av -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n if ( av -> bit_rate == 0 ) \n av -> bit_rate = 64000 ; \n if ( av -> sample_rate == 0 ) \n av -> sample_rate = 22050 ; \n if ( av -> channels == 0 ) \n av -> channels = 1 ; \n break ; \n case CODEC_TYPE_VIDEO : \n if ( av -> bit_rate == 0 ) \n av -> bit_rate = 64000 ; \n if ( av -> frame_rate == 0 ) \n av -> frame_rate = 5 * FRAME_RATE_BASE ; \n if ( av -> width == 0 || av -> height == 0 ) { \n av -> width = 160 ; \n av -> height = 128 ; \n } \n if ( av -> bit_rate_tolerance == 0 ) \n av -> bit_rate_tolerance = av -> bit_rate / 4 ; \n if ( av -> qmin == 0 ) \n av -> qmin = 3 ; \n if ( av -> qmax == 0 ) \n av -> qmax = 31 ; \n if ( av -> max_qdiff == 0 ) \n av -> max_qdiff = 3 ; \n av -> qcompress = 0.5 ; \n av -> qblur = 0.5 ; \n break ; \n default : \n abort ( ) ; \n } \n st = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! st ) \n return ; \n stream -> streams [ stream -> nb_streams ++ ] = st ; \n memcpy ( & st -> codec , av , sizeof ( AVCodecContext ) ) ; \n }", "idx": 14303}
{"project": "FFmpeg", "commit_id": "dad42bc5a134f60164eab2dfb0892b761603e1e1", "target": 0, "func": "static int output_frame ( H264Context * h , AVFrame * dst , H264Picture * srcp ) \n { \n AVFrame * src = srcp -> f ; \n int ret ; \n if ( src -> format == AV_PIX_FMT_VIDEOTOOLBOX && src -> buf [ 0 ] -> size == 1 ) \n return AVERROR_EXTERNAL ; \n ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n av_dict_set ( & dst -> metadata , \" \" , ff_h264_sei_stereo_mode ( & h -> sei . frame_packing ) , 0 ) ; \n if ( srcp -> sei_recovery_frame_cnt == 0 ) \n dst -> key_frame = 1 ; \n return 0 ; \n }", "idx": 14305}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "int ff_dxva2_is_d3d11 ( const AVCodecContext * avctx ) \n { \n if ( CONFIG_D3D11VA ) \n return avctx -> pix_fmt == AV_PIX_FMT_D3D11VA_VLD ; \n else \n return 0 ; \n }", "idx": 14307}
{"project": "FFmpeg", "commit_id": "e22155ef0eb393dfc8f6e2a6d9d47d95a8aea9c3", "target": 1, "func": "static int nsv_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n NSVContext * nsv = s -> priv_data ; \n AVStream * st = s -> streams [ stream_index ] ; \n NSVStream * nst = st -> priv_data ; \n int index ; \n index = av_index_search_timestamp ( st , timestamp , flags ) ; \n if ( index < 0 ) \n return -1 ; \n avio_seek ( s -> pb , st -> index_entries [ index ] . pos , SEEK_SET ) ; \n nst -> frame_offset = st -> index_entries [ index ] . timestamp ; \n nsv -> state = NSV_UNSYNC ; \n return 0 ; \n }", "idx": 14310}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "int ff_mov_read_esds ( AVFormatContext * fc , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n int tag ; \n if ( fc -> nb_streams < 1 ) \n return 0 ; \n st = fc -> streams [ fc -> nb_streams - 1 ] ; \n avio_rb32 ( pb ) ; \n ff_mp4_read_descr ( fc , pb , & tag ) ; \n if ( tag == MP4ESDescrTag ) { \n ff_mp4_parse_es_descr ( pb , NULL ) ; \n } else \n avio_rb16 ( pb ) ; \n ff_mp4_read_descr ( fc , pb , & tag ) ; \n if ( tag == MP4DecConfigDescrTag ) \n ff_mp4_read_dec_config_descr ( fc , st , pb ) ; \n return 0 ; \n }", "idx": 14315}
{"project": "FFmpeg", "commit_id": "b6eaa3928e198554a3934dd5ad6eac4d16f27df2", "target": 1, "func": "static int videotoolbox_common_end_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n int status ; \n AVVideotoolboxContext * videotoolbox = avctx -> hwaccel_context ; \n VTContext * vtctx = avctx -> internal -> hwaccel_priv_data ; \n av_buffer_unref ( & frame -> buf [ 0 ] ) ; \n if ( ! videotoolbox -> session || ! vtctx -> bitstream ) \n return AVERROR_INVALIDDATA ; \n status = videotoolbox_session_decode_frame ( avctx ) ; \n if ( status ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , status ) ; \n return AVERROR_UNKNOWN ; \n } \n if ( ! vtctx -> frame ) \n return AVERROR_UNKNOWN ; \n return ff_videotoolbox_buffer_create ( vtctx , frame ) ; \n }", "idx": 14323}
{"project": "FFmpeg", "commit_id": "d150a147dac67faeaf6b1f25a523ae330168ee1e", "target": 0, "func": "static av_cold int close_decoder ( AVCodecContext * avctx ) \n { \n PGSSubContext * ctx = avctx -> priv_data ; \n av_freep ( & ctx -> picture . rle ) ; \n ctx -> picture . rle_buffer_size = 0 ; \n return 0 ; \n }", "idx": 14329}
{"project": "FFmpeg", "commit_id": "4d2f83f8acb6c6444c3b276e15c5369d28b7c037", "target": 0, "func": "static int gsm_parse ( AVCodecParserContext * s1 , AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n GSMParseContext * s = s1 -> priv_data ; \n ParseContext * pc = & s -> pc ; \n int next ; \n if ( ! s -> block_size ) { \n switch ( avctx -> codec_id ) { \n case AV_CODEC_ID_GSM : \n s -> block_size = GSM_BLOCK_SIZE ; \n s -> duration = GSM_FRAME_SIZE ; \n break ; \n case AV_CODEC_ID_GSM_MS : \n s -> block_size = GSM_MS_BLOCK_SIZE ; \n s -> duration = GSM_FRAME_SIZE * 2 ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n } \n if ( ! s -> remaining ) \n s -> remaining = s -> block_size ; \n if ( s -> remaining <= buf_size ) { \n next = s -> remaining ; \n s -> remaining = 0 ; \n } else { \n next = END_NOT_FOUND ; \n s -> remaining -= buf_size ; \n } \n if ( ff_combine_frame ( pc , next , & buf , & buf_size ) < 0 || ! buf_size ) { \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n } \n s1 -> duration = s -> duration ; \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n return next ; \n }", "idx": 14330}
{"project": "FFmpeg", "commit_id": "d597655f771979c70c08f8f8ed84c1319da121e8", "target": 0, "func": "static void put_ebml_uint ( ByteIOContext * pb , unsigned int elementid , uint64_t val ) \n { \n int i , bytes = 1 ; \n while ( val >> bytes * 8 ) bytes ++ ; \n put_ebml_id ( pb , elementid ) ; \n put_ebml_num ( pb , bytes , 0 ) ; \n for ( i = bytes - 1 ; i >= 0 ; i -- ) \n put_byte ( pb , val >> i * 8 ) ; \n }", "idx": 14331}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int sunrast_encode_init ( AVCodecContext * avctx ) \n { \n SUNRASTContext * s = avctx -> priv_data ; \n switch ( avctx -> coder_type ) { \n case FF_CODER_TYPE_RLE : \n s -> type = RT_BYTE_ENCODED ; \n break ; \n case FF_CODER_TYPE_RAW : \n s -> type = RT_STANDARD ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n s -> maptype = RMT_NONE ; \n s -> maplength = 0 ; \n switch ( avctx -> pix_fmt ) { \n case AV_PIX_FMT_MONOWHITE : \n s -> depth = 1 ; \n break ; \n case AV_PIX_FMT_PAL8 : \n s -> maptype = RMT_EQUAL_RGB ; \n s -> maplength = 3 * 256 ; \n case AV_PIX_FMT_GRAY8 : \n s -> depth = 8 ; \n break ; \n case AV_PIX_FMT_BGR24 : \n s -> depth = 24 ; \n break ; \n default : \n return AVERROR_BUG ; \n } \n s -> length = avctx -> height * ( FFALIGN ( avctx -> width * s -> depth , 16 ) >> 3 ) ; \n s -> size = 32 + s -> maplength + \n s -> length * ( s -> type == RT_BYTE_ENCODED ? 2 : 1 ) ; \n return 0 ; \n }", "idx": 14341}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static av_cold int v4l2_decode_init ( AVCodecContext * avctx ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n V4L2Context * capture = & s -> capture ; \n V4L2Context * output = & s -> output ; \n int ret ; \n output -> height = capture -> height = avctx -> coded_height ; \n output -> width = capture -> width = avctx -> coded_width ; \n output -> av_codec_id = avctx -> codec_id ; \n output -> av_pix_fmt = AV_PIX_FMT_NONE ; \n capture -> av_codec_id = AV_CODEC_ID_RAWVIDEO ; \n capture -> av_pix_fmt = avctx -> pix_fmt ; \n ret = ff_v4l2_m2m_codec_init ( avctx ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n return v4l2_prepare_decoder ( s ) ; \n }", "idx": 14345}
{"project": "FFmpeg", "commit_id": "014b178f84fd6c5766e6a626a83f15a0dc635c90", "target": 1, "func": "static int16_t square_root ( int val ) \n { \n return ( ff_sqrt ( val << 1 ) >> 1 ) & ( ~ 1 ) ; \n }", "idx": 14346}
{"project": "FFmpeg", "commit_id": "0d3a51e5d279dd2a56c81ba7a81a70128c5a7545", "target": 1, "func": "static int process_audio_header_eacs ( AVFormatContext * s ) \n { \n EaDemuxContext * ea = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int compression_type ; \n ea -> sample_rate = ea -> big_endian ? avio_rb32 ( pb ) : avio_rl32 ( pb ) ; \n ea -> bytes = avio_r8 ( pb ) ; \n ea -> num_channels = avio_r8 ( pb ) ; \n compression_type = avio_r8 ( pb ) ; \n avio_skip ( pb , 13 ) ; \n switch ( compression_type ) { \n case 0 : \n switch ( ea -> bytes ) { \n case 1 : ea -> audio_codec = CODEC_ID_PCM_S8 ; break ; \n case 2 : ea -> audio_codec = CODEC_ID_PCM_S16LE ; break ; \n break ; \n case 1 : ea -> audio_codec = CODEC_ID_PCM_MULAW ; ea -> bytes = 1 ; break ; \n case 2 : ea -> audio_codec = CODEC_ID_ADPCM_IMA_EA_EACS ; break ; \n default : \n av_log ( s , AV_LOG_ERROR , \" \\n \" , compression_type ) ; \n return 1 ;", "idx": 14347}
{"project": "FFmpeg", "commit_id": "786594184a1797cc4b573001f3eeb188d5912062", "target": 1, "func": "static void add_pid_to_pmt ( MpegTSContext * ts , unsigned int programid , \n unsigned int pid ) \n { \n struct Program * p = get_program ( ts , programid ) ; \n int i ; \n if ( ! p ) \n return ; \n if ( p -> nb_pids >= MAX_PIDS_PER_PROGRAM ) \n return ; \n for ( i = 0 ; i < MAX_PIDS_PER_PROGRAM ; i ++ ) \n if ( p -> pids [ i ] == pid ) \n return ; \n p -> pids [ p -> nb_pids ++ ] = pid ; \n }", "idx": 14349}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr15ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d = ( ( uint16_t * ) src ) [ i ] ; \n int b = d & 0x1F ; \n int g = ( d >> 5 ) & 0x1F ; \n int r = ( d >> 10 ) & 0x1F ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b ) >> ( RGB2YUV_SHIFT - 3 ) ) + 16 ; \n } \n }", "idx": 14353}
{"project": "FFmpeg", "commit_id": "65988b991659fea72365be53e17d10953c0f8f78", "target": 1, "func": "static void decode_gain_info ( GetBitContext * gb , int * gaininfo ) \n { \n int i , n ; \n while ( get_bits1 ( gb ) ) { \n } \n n = get_bits_count ( gb ) - 1 ; \n i = 0 ; \n while ( n -- ) { \n int index = get_bits ( gb , 3 ) ; \n int gain = get_bits1 ( gb ) ? get_bits ( gb , 4 ) - 7 : -1 ; \n while ( i <= index ) \n gaininfo [ i ++ ] = gain ; \n } \n while ( i <= 8 ) \n gaininfo [ i ++ ] = 0 ; \n }", "idx": 14355}
{"project": "FFmpeg", "commit_id": "67fa02ed794f9505bd9c3584c14bfb61c895f5bc", "target": 0, "func": "static inline void celt_encode_pulses ( OpusRangeCoder * rc , int * y , uint32_t N , uint32_t K ) \n { \n ff_opus_rc_enc_uint ( rc , celt_icwrsi ( N , y ) , CELT_PVQ_V ( N , K ) ) ; \n }", "idx": 14365}
{"project": "FFmpeg", "commit_id": "bbd977162590db4b29a5532e3e7102e054ff3ae0", "target": 0, "func": "static inline int coeff_unpack_golomb ( GetBitContext * gb , int qfactor , int qoffset ) \n { \n int sign , coeff ; \n uint32_t buf ; \n OPEN_READER ( re , gb ) ; \n UPDATE_CACHE ( re , gb ) ; \n buf = GET_CACHE ( re , gb ) ; \n if ( buf & 0xAA800000 ) { \n buf >>= 32 - 8 ; \n SKIP_BITS ( re , gb , ff_interleaved_golomb_vlc_len [ buf ] ) ; \n coeff = ff_interleaved_ue_golomb_vlc_code [ buf ] ; \n } else { \n unsigned ret = 1 ; \n do { \n buf >>= 32 - 8 ; \n SKIP_BITS ( re , gb , \n FFMIN ( ff_interleaved_golomb_vlc_len [ buf ] , 8 ) ) ; \n if ( ff_interleaved_golomb_vlc_len [ buf ] != 9 ) { \n ret <<= ( ff_interleaved_golomb_vlc_len [ buf ] - 1 ) >> 1 ; \n ret |= ff_interleaved_dirac_golomb_vlc_code [ buf ] ; \n break ; \n } \n ret = ( ret << 4 ) | ff_interleaved_dirac_golomb_vlc_code [ buf ] ; \n UPDATE_CACHE ( re , gb ) ; \n buf = GET_CACHE ( re , gb ) ; \n } while ( ret < 0x8000000U && BITS_AVAILABLE ( re , gb ) ) ; \n coeff = ret - 1 ; \n } \n if ( coeff ) { \n coeff = ( coeff * qfactor + qoffset + 2 ) >> 2 ; \n sign = SHOW_SBITS ( re , gb , 1 ) ; \n LAST_SKIP_BITS ( re , gb , 1 ) ; \n coeff = ( coeff ^ sign ) - sign ; \n } \n CLOSE_READER ( re , gb ) ; \n return coeff ; \n }", "idx": 14383}
{"project": "FFmpeg", "commit_id": "40fbf3204208f89a0626f85ce6dd06ca0741583b", "target": 0, "func": "int attribute_align_arg avcodec_receive_frame ( AVCodecContext * avctx , AVFrame * frame ) \n { \n int ret ; \n av_frame_unref ( frame ) ; \n if ( ! avcodec_is_open ( avctx ) || ! av_codec_is_decoder ( avctx -> codec ) ) \n return AVERROR ( EINVAL ) ; \n if ( avctx -> codec -> receive_frame ) { \n if ( avctx -> internal -> draining && ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) ) \n return AVERROR_EOF ; \n return avctx -> codec -> receive_frame ( avctx , frame ) ; \n } \n if ( ! avctx -> internal -> buffer_frame -> buf [ 0 ] ) { \n if ( ! avctx -> internal -> buffer_pkt -> size && ! avctx -> internal -> draining ) \n return AVERROR ( EAGAIN ) ; \n while ( 1 ) { \n if ( ( ret = do_decode ( avctx , avctx -> internal -> buffer_pkt ) ) < 0 ) { \n av_packet_unref ( avctx -> internal -> buffer_pkt ) ; \n return ret ; \n } \n if ( avctx -> internal -> buffer_frame -> buf [ 0 ] || \n ! avctx -> internal -> buffer_pkt -> size ) \n break ; \n } \n } \n if ( ! avctx -> internal -> buffer_frame -> buf [ 0 ] ) \n return avctx -> internal -> draining ? AVERROR_EOF : AVERROR ( EAGAIN ) ; \n av_frame_move_ref ( frame , avctx -> internal -> buffer_frame ) ; \n return 0 ; \n }", "idx": 14394}
{"project": "FFmpeg", "commit_id": "e9e87822022fc81f92866f870ecedfd2f6272ac9", "target": 0, "func": "static int find_image_range ( int * pfirst_index , int * plast_index , \n const char * path , int start_index , int start_index_range ) \n { \n char buf [ 1024 ] ; \n int range , last_index , range1 , first_index ; \n for ( first_index = start_index ; first_index < start_index + start_index_range ; first_index ++ ) { \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , first_index ) < 0 ) { \n * pfirst_index = \n * plast_index = 1 ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n return 0 ; \n return -1 ; \n } \n if ( avio_check ( buf , AVIO_FLAG_READ ) > 0 ) \n break ; \n } \n if ( first_index == start_index + start_index_range ) \n goto fail ; \n last_index = first_index ; \n for ( ; ; ) { \n range = 0 ; \n for ( ; ; ) { \n if ( ! range ) \n range1 = 1 ; \n else \n range1 = 2 * range ; \n if ( av_get_frame_filename ( buf , sizeof ( buf ) , path , \n last_index + range1 ) < 0 ) \n goto fail ; \n if ( avio_check ( buf , AVIO_FLAG_READ ) <= 0 ) \n break ; \n range = range1 ; \n if ( range >= ( 1 << 30 ) ) \n goto fail ; \n } \n if ( ! range ) \n break ; \n last_index += range ; \n } \n * pfirst_index = first_index ; \n * plast_index = last_index ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 14401}
{"project": "FFmpeg", "commit_id": "a8ff69ce2bad1c4bb043e88ea35f5ab5691d4f3c", "target": 0, "func": "static int encode_ext_header ( Wmv2Context * w ) { \n MpegEncContext * const s = & w -> s ; \n PutBitContext pb ; \n int code ; \n init_put_bits ( & pb , s -> avctx -> extradata , s -> avctx -> extradata_size ) ; \n put_bits ( & pb , 5 , s -> avctx -> time_base . den / s -> avctx -> time_base . num ) ; \n put_bits ( & pb , 11 , FFMIN ( s -> bit_rate / 1024 , 2047 ) ) ; \n put_bits ( & pb , 1 , w -> mspel_bit = 1 ) ; \n put_bits ( & pb , 1 , w -> flag3 = 1 ) ; \n put_bits ( & pb , 1 , w -> abt_flag = 1 ) ; \n put_bits ( & pb , 1 , w -> j_type_bit = 1 ) ; \n put_bits ( & pb , 1 , w -> top_left_mv_flag = 0 ) ; \n put_bits ( & pb , 1 , w -> per_mb_rl_bit = 1 ) ; \n put_bits ( & pb , 3 , code = 1 ) ; \n flush_put_bits ( & pb ) ; \n s -> slice_height = s -> mb_height / code ; \n return 0 ; \n }", "idx": 14416}
{"project": "FFmpeg", "commit_id": "2c9639227766fea9a8109f82378b312a8d32a1ee", "target": 1, "func": "int avpicture_get_size ( enum AVPixelFormat pix_fmt , int width , int height ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n AVPicture dummy_pict ; \n int ret ; \n if ( ( ret = av_image_check_size ( width , height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( desc -> flags & PIX_FMT_PSEUDOPAL ) \n return width * height ; \n return avpicture_fill ( & dummy_pict , NULL , pix_fmt , width , height ) ; \n }", "idx": 14447}
{"project": "FFmpeg", "commit_id": "6e8fe448154e1aa0928cb0d2e1aecb7255c751cc", "target": 1, "func": "static av_cold int wmv2_encode_init ( AVCodecContext * avctx ) { \n Wmv2Context * const w = avctx -> priv_data ; \n if ( ff_MPV_encode_init ( avctx ) < 0 ) \n return -1 ; \n ff_wmv2_common_init ( w ) ; \n avctx -> extradata_size = 4 ; \n avctx -> extradata = av_mallocz ( avctx -> extradata_size + 10 ) ; \n encode_ext_header ( w ) ; \n return 0 ; \n }", "idx": 14451}
{"project": "FFmpeg", "commit_id": "85a4dbeb9c9aa8b22ca5a7b76aa48f6f44735156", "target": 1, "func": "static int adaptive_cb_search ( const int16_t * adapt_cb , float * work , \n const float * coefs , float * data ) \n { \n int i , best_vect ; \n float score , gain , best_score , best_gain ; \n float exc [ BLOCKSIZE ] ; \n gain = best_score = 0 ; \n for ( i = BLOCKSIZE / 2 ; i <= BUFFERSIZE ; i ++ ) { \n create_adapt_vect ( exc , adapt_cb , i ) ; \n get_match_score ( work , coefs , exc , NULL , NULL , data , & score , & gain ) ; \n if ( score > best_score ) { \n best_score = score ; \n best_vect = i ; \n best_gain = gain ; \n } \n } \n if ( ! best_score ) \n return 0 ; \n create_adapt_vect ( exc , adapt_cb , best_vect ) ; \n ff_celp_lp_synthesis_filterf ( work , coefs , exc , BLOCKSIZE , LPC_ORDER ) ; \n for ( i = 0 ; i < BLOCKSIZE ; i ++ ) \n data [ i ] -= best_gain * work [ i ] ; \n return best_vect - BLOCKSIZE / 2 + 1 ; \n }", "idx": 14454}
{"project": "FFmpeg", "commit_id": "838740e6420538ad45982da6b1d3aa3ae91307f5", "target": 1, "func": "static void decode_hrd ( HEVCContext * s , int common_inf_present , \n int max_sublayers ) \n { \n GetBitContext * gb = & s -> HEVClc . gb ; \n int nal_params_present = 0 , vcl_params_present = 0 ; \n int subpic_params_present = 0 ; \n int i ; \n if ( common_inf_present ) { \n nal_params_present = get_bits1 ( gb ) ; \n vcl_params_present = get_bits1 ( gb ) ; \n if ( nal_params_present || vcl_params_present ) { \n subpic_params_present = get_bits1 ( gb ) ; \n if ( subpic_params_present ) { \n skip_bits ( gb , 8 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 1 ) ; \n skip_bits ( gb , 5 ) ; \n } \n skip_bits ( gb , 4 ) ; \n skip_bits ( gb , 4 ) ; \n if ( subpic_params_present ) \n skip_bits ( gb , 4 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 5 ) ; \n skip_bits ( gb , 5 ) ; \n } \n } \n for ( i = 0 ; i < max_sublayers ; i ++ ) { \n int low_delay = 0 ; \n int nb_cpb = 1 ; \n int fixed_rate = get_bits1 ( gb ) ; \n if ( ! fixed_rate ) \n fixed_rate = get_bits1 ( gb ) ; \n if ( fixed_rate ) \n get_ue_golomb_long ( gb ) ; \n else \n low_delay = get_bits1 ( gb ) ; \n if ( ! low_delay ) \n nb_cpb = get_ue_golomb_long ( gb ) + 1 ; \n if ( nal_params_present ) \n decode_sublayer_hrd ( s , nb_cpb , subpic_params_present ) ; \n if ( vcl_params_present ) \n decode_sublayer_hrd ( s , nb_cpb , subpic_params_present ) ; \n } \n }", "idx": 14460}
{"project": "FFmpeg", "commit_id": "8458dab185ab52c3663c6f5a57c2bee7ca22af37", "target": 0, "func": "static int rle_unpack ( unsigned char * src , unsigned char * dest , int len ) \n { \n unsigned char * ps ; \n unsigned char * pd ; \n int i , l ; \n ps = src ; \n pd = dest ; \n if ( len & 1 ) \n * pd ++ = * ps ++ ; \n len >>= 1 ; \n i = 0 ; \n do { \n l = * ps ++ ; \n if ( l & 0x80 ) { \n l = ( l & 0x7F ) * 2 ; \n memcpy ( pd , ps , l ) ; \n ps += l ; \n pd += l ; \n } else { \n for ( i = 0 ; i < l ; i ++ ) { \n * pd ++ = ps [ 0 ] ; \n * pd ++ = ps [ 1 ] ; \n } \n ps += 2 ; \n } \n i += l ; \n } while ( i < len ) ; \n return ( ps - src ) ; \n }", "idx": 14488}
{"project": "FFmpeg", "commit_id": "df63f130c880c078e4b0ab0652fcb86d31ac1cdd", "target": 0, "func": "static int flv_set_video_codec ( AVFormatContext * s , AVStream * vstream , int flv_codecid ) { \n FLVContext * flv = s -> priv_data ; \n AVCodecContext * vcodec = vstream -> codec ; \n switch ( flv_codecid ) { \n case FLV_CODECID_H263 : vcodec -> codec_id = CODEC_ID_FLV1 ; break ; \n case FLV_CODECID_SCREEN : vcodec -> codec_id = CODEC_ID_FLASHSV ; break ; \n case FLV_CODECID_VP6A : \n if ( ! flv -> alpha_stream ) { \n AVCodecContext * alpha_codec ; \n flv -> alpha_stream = av_new_stream ( s , 2 ) ; \n if ( flv -> alpha_stream ) { \n av_set_pts_info ( flv -> alpha_stream , 24 , 1 , 1000 ) ; \n alpha_codec = flv -> alpha_stream -> codec ; \n alpha_codec -> codec_type = CODEC_TYPE_VIDEO ; \n alpha_codec -> codec_id = CODEC_ID_VP6F ; \n alpha_codec -> extradata_size = 1 ; \n alpha_codec -> extradata = av_malloc ( 1 ) ; \n } \n } \n case FLV_CODECID_VP6 : vcodec -> codec_id = CODEC_ID_VP6F ; \n if ( vcodec -> extradata_size != 1 ) { \n vcodec -> extradata_size = 1 ; \n vcodec -> extradata = av_malloc ( 1 ) ; \n } \n vcodec -> extradata [ 0 ] = get_byte ( & s -> pb ) ; \n if ( flv -> alpha_stream ) \n flv -> alpha_stream -> codec -> extradata [ 0 ] = vcodec -> extradata [ 0 ] ; \n return 1 ; \n default : \n av_log ( s , AV_LOG_INFO , \" \\n \" , flv_codecid ) ; \n vcodec -> codec_tag = flv_codecid ; \n } \n return 0 ; \n }", "idx": 14514}
{"project": "FFmpeg", "commit_id": "31d657130b02b151a2fe6739f782d9d504b2cfda", "target": 0, "func": "static int sub2video_prepare ( InputStream * ist , InputFilter * ifilter ) \n { \n AVFormatContext * avf = input_files [ ist -> file_index ] -> ctx ; \n int i , w , h ; \n w = ifilter -> width ; \n h = ifilter -> height ; \n if ( ! ( w && h ) ) { \n for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { \n if ( avf -> streams [ i ] -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n w = FFMAX ( w , avf -> streams [ i ] -> codecpar -> width ) ; \n h = FFMAX ( h , avf -> streams [ i ] -> codecpar -> height ) ; \n } \n } \n if ( ! ( w && h ) ) { \n w = FFMAX ( w , 720 ) ; \n h = FFMAX ( h , 576 ) ; \n } \n av_log ( avf , AV_LOG_INFO , \" \\n \" , w , h ) ; \n } \n ist -> sub2video . w = ist -> resample_width = w ; \n ist -> sub2video . h = ist -> resample_height = h ; \n ist -> resample_pix_fmt = ifilter -> format = AV_PIX_FMT_RGB32 ; \n ist -> sub2video . frame = av_frame_alloc ( ) ; \n if ( ! ist -> sub2video . frame ) \n return AVERROR ( ENOMEM ) ; \n ist -> sub2video . last_pts = INT64_MIN ; \n return 0 ; \n }", "idx": 14516}
{"project": "FFmpeg", "commit_id": "42e7f6d781e0533505ffab53640739c7912a6753", "target": 0, "func": "static int parse_inputs ( const char * * buf , AVFilterInOut * * curr_inputs , \n AVFilterInOut * * open_outputs , AVClass * log_ctx ) \n { \n int pad = 0 ; \n while ( * * buf == ' ' ) { \n char * name = parse_link_name ( buf , log_ctx ) ; \n AVFilterInOut * match ; \n if ( ! name ) \n return -1 ; \n match = extract_inout ( name , open_outputs ) ; \n if ( match ) { \n av_free ( name ) ; \n } else { \n match = av_mallocz ( sizeof ( AVFilterInOut ) ) ; \n match -> name = name ; \n match -> pad_idx = pad ; \n } \n insert_inout ( curr_inputs , match ) ; \n * buf += strspn ( * buf , WHITESPACES ) ; \n pad ++ ; \n } \n return pad ; \n }", "idx": 14517}
{"project": "FFmpeg", "commit_id": "e292d75113fdcb28dcd76321771ec139393af35e", "target": 1, "func": "static int writer_open ( WriterContext * * wctx , const Writer * writer , const char * args , \n const struct section * sections , int nb_sections ) \n { \n int i , ret = 0 ; \n if ( ! ( * wctx = av_malloc ( sizeof ( WriterContext ) ) ) ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( ! ( ( * wctx ) -> priv = av_mallocz ( writer -> priv_size ) ) ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n ( * wctx ) -> class = & writer_class ; \n ( * wctx ) -> writer = writer ; \n ( * wctx ) -> level = -1 ; \n ( * wctx ) -> sections = sections ; \n ( * wctx ) -> nb_sections = nb_sections ; \n if ( writer -> priv_class ) { \n void * priv_ctx = ( * wctx ) -> priv ; \n * ( ( const AVClass * * ) priv_ctx ) = writer -> priv_class ; \n av_opt_set_defaults ( priv_ctx ) ; \n if ( args && \n ( ret = av_set_options_string ( priv_ctx , args , \" \" , \" \" ) ) < 0 ) \n goto fail ; \n } \n for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) \n av_bprint_init ( & ( * wctx ) -> section_pbuf [ i ] , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; \n if ( ( * wctx ) -> writer -> init ) \n ret = ( * wctx ) -> writer -> init ( * wctx ) ; \n if ( ret < 0 ) \n goto fail ; \n return 0 ; \n fail : \n writer_close ( wctx ) ; \n return ret ; \n }", "idx": 14523}
{"project": "FFmpeg", "commit_id": "38f966b2222db4bfeeaca4642a63049253536c46", "target": 0, "func": "static void test_vector_dmul_scalar ( const double * src0 , const double * src1 ) \n { \n LOCAL_ALIGNED_32 ( double , cdst ,  [ LEN ] ) ; \n LOCAL_ALIGNED_32 ( double , odst ,  [ LEN ] ) ; \n int i ; \n declare_func ( void , double * dst , const double * src , double mul , int len ) ; \n call_ref ( cdst , src0 , src1 [ 0 ] , LEN ) ; \n call_new ( odst , src0 , src1 [ 0 ] , LEN ) ; \n for ( i = 0 ; i < LEN ; i ++ ) { \n if ( ! double_near_abs_eps ( cdst [ i ] , odst [ i ] , DBL_EPSILON ) ) { \n fprintf ( stderr , \" \\n \" , i , \n cdst [ i ] , odst [ i ] , cdst [ i ] - odst [ i ] ) ; \n fail ( ) ; \n break ; \n } \n } \n bench_new ( odst , src0 , src1 [ 0 ] , LEN ) ; \n }", "idx": 14546}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static void show_packet ( WriterContext * w , AVFormatContext * fmt_ctx , AVPacket * pkt , int packet_idx ) \n { \n char val_str [ 128 ] ; \n AVStream * st = fmt_ctx -> streams [ pkt -> stream_index ] ; \n struct print_buf pbuf = { . s = NULL } ; \n print_section_header ( \" \" ) ; \n print_str ( \" \" , av_x_if_null ( av_get_media_type_string ( st -> codec -> codec_type ) , \" \" ) ) ; \n print_int ( \" \" , pkt -> stream_index ) ; \n print_ts ( \" \" , pkt -> pts ) ; \n print_time ( \" \" , pkt -> pts , & st -> time_base ) ; \n print_ts ( \" \" , pkt -> dts ) ; \n print_time ( \" \" , pkt -> dts , & st -> time_base ) ; \n print_ts ( \" \" , pkt -> duration ) ; \n print_time ( \" \" , pkt -> duration , & st -> time_base ) ; \n print_val ( \" \" , pkt -> size , unit_byte_str ) ; \n print_fmt ( \" \" , \" \" PRId64 , pkt -> pos ) ; \n print_fmt ( \" \" , \" \" , pkt -> flags & AV_PKT_FLAG_KEY ? ' ' : ' ' ) ; \n print_section_footer ( \" \" ) ; \n av_free ( pbuf . s ) ; \n fflush ( stdout ) ; \n }", "idx": 14547}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static av_cold int flac_decode_init ( AVCodecContext * avctx ) \n { \n FLACContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> sample_fmt = SAMPLE_FMT_S16 ; \n if ( avctx -> extradata_size > 4 ) { \n if ( avctx -> extradata_size == FLAC_STREAMINFO_SIZE ) { \n ff_flac_parse_streaminfo ( avctx , ( FLACStreaminfo * ) s , \n avctx -> extradata ) ; \n allocate_buffers ( s ) ; \n } else { \n init_get_bits ( & s -> gb , avctx -> extradata , avctx -> extradata_size * 8 ) ; \n metadata_parse ( s ) ; \n } \n } \n return 0 ; \n }", "idx": 14603}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_shorts_metadata ( int count , const char * name , \n const char * sep , TiffContext * s ) \n { \n char * ap ; \n int i ; \n int16_t * sp ; \n if ( count >= INT_MAX / sizeof ( int16_t ) || count <= 0 ) \n return AVERROR_INVALIDDATA ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int16_t ) ) \n return AVERROR_INVALIDDATA ; \n sp = av_malloc ( count * sizeof ( int16_t ) ) ; \n if ( ! sp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n sp [ i ] = tget_short ( & s -> gb , s -> le ) ; \n ap = shorts2str ( sp , count , sep ) ; \n av_freep ( & sp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( avpriv_frame_get_metadatap ( & s -> picture ) , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 14605}
{"project": "FFmpeg", "commit_id": "796012af6c780b5b13ebca39a491f215515a18fe", "target": 0, "func": "static uint8_t * advance_line ( uint8_t * start , uint8_t * line , \n int stride , int * y , int h , int interleave ) \n { \n * y += interleave ; \n if ( * y < h ) { \n return line + interleave * stride ; \n } else { \n * y = ( * y + 1 ) & ( interleave - 1 ) ; \n if ( * y ) { \n return start + * y * stride ; \n } else { \n return NULL ; \n } \n } \n }", "idx": 14609}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel16_mc32_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_16w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 16 , 1 ) ; \n }", "idx": 14610}
{"project": "FFmpeg", "commit_id": "4f3b058c84f570e261d743c7c22f865617fd28ac", "target": 1, "func": "void ff_cavs_init_top_lines ( AVSContext * h ) { \n h -> top_qp = av_malloc ( h -> mb_width ) ; \n h -> top_mv [ 0 ] = av_malloc ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ; \n h -> top_mv [ 1 ] = av_malloc ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ; \n h -> top_pred_Y = av_malloc ( h -> mb_width * 2 * sizeof ( * h -> top_pred_Y ) ) ; \n h -> top_border_y = av_malloc ( ( h -> mb_width + 1 ) * 16 ) ; \n h -> top_border_u = av_malloc ( h -> mb_width * 10 ) ; \n h -> top_border_v = av_malloc ( h -> mb_width * 10 ) ; \n h -> col_mv = av_malloc ( h -> mb_width * h -> mb_height * 4 * sizeof ( cavs_vector ) ) ; \n h -> col_type_base = av_malloc ( h -> mb_width * h -> mb_height ) ; \n h -> block = av_mallocz ( 64 * sizeof ( int16_t ) ) ; \n }", "idx": 14613}
{"project": "FFmpeg", "commit_id": "6fd075f1806e375f66ce436cca15e085f0088118", "target": 1, "func": "int avpriv_adx_decode_header ( AVCodecContext * avctx , const uint8_t * buf , \n int bufsize , int * header_size , int * coeff ) \n { \n int offset , cutoff ; \n if ( bufsize < 24 ) \n return AVERROR_INVALIDDATA ; \n if ( AV_RB16 ( buf ) != 0x8000 ) \n return AVERROR_INVALIDDATA ; \n offset = AV_RB16 ( buf + 2 ) + 4 ; \n if ( bufsize >= offset && memcmp ( buf + offset - 6 , \" \" , 6 ) ) \n return AVERROR_INVALIDDATA ; \n if ( buf [ 4 ] != 3 || buf [ 5 ] != 18 || buf [ 6 ] != 4 ) { \n av_log_ask_for_sample ( avctx , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avctx -> channels = buf [ 7 ] ; \n if ( avctx -> channels > 2 ) \n return AVERROR_INVALIDDATA ; \n avctx -> sample_rate = AV_RB32 ( buf + 8 ) ; \n if ( avctx -> sample_rate < 1 || \n avctx -> sample_rate > INT_MAX / ( avctx -> channels * BLOCK_SIZE * 8 ) ) \n return AVERROR_INVALIDDATA ; \n avctx -> bit_rate = avctx -> sample_rate * avctx -> channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES ; \n if ( coeff ) { \n cutoff = AV_RB16 ( buf + 16 ) ; \n ff_adx_calculate_coeffs ( cutoff , avctx -> sample_rate , COEFF_BITS , coeff ) ; \n } \n * header_size = offset ; \n return 0 ; \n }", "idx": 14619}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void apply_mdct ( AC3EncodeContext * s ) \n { \n int blk , ch ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n const SampleType * input_samples = & s -> planar_samples [ ch ] [ blk * AC3_BLOCK_SIZE ] ; \n apply_window ( & s -> dsp , s -> windowed_samples , input_samples , s -> mdct . window , AC3_WINDOW_SIZE ) ; \n block -> coeff_shift [ ch ] = normalize_samples ( s ) ; \n mdct512 ( & s -> mdct , block -> mdct_coef [ ch ] , s -> windowed_samples ) ; \n } \n } \n }", "idx": 14623}
{"project": "FFmpeg", "commit_id": "db56a7507ee7c1e095d2eef451d5a487f614edff", "target": 1, "func": "static inline int draw_glyph_rgb ( AVFilterBufferRef * picref , FT_Bitmap * bitmap , \n unsigned int x , unsigned int y , \n unsigned int width , unsigned int height , int pixel_step , \n const uint8_t rgba_color [ 4 ] , const uint8_t rgba_map [ 4 ] ) \n { \n int r , c , alpha ; \n uint8_t * p ; \n uint8_t src_val ; \n for ( r = 0 ; r < bitmap -> rows && r + y < height ; r ++ ) { \n for ( c = 0 ; c < bitmap -> width && c + x < width ; c ++ ) { \n src_val = GET_BITMAP_VAL ( r , c ) ; \n if ( ! src_val ) \n continue ; \n SET_PIXEL_RGB ( picref , rgba_color , src_val , c + x , y + r , pixel_step , \n rgba_map [ 0 ] , rgba_map [ 1 ] , rgba_map [ 2 ] , rgba_map [ 3 ] ) ; \n } \n } \n return 0 ; \n }", "idx": 14631}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_5x5 ( GetBitContext * gb , AVFrame * frame , \n int line , int left , uint8_t lru [ 3 ] [ 8 ] , \n int is_565 ) \n { \n int x , y ; \n int r , g , b ; \n int width = frame -> width ; \n int stride = frame -> linesize [ 0 ] ; \n uint8_t * dst = frame -> data [ 0 ] + stride * line ; \n for ( y = 0 ; y < left && get_bits_left ( gb ) > 16 ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n b = decode_sym_565 ( gb , lru [ 0 ] , 5 ) ; \n g = decode_sym_565 ( gb , lru [ 1 ] , is_565 ? 6 : 5 ) ; \n r = decode_sym_565 ( gb , lru [ 2 ] , 5 ) ; \n dst [ x * 3 + 0 ] = ( r << 3 ) | ( r >> 2 ) ; \n dst [ x * 3 + 1 ] = is_565 ? ( g << 2 ) | ( g >> 4 ) : ( g << 3 ) | ( g >> 2 ) ; \n dst [ x * 3 + 2 ] = ( b << 3 ) | ( b >> 2 ) ; \n } \n dst += stride ; \n } \n return y ; \n }", "idx": 14645}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct512 ( AC3MDCTContext * mdct , int32_t * out , int16_t * in ) \n { \n int i , re , im , n , n2 , n4 ; \n int16_t * rot = mdct -> rot_tmp ; \n IComplex * x = mdct -> cplx_tmp ; \n n = 1 << mdct -> nbits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n for ( i = 0 ; i < n4 ; i ++ ) \n rot [ i ] = - in [ i + 3 * n4 ] ; \n memcpy ( & rot [ n4 ] , & in [ 0 ] , 3 * n4 * sizeof ( * in ) ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n re = ( ( int ) rot [ 2 * i ] - ( int ) rot [ n - 1 - 2 * i ] ) >> 1 ; \n im = - ( ( int ) rot [ n2 + 2 * i ] - ( int ) rot [ n2 - 1 - 2 * i ] ) >> 1 ; \n CMUL ( x [ i ] . re , x [ i ] . im , re , im , - mdct -> xcos1 [ i ] , mdct -> xsin1 [ i ] , 15 ) ; \n } \n fft ( mdct , x , mdct -> nbits - 2 ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n re = x [ i ] . re ; \n im = x [ i ] . im ; \n CMUL ( out [ n2 - 1 - 2 * i ] , out [ 2 * i ] , re , im , mdct -> xsin1 [ i ] , mdct -> xcos1 [ i ] , 0 ) ; \n } \n }", "idx": 14646}
{"project": "FFmpeg", "commit_id": "3cff53369acdb3bc0695dd6d5df51457fdaa16ce", "target": 1, "func": "int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , \n const uint8_t * name , uint8_t * dst , int dst_size ) \n { \n int namelen = strlen ( name ) ; \n int len ; \n while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { \n len = ff_amf_tag_size ( data , data_end ) ; \n if ( len < 0 ) \n len = data_end - data ; \n data += len ; \n } \n if ( data_end - data < 3 ) \n return -1 ; \n data ++ ; \n for ( ; ; ) { \n int size = bytestream_get_be16 ( & data ) ; \n if ( ! size ) \n break ; \n if ( data + size >= data_end || data + size < data ) \n return -1 ; \n data += size ; \n if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { \n switch ( * data ++ ) { \n case AMF_DATA_TYPE_NUMBER : \n snprintf ( dst , dst_size , \" \" , av_int2double ( AV_RB64 ( data ) ) ) ; \n break ; \n case AMF_DATA_TYPE_BOOL : \n snprintf ( dst , dst_size , \" \" , * data ? \" \" : \" \" ) ; \n break ; \n case AMF_DATA_TYPE_STRING : \n len = bytestream_get_be16 ( & data ) ; \n av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; \n break ; \n default : \n return -1 ; \n } \n return 0 ; \n } \n len = ff_amf_tag_size ( data , data_end ) ; \n if ( len < 0 || data + len >= data_end || data + len < data ) \n return -1 ; \n data += len ; \n } \n return -1 ; \n }", "idx": 14650}
{"project": "FFmpeg", "commit_id": "82a1d575757d5bc9b0b218fe89c77f8de06a7d39", "target": 1, "func": "static int fraps2_decode_plane ( FrapsContext * s , uint8_t * dst , int stride , int w , \n int h , const uint8_t * src , int size , int Uoff , \n const int step ) \n { \n int i , j ; \n GetBitContext gb ; \n VLC vlc ; \n Node nodes [ 512 ] ; \n for ( i = 0 ; i < 256 ; i ++ ) \n nodes [ i ] . count = bytestream_get_le32 ( & src ) ; \n size -= 1024 ; \n if ( ff_huff_build_tree ( s -> avctx , & vlc , 256 , nodes , huff_cmp , \n FF_HUFFMAN_FLAG_ZERO_COUNT ) < 0 ) \n return -1 ; \n s -> dsp . bswap_buf ( ( uint32_t * ) s -> tmpbuf , ( const uint32_t * ) src , size >> 2 ) ; \n init_get_bits ( & gb , s -> tmpbuf , size * 8 ) ; \n for ( j = 0 ; j < h ; j ++ ) { \n for ( i = 0 ; i < w * step ; i += step ) { \n dst [ i ] = get_vlc2 ( & gb , vlc . table , 9 , 3 ) ; \n if ( j ) dst [ i ] += dst [ i - stride ] ; \n else if ( Uoff ) dst [ i ] += 0x80 ; \n } \n dst += stride ; \n if ( get_bits_left ( & gb ) < 0 ) { \n free_vlc ( & vlc ) ; \n return -1 ; \n } \n } \n free_vlc ( & vlc ) ; \n return 0 ; \n }", "idx": 14656}
{"project": "FFmpeg", "commit_id": "72dafea0fc0eb7230d7ebb0a7bc803e13b72aaad", "target": 1, "func": "yuv2gray16_X_c_template ( SwsContext * c , const int16_t * lumFilter , \n const int32_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int32_t * * chrUSrc , \n const int32_t * * chrVSrc , int chrFilterSize , \n const int32_t * * alpSrc , uint16_t * dest , int dstW , \n int y , enum PixelFormat target )  \n { \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int j ; \n int Y1 = 1 << 14 ; \n int Y2 = 1 << 14 ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) { \n Y1 += lumSrc [ j ] [ i * 2 ] * lumFilter [ j ] ; \n Y2 += lumSrc [ j ] [ i * 2 + 1 ] * lumFilter [ j ] ; \n } \n Y1 >>= 15 ; \n Y2 >>= 15 ; \n if ( ( Y1 | Y2 ) & 0x10000 ) { \n Y1 = av_clip_uint16 ( Y1 ) ; \n Y2 = av_clip_uint16 ( Y2 ) ; \n } \n output_pixel ( & dest [ i * 2 + 0 ] , Y1 ) ; \n output_pixel ( & dest [ i * 2 + 1 ] , Y2 ) ; \n } \n }", "idx": 14659}
{"project": "FFmpeg", "commit_id": "72f9a6349cae0eba7caf9e338bee46c1d9baed27", "target": 1, "func": "static int cmp ( const void * key , const void * node ) \n { \n return ( * ( const int64_t * ) key ) - ( ( const CacheEntry * ) node ) -> logical_pos ; \n }", "idx": 14662}
{"project": "FFmpeg", "commit_id": "d872643cfe07e39fee42c846d5a3f57d5cad6ab6", "target": 1, "func": "static void compute_chapters_end ( AVFormatContext * s ) \n { \n unsigned int i , j ; \n int64_t max_time = s -> duration + \n ( ( s -> start_time == AV_NOPTS_VALUE ) ? 0 : s -> start_time ) ; \n for ( i = 0 ; i < s -> nb_chapters ; i ++ ) \n if ( s -> chapters [ i ] -> end == AV_NOPTS_VALUE ) { \n AVChapter * ch = s -> chapters [ i ] ; \n int64_t end = max_time ? av_rescale_q ( max_time , AV_TIME_BASE_Q , \n ch -> time_base ) \n : INT64_MAX ; \n for ( j = 0 ; j < s -> nb_chapters ; j ++ ) { \n AVChapter * ch1 = s -> chapters [ j ] ; \n int64_t next_start = av_rescale_q ( ch1 -> start , ch1 -> time_base , \n ch -> time_base ) ; \n if ( j != i && next_start > ch -> start && next_start < end ) \n end = next_start ; \n } \n ch -> end = ( end == INT64_MAX ) ? ch -> start : end ; \n } \n }", "idx": 14664}
{"project": "FFmpeg", "commit_id": "e248522d1b0d6dd8641f382cd5c4338d0ecd98e5", "target": 1, "func": "static int decode_styl ( const uint8_t * tsmb , MovTextContext * m , AVPacket * avpkt ) \n { \n int i ; \n m -> style_entries = AV_RB16 ( tsmb ) ; \n tsmb += 2 ; \n if ( m -> tracksize + m -> size_var + 2 + m -> style_entries * 12 > avpkt -> size ) \n return -1 ; \n m -> box_flags |= STYL_BOX ; \n for ( i = 0 ; i < m -> style_entries ; i ++ ) { \n m -> s_temp = av_malloc ( sizeof ( * m -> s_temp ) ) ; \n if ( ! m -> s_temp ) { \n mov_text_cleanup ( m ) ; \n return AVERROR ( ENOMEM ) ; \n } \n m -> s_temp -> style_start = AV_RB16 ( tsmb ) ; \n tsmb += 2 ; \n m -> s_temp -> style_end = AV_RB16 ( tsmb ) ; \n tsmb += 2 ; \n m -> s_temp -> style_fontID = AV_RB16 ( tsmb ) ; \n tsmb += 2 ; \n m -> s_temp -> style_flag = AV_RB8 ( tsmb ) ; \n tsmb ++ ; \n m -> s_temp -> fontsize = AV_RB8 ( tsmb ) ; \n av_dynarray_add ( & m -> s , & m -> count_s , m -> s_temp ) ; \n if ( ! m -> s ) { \n mov_text_cleanup ( m ) ; \n return AVERROR ( ENOMEM ) ; \n } \n tsmb ++ ; \n tsmb += 4 ; \n } \n return 0 ; \n }", "idx": 14681}
{"project": "FFmpeg", "commit_id": "dbe94539469b6d5113b37ea45eaf69ddbe34154e", "target": 0, "func": "static void opt_pass ( const char * pass_str ) \n { \n int pass ; \n pass = atoi ( pass_str ) ; \n if ( pass != 1 && pass != 2 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n do_pass = pass ; \n }", "idx": 14682}
{"project": "FFmpeg", "commit_id": "88d1e2b2b0a129365a62efd666db0394e8ffbe08", "target": 1, "func": "float av_int2flt ( int32_t v ) { \n if ( v + v > 0xFF000000U ) \n return NAN ; \n return ldexp ( ( ( v & 0x7FFFFF ) + ( 1 << 23 ) ) * ( v >> 31 | 1 ) , ( v >> 23 & 0xFF ) - 150 ) ; \n }", "idx": 14683}
{"project": "FFmpeg", "commit_id": "4257b804e2354db07e66ebfd966d7d13f49c7895", "target": 0, "func": "static int opt_deinterlace ( void * optctx , const char * opt , const char * arg ) \n { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , opt ) ; \n do_deinterlace = 1 ; \n return 0 ; \n }", "idx": 14684}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_get_schro_frame_format ( SchroChromaFormat schro_pix_fmt , \n SchroFrameFormat * schro_frame_fmt ) \n { \n unsigned int num_formats = sizeof ( schro_pixel_format_map ) / \n sizeof ( schro_pixel_format_map [ 0 ] ) ; \n int idx ; \n for ( idx = 0 ; idx < num_formats ; ++ idx ) { \n if ( schro_pixel_format_map [ idx ] . schro_pix_fmt == schro_pix_fmt ) { \n * schro_frame_fmt = schro_pixel_format_map [ idx ] . schro_frame_fmt ; \n return 0 ; \n } \n } \n return -1 ; \n }", "idx": 14685}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static int read_mv_component ( VP56RangeCoder * c , const uint8_t * p ) \n { \n int bit , x = 0 ; \n if ( vp56_rac_get_prob_branchy ( c , p [ 0 ] ) ) { \n int i ; \n for ( i = 0 ; i < 3 ; i ++ ) \n x += vp56_rac_get_prob ( c , p [ 9 + i ] ) << i ; \n for ( i = 9 ; i > 3 ; i -- ) \n x += vp56_rac_get_prob ( c , p [ 9 + i ] ) << i ; \n if ( ! ( x & 0xFFF0 ) || vp56_rac_get_prob ( c , p [ 12 ] ) ) \n x += 8 ; \n } else { \n const uint8_t * ps = p + 2 ; \n bit = vp56_rac_get_prob ( c , * ps ) ; \n ps += 1 + 3 * bit ; \n x += 4 * bit ; \n bit = vp56_rac_get_prob ( c , * ps ) ; \n ps += 1 + bit ; \n x += 2 * bit ; \n x += vp56_rac_get_prob ( c , * ps ) ; \n } \n return ( x && vp56_rac_get_prob ( c , p [ 1 ] ) ) ? - x : x ; \n }", "idx": 14686}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static int swf_write_packet ( AVFormatContext * s , int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n AVCodecContext * codec = & s -> streams [ stream_index ] -> codec ; \n if ( codec -> codec_type == CODEC_TYPE_AUDIO ) \n return swf_write_audio ( s , buf , size ) ; \n else \n return swf_write_video ( s , codec , buf , size ) ; \n }", "idx": 14691}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale16To15_c ( SwsContext * c , int16_t * dst , int dstW , const uint8_t * _src , \n const int16_t * filter , \n const int16_t * filterPos , int filterSize ) \n { \n int i ; \n const uint16_t * src = ( const uint16_t * ) _src ; \n int sh = av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += src [ srcPos + j ] * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> sh , ( 1 << 15 ) - 1 ) ; \n } \n }", "idx": 14692}
{"project": "FFmpeg", "commit_id": "dd44d9e316c17f473eff9f4a5a94ad0d7adb157e", "target": 1, "func": "static int decode_extradata ( ADTSContext * adts , uint8_t * buf , int size ) \n { \n GetBitContext gb ; \n init_get_bits ( & gb , buf , size * 8 ) ; \n adts -> objecttype = get_bits ( & gb , 5 ) - 1 ; \n adts -> sample_rate_index = get_bits ( & gb , 4 ) ; \n adts -> channel_conf = get_bits ( & gb , 4 ) ; \n adts -> write_adts = 1 ; \n return 0 ; \n }", "idx": 14695}
{"project": "FFmpeg", "commit_id": "cd8e5f9637b42f0caafbb0ab470e3f133cb5f200", "target": 1, "func": "static void add_pixels_clamped_mmx ( const DCTELEM * block , UINT8 * pixels , int line_size ) \n { \n const DCTELEM * p ; \n UINT8 * pix ; \n int i ; \n p = block ; \n pix = pixels ; \n MOVQ_ZERO ( mm7 ) ; \n i = 4 ; \n while ( i ) { \n __asm __volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + m \" \" + m \" \n : \" m \" \n : \" memory \" \n pix += line_size * 2 ; \n p += 16 ; \n i -- ; \n } ; \n }", "idx": 14699}
{"project": "FFmpeg", "commit_id": "cbd622be997e8307a409efc3b4bbe8765147def2", "target": 1, "func": "static void decode_scaling_list ( GetBitContext * gb , uint8_t * factors , int size , \n const uint8_t * jvt_list , \n const uint8_t * fallback_list ) \n { \n int i , last = 8 , next = 8 ; \n const uint8_t * scan = size == 16 ? ff_zigzag_scan : ff_zigzag_direct ; \n if ( ! get_bits1 ( gb ) ) \n memcpy ( factors , fallback_list , size * sizeof ( uint8_t ) ) ; \n else \n for ( i = 0 ; i < size ; i ++ ) { \n if ( next ) \n next = ( last + get_se_golomb ( gb ) ) & 0xff ; \n if ( ! i && ! next ) { \n memcpy ( factors , jvt_list , size * sizeof ( uint8_t ) ) ; \n break ; \n } \n last = factors [ scan [ i ] ] = next ? next : last ; \n } \n }", "idx": 14701}
{"project": "FFmpeg", "commit_id": "b3928a1cc65462a72fea538fcf082cbc8f373e37", "target": 0, "func": "int swri_realloc_audio ( AudioData * a , int count ) { \n int i , countb ; \n AudioData old ; \n if ( count < 0 || count > INT_MAX / 2 / a -> bps / a -> ch_count ) \n return AVERROR ( EINVAL ) ; \n if ( a -> count >= count ) \n return 0 ; \n count *= 2 ; \n countb = FFALIGN ( count * a -> bps , ALIGN ) ; \n old = * a ; \n av_assert0 ( a -> bps ) ; \n av_assert0 ( a -> ch_count ) ; \n a -> data = av_mallocz_array ( countb , a -> ch_count ) ; \n if ( ! a -> data ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < a -> ch_count ; i ++ ) { \n a -> ch [ i ] = a -> data + i * ( a -> planar ? countb : a -> bps ) ; \n if ( a -> planar ) memcpy ( a -> ch [ i ] , old . ch [ i ] , a -> count * a -> bps ) ; \n } \n if ( ! a -> planar ) memcpy ( a -> ch [ 0 ] , old . ch [ 0 ] , a -> count * a -> ch_count * a -> bps ) ; \n av_freep ( & old . data ) ; \n a -> count = count ; \n return 1 ; \n }", "idx": 14711}
{"project": "FFmpeg", "commit_id": "919f3554387e043bdfe10c6369356d1104882183", "target": 1, "func": "void ff_decode_dxt3 ( const uint8_t * s , uint8_t * dst , \n const unsigned int w , const unsigned int h , \n const unsigned int stride ) { \n unsigned int bx , by , qstride = stride / 4 ; \n uint32_t * d = ( uint32_t * ) dst ; \n for ( by = 0 ; by < h / 4 ; by ++ , d += stride - w ) \n for ( bx = 0 ; bx < w / 4 ; bx ++ , s += 16 , d += 4 ) \n dxt1_decode_pixels ( s + 8 , d , qstride , 1 , AV_RL64 ( s ) ) ; \n }", "idx": 14744}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static enum AVPixelFormat get_format ( AVCodecContext * s , const enum AVPixelFormat * pix_fmts ) \n { \n InputStream * ist = s -> opaque ; \n const enum AVPixelFormat * p ; \n int ret ; \n for ( p = pix_fmts ; * p != -1 ; p ++ ) { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( * p ) ; \n const HWAccel * hwaccel ; \n if ( ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) \n break ; \n hwaccel = get_hwaccel ( * p , ist -> hwaccel_id ) ; \n if ( ! hwaccel || \n ( ist -> active_hwaccel_id && ist -> active_hwaccel_id != hwaccel -> id ) || \n ( ist -> hwaccel_id != HWACCEL_AUTO && ist -> hwaccel_id != hwaccel -> id ) ) \n continue ; \n ret = hwaccel -> init ( s ) ; \n if ( ret < 0 ) { \n if ( ist -> hwaccel_id == hwaccel -> id ) { \n av_log ( NULL , AV_LOG_FATAL , \n \" \" \n \" \\n \" , hwaccel -> name , \n ist -> file_index , ist -> st -> index ) ; \n return AV_PIX_FMT_NONE ; \n } \n continue ; \n } \n if ( ist -> hw_frames_ctx ) { \n s -> hw_frames_ctx = av_buffer_ref ( ist -> hw_frames_ctx ) ; \n if ( ! s -> hw_frames_ctx ) \n return AV_PIX_FMT_NONE ; \n } \n ist -> active_hwaccel_id = hwaccel -> id ; \n ist -> hwaccel_pix_fmt = * p ; \n break ; \n } \n return * p ; \n }", "idx": 14749}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static void uninit ( struct vf_instance * vf ) \n { \n free ( vf -> priv ) ; \n }", "idx": 14752}
{"project": "FFmpeg", "commit_id": "991ef6e5b9a6a9d95e274ff6bff52db1c82b3808", "target": 1, "func": "static int decode_nal_sei_message ( GetBitContext * gb , void * logctx , HEVCSEI * s , \n const HEVCParamSets * ps , int nal_unit_type ) \n { \n int payload_type = 0 ; \n int payload_size = 0 ; \n int byte = 0xFF ; \n av_log ( logctx , AV_LOG_DEBUG , \" \\n \" ) ; \n while ( byte == 0xFF ) { \n byte = get_bits ( gb , 8 ) ; \n payload_type += byte ; \n } \n byte = 0xFF ; \n while ( byte == 0xFF ) { \n byte = get_bits ( gb , 8 ) ; \n payload_size += byte ; \n } \n if ( nal_unit_type == HEVC_NAL_SEI_PREFIX ) { \n return decode_nal_sei_prefix ( gb , logctx , s , ps , payload_type , payload_size ) ; \n } else { \n return decode_nal_sei_suffix ( gb , logctx , s , payload_type , payload_size ) ; \n } \n }", "idx": 14759}
{"project": "FFmpeg", "commit_id": "b46b233baffc2076a1a17a264ba9553ae0d4878f", "target": 1, "func": "static int read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n FilmstripDemuxContext * film = s -> priv_data ; \n AVStream * st = s -> streams [ 0 ] ; \n if ( s -> pb -> eof_reached ) \n return AVERROR ( EIO ) ; \n pkt -> dts = avio_tell ( s -> pb ) / ( st -> codec -> width * ( st -> codec -> height + film -> leading ) * 4 ) ; \n pkt -> size = av_get_packet ( s -> pb , pkt , st -> codec -> width * st -> codec -> height * 4 ) ; \n avio_skip ( s -> pb , st -> codec -> width * film -> leading * 4 ) ; \n if ( pkt -> size < 0 ) \n return pkt -> size ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n return 0 ; \n }", "idx": 14762}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_parse_next_image ( GifState * s ) \n { \n ByteIOContext * f = s -> f ; \n int ret , code ; \n for ( ; ; ) { \n code = url_fgetc ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , code , code ) ; \n #endif \n switch ( code ) { \n case ' ' : \n if ( gif_read_image ( s ) < 0 ) \n return AVERROR ( EIO ) ; \n ret = 0 ; \n goto the_end ; \n case ' ' : \n ret = AVERROR ( EIO ) ; \n goto the_end ; \n case ' ' : \n if ( gif_read_extension ( s ) < 0 ) \n return AVERROR ( EIO ) ; \n break ; \n case EOF : \n default : \n ret = AVERROR ( EIO ) ; \n goto the_end ; \n } \n } \n the_end : \n return ret ; \n }", "idx": 14766}
{"project": "FFmpeg", "commit_id": "507dce2536fea4b78a9f4973f77e1fa20cfe1b81", "target": 0, "func": "av_cold void ff_rv34dsp_init ( RV34DSPContext * c , DSPContext * dsp ) { \n c -> rv34_inv_transform = rv34_inv_transform_noround_c ; \n c -> rv34_inv_transform_dc = rv34_inv_transform_dc_noround_c ; \n c -> rv34_idct_add = rv34_idct_add_c ; \n c -> rv34_idct_dc_add = rv34_idct_dc_add_c ; \n if ( HAVE_NEON ) \n ff_rv34dsp_init_neon ( c , dsp ) ; \n if ( ARCH_X86 ) \n ff_rv34dsp_init_x86 ( c , dsp ) ; \n }", "idx": 14780}
{"project": "FFmpeg", "commit_id": "1c169782cae6c5c430ff62e7d7272dc9d0e8d527", "target": 0, "func": "static void print_sdp ( void ) \n { \n char sdp [ 16384 ] ; \n int i ; \n AVFormatContext * * avc = av_malloc ( sizeof ( * avc ) * nb_output_files ) ; \n if ( ! avc ) \n exit_program ( 1 ) ; \n for ( i = 0 ; i < nb_output_files ; i ++ ) \n avc [ i ] = output_files [ i ] -> ctx ; \n av_sdp_create ( avc , nb_output_files , sdp , sizeof ( sdp ) ) ; \n printf ( \" \\n \\n \" , sdp ) ; \n fflush ( stdout ) ; \n av_freep ( & avc ) ; \n }", "idx": 14802}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static void decode_colskip ( uint8_t * plane , int width , int height , int stride , VC9Context * v ) { \n int x , y ; \n GetBitContext * gb = & v -> s . gb ; \n for ( x = 0 ; x < width ; x ++ ) { \n if ( ! get_bits ( gb , 1 ) ) \n for ( y = 0 ; y < height ; y ++ ) \n plane [ y * stride ] = 0 ; \n else \n for ( y = 0 ; y < height ; y ++ ) \n plane [ y * stride ] = get_bits ( gb , 1 ) ; \n plane ++ ; \n } \n }", "idx": 14820}
{"project": "FFmpeg", "commit_id": "5a446bc88e49cc6400d0c646ca1eb540a727c9de", "target": 1, "func": "static void vc1_h_overlap_c ( uint8_t * src , int stride ) \n { \n int i ; \n int a , b , c , d ; \n int d1 , d2 ; \n int rnd = 1 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n a = src [ -2 ] ; \n b = src [ -1 ] ; \n c = src [ 0 ] ; \n d = src [ 1 ] ; \n d1 = ( a - d + 3 + rnd ) >> 3 ; \n d2 = ( a - d + b - c + 4 - rnd ) >> 3 ; \n src [ -2 ] = a - d1 ; \n src [ -1 ] = b - d2 ; \n src [ 0 ] = c + d2 ; \n src [ 1 ] = d + d1 ; \n src += stride ; \n rnd = ! rnd ; \n } \n }", "idx": 14826}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int targa_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 14837}
{"project": "FFmpeg", "commit_id": "e3751aa6ec8147ab7ca2649d4daadf8d4dce27d5", "target": 0, "func": "static void backward_filter ( RA288Context * ractx ) \n { \n float temp1 [ 37 ] ; \n float temp2 [ 11 ] ; \n do_hybrid_window ( 36 , 40 , 35 , ractx -> sp_block , temp1 , ractx -> sp_hist , \n ractx -> sp_rec , syn_window ) ; \n if ( ! eval_lpc_coeffs ( temp1 , ractx -> sp_lpc , 36 ) ) \n colmult ( ractx -> sp_lpc , ractx -> sp_lpc , syn_bw_tab , 36 ) ; \n do_hybrid_window ( 10 , 8 , 20 , ractx -> gain_block , temp2 , ractx -> gain_hist , \n ractx -> gain_rec , gain_window ) ; \n if ( ! eval_lpc_coeffs ( temp2 , ractx -> gain_lpc , 10 ) ) \n colmult ( ractx -> gain_lpc , ractx -> gain_lpc , gain_bw_tab , 10 ) ; \n }", "idx": 14859}
{"project": "FFmpeg", "commit_id": "190f6135b48a97dadd7586f154640bec6468df1b", "target": 0, "func": "static int dshow_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n struct dshow_ctx * ctx = s -> priv_data ; \n AVPacketList * pktl = NULL ; \n while ( ! pktl ) { \n WaitForSingleObject ( ctx -> mutex , INFINITE ) ; \n pktl = ctx -> pktl ; \n if ( pktl ) { \n * pkt = pktl -> pkt ; \n ctx -> pktl = ctx -> pktl -> next ; \n av_free ( pktl ) ; \n ctx -> curbufsize -= pkt -> size ; \n } \n ResetEvent ( ctx -> event ) ; \n ReleaseMutex ( ctx -> mutex ) ; \n if ( ! pktl ) { \n if ( s -> flags & AVFMT_FLAG_NONBLOCK ) { \n return AVERROR ( EAGAIN ) ; \n } else { \n WaitForSingleObject ( ctx -> event , INFINITE ) ; \n } \n } \n } \n return pkt -> size ; \n }", "idx": 14868}
{"project": "FFmpeg", "commit_id": "6e0d8c06c7af61859e8d7bc2351a607d8abeab75", "target": 0, "func": "static void opt_mb_qmax ( const char * arg ) \n { \n video_mb_qmax = atoi ( arg ) ; \n if ( video_mb_qmax < 0 || \n video_mb_qmax > 31 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 14873}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "static av_noinline void emulated_edge_mc_mmxext ( uint8_t * buf , const uint8_t * src , \n ptrdiff_t buf_stride , \n ptrdiff_t src_stride , \n int block_w , int block_h , \n int src_x , int src_y , int w , int h ) \n { \n emulated_edge_mc ( buf , src , buf_stride , src_stride , block_w , block_h , \n src_x , src_y , w , h , vfixtbl_mmx , & ff_emu_edge_vvar_mmx , \n hfixtbl_mmxext , & ff_emu_edge_hvar_mmxext ) ; \n }", "idx": 14924}
{"project": "FFmpeg", "commit_id": "e644db613a8fe008c996ca642800f8ccd90e613f", "target": 1, "func": "static av_cold int xvid_encode_close ( AVCodecContext * avctx ) { \n struct xvid_context * x = avctx -> priv_data ; \n xvid_encore ( x -> encoder_handle , XVID_ENC_DESTROY , NULL , NULL ) ; \n if ( avctx -> extradata != NULL ) \n av_free ( avctx -> extradata ) ; \n if ( x -> twopassbuffer != NULL ) { \n av_free ( x -> twopassbuffer ) ; \n av_free ( x -> old_twopassbuffer ) ; \n } \n if ( x -> twopassfile != NULL ) \n av_free ( x -> twopassfile ) ; \n if ( x -> intra_matrix != NULL ) \n av_free ( x -> intra_matrix ) ; \n if ( x -> inter_matrix != NULL ) \n av_free ( x -> inter_matrix ) ; \n return 0 ; \n }", "idx": 14946}
{"project": "FFmpeg", "commit_id": "7f8027b76f1bdce7452d02513fc179cca20d8867", "target": 0, "func": "unsigned long av_adler32_update ( unsigned long adler , const uint8_t * buf , \n unsigned int len ) \n { \n unsigned long s1 = adler & 0xffff ; \n unsigned long s2 = adler >> 16 ; \n while ( len > 0 ) { \n #if CONFIG_SMALL  \n  \n  while ( len > 4 && s2 < ( 1U << 31 ) ) { \n DO4 ( buf ) ; \n len -= 4 ; \n } \n #else \n while ( len > 16 && s2 < ( 1U << 31 ) ) { \n DO16 ( buf ) ; \n len -= 16 ; \n } \n #endif \n DO1 ( buf ) ; len -- ; \n s1 %= BASE ; \n s2 %= BASE ; \n } \n return ( s2 << 16 ) | s1 ; \n }", "idx": 14949}
{"project": "FFmpeg", "commit_id": "a503afb11f80facc0fa12b733c5c58989950b108", "target": 0, "func": "static int mpc_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n MPCContext * c = s -> priv_data ; \n AVPacket pkt1 , * pkt = & pkt1 ; \n int ret ; \n int index = av_index_search_timestamp ( st , timestamp - DELAY_FRAMES , flags ) ; \n uint32_t lastframe ; \n if ( index >= 0 ) { \n c -> curframe = st -> index_entries [ index ] . pos ; \n return 0 ; \n } \n if ( timestamp < 0 || timestamp >= c -> fcount ) \n return -1 ; \n timestamp -= DELAY_FRAMES ; \n lastframe = c -> curframe ; \n if ( c -> frames_noted ) c -> curframe = c -> frames_noted - 1 ; \n while ( c -> curframe < timestamp ) { \n ret = av_read_frame ( s , pkt ) ; \n if ( ret < 0 ) { \n c -> curframe = lastframe ; \n return ret ; \n } \n av_free_packet ( pkt ) ; \n } \n return 0 ; \n }", "idx": 14950}
{"project": "FFmpeg", "commit_id": "fb93e61e2b7baa44ff991bc0ce96291490a0188e", "target": 0, "func": "av_cold void ff_gradfun_init_x86 ( GradFunContext * gf ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( HAVE_MMX2 && cpu_flags & AV_CPU_FLAG_MMX2 ) \n gf -> filter_line = gradfun_filter_line_mmx2 ; \n if ( HAVE_SSSE3 && cpu_flags & AV_CPU_FLAG_SSSE3 ) \n gf -> filter_line = gradfun_filter_line_ssse3 ; \n if ( HAVE_SSE && cpu_flags & AV_CPU_FLAG_SSE2 ) \n gf -> blur_line = gradfun_blur_line_sse2 ; \n }", "idx": 14952}
{"project": "FFmpeg", "commit_id": "9835abb6d63fb07613994ae90e72fef758149408", "target": 0, "func": "int ff_listen_bind ( int fd , const struct sockaddr * addr , \n socklen_t addrlen , int timeout ) \n { \n int ret ; \n int reuse = 1 ; \n struct pollfd lp = { fd , POLLIN , 0 } ; \n setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & reuse , sizeof ( reuse ) ) ; \n ret = bind ( fd , addr , addrlen ) ; \n if ( ret ) \n return ff_neterrno ( ) ; \n ret = listen ( fd , 1 ) ; \n if ( ret ) \n return ff_neterrno ( ) ; \n ret = poll ( & lp , 1 , timeout >= 0 ? timeout : -1 ) ; \n if ( ret <= 0 ) \n return AVERROR ( ETIMEDOUT ) ; \n ret = accept ( fd , NULL , NULL ) ; \n if ( ret < 0 ) \n return ff_neterrno ( ) ; \n closesocket ( fd ) ; \n ff_socket_nonblock ( ret , 1 ) ; \n return ret ; \n }", "idx": 14974}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static inline void writer_print_string ( WriterContext * wctx , \n const char * key , const char * val , int opt ) \n { \n const struct section * section = wctx -> section [ wctx -> level ] ; \n if ( opt && ! ( wctx -> writer -> flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS ) ) \n return ; \n if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { \n wctx -> writer -> print_string ( wctx , key , val ) ; \n wctx -> nb_item [ wctx -> level ] ++ ; \n } \n }", "idx": 15006}
{"project": "FFmpeg", "commit_id": "8c5ee45d13b7a0d14ff75b7db72d5400b7750571", "target": 0, "func": "static int verify_expr ( AVExpr * e ) \n { \n if ( ! e ) return 0 ; \n switch ( e -> type ) { \n case e_value : \n case e_const : return 1 ; \n case e_func0 : \n case e_func1 : \n case e_squish : \n case e_ld : \n case e_gauss : \n case e_isnan : \n case e_floor : \n case e_ceil : \n case e_trunc : \n case e_sqrt : \n case e_not : \n case e_random : \n return verify_expr ( e -> param [ 0 ] ) && ! e -> param [ 2 ] ; \n case e_taylor : \n return verify_expr ( e -> param [ 0 ] ) && verify_expr ( e -> param [ 1 ] ) \n && ( ! e -> param [ 2 ] || verify_expr ( e -> param [ 2 ] ) ) ; \n default : return verify_expr ( e -> param [ 0 ] ) && verify_expr ( e -> param [ 1 ] ) && ! e -> param [ 2 ] ; \n } \n }", "idx": 15007}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel4_mc10_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_4w_msa ( src - 2 , stride , dst , stride , 4 , 0 ) ; \n }", "idx": 15008}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_stco ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n if ( entries >= UINT_MAX / sizeof ( int64_t ) ) \n return -1 ; \n sc -> chunk_offsets = av_malloc ( entries * sizeof ( int64_t ) ) ; \n if ( ! sc -> chunk_offsets ) \n return AVERROR ( ENOMEM ) ; \n sc -> chunk_count = entries ; \n if ( atom . type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n for ( i = 0 ; i < entries ; i ++ ) \n sc -> chunk_offsets [ i ] = get_be32 ( pb ) ; \n else if ( atom . type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n for ( i = 0 ; i < entries ; i ++ ) \n sc -> chunk_offsets [ i ] = get_be64 ( pb ) ; \n else \n return -1 ; \n return 0 ; \n }", "idx": 15009}
{"project": "FFmpeg", "commit_id": "33ae681f5ca9fa9aae82081dd6a6edbe2509f983", "target": 0, "func": "void ff_acelp_lspd2lpc ( const double * lsp , float * lpc ) \n { \n double pa [ 6 ] , qa [ 6 ] ; \n int i ; \n lsp2polyf ( lsp , pa , 5 ) ; \n lsp2polyf ( lsp + 1 , qa , 5 ) ; \n for ( i = 4 ; i >= 0 ; i -- ) \n { \n double paf = pa [ i + 1 ] + pa [ i ] ; \n double qaf = qa [ i + 1 ] - qa [ i ] ; \n lpc [ i ] = 0.5 * ( paf + qaf ) ; \n lpc [ 9 - i ] = 0.5 * ( paf - qaf ) ; \n } \n }", "idx": 15010}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_8w_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 8 ) ; \n }", "idx": 15011}
{"project": "FFmpeg", "commit_id": "210461c0a83a5625560fa1d92229200dc7fb869b", "target": 0, "func": "static void deinterlace_bottom_field_inplace ( uint8_t * src1 , int src_wrap , \n int width , int height ) \n { \n uint8_t * src_m1 , * src_0 , * src_p1 , * src_p2 ; \n int y ; \n uint8_t * buf ; \n buf = av_malloc ( width ) ; \n src_m1 = src1 ; \n memcpy ( buf , src_m1 , width ) ; \n src_0 = & src_m1 [ src_wrap ] ; \n src_p1 = & src_0 [ src_wrap ] ; \n src_p2 = & src_p1 [ src_wrap ] ; \n for ( y = 0 ; y < ( height - 2 ) ; y += 2 ) { \n deinterlace_line_inplace ( buf , src_m1 , src_0 , src_p1 , src_p2 , width ) ; \n src_m1 = src_p1 ; \n src_0 = src_p2 ; \n src_p1 += 2 * src_wrap ; \n src_p2 += 2 * src_wrap ; \n } \n deinterlace_line_inplace ( buf , src_m1 , src_0 , src_0 , src_0 , width ) ; \n av_free ( buf ) ; \n }", "idx": 15033}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_1r_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 512 ] ) ; \n samples [ i + 256 ] = samples [ i + 512 ] = 0 ; \n } \n }", "idx": 15043}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static int add_shorts_metadata ( int count , const char * name , \n const char * sep , TiffContext * s ) \n { \n char * ap ; \n int i ; \n int16_t * sp ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int16_t ) ) \n return -1 ; \n sp = av_malloc ( count * sizeof ( int16_t ) ) ; \n if ( ! sp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n sp [ i ] = tget_short ( & s -> gb , s -> le ) ; \n ap = shorts2str ( sp , count , sep ) ; \n av_freep ( & sp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( & s -> picture . metadata , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 15045}
{"project": "FFmpeg", "commit_id": "2928b83c7581ef3d66108684a2e6f07f5d049b50", "target": 0, "func": "int av_open_input_file ( AVFormatContext * * ic_ptr , const char * filename , \n AVInputFormat * fmt , \n int buf_size , \n AVFormatParameters * ap ) \n { \n int err ; \n AVProbeData probe_data , * pd = & probe_data ; \n ByteIOContext * pb = NULL ; \n void * logctx = ap && ap -> prealloced_context ? * ic_ptr : NULL ; \n pd -> filename = \" \" ; \n if ( filename ) \n pd -> filename = filename ; \n pd -> buf = NULL ; \n pd -> buf_size = 0 ; \n if ( ! fmt ) { \n fmt = av_probe_input_format ( pd , 0 ) ; \n } \n if ( ! fmt || ! ( fmt -> flags & AVFMT_NOFILE ) ) { \n if ( ( err = url_fopen ( & pb , filename , URL_RDONLY ) ) < 0 ) { \n goto fail ; \n } \n if ( buf_size > 0 ) { \n url_setbufsize ( pb , buf_size ) ; \n } \n if ( ( err = ff_probe_input_buffer ( & pb , & fmt , filename , logctx , 0 , 0 ) ) < 0 ) { \n goto fail ; \n } \n } \n if ( ! fmt ) { \n err = AVERROR_NOFMT ; \n goto fail ; \n } \n if ( fmt -> flags & AVFMT_NEEDNUMBER ) { \n if ( ! av_filename_number_test ( filename ) ) { \n err = AVERROR_NUMEXPECTED ; \n goto fail ; \n } \n } \n err = av_open_input_stream ( ic_ptr , pb , filename , fmt , ap ) ; \n if ( err ) \n goto fail ; \n return 0 ; \n fail : \n av_freep ( & pd -> buf ) ; \n if ( pb ) \n url_fclose ( pb ) ; \n if ( ap && ap -> prealloced_context ) \n av_free ( * ic_ptr ) ; \n * ic_ptr = NULL ; \n return err ; \n }", "idx": 15046}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int amr_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 5 ) \n return 0 ; \n if ( memcmp ( p -> buf , AMR_header , 5 ) == 0 ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 15047}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int yuv4_probe ( AVProbeData * pd ) \n { \n if ( pd -> buf_size <= sizeof ( Y4M_MAGIC ) ) \n return 0 ; \n if ( strncmp ( pd -> buf , Y4M_MAGIC , sizeof ( Y4M_MAGIC ) - 1 ) == 0 ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 15049}
{"project": "FFmpeg", "commit_id": "7e10145976866fc6227d3ccc697a7c9fee862a77", "target": 0, "func": "static rwpipe * rwpipe_open ( int argc , char * argv [ ] ) \n { \n rwpipe * this = av_mallocz ( sizeof ( rwpipe ) ) ; \n if ( this != NULL ) \n { \n int input [ 2 ] ; \n int output [ 2 ] ; \n pipe ( input ) ; \n pipe ( output ) ; \n this -> pid = fork ( ) ; \n if ( this -> pid == 0 ) \n { \n #define COMMAND_SIZE  10240  \n  \n  char * command = av_mallocz ( COMMAND_SIZE ) ; \n int i ; \n strcpy ( command , \" \" ) ; \n for ( i = 0 ; i < argc ; i ++ ) \n { \n av_strlcat ( command , argv [ i ] , COMMAND_SIZE ) ; \n av_strlcat ( command , \" \" , COMMAND_SIZE ) ; \n } \n dup2 ( output [ 0 ] , STDIN_FILENO ) ; \n dup2 ( input [ 1 ] , STDOUT_FILENO ) ; \n close ( input [ 0 ] ) ; \n close ( input [ 1 ] ) ; \n close ( output [ 0 ] ) ; \n close ( output [ 1 ] ) ; \n execl ( \" \" , \" \" , \" \" , command , ( char * ) NULL ) ; \n _exit ( 255 ) ; \n } \n else \n { \n close ( input [ 1 ] ) ; \n close ( output [ 0 ] ) ; \n this -> reader = fdopen ( input [ 0 ] , \" \" ) ; \n this -> writer = fdopen ( output [ 1 ] , \" \" ) ; \n } \n } \n return this ; \n }", "idx": 15050}
{"project": "FFmpeg", "commit_id": "e9a26dc5bf66e106dbe3b81b2d59367f7e971e5c", "target": 0, "func": "static int validate_codec_tag ( AVFormatContext * s , AVStream * st ) \n { \n const AVCodecTag * avctag ; \n int n ; \n enum AVCodecID id = AV_CODEC_ID_NONE ; \n unsigned int tag = 0 ; \n for ( n = 0 ; s -> oformat -> codec_tag [ n ] ; n ++ ) { \n avctag = s -> oformat -> codec_tag [ n ] ; \n while ( avctag -> id != AV_CODEC_ID_NONE ) { \n if ( avpriv_toupper4 ( avctag -> tag ) == avpriv_toupper4 ( st -> codec -> codec_tag ) ) { \n id = avctag -> id ; \n if ( id == st -> codec -> codec_id ) \n return 1 ; \n } \n if ( avctag -> id == st -> codec -> codec_id ) \n tag = avctag -> tag ; \n avctag ++ ; \n } \n } \n if ( id != AV_CODEC_ID_NONE ) \n return 0 ; \n if ( tag && ( st -> codec -> strict_std_compliance >= FF_COMPLIANCE_NORMAL ) ) \n return 0 ; \n return 1 ; \n }", "idx": 15052}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2gray16_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n int yalpha1 = 4095 - yalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n const int i2 = 2 * i ; \n int Y1 = ( buf0 [ i2 ] * yalpha1 + buf1 [ i2 ] * yalpha ) >> 11 ; \n int Y2 = ( buf0 [ i2 + 1 ] * yalpha1 + buf1 [ i2 + 1 ] * yalpha ) >> 11 ; \n output_pixel ( & dest [ 2 * i2 + 0 ] , Y1 ) ; \n output_pixel ( & dest [ 2 * i2 + 2 ] , Y2 ) ; \n } \n }", "idx": 15063}
{"project": "FFmpeg", "commit_id": "30df9789a9745d8e4b1afc10d1a983bfc8816eb9", "target": 0, "func": "static void unpack_alpha ( GetBitContext * gb , uint16_t * dst , int num_coeffs , \n const int num_bits ) \n { \n const int mask = ( 1 << num_bits ) - 1 ; \n int i , idx , val , alpha_val ; \n idx = 0 ; \n alpha_val = mask ; \n do { \n do { \n if ( get_bits1 ( gb ) ) \n val = get_bits ( gb , num_bits ) ; \n else { \n int sign ; \n val = get_bits ( gb , num_bits == 16 ? 7 : 4 ) ; \n sign = val & 1 ; \n val = ( val + 2 ) >> 1 ; \n if ( sign ) \n val = - val ; \n } \n alpha_val = ( alpha_val + val ) & mask ; \n if ( num_bits == 16 ) \n dst [ idx ++ ] = alpha_val >> 6 ; \n else \n dst [ idx ++ ] = ( alpha_val << 2 ) | ( alpha_val >> 6 ) ; \n if ( idx == num_coeffs - 1 ) \n break ; \n } while ( get_bits1 ( gb ) ) ; \n val = get_bits ( gb , 4 ) ; \n if ( ! val ) \n val = get_bits ( gb , 11 ) ; \n if ( idx + val > num_coeffs ) \n val = num_coeffs - idx ; \n if ( num_bits == 16 ) \n for ( i = 0 ; i < val ; i ++ ) \n dst [ idx ++ ] = alpha_val >> 6 ; \n else \n for ( i = 0 ; i < val ; i ++ ) \n dst [ idx ++ ] = ( alpha_val << 2 ) | ( alpha_val >> 6 ) ; \n } while ( idx < num_coeffs ) ; \n }", "idx": 15085}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void mdct512 ( AC3MDCTContext * mdct , int32_t * out , int16_t * in ) \n { \n int i , re , im , n , n2 , n4 ; \n int16_t * rot = mdct -> rot_tmp ; \n IComplex * x = mdct -> cplx_tmp ; \n n = 1 << mdct -> nbits ; \n n2 = n >> 1 ; \n n4 = n >> 2 ; \n for ( i = 0 ; i < n4 ; i ++ ) \n rot [ i ] = - in [ i + 3 * n4 ] ; \n memcpy ( & rot [ n4 ] , & in [ 0 ] , 3 * n4 * sizeof ( * in ) ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n re = ( ( int ) rot [ 2 * i ] - ( int ) rot [ n - 1 - 2 * i ] ) >> 1 ; \n im = - ( ( int ) rot [ n2 + 2 * i ] - ( int ) rot [ n2 - 1 - 2 * i ] ) >> 1 ; \n CMUL ( x [ i ] . re , x [ i ] . im , re , im , - mdct -> xcos1 [ i ] , mdct -> xsin1 [ i ] ) ; \n } \n fft ( mdct , x , mdct -> nbits - 2 ) ; \n for ( i = 0 ; i < n4 ; i ++ ) { \n re = x [ i ] . re ; \n im = x [ i ] . im ; \n CMUL ( out [ n2 - 1 - 2 * i ] , out [ 2 * i ] , re , im , mdct -> xsin1 [ i ] , mdct -> xcos1 [ i ] ) ; \n } \n }", "idx": 15093}
{"project": "FFmpeg", "commit_id": "cf04af2086be105ff86088357b83d672d38417d9", "target": 1, "func": "static int get_cod ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n Jpeg2000CodingStyle tmp ; \n int compno , ret ; \n if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) \n tmp . csty = bytestream2_get_byteu ( & s -> g ) ; \n tmp . prog_order = bytestream2_get_byteu ( & s -> g ) ; \n tmp . nlayers = bytestream2_get_be16u ( & s -> g ) ; \n tmp . mct = bytestream2_get_byteu ( & s -> g ) ; \n if ( ( ret = get_cox ( s , & tmp ) ) < 0 ) \n return ret ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) \n if ( ! ( properties [ compno ] & HAD_COC ) ) \n memcpy ( c + compno , & tmp , sizeof ( tmp ) ) ; \n return 0 ; ", "idx": 15096}
{"project": "FFmpeg", "commit_id": "4bf2e7c5f1c0ad3997fd7c9859c16db8e4e16df6", "target": 1, "func": "static av_cold void construct_perm_table ( TwinContext * tctx , enum FrameType ftype ) \n { \n int block_size ; \n const ModeTab * mtab = tctx -> mtab ; \n int size = tctx -> avctx -> channels * mtab -> fmode [ ftype ] . sub ; \n int16_t * tmp_perm = ( int16_t * ) tctx -> tmp_buf ; \n if ( ftype == FT_PPC ) { \n size = tctx -> avctx -> channels ; \n block_size = mtab -> ppc_shape_len ; \n } else \n block_size = mtab -> size / mtab -> fmode [ ftype ] . sub ; \n permutate_in_line ( tmp_perm , tctx -> n_div [ ftype ] , size , \n block_size , tctx -> length [ ftype ] , \n tctx -> length_change [ ftype ] , ftype ) ; \n transpose_perm ( tctx -> permut [ ftype ] , tmp_perm , tctx -> n_div [ ftype ] , \n tctx -> length [ ftype ] , tctx -> length_change [ ftype ] ) ; \n linear_perm ( tctx -> permut [ ftype ] , tctx -> permut [ ftype ] , size , \n size * block_size ) ; \n }", "idx": 15097}
{"project": "FFmpeg", "commit_id": "d608a27d9e28d24ab56acc4ea6bfb13b2802035c", "target": 0, "func": "static int real_seek ( AVFormatContext * avf , int stream , \n int64_t min_ts , int64_t ts , int64_t max_ts , int flags ) \n { \n ConcatContext * cat = avf -> priv_data ; \n int ret , left , right ; \n if ( stream >= 0 ) { \n if ( stream >= avf -> nb_streams ) \n return AVERROR ( EINVAL ) ; \n rescale_interval ( avf -> streams [ stream ] -> time_base , AV_TIME_BASE_Q , \n & min_ts , & ts , & max_ts ) ; \n } \n left = 0 ; \n right = cat -> nb_files ; \n while ( right - left > 1 ) { \n int mid = ( left + right ) / 2 ; \n if ( ts < cat -> files [ mid ] . start_time ) \n right = mid ; \n else \n left = mid ; \n } \n if ( ( ret = open_file ( avf , left ) ) < 0 ) \n return ret ; \n ret = try_seek ( avf , stream , min_ts , ts , max_ts , flags ) ; \n if ( ret < 0 && ! ( flags & AVSEEK_FLAG_BACKWARD ) && \n left < cat -> nb_files - 1 && \n cat -> files [ left + 1 ] . start_time < max_ts ) { \n if ( ( ret = open_file ( avf , left + 1 ) ) < 0 ) \n return ret ; \n ret = try_seek ( avf , stream , min_ts , ts , max_ts , flags ) ; \n } \n return ret ; \n }", "idx": 15100}
{"project": "FFmpeg", "commit_id": "0c9ab5ef9c1ee852c80c859c9e07efe8730b57ed", "target": 1, "func": "static void FUNC ( dequant ) ( int16_t * coeffs , int16_t log2_size ) \n { \n int shift = 15 - BIT_DEPTH - log2_size ; \n int x , y ; \n int size = 1 << log2_size ; \n if ( shift > 0 ) { \n int offset = 1 << ( shift - 1 ) ; \n for ( y = 0 ; y < size ; y ++ ) { \n for ( x = 0 ; x < size ; x ++ ) { \n * coeffs = ( * coeffs + offset ) >> shift ; \n coeffs ++ ; \n } \n } \n } else { \n for ( y = 0 ; y < size ; y ++ ) { \n for ( x = 0 ; x < size ; x ++ ) { \n * coeffs = * coeffs << - shift ; \n coeffs ++ ; \n } \n } \n } \n }", "idx": 15101}
{"project": "FFmpeg", "commit_id": "83f238cbf0c038245d2b2dffa5beb0916e7c36d2", "target": 0, "func": "void dsputil_init_armv4l ( void ) \n { \n }", "idx": 15122}
{"project": "FFmpeg", "commit_id": "857cd1f33bcf86005529af2a77f861f884327be5", "target": 0, "func": "static void RENAME ( resample_one ) ( DELEM * dst , const DELEM * src , \n int dst_size , int64_t index2 , int64_t incr ) \n { \n int dst_index ; \n for ( dst_index = 0 ; dst_index < dst_size ; dst_index ++ ) { \n dst [ dst_index ] = src [ index2 >> 32 ] ; \n index2 += incr ; \n } \n }", "idx": 15123}
{"project": "FFmpeg", "commit_id": "8f618f4c048e3579b62768665c255b89bd99b89f", "target": 1, "func": "AVFilterContext * avfilter_open ( AVFilter * filter , char * inst_name ) \n { \n AVFilterContext * ret = av_malloc ( sizeof ( AVFilterContext ) ) ; \n ret -> av_class = av_mallocz ( sizeof ( AVClass ) ) ; \n ret -> av_class -> item_name = filter_name ; \n ret -> filter = filter ; \n ret -> name = inst_name ? av_strdup ( inst_name ) : NULL ; \n ret -> priv = av_mallocz ( filter -> priv_size ) ; \n ret -> input_count = pad_count ( filter -> inputs ) ; \n ret -> input_pads = av_malloc ( sizeof ( AVFilterPad ) * ret -> input_count ) ; \n memcpy ( ret -> input_pads , filter -> inputs , sizeof ( AVFilterPad ) * ret -> input_count ) ; \n ret -> inputs = av_mallocz ( sizeof ( AVFilterLink * ) * ret -> input_count ) ; \n ret -> output_count = pad_count ( filter -> outputs ) ; \n ret -> output_pads = av_malloc ( sizeof ( AVFilterPad ) * ret -> output_count ) ; \n memcpy ( ret -> output_pads , filter -> outputs , sizeof ( AVFilterPad ) * ret -> output_count ) ; \n ret -> outputs = av_mallocz ( sizeof ( AVFilterLink * ) * ret -> output_count ) ; \n return ret ; \n }", "idx": 15135}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC ( ff_h264_idct8_dc_add ) ( uint8_t * _dst , DCTELEM * block , int stride ) { \n int i , j ; \n int dc = ( ( ( dctcoef * ) block ) [ 0 ] + 32 ) >> 6 ; \n INIT_CLIP \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( j = 0 ; j < 8 ; j ++ ) \n { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = CLIP ( dst [ i ] + dc ) ; \n dst += stride ; \n } \n }", "idx": 15142}
{"project": "FFmpeg", "commit_id": "7149fce2cac0474a5fbc5b47add1158cd8bb283e", "target": 1, "func": "static void render_line ( int x0 , int y0 , int x1 , int y1 , float * buf ) \n { \n int dy = y1 - y0 ; \n int adx = x1 - x0 ; \n int ady = FFABS ( dy ) ; \n int sy = dy < 0 ? -1 : 1 ; \n buf [ x0 ] = ff_vorbis_floor1_inverse_db_table [ y0 ] ; \n if ( ady * 2 <= adx ) { \n render_line_unrolled ( x0 , y0 , x1 , sy , ady , adx , buf ) ; \n } else { \n int base = dy / adx ; \n int x = x0 ; \n int y = y0 ; \n int err = - adx ; \n ady -= FFABS ( base ) * adx ; \n while ( ++ x < x1 ) { \n y += base ; \n err += ady ; \n if ( err >= 0 ) { \n err -= adx ; \n y += sy ; \n } \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n } \n }", "idx": 15155}
{"project": "FFmpeg", "commit_id": "ea7f080749d68a431226ce196014da38761a0d82", "target": 1, "func": "void ff_rtsp_close_streams ( AVFormatContext * s ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n RTSPStream * rtsp_st ; \n ff_rtsp_undo_setup ( s ) ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st ) { \n if ( rtsp_st -> dynamic_handler && rtsp_st -> dynamic_protocol_context ) \n rtsp_st -> dynamic_handler -> close ( \n rtsp_st -> dynamic_protocol_context ) ; \n } \n } \n av_free ( rt -> rtsp_streams ) ; \n if ( rt -> asf_ctx ) { \n av_close_input_stream ( rt -> asf_ctx ) ; \n rt -> asf_ctx = NULL ; \n } \n av_free ( rt -> p ) ; \n av_free ( rt -> recvbuf ) ; \n }", "idx": 15157}
{"project": "FFmpeg", "commit_id": "ce87711df563a9d2d0537a062b86bb91b15ea1a0", "target": 0, "func": "int avpriv_exif_decode_ifd ( AVCodecContext * avctx , GetByteContext * gbytes , int le , \n int depth , AVDictionary * * metadata ) \n { \n int i , ret ; \n int entries ; \n entries = ff_tget_short ( gbytes , le ) ; \n if ( bytestream2_get_bytes_left ( gbytes ) < entries * 12 ) { \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < entries ; i ++ ) { \n if ( ( ret = exif_decode_tag ( avctx , gbytes , le , depth , metadata ) ) < 0 ) { \n return ret ; \n } \n } \n return ff_tget_long ( gbytes , le ) ; \n }", "idx": 15174}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_start ( AVFormatContext * s , int write_header ) \n { \n SegmentContext * c = s -> priv_data ; \n AVFormatContext * oc = c -> avf ; \n int err = 0 ; \n if ( write_header ) { \n avformat_free_context ( oc ) ; \n c -> avf = NULL ; \n if ( ( err = segment_mux_init ( s ) ) < 0 ) \n return err ; \n oc = c -> avf ; \n } \n if ( c -> wrap ) \n c -> number %= c -> wrap ; \n if ( av_get_frame_filename ( oc -> filename , sizeof ( oc -> filename ) , \n s -> filename , c -> number ++ ) < 0 ) \n return AVERROR ( EINVAL ) ; \n if ( ( err = avio_open2 ( & oc -> pb , oc -> filename , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ) < 0 ) \n return err ; \n if ( oc -> oformat -> priv_class && oc -> priv_data ) \n av_opt_set ( oc -> priv_data , \" \" , \" \" , 0 ) ; \n if ( write_header ) { \n if ( ( err = avformat_write_header ( oc , NULL ) ) < 0 ) \n return err ; \n } \n return 0 ; \n }", "idx": 15185}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int cmp_int ( const void * p1 , const void * p2 ) \n { \n int left = * ( const int * ) p1 ; \n int right = * ( const int * ) p2 ; \n return ( ( left > right ) - ( left < right ) ) ; \n }", "idx": 15203}
{"project": "FFmpeg", "commit_id": "4d7c71c36467331f1e0c0f17af9f371d33308a9c", "target": 1, "func": "void ff_interleave_add_packet ( AVFormatContext * s , AVPacket * pkt , \n int ( * compare ) ( AVFormatContext * , AVPacket * , AVPacket * ) ) \n { \n AVPacketList * * next_point , * this_pktl ; \n this_pktl = av_mallocz ( sizeof ( AVPacketList ) ) ; \n this_pktl -> pkt = * pkt ; \n pkt -> destruct = NULL ; \n av_dup_packet ( & this_pktl -> pkt ) ; \n if ( s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer ) { \n next_point = & ( s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer -> next ) ; \n } else \n next_point = & s -> packet_buffer ; \n if ( * next_point ) { \n if ( compare ( s , & s -> packet_buffer_end -> pkt , pkt ) ) { \n while ( ! compare ( s , & ( * next_point ) -> pkt , pkt ) ) { \n next_point = & ( * next_point ) -> next ; \n } \n goto next_non_null ; \n } else { \n next_point = & ( s -> packet_buffer_end -> next ) ; \n } \n } \n assert ( ! * next_point ) ; \n s -> packet_buffer_end = this_pktl ; \n next_non_null : \n this_pktl -> next = * next_point ; \n s -> streams [ pkt -> stream_index ] -> last_in_packet_buffer = \n * next_point = this_pktl ; \n }", "idx": 15210}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static char * json_escape_str ( const char * s ) \n { \n static const char json_escape [ ] = { ' ' , ' \\\\ ' , ' \\b ' , ' \\f ' , ' \\n ' , ' \\r ' , ' \\t ' , 0 } ; \n static const char json_subst [ ] = { ' ' , ' \\\\ ' , ' ' , ' ' , ' ' , ' ' , ' ' , 0 } ; \n char * ret , * p ; \n int i , len = 0 ; \n for ( i = 0 ; s [ i ] ; i ++ ) { \n if ( strchr ( json_escape , s [ i ] ) ) len += 2 ; \n else if ( ( unsigned char ) s [ i ] < 32 ) len += 6 ; \n else len += 1 ; \n } \n p = ret = av_malloc ( len + 1 ) ; \n if ( ! p ) \n return NULL ; \n for ( i = 0 ; s [ i ] ; i ++ ) { \n char * q = strchr ( json_escape , s [ i ] ) ; \n if ( q ) { \n * p ++ = ' \\\\ ' ; \n * p ++ = json_subst [ q - json_escape ] ; \n } else if ( ( unsigned char ) s [ i ] < 32 ) { \n snprintf ( p , 7 , \" \\\\ \" , s [ i ] & 0xff ) ; \n p += 6 ; \n } else { \n * p ++ = s [ i ] ; \n } \n } \n * p = 0 ; \n return ret ; \n }", "idx": 15216}
{"project": "FFmpeg", "commit_id": "8108551a5c4c4c9696582c73d000f94b12cd95a5", "target": 0, "func": "static int gif_image_write_header ( ByteIOContext * pb , \n int width , int height , uint32_t * palette ) \n { \n int i ; \n unsigned int v ; \n put_tag ( pb , \" \" ) ; \n put_tag ( pb , \" \" ) ; \n put_le16 ( pb , width ) ; \n put_le16 ( pb , height ) ; \n put_byte ( pb , 0xf7 ) ; \n put_byte ( pb , 0x1f ) ; \n put_byte ( pb , 0 ) ; \n if ( ! palette ) { \n put_buffer ( pb , ( unsigned char * ) gif_clut , 216 * 3 ) ; \n for ( i = 0 ; i < ( ( 256 - 216 ) * 3 ) ; i ++ ) \n put_byte ( pb , 0 ) ; \n } else { \n for ( i = 0 ; i < 256 ; i ++ ) { \n v = palette [ i ] ; \n put_byte ( pb , ( v >> 16 ) & 0xff ) ; \n put_byte ( pb , ( v >> 8 ) & 0xff ) ; \n put_byte ( pb , ( v ) & 0xff ) ; \n } \n } \n #ifdef GIF_ADD_APP_HEADER \n put_byte ( pb , 0x21 ) ; \n put_byte ( pb , 0xff ) ; \n put_byte ( pb , 0x0b ) ; \n put_tag ( pb , \" \" ) ; \n put_byte ( pb , 0x03 ) ; \n put_byte ( pb , 0x01 ) ; \n put_byte ( pb , 0x00 ) ; \n put_byte ( pb , 0x00 ) ; \n #endif \n return 0 ; \n }", "idx": 15218}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static int add_doubles_metadata ( const uint8_t * * buf , int count , \n const char * name , const char * sep , \n TiffContext * s ) \n { \n char * ap ; \n int i ; \n double * dp = av_malloc ( count * sizeof ( double ) ) ; \n if ( ! dp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n dp [ i ] = tget_double ( buf , s -> le ) ; \n ap = doubles2str ( dp , count , sep ) ; \n av_freep ( & dp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( & s -> picture . metadata , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 15224}
{"project": "FFmpeg", "commit_id": "d574e22659bd51cdf16723a204fef65a9e783f1d", "target": 0, "func": "static void hdcd_reset ( hdcd_state_t * state , unsigned rate ) \n { \n int i ; \n state -> window = 0 ; \n state -> readahead = 32 ; \n state -> arg = 0 ; \n state -> control = 0 ; \n state -> running_gain = 0 ; \n state -> sustain = 0 ; \n state -> sustain_reset = rate * 10 ; \n state -> code_counterA = 0 ; \n state -> code_counterA_almost = 0 ; \n state -> code_counterB = 0 ; \n state -> code_counterB_checkfails = 0 ; \n state -> code_counterC = 0 ; \n state -> code_counterC_unmatched = 0 ; \n state -> count_peak_extend = 0 ; \n state -> count_transient_filter = 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) state -> gain_counts [ i ] = 0 ; \n state -> max_gain = 0 ; \n state -> count_sustain_expired = -1 ; \n }", "idx": 15234}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static int decode_cabac_mb_chroma_pre_mode ( H264Context * h ) { \n const int mba_xy = h -> left_mb_xy [ 0 ] ; \n const int mbb_xy = h -> top_mb_xy ; \n int ctx = 0 ; \n if ( h -> slice_table [ mba_xy ] == h -> slice_num && h -> chroma_pred_mode_table [ mba_xy ] != 0 ) \n ctx ++ ; \n if ( h -> slice_table [ mbb_xy ] == h -> slice_num && h -> chroma_pred_mode_table [ mbb_xy ] != 0 ) \n ctx ++ ; \n if ( get_cabac ( & h -> cabac , & h -> cabac_state [ 64 + ctx ] ) == 0 ) \n return 0 ; \n if ( get_cabac ( & h -> cabac , & h -> cabac_state [ 64 + 3 ] ) == 0 ) \n return 1 ; \n if ( get_cabac ( & h -> cabac , & h -> cabac_state [ 64 + 3 ] ) == 0 ) \n return 2 ; \n else \n return 3 ; \n }", "idx": 15237}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int mp3_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size ; \n size = MP3_PACKET_SIZE ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = 0 ; \n if ( ret <= 0 ) { \n if ( ret < 0 ) \n return ret ; \n return AVERROR_EOF ; \n } \n if ( ret > ID3v1_TAG_SIZE && \n memcmp ( & pkt -> data [ ret - ID3v1_TAG_SIZE ] , \" \" , 3 ) == 0 ) \n ret -= ID3v1_TAG_SIZE ; \n pkt -> size = ret ; \n return ret ; \n }", "idx": 15257}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "int is_adx ( const unsigned char * buf , size_t bufsize ) \n { \n int offset ; \n if ( buf [ 0 ] != 0x80 ) return 0 ; \n offset = ( read_long ( buf ) ^ 0x80000000 ) + 4 ; \n if ( bufsize < offset || memcmp ( buf + offset - 6 , \" \" , 6 ) ) return 0 ; \n return offset ; \n }", "idx": 15263}
{"project": "FFmpeg", "commit_id": "2b31a9c613f95383d5106f8c1cbcee8eb291090f", "target": 1, "func": "static int iff_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n IffDemuxContext * iff = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n AVStream * st = s -> streams [ 0 ] ; \n int ret ; \n int64_t pos = avio_tell ( pb ) ; \n if ( pos >= iff -> body_end ) \n return AVERROR_EOF ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n if ( st -> codec -> codec_tag == ID_MAUD ) { \n ret = av_get_packet ( pb , pkt , FFMIN ( iff -> body_end - pos , 1024 * st -> codec -> block_align ) ) ; \n } else { \n ret = av_get_packet ( pb , pkt , iff -> body_size ) ; \n } \n } else if ( st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n uint8_t * buf ; \n if ( av_new_packet ( pkt , iff -> body_size + 2 ) < 0 ) { \n return AVERROR ( ENOMEM ) ; \n } \n buf = pkt -> data ; \n bytestream_put_be16 ( & buf , 2 ) ; \n ret = avio_read ( pb , buf , iff -> body_size ) ; \n } else { \n av_assert0 ( 0 ) ; \n } \n if ( pos == iff -> body_pos ) \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = 0 ; \n return ret ; \n }", "idx": 15275}
{"project": "FFmpeg", "commit_id": "29112db8c0f65886e69cbbd6f4e5c44d2d14d238", "target": 1, "func": "static int set_palette ( AVFrame * frame , const uint8_t * palette_buffer , int buf_size ) \n { \n uint32_t * palette = ( uint32_t * ) frame -> data [ 1 ] ; \n int a ; \n if ( buf_size < 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n for ( a = 0 ; a < 256 ; a ++ ) { \n palette [ a ] = AV_RB24 ( & palette_buffer [ a * 3 ] ) * 4 ; \n } \n frame -> palette_has_changed = 1 ; \n return 256 * 3 ; \n }", "idx": 15280}
{"project": "FFmpeg", "commit_id": "4d388c0cd05dd4de545e8ea333ab4de7d67ad12d", "target": 1, "func": "static int build_def_list ( Picture * def , Picture * * in , int len , int is_long , int sel ) \n { \n int i [ 2 ] = { 0 } ; \n int index = 0 ; \n while ( i [ 0 ] < len || i [ 1 ] < len ) { \n while ( i [ 0 ] < len && ! ( in [ i [ 0 ] ] && ( in [ i [ 0 ] ] -> reference & sel ) ) ) \n i [ 0 ] ++ ; \n while ( i [ 1 ] < len && ! ( in [ i [ 1 ] ] && ( in [ i [ 1 ] ] -> reference & ( sel ^ 3 ) ) ) ) \n i [ 1 ] ++ ; \n if ( i [ 0 ] < len ) { \n in [ i [ 0 ] ] -> pic_id = is_long ? i [ 0 ] : in [ i [ 0 ] ] -> frame_num ; \n split_field_copy ( & def [ index ++ ] , in [ i [ 0 ] ++ ] , sel , 1 ) ; \n } \n if ( i [ 1 ] < len ) { \n in [ i [ 1 ] ] -> pic_id = is_long ? i [ 1 ] : in [ i [ 1 ] ] -> frame_num ; \n split_field_copy ( & def [ index ++ ] , in [ i [ 1 ] ++ ] , sel ^ 3 , 0 ) ; \n } \n } \n return index ; \n }", "idx": 15281}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static SchroBuffer * find_next_parse_unit ( SchroParseUnitContext * parse_ctx ) \n { \n SchroBuffer * enc_buf = NULL ; \n int next_pu_offset = 0 ; \n unsigned char * in_buf ; \n if ( parse_ctx -> buf_size < 13 || \n parse_ctx -> buf [ 0 ] != ' ' || \n parse_ctx -> buf [ 1 ] != ' ' || \n parse_ctx -> buf [ 2 ] != ' ' || \n parse_ctx -> buf [ 3 ] != ' ' ) \n return NULL ; \n next_pu_offset = ( parse_ctx -> buf [ 5 ] << 24 ) + \n ( parse_ctx -> buf [ 6 ] << 16 ) + \n ( parse_ctx -> buf [ 7 ] << 8 ) + \n parse_ctx -> buf [ 8 ] ; \n if ( next_pu_offset == 0 && \n SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE ( parse_ctx -> buf [ 4 ] ) ) \n next_pu_offset = 13 ; \n if ( next_pu_offset <= 0 || parse_ctx -> buf_size < next_pu_offset ) \n return NULL ; \n in_buf = av_malloc ( next_pu_offset ) ; \n if ( ! in_buf ) { \n av_log ( parse_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return NULL ; \n } \n memcpy ( in_buf , parse_ctx -> buf , next_pu_offset ) ; \n enc_buf = schro_buffer_new_with_data ( in_buf , next_pu_offset ) ; \n enc_buf -> free = libschroedinger_decode_buffer_free ; \n enc_buf -> priv = in_buf ; \n parse_ctx -> buf += next_pu_offset ; \n parse_ctx -> buf_size -= next_pu_offset ; \n return enc_buf ; \n }", "idx": 15291}
{"project": "FFmpeg", "commit_id": "e72f3d10f64f5c65a67aa21dcc79a85ee55e912e", "target": 0, "func": "static int dnxhd_10bit_dct_quantize ( MpegEncContext * ctx , DCTELEM * block , \n int n , int qscale , int * overflow ) \n { \n const uint8_t * scantable = ctx -> intra_scantable . scantable ; \n const int * qmat = ctx -> q_intra_matrix [ qscale ] ; \n int last_non_zero = 0 ; \n ctx -> dsp . fdct ( block ) ; \n block [ 0 ] = ( block [ 0 ] + 2 ) >> 2 ; \n for ( int i = 1 ; i < 64 ; ++ i ) { \n int j = scantable [ i ] ; \n int sign = block [ j ] >> 31 ; \n int level = ( block [ j ] ^ sign ) - sign ; \n level = level * qmat [ j ] >> DNX10BIT_QMAT_SHIFT ; \n block [ j ] = ( level ^ sign ) - sign ; \n if ( level ) \n last_non_zero = i ; \n } \n return last_non_zero ; \n }", "idx": 15293}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int XAVS_close ( AVCodecContext * avctx ) \n { \n XavsContext * x4 = avctx -> priv_data ; \n av_freep ( & avctx -> extradata ) ; \n av_free ( x4 -> sei ) ; \n av_freep ( & x4 -> pts_buffer ) ; \n if ( x4 -> enc ) \n xavs_encoder_close ( x4 -> enc ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 15295}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_minf_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) \n mov_write_vmhd_tag ( pb ) ; \n else if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO ) \n mov_write_smhd_tag ( pb ) ; \n else if ( track -> enc -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { \n if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) || is_clcp_track ( track ) ) { \n mov_write_gmhd_tag ( pb , track ) ; \n } else { \n mov_write_nmhd_tag ( pb ) ; \n } \n } else if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n mov_write_hmhd_tag ( pb ) ; \n } else if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n mov_write_gmhd_tag ( pb , track ) ; \n } \n if ( track -> mode == MODE_MOV ) \n mov_write_hdlr_tag ( pb , NULL ) ; \n mov_write_dinf_tag ( pb ) ; \n mov_write_stbl_tag ( pb , track ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 15299}
{"project": "FFmpeg", "commit_id": "f707a5ebba734597b1ff0810931b55b630077ab3", "target": 1, "func": "static void ir2_decode_plane ( Ir2Context * ctx , int width , int height , uint8_t * dst , int stride , \n const uint8_t * table ) \n { \n int i ; \n int j ; \n int out = 0 ; \n int c ; \n int t ; \n while ( out < width ) { \n c = ir2_get_code ( & ctx -> gb ) ; \n if ( c > 0x80 ) { \n c -= 0x80 ; \n for ( i = 0 ; i < c * 2 ; i ++ ) \n dst [ out ++ ] = 0x80 ; \n } else { \n dst [ out ++ ] = table [ c * 2 ] ; \n dst [ out ++ ] = table [ ( c * 2 ) + 1 ] ; \n } \n } \n dst += stride ; \n for ( j = 1 ; j < height ; j ++ ) { \n out = 0 ; \n while ( out < width ) { \n c = ir2_get_code ( & ctx -> gb ) ; \n if ( c > 0x80 ) { \n c -= 0x80 ; \n for ( i = 0 ; i < c * 2 ; i ++ ) { \n dst [ out ] = dst [ out - stride ] ; \n out ++ ; \n } \n } else { \n t = dst [ out - stride ] + ( table [ c * 2 ] - 128 ) ; \n CLAMP_TO_BYTE ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n t = dst [ out - stride ] + ( table [ ( c * 2 ) + 1 ] - 128 ) ; \n CLAMP_TO_BYTE ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n } \n } \n dst += stride ; \n } \n }", "idx": 15302}
{"project": "FFmpeg", "commit_id": "0c33ceda91dd646414a2e0ec832bada5acb6b762", "target": 0, "func": "int main ( void ) \n { \n int x = 0 ; \n int i , j ; \n AVLFG state ; \n av_lfg_init ( & state , 0xdeadbeef ) ; \n for ( j = 0 ; j < 10000 ; j ++ ) { \n START_TIMER \n for ( i  = 0 ; i < 624 ; i ++ ) { \n x += av_lfg_get ( & state ) ; \n } \n STOP_TIMER ( \" \" ) ; \n } \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , x ) ; \n { \n double mean = 1000 ; \n double stddev = 53 ; \n av_lfg_init ( & state , 42 ) ; \n for ( i = 0 ; i < 1000 ; i += 2 ) { \n double bmg_out [ 2 ] ; \n av_bmg_get ( & state , bmg_out ) ; \n av_log ( NULL , AV_LOG_INFO , \n \" \\n \\n \" , \n bmg_out [ 0 ] * stddev + mean , \n bmg_out [ 1 ] * stddev + mean ) ; \n } \n } \n return 0 ; \n }", "idx": 15307}
{"project": "FFmpeg", "commit_id": "fb7a2bf6956173eda6f9caceef8599fa4f83500d", "target": 0, "func": "enum CodecID codec_get_id ( const CodecTag * tags , unsigned int tag ) \n { \n while ( tags -> id != 0 ) { \n if ( toupper ( ( tag >> 0 ) & 0xFF ) == toupper ( ( tags -> tag >> 0 ) & 0xFF ) \n && toupper ( ( tag >> 8 ) & 0xFF ) == toupper ( ( tags -> tag >> 8 ) & 0xFF ) \n && toupper ( ( tag >> 16 ) & 0xFF ) == toupper ( ( tags -> tag >> 16 ) & 0xFF ) \n && toupper ( ( tag >> 24 ) & 0xFF ) == toupper ( ( tags -> tag >> 24 ) & 0xFF ) ) \n return tags -> id ; \n tags ++ ; \n } \n return CODEC_ID_NONE ; \n }", "idx": 15308}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred4x4_vertical_add ) ( uint8_t * _pix , const int16_t * _block , \n ptrdiff_t stride ) \n { \n int i ; \n pixel * pix = ( pixel * ) _pix ; \n const dctcoef * block = ( const dctcoef * ) _block ; \n stride >>= sizeof ( pixel ) - 1 ; \n pix -= stride ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n pixel v = pix [ 0 ] ; \n pix [ 1 * stride ] = v += block [ 0 ] ; \n pix [ 2 * stride ] = v += block [ 4 ] ; \n pix [ 3 * stride ] = v += block [ 8 ] ; \n pix [ 4 * stride ] = v + block [ 12 ] ; \n pix ++ ; \n block ++ ; \n } \n }", "idx": 15309}
{"project": "FFmpeg", "commit_id": "b39f872a41b92a31589052c8f914c5b52f206fd0", "target": 1, "func": "static int adts_aac_probe ( AVProbeData * p ) \n { \n int max_frames = 0 , first_frames = 0 ; \n int fsize , frames ; \n uint8_t * buf0 = p -> buf ; \n uint8_t * buf2 ; \n uint8_t * buf ; \n uint8_t * end = buf0 + p -> buf_size - 7 ; \n buf = buf0 ; \n for ( ; buf < end ; buf = buf2 + 1 ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n uint32_t header = AV_RB16 ( buf2 ) ; \n if ( ( header & 0xFFF6 ) != 0xFFF0 ) \n break ; \n fsize = ( AV_RB32 ( buf2 + 3 ) >> 13 ) & 0x1FFF ; \n if ( fsize < 7 ) \n break ; \n buf2 += fsize ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == buf0 ) \n first_frames = frames ; \n } \n if ( first_frames >= 3 ) return AVPROBE_SCORE_MAX / 2 + 1 ; \n else if ( max_frames > 500 ) return AVPROBE_SCORE_MAX / 2 ; \n else if ( max_frames >= 3 ) return AVPROBE_SCORE_MAX / 4 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 15316}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "void avdevice_register_all ( void ) \n { \n static int inited ; \n if ( inited ) \n return ; \n inited = 1 ; \n REGISTER_MUXDEMUX ( AUDIO_BEOS , audio_beos ) ; \n REGISTER_DEMUXER ( BKTR , bktr ) ; \n REGISTER_DEMUXER ( DV1394 , dv1394 ) ; \n REGISTER_MUXDEMUX ( OSS , oss ) ; \n REGISTER_DEMUXER ( V4L2 , v4l2 ) ; \n REGISTER_DEMUXER ( V4L , v4l ) ; \n REGISTER_DEMUXER ( X11_GRAB_DEVICE , x11_grab_device ) ; \n REGISTER_DEMUXER ( LIBDC1394 , libdc1394 ) ; \n }", "idx": 15320}
{"project": "FFmpeg", "commit_id": "7d49f79f1cd47783a963a757a6563b9cac29db62", "target": 0, "func": "static int qdm2_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n QDM2Context * s = avctx -> priv_data ; \n int16_t * out = data ; \n int i ; \n if ( ! buf ) \n return 0 ; \n if ( buf_size < s -> checksum_size ) \n return -1 ; \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , \n buf_size , buf , s -> checksum_size , data , * data_size ) ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n if ( qdm2_decode ( s , buf , out ) < 0 ) \n return -1 ; \n out += s -> channels * s -> frame_size ; \n } \n * data_size = ( uint8_t * ) out - ( uint8_t * ) data ; \n return s -> checksum_size ; \n }", "idx": 15323}
{"project": "FFmpeg", "commit_id": "daece4c6745b42e8b1e171fb4bf485d5d64fc53f", "target": 0, "func": "static VideoState * stream_open ( const char * filename , AVInputFormat * iformat ) \n { \n VideoState * is ; \n is = av_mallocz ( sizeof ( VideoState ) ) ; \n if ( ! is ) \n return NULL ; \n av_strlcpy ( is -> filename , filename , sizeof ( is -> filename ) ) ; \n is -> iformat = iformat ; \n is -> ytop = 0 ; \n is -> xleft = 0 ; \n is -> pictq_mutex = SDL_CreateMutex ( ) ; \n is -> pictq_cond = SDL_CreateCond ( ) ; \n is -> subpq_mutex = SDL_CreateMutex ( ) ; \n is -> subpq_cond = SDL_CreateCond ( ) ; \n packet_queue_init ( & is -> videoq ) ; \n packet_queue_init ( & is -> audioq ) ; \n packet_queue_init ( & is -> subtitleq ) ; \n is -> continue_read_thread = SDL_CreateCond ( ) ; \n update_external_clock_pts ( is , ( double ) AV_NOPTS_VALUE ) ; \n update_external_clock_speed ( is , 1.0 ) ; \n is -> audio_current_pts_drift = - av_gettime ( ) / 1000000.0 ; \n is -> video_current_pts_drift = is -> audio_current_pts_drift ; \n is -> audio_clock_serial = -1 ; \n is -> video_clock_serial = -1 ; \n is -> av_sync_type = av_sync_type ; \n is -> read_tid = SDL_CreateThread ( read_thread , is ) ; \n if ( ! is -> read_tid ) { \n av_free ( is ) ; \n return NULL ; \n } \n return is ; \n }", "idx": 15331}
{"project": "FFmpeg", "commit_id": "0ccabeeaef77e240f2a44f78271a8914a23e239b", "target": 0, "func": "void avfilter_start_frame ( AVFilterLink * link , AVFilterBufferRef * picref ) \n { \n void ( * start_frame ) ( AVFilterLink * , AVFilterBufferRef * ) ; \n AVFilterPad * dst = link -> dstpad ; \n FF_DPRINTF_START ( NULL , start_frame ) ; ff_dprintf_link ( NULL , link , 0 ) ; dprintf ( NULL , \" \" ) ; ff_dprintf_ref ( NULL , picref , 1 ) ; \n if ( ! ( start_frame = dst -> start_frame ) ) \n start_frame = avfilter_default_start_frame ; \n if ( ( dst -> min_perms & picref -> perms ) != dst -> min_perms || \n dst -> rej_perms & picref -> perms ) { \n av_log ( link -> dst , AV_LOG_DEBUG , \n \" \\n \" , \n picref -> perms , \n link -> dstpad -> min_perms , link -> dstpad -> rej_perms ) ; \n link -> cur_buf = avfilter_get_video_buffer ( link , dst -> min_perms , link -> w , link -> h ) ; \n link -> src_buf = picref ; \n avfilter_copy_buffer_ref_props ( link -> cur_buf , link -> src_buf ) ; \n } \n else \n link -> cur_buf = picref ; \n start_frame ( link , link -> cur_buf ) ; \n }", "idx": 15333}
{"project": "FFmpeg", "commit_id": "8692e6284f5169257a537c8fc25addf32fc67c87", "target": 0, "func": "rdt_new_context ( void ) \n { \n PayloadContext * rdt = av_mallocz ( sizeof ( PayloadContext ) ) ; \n int ret = avformat_open_input ( & rdt -> rmctx , \" \" , & ff_rdt_demuxer , NULL ) ; \n if ( ret < 0 ) { \n av_free ( rdt ) ; \n return NULL ; \n } \n return rdt ; \n }", "idx": 15335}
{"project": "FFmpeg", "commit_id": "4e93f00b06d9623ea9639ba7185cdacdf11c2672", "target": 0, "func": "static av_cold int nvenc_setup_surfaces ( AVCodecContext * avctx ) \n { \n NvencContext * ctx = avctx -> priv_data ; \n int i , res ; \n ctx -> surfaces = av_mallocz_array ( ctx -> nb_surfaces , sizeof ( * ctx -> surfaces ) ) ; \n if ( ! ctx -> surfaces ) \n return AVERROR ( ENOMEM ) ; \n ctx -> timestamp_list = av_fifo_alloc ( ctx -> nb_surfaces * sizeof ( int64_t ) ) ; \n if ( ! ctx -> timestamp_list ) \n return AVERROR ( ENOMEM ) ; \n ctx -> unused_surface_queue = av_fifo_alloc ( ctx -> nb_surfaces * sizeof ( NvencSurface * ) ) ; \n if ( ! ctx -> unused_surface_queue ) \n return AVERROR ( ENOMEM ) ; \n ctx -> output_surface_queue = av_fifo_alloc ( ctx -> nb_surfaces * sizeof ( NvencSurface * ) ) ; \n if ( ! ctx -> output_surface_queue ) \n return AVERROR ( ENOMEM ) ; \n ctx -> output_surface_ready_queue = av_fifo_alloc ( ctx -> nb_surfaces * sizeof ( NvencSurface * ) ) ; \n if ( ! ctx -> output_surface_ready_queue ) \n return AVERROR ( ENOMEM ) ; \n res = nvenc_push_context ( avctx ) ; \n if ( res < 0 ) \n return res ; \n for ( i = 0 ; i < ctx -> nb_surfaces ; i ++ ) { \n if ( ( res = nvenc_alloc_surface ( avctx , i ) ) < 0 ) \n { \n nvenc_pop_context ( avctx ) ; \n return res ; \n } \n } \n res = nvenc_pop_context ( avctx ) ; \n if ( res < 0 ) \n return res ; \n return 0 ; \n }", "idx": 15355}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv30_decode_intra_types ( RV34DecContext * r , GetBitContext * gb , int8_t * dst ) \n { \n int i , j , k ; \n for ( i = 0 ; i < 4 ; i ++ , dst += r -> intra_types_stride - 4 ) { \n for ( j = 0 ; j < 4 ; j += 2 ) { \n int code = svq3_get_ue_golomb ( gb ) << 1 ; \n if ( code >= 81 * 2 ) { \n av_log ( r -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( k = 0 ; k < 2 ; k ++ ) { \n int A = dst [ - r -> intra_types_stride ] + 1 ; \n int B = dst [ -1 ] + 1 ; \n * dst ++ = rv30_itype_from_context [ A * 90 + B * 9 + rv30_itype_code [ code + k ] ] ; \n if ( dst [ -1 ] == 9 ) { \n av_log ( r -> s . avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n } \n } \n } \n return 0 ; \n }", "idx": 15360}
{"project": "FFmpeg", "commit_id": "64d779f2f7607070a87b0a70edeba5e51834ce85", "target": 0, "func": "static void put_cabac ( CABACContext * c , uint8_t * const state , int bit ) { \n int RangeLPS = ff_h264_lps_range [ 2 * ( c -> range & 0xC0 ) + * state ] ; \n if ( bit == ( ( * state ) & 1 ) ) { \n c -> range -= RangeLPS ; \n * state = ff_h264_mps_state [ * state ] ; \n } else { \n c -> low += c -> range - RangeLPS ; \n c -> range = RangeLPS ; \n * state = ff_h264_lps_state [ * state ] ; \n } \n renorm_cabac_encoder ( c ) ; \n }", "idx": 15361}
{"project": "FFmpeg", "commit_id": "aa926a480f2f84a87dc1fbf42d40fe23bae82ae1", "target": 0, "func": "static int wv_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n ByteIOContext * pb = s -> pb ; \n WVContext * wc = s -> priv_data ; \n AVStream * st ; \n if ( wv_read_block_header ( s , pb ) < 0 ) \n return -1 ; \n wc -> block_parsed = 0 ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return -1 ; \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = CODEC_ID_WAVPACK ; \n st -> codec -> channels = wc -> chan ; \n st -> codec -> sample_rate = wc -> rate ; \n st -> codec -> bits_per_coded_sample = wc -> bpp ; \n av_set_pts_info ( st , 64 , 1 , wc -> rate ) ; \n s -> start_time = 0 ; \n s -> duration = ( int64_t ) wc -> samples * AV_TIME_BASE / st -> codec -> sample_rate ; \n if ( ! url_is_streamed ( s -> pb ) ) { \n int64_t cur = url_ftell ( s -> pb ) ; \n ff_ape_parse_tag ( s ) ; \n if ( ! av_metadata_get ( s -> metadata , \" \" , NULL , AV_METADATA_IGNORE_SUFFIX ) ) \n ff_id3v1_read ( s ) ; \n url_fseek ( s -> pb , cur , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 15362}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int mov_read_esds ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n return ff_mov_read_esds ( c -> fc , pb , atom ) ; \n }", "idx": 15363}
{"project": "FFmpeg", "commit_id": "2c9a5172d328259c5d76e588f2ddc12f439ffcd0", "target": 1, "func": "static int decode_tsw1 ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n const uint8_t * frame_start = frame ; \n const uint8_t * frame_end = frame + width * height ; \n int mask = 0x10000 , bitbuf = 0 ; \n int v , offset , count , segments ; \n segments = bytestream_get_le32 ( & src ) ; \n frame += bytestream_get_le32 ( & src ) ; \n if ( frame < frame_start || frame > frame_end ) \n return -1 ; \n while ( segments -- ) { \n if ( mask == 0x10000 ) { \n if ( src >= src_end ) \n return -1 ; \n bitbuf = bytestream_get_le16 ( & src ) ; \n mask = 1 ; \n } \n if ( src_end - src < 2 || frame_end - frame < 2 ) \n return -1 ; \n if ( bitbuf & mask ) { \n v = bytestream_get_le16 ( & src ) ; \n offset = ( v & 0x1FFF ) << 1 ; \n count = ( ( v >> 13 ) + 2 ) << 1 ; \n if ( frame - frame_start < offset || frame_end - frame < count ) \n return -1 ; \n av_memcpy_backptr ( frame , offset , count ) ; \n frame += count ; \n } else { \n * frame ++ = * src ++ ; \n * frame ++ = * src ++ ; \n } \n mask <<= 1 ; \n } \n return 0 ; \n }", "idx": 15369}
{"project": "FFmpeg", "commit_id": "6bd665b7c5798803366b877903fa3bce7f129d05", "target": 0, "func": "int ff_tak_decode_frame_header ( AVCodecContext * avctx , GetBitContext * gb , \n TAKStreamInfo * ti , int log_level_offset ) \n { \n if ( get_bits ( gb , TAK_FRAME_HEADER_SYNC_ID_BITS ) != TAK_FRAME_HEADER_SYNC_ID ) { \n av_log ( avctx , AV_LOG_ERROR + log_level_offset , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n ti -> flags = get_bits ( gb , TAK_FRAME_HEADER_FLAGS_BITS ) ; \n ti -> frame_num = get_bits ( gb , TAK_FRAME_HEADER_NO_BITS ) ; \n if ( ti -> flags & TAK_FRAME_FLAG_IS_LAST ) { \n ti -> last_frame_samples = get_bits ( gb , TAK_FRAME_HEADER_SAMPLE_COUNT_BITS ) + 1 ; \n skip_bits ( gb , 2 ) ; \n } else { \n ti -> last_frame_samples = 0 ; \n } \n if ( ti -> flags & TAK_FRAME_FLAG_HAS_INFO ) { \n avpriv_tak_parse_streaminfo ( gb , ti ) ; \n if ( get_bits ( gb , 6 ) ) \n skip_bits ( gb , 25 ) ; \n align_get_bits ( gb ) ; \n } \n if ( ti -> flags & TAK_FRAME_FLAG_HAS_METADATA ) \n return AVERROR_INVALIDDATA ; \n skip_bits ( gb , 24 ) ; \n return 0 ; \n }", "idx": 15378}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_wave ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return AVERROR_INVALIDDATA ; \n if ( st -> codec -> codec_id == AV_CODEC_ID_QDM2 || st -> codec -> codec_id == AV_CODEC_ID_QDMC ) { \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size ; \n avio_read ( pb , st -> codec -> extradata , atom . size ) ; \n } else if ( atom . size > 8 ) { \n int ret ; \n if ( ( ret = mov_read_default ( c , pb , atom ) ) < 0 ) \n return ret ; \n } else \n avio_skip ( pb , atom . size ) ; \n return 0 ; \n }", "idx": 15381}
{"project": "FFmpeg", "commit_id": "9afb7061f938831248942050cfdb449e014ed427", "target": 1, "func": "static int mov_read_chan ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( atom . size < 16 ) \n return 0 ; \n ff_mov_read_chan ( c -> fc , st , atom . size - 4 ) ; \n return 0 ; \n }", "idx": 15383}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int theora_decode_header ( AVCodecContext * avctx , GetBitContext gb ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n int major , minor , micro ; \n major = get_bits ( & gb , 8 ) ; \n minor = get_bits ( & gb , 8 ) ; \n micro = get_bits ( & gb , 8 ) ; \n av_log ( avctx , AV_LOG_INFO , \" \\n \" , \n major , minor , micro ) ; \n s -> theora = ( major << 16 ) | ( minor << 8 ) | micro ; \n if ( s -> theora < 0x030300 ) \n { \n s -> flipped_image = 1 ; \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n s -> width = get_bits ( & gb , 16 ) << 4 ; \n s -> height = get_bits ( & gb , 16 ) << 4 ; \n skip_bits ( & gb , 24 ) ; \n skip_bits ( & gb , 24 ) ; \n skip_bits ( & gb , 8 ) ; \n skip_bits ( & gb , 8 ) ; \n skip_bits ( & gb , 32 ) ; \n skip_bits ( & gb , 32 ) ; \n skip_bits ( & gb , 24 ) ; \n skip_bits ( & gb , 24 ) ; \n if ( s -> theora < 0x030300 ) \n skip_bits ( & gb , 5 ) ; \n skip_bits ( & gb , 8 ) ; \n skip_bits ( & gb , 24 ) ; \n skip_bits ( & gb , 6 ) ; \n if ( s -> theora >= 0x030300 ) \n { \n skip_bits ( & gb , 5 ) ; \n skip_bits ( & gb , 5 ) ; \n avctx -> width = s -> width ; \n avctx -> height = s -> height ; \n vp3_decode_init ( avctx ) ; \n return 0 ;", "idx": 15386}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "void av_opencl_uninit ( void ) \n { \n cl_int status ; \n int i ; \n LOCK_OPENCL \n gpu_env . init_count -- ; \n if ( gpu_env . is_user_created ) \n goto end ; \n if ( ( gpu_env . init_count > 0 ) || ( gpu_env . kernel_count > 0 ) ) \n goto end ; \n for ( i = 0 ; i < gpu_env . program_count ; i ++ ) { \n if ( gpu_env . programs [ i ] ) { \n status = clReleaseProgram ( gpu_env . programs [ i ] ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n } \n gpu_env . programs [ i ] = NULL ; \n } \n } \n if ( gpu_env . command_queue ) { \n status = clReleaseCommandQueue ( gpu_env . command_queue ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n } \n gpu_env . command_queue = NULL ; \n } \n if ( gpu_env . context ) { \n status = clReleaseContext ( gpu_env . context ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n } \n gpu_env . context = NULL ; \n } \n av_freep ( & ( gpu_env . device_ids ) ) ; \n end : \n UNLOCK_OPENCL  \n }", "idx": 15393}
{"project": "FFmpeg", "commit_id": "2fbc759d08cae97f9361e464a685a149c9d12c72", "target": 1, "func": "static int dirac_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 15398}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void apply_mdct ( AC3EncodeContext * s ) \n { \n int blk , ch ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n const SampleType * input_samples = & s -> planar_samples [ ch ] [ blk * AC3_BLOCK_SIZE ] ; \n apply_window ( & s -> dsp , s -> windowed_samples , input_samples , s -> mdct . window , AC3_WINDOW_SIZE ) ; \n block -> exp_shift [ ch ] = normalize_samples ( s ) ; \n mdct512 ( & s -> mdct , block -> mdct_coef [ ch ] , s -> windowed_samples ) ; \n } \n } \n }", "idx": 15399}
{"project": "FFmpeg", "commit_id": "5331773cc33ba26b9e26ace643d926219e46a17b", "target": 0, "func": "static void read_id3 ( AVFormatContext * s , uint64_t id3pos ) \n { \n ID3v2ExtraMeta * id3v2_extra_meta = NULL ; \n if ( avio_seek ( s -> pb , id3pos , SEEK_SET ) < 0 ) \n return ; \n ff_id3v2_read ( s , ID3v2_DEFAULT_MAGIC , & id3v2_extra_meta ) ; \n if ( id3v2_extra_meta ) \n ff_id3v2_parse_apic ( s , & id3v2_extra_meta ) ; \n ff_id3v2_free_extra_meta ( & id3v2_extra_meta ) ; \n }", "idx": 15400}
{"project": "FFmpeg", "commit_id": "9cf0419bb1a2cf929dcf458d435ae3c3bfb5d3ab", "target": 0, "func": "static int mov_read_wave ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return -1 ; \n if ( st -> codec -> codec_id == CODEC_ID_QDM2 ) { \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata_size = atom . size ; \n st -> codec -> extradata = av_mallocz ( st -> codec -> extradata_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( st -> codec -> extradata ) { \n get_buffer ( pb , st -> codec -> extradata , atom . size ) ; \n } else \n url_fskip ( pb , atom . size ) ; \n } else if ( atom . size > 8 ) { \n mov_read_default ( c , pb , atom ) ; \n } else \n url_fskip ( pb , atom . size ) ; \n return 0 ; \n }", "idx": 15402}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vp8_idct_dc_add_c ( uint8_t * dst , DCTELEM block [ 16 ] , ptrdiff_t stride ) \n { \n int i , dc = ( block [ 0 ] + 4 ) >> 3 ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n block [ 0 ] = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dst [ 0 ] = cm [ dst [ 0 ] ] ; \n dst [ 1 ] = cm [ dst [ 1 ] ] ; \n dst [ 2 ] = cm [ dst [ 2 ] ] ; \n dst [ 3 ] = cm [ dst [ 3 ] ] ; \n dst += stride ; \n } \n }", "idx": 15407}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void print_sdp ( void ) \n { \n char sdp [ 16384 ] ; \n int i ; \n AVFormatContext * * avc = av_malloc ( sizeof ( * avc ) * nb_output_files ) ; \n if ( ! avc ) \n exit ( 1 ) ; \n for ( i = 0 ; i < nb_output_files ; i ++ ) \n avc [ i ] = output_files [ i ] -> ctx ; \n av_sdp_create ( avc , nb_output_files , sdp , sizeof ( sdp ) ) ; \n printf ( \" \\n \\n \" , sdp ) ; \n fflush ( stdout ) ; \n av_freep ( & avc ) ; \n }", "idx": 15410}
{"project": "FFmpeg", "commit_id": "0d194ee51ed477f843900e657a7edbcbecdffa42", "target": 0, "func": "static void vc1_decode_skip_blocks ( VC1Context * v ) \n { \n MpegEncContext * s = & v -> s ; \n ff_er_add_slice ( s , 0 , s -> start_mb_y , s -> mb_width - 1 , s -> end_mb_y - 1 , ER_MB_END ) ; \n s -> first_slice_line = 1 ; \n for ( s -> mb_y = s -> start_mb_y ; s -> mb_y < s -> end_mb_y ; s -> mb_y ++ ) { \n s -> mb_x = 0 ; \n ff_init_block_index ( s ) ; \n ff_update_block_index ( s ) ; \n if ( s -> last_picture . f . data [ 0 ] ) { \n memcpy ( s -> dest [ 0 ] , s -> last_picture . f . data [ 0 ] + s -> mb_y * 16 * s -> linesize , s -> linesize * 16 ) ; \n memcpy ( s -> dest [ 1 ] , s -> last_picture . f . data [ 1 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ; \n memcpy ( s -> dest [ 2 ] , s -> last_picture . f . data [ 2 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ; \n } \n ff_draw_horiz_band ( s , s -> mb_y * 16 , 16 ) ; \n s -> first_slice_line = 0 ; \n } \n s -> pict_type = AV_PICTURE_TYPE_P ; \n }", "idx": 15431}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int asf_write_header ( AVFormatContext * s ) \n { \n ASFContext * asf = s -> priv_data ; \n asf -> packet_size = PACKET_SIZE ; \n asf -> nb_packets = 0 ; \n asf -> last_indexed_pts = 0 ; \n asf -> index_ptr = ( ASFIndex * ) av_malloc ( sizeof ( ASFIndex ) * ASF_INDEX_BLOCK ) ; \n asf -> nb_index_memory_alloc = ASF_INDEX_BLOCK ; \n asf -> nb_index_count = 0 ; \n asf -> maximum_packet = 0 ; \n if ( asf_write_header1 ( s , 0 , 50 ) < 0 ) { \n return -1 ; \n } \n put_flush_packet ( s -> pb ) ; \n asf -> packet_nb_payloads = 0 ; \n asf -> packet_timestamp_start = -1 ; \n asf -> packet_timestamp_end = -1 ; \n init_put_byte ( & asf -> pb , asf -> packet_buf , asf -> packet_size , 1 , \n NULL , NULL , NULL , NULL ) ; \n return 0 ; \n }", "idx": 15452}
{"project": "FFmpeg", "commit_id": "3e2b6358e0c9744aee2a024c2be8e51e8900b0b1", "target": 0, "func": "int get_buffer ( ByteIOContext * s , unsigned char * buf , int size ) \n { \n int len , size1 ; \n size1 = size ; \n while ( size > 0 ) { \n len = s -> buf_end - s -> buf_ptr ; \n if ( len > size ) \n len = size ; \n if ( len == 0 ) { \n fill_buffer ( s ) ; \n len = s -> buf_end - s -> buf_ptr ; \n if ( len == 0 ) \n break ; \n } else { \n memcpy ( buf , s -> buf_ptr , len ) ; \n buf += len ; \n s -> buf_ptr += len ; \n size -= len ; \n } \n } \n return size1 - size ; \n }", "idx": 15497}
{"project": "FFmpeg", "commit_id": "c3bd1d60af97e8d2568dac9fcce7bdabb4ff93c8", "target": 0, "func": "AVFilterFormats * ff_make_format_list ( const int * fmts ) \n { \n AVFilterFormats * formats ; \n int count ; \n for ( count = 0 ; fmts [ count ] != -1 ; count ++ ) \n ; \n formats = av_mallocz ( sizeof ( * formats ) ) ; \n if ( count ) \n formats -> formats = av_malloc ( sizeof ( * formats -> formats ) * count ) ; \n formats -> nb_formats = count ; \n memcpy ( formats -> formats , fmts , sizeof ( * formats -> formats ) * count ) ; \n return formats ; \n }", "idx": 15498}
{"project": "FFmpeg", "commit_id": "6f1ccca4ae3b93b6a2a820a7a0e72081ab35767c", "target": 0, "func": "static int dnxhd_decode_dct_block_10_444 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n return dnxhd_decode_dct_block ( ctx , row , n , 6 , 32 , 6 ) ; \n }", "idx": 15505}
{"project": "FFmpeg", "commit_id": "3646ef6f7c0c02dc6d2f393f9fd0f6ebcbf15b44", "target": 0, "func": "static int h264_probe ( AVProbeData * p ) \n { \n uint32_t code = -1 ; \n int sps = 0 , pps = 0 , idr = 0 , res = 0 , sli = 0 ; \n int i ; \n for ( i = 0 ; i < p -> buf_size ; i ++ ) { \n code = ( code << 8 ) + p -> buf [ i ] ; \n if ( ( code & 0xffffff00 ) == 0x100 ) { \n int ref_idc = ( code >> 5 ) & 3 ; \n int type = code & 0x1F ; \n static const int8_t ref_zero [ ] = { \n 2 , 0 , 0 , 0 , 0 , -1 , 1 , -1 , \n -1 , 1 , 1 , 1 , 1 , -1 , 2 , 2 , \n 2 , 2 , 2 , 0 , 2 , 2 , 2 , 2 , \n 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 \n } ; \n if ( code & 0x80 ) \n return 0 ; \n if ( ref_zero [ type ] == 1 && ref_idc ) \n return 0 ; \n if ( ref_zero [ type ] == -1 && ! ref_idc ) \n return 0 ; \n if ( ref_zero [ type ] == 2 ) { \n if ( ! ( code == 0x100 && ! p -> buf [ i + 1 ] && ! p -> buf [ i + 2 ] ) ) \n res ++ ; \n } \n switch ( type ) { \n case 1 : \n sli ++ ; \n break ; \n case 5 : \n idr ++ ; \n break ; \n case 7 : \n if ( p -> buf [ i + 2 ] & 0x03 ) \n return 0 ; \n sps ++ ; \n break ; \n case 8 : \n pps ++ ; \n break ; \n } \n } \n } \n ff_tlog ( NULL , \" \\n \" , sps , pps , idr , sli , res ) ; \n if ( sps && pps && ( idr || sli > 3 ) && res < ( sps + pps + idr ) ) \n return AVPROBE_SCORE_EXTENSION + 1 ; \n return 0 ; \n }", "idx": 15508}
{"project": "FFmpeg", "commit_id": "373211d828f351d86908d47828444f620bfd176d", "target": 0, "func": "static int mov_write_tapt_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int32_t width = av_rescale ( track -> enc -> sample_aspect_ratio . num , track -> enc -> width , \n track -> enc -> sample_aspect_ratio . den ) ; \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 20 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , width << 16 ) ; \n avio_wb32 ( pb , track -> enc -> height << 16 ) ; \n avio_wb32 ( pb , 20 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , track -> enc -> width << 16 ) ; \n avio_wb32 ( pb , track -> enc -> height << 16 ) ; \n return updateSize ( pb , pos ) ; \n } ;", "idx": 15509}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( rgb24ToUV_half ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , long width , uint32_t * unused ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src1 [ 6 * i + 0 ] + src1 [ 6 * i + 3 ] ; \n int g = src1 [ 6 * i + 1 ] + src1 [ 6 * i + 4 ] ; \n int b = src1 [ 6 * i + 2 ] + src1 [ 6 * i + 5 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << RGB2YUV_SHIFT ) ) >> ( RGB2YUV_SHIFT + 1 ) ; \n } \n }", "idx": 15510}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_licence ( void ) \n { \n printf ( \n \" \" FFMPEG_VERSION \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n ) ; \n exit ( 1 ) ; \n }", "idx": 15516}
{"project": "FFmpeg", "commit_id": "cd15b7c03d8df29d4c69b0620cf27d4a8c9dfb65", "target": 0, "func": "int av_samples_alloc ( uint8_t * * audio_data , int * linesize , int nb_channels , \n int nb_samples , enum AVSampleFormat sample_fmt , int align ) \n { \n uint8_t * buf ; \n int size = av_samples_get_buffer_size ( NULL , nb_channels , nb_samples , \n sample_fmt , align ) ; \n if ( size < 0 ) \n return size ; \n buf = av_mallocz ( size ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n size = av_samples_fill_arrays ( audio_data , linesize , buf , nb_channels , \n nb_samples , sample_fmt , align ) ; \n if ( size < 0 ) { \n av_free ( buf ) ; \n return size ; \n } \n return 0 ; \n }", "idx": 15532}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static const OptionDef * find_option ( const OptionDef * po , const char * name ) \n { \n const char * p = strchr ( name , ' ' ) ; \n int len = p ? p - name : strlen ( name ) ; \n while ( po -> name != NULL ) { \n if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len ) \n break ; \n po ++ ; \n } \n return po ; \n }", "idx": 15543}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int set_string ( void * obj , const AVOption * o , const char * val , uint8_t * * dst ) \n { \n av_freep ( dst ) ; \n * dst = av_strdup ( val ) ; \n return 0 ; \n }", "idx": 15553}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int mkv_write_native_codecprivate ( AVFormatContext * s , \n AVCodecParameters * par , \n AVIOContext * dyn_cp ) \n { \n switch ( par -> codec_id ) { \n case AV_CODEC_ID_VORBIS : \n case AV_CODEC_ID_THEORA : \n return put_xiph_codecpriv ( s , dyn_cp , par ) ; \n case AV_CODEC_ID_FLAC : \n return put_flac_codecpriv ( s , dyn_cp , par ) ; \n case AV_CODEC_ID_WAVPACK : \n return put_wv_codecpriv ( dyn_cp , par ) ; \n case AV_CODEC_ID_H264 : \n return ff_isom_write_avcc ( dyn_cp , par -> extradata , \n par -> extradata_size ) ; \n case AV_CODEC_ID_HEVC : \n ff_isom_write_hvcc ( dyn_cp , par -> extradata , \n par -> extradata_size , 0 ) ; \n return 0 ; \n case AV_CODEC_ID_ALAC : \n if ( par -> extradata_size < 36 ) { \n av_log ( s , AV_LOG_ERROR , \n \" \" \n \" \" ) ; \n return AVERROR_INVALIDDATA ; \n } else \n avio_write ( dyn_cp , par -> extradata + 12 , \n par -> extradata_size - 12 ) ; \n break ; \n default : \n if ( par -> codec_id == AV_CODEC_ID_PRORES && \n ff_codec_get_id ( ff_codec_movvideo_tags , par -> codec_tag ) == AV_CODEC_ID_PRORES ) { \n avio_wl32 ( dyn_cp , par -> codec_tag ) ; \n } else if ( par -> extradata_size && par -> codec_id != AV_CODEC_ID_TTA ) \n avio_write ( dyn_cp , par -> extradata , par -> extradata_size ) ; \n } \n return 0 ; \n }", "idx": 15554}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int avs_probe ( AVProbeData * p ) \n { \n const uint8_t * d ; \n if ( p -> buf_size < 2 ) \n return 0 ; \n d = p -> buf ; \n if ( d [ 0 ] == ' ' && d [ 1 ] == ' ' && d [ 2 ] == 0x10 && d [ 3 ] == 0 ) \n return 50 ; \n return 0 ; \n }", "idx": 15568}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_blocks_ind ( ALSDecContext * ctx , unsigned int ra_frame , \n unsigned int c , const unsigned int * div_blocks , \n unsigned int * js_blocks ) \n { \n unsigned int b ; \n ALSBlockData bd = { 0 } ; \n bd . ra_block = ra_frame ; \n bd . const_block = ctx -> const_block ; \n bd . shift_lsbs = ctx -> shift_lsbs ; \n bd . opt_order = ctx -> opt_order ; \n bd . store_prev_samples = ctx -> store_prev_samples ; \n bd . use_ltp = ctx -> use_ltp ; \n bd . ltp_lag = ctx -> ltp_lag ; \n bd . ltp_gain = ctx -> ltp_gain [ 0 ] ; \n bd . quant_cof = ctx -> quant_cof [ 0 ] ; \n bd . lpc_cof = ctx -> lpc_cof [ 0 ] ; \n bd . prev_raw_samples = ctx -> prev_raw_samples ; \n bd . raw_samples = ctx -> raw_samples [ c ] ; \n for ( b = 0 ; b < ctx -> num_blocks ; b ++ ) { \n bd . block_length = div_blocks [ b ] ; \n if ( read_decode_block ( ctx , & bd ) ) { \n zero_remaining ( b , ctx -> num_blocks , div_blocks , bd . raw_samples ) ; \n return -1 ; \n } \n bd . raw_samples += div_blocks [ b ] ; \n bd . ra_block = 0 ; \n } \n return 0 ; \n }", "idx": 15575}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( bgr16ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d = ( ( uint16_t * ) src ) [ i ] ; \n int b = d & 0x1F ; \n int g = ( d >> 5 ) & 0x3F ; \n int r = ( d >> 11 ) & 0x1F ; \n dst [ i ] = ( ( 2 * RY * r + GY * g + 2 * BY * b ) >> ( RGB2YUV_SHIFT - 2 ) ) + 16 ; \n } \n }", "idx": 15581}
{"project": "FFmpeg", "commit_id": "b46dcd5209a77254345ae098b83a872634c5591b", "target": 1, "func": "static int check_timecode ( void * log_ctx , AVTimecode * tc ) \n { \n if ( tc -> fps <= 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ( tc -> flags & AV_TIMECODE_FLAG_DROPFRAME ) && tc -> fps != 30 && tc -> fps != 60 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( check_fps ( tc -> fps ) < 0 ) { \n av_log ( log_ctx , AV_LOG_WARNING , \" \\n \" , \n tc -> rate . num , tc -> rate . den ) ; \n } \n return 0 ; \n }", "idx": 15591}
{"project": "FFmpeg", "commit_id": "d55f83de4d419d22d2fd2c0b9ff4ce6bf93847d6", "target": 0, "func": "static inline void quantize_coefs ( double * coef , int * idx , float * lpc , int order , \n int c_bits ) \n { \n int i ; \n const float * quant_arr = tns_tmp2_map [ c_bits ] ; \n for ( i = 0 ; i < order ; i ++ ) { \n idx [ i ] = quant_array_idx ( ( float ) coef [ i ] , quant_arr , c_bits ? 16 : 8 ) ; \n lpc [ i ] = quant_arr [ idx [ i ] ] ; \n } \n }", "idx": 15605}
{"project": "FFmpeg", "commit_id": "7ccc0ed6a0cedbe80443779a805ec90335cd832f", "target": 0, "func": "static uint64_t get_fourcc ( AVIOContext * bc ) \n { \n unsigned int len = ffio_read_varlen ( bc ) ; \n if ( len == 2 ) \n return avio_rl16 ( bc ) ; \n else if ( len == 4 ) \n return avio_rl32 ( bc ) ; \n else \n return -1 ; \n }", "idx": 15611}
{"project": "FFmpeg", "commit_id": "d1a4544de904cc76fea32d9d22252152ebb18edb", "target": 0, "func": "static int ac3_probe ( AVProbeData * p ) \n { \n int max_frames , first_frames = 0 , frames ; \n uint8_t * buf , * buf2 , * end ; \n AC3HeaderInfo hdr ; \n if ( p -> buf_size < 7 ) \n return 0 ; \n max_frames = 0 ; \n buf = p -> buf ; \n end = buf + p -> buf_size ; \n for ( ; buf < end ; buf ++ ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n if ( ff_ac3_parse_header ( buf2 , & hdr ) < 0 ) \n break ; \n buf2 += hdr . frame_size ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == p -> buf ) \n first_frames = frames ; \n } \n if ( first_frames >= 3 ) return AVPROBE_SCORE_MAX * 3 / 4 ; \n else if ( max_frames >= 3 ) return AVPROBE_SCORE_MAX / 2 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 15616}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "int init_put_byte ( ByteIOContext * s , \n unsigned char * buffer , \n int buffer_size , \n int write_flag , \n void * opaque , \n int ( * read_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n void ( * write_packet ) ( void * opaque , uint8_t * buf , int buf_size ) , \n int ( * seek ) ( void * opaque , offset_t offset , int whence ) ) \n { \n s -> buffer = buffer ; \n s -> buffer_size = buffer_size ; \n s -> buf_ptr = buffer ; \n s -> write_flag = write_flag ; \n if ( ! s -> write_flag ) \n s -> buf_end = buffer ; \n else \n s -> buf_end = buffer + buffer_size ; \n s -> opaque = opaque ; \n s -> write_packet = write_packet ; \n s -> read_packet = read_packet ; \n s -> seek = seek ; \n s -> pos = 0 ; \n s -> must_flush = 0 ; \n s -> eof_reached = 0 ; \n s -> is_streamed = 0 ; \n s -> max_packet_size = 0 ; \n s -> checksum_ptr = NULL ; \n s -> update_checksum = NULL ; \n return 0 ; \n }", "idx": 15617}
{"project": "FFmpeg", "commit_id": "22a7e19b50cc1627dd16e22c5e89b1f92f1d0c0e", "target": 1, "func": "static int rawvideo_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int packet_size , ret , width , height ; \n AVStream * st = s -> streams [ 0 ] ; \n width = st -> codec -> width ; \n height = st -> codec -> height ; \n packet_size = avpicture_get_size ( st -> codec -> pix_fmt , width , height ) ; \n if ( packet_size < 0 ) \n return -1 ; \n ret = av_get_packet ( s -> pb , pkt , packet_size ) ; \n pkt -> pts = \n pkt -> dts = pkt -> pos / packet_size ; \n pkt -> stream_index = 0 ; \n if ( ret != packet_size ) \n return AVERROR ( EIO ) ; \n return 0 ; \n }", "idx": 15621}
{"project": "FFmpeg", "commit_id": "b6eaa3928e198554a3934dd5ad6eac4d16f27df2", "target": 1, "func": "void ff_h264_remove_all_refs ( H264Context * h ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n remove_long ( h , i , 0 ) ; \n } \n assert ( h -> long_ref_count == 0 ) ; \n if ( h -> short_ref_count && ! h -> last_pic_for_ec . f -> data [ 0 ] ) { \n ff_h264_unref_picture ( h , & h -> last_pic_for_ec ) ; \n if ( h -> short_ref [ 0 ] -> f -> buf [ 0 ] ) \n ff_h264_ref_picture ( h , & h -> last_pic_for_ec , h -> short_ref [ 0 ] ) ; \n } \n for ( i = 0 ; i < h -> short_ref_count ; i ++ ) { \n unreference_pic ( h , h -> short_ref [ i ] , 0 ) ; \n h -> short_ref [ i ] = NULL ; \n } \n h -> short_ref_count = 0 ; \n memset ( h -> default_ref , 0 , sizeof ( h -> default_ref ) ) ; \n }", "idx": 15624}
{"project": "FFmpeg", "commit_id": "ae100046ca32b0b83031a60d0c3cdfc5ceb9f874", "target": 0, "func": "int avpriv_exif_decode_ifd ( void * logctx , GetByteContext * gbytes , int le , \n int depth , AVDictionary * * metadata ) \n { \n int i , ret ; \n int entries ; \n entries = ff_tget_short ( gbytes , le ) ; \n if ( bytestream2_get_bytes_left ( gbytes ) < entries * 12 ) { \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < entries ; i ++ ) { \n if ( ( ret = exif_decode_tag ( logctx , gbytes , le , depth , metadata ) ) < 0 ) { \n return ret ; \n } \n } \n return ff_tget_long ( gbytes , le ) ; \n }", "idx": 15646}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x8_vertical_add ) ( uint8_t * pix , const int * block_offset , \n const int16_t * block , ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) \n FUNCC ( pred4x4_vertical_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 15657}
{"project": "FFmpeg", "commit_id": "dffae122d0f448029c30afc672233f114a3fe09c", "target": 1, "func": "static int decode_block ( MJpegDecodeContext * s , int16_t * block , int component , \n int dc_index , int ac_index , int16_t * quant_matrix ) \n { \n int code , i , j , level , val ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xfffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n val = val * quant_matrix [ 0 ] + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n i = 0 ; \n { OPEN_READER ( re , & s -> gb ) ; \n do { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 ) ; \n i += ( ( unsigned ) code ) >> 4 ; \n code &= 0xf ; \n if ( code ) { \n if ( code > MIN_CACHE_BITS - 16 ) \n UPDATE_CACHE ( re , & s -> gb ) ; \n { \n int cache = GET_CACHE ( re , & s -> gb ) ; \n int sign = ( ~ cache ) >> 31 ; \n level = ( NEG_USR32 ( sign ^ cache , code ) ^ sign ) - sign ; \n } \n LAST_SKIP_BITS ( re , & s -> gb , code ) ; \n if ( i > 63 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n j = s -> scantable . permutated [ i ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n } \n } while ( i < 63 ) ; \n CLOSE_READER ( re , & s -> gb ) ; } \n return 0 ; \n }", "idx": 15670}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_4x4_msa ( src - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 15676}
{"project": "FFmpeg", "commit_id": "719dbe86ea0e85b3b89f492c69e10bb0e733bcbb", "target": 0, "func": "static int h261_decode_picture_header ( H261Context * h ) \n { \n MpegEncContext * const s = & h -> s ; \n int format , i ; \n uint32_t startcode = 0 ; \n for ( i = get_bits_left ( & s -> gb ) ; i > 24 ; i -= 1 ) { \n startcode = ( ( startcode << 1 ) | get_bits ( & s -> gb , 1 ) ) & 0x000FFFFF ; \n if ( startcode == 0x10 ) \n break ; \n } \n if ( startcode != 0x10 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n i = get_bits ( & s -> gb , 5 ) ; \n if ( i < ( s -> picture_number & 31 ) ) \n i += 32 ; \n s -> picture_number = ( s -> picture_number & ~ 31 ) + i ; \n s -> avctx -> time_base = ( AVRational ) { 1001 , 30000 } ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits1 ( & s -> gb ) ; \n format = get_bits1 ( & s -> gb ) ; \n if ( format == 0 ) { \n s -> width = 176 ; \n s -> height = 144 ; \n s -> mb_width = 11 ; \n s -> mb_height = 9 ; \n } else { \n s -> width = 352 ; \n s -> height = 288 ; \n s -> mb_width = 22 ; \n s -> mb_height = 18 ; \n } \n s -> mb_num = s -> mb_width * s -> mb_height ; \n skip_bits1 ( & s -> gb ) ; \n skip_bits1 ( & s -> gb ) ; \n while ( get_bits1 ( & s -> gb ) != 0 ) \n skip_bits ( & s -> gb , 8 ) ; \n s -> pict_type = AV_PICTURE_TYPE_P ; \n h -> gob_number = 0 ; \n return 0 ; \n }", "idx": 15678}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void h261_decode_init_vlc ( H261Context * h ) { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_vlc ( & h261_mba_vlc , H261_MBA_VLC_BITS , 35 , \n h261_mba_bits , 1 , 1 , \n h261_mba_code , 1 , 1 ) ; \n init_vlc ( & h261_mtype_vlc , H261_MTYPE_VLC_BITS , 10 , \n h261_mtype_bits , 1 , 1 , \n h261_mtype_code , 1 , 1 ) ; \n init_vlc ( & h261_mv_vlc , H261_MV_VLC_BITS , 17 , \n & h261_mv_tab [ 0 ] [ 1 ] , 2 , 1 , \n & h261_mv_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & h261_cbp_vlc , H261_CBP_VLC_BITS , 63 , \n & h261_cbp_tab [ 0 ] [ 1 ] , 2 , 1 , \n & h261_cbp_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_rl ( & h261_rl_tcoeff ) ; \n init_vlc_rl ( & h261_rl_tcoeff ) ; \n } \n }", "idx": 15681}
{"project": "FFmpeg", "commit_id": "9351a156de724edb69ba6e1f05884fe806a13a21", "target": 1, "func": "static void decode_band_structure ( GetBitContext * gbc , int blk , int eac3 , \n int ecpl , int start_subband , int end_subband , \n const uint8_t * default_band_struct , \n int * num_bands , uint8_t * band_sizes ) \n { \n int subbnd , bnd , n_subbands , n_bands = 0 ; \n uint8_t bnd_sz [ 22 ] ; \n uint8_t coded_band_struct [ 22 ] ; \n const uint8_t * band_struct ; \n n_subbands = end_subband - start_subband ; \n if ( ! eac3 || get_bits1 ( gbc ) ) { \n for ( subbnd = 0 ; subbnd < n_subbands - 1 ; subbnd ++ ) { \n coded_band_struct [ subbnd ] = get_bits1 ( gbc ) ; \n } \n band_struct = coded_band_struct ; \n } else if ( ! blk ) { \n band_struct = & default_band_struct [ start_subband + 1 ] ; \n } else { \n return ; \n } \n if ( num_bands || band_sizes ) { \n n_bands = n_subbands ; \n bnd_sz [ 0 ] = ecpl ? 6 : 12 ; \n for ( bnd = 0 , subbnd = 1 ; subbnd < n_subbands ; subbnd ++ ) { \n int subbnd_size = ( ecpl && subbnd < 4 ) ? 6 : 12 ; \n if ( band_struct [ subbnd - 1 ] ) { \n n_bands -- ; \n bnd_sz [ bnd ] += subbnd_size ; \n } else { \n bnd_sz [ ++ bnd ] = subbnd_size ; \n } \n } \n } \n if ( num_bands ) \n * num_bands = n_bands ; \n if ( band_sizes ) \n memcpy ( band_sizes , bnd_sz , n_bands ) ; \n }", "idx": 15688}
{"project": "FFmpeg", "commit_id": "b4330a0e02fcbef61d630a369abe5f4421ced659", "target": 0, "func": "static int detect_stream_specific ( AVFormatContext * avf , int idx ) \n { \n ConcatContext * cat = avf -> priv_data ; \n AVStream * st = cat -> avf -> streams [ idx ] ; \n ConcatStream * cs = & cat -> cur_file -> streams [ idx ] ; \n AVBitStreamFilterContext * bsf ; \n int ret ; \n if ( cat -> auto_convert && st -> codecpar -> codec_id == AV_CODEC_ID_H264 && \n ( st -> codecpar -> extradata_size < 4 || AV_RB32 ( st -> codecpar -> extradata ) != 1 ) ) { \n av_log ( cat -> avf , AV_LOG_INFO , \n \" \\n \" ) ; \n if ( ! ( bsf = av_bitstream_filter_init ( \" \" ) ) ) { \n av_log ( avf , AV_LOG_ERROR , \" \" \n \" \\n \" ) ; \n return AVERROR_BSF_NOT_FOUND ; \n } \n cs -> bsf = bsf ; \n cs -> avctx = avcodec_alloc_context3 ( NULL ) ; \n if ( ! cs -> avctx ) \n return AVERROR ( ENOMEM ) ; \n av_freep ( & st -> codecpar -> extradata ) ; \n st -> codecpar -> extradata_size = 0 ; \n ret = avcodec_parameters_to_context ( cs -> avctx , st -> codecpar ) ; \n if ( ret < 0 ) { \n avcodec_free_context ( & cs -> avctx ) ; \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 15712}
{"project": "FFmpeg", "commit_id": "2578a546183da09d49d5bba8ab5e982dece1dede", "target": 0, "func": "void ff_rv10_encode_picture_header ( MpegEncContext * s , int picture_number ) \n { \n int full_frame = 0 ; \n avpriv_align_put_bits ( & s -> pb ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 1 , ( s -> pict_type == AV_PICTURE_TYPE_P ) ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n put_bits ( & s -> pb , 5 , s -> qscale ) ; \n if ( s -> pict_type == AV_PICTURE_TYPE_I ) { \n } \n if ( ! full_frame ) { \n put_bits ( & s -> pb , 6 , 0 ) ; \n put_bits ( & s -> pb , 6 , 0 ) ; \n put_bits ( & s -> pb , 12 , s -> mb_width * s -> mb_height ) ; \n } \n put_bits ( & s -> pb , 3 , 0 ) ; \n }", "idx": 15735}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "func": "int ff_cmap_read_palette ( AVCodecContext * avctx , uint32_t * pal ) \n { \n int count , i ; \n if ( avctx -> bits_per_coded_sample > 8 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n count = 1 << avctx -> bits_per_coded_sample ; \n if ( avctx -> extradata_size < count * 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( i = 0 ; i < count ; i ++ ) { \n pal [ i ] = 0xFF000000 | AV_RB24 ( avctx -> extradata + i * 3 ) ; \n } \n return 0 ; \n }", "idx": 15736}
{"project": "FFmpeg", "commit_id": "9fac508ca46f93450ec232299dfd15ac70b6f326", "target": 1, "func": "static inline int wnv1_get_code ( WNV1Context * w , int base_value ) \n { \n int v = get_vlc2 ( & w -> gb , code_vlc . table , CODE_VLC_BITS , 1 ) ; \n if ( v == 15 ) \n return ff_reverse [ get_bits ( & w -> gb , 8 - w -> shift ) ] ; \n else \n return base_value + ( ( v - 7 ) << w -> shift ) ; \n }", "idx": 15740}
{"project": "FFmpeg", "commit_id": "10931720cd55d83e0b933b8a9bb0795fd9e48875", "target": 1, "func": "int av_image_get_linesize ( enum PixelFormat pix_fmt , int width , int plane ) \n { \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n int max_step [ 4 ] ; \n int max_step_comp [ 4 ] ; \n int s ; \n if ( desc -> flags & PIX_FMT_BITSTREAM ) \n return ( width * ( desc -> comp [ 0 ] . step_minus1 + 1 ) + 7 ) >> 3 ; \n av_image_fill_max_pixsteps ( max_step , max_step_comp , desc ) ; \n s = ( max_step_comp [ plane ] == 1 || max_step_comp [ plane ] == 2 ) ? desc -> log2_chroma_w : 0 ; \n return max_step [ plane ] * ( ( ( width + ( 1 << s ) - 1 ) ) >> s ) ; \n }", "idx": 15743}
{"project": "FFmpeg", "commit_id": "078d43e23a7a3d64aafee8a58b380d3e139b3020", "target": 1, "func": "rdt_parse_packet ( AVFormatContext * ctx , PayloadContext * rdt , AVStream * st , \n AVPacket * pkt , uint32_t * timestamp , \n const uint8_t * buf , int len , uint16_t rtp_seq , int flags )  \n { \n int seq = 1 , res ; \n AVIOContext pb ; \n if ( ! rdt -> rmctx ) \n return AVERROR ( EINVAL ) ; \n if ( rdt -> audio_pkt_cnt == 0 ) { \n int pos ; \n ffio_init_context ( & pb , buf , len , 0 , NULL , NULL , NULL , NULL ) ; \n flags = ( flags & RTP_FLAG_KEY ) ? 2 : 0 ; \n res = ff_rm_parse_packet ( rdt -> rmctx , & pb , st , rdt -> rmst [ st -> index ] , len , pkt , \n & seq , flags , * timestamp ) ; \n pos = avio_tell ( & pb ) ; \n if ( res < 0 ) \n return res ; \n if ( res > 0 ) { \n if ( st -> codec -> codec_id == AV_CODEC_ID_AAC ) { \n memcpy ( rdt -> buffer , buf + pos , len - pos ) ; \n rdt -> rmctx -> pb = avio_alloc_context ( rdt -> buffer , len - pos , 0 , \n NULL , NULL , NULL , NULL ) ; \n } \n goto get_cache ; \n } \n } else { \n get_cache : \n rdt -> audio_pkt_cnt = \n ff_rm_retrieve_cache ( rdt -> rmctx , rdt -> rmctx -> pb , \n st , rdt -> rmst [ st -> index ] , pkt ) ; \n if ( rdt -> audio_pkt_cnt == 0 && \n st -> codec -> codec_id == AV_CODEC_ID_AAC ) \n av_freep ( & rdt -> rmctx -> pb ) ; \n } \n pkt -> stream_index = st -> index ; \n pkt -> pts = * timestamp ; \n return rdt -> audio_pkt_cnt > 0 ; \n }", "idx": 15744}
{"project": "FFmpeg", "commit_id": "7207dd8f829baee58b4df6c97c19ffde77039e8d", "target": 0, "func": "ff_rm_retrieve_cache ( AVFormatContext * s , AVIOContext * pb , \n AVStream * st , RMStream * ast , AVPacket * pkt )  \n { \n RMDemuxContext * rm = s -> priv_data ; \n assert ( rm -> audio_pkt_cnt > 0 ) ; \n if ( ast -> deint_id == DEINT_ID_VBRF || \n ast -> deint_id == DEINT_ID_VBRS ) \n av_get_packet ( pb , pkt , ast -> sub_packet_lengths [ ast -> sub_packet_cnt - rm -> audio_pkt_cnt ] ) ; \n else { \n av_new_packet ( pkt , st -> codec -> block_align ) ; \n memcpy ( pkt -> data , ast -> pkt . data + st -> codec -> block_align * \n ( ast -> sub_packet_h * ast -> audio_framesize / st -> codec -> block_align - rm -> audio_pkt_cnt ) , \n st -> codec -> block_align ) ; \n } \n rm -> audio_pkt_cnt -- ; \n if ( ( pkt -> pts = ast -> audiotimestamp ) != AV_NOPTS_VALUE ) { \n ast -> audiotimestamp = AV_NOPTS_VALUE ; \n pkt -> flags = AV_PKT_FLAG_KEY ; \n } else \n pkt -> flags = 0 ; \n pkt -> stream_index = st -> index ; \n return rm -> audio_pkt_cnt ; \n }", "idx": 15746}
{"project": "FFmpeg", "commit_id": "f92e1af844208eb34fc0cdb2e38959c3a92165c9", "target": 0, "func": "int av_bsf_send_packet ( AVBSFContext * ctx , AVPacket * pkt ) \n { \n if ( ! pkt ) { \n ctx -> internal -> eof = 1 ; \n return 0 ; \n } \n if ( ctx -> internal -> eof ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ctx -> internal -> buffer_pkt -> data || \n ctx -> internal -> buffer_pkt -> side_data_elems ) \n return AVERROR ( EAGAIN ) ; \n av_packet_move_ref ( ctx -> internal -> buffer_pkt , pkt ) ; \n return 0 ; \n }", "idx": 15747}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static int refresh_thread ( void * opaque ) \n { \n VideoState * is = opaque ; \n while ( ! is -> abort_request ) { \n SDL_Event event ; \n event . type = FF_REFRESH_EVENT ; \n event . user . data1 = opaque ; \n if ( ! is -> refresh && ( ! is -> paused || is -> force_refresh ) ) { \n is -> refresh = 1 ; \n SDL_PushEvent ( & event ) ; \n } \n av_usleep ( is -> audio_st && is -> show_mode != SHOW_MODE_VIDEO ? rdftspeed * 1000 : 5000 ) ; \n } \n return 0 ; \n }", "idx": 15749}
{"project": "FFmpeg", "commit_id": "3d7c84747d4b68f3929c98a6e09efea8e53634dc", "target": 0, "func": "void ff_hpeldsp_init_x86 ( HpelDSPContext * c , int flags ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( INLINE_MMX ( cpu_flags ) ) \n hpeldsp_init_mmx ( c , flags , cpu_flags ) ; \n if ( EXTERNAL_MMXEXT ( cpu_flags ) ) \n hpeldsp_init_mmxext ( c , flags , cpu_flags ) ; \n if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) \n hpeldsp_init_3dnow ( c , flags , cpu_flags ) ; \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) \n hpeldsp_init_sse2 ( c , flags , cpu_flags ) ; \n }", "idx": 15751}
{"project": "FFmpeg", "commit_id": "53df079a730043cd0aa330c9aba7950034b1424f", "target": 1, "func": "static int alac_set_info ( ALACContext * alac ) \n { \n const unsigned char * ptr = alac -> avctx -> extradata ; \n ptr += 4 ; \n ptr += 4 ; \n ptr += 4 ; \n if ( AV_RB32 ( ptr ) >= UINT_MAX / 4 ) { \n av_log ( alac -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n alac -> setinfo_max_samples_per_frame = bytestream_get_be32 ( & ptr ) ; \n ptr ++ ; \n alac -> setinfo_sample_size = * ptr ++ ; \n alac -> setinfo_rice_historymult = * ptr ++ ; \n alac -> setinfo_rice_initialhistory = * ptr ++ ; \n alac -> setinfo_rice_kmodifier = * ptr ++ ; \n alac -> numchannels = * ptr ++ ; \n bytestream_get_be16 ( & ptr ) ; \n bytestream_get_be32 ( & ptr ) ; \n bytestream_get_be32 ( & ptr ) ; \n bytestream_get_be32 ( & ptr ) ; \n return 0 ; \n }", "idx": 15753}
{"project": "FFmpeg", "commit_id": "8540dcfd7af14da4080770dfbfa997cffdd0878b", "target": 1, "func": "static av_always_inline int check_4block_inter ( SnowContext * s , int mb_x , int mb_y , int p0 , int p1 , int ref , int * best_rd ) { \n const int b_stride = s -> b_width << s -> block_max_depth ; \n BlockNode * block = & s -> block [ mb_x + mb_y * b_stride ] ; \n BlockNode backup [ 4 ] = { block [ 0 ] , block [ 1 ] , block [ b_stride ] , block [ b_stride + 1 ] } ; \n int rd , index , value ; \n assert ( mb_x >= 0 && mb_y >= 0 ) ; \n assert ( mb_x < b_stride ) ; \n assert ( ( ( mb_x | mb_y ) & 1 ) == 0 ) ; \n index = ( p0 + 31 * p1 ) & ( ME_CACHE_SIZE - 1 ) ; \n value = s -> me_cache_generation + ( p0 >> 10 ) + ( p1 << 6 ) + ( block -> ref << 12 ) ; \n if ( s -> me_cache [ index ] == value ) \n return 0 ; \n s -> me_cache [ index ] = value ; \n block -> mx = p0 ; \n block -> my = p1 ; \n block -> ref = ref ; \n block -> type &= ~ BLOCK_INTRA ; \n block [ 1 ] = block [ b_stride ] = block [ b_stride + 1 ] = * block ; \n rd = get_4block_rd ( s , mb_x , mb_y , 0 ) ; \n if ( rd < * best_rd ) { \n * best_rd = rd ; \n return 1 ; \n } else { \n block [ 0 ] = backup [ 0 ] ; \n block [ 1 ] = backup [ 1 ] ; \n block [ b_stride ] = backup [ 2 ] ; \n block [ b_stride + 1 ] = backup [ 3 ] ; \n return 0 ; \n } \n }", "idx": 15759}
{"project": "FFmpeg", "commit_id": "c7269e3a2697c189c907832b8a36341cbb40936c", "target": 1, "func": "static int get_buffer ( AVCodecContext * avctx , AVFrame * pic ) \n { \n pic -> type = FF_BUFFER_TYPE_USER ; \n pic -> data [ 0 ] = ( void * ) 1 ; \n return 0 ; \n }", "idx": 15762}
{"project": "FFmpeg", "commit_id": "57623cba1301ee7874687dd7e04c611051638e9d", "target": 0, "func": "static enum AVPixelFormat webp_get_format ( AVCodecContext * avctx , \n const enum AVPixelFormat * formats ) \n { \n WebPContext * s = avctx -> priv_data ; \n if ( s -> has_alpha ) \n return AV_PIX_FMT_YUVA420P ; \n else \n return AV_PIX_FMT_YUV420P ; \n }", "idx": 15803}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static void coded_frame_add ( void * list , struct FrameListData * cx_frame ) \n { \n struct FrameListData * * p = list ; \n while ( * p != NULL ) \n p = & ( * p ) -> next ; \n * p = cx_frame ; \n cx_frame -> next = NULL ; \n }", "idx": 15805}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static inline int coef_test_compression ( int coef ) \n { \n int tmp = coef >> 2 ; \n int res = ff_ctz ( tmp ) ; \n if ( res > 1 ) \n return 1 ; \n else if ( res == 1 ) \n return 0 ; \n else if ( ff_ctz ( tmp >> 1 ) > 0 ) \n return 0 ; \n else \n return 1 ; \n }", "idx": 15809}
{"project": "FFmpeg", "commit_id": "0ab00a75e41f4399126777e49385c809d8fcc311", "target": 0, "func": "static enum AVPixelFormat dshow_pixfmt ( DWORD biCompression , WORD biBitCount ) \n { \n switch ( biCompression ) { \n case BI_BITFIELDS : \n case BI_RGB : \n switch ( biBitCount ) { \n case 1 : \n return AV_PIX_FMT_MONOWHITE ; \n case 4 : \n return AV_PIX_FMT_RGB4 ; \n case 8 : \n return AV_PIX_FMT_RGB8 ; \n case 16 : \n return AV_PIX_FMT_RGB555 ; \n case 24 : \n return AV_PIX_FMT_BGR24 ; \n case 32 : \n return AV_PIX_FMT_0RGB32 ; \n } \n } \n return avpriv_find_pix_fmt ( ff_raw_pix_fmt_tags , biCompression ) ; \n }", "idx": 15842}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void decode_scaling_list ( H264Context * h , uint8_t * factors , int size , \n const uint8_t * jvt_list , \n const uint8_t * fallback_list ) \n { \n int i , last = 8 , next = 8 ; \n const uint8_t * scan = size == 16 ? ff_zigzag_scan : ff_zigzag_direct ; \n if ( ! get_bits1 ( & h -> gb ) ) \n memcpy ( factors , fallback_list , size * sizeof ( uint8_t ) ) ; \n else \n for ( i = 0 ; i < size ; i ++ ) { \n if ( next ) \n next = ( last + get_se_golomb ( & h -> gb ) ) & 0xff ; \n if ( ! i && ! next ) { \n memcpy ( factors , jvt_list , size * sizeof ( uint8_t ) ) ; \n break ; \n } \n last = factors [ scan [ i ] ] = next ? next : last ; \n } \n }", "idx": 15843}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int svq1_encode_end ( AVCodecContext * avctx ) \n { \n SVQ1EncContext * const s = avctx -> priv_data ; \n int i ; \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , \n s -> rd_total / ( double ) ( avctx -> width * avctx -> height * \n avctx -> frame_number ) ) ; \n s -> m . mb_type = NULL ; \n ff_mpv_common_end ( & s -> m ) ; \n av_freep ( & s -> m . me . scratchpad ) ; \n av_freep ( & s -> m . me . map ) ; \n av_freep ( & s -> m . me . score_map ) ; \n av_freep ( & s -> mb_type ) ; \n av_freep ( & s -> dummy ) ; \n av_freep ( & s -> scratchbuf ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n av_freep ( & s -> motion_val8 [ i ] ) ; \n av_freep ( & s -> motion_val16 [ i ] ) ; \n } \n av_frame_free ( & s -> current_picture ) ; \n av_frame_free ( & s -> last_picture ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 15854}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline int small_diamond_search ( MpegEncContext * s , int * best , int dmin , \n UINT8 * new_pic , UINT8 * old_pic , int pic_stride , \n int pred_x , int pred_y , UINT16 * mv_penalty , int quant , \n int xmin , int ymin , int xmax , int ymax , int shift ) \n { \n int next_dir = -1 ; \n for ( ; ; ) { \n int d ; \n const int dir = next_dir ; \n const int x = best [ 0 ] ; \n const int y = best [ 1 ] ; \n next_dir = -1 ; \n if ( dir != 2 && x > xmin ) CHECK_MV_DIR ( x - 1 , y , 0 )  \n if ( dir != 3 && y > ymin ) CHECK_MV_DIR ( x , y - 1 , 1 )  \n if ( dir != 0 && x < xmax ) CHECK_MV_DIR ( x + 1 , y , 2 )  \n if ( dir != 1 && y < ymax ) CHECK_MV_DIR ( x , y + 1 , 3 )  \n if ( next_dir == -1 ) { \n return dmin ; \n } \n } \n }", "idx": 15870}
{"project": "FFmpeg", "commit_id": "bf51fcd304d5594a4d8eed2bedf0ef0f68fa65f8", "target": 0, "func": "static int mjpeg_probe ( AVProbeData * p ) \n { \n int i ; \n int state = -1 ; \n int nb_invalid = 0 ; \n int nb_frames = 0 ; \n for ( i = 0 ; i < p -> buf_size - 2 ; i ++ ) { \n int c ; \n if ( p -> buf [ i ] != 0xFF ) \n continue ; \n c = p -> buf [ i + 1 ] ; \n switch ( c ) { \n case 0xD8 : \n state = 0xD8 ; \n break ; \n case 0xC0 : \n case 0xC1 : \n case 0xC2 : \n case 0xC3 : \n case 0xC5 : \n case 0xC6 : \n case 0xC7 : \n case 0xF7 : \n if ( state == 0xD8 ) { \n state = 0xC0 ; \n } else \n nb_invalid ++ ; \n break ; \n case 0xDA : \n if ( state == 0xC0 ) { \n state = 0xDA ; \n } else \n nb_invalid ++ ; \n break ; \n case 0xD9 : \n if ( state == 0xDA ) { \n state = 0xD9 ; \n nb_frames ++ ; \n } else \n nb_invalid ++ ; \n break ; \n default : \n if ( ( c >= 0x02 && c <= 0xBF ) \n || c == 0xC8 ) { \n nb_invalid ++ ; \n } \n } \n } \n if ( nb_invalid * 4 + 1 < nb_frames ) { \n static const char ct_jpeg [ ] = \" \\r \\n \\r \\n \\r \\n \" ; \n int i ; \n for ( i = 0 ; i < FFMIN ( p -> buf_size - sizeof ( ct_jpeg ) , 100 ) ; i ++ ) \n if ( ! memcmp ( p -> buf + i , ct_jpeg , sizeof ( ct_jpeg ) - 1 ) ) \n return AVPROBE_SCORE_EXTENSION ; \n if ( nb_invalid == 0 && nb_frames > 2 ) \n return AVPROBE_SCORE_EXTENSION / 2 ; \n return AVPROBE_SCORE_EXTENSION / 4 ; \n } \n return 0 ; \n }", "idx": 15881}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int ipmovie_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < IPMOVIE_SIGNATURE_SIZE ) \n return 0 ; \n if ( strncmp ( p -> buf , IPMOVIE_SIGNATURE , IPMOVIE_SIGNATURE_SIZE ) != 0 ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 15904}
{"project": "FFmpeg", "commit_id": "fb135139fd3992eb1f0eacc9cfd878e05b95ec46", "target": 0, "func": "enum AVCodecID ff_guess_image2_codec ( const char * filename ) \n { \n return av_str2id ( img_tags , filename ) ; \n }", "idx": 15908}
{"project": "FFmpeg", "commit_id": "965424dad112211fc5887d96bd093773c133416c", "target": 0, "func": "static int estimate_qp ( MpegEncContext * s , int dry_run ) { \n if ( s -> next_lambda ) { \n s -> current_picture_ptr -> quality = \n s -> current_picture . quality = s -> next_lambda ; \n if ( ! dry_run ) s -> next_lambda = 0 ; \n } else if ( ! s -> fixed_qscale ) { \n s -> current_picture_ptr -> quality = \n s -> current_picture . quality = ff_rate_estimate_qscale ( s , dry_run ) ; \n if ( s -> current_picture . quality < 0 ) \n return -1 ; \n } \n if ( s -> adaptive_quant ) { \n switch ( s -> codec_id ) { \n case CODEC_ID_MPEG4 : \n if ( CONFIG_MPEG4_ENCODER ) \n ff_clean_mpeg4_qscales ( s ) ; \n break ; \n case CODEC_ID_H263 : \n case CODEC_ID_H263P : \n case CODEC_ID_FLV1 : \n if ( CONFIG_H263_ENCODER || CONFIG_H263P_ENCODER || CONFIG_FLV_ENCODER ) \n ff_clean_h263_qscales ( s ) ; \n break ; \n } \n s -> lambda = s -> lambda_table [ 0 ] ; \n } else \n s -> lambda = s -> current_picture . quality ; \n update_qscale ( s ) ; \n return 0 ; \n }", "idx": 15920}
{"project": "FFmpeg", "commit_id": "e3751aa6ec8147ab7ca2649d4daadf8d4dce27d5", "target": 0, "func": "static void do_hybrid_window ( int order , int n , int non_rec , const float * in , \n float * out , float * hist , float * out2 , \n const float * window ) \n { \n int i ; \n float buffer1 [ order + 1 ] ; \n float buffer2 [ order + 1 ] ; \n float work [ order + n + non_rec ] ; \n memmove ( hist , hist + n , ( order + non_rec ) * sizeof ( * hist ) ) ; \n for ( i = 0 ; i < n ; i ++ ) \n hist [ order + non_rec + i ] = in [ n - i - 1 ] ; \n colmult ( work , window , hist , order + n + non_rec ) ; \n convolve ( buffer1 , work + order , n , order ) ; \n convolve ( buffer2 , work + order + n , non_rec , order ) ; \n for ( i = 0 ; i <= order ; i ++ ) { \n out2 [ i ] = out2 [ i ] * 0.5625 + buffer1 [ i ] ; \n out [ i ] = out2 [ i ] + buffer2 [ i ] ; \n } \n * out *= 257. / 256. ; \n }", "idx": 15942}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "void ff_aac_encode_tns_info ( AACEncContext * s , SingleChannelElement * sce ) \n { \n int i , w , filt , coef_len , coef_compress ; \n const int coef_res = MAX_LPC_PRECISION == 4 ? 1 : 0 ; \n const int is8 = sce -> ics . window_sequence [ 0 ] == EIGHT_SHORT_SEQUENCE ; \n put_bits ( & s -> pb , 1 , ! ! sce -> tns . present ) ; \n if ( ! sce -> tns . present ) \n return ; \n for ( i = 0 ; i < sce -> ics . num_windows ; i ++ ) { \n put_bits ( & s -> pb , 2 - is8 , sce -> tns . n_filt [ i ] ) ; \n if ( sce -> tns . n_filt [ i ] ) { \n put_bits ( & s -> pb , 1 , ! ! coef_res ) ; \n for ( filt = 0 ; filt < sce -> tns . n_filt [ i ] ; filt ++ ) { \n put_bits ( & s -> pb , 6 - 2 * is8 , sce -> tns . length [ i ] [ filt ] ) ; \n put_bits ( & s -> pb , 5 - 2 * is8 , sce -> tns . order [ i ] [ filt ] ) ; \n if ( sce -> tns . order [ i ] [ filt ] ) { \n coef_compress = compress_coef ( sce -> tns . coef_idx [ i ] [ filt ] , \n sce -> tns . order [ i ] [ filt ] ) ; \n put_bits ( & s -> pb , 1 , ! ! sce -> tns . direction [ i ] [ filt ] ) ; \n put_bits ( & s -> pb , 1 , ! ! coef_compress ) ; \n coef_len = coef_res + 3 - coef_compress ; \n for ( w = 0 ; w < sce -> tns . order [ i ] [ filt ] ; w ++ ) \n put_bits ( & s -> pb , coef_len , sce -> tns . coef_idx [ i ] [ filt ] [ w ] ) ; \n } \n } \n } \n } \n }", "idx": 15947}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "AVFilterBufferRef * avfilter_null_get_audio_buffer ( AVFilterLink * link , int perms , \n enum AVSampleFormat sample_fmt , int size , \n int64_t channel_layout , int packed ) \n { \n return avfilter_get_audio_buffer ( link -> dst -> outputs [ 0 ] , perms , sample_fmt , \n size , channel_layout , packed ) ; \n }", "idx": 15948}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_volume_init_x86 ( VolumeContext * vol ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n enum AVSampleFormat sample_fmt = av_get_packed_sample_fmt ( vol -> sample_fmt ) ; \n if ( sample_fmt == AV_SAMPLE_FMT_S16 ) { \n if ( EXTERNAL_SSE2 ( cpu_flags ) && vol -> volume_i < 32768 ) { \n vol -> scale_samples = ff_scale_samples_s16_sse2 ; \n vol -> samples_align = 8 ; \n } \n } else if ( sample_fmt == AV_SAMPLE_FMT_S32 ) { \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n vol -> scale_samples = ff_scale_samples_s32_sse2 ; \n vol -> samples_align = 4 ; \n } \n if ( EXTERNAL_SSSE3 ( cpu_flags ) && cpu_flags & AV_CPU_FLAG_ATOM ) { \n vol -> scale_samples = ff_scale_samples_s32_ssse3_atom ; \n vol -> samples_align = 4 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n vol -> scale_samples = ff_scale_samples_s32_avx ; \n vol -> samples_align = 8 ; \n } \n } \n }", "idx": 15956}
{"project": "FFmpeg", "commit_id": "6eda91ad54fd3214610edb1e4a5adb58806c243e", "target": 0, "func": "static void clear_program ( MpegTSContext * ts , unsigned int programid ) \n { \n int i ; \n clear_avprogram ( ts , programid ) ; \n for ( i = 0 ; i < ts -> nb_prg ; i ++ ) \n if ( ts -> prg [ i ] . id == programid ) \n ts -> prg [ i ] . nb_pids = 0 ; \n }", "idx": 15967}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static void jpeg2000_flush ( Jpeg2000DecoderContext * s ) \n { \n if ( * s -> buf == 0xff ) \n s -> buf ++ ; \n s -> bit_index = 8 ; \n s -> buf ++ ; \n }", "idx": 15968}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static int v4l2_receive_packet ( AVCodecContext * avctx , AVPacket * avpkt ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n V4L2Context * const capture = & s -> capture ; \n V4L2Context * const output = & s -> output ; \n int ret ; \n if ( s -> draining ) \n goto dequeue ; \n if ( ! output -> streamon ) { \n ret = ff_v4l2_context_set_status ( output , VIDIOC_STREAMON ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n } \n if ( ! capture -> streamon ) { \n ret = ff_v4l2_context_set_status ( capture , VIDIOC_STREAMON ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n } \n dequeue : \n return ff_v4l2_context_dequeue_packet ( capture , avpkt ) ; \n }", "idx": 15992}
{"project": "FFmpeg", "commit_id": "9bd4a9f4eec8c8843b54126253bb9d77af95bbb3", "target": 0, "func": "static int mov_rewrite_dvd_sub_extradata ( AVStream * st ) \n { \n char pal_s [ 256 ] ; \n char buf [ 256 ] ; \n int pal_s_pos = 0 ; \n uint8_t * src = st -> codec -> extradata ; \n int i ; \n if ( st -> codec -> extradata_size != 64 ) \n return 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n uint32_t yuv = AV_RB32 ( src + i * 4 ) ; \n uint32_t rgba = yuv_to_rgba ( yuv ) ; \n snprintf ( pal_s + pal_s_pos , sizeof ( pal_s ) - pal_s_pos , \" \" , rgba , \n i != 15 ? \" \" : \" \" ) ; \n pal_s_pos = strlen ( pal_s ) ; \n if ( pal_s_pos >= sizeof ( pal_s ) ) \n return 0 ; \n } \n snprintf ( buf , sizeof ( buf ) , \" \\n \\n \" , \n st -> codec -> width , st -> codec -> height , pal_s ) ; \n av_freep ( & st -> codec -> extradata ) ; \n st -> codec -> extradata_size = 0 ; \n st -> codec -> extradata = av_mallocz ( strlen ( buf ) + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = strlen ( buf ) ; \n memcpy ( st -> codec -> extradata , buf , st -> codec -> extradata_size ) ; \n return 0 ; \n }", "idx": 15994}
{"project": "FFmpeg", "commit_id": "92b8c9d89e7ae86bffa05393bb230d5a165b0148", "target": 0, "func": "static int au_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n int ret ; \n ret = av_get_packet ( s -> pb , pkt , BLOCK_SIZE * \n s -> streams [ 0 ] -> codec -> channels * \n av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) >> 3 ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> flags &= ~ AV_PKT_FLAG_CORRUPT ; \n pkt -> stream_index = 0 ; \n return 0 ; \n }", "idx": 15996}
{"project": "FFmpeg", "commit_id": "898276c16b1683ac77723e97574a3bfdb29507fd", "target": 0, "func": "static int r3d_read_reda ( AVFormatContext * s , AVPacket * pkt , Atom * atom ) \n { \n AVStream * st = s -> streams [ 1 ] ; \n int av_unused tmp , tmp2 ; \n int samples , size ; \n uint64_t pos = avio_tell ( s -> pb ) ; \n unsigned dts ; \n int ret ; \n dts = avio_rb32 ( s -> pb ) ; \n st -> codec -> sample_rate = avio_rb32 ( s -> pb ) ; \n if ( st -> codec -> sample_rate <= 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n samples = avio_rb32 ( s -> pb ) ; \n tmp = avio_rb32 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n tmp = avio_rb16 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n tmp = avio_r8 ( s -> pb ) ; \n tmp2 = avio_r8 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp , tmp2 ) ; \n tmp = avio_rb32 ( s -> pb ) ; \n av_dlog ( s , \" \\n \" , tmp ) ; \n size = atom -> size - 8 - ( avio_tell ( s -> pb ) - pos ) ; \n if ( size < 0 ) \n return -1 ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n if ( ret < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n pkt -> stream_index = 1 ; \n pkt -> dts = dts ; \n pkt -> duration = av_rescale ( samples , st -> time_base . den , st -> codec -> sample_rate ) ; \n av_dlog ( s , \" \" PRId64 \" \\n \" , \n pkt -> dts , pkt -> duration , samples , st -> codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 15998}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb16tobgr32 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n #ifdef WORDS_BIGENDIAN \n * d ++ = 0 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n #else \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = 0 ; \n #endif \n } \n }", "idx": 16001}
{"project": "FFmpeg", "commit_id": "f707a5ebba734597b1ff0810931b55b630077ab3", "target": 1, "func": "static void ir2_decode_plane_inter ( Ir2Context * ctx , int width , int height , uint8_t * dst , int stride , \n const uint8_t * table ) \n { \n int j ; \n int out = 0 ; \n int c ; \n int t ; \n for ( j = 0 ; j < height ; j ++ ) { \n out = 0 ; \n while ( out < width ) { \n c = ir2_get_code ( & ctx -> gb ) ; \n if ( c > 0x80 ) { \n c -= 0x80 ; \n out += c * 2 ; \n } else { \n t = dst [ out ] + ( table [ c * 2 ] - 128 ) ; \n CLAMP_TO_BYTE ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n t = dst [ out ] + ( table [ ( c * 2 ) + 1 ] - 128 ) ; \n CLAMP_TO_BYTE ( t ) ; \n dst [ out ] = t ; \n out ++ ; \n } \n } \n dst += stride ; \n } \n }", "idx": 16002}
{"project": "FFmpeg", "commit_id": "4d7c71c36467331f1e0c0f17af9f371d33308a9c", "target": 1, "func": "int ff_audio_rechunk_interleave ( AVFormatContext * s , AVPacket * out , AVPacket * pkt , int flush , \n int ( * get_packet ) ( AVFormatContext * , AVPacket * , AVPacket * , int ) , \n int ( * compare_ts ) ( AVFormatContext * , AVPacket * , AVPacket * ) ) \n { \n int i ; \n if ( pkt ) { \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n unsigned new_size = av_fifo_size ( aic -> fifo ) + pkt -> size ; \n if ( new_size > aic -> fifo_size ) { \n if ( av_fifo_realloc2 ( aic -> fifo , new_size ) < 0 ) \n return -1 ; \n aic -> fifo_size = new_size ; \n } \n av_fifo_generic_write ( aic -> fifo , pkt -> data , pkt -> size , NULL ) ; \n } else { \n pkt -> pts = pkt -> dts = aic -> dts ; \n aic -> dts += pkt -> duration ; \n ff_interleave_add_packet ( s , pkt , compare_ts ) ; \n } \n pkt = NULL ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n AVPacket new_pkt ; \n while ( ff_interleave_new_audio_packet ( s , & new_pkt , i , flush ) ) \n ff_interleave_add_packet ( s , & new_pkt , compare_ts ) ; \n } \n } \n return get_packet ( s , out , pkt , flush ) ; \n }", "idx": 16005}
{"project": "FFmpeg", "commit_id": "d8173f264f732a4d14220816de2e54642115e2a7", "target": 0, "func": "static int dv_read_timecode ( AVFormatContext * s ) { \n int ret ; \n char timecode [ AV_TIMECODE_STR_SIZE ] ; \n int64_t pos = avio_tell ( s -> pb ) ; \n int partial_frame_size = 3 * 80 ; \n uint8_t * partial_frame = av_mallocz ( sizeof ( * partial_frame ) * \n partial_frame_size ) ; \n RawDVContext * c = s -> priv_data ; \n ret = avio_read ( s -> pb , partial_frame , partial_frame_size ) ; \n if ( ret < 0 ) \n goto finish ; \n if ( ret < partial_frame_size ) { \n ret = -1 ; \n goto finish ; \n } \n ret = dv_extract_timecode ( c -> dv_demux , partial_frame , timecode ) ; \n if ( ret ) \n av_dict_set ( & s -> metadata , \" \" , timecode , 0 ) ; \n else if ( ret < 0 ) \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n finish : \n av_free ( partial_frame ) ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n return ret ; \n }", "idx": 16031}
{"project": "FFmpeg", "commit_id": "d5a3578350a3901a26df39df196bb085760ec46f", "target": 1, "func": "static int svag_read_header ( AVFormatContext * s ) \n { \n unsigned size , align ; \n AVStream * st ; \n avio_skip ( s -> pb , 4 ) ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n size = avio_rl32 ( s -> pb ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codec -> codec_id = AV_CODEC_ID_ADPCM_PSX ; \n st -> codec -> sample_rate = avio_rl32 ( s -> pb ) ; \n if ( st -> codec -> sample_rate <= 0 ) \n return AVERROR_INVALIDDATA ; \n st -> codec -> channels = avio_rl32 ( s -> pb ) ; \n if ( st -> codec -> channels <= 0 ) \n return AVERROR_INVALIDDATA ; \n st -> duration = size / ( 16 * st -> codec -> channels ) * 28 ; \n align = avio_rl32 ( s -> pb ) ; \n if ( align <= 0 || align > INT_MAX / st -> codec -> channels ) \n return AVERROR_INVALIDDATA ; \n st -> codec -> block_align = align * st -> codec -> channels ; \n avio_skip ( s -> pb , 0x800 - avio_tell ( s -> pb ) ) ; \n avpriv_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 16049}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel4_mc12_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_4w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 4 , 0 ) ; \n }", "idx": 16059}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "enum AVCodecID avpriv_fmt_v4l2codec ( uint32_t v4l2_fmt ) \n { \n int i ; \n for ( i = 0 ; avpriv_fmt_conversion_table [ i ] . codec_id != AV_CODEC_ID_NONE ; i ++ ) { \n if ( avpriv_fmt_conversion_table [ i ] . v4l2_fmt == v4l2_fmt ) { \n return avpriv_fmt_conversion_table [ i ] . codec_id ; \n } \n } \n return AV_CODEC_ID_NONE ; \n }", "idx": 16060}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int alac_encode_close ( AVCodecContext * avctx ) \n { \n AlacEncodeContext * s = avctx -> priv_data ; \n ff_lpc_end ( & s -> lpc_ctx ) ; \n av_freep ( & avctx -> extradata ) ; \n avctx -> extradata_size = 0 ; \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 16062}
{"project": "FFmpeg", "commit_id": "ea7599ba8bbbf38ce958e5cdc621bd85b420826b", "target": 1, "func": "static int mp3_read_probe ( AVProbeData * p ) \n { \n int max_frames , first_frames ; \n int fsize , frames , sample_rate ; \n uint32_t header ; \n uint8_t * buf , * buf2 , * end ; \n AVCodecContext avctx ; \n if ( id3v2_match ( p -> buf ) ) \n return AVPROBE_SCORE_MAX / 2 + 1 ; \n max_frames = 0 ; \n buf = p -> buf ; \n end = buf + FFMIN ( 4096 , p -> buf_size - sizeof ( uint32_t ) ) ; \n for ( ; buf < end ; buf ++ ) { \n buf2 = buf ; \n for ( frames = 0 ; buf2 < end ; frames ++ ) { \n header = AV_RB32 ( buf2 ) ; \n fsize = ff_mpa_decode_header ( & avctx , header , & sample_rate ) ; \n if ( fsize < 0 ) \n break ; \n buf2 += fsize ; \n } \n max_frames = FFMAX ( max_frames , frames ) ; \n if ( buf == p -> buf ) \n first_frames = frames ; \n } \n if ( first_frames >= 3 ) return AVPROBE_SCORE_MAX / 2 + 1 ; \n else if ( max_frames >= 3 ) return AVPROBE_SCORE_MAX / 4 ; \n else if ( max_frames >= 1 ) return 1 ; \n else return 0 ; \n }", "idx": 16102}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_video_probe ( AVProbeData * pd ) \n { \n const uint8_t * p , * p_end ; \n int bits_per_pixel , has_global_palette , ext_code , ext_len ; \n int gce_flags , gce_disposal ; \n if ( pd -> buf_size < 24 || \n memcmp ( pd -> buf , gif89a_sig , 6 ) != 0 ) \n return 0 ; \n p_end = pd -> buf + pd -> buf_size ; \n p = pd -> buf + 6 ; \n bits_per_pixel = ( p [ 4 ] & 0x07 ) + 1 ; \n has_global_palette = ( p [ 4 ] & 0x80 ) ; \n p += 7 ; \n if ( has_global_palette ) \n p += ( 1 << bits_per_pixel ) * 3 ; \n for ( ; ; ) { \n if ( p >= p_end ) \n return 0 ; \n if ( * p != ' ' ) \n break ; \n p ++ ; \n if ( p >= p_end ) \n return 0 ; \n ext_code = * p ++ ; \n if ( p >= p_end ) \n return 0 ; \n ext_len = * p ++ ; \n if ( ext_code == 0xf9 ) { \n if ( p >= p_end ) \n return 0 ; \n gce_flags = * p ++ ; \n gce_disposal = ( gce_flags >> 2 ) & 0x7 ; \n if ( gce_disposal != 0 ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n } \n for ( ; ; ) { \n if ( ext_len == 0 ) \n break ; \n p += ext_len ; \n if ( p >= p_end ) \n return 0 ; \n ext_len = * p ++ ; \n } \n } \n return 0 ; \n }", "idx": 16104}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static void writer_print_time ( WriterContext * wctx , const char * key , \n int64_t ts , const AVRational * time_base , int is_duration ) \n { \n char buf [ 128 ] ; \n if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { \n writer_print_string ( wctx , key , \" \" , 1 ) ; \n } else { \n double d = ts * av_q2d ( * time_base ) ; \n struct unit_value uv ; \n uv . val . d = d ; \n uv . unit = unit_second_str ; \n value_string ( buf , sizeof ( buf ) , uv ) ; \n writer_print_string ( wctx , key , buf , 0 ) ; \n } \n }", "idx": 16106}
{"project": "FFmpeg", "commit_id": "3115550abe96de674dac42f02a0b464e137bfc20", "target": 1, "func": "static void fill_yuv_image ( AVFrame * pict , int frame_index , \n int width , int height ) \n { \n int x , y , i , ret ; \n ret = av_frame_make_writable ( pict ) ; \n if ( ret < 0 ) \n exit ( 1 ) ; \n i = frame_index ; \n for ( y = 0 ; y < height ; y ++ ) \n for ( x = 0 ; x < width ; x ++ ) \n pict -> data [ 0 ] [ y * pict -> linesize [ 0 ] + x ] = x + y + i * 3 ; \n for ( y = 0 ; y < height / 2 ; y ++ ) { \n for ( x = 0 ; x < width / 2 ; x ++ ) { \n pict -> data [ 1 ] [ y * pict -> linesize [ 1 ] + x ] = 128 + y + i * 2 ; \n pict -> data [ 2 ] [ y * pict -> linesize [ 2 ] + x ] = 64 + x + i * 5 ; \n } \n } \n }", "idx": 16107}
{"project": "FFmpeg", "commit_id": "7f9ec5593e04827249e7aeb466da06a98a0d7329", "target": 1, "func": "static int asf_read_marker ( AVFormatContext * s , int64_t size ) \n { \n AVIOContext * pb = s -> pb ; \n ASFContext * asf = s -> priv_data ; \n int i , count , name_len , ret ; \n char name [ 1024 ] ; \n avio_rl64 ( pb ) ; \n avio_rl64 ( pb ) ; \n count = avio_rl32 ( pb ) ; \n avio_rl16 ( pb ) ; \n name_len = avio_rl16 ( pb ) ; \n for ( i = 0 ; i < name_len ; i ++ ) \n avio_r8 ( pb ) ; \n for ( i = 0 ; i < count ; i ++ ) { \n int64_t pres_time ; \n int name_len ; \n avio_rl64 ( pb ) ; \n pres_time = avio_rl64 ( pb ) ; \n pres_time -= asf -> hdr . preroll * 10000 ; \n avio_rl16 ( pb ) ; \n avio_rl32 ( pb ) ; \n avio_rl32 ( pb ) ; \n name_len = avio_rl32 ( pb ) ; \n if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , \n sizeof ( name ) ) ) < name_len ) \n avio_skip ( pb , name_len - ret ) ; \n avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , \n AV_NOPTS_VALUE , name ) ; \n } \n return 0 ; \n }", "idx": 16128}
{"project": "FFmpeg", "commit_id": "6c9c8b06b32013c58101f27991eae251bf4eb485", "target": 0, "func": "static void eval_coefs ( int * coefs , const int * refl ) \n { \n int buffer [ 10 ] ; \n int * b1 = buffer ; \n int * b2 = coefs ; \n int x , y ; \n for ( x = 0 ; x < 10 ; x ++ ) { \n b1 [ x ] = refl [ x ] << 4 ; \n for ( y = 0 ; y < x ; y ++ ) \n b1 [ y ] = ( ( refl [ x ] * b2 [ x - y - 1 ] ) >> 12 ) + b2 [ y ] ; \n FFSWAP ( int * , b1 , b2 ) ; \n } \n for ( x = 0 ; x < 10 ; x ++ ) \n coefs [ x ] >>= 4 ; \n }", "idx": 16139}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "const char * small_strptime ( const char * p , const char * fmt , \n struct tm * dt ) \n { \n int c , val ; \n for ( ; ; ) { \n c = * fmt ++ ; \n if ( c == ' \\0 ' ) { \n return p ; \n } else if ( c == ' ' ) { \n c = * fmt ++ ; \n switch ( c ) { \n case ' ' : \n val = date_get_num ( & p , 0 , 23 , 2 ) ; \n if ( val == -1 ) \n return NULL ; \n dt -> tm_hour = val ; \n break ; \n case ' ' : \n val = date_get_num ( & p , 0 , 59 , 2 ) ; \n if ( val == -1 ) \n return NULL ; \n dt -> tm_min = val ; \n break ; \n case ' ' : \n val = date_get_num ( & p , 0 , 59 , 2 ) ; \n if ( val == -1 ) \n return NULL ; \n dt -> tm_sec = val ; \n break ; \n case ' ' : \n val = date_get_num ( & p , 0 , 9999 , 4 ) ; \n if ( val == -1 ) \n return NULL ; \n dt -> tm_year = val - 1900 ; \n break ; \n case ' ' : \n val = date_get_num ( & p , 1 , 12 , 2 ) ; \n if ( val == -1 ) \n return NULL ; \n dt -> tm_mon = val - 1 ; \n break ; \n case ' ' : \n val = date_get_num ( & p , 1 , 31 , 2 ) ; \n if ( val == -1 ) \n return NULL ; \n dt -> tm_mday = val ; \n break ; \n case ' ' : \n goto match ; \n default : \n return NULL ; \n } \n } else { \n match : \n if ( c != * p ) \n return NULL ; \n p ++ ; \n } \n } \n return p ; \n }", "idx": 16150}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_2r_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 4 ] [ i ] ) ; \n output [ 2 ] [ i ] += ( output [ 3 ] [ i ] + output [ 5 ] [ i ] ) ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n memset ( output [ 5 ] , 0 , sizeof ( output [ 5 ] ) ) ; \n }", "idx": 16161}
{"project": "FFmpeg", "commit_id": "61cec5adaacb358783c18aa07362f15824c1b274", "target": 1, "func": "void ff_tls_deinit ( void ) \n { \n #if CONFIG_TLS_OPENSSL_PROTOCOL  \n  \n  ff_openssl_deinit ( ) ; \n #endif \n #if CONFIG_TLS_GNUTLS_PROTOCOL  \n  \n  ff_gnutls_deinit ( ) ; \n #endif \n }", "idx": 16176}
{"project": "FFmpeg", "commit_id": "b7e506b3b9caf1d7b8b494f83a85c1b61be46993", "target": 1, "func": "static int swf_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 15 ) \n return 0 ; \n if ( AV_RB24 ( p -> buf ) != AV_RB24 ( \" \" ) \n && AV_RB24 ( p -> buf ) != AV_RB24 ( \" \" ) ) \n return 0 ; \n if ( p -> buf [ 3 ] >= 20 ) \n return AVPROBE_SCORE_MAX / 4 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 16188}
{"project": "FFmpeg", "commit_id": "1bab6f852c7ca433285d19f65c701885fa69cc57", "target": 1, "func": "static void RENAME ( yuv2yuyv422_1 ) ( SwsContext * c , const int16_t * buf0 , \n const int16_t * ubuf [ 2 ] , const int16_t * bguf [ 2 ] , \n const int16_t * abuf0 , uint8_t * dest , \n int dstW , int uvalpha , int y ) \n { \n const int16_t * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] ; \n const int16_t * buf1 = buf0 ; \n if ( uvalpha < 2048 ) { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED1 ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n } else { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2PACKED1b ( % % REGBP , % 5 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n } \n }", "idx": 16189}
{"project": "FFmpeg", "commit_id": "bd10f6e1492492b0dfddc7dd8773e782ccea6daf", "target": 1, "func": "static av_cold int g726_init ( AVCodecContext * avctx ) \n { \n G726Context * c = avctx -> priv_data ; \n unsigned int index = ( avctx -> bit_rate + avctx -> sample_rate / 2 ) / avctx -> sample_rate - 2 ; \n if ( avctx -> bit_rate % avctx -> sample_rate && avctx -> codec -> encode ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( index > 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , index + 2 ) ; \n return -1 ; \n } \n g726_reset ( c , index ) ; \n c -> code_size = index + 2 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> key_frame = 1 ; \n if ( avctx -> codec -> decode ) \n avctx -> sample_fmt = SAMPLE_FMT_S16 ; \n return 0 ; \n }", "idx": 16202}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static int parse_meter ( DBEContext * s ) \n { \n if ( s -> meter_size ) \n skip_input ( s , s -> key_present + s -> meter_size + 1 ) ; \n return 0 ; \n }", "idx": 16212}
{"project": "FFmpeg", "commit_id": "2f96cc1fc41f2d3a349d55f9d2078694a6a87dc1", "target": 1, "func": "int ff_rtsp_send_cmd_with_content ( AVFormatContext * s , \n const char * method , const char * url , \n const char * header , \n RTSPMessageHeader * reply , \n unsigned char * * content_ptr , \n const unsigned char * send_content , \n int send_content_length ) \n { \n RTSPState * rt = s -> priv_data ; \n HTTPAuthType cur_auth_type ; \n int ret ; \n retry : \n cur_auth_type = rt -> auth_state . auth_type ; \n if ( ( ret = ff_rtsp_send_cmd_with_content_async ( s , method , url , header , \n send_content , \n send_content_length ) ) ) \n return ret ; \n if ( ( ret = ff_rtsp_read_reply ( s , reply , content_ptr , 0 , method ) ) < 0 ) \n return ret ; \n if ( reply -> status_code == 401 && cur_auth_type == HTTP_AUTH_NONE && \n rt -> auth_state . auth_type != HTTP_AUTH_NONE ) \n goto retry ; \n if ( reply -> status_code > 400 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , \n method , \n reply -> status_code , \n reply -> reason ) ; \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , rt -> last_reply ) ; \n } \n return 0 ; \n }", "idx": 16219}
{"project": "FFmpeg", "commit_id": "892a4c2da8518aa5c86b6cfdd90a7f399a41c814", "target": 1, "func": "int ff_huff_build_tree ( AVCodecContext * avctx , VLC * vlc , int nb_codes , \n Node * nodes , huff_cmp_t cmp , int hnode_first ) \n { \n int i , j ; \n int cur_node ; \n int64_t sum = 0 ; \n for ( i = 0 ; i < nb_codes ; i ++ ) { \n nodes [ i ] . sym = i ; \n nodes [ i ] . n0 = -2 ; \n sum += nodes [ i ] . count ; \n } \n if ( sum >> 31 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n qsort ( nodes , nb_codes , sizeof ( Node ) , cmp ) ; \n cur_node = nb_codes ; \n for ( i = 0 ; i < nb_codes * 2 - 1 ; i += 2 ) { \n nodes [ cur_node ] . sym = HNODE ; \n nodes [ cur_node ] . count = nodes [ i ] . count + nodes [ i + 1 ] . count ; \n nodes [ cur_node ] . n0 = i ; \n for ( j = cur_node ; j > 0 ; j -- ) { \n if ( nodes [ j ] . count > nodes [ j - 1 ] . count || \n ( nodes [ j ] . count == nodes [ j - 1 ] . count && \n ( ! hnode_first || nodes [ j ] . n0 == j - 1 || nodes [ j ] . n0 == j - 2 || \n ( nodes [ j ] . sym != HNODE && nodes [ j - 1 ] . sym != HNODE ) ) ) ) \n break ; \n FFSWAP ( Node , nodes [ j ] , nodes [ j - 1 ] ) ; \n } \n cur_node ++ ; \n } \n if ( build_huff_tree ( vlc , nodes , nb_codes * 2 - 2 ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 16221}
{"project": "FFmpeg", "commit_id": "05a4bacbf7ece618553d339afe1d0b57bc87aea8", "target": 0, "func": "uint8_t * av_packet_new_side_data ( AVPacket * pkt , enum AVPacketSideDataType type , \n int size ) \n { \n int ret ; \n uint8_t * data ; \n if ( ( unsigned ) size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE ) \n return NULL ; \n data = av_malloc ( size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! data ) \n return NULL ; \n ret = av_packet_add_side_data ( pkt , type , data , size ) ; \n if ( ret < 0 ) { \n av_freep ( & data ) ; \n return NULL ; \n } \n return data ; \n }", "idx": 16222}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static unsigned tget_short ( const uint8_t * * p , int le ) \n { \n unsigned v = le ? AV_RL16 ( * p ) : AV_RB16 ( * p ) ; \n * p += 2 ; \n return v ; \n }", "idx": 16239}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int get_packetheader ( NUTContext * nut , ByteIOContext * bc , int prefix_length ) \n { \n int64_t start , size , last_size ; \n start = url_ftell ( bc ) - prefix_length ; \n if ( start != nut -> packet_start + nut -> written_packet_size ) { \n av_log ( nut -> avf , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n size = get_v ( bc ) ; \n last_size = get_v ( bc ) ; \n if ( nut -> written_packet_size != last_size ) { \n av_log ( nut -> avf , AV_LOG_ERROR , \" \\n \" , nut -> written_packet_size , last_size , start ) ; \n return -1 ; \n } \n nut -> last_packet_start = nut -> packet_start ; \n nut -> packet_start = start ; \n nut -> written_packet_size = size ; \n return size ; \n }", "idx": 16264}
{"project": "FFmpeg", "commit_id": "0871ae1a930122f7124358a0ce3caf81876913a9", "target": 1, "func": "int av_fifo_generic_read ( AVFifoBuffer * f , int buf_size , void ( * func ) ( void * , void * , int ) , void * dest ) \n { \n int size = av_fifo_size ( f ) ; \n if ( size < buf_size ) \n return -1 ; \n do { \n int len = FFMIN ( f -> end - f -> rptr , buf_size ) ; \n if ( func ) func ( dest , f -> rptr , len ) ; \n else { \n memcpy ( dest , f -> rptr , len ) ; \n dest = ( uint8_t * ) dest + len ; \n } \n av_fifo_drain ( f , len ) ; \n buf_size -= len ; \n } while ( buf_size > 0 ) ; \n return 0 ; \n }", "idx": 16291}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int cmp_pkt_sub_ts_pos ( const void * a , const void * b ) \n { \n const AVPacket * s1 = a ; \n const AVPacket * s2 = b ; \n if ( s1 -> pts == s2 -> pts ) { \n if ( s1 -> pos == s2 -> pos ) \n return 0 ; \n return s1 -> pos > s2 -> pos ? 1 : -1 ; \n } \n return s1 -> pts > s2 -> pts ? 1 : -1 ; \n }", "idx": 16292}
{"project": "FFmpeg", "commit_id": "cfda1bea4c18ec1edbc11ecc465f788b02851488", "target": 1, "func": "static int open_url ( HLSContext * c , URLContext * * uc , const char * url , AVDictionary * opts ) \n { \n AVDictionary * tmp = NULL ; \n int ret ; \n const char * proto_name = avio_find_protocol_name ( url ) ; \n if ( ! av_strstart ( proto_name , \" \" , NULL ) && ! av_strstart ( proto_name , \" \" , NULL ) ) \n return AVERROR_INVALIDDATA ; \n if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ' ' ) \n ; \n else if ( strcmp ( proto_name , \" \" ) || ! strcmp ( url , \" \" ) ) \n return AVERROR_INVALIDDATA ; \n av_dict_copy ( & tmp , c -> avio_opts , 0 ) ; \n av_dict_copy ( & tmp , opts , 0 ) ; \n ret = ffurl_open ( uc , url , AVIO_FLAG_READ , c -> interrupt_callback , & tmp ) ; \n if ( ret >= 0 ) { \n URLContext * u = * uc ; \n update_options ( & c -> cookies , \" \" , u -> priv_data ) ; \n av_dict_set ( & opts , \" \" , c -> cookies , 0 ) ; \n } \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 16298}
{"project": "FFmpeg", "commit_id": "cfd937b081adfa122e3f814b928c9ea0ada7f4f0", "target": 0, "func": "static void apply_dependent_coupling ( AACContext * ac , SingleChannelElement * target , ChannelElement * cce , int index ) { \n IndividualChannelStream * ics = & cce -> ch [ 0 ] . ics ; \n const uint16_t * offsets = ics -> swb_offset ; \n float * dest = target -> coeffs ; \n const float * src = cce -> ch [ 0 ] . coeffs ; \n int g , i , group , k , idx = 0 ; \n if ( ac -> m4ac . object_type == AOT_AAC_LTP ) { \n av_log ( ac -> avccontext , AV_LOG_ERROR , \n \" \\n \" ) ; \n return ; \n } \n for ( g = 0 ; g < ics -> num_window_groups ; g ++ ) { \n for ( i = 0 ; i < ics -> max_sfb ; i ++ , idx ++ ) { \n if ( cce -> ch [ 0 ] . band_type [ idx ] != ZERO_BT ) { \n for ( group = 0 ; group < ics -> group_len [ g ] ; group ++ ) { \n for ( k = offsets [ i ] ; k < offsets [ i + 1 ] ; k ++ ) { \n dest [ group * 128 + k ] += cce -> coup . gain [ index ] [ idx ] * src [ group * 128 + k ] ; \n } \n } \n } \n } \n dest += ics -> group_len [ g ] * 128 ; \n src += ics -> group_len [ g ] * 128 ; \n } \n }", "idx": 16311}
{"project": "FFmpeg", "commit_id": "1303d62d8416fa315a0cc7bbbe35cfdab787ea92", "target": 0, "func": "static int mpegts_resync ( ByteIOContext * pb ) \n { \n int c , i ; \n for ( i = 0 ; i < MAX_RESYNC_SIZE ; i ++ ) { \n c = url_fgetc ( pb ) ; \n if ( c < 0 ) \n return -1 ; \n if ( c == 0x47 ) { \n url_fseek ( pb , -1 , SEEK_CUR ) ; \n return 0 ; \n } \n } \n return -1 ; \n }", "idx": 16336}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "func": "static int write_header ( FlashSV2Context * s , uint8_t * buf , int buf_size ) \n { \n PutBitContext pb ; \n int buf_pos , len ; \n if ( buf_size < 5 ) \n return -1 ; \n init_put_bits ( & pb , buf , buf_size * 8 ) ; \n put_bits ( & pb , 4 , ( s -> block_width >> 4 ) - 1 ) ; \n put_bits ( & pb , 12 , s -> image_width ) ; \n put_bits ( & pb , 4 , ( s -> block_height >> 4 ) - 1 ) ; \n put_bits ( & pb , 12 , s -> image_height ) ; \n flush_put_bits ( & pb ) ; \n buf_pos = 4 ; \n buf [ buf_pos ++ ] = s -> flags ; \n if ( s -> flags & HAS_PALLET_INFO ) { \n len = write_palette ( s , buf + buf_pos , buf_size - buf_pos ) ; \n if ( len < 0 ) \n return -1 ; \n buf_pos += len ; \n } \n return buf_pos ; \n }", "idx": 16337}
{"project": "FFmpeg", "commit_id": "9e27e0d4f825e97104333e3006f450f566935af0", "target": 1, "func": "static void add_wav ( int16_t * dest , int n , int skip_first , int * m , \n const int16_t * s1 , const int8_t * s2 , const int8_t * s3 ) \n { \n int i ; \n int v [ 3 ] ; \n v [ 0 ] = 0 ; \n for ( i = ! skip_first ; i < 3 ; i ++ ) \n v [ i ] = ( gain_val_tab [ n ] [ i ] * m [ i ] ) >> gain_exp_tab [ n ] ; \n dest [ i ] = ( s1 [ i ] * v [ 0 ] + s2 [ i ] * v [ 1 ] + s3 [ i ] * v [ 2 ] ) >> 12 ; ", "idx": 16344}
{"project": "FFmpeg", "commit_id": "eae7338e1592f4a398b7c3cb9d1ac854b7a44ff8", "target": 1, "func": "static av_cold int X264_close ( AVCodecContext * avctx ) \n { \n X264Context * x4 = avctx -> priv_data ; \n av_freep ( & avctx -> extradata ) ; \n av_free ( x4 -> sei ) ; \n if ( x4 -> enc ) \n x264_encoder_close ( x4 -> enc ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 16347}
{"project": "FFmpeg", "commit_id": "f431315a866da9600e3eaa99fc54da1f554f170c", "target": 1, "func": "static int start_frame_overlay ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n OverlayContext * over = ctx -> priv ; \n inlink -> cur_buf = NULL ; \n over -> overpicref = inpicref ; \n over -> overpicref -> pts = av_rescale_q ( inpicref -> pts , ctx -> inputs [ OVERLAY ] -> time_base , \n ctx -> outputs [ 0 ] -> time_base ) ; \n return 0 ; \n }", "idx": 16354}
{"project": "FFmpeg", "commit_id": "43b434210e597d484aef57c4139c3126d22b7e2b", "target": 1, "func": "int ff_h264_execute_decode_slices ( H264Context * h , unsigned context_count ) \n { \n AVCodecContext * const avctx = h -> avctx ; \n H264SliceContext * sl ; \n int i ; \n av_assert0 ( context_count && h -> slice_ctx [ context_count - 1 ] . mb_y < h -> mb_height ) ; \n if ( h -> avctx -> hwaccel || \n h -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) \n return 0 ; \n if ( context_count == 1 ) { \n int ret = decode_slice ( avctx , & h -> slice_ctx [ 0 ] ) ; \n h -> mb_y = h -> slice_ctx [ 0 ] . mb_y ; \n return ret ; \n } else { \n av_assert0 ( context_count > 0 ) ; \n for ( i = 1 ; i < context_count ; i ++ ) { \n sl = & h -> slice_ctx [ i ] ; \n if ( CONFIG_ERROR_RESILIENCE ) { \n sl -> er . error_count = 0 ; \n } \n } \n avctx -> execute ( avctx , decode_slice , h -> slice_ctx , \n NULL , context_count , sizeof ( h -> slice_ctx [ 0 ] ) ) ; \n sl = & h -> slice_ctx [ context_count - 1 ] ; \n h -> mb_y = sl -> mb_y ; \n if ( CONFIG_ERROR_RESILIENCE ) { \n for ( i = 1 ; i < context_count ; i ++ ) \n h -> slice_ctx [ 0 ] . er . error_count += h -> slice_ctx [ i ] . er . error_count ; \n } \n } \n return 0 ; \n }", "idx": 16373}
{"project": "FFmpeg", "commit_id": "c4c3a3d580fa2f9d65af3fb6027ffbf9a28e9d55", "target": 1, "func": "static int filter_packet ( void * log_ctx , AVPacket * pkt , \n AVFormatContext * fmt_ctx , AVBitStreamFilterContext * bsf_ctx ) \n { \n AVCodecContext * enc_ctx = fmt_ctx -> streams [ pkt -> stream_index ] -> codec ; \n int ret ; \n while ( bsf_ctx ) { \n AVPacket new_pkt = * pkt ; \n ret = av_bitstream_filter_filter ( bsf_ctx , enc_ctx , NULL , \n & new_pkt . data , & new_pkt . size , \n pkt -> data , pkt -> size , \n pkt -> flags & AV_PKT_FLAG_KEY ) ; \n if ( ret == 0 && new_pkt . data != pkt -> data && new_pkt . destruct ) { \n if ( ( ret = av_copy_packet ( & new_pkt , pkt ) ) < 0 ) \n break ; \n ret = 1 ; \n } \n if ( ret > 0 ) { \n av_free_packet ( pkt ) ; \n new_pkt . buf = av_buffer_create ( new_pkt . data , new_pkt . size , \n av_buffer_default_free , NULL , 0 ) ; \n if ( ! new_pkt . buf ) \n break ; \n } \n * pkt = new_pkt ; \n bsf_ctx = bsf_ctx -> next ; \n } \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , \n bsf_ctx -> filter -> name , pkt -> stream_index , fmt_ctx -> filename , \n avcodec_get_name ( enc_ctx -> codec_id ) ) ; \n } \n return ret ; \n }", "idx": 16379}
{"project": "FFmpeg", "commit_id": "474d858fd9551b45a17e1f3a4322de1a88e749b9", "target": 0, "func": "static int get_port ( const struct sockaddr_storage * ss ) \n { \n sockaddr_union ssu = ( sockaddr_union ) { . storage = * ss } ; \n if ( ss -> ss_family == AF_INET ) \n return ntohs ( ssu . in . sin_port ) ; \n #if HAVE_STRUCT_SOCKADDR_IN6  \n  \n  if ( ss -> ss_family == AF_INET6 ) \n return ntohs ( ssu . in6 . sin6_port ) ; \n #endif \n return 0 ; \n }", "idx": 16388}
{"project": "FFmpeg", "commit_id": "631c56a8e46dea41585f3e7b3ef9c52b49faa385", "target": 0, "func": "int avformat_network_deinit ( void ) \n { \n #if CONFIG_NETWORK  \n  \n  ff_network_close ( ) ; \n ff_tls_deinit ( ) ; \n ff_network_inited_globally = 0 ; \n #endif \n return 0 ; \n }", "idx": 16389}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel8_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_and_aver_dst_8x8_msa ( src - ( stride * 2 ) , stride , dst , stride ) ; \n }", "idx": 16390}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static int dvvideo_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 16401}
{"project": "FFmpeg", "commit_id": "6770a9d6898a0c7561586dabd7a4e5b5187bed62", "target": 1, "func": "static OutputStream * choose_output ( void ) \n { \n int i ; \n int64_t opts_min = INT64_MAX ; \n OutputStream * ost_min = NULL ; \n for ( i = 0 ; i < nb_output_streams ; i ++ ) { \n OutputStream * ost = output_streams [ i ] ; \n int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , \n AV_TIME_BASE_Q ) ; \n if ( ! ost -> finished && opts < opts_min ) { \n opts_min = opts ; \n ost_min = ost -> unavailable ? NULL : ost ; \n } \n } \n return ost_min ; \n }", "idx": 16429}
{"project": "FFmpeg", "commit_id": "8c50704ebf1777bee76772c4835d9760b3721057", "target": 1, "func": "static av_always_inline int setup_classifs ( vorbis_context * vc , \n vorbis_residue * vr , \n uint8_t * do_not_decode , \n unsigned ch_used , \n int partition_count ) \n { \n int p , j , i ; \n unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; \n unsigned inverse_class = ff_inverse [ vr -> classifications ] ; \n unsigned temp , temp2 ; \n for ( p = 0 , j = 0 ; j < ch_used ; ++ j ) { \n if ( ! do_not_decode [ j ] ) { \n temp = get_vlc2 ( & vc -> gb , vc -> codebooks [ vr -> classbook ] . vlc . table , \n vc -> codebooks [ vr -> classbook ] . nb_bits , 3 ) ; \n av_dlog ( NULL , \" \\n \" , temp ) ; \n if ( ( int ) temp < 0 ) \n return temp ; \n av_assert0 ( vr -> classifications > 1 ) ; \n if ( temp <= 65536 ) { \n for ( i = partition_count + c_p_c - 1 ; i >= partition_count ; i -- ) { \n temp2 = ( ( ( uint64_t ) temp ) * inverse_class ) >> 32 ; \n if ( i < vr -> ptns_to_read ) \n vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications ; \n temp = temp2 ; \n } \n } else { \n for ( i = partition_count + c_p_c - 1 ; i >= partition_count ; i -- ) { \n temp2 = temp / vr -> classifications ; \n if ( i < vr -> ptns_to_read ) \n vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications ; \n temp = temp2 ; \n } \n } \n } \n p += vr -> ptns_to_read ; \n } \n return 0 ; \n }", "idx": 16438}
{"project": "FFmpeg", "commit_id": "69dde1ad36b7d95b8b9268f414aa6c076212ed41", "target": 0, "func": "static int mov_write_tkhd_tag ( ByteIOContext * pb , MOVTrack * track ) \n { \n int64_t maxTrackLenTemp ; \n put_be32 ( pb , 0x5c ) ; \n put_tag ( pb , \" \" ) ; \n put_be32 ( pb , 0xf ) ; \n put_be32 ( pb , track -> time ) ; \n put_be32 ( pb , track -> time ) ; \n put_be32 ( pb , track -> trackID ) ; \n put_be32 ( pb , 0 ) ; \n maxTrackLenTemp = ( ( int64_t ) globalTimescale * ( int64_t ) track -> trackDuration ) / ( int64_t ) track -> timescale ; \n put_be32 ( pb , ( long ) maxTrackLenTemp ) ; \n put_be32 ( pb , 0 ) ; \n put_be32 ( pb , 0 ) ; \n put_be32 ( pb , 0x0 ) ; \n if ( track -> enc -> codec_type == CODEC_TYPE_AUDIO ) \n put_be16 ( pb , 0x0100 ) ; \n else \n put_be16 ( pb , 0 ) ; \n put_be16 ( pb , 0 ) ; \n put_be32 ( pb , 0x00010000 ) ; \n put_be32 ( pb , 0x0 ) ; \n put_be32 ( pb , 0x0 ) ; \n put_be32 ( pb , 0x0 ) ; \n put_be32 ( pb , 0x00010000 ) ; \n put_be32 ( pb , 0x0 ) ; \n put_be32 ( pb , 0x0 ) ; \n put_be32 ( pb , 0x0 ) ; \n put_be32 ( pb , 0x40000000 ) ; \n if ( track -> enc -> codec_type == CODEC_TYPE_VIDEO ) { \n put_be32 ( pb , track -> enc -> width * 0x10000 ) ; \n put_be32 ( pb , track -> enc -> height * 0x10000 ) ; \n } \n else { \n put_be32 ( pb , 0 ) ; \n put_be32 ( pb , 0 ) ; \n } \n return 0x5c ; \n }", "idx": 16441}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_NONE_mips ( struct AACEncContext * s , \n PutBitContext * pb , const float * in , float * out , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits , const float ROUNDING ) { \n av_assert0 ( 0 ) ; \n }", "idx": 16442}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "void mpeg1_encode_init ( MpegEncContext * s ) \n { \n static int done = 0 ; \n if ( ! done ) { \n int f_code ; \n int mv ; \n done = 1 ; \n for ( f_code = 1 ; f_code <= MAX_FCODE ; f_code ++ ) { \n for ( mv = - MAX_MV ; mv <= MAX_MV ; mv ++ ) { \n int len ; \n if ( mv == 0 ) len = mbMotionVectorTable [ 0 ] [ 1 ] ; \n else { \n int val , bit_size , range , code ; \n bit_size = s -> f_code - 1 ; \n range = 1 << bit_size ; \n val = mv ; \n if ( val < 0 ) \n val = - val ; \n val -- ; \n code = ( val >> bit_size ) + 1 ; \n if ( code < 17 ) { \n len = mbMotionVectorTable [ code ] [ 1 ] + 1 + bit_size ; \n } else { \n len = mbMotionVectorTable [ 16 ] [ 1 ] + 2 + bit_size ; \n } \n } \n mv_penalty [ f_code ] [ mv + MAX_MV ] = len ; \n } \n } \n for ( f_code = MAX_FCODE ; f_code > 0 ; f_code -- ) { \n for ( mv = - ( 8 << f_code ) ; mv < ( 8 << f_code ) ; mv ++ ) { \n fcode_tab [ mv + MAX_MV ] = f_code ; \n } \n } \n } \n s -> mv_penalty = mv_penalty ; \n s -> fcode_tab = fcode_tab ; \n }", "idx": 16448}
{"project": "FFmpeg", "commit_id": "702200358197a0ea5ea82d1d6540c785bb04fae4", "target": 0, "func": "static int cook_decode_close ( AVCodecContext * avctx ) \n { \n int i ; \n COOKContext * q = avctx -> priv_data ; \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" ) ; \n av_free ( q -> mlt_window ) ; \n av_free ( q -> mlt_precos ) ; \n av_free ( q -> mlt_presin ) ; \n av_free ( q -> mlt_postcos ) ; \n av_free ( q -> frame_reorder_index ) ; \n av_free ( q -> frame_reorder_buffer ) ; \n av_free ( q -> decoded_bytes_buffer ) ; \n ff_fft_end ( & q -> fft_ctx ) ; \n for ( i = 0 ; i < 13 ; i ++ ) { \n free_vlc ( & q -> envelope_quant_index [ i ] ) ; \n } \n for ( i = 0 ; i < 7 ; i ++ ) { \n free_vlc ( & q -> sqvh [ i ] ) ; \n } \n if ( q -> nb_channels == 2 && q -> joint_stereo == 1 ) { \n free_vlc ( & q -> ccpl ) ; \n } \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" ) ; \n return 0 ; \n }", "idx": 16450}
{"project": "FFmpeg", "commit_id": "45b7bd7c53b41bc5ff6fc2158831f2b1b1256113", "target": 1, "func": "int ff_h264_check_intra_pred_mode ( H264Context * h , int mode ) { \n MpegEncContext * const s = & h -> s ; \n static const int8_t top [ 7 ] = { LEFT_DC_PRED8x8 , 1 , -1 , -1 } ; \n static const int8_t left [ 7 ] = { TOP_DC_PRED8x8 , -1 , 2 , -1 , DC_128_PRED8x8 } ; \n if ( mode > 6U ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n if ( ! ( h -> top_samples_available & 0x8000 ) ) { \n mode = top [ mode ] ; \n if ( mode < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n } \n if ( ( h -> left_samples_available & 0x8080 ) != 0x8080 ) { \n mode = left [ mode ] ; \n if ( h -> left_samples_available & 0x8080 ) { \n mode = ALZHEIMER_DC_L0T_PRED8x8 + ( ! ( h -> left_samples_available & 0x8000 ) ) + 2 * ( mode == DC_128_PRED8x8 ) ; \n } \n if ( mode < 0 ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , s -> mb_x , s -> mb_y ) ; \n return -1 ; \n } \n } \n return mode ; \n }", "idx": 16454}
{"project": "FFmpeg", "commit_id": "d65b9114f35c1afe2a7061f0a1ec957d33ba02b5", "target": 0, "func": "static int file_open_dir ( URLContext * h ) \n { \n #if HAVE_DIRENT_H  \n  \n  FileContext * c = h -> priv_data ; \n c -> dir = opendir ( h -> filename ) ; \n if ( ! c -> dir ) \n return AVERROR ( errno ) ; \n return 0 ; \n #else \n return AVERROR ( ENOSYS ) ; \n #endif \n }", "idx": 16471}
{"project": "FFmpeg", "commit_id": "aade9884e95c6f6da5a856da95501bc14a6225aa", "target": 0, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n APadContext * apad = ctx -> priv ; \n if ( apad -> whole_len ) \n apad -> whole_len -= frame -> nb_samples ; \n apad -> next_pts = frame -> pts + av_rescale_q ( frame -> nb_samples , ( AVRational ) { 1 , inlink -> sample_rate } , inlink -> time_base ) ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , frame ) ; \n }", "idx": 16473}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void free_duplicate_context ( MpegEncContext * s ) \n { \n if ( s == NULL ) \n return ; \n av_freep ( & s -> edge_emu_buffer ) ; \n av_freep ( & s -> me . scratchpad ) ; \n s -> me . temp = \n s -> rd_scratchpad = \n s -> b_scratchpad = \n s -> obmc_scratchpad = NULL ; \n av_freep ( & s -> dct_error_sum ) ; \n av_freep ( & s -> me . map ) ; \n av_freep ( & s -> me . score_map ) ; \n av_freep ( & s -> blocks ) ; \n av_freep ( & s -> ac_val_base ) ; \n s -> block = NULL ; \n }", "idx": 16475}
{"project": "FFmpeg", "commit_id": "47550e62bf717ed626b652bd3797fcae0ca8c335", "target": 0, "func": "static int ast_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVIOContext * pb = s -> pb ; \n ASTMuxContext * ast = s -> priv_data ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n int size = pkt -> size / enc -> channels ; \n if ( enc -> frame_number == 1 ) \n ast -> fbs = size ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , size ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_write ( pb , pkt -> data , pkt -> size ) ; \n return 0 ; \n }", "idx": 16514}
{"project": "FFmpeg", "commit_id": "6260ab60a80fd8baebf79f9ce9299b0db72333b5", "target": 0, "func": "static void blend_image_rgb_pm ( AVFilterContext * ctx , AVFrame * dst , const AVFrame * src , int x , int y ) \n { \n blend_image_packed_rgb ( ctx , dst , src , 0 , x , y , 1 ) ; \n }", "idx": 16525}
{"project": "FFmpeg", "commit_id": "8458dab185ab52c3663c6f5a57c2bee7ca22af37", "target": 0, "func": "static void lz_unpack ( unsigned char * src , unsigned char * dest ) \n { \n unsigned char * s ; \n unsigned char * d ; \n unsigned char queue [ QUEUE_SIZE ] ; \n unsigned int qpos ; \n unsigned int dataleft ; \n unsigned int chainofs ; \n unsigned int chainlen ; \n unsigned int speclen ; \n unsigned char tag ; \n unsigned int i , j ; \n s = src ; \n d = dest ; \n dataleft = LE_32 ( s ) ; \n s += 4 ; \n memset ( queue , QUEUE_SIZE , 0x20 ) ; \n if ( LE_32 ( s ) == 0x56781234 ) { \n s += 4 ; \n qpos = 0x111 ; \n speclen = 0xF + 3 ; \n } else { \n qpos = 0xFEE ; \n speclen = 100 ; \n } \n while ( dataleft > 0 ) { \n tag = * s ++ ; \n if ( ( tag == 0xFF ) && ( dataleft > 8 ) ) { \n for ( i = 0 ; i < 8 ; i ++ ) { \n queue [ qpos ++ ] = * d ++ = * s ++ ; \n qpos &= QUEUE_MASK ; \n } \n dataleft -= 8 ; \n } else { \n for ( i = 0 ; i < 8 ; i ++ ) { \n if ( dataleft == 0 ) \n break ; \n if ( tag & 0x01 ) { \n queue [ qpos ++ ] = * d ++ = * s ++ ; \n qpos &= QUEUE_MASK ; \n dataleft -- ; \n } else { \n chainofs = * s ++ ; \n chainofs |= ( ( * s & 0xF0 ) << 4 ) ; \n chainlen = ( * s ++ & 0x0F ) + 3 ; \n if ( chainlen == speclen ) \n chainlen = * s ++ + 0xF + 3 ; \n for ( j = 0 ; j < chainlen ; j ++ ) { \n * d = queue [ chainofs ++ & QUEUE_MASK ] ; \n queue [ qpos ++ ] = * d ++ ; \n qpos &= QUEUE_MASK ; \n } \n dataleft -= chainlen ; \n } \n tag >>= 1 ; \n } \n } \n } \n }", "idx": 16539}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_mpeg12_decode_slice ( AVCodecContext * avctx , const uint8_t * buffer , uint32_t size ) \n { \n NVDECContext * ctx = avctx -> internal -> hwaccel_priv_data ; \n void * tmp ; \n tmp = av_fast_realloc ( ctx -> slice_offsets , & ctx -> slice_offsets_allocated , \n ( ctx -> nb_slices + 1 ) * sizeof ( * ctx -> slice_offsets ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n ctx -> slice_offsets = tmp ; \n if ( ! ctx -> bitstream ) \n ctx -> bitstream = ( uint8_t * ) buffer ; \n ctx -> slice_offsets [ ctx -> nb_slices ] = buffer - ctx -> bitstream ; \n ctx -> bitstream_len += size ; \n ctx -> nb_slices ++ ; \n return 0 ; \n }", "idx": 16550}
{"project": "FFmpeg", "commit_id": "07bad27810cdd7d3171cbd542119aa051646377c", "target": 0, "func": "void ff_null_start_frame ( AVFilterLink * link , AVFilterBufferRef * picref ) \n { \n ff_start_frame ( link -> dst -> outputs [ 0 ] , picref ) ; \n }", "idx": 16562}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_mbaff_edgecv ( H264Context * h , uint8_t * pix , int stride , const int16_t bS [ 7 ] , int bsi , int qp , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 16571}
{"project": "FFmpeg", "commit_id": "27c7ca9c12bb42d5c44d46f24cd970469d0ef55a", "target": 0, "func": "void ff_read_frame_flush ( AVFormatContext * s ) \n { \n AVStream * st ; \n int i , j ; \n flush_packet_queue ( s ) ; \n s -> cur_st = NULL ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n if ( st -> parser ) { \n av_parser_close ( st -> parser ) ; \n st -> parser = NULL ; \n av_free_packet ( & st -> cur_pkt ) ; \n } \n st -> last_IP_pts = AV_NOPTS_VALUE ; \n st -> cur_dts = AV_NOPTS_VALUE ; \n st -> reference_dts = AV_NOPTS_VALUE ; \n st -> cur_ptr = NULL ; \n st -> cur_len = 0 ; \n st -> probe_packets = MAX_PROBE_PACKETS ; \n for ( j = 0 ; j < MAX_REORDER_DELAY + 1 ; j ++ ) \n st -> pts_buffer [ j ] = AV_NOPTS_VALUE ; \n } \n }", "idx": 16573}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "void av_register_input_format ( AVInputFormat * format ) \n { \n AVInputFormat * * p = & first_iformat ; \n while ( * p != NULL ) \n p = & ( * p ) -> next ; \n * p = format ; \n format -> next = NULL ; \n }", "idx": 16574}
{"project": "FFmpeg", "commit_id": "0c0aef1caf0cb5dd3b294f9fff923175036bd985", "target": 0, "func": "static void set_http_options ( AVFormatContext * s , AVDictionary * * options , HLSContext * c ) \n { \n const char * proto = avio_find_protocol_name ( s -> filename ) ; \n int http_base_proto = ! av_strcasecmp ( proto , \" \" ) || ! av_strcasecmp ( proto , \" \" ) ; \n if ( c -> method ) { \n av_dict_set ( options , \" \" , c -> method , 0 ) ; \n } else if ( proto && http_base_proto ) { \n av_log ( c , AV_LOG_WARNING , \" \\n \" ) ; \n av_dict_set ( options , \" \" , \" \" , 0 ) ; \n } \n }", "idx": 16575}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_ctts ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> ctts_data ) ) \n return -1 ; \n sc -> ctts_data = av_malloc ( entries * sizeof ( * sc -> ctts_data ) ) ; \n if ( ! sc -> ctts_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> ctts_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n int count = get_be32 ( pb ) ; \n int duration = get_be32 ( pb ) ; \n sc -> ctts_data [ i ] . count = count ; \n sc -> ctts_data [ i ] . duration = duration ; \n } \n return 0 ; \n }", "idx": 16576}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void dwt_encode97_float ( DWTContext * s , float * t ) \n { \n int lev , \n w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; \n float * line = s -> f_linebuf ; \n line += 5 ; \n for ( lev = s -> ndeclevels - 1 ; lev >= 0 ; lev -- ) { \n int lh = s -> linelen [ lev ] [ 0 ] , \n lv = s -> linelen [ lev ] [ 1 ] , \n mh = s -> mod [ lev ] [ 0 ] , \n mv = s -> mod [ lev ] [ 1 ] , \n lp ; \n float * l ; \n l = line + mh ; \n for ( lp = 0 ; lp < lv ; lp ++ ) { \n int i , j = 0 ; \n for ( i = 0 ; i < lh ; i ++ ) \n l [ i ] = t [ w * lp + i ] ; \n sd_1d97_float ( line , mh , mh + lh ) ; \n for ( i = mh ; i < lh ; i += 2 , j ++ ) \n t [ w * lp + j ] = F_LFTG_X * l [ i ] / 2 ; \n for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) \n t [ w * lp + j ] = F_LFTG_K * l [ i ] / 2 ; \n } \n l = line + mv ; \n for ( lp = 0 ; lp < lh ; lp ++ ) { \n int i , j = 0 ; \n for ( i = 0 ; i < lv ; i ++ ) \n l [ i ] = t [ w * i + lp ] ; \n sd_1d97_float ( line , mv , mv + lv ) ; \n for ( i = mv ; i < lv ; i += 2 , j ++ ) \n t [ w * j + lp ] = F_LFTG_X * l [ i ] / 2 ; \n for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) \n t [ w * j + lp ] = F_LFTG_K * l [ i ] / 2 ; \n } \n } \n }", "idx": 16620}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int aacPlus_encode_frame ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * frame , int * got_packet ) \n { \n aacPlusAudioContext * s = avctx -> priv_data ; \n int32_t * input_buffer = ( int32_t * ) frame -> data [ 0 ] ; \n int ret ; \n if ( ( ret = ff_alloc_packet2 ( avctx , pkt , s -> max_output_bytes ) ) ) \n return ret ; \n pkt -> size = aacplusEncEncode ( s -> aacplus_handle , input_buffer , \n s -> samples_input , pkt -> data , pkt -> size ) ; \n * got_packet = 1 ; \n pkt -> pts = frame -> pts ; \n return 0 ; \n }", "idx": 16625}
{"project": "FFmpeg", "commit_id": "ce87711df563a9d2d0537a062b86bb91b15ea1a0", "target": 0, "func": "static int exif_decode_tag ( AVCodecContext * avctx , GetByteContext * gbytes , int le , \n int depth , AVDictionary * * metadata ) \n { \n int ret , cur_pos ; \n unsigned id , count ; \n enum TiffTypes type ; \n if ( depth > 2 ) { \n return 0 ; \n } \n ff_tread_tag ( gbytes , le , & id , & type , & count , & cur_pos ) ; \n if ( ! bytestream2_tell ( gbytes ) ) { \n bytestream2_seek ( gbytes , cur_pos , SEEK_SET ) ; \n return 0 ; \n } \n ret = ff_tis_ifd ( id ) ; \n if ( ret ) { \n ret = avpriv_exif_decode_ifd ( avctx , gbytes , le , depth + 1 , metadata ) ; \n } else { \n const char * name = exif_get_tag_name ( id ) ; \n char * use_name = ( char * ) name ; \n if ( ! use_name ) { \n use_name = av_malloc ( 7 ) ; \n if ( ! use_name ) { \n return AVERROR ( ENOMEM ) ; \n } \n snprintf ( use_name , 7 , \" \" , id ) ; \n } \n ret = exif_add_metadata ( avctx , count , type , use_name , NULL , \n gbytes , le , metadata ) ; \n if ( ! name ) { \n av_freep ( & use_name ) ; \n } \n } \n bytestream2_seek ( gbytes , cur_pos , SEEK_SET ) ; \n return ret ; \n }", "idx": 16636}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr24 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n } \n }", "idx": 16655}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "int av_buffersink_get_samples ( AVFilterContext * ctx , AVFrame * frame , int nb_samples ) \n { \n BufferSinkContext * s = ctx -> priv ; \n AVFilterLink * link = ctx -> inputs [ 0 ] ; \n AVFrame * cur_frame ; \n int ret = 0 ; \n if ( ! s -> audio_fifo ) { \n int nb_channels = link -> channels ; \n if ( ! ( s -> audio_fifo = av_audio_fifo_alloc ( link -> format , nb_channels , nb_samples ) ) ) \n return AVERROR ( ENOMEM ) ; \n } \n while ( ret >= 0 ) { \n if ( av_audio_fifo_size ( s -> audio_fifo ) >= nb_samples ) \n return read_from_fifo ( ctx , frame , nb_samples ) ; \n if ( ! ( cur_frame = av_frame_alloc ( ) ) ) \n return AVERROR ( ENOMEM ) ; \n ret = av_buffersink_get_frame_flags ( ctx , cur_frame , 0 ) ; \n if ( ret == AVERROR_EOF && av_audio_fifo_size ( s -> audio_fifo ) ) { \n av_frame_free ( & cur_frame ) ; \n return read_from_fifo ( ctx , frame , av_audio_fifo_size ( s -> audio_fifo ) ) ; \n } else if ( ret < 0 ) { \n av_frame_free ( & cur_frame ) ; \n return ret ; \n } \n if ( cur_frame -> pts != AV_NOPTS_VALUE ) { \n s -> next_pts = cur_frame -> pts - \n av_rescale_q ( av_audio_fifo_size ( s -> audio_fifo ) , \n ( AVRational ) { 1 , link -> sample_rate } , \n link -> time_base ) ; \n } \n ret = av_audio_fifo_write ( s -> audio_fifo , ( void * * ) cur_frame -> extended_data , \n cur_frame -> nb_samples ) ; \n av_frame_free ( & cur_frame ) ; \n } \n return ret ; \n }", "idx": 16656}
{"project": "FFmpeg", "commit_id": "d549f026d8b64b879c3ce3b8c7d153c82aa5eb52", "target": 1, "func": "static av_always_inline void sbr_hf_apply_noise ( int ( * Y ) [ 2 ] , \n const SoftFloat * s_m , \n const SoftFloat * q_filt , \n int noise , \n int phi_sign0 , \n int phi_sign1 , \n int m_max ) \n { \n int m ; \n for ( m = 0 ; m < m_max ; m ++ ) { \n int y0 = Y [ m ] [ 0 ] ; \n int y1 = Y [ m ] [ 1 ] ; \n noise = ( noise + 1 ) & 0x1ff ; \n if ( s_m [ m ] . mant ) { \n int shift , round ; \n shift = 22 - s_m [ m ] . exp ; \n if ( shift < 30 ) { \n round = 1 << ( shift - 1 ) ; \n y0 += ( s_m [ m ] . mant * phi_sign0 + round ) >> shift ; \n y1 += ( s_m [ m ] . mant * phi_sign1 + round ) >> shift ; \n } \n } else { \n int shift , round , tmp ; \n int64_t accu ; \n shift = 22 - q_filt [ m ] . exp ; \n if ( shift < 30 ) { \n round = 1 << ( shift - 1 ) ; \n accu = ( int64_t ) q_filt [ m ] . mant * ff_sbr_noise_table_fixed [ noise ] [ 0 ] ; \n tmp = ( int ) ( ( accu + 0x40000000 ) >> 31 ) ; \n y0 += ( tmp + round ) >> shift ; \n accu = ( int64_t ) q_filt [ m ] . mant * ff_sbr_noise_table_fixed [ noise ] [ 1 ] ; \n tmp = ( int ) ( ( accu + 0x40000000 ) >> 31 ) ; \n y1 += ( tmp + round ) >> shift ; \n } \n } \n Y [ m ] [ 0 ] = y0 ; \n Y [ m ] [ 1 ] = y1 ; \n phi_sign1 = - phi_sign1 ; \n } \n }", "idx": 16667}
{"project": "FFmpeg", "commit_id": "a03a642d5ceb5f2f7c6ebbf56ff365dfbcdb65eb", "target": 1, "func": "av_cold void ff_h264dsp_init_ppc ( H264DSPContext * c , const int bit_depth , \n const int chroma_format_idc ) \n { \n #if HAVE_ALTIVEC  \n  \n  if ( ! ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) ) \n return ; \n if ( bit_depth == 8 ) { \n c -> h264_idct_add = h264_idct_add_altivec ; \n if ( chroma_format_idc == 1 ) \n c -> h264_idct_add8 = h264_idct_add8_altivec ; \n c -> h264_idct_add16 = h264_idct_add16_altivec ; \n c -> h264_idct_add16intra = h264_idct_add16intra_altivec ; \n c -> h264_idct_dc_add = h264_idct_dc_add_altivec ; \n c -> h264_idct8_dc_add = h264_idct8_dc_add_altivec ; \n c -> h264_idct8_add = h264_idct8_add_altivec ; \n c -> h264_idct8_add4 = h264_idct8_add4_altivec ; \n c -> h264_v_loop_filter_luma = h264_v_loop_filter_luma_altivec ; \n c -> h264_h_loop_filter_luma = h264_h_loop_filter_luma_altivec ; \n c -> weight_h264_pixels_tab [ 0 ] = weight_h264_pixels16_altivec ; \n c -> weight_h264_pixels_tab [ 1 ] = weight_h264_pixels8_altivec ; \n c -> biweight_h264_pixels_tab [ 0 ] = biweight_h264_pixels16_altivec ; \n c -> biweight_h264_pixels_tab [ 1 ] = biweight_h264_pixels8_altivec ; \n } \n #endif \n }", "idx": 16668}
{"project": "FFmpeg", "commit_id": "6dc7dd7af45aa1e341b471fd054f85ae2747775b", "target": 1, "func": "static av_cold int atrac1_decode_init ( AVCodecContext * avctx ) \n { \n AT1Ctx * q = avctx -> priv_data ; \n avctx -> sample_fmt = AV_SAMPLE_FMT_FLT ; \n if ( avctx -> channels < 1 || avctx -> channels > AT1_MAX_CHANNELS ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> channels ) ; \n return AVERROR ( EINVAL ) ; \n } \n q -> channels = avctx -> channels ; \n if ( avctx -> channels == 2 ) { \n q -> out_samples [ 0 ] = av_malloc ( 2 * AT1_SU_SAMPLES * sizeof ( * q -> out_samples [ 0 ] ) ) ; \n q -> out_samples [ 1 ] = q -> out_samples [ 0 ] + AT1_SU_SAMPLES ; \n if ( ! q -> out_samples [ 0 ] ) { \n av_freep ( & q -> out_samples [ 0 ] ) ; \n return AVERROR ( ENOMEM ) ; \n } \n } \n ff_mdct_init ( & q -> mdct_ctx [ 0 ] , 6 , 1 , -1.0 / ( 1 << 15 ) ) ; \n ff_mdct_init ( & q -> mdct_ctx [ 1 ] , 8 , 1 , -1.0 / ( 1 << 15 ) ) ; \n ff_mdct_init ( & q -> mdct_ctx [ 2 ] , 9 , 1 , -1.0 / ( 1 << 15 ) ) ; \n ff_init_ff_sine_windows ( 5 ) ; \n atrac_generate_tables ( ) ; \n dsputil_init ( & q -> dsp , avctx ) ; \n ff_fmt_convert_init ( & q -> fmt_conv , avctx ) ; \n q -> bands [ 0 ] = q -> low ; \n q -> bands [ 1 ] = q -> mid ; \n q -> bands [ 2 ] = q -> high ; \n q -> SUs [ 0 ] . spectrum [ 0 ] = q -> SUs [ 0 ] . spec1 ; \n q -> SUs [ 0 ] . spectrum [ 1 ] = q -> SUs [ 0 ] . spec2 ; \n q -> SUs [ 1 ] . spectrum [ 0 ] = q -> SUs [ 1 ] . spec1 ; \n q -> SUs [ 1 ] . spectrum [ 1 ] = q -> SUs [ 1 ] . spec2 ; \n return 0 ; \n }", "idx": 16669}
{"project": "FFmpeg", "commit_id": "63a99622876ff79a07862167f243a7d3823b7315", "target": 1, "func": "static int query_formats ( AVFilterContext * ctx ) \n { \n AVFilterFormats * formats = NULL ; \n int fmt ; \n for ( fmt = 0 ; fmt < AV_PIX_FMT_NB ; fmt ++ ) { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( fmt ) ; \n if ( ! ( desc -> flags & PIX_FMT_PAL || \n fmt == AV_PIX_FMT_NV21 || \n fmt == AV_PIX_FMT_NV12 ) ) \n ff_add_format ( & formats , fmt ) ; \n } \n ff_set_common_formats ( ctx , formats ) ; \n return 0 ; \n }", "idx": 16670}
{"project": "FFmpeg", "commit_id": "9244b839b788e4677019041907ff5a4378a23490", "target": 1, "func": "static void dmix_sub_c ( int32_t * dst , const int32_t * src , int coeff , ptrdiff_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) \n dst [ i ] -= mul15 ( src [ i ] , coeff ) ; \n }", "idx": 16677}
{"project": "FFmpeg", "commit_id": "75f418064ecf5c2713151cbe6b3a716d2c047f1d", "target": 1, "func": "static int read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n CaffContext * caf = s -> priv_data ; \n int64_t pos ; \n timestamp = FFMAX ( timestamp , 0 ) ; \n if ( caf -> frames_per_packet > 0 && caf -> bytes_per_packet > 0 ) { \n pos = caf -> bytes_per_packet * timestamp / caf -> frames_per_packet ; \n if ( caf -> data_size > 0 ) \n pos = FFMIN ( pos , caf -> data_size ) ; \n caf -> packet_cnt = pos / caf -> bytes_per_packet ; \n caf -> frame_cnt = caf -> frames_per_packet * caf -> packet_cnt ; \n } else if ( st -> nb_index_entries ) { \n caf -> packet_cnt = av_index_search_timestamp ( st , timestamp , flags ) ; \n caf -> frame_cnt = st -> index_entries [ caf -> packet_cnt ] . timestamp ; \n pos = st -> index_entries [ caf -> packet_cnt ] . pos ; \n } else { \n return -1 ; \n } \n avio_seek ( s -> pb , pos + caf -> data_start , SEEK_SET ) ; \n return 0 ; \n }", "idx": 16678}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( yvu9toyv12 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , \n uint8_t * ydst , uint8_t * udst , uint8_t * vdst , \n long width , long height , long lumStride , long chromStride ) \n { \n memcpy ( ydst , ysrc , width * height ) ; \n }", "idx": 16689}
{"project": "FFmpeg", "commit_id": "31741aecbf9938194b25f14de434104be33f5809", "target": 1, "func": "static int setup_hwaccel ( AVCodecContext * avctx , \n const enum AVPixelFormat fmt , \n const char * name ) \n { \n AVHWAccel * hwa = find_hwaccel ( avctx -> codec_id , fmt ) ; \n int ret = 0 ; \n if ( ! hwa ) { \n \" \" , \n name ) ; \n return AVERROR ( ENOENT ) ; \n if ( hwa -> capabilities & HWACCEL_CODEC_CAP_EXPERIMENTAL && \n avctx -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL ) { \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" , \n hwa -> name ) ; \n return AVERROR_PATCHWELCOME ; \n if ( hwa -> priv_data_size ) { \n avctx -> internal -> hwaccel_priv_data = av_mallocz ( hwa -> priv_data_size ) ; \n if ( ! avctx -> internal -> hwaccel_priv_data ) \n return AVERROR ( ENOMEM ) ; \n if ( hwa -> init ) { \n ret = hwa -> init ( avctx ) ; \n if ( ret < 0 ) { \n av_freep ( & avctx -> internal -> hwaccel_priv_data ) ; \n return ret ; \n avctx -> hwaccel = hwa ; \n return 0 ;", "idx": 16702}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static int mlib_YUV2RGB420_24 ( SwsContext * c , uint8_t * src [ ] , int srcStride [ ] , int srcSliceY , \n int srcSliceH , uint8_t * dst [ ] , int dstStride [ ] ) { \n if ( c -> srcFormat == PIX_FMT_YUV422P ) { \n srcStride [ 1 ] *= 2 ; \n srcStride [ 2 ] *= 2 ; \n } \n assert ( srcStride [ 1 ] == srcStride [ 2 ] ) ; \n mlib_VideoColorYUV2RGB420 ( dst [ 0 ] + srcSliceY * dstStride [ 0 ] , src [ 0 ] , src [ 1 ] , src [ 2 ] , c -> dstW , \n srcSliceH , dstStride [ 0 ] , srcStride [ 0 ] , srcStride [ 1 ] ) ; \n return srcSliceH ; \n }", "idx": 16705}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "double av_get_double ( void * obj , const char * name , const AVOption * * o_out ) \n { \n int64_t intnum = 1 ; \n double num = 1 ; \n int den = 1 ; \n av_get_number ( obj , name , o_out , & num , & den , & intnum ) ; \n return num * intnum / den ; \n }", "idx": 16714}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float quantize_band_cost_bits ( struct AACEncContext * s , const float * in , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits , int rtz ) \n { \n return get_band_numbits ( s , NULL , in , scaled , size , scale_idx , cb , lambda , uplim , bits ) ; \n }", "idx": 16719}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static inline int show_tags ( WriterContext * wctx , AVDictionary * tags , int section_id ) \n { \n AVDictionaryEntry * tag = NULL ; \n int ret = 0 ; \n if ( ! tags ) \n return 0 ; \n writer_print_section_header ( wctx , section_id ) ; \n while ( ( tag = av_dict_get ( tags , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) { \n ret = writer_print_string ( wctx , tag -> key , tag -> value , 0 ) ; \n if ( ret < 0 ) \n break ; \n } \n writer_print_section_footer ( wctx ) ; \n return ret ; \n }", "idx": 16749}
{"project": "FFmpeg", "commit_id": "223d996aaf9f1668c28519d3d7eb756e6cdf3fcf", "target": 1, "func": "static inline int get_symbol ( RangeCoder * c , uint8_t * state , int is_signed ) { \n if ( get_rac ( c , state + 0 ) ) \n return 0 ; \n else { \n int i , e , a ; \n e = 0 ; \n while ( get_rac ( c , state + 1 + e ) ) { \n e ++ ; \n } \n assert ( e <= 9 ) ; \n a = 1 ; \n for ( i = e - 1 ; i >= 0 ; i -- ) { \n a += a + get_rac ( c , state + 22 + i ) ; \n } \n if ( is_signed && get_rac ( c , state + 11 + e ) ) \n return - a ; \n else \n return a ; \n } \n }", "idx": 16754}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_source_package ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFPackage * package = arg ; \n switch ( tag ) { \n case 0x4403 : \n package -> tracks_count = avio_rb32 ( pb ) ; \n if ( package -> tracks_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n package -> tracks_refs = av_malloc ( package -> tracks_count * sizeof ( UID ) ) ; \n if ( ! package -> tracks_refs ) \n return -1 ; \n avio_skip ( pb , 4 ) ; \n avio_read ( pb , ( uint8_t * ) package -> tracks_refs , package -> tracks_count * sizeof ( UID ) ) ; \n break ; \n case 0x4401 : \n avio_skip ( pb , 16 ) ; \n avio_read ( pb , package -> package_uid , 16 ) ; \n break ; \n case 0x4701 : \n avio_read ( pb , package -> descriptor_ref , 16 ) ; \n break ; \n } \n return 0 ; \n }", "idx": 16757}
{"project": "FFmpeg", "commit_id": "bb6a7b6f75ac544c956e3eefee297700ef4d3468", "target": 1, "func": "int ff_lzf_uncompress ( GetByteContext * gb , uint8_t * * buf , int64_t * size ) \n { \n int ret = 0 ; \n uint8_t * p = * buf ; \n int64_t len = 0 ; \n while ( bytestream2_get_bytes_left ( gb ) > 2 ) { \n uint8_t s = bytestream2_get_byte ( gb ) ; \n if ( s < LZF_LITERAL_MAX ) { \n s ++ ; \n if ( s > * size - len ) { \n * size += * size / 2 ; \n ret = av_reallocp ( buf , * size ) ; \n if ( ret < 0 ) \n return ret ; \n } \n bytestream2_get_buffer ( gb , p , s ) ; \n p += s ; \n len += s ; \n } else { \n int l = 2 + ( s >> 5 ) ; \n int off = ( ( s & 0x1f ) << 8 ) + 1 ; \n if ( l == LZF_LONG_BACKREF ) \n l += bytestream2_get_byte ( gb ) ; \n off += bytestream2_get_byte ( gb ) ; \n if ( off > len ) \n return AVERROR_INVALIDDATA ; \n if ( l > * size - len ) { \n * size += * size / 2 ; \n ret = av_reallocp ( buf , * size ) ; \n if ( ret < 0 ) \n return ret ; \n } \n av_memcpy_backptr ( p , off , l ) ; \n p += l ; \n len += l ; \n } \n } \n * size = len ; \n return 0 ; \n }", "idx": 16760}
{"project": "FFmpeg", "commit_id": "e55376a1fd5abebbb0a082aa20739d58c2260a37", "target": 1, "func": "static int inject_fake_duration_metadata ( RTMPContext * rt ) \n { \n uint8_t * p ; \n uint8_t * old_flv_data = rt -> flv_data ; \n if ( ! ( rt -> flv_data = av_malloc ( rt -> flv_size + 55 ) ) ) { \n rt -> flv_data = old_flv_data ; \n return AVERROR ( ENOMEM ) ; \n } \n memcpy ( rt -> flv_data , old_flv_data , 13 ) ; \n memcpy ( rt -> flv_data + 13 + 55 , old_flv_data + 13 , rt -> flv_size - 13 ) ; \n rt -> flv_size += 55 ; \n av_free ( old_flv_data ) ; \n p = rt -> flv_data + 13 ; \n bytestream_put_byte ( & p , FLV_TAG_TYPE_META ) ; \n bytestream_put_be24 ( & p , 40 ) ; \n bytestream_put_be24 ( & p , 0 ) ; \n bytestream_put_be32 ( & p , 0 ) ; \n bytestream_put_byte ( & p , AMF_DATA_TYPE_STRING ) ; \n bytestream_put_be16 ( & p , 10 ) ; \n bytestream_put_buffer ( & p , \" \" , 10 ) ; \n bytestream_put_byte ( & p , AMF_DATA_TYPE_MIXEDARRAY ) ; \n bytestream_put_be32 ( & p , 1 ) ; \n bytestream_put_be16 ( & p , 8 ) ; \n bytestream_put_buffer ( & p , \" \" , 8 ) ; \n bytestream_put_byte ( & p , AMF_DATA_TYPE_NUMBER ) ; \n bytestream_put_be64 ( & p , av_double2int ( rt -> duration ) ) ; \n bytestream_put_be16 ( & p , 0 ) ; \n bytestream_put_byte ( & p , AMF_END_OF_OBJECT ) ; \n bytestream_put_be32 ( & p , 40 ) ; \n return 0 ; \n }", "idx": 16761}
{"project": "FFmpeg", "commit_id": "341f01290c2353669ed2263f56e1a9f4c67cc597", "target": 1, "func": "static int huff_build ( VLC * vlc , uint8_t * len ) \n { \n HuffEntry he [ 256 ] ; \n uint32_t codes [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint8_t syms [ 256 ] ; \n uint32_t code ; \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n he [ i ] . sym = 255 - i ; \n he [ i ] . len = len [ i ] ; \n if ( len [ i ] == 0 ) \n return AVERROR_INVALIDDATA ; \n } \n AV_QSORT ( he , 256 , HuffEntry , huff_cmp_len ) ; \n code = 1 ; \n for ( i = 255 ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n ff_free_vlc ( vlc ) ; \n return ff_init_vlc_sparse ( vlc , FFMIN ( he [ 255 ] . len , 12 ) , 256 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 16772}
{"project": "FFmpeg", "commit_id": "9f5769437aaab30a359cde254f39d9a28b1ce657", "target": 0, "func": "static void handle_stream_probing ( AVStream * st ) \n { \n if ( st -> codec -> codec_id == AV_CODEC_ID_PCM_S16LE ) { \n st -> request_probe = AVPROBE_SCORE_EXTENSION ; \n st -> probe_packets = FFMIN ( st -> probe_packets , 14 ) ; \n } \n }", "idx": 16805}
{"project": "FFmpeg", "commit_id": "dccda293a0576d5414fafc0e95615c82a2f2399f", "target": 0, "func": "int avcodec_close ( AVCodecContext * avctx ) \n { \n if ( ff_lockmgr_cb ) { \n if ( ( * ff_lockmgr_cb ) ( & codec_mutex , AV_LOCK_OBTAIN ) ) \n return -1 ; \n } \n entangled_thread_counter ++ ; \n if ( entangled_thread_counter != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n entangled_thread_counter -- ; \n return -1 ; \n } \n if ( HAVE_THREADS && avctx -> thread_opaque ) \n avcodec_thread_free ( avctx ) ; \n if ( avctx -> codec -> close ) \n avctx -> codec -> close ( avctx ) ; \n avcodec_default_free_buffers ( avctx ) ; \n av_freep ( & avctx -> priv_data ) ; \n avctx -> codec = NULL ; \n entangled_thread_counter -- ; \n if ( ff_lockmgr_cb ) { \n ( * ff_lockmgr_cb ) ( & codec_mutex , AV_LOCK_RELEASE ) ; \n } \n return 0 ; \n }", "idx": 16806}
{"project": "FFmpeg", "commit_id": "a26e1d4c1f7c93d24250dd9c0786241f92fcdea4", "target": 0, "func": "static int get_packetheader ( NUTContext * nut , ByteIOContext * bc , int calculate_checksum ) \n { \n int64_t start , size ; \n start = url_ftell ( bc ) - 8 ; \n init_checksum ( bc , calculate_checksum ? update_adler32 : NULL , 0 ) ; \n size = get_v ( bc ) ; \n nut -> packet_start [ 2 ] = start ; \n nut -> written_packet_size = size ; \n return size ; \n }", "idx": 16809}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static void rtsp_close_streams ( RTSPState * rt ) \n { \n int i ; \n RTSPStream * rtsp_st ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( rtsp_st ) { \n if ( rtsp_st -> transport_priv ) { \n if ( rt -> transport == RTSP_TRANSPORT_RDT ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else \n rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n if ( rtsp_st -> rtp_handle ) \n url_close ( rtsp_st -> rtp_handle ) ; \n if ( rtsp_st -> dynamic_handler && rtsp_st -> dynamic_protocol_context ) \n rtsp_st -> dynamic_handler -> close ( rtsp_st -> dynamic_protocol_context ) ; \n } \n } \n av_free ( rt -> rtsp_streams ) ; \n if ( rt -> asf_ctx ) { \n av_close_input_stream ( rt -> asf_ctx ) ; \n rt -> asf_ctx = NULL ; \n } \n av_freep ( & rt -> auth_b64 ) ; \n }", "idx": 16810}
{"project": "FFmpeg", "commit_id": "a2816230c5c0a8fc72bc0163b7d21a96b194d87a", "target": 0, "func": "static void compat_free_buffer ( void * opaque , uint8_t * data ) \n { \n CompatReleaseBufPriv * priv = opaque ; \n priv -> avctx . release_buffer ( & priv -> avctx , & priv -> frame ) ; \n av_freep ( & priv ) ; \n }", "idx": 16813}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static int process_tns_coeffs ( TemporalNoiseShaping * tns , float * tns_coefs_raw , \n int order , int w , int filt ) \n { \n int i , j ; \n int * idx = tns -> coef_idx [ w ] [ filt ] ; \n float * lpc = tns -> coef [ w ] [ filt ] ; \n const int iqfac_p = ( ( 1 << ( MAX_LPC_PRECISION - 1 ) ) - 0.5 ) / ( M_PI / 2.0 ) ; \n const int iqfac_m = ( ( 1 << ( MAX_LPC_PRECISION - 1 ) ) + 0.5 ) / ( M_PI / 2.0 ) ; \n float temp [ TNS_MAX_ORDER ] = { 0.0f } , out [ TNS_MAX_ORDER ] = { 0.0f } ; \n for ( i = 0 ; i < order ; i ++ ) { \n idx [ i ] = ceilf ( asin ( tns_coefs_raw [ i ] ) * ( ( tns_coefs_raw [ i ] >= 0 ) ? iqfac_p : iqfac_m ) ) ; \n lpc [ i ] = 2 * sin ( idx [ i ] / ( ( idx [ i ] >= 0 ) ? iqfac_p : iqfac_m ) ) ; \n } \n for ( i = order ; i > -1 ; i -- ) { \n lpc [ i ] = ( fabs ( lpc [ i ] ) > 0.1f ) ? lpc [ i ] : 0.0f ; \n if ( lpc [ i ] != 0.0 ) { \n order = i ; \n break ; \n } \n } \n if ( ! order ) \n return 0 ; \n out [ 0 ] = 1.0f ; \n for ( i = 1 ; i <= order ; i ++ ) { \n for ( j = 1 ; j < i ; j ++ ) { \n temp [ j ] = out [ j ] + lpc [ i ] * out [ i - j ] ; \n } \n for ( j = 1 ; j <= i ; j ++ ) { \n out [ j ] = temp [ j ] ; \n } \n out [ i ] = lpc [ i - 1 ] ; \n } \n memcpy ( lpc , out , TNS_MAX_ORDER * sizeof ( float ) ) ; \n return order ; \n }", "idx": 16824}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 256 ] ; \n samples [ i + 256 ] = samples [ i + 512 ] ; \n samples [ i + 512 ] = 0 ; \n } \n }", "idx": 16825}
{"project": "FFmpeg", "commit_id": "2ad0d96a24879b96153a3fbbc1707372baa2615e", "target": 0, "func": "void ff_acelp_interpolate ( \n int16_t * out , \n const int16_t * in , \n const int16_t * filter_coeffs , \n int precision , \n int frac_pos , \n int filter_length , \n int length ) \n { \n int n , i ; \n assert ( pitch_delay_frac >= 0 && pitch_delay_frac < precision ) ; \n for ( n = 0 ; n < length ; n ++ ) \n { \n int idx = 0 ; \n int v = 0x4000 ; \n for ( i = 0 ; i < filter_length ; ) \n { \n v += in [ n + i ] * filter_coeffs [ idx + frac_pos ] ; \n idx += precision ; \n i ++ ; \n v += in [ n - i ] * filter_coeffs [ idx - frac_pos ] ; \n } \n out [ n ] = av_clip_int16 ( v >> 15 ) ; \n } \n }", "idx": 16836}
{"project": "FFmpeg", "commit_id": "7fc73d9ab781f66b63f3bbe2f384f4f639ae78e9", "target": 1, "func": "static int rm_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n RMDemuxContext * rm = s -> priv_data ; \n AVStream * st ; \n int i , len , res , seq = 1 ; \n int64_t timestamp , pos ; \n int flags ; \n for ( ; ; ) { \n if ( rm -> audio_pkt_cnt ) { \n st = s -> streams [ rm -> audio_stream_num ] ; \n res = ff_rm_retrieve_cache ( s , s -> pb , st , st -> priv_data , pkt ) ; \n if ( res < 0 ) \n return res ; \n flags = 0 ; \n } else { \n if ( rm -> old_format ) { \n RMStream * ast ; \n st = s -> streams [ 0 ] ; \n ast = st -> priv_data ; \n timestamp = AV_NOPTS_VALUE ; \n len = ! ast -> audio_framesize ? RAW_PACKET_SIZE : \n ast -> coded_framesize * ast -> sub_packet_h / 2 ; \n flags = ( seq ++ == 1 ) ? 2 : 0 ; \n pos = avio_tell ( s -> pb ) ; \n } else { \n len = sync ( s , & timestamp , & flags , & i , & pos ) ; \n if ( len > 0 ) \n st = s -> streams [ i ] ; \n } \n if ( len < 0 || url_feof ( s -> pb ) ) \n return AVERROR ( EIO ) ; \n res = ff_rm_parse_packet ( s , s -> pb , st , st -> priv_data , len , pkt , \n & seq , flags , timestamp ) ; \n if ( ( flags & 2 ) && ( seq & 0x7F ) == 1 ) \n av_add_index_entry ( st , pos , timestamp , 0 , 0 , AVINDEX_KEYFRAME ) ; \n if ( res ) \n continue ; \n } \n if ( ( st -> discard >= AVDISCARD_NONKEY && ! ( flags & 2 ) ) \n || st -> discard >= AVDISCARD_ALL ) { \n av_free_packet ( pkt ) ; \n } else \n break ; \n } \n return 0 ; \n }", "idx": 16854}
{"project": "FFmpeg", "commit_id": "a7196795613f2cd416cf2c51c767a1125e27b057", "target": 0, "func": "int ff_parse_packing_format ( int * ret , const char * arg , void * log_ctx ) \n { \n char * tail ; \n int planar = strtol ( arg , & tail , 10 ) ; \n if ( * tail ) { \n planar = ( strcmp ( arg , \" \" ) != 0 ) ; \n } else if ( planar != 0 && planar != 1 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , arg ) ; \n return AVERROR ( EINVAL ) ; \n } \n * ret = planar ; \n return 0 ; \n }", "idx": 16860}
{"project": "FFmpeg", "commit_id": "04001767728fd4ed8b4f9d2ebbb9f9a8c9a7be0d", "target": 0, "func": "static int query_format ( struct vf_instance * vf , unsigned int fmt ) \n { \n switch ( fmt ) { \n case IMGFMT_YV12 : \n case IMGFMT_IYUV : \n case IMGFMT_I420 : \n return ff_vf_next_query_format ( vf , fmt ) ; \n } \n return 0 ; \n }", "idx": 16871}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel4_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_and_aver_dst_4x4_msa ( src - ( stride * 2 ) , stride , dst , stride ) ; \n }", "idx": 16886}
{"project": "FFmpeg", "commit_id": "c9fe0caf7a1abde7ca0b1a359f551103064867b1", "target": 0, "func": "static void FUNC ( transquant_bypass32x32 ) ( uint8_t * _dst , int16_t * coeffs , \n ptrdiff_t stride ) \n { \n int x , y ; \n pixel * dst = ( pixel * ) _dst ; \n stride /= sizeof ( pixel ) ; \n for ( y = 0 ; y < 32 ; y ++ ) { \n for ( x = 0 ; x < 32 ; x ++ ) { \n dst [ x ] += * coeffs ; \n coeffs ++ ; \n } \n dst += stride ; \n } \n }", "idx": 16908}
{"project": "FFmpeg", "commit_id": "5b4d026a030a775f0bd287e3a27188e8b5c9009f", "target": 1, "func": "static inline int op ( uint8_t * * dst , const uint8_t * dst_end , \n const uint8_t * * buf , const uint8_t * buf_end , \n int pixel , int count , \n int * x , int width , int linesize ) \n { \n int remaining = width - * x ; \n while ( count > 0 ) { \n int striplen = FFMIN ( count , remaining ) ; \n if ( buf ) { \n striplen = FFMIN ( striplen , buf_end - * buf ) ; \n if ( * buf >= buf_end ) \n goto exhausted ; \n memcpy ( * dst , * buf , striplen ) ; \n * buf += striplen ; \n } else if ( pixel >= 0 ) \n memset ( * dst , pixel , striplen ) ; \n * dst += striplen ; \n remaining -= striplen ; \n count -= striplen ; \n if ( remaining <= 0 ) { \n * dst += linesize - width ; \n remaining = width ; \n } \n if ( linesize > 0 ) { \n if ( * dst >= dst_end ) goto exhausted ; \n } else { \n if ( * dst <= dst_end ) goto exhausted ; \n } \n } \n * x = width - remaining ; \n return 0 ; \n exhausted : \n * x = width - remaining ; \n return 1 ; \n }", "idx": 16936}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "build_qp_table ( PPS * pps , int index )  \n { \n int i ; \n for ( i = 0 ; i < 255 ; i ++ ) \n pps -> chroma_qp_table [ i & 0xff ] = chroma_qp [ av_clip ( i + index , 0 , 51 ) ] ; \n pps -> chroma_qp_index_offset = index ; \n }", "idx": 16938}
{"project": "FFmpeg", "commit_id": "dddc9b7a8ec3a03e48c69991ca7f20f10dd6f022", "target": 0, "func": "static int decode_profile_tier_level ( HEVCContext * s , ProfileTierLevel * ptl ) \n { \n int i ; \n HEVCLocalContext * lc = s -> HEVClc ; \n GetBitContext * gb = & lc -> gb ; \n ptl -> profile_space = get_bits ( gb , 2 ) ; \n ptl -> tier_flag = get_bits1 ( gb ) ; \n ptl -> profile_idc = get_bits ( gb , 5 ) ; \n if ( ptl -> profile_idc == 1 ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == 2 ) \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" , ptl -> profile_idc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) \n ptl -> profile_compatibility_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> progressive_source_flag = get_bits1 ( gb ) ; \n ptl -> interlaced_source_flag = get_bits1 ( gb ) ; \n ptl -> non_packed_constraint_flag = get_bits1 ( gb ) ; \n ptl -> frame_only_constraint_flag = get_bits1 ( gb ) ; \n if ( get_bits ( gb , 16 ) != 0 ) \n return -1 ; \n if ( get_bits ( gb , 16 ) != 0 ) \n return -1 ; \n if ( get_bits ( gb , 12 ) != 0 ) \n return -1 ; \n return 0 ; \n }", "idx": 16949}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "static int av_thread_message_queue_send_locked ( AVThreadMessageQueue * mq , \n void * msg , \n unsigned flags ) \n { \n while ( ! mq -> err_send && av_fifo_space ( mq -> fifo ) < mq -> elsize ) { \n if ( ( flags & AV_THREAD_MESSAGE_NONBLOCK ) ) \n return AVERROR ( EAGAIN ) ; \n pthread_cond_wait ( & mq -> cond , & mq -> lock ) ; \n } \n if ( mq -> err_send ) \n return mq -> err_send ; \n av_fifo_generic_write ( mq -> fifo , msg , mq -> elsize , NULL ) ; \n pthread_cond_signal ( & mq -> cond ) ; \n return 0 ; \n }", "idx": 16972}
{"project": "FFmpeg", "commit_id": "50a3c4c5d2634b5d4076a5b7c099729cbd59ac45", "target": 1, "func": "static int rsd_probe ( AVProbeData * p ) \n { \n if ( ! memcmp ( p -> buf , \" \" , 3 ) && \n p -> buf [ 3 ] - ' ' >= 2 && p -> buf [ 3 ] - ' ' <= 6 ) \n return AVPROBE_SCORE_EXTENSION ; \n return 0 ; \n }", "idx": 16973}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static av_always_inline int simple_limit ( uint8_t * p , ptrdiff_t stride , int flim ) \n { \n LOAD_PIXELS \n return  2 * FFABS ( p0 - q0 ) + ( FFABS ( p1 - q1 ) >> 1 ) <= flim ; \n }", "idx": 16975}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "void sample_dump ( int fnum , INT32 * tab , int n ) \n { \n static FILE * files [ 16 ] , * f ; \n char buf [ 512 ] ; \n f = files [ fnum ] ; \n if ( ! f ) { \n sprintf ( buf , \" \" , fnum ) ; \n f = fopen ( buf , \" \" ) ; \n if ( ! f ) \n return ; \n files [ fnum ] = f ; \n } \n if ( fnum == 0 ) { \n int i ; \n static int pos = 0 ; \n printf ( \" \\n \" , pos ) ; \n for ( i = 0 ; i < n ; i ++ ) { \n printf ( \" \" , ( double ) tab [ i ] / 32768.0 ) ; \n if ( ( i % 18 ) == 17 ) \n printf ( \" \\n \" ) ; \n } \n pos += n ; \n } \n fwrite ( tab , 1 , n * sizeof ( INT32 ) , f ) ; \n }", "idx": 16976}
{"project": "FFmpeg", "commit_id": "8d2e0e2c7058a3eaf7f45d740be6e93972bbfd68", "target": 0, "func": "const uint8_t * ff_h263_find_resync_marker ( MpegEncContext * s , const uint8_t * av_restrict p , const uint8_t * av_restrict end ) \n { \n av_assert2 ( p < end ) ; \n end -= 2 ; \n p ++ ; \n if ( s -> resync_marker ) { \n for ( ; p < end ; p += 2 ) { \n if ( ! * p ) { \n if ( ! p [ -1 ] && p [ 1 ] ) return p - 1 ; \n else if ( ! p [ 1 ] && p [ 2 ] ) return p ; \n } \n } \n } \n return end + 2 ; \n }", "idx": 16980}
{"project": "FFmpeg", "commit_id": "eabbc64728c2fdb74f565aededec2ab023d20699", "target": 0, "func": "static int start_ebml_master_crc32 ( AVIOContext * pb , AVIOContext * * dyn_cp , ebml_master * master , \n unsigned int elementid , uint64_t expectedsize ) \n { \n int ret ; \n if ( ( ret = avio_open_dyn_buf ( dyn_cp ) ) < 0 ) \n return ret ; \n if ( pb -> seekable ) \n * master = start_ebml_master ( pb , elementid , expectedsize ) ; \n else \n * master = start_ebml_master ( * dyn_cp , elementid , expectedsize ) ; \n return 0 ; \n }", "idx": 16982}
{"project": "FFmpeg", "commit_id": "e6c90ce94f1b07f50cea2babf7471af455cca0ff", "target": 0, "func": "static void decode_finish_row ( H264Context * h , H264SliceContext * sl ) \n { \n int top = 16 * ( h -> mb_y >> FIELD_PICTURE ( h ) ) ; \n int pic_height = 16 * h -> mb_height >> FIELD_PICTURE ( h ) ; \n int height = 16 << FRAME_MBAFF ( h ) ; \n int deblock_border = ( 16 + 4 ) << FRAME_MBAFF ( h ) ; \n if ( h -> deblocking_filter ) { \n if ( ( top + height ) >= pic_height ) \n height += deblock_border ; \n top -= deblock_border ; \n } \n if ( top >= pic_height || ( top + height ) < 0 ) \n return ; \n height = FFMIN ( height , pic_height - top ) ; \n if ( top < 0 ) { \n height = top + height ; \n top = 0 ; \n } \n ff_h264_draw_horiz_band ( h , sl , top , height ) ; \n if ( h -> droppable ) \n return ; \n ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , top + height - 1 , \n h -> picture_structure == PICT_BOTTOM_FIELD ) ; \n }", "idx": 16985}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static inline void show_tags ( WriterContext * wctx , AVDictionary * tags , int section_id ) \n { \n AVDictionaryEntry * tag = NULL ; \n if ( ! tags ) \n return ; \n writer_print_section_header ( wctx , section_id ) ; \n while ( ( tag = av_dict_get ( tags , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) \n writer_print_string ( wctx , tag -> key , tag -> value , 0 ) ; \n writer_print_section_footer ( wctx ) ; \n }", "idx": 16987}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static av_always_inline int normal_limit ( uint8_t * p , ptrdiff_t stride , int E , int I ) \n { \n LOAD_PIXELS \n return  simple_limit ( p , stride , E ) \n && FFABS ( p3 - p2 ) <= I && FFABS ( p2 - p1 ) <= I && FFABS ( p1 - p0 ) <= I \n && FFABS ( q3 - q2 ) <= I && FFABS ( q2 - q1 ) <= I && FFABS ( q1 - q0 ) <= I ; \n }", "idx": 17031}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static double tget_double ( const uint8_t * * p , int le ) \n { \n av_alias64 i = { . u64 = le ? AV_RL64 ( * p ) : AV_RB64 ( * p ) } ; \n * p += 8 ; \n return i . f64 ; \n }", "idx": 17042}
{"project": "FFmpeg", "commit_id": "8136f234445862c94d1c081606b2d1e3d44fccf3", "target": 1, "func": "static void yop_paint_block ( YopDecContext * s , int tag ) \n { \n s -> dstptr [ 0 ] = s -> srcptr [ 0 ] ; \n s -> dstptr [ 1 ] = s -> srcptr [ paint_lut [ tag ] [ 0 ] ] ; \n s -> dstptr [ s -> frame . linesize [ 0 ] ] = s -> srcptr [ paint_lut [ tag ] [ 1 ] ] ; \n s -> dstptr [ s -> frame . linesize [ 0 ] + 1 ] = s -> srcptr [ paint_lut [ tag ] [ 2 ] ] ; \n s -> srcptr += paint_lut [ tag ] [ 3 ] ; \n }", "idx": 17057}
{"project": "FFmpeg", "commit_id": "fdbd924b84e85ac5c80f01ee059ed5c81d3cc205", "target": 1, "func": "av_cold int ff_rv34_decode_init ( AVCodecContext * avctx ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n MpegEncContext * s = & r -> s ; \n int ret ; \n ff_MPV_decode_defaults ( s ) ; \n s -> avctx = avctx ; \n s -> out_format = FMT_H263 ; \n s -> codec_id = avctx -> codec_id ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n r -> s . avctx = avctx ; \n avctx -> flags |= CODEC_FLAG_EMU_EDGE ; \n r -> s . flags |= CODEC_FLAG_EMU_EDGE ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n avctx -> has_b_frames = 1 ; \n s -> low_delay = 0 ; \n if ( ( ret = ff_MPV_common_init ( s ) ) < 0 ) \n return ret ; \n ff_h264_pred_init ( & r -> h , AV_CODEC_ID_RV40 , 8 , 1 ) ; \n #if CONFIG_RV30_DECODER  \n  \n  if ( avctx -> codec_id == AV_CODEC_ID_RV30 ) \n ff_rv30dsp_init ( & r -> rdsp ) ; \n #endif \n #if CONFIG_RV40_DECODER  \n  \n  if ( avctx -> codec_id == AV_CODEC_ID_RV40 ) \n ff_rv40dsp_init ( & r -> rdsp ) ; \n #endif \n if ( ( ret = rv34_decoder_alloc ( r ) ) < 0 ) \n return ret ; \n if ( ! intra_vlcs [ 0 ] . cbppattern [ 0 ] . bits ) \n rv34_init_tables ( ) ; \n avctx -> internal -> allocate_progress = 1 ; \n return 0 ; \n }", "idx": 17058}
{"project": "FFmpeg", "commit_id": "e6ffd997cbc06426e75d3fa291b991866c84a79b", "target": 0, "func": "static inline int get_scale ( GetBitContext * gb , int level , int value ) \n { \n if ( level < 5 ) { \n value += get_bitalloc ( gb , & dca_scalefactor , level ) ; \n } else if ( level < 8 ) \n value = get_bits ( gb , level + 1 ) ; \n return value ; \n }", "idx": 17087}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_source_package ( MXFPackage * package , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x4403 : \n package -> tracks_count = get_be32 ( pb ) ; \n if ( package -> tracks_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n package -> tracks_refs = av_malloc ( package -> tracks_count * sizeof ( UID ) ) ; \n if ( ! package -> tracks_refs ) \n return -1 ; \n url_fskip ( pb , 4 ) ; \n get_buffer ( pb , ( uint8_t * ) package -> tracks_refs , package -> tracks_count * sizeof ( UID ) ) ; \n break ; \n case 0x4401 : \n url_fskip ( pb , 16 ) ; \n get_buffer ( pb , package -> package_uid , 16 ) ; \n break ; \n case 0x4701 : \n get_buffer ( pb , package -> descriptor_ref , 16 ) ; \n break ; \n } \n return 0 ; \n }", "idx": 17100}
{"project": "FFmpeg", "commit_id": "97392553656a7f4fabde9ded4d2b7f538d98ee17", "target": 1, "func": "static av_cold void movie_uninit ( AVFilterContext * ctx ) \n { \n MovieContext * movie = ctx -> priv ; \n int i ; \n for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) { \n av_freep ( & ctx -> output_pads [ i ] . name ) ; \n if ( movie -> st [ i ] . st ) \n avcodec_close ( movie -> st [ i ] . st -> codec ) ; \n } \n av_freep ( & movie -> st ) ; \n av_freep ( & movie -> out_index ) ; \n av_frame_free ( & movie -> frame ) ; \n if ( movie -> format_ctx ) \n avformat_close_input ( & movie -> format_ctx ) ; \n }", "idx": 17116}
{"project": "FFmpeg", "commit_id": "2884cf205a9a29d89db7a444c5b1613cdfe37acf", "target": 0, "func": "static inline int get_egolomb ( GetBitContext * gb ) \n { \n int v = 4 ; \n while ( get_bits1 ( gb ) ) v ++ ; \n return ( 1 << v ) + get_bits ( gb , v ) ; \n }", "idx": 17126}
{"project": "FFmpeg", "commit_id": "a51fbb56bb9352476affaef1fc6773c8b059db91", "target": 0, "func": "static av_cold void common_init ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n s -> width = s -> avctx -> width ; \n s -> height = s -> avctx -> height ; \n s -> codec_id = s -> avctx -> codec -> id ; \n ff_h264dsp_init ( & h -> h264dsp , 8 , 1 ) ; \n ff_h264_pred_init ( & h -> hpc , s -> codec_id , 8 , 1 ) ; \n h -> dequant_coeff_pps = -1 ; \n s -> unrestricted_mv = 1 ; \n s -> decode = 1 ; \n dsputil_init ( & s -> dsp , s -> avctx ) ; \n memset ( h -> pps . scaling_matrix4 , 16 , 6 * 16 * sizeof ( uint8_t ) ) ; \n memset ( h -> pps . scaling_matrix8 , 16 , 2 * 64 * sizeof ( uint8_t ) ) ; \n }", "idx": 17130}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2rgb555_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \" \n YSCALEYUV2RGB ( % % REGBP , % 5 ) \n \" \\n \\t \" \n #ifdef DITHER1XBPP \n \" \" BLUE_DITHER \" \\n \\t \" \n \" \" GREEN_DITHER \" \\n \\t \" \n \" \" RED_DITHER \" \\n \\t \" \n #endif \n WRITERGB15 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) \n ) ; \n }", "idx": 17131}
{"project": "FFmpeg", "commit_id": "e80b2b9c81716a5d9f559c04cfe69d76b04e4cd3", "target": 0, "func": "static int dca_find_frame_end ( DCAParseContext * pc1 , const uint8_t * buf , \n int buf_size ) \n { \n int start_found , i ; \n uint32_t state ; \n ParseContext * pc = & pc1 -> pc ; \n start_found = pc -> frame_start_found ; \n state = pc -> state ; \n i = 0 ; \n if ( ! start_found ) { \n for ( i = 0 ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( IS_MARKER ( state , i , buf , buf_size ) ) { \n if ( ! pc1 -> lastmarker || state == pc1 -> lastmarker || pc1 -> lastmarker == DCA_SYNCWORD_SUBSTREAM ) { \n start_found = 1 ; \n pc1 -> lastmarker = state ; \n i ++ ; \n break ; \n } \n } \n } \n } \n if ( start_found ) { \n for ( ; i < buf_size ; i ++ ) { \n pc1 -> size ++ ; \n state = ( state << 8 ) | buf [ i ] ; \n if ( state == DCA_SYNCWORD_SUBSTREAM && ! pc1 -> hd_pos ) \n pc1 -> hd_pos = pc1 -> size ; \n if ( IS_MARKER ( state , i , buf , buf_size ) && ( state == pc1 -> lastmarker || pc1 -> lastmarker == DCA_SYNCWORD_SUBSTREAM ) ) { \n if ( pc1 -> framesize > pc1 -> size ) \n continue ; \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n pc1 -> size = 0 ; \n return i - 3 ; \n } \n } \n } \n pc -> frame_start_found = start_found ; \n pc -> state = state ; \n return END_NOT_FOUND ; \n }", "idx": 17158}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel8_mc12_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_8w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 8 , 0 ) ; \n }", "idx": 17169}
{"project": "FFmpeg", "commit_id": "cabfed6895fcc679cd6a6244a12d800e0f3f2d20", "target": 1, "func": "static int msvideo1_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n Msvideo1Context * s = avctx -> priv_data ; \n int ret ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) \n return ret ; \n if ( s -> mode_8bit ) { \n int size ; \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , & size ) ; \n if ( pal && size == AVPALETTE_SIZE ) { \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n s -> frame -> palette_has_changed = 1 ; \n } else if ( pal ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , size ) ; \n if ( s -> mode_8bit ) \n msvideo1_decode_8bit ( s ) ; \n else \n msvideo1_decode_16bit ( s ) ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n * got_frame = 1 ; \n return buf_size ;", "idx": 17171}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb16tobgr24 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n const uint16_t * end ; \n uint8_t * d = ( uint8_t * ) dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n while ( s < end ) \n { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0xF800 ) >> 8 ; \n * d ++ = ( bgr & 0x7E0 ) >> 3 ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n } \n }", "idx": 17173}
{"project": "FFmpeg", "commit_id": "ecff5acb5a738fcb4f9e206a12070dac4bf259b3", "target": 1, "func": "static int svq1_motion_inter_block ( DSPContext * dsp , GetBitContext * bitbuf , \n uint8_t * current , uint8_t * previous , \n int pitch , svq1_pmv * motion , int x , int y ) \n { \n uint8_t * src ; \n uint8_t * dst ; \n svq1_pmv mv ; \n svq1_pmv * pmv [ 3 ] ; \n int result ; \n pmv [ 0 ] = & motion [ 0 ] ; \n if ( y == 0 ) { \n pmv [ 1 ] = \n pmv [ 2 ] = pmv [ 0 ] ; \n } else { \n pmv [ 1 ] = & motion [ x / 8 + 2 ] ; \n pmv [ 2 ] = & motion [ x / 8 + 4 ] ; \n } \n result = svq1_decode_motion_vector ( bitbuf , & mv , pmv ) ; \n if ( result != 0 ) \n return result ; \n motion [ 0 ] . x = \n motion [ x / 8 + 2 ] . x = \n motion [ x / 8 + 3 ] . x = mv . x ; \n motion [ 0 ] . y = \n motion [ x / 8 + 2 ] . y = \n motion [ x / 8 + 3 ] . y = mv . y ; \n if ( y + ( mv . y >> 1 ) < 0 ) \n mv . y = 0 ; \n if ( x + ( mv . x >> 1 ) < 0 ) \n mv . x = 0 ; \n src = & previous [ ( x + ( mv . x >> 1 ) ) + ( y + ( mv . y >> 1 ) ) * pitch ] ; \n dst = current ; \n dsp -> put_pixels_tab [ 0 ] [ ( mv . y & 1 ) << 1 | ( mv . x & 1 ) ] ( dst , src , pitch , 16 ) ; \n return 0 ; \n }", "idx": 17176}
{"project": "FFmpeg", "commit_id": "125acd215250ead008938266efcacd56743f3a2a", "target": 0, "func": "static int graph_config_formats ( AVFilterGraph * graph , AVClass * log_ctx ) \n { \n int ret ; \n if ( ( ret = query_formats ( graph , log_ctx ) ) < 0 ) \n return ret ; \n reduce_formats ( graph ) ; \n swap_sample_fmts ( graph ) ; \n swap_samplerates ( graph ) ; \n swap_channel_layouts ( graph ) ; \n if ( ( ret = pick_formats ( graph ) ) < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 17182}
{"project": "FFmpeg", "commit_id": "69c23e6f33c38ebc03ce7f51fcb963deaff7383b", "target": 0, "func": "static int pred ( float * in , float * tgt , int n ) \n { \n int x , y ; \n float * p1 , * p2 ; \n double f0 , f1 , f2 ; \n float temp ; \n if ( in [ n ] == 0 ) \n return 0 ; \n if ( ( f0 = * in ) <= 0 ) \n return 0 ; \n for ( x = 1 ; ; x ++ ) { \n if ( n < x ) \n return 1 ; \n p1 = in + x ; \n p2 = tgt ; \n f1 = * ( p1 -- ) ; \n for ( y = x ; -- y ; f1 += ( * ( p1 -- ) ) * ( * ( p2 ++ ) ) ) ; \n p1 = tgt + x - 1 ; \n p2 = tgt ; \n * ( p1 -- ) = f2 = - f1 / f0 ; \n for ( y = x >> 1 ; y -- ; ) { \n temp = * p2 + * p1 * f2 ; \n * ( p1 -- ) += * p2 * f2 ; \n * ( p2 ++ ) = temp ; \n } \n if ( ( f0 += f1 * f2 ) < 0 ) \n return 0 ; \n } \n }", "idx": 17184}
{"project": "FFmpeg", "commit_id": "b6ee25e300420a3c98b78a1c2e983250ff065038", "target": 1, "func": "static inline struct rgbvec interp_trilinear ( const LUT3DContext * lut3d , \n const struct rgbvec * s ) \n { \n const struct rgbvec d = { s -> r - PREV ( s -> r ) , s -> g - PREV ( s -> g ) , s -> b - PREV ( s -> b ) } ; \n const struct rgbvec c000 = lut3d -> lut [ PREV ( s -> r ) ] [ PREV ( s -> g ) ] [ PREV ( s -> b ) ] ; \n const struct rgbvec c001 = lut3d -> lut [ PREV ( s -> r ) ] [ PREV ( s -> g ) ] [ NEXT ( s -> b ) ] ; \n const struct rgbvec c010 = lut3d -> lut [ PREV ( s -> r ) ] [ NEXT ( s -> g ) ] [ PREV ( s -> b ) ] ; \n const struct rgbvec c011 = lut3d -> lut [ PREV ( s -> r ) ] [ NEXT ( s -> g ) ] [ NEXT ( s -> b ) ] ; \n const struct rgbvec c100 = lut3d -> lut [ NEXT ( s -> r ) ] [ PREV ( s -> g ) ] [ PREV ( s -> b ) ] ; \n const struct rgbvec c101 = lut3d -> lut [ NEXT ( s -> r ) ] [ PREV ( s -> g ) ] [ NEXT ( s -> b ) ] ; \n const struct rgbvec c110 = lut3d -> lut [ NEXT ( s -> r ) ] [ NEXT ( s -> g ) ] [ PREV ( s -> b ) ] ; \n const struct rgbvec c111 = lut3d -> lut [ NEXT ( s -> r ) ] [ NEXT ( s -> g ) ] [ NEXT ( s -> b ) ] ; \n const struct rgbvec c00 = lerp ( & c000 , & c100 , d . r ) ; \n const struct rgbvec c10 = lerp ( & c010 , & c110 , d . r ) ; \n const struct rgbvec c01 = lerp ( & c001 , & c101 , d . r ) ; \n const struct rgbvec c11 = lerp ( & c011 , & c111 , d . r ) ; \n const struct rgbvec c0 = lerp ( & c00 , & c10 , d . g ) ; \n const struct rgbvec c1 = lerp ( & c01 , & c11 , d . g ) ; \n const struct rgbvec c = lerp ( & c0 , & c1 , d . b ) ; \n return c ; \n }", "idx": 17187}
{"project": "FFmpeg", "commit_id": "89b51b570daa80e6e3790fcd449fe61fc5574e07", "target": 1, "func": "static int ogg_read_close ( AVFormatContext * s ) \n { \n struct ogg * ogg = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) { \n av_free ( ogg -> streams [ i ] . buf ) ; \n av_free ( ogg -> streams [ i ] . private ) ; \n } \n av_free ( ogg -> streams ) ; \n return 0 ; \n }", "idx": 17189}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "av_cold void ff_blockdsp_init ( BlockDSPContext * c , AVCodecContext * avctx ) \n { \n c -> clear_block = clear_block_8_c ; \n c -> clear_blocks = clear_blocks_8_c ; \n c -> fill_block_tab [ 0 ] = fill_block16_c ; \n c -> fill_block_tab [ 1 ] = fill_block8_c ; \n if ( ARCH_ARM ) \n ff_blockdsp_init_arm ( c ) ; \n if ( ARCH_PPC ) \n ff_blockdsp_init_ppc ( c ) ; \n if ( ARCH_X86 )  \n #if FF_API_XVMC  \n  \n  ff_blockdsp_init_x86 ( c , avctx ) ; \n #else \n ff_blockdsp_init_x86 ( c ) ; \n #endif \n }", "idx": 17198}
{"project": "FFmpeg", "commit_id": "26f027fba1c5ab482fa2488fbe0fa36c8bb33b69", "target": 1, "func": "static void estimate_timings_from_bit_rate ( AVFormatContext * ic ) \n { \n int64_t filesize , duration ; \n int i ; \n AVStream * st ; \n if ( ic -> bit_rate <= 0 ) { \n int bit_rate = 0 ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n if ( st -> codec -> bit_rate > 0 ) { \n if ( INT_MAX - st -> codec -> bit_rate > bit_rate ) { \n bit_rate = 0 ; \n break ; \n } \n bit_rate += st -> codec -> bit_rate ; \n } \n } \n ic -> bit_rate = bit_rate ; \n } \n if ( ic -> duration == AV_NOPTS_VALUE && \n ic -> bit_rate != 0 ) { \n filesize = ic -> pb ? avio_size ( ic -> pb ) : 0 ; \n if ( filesize > 0 ) { \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n duration = av_rescale ( 8 * filesize , st -> time_base . den , ic -> bit_rate * ( int64_t ) st -> time_base . num ) ; \n if ( st -> duration == AV_NOPTS_VALUE ) \n st -> duration = duration ; \n } \n } \n } \n }", "idx": 17200}
{"project": "FFmpeg", "commit_id": "6fb2fd895e858ab93f46e656a322778ee181c307", "target": 1, "func": "AVFilterBufferRef * avfilter_ref_buffer ( AVFilterBufferRef * ref , int pmask ) \n { \n AVFilterBufferRef * ret = av_malloc ( sizeof ( AVFilterBufferRef ) ) ; \n if ( ! ret ) \n return NULL ; \n * ret = * ref ; \n if ( ref -> type == AVMEDIA_TYPE_VIDEO ) { \n ret -> video = av_malloc ( sizeof ( AVFilterBufferRefVideoProps ) ) ; \n if ( ! ret -> video ) { \n av_free ( ret ) ; \n return NULL ; \n } \n copy_video_props ( ret -> video , ref -> video ) ; \n ret -> extended_data = ret -> data ; \n } else if ( ref -> type == AVMEDIA_TYPE_AUDIO ) { \n ret -> audio = av_malloc ( sizeof ( AVFilterBufferRefAudioProps ) ) ; \n if ( ! ret -> audio ) { \n av_free ( ret ) ; \n return NULL ; \n } \n * ret -> audio = * ref -> audio ; \n if ( ref -> extended_data && ref -> extended_data != ref -> data ) { \n int nb_channels = av_get_channel_layout_nb_channels ( ref -> audio -> channel_layout ) ; \n if ( ! ( ret -> extended_data = av_malloc ( sizeof ( * ret -> extended_data ) * \n nb_channels ) ) ) { \n av_freep ( & ret -> audio ) ; \n av_freep ( & ret ) ; \n return NULL ; \n } \n memcpy ( ret -> extended_data , ref -> extended_data , \n sizeof ( * ret -> extended_data ) * nb_channels ) ; \n } else \n ret -> extended_data = ret -> data ; \n } \n ret -> perms &= pmask ; \n ret -> buf -> refcount ++ ; \n return ret ; \n }", "idx": 17201}
{"project": "FFmpeg", "commit_id": "5836a5037ecbbd9b10ac85cdec5ff8cccb1177d0", "target": 0, "func": "static int integrate ( hdcd_state_t * state , int * flag , const int32_t * samples , int count , int stride ) \n { \n uint32_t bits = 0 ; \n int result = FFMIN ( state -> readahead , count ) ; \n int i ; \n * flag = 0 ; \n for ( i = result - 1 ; i >= 0 ; i -- ) { \n bits |= ( * samples & 1 ) << i ; \n samples += stride ; \n } \n state -> window = ( state -> window << result ) | bits ; \n state -> readahead -= result ; \n if ( state -> readahead > 0 ) \n return result ; \n bits = ( state -> window ^ state -> window >> 5 ^ state -> window >> 23 ) ; \n if ( state -> arg ) { \n if ( ( bits & 0xffffffc8 ) == 0x0fa00500 ) { \n state -> control = ( bits & 255 ) + ( bits & 7 ) ; \n * flag = 1 ; \n state -> code_counterA ++ ; \n } \n if ( ( ( bits ^ ( ~ bits >> 8 & 255 ) ) & 0xffff00ff ) == 0xa0060000 ) { \n state -> control = bits >> 8 & 255 ; \n * flag = 1 ; \n state -> code_counterB ++ ; \n } \n state -> arg = 0 ; \n } \n if ( bits == 0x7e0fa005 || bits == 0x7e0fa006 ) { \n state -> readahead = ( bits & 3 ) * 8 ; \n state -> arg = 1 ; \n state -> code_counterC ++ ; \n } else { \n if ( bits ) \n state -> readahead = readaheadtab [ bits & ~ ( -1 << 8 ) ] ; \n else \n state -> readahead = 31 ; \n } \n return result ; \n }", "idx": 17204}
{"project": "FFmpeg", "commit_id": "2139e584391b6db7ad315cf4f6443f87f7813d51", "target": 1, "func": "static int64_t dv_frame_offset ( AVFormatContext * s , DVDemuxContext * c , \n int64_t timestamp , int flags ) \n { \n const AVDVProfile * sys = av_dv_codec_profile2 ( c -> vst -> codec -> width , c -> vst -> codec -> height , \n c -> vst -> codec -> pix_fmt , c -> vst -> codec -> time_base ) ; \n int64_t offset ; \n int64_t size = avio_size ( s -> pb ) - s -> internal -> data_offset ; \n int64_t max_offset = ( ( size - 1 ) / sys -> frame_size ) * sys -> frame_size ; \n offset = sys -> frame_size * timestamp ; \n if ( size >= 0 && offset > max_offset ) \n offset = max_offset ; \n else if ( offset < 0 ) \n offset = 0 ; \n return offset + s -> internal -> data_offset ; \n }", "idx": 17211}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( uyvyToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , long width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm4 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( - width ) , \" \" ( src1 + width * 4 ) , \" \" ( dstU + width ) , \" \" ( dstV + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = src1 [ 4 * i + 0 ] ; \n dstV [ i ] = src1 [ 4 * i + 2 ] ; \n } \n #endif \n assert ( src1 == src2 ) ; \n }", "idx": 17217}
{"project": "FFmpeg", "commit_id": "b829da363985cb2f80130bba304cc29a632f6446", "target": 1, "func": "static int smacker_decode_tree ( GetBitContext * gb , HuffContext * hc , uint32_t prefix , int length ) \n { \n if ( ! get_bits1 ( gb ) ) { \n if ( hc -> current >= 256 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n if ( length ) { \n hc -> bits [ hc -> current ] = prefix ; \n hc -> lengths [ hc -> current ] = length ; \n } else { \n hc -> bits [ hc -> current ] = 0 ; \n hc -> lengths [ hc -> current ] = 0 ; \n hc -> values [ hc -> current ] = get_bits ( gb , 8 ) ; \n hc -> current ++ ; \n if ( hc -> maxlength < length ) \n hc -> maxlength = length ; \n return 0 ; \n } else  { \n int r ; \n length ++ ; \n r = smacker_decode_tree ( gb , hc , prefix , length ) ; \n if ( r ) \n return r ; \n return smacker_decode_tree ( gb , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ;", "idx": 17238}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_2d_vlc_rl ( RLTable * rl ) \n { \n int i ; \n init_vlc ( & rl -> vlc , TEX_VLC_BITS , rl -> n + 2 , \n & rl -> table_vlc [ 0 ] [ 1 ] , 4 , 2 , \n & rl -> table_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; \n rl -> rl_vlc [ 0 ] = av_malloc ( rl -> vlc . table_size * sizeof ( RL_VLC_ELEM ) ) ; \n for ( i = 0 ; i < rl -> vlc . table_size ; i ++ ) { \n int code = rl -> vlc . table [ i ] [ 0 ] ; \n int len = rl -> vlc . table [ i ] [ 1 ] ; \n int level , run ; \n if ( len == 0 ) { \n run = 65 ; \n level = MAX_LEVEL ; \n } else if ( len < 0 ) { \n run = 0 ; \n level = code ; \n } else { \n if ( code == rl -> n ) { \n run = 65 ; \n level = 0 ; \n } else if ( code == rl -> n + 1 ) { \n run = 0 ; \n level = 127 ; \n } else { \n run = rl -> table_run [ code ] + 1 ; \n level = rl -> table_level [ code ] ; \n } \n } \n rl -> rl_vlc [ 0 ] [ i ] . len = len ; \n rl -> rl_vlc [ 0 ] [ i ] . level = level ; \n rl -> rl_vlc [ 0 ] [ i ] . run = run ; \n } \n }", "idx": 17239}
{"project": "FFmpeg", "commit_id": "7ab631261033a71a52563c3b23b6eef826eb5994", "target": 1, "func": "static void draw_rectangle ( unsigned val , uint8_t * dst , int dst_linesize , unsigned segment_width , \n unsigned x , unsigned y , unsigned w , unsigned h ) \n { \n int i ; \n int step = 3 ; \n dst += segment_width * ( step * x + y * dst_linesize ) ; \n w *= segment_width * step ; \n h *= segment_width ; \n for ( i = 0 ; i < h ; i ++ ) { \n memset ( dst , val , w ) ; \n dst += dst_linesize ; \n } \n }", "idx": 17278}
{"project": "FFmpeg", "commit_id": "d8245c3bcdd162891825a52cf55e4e8173d85a18", "target": 1, "func": "static av_cold int cinvideo_decode_init ( AVCodecContext * avctx ) \n { \n CinVideoContext * cin = avctx -> priv_data ; \n unsigned int i ; \n cin -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n avcodec_get_frame_defaults ( & cin -> frame ) ; \n cin -> frame . data [ 0 ] = NULL ; \n cin -> bitmap_size = avctx -> width * avctx -> height ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n cin -> bitmap_table [ i ] = av_mallocz ( cin -> bitmap_size ) ; \n if ( ! cin -> bitmap_table [ i ] ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n return 0 ; \n }", "idx": 17283}
{"project": "FFmpeg", "commit_id": "3438d82d4b3bd987304975961e2a42e82767107d", "target": 0, "func": "static int ffm_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n FFMContext * ffm = s -> priv_data ; \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n int64_t pts ; \n uint8_t header [ FRAME_HEADER_SIZE ] ; \n pts = ffm -> start_time + pkt -> pts ; \n header [ 0 ] = pkt -> stream_index ; \n header [ 1 ] = 0 ; \n if ( pkt -> flags & PKT_FLAG_KEY ) \n header [ 1 ] |= FLAG_KEY_FRAME ; \n AV_WB24 ( header + 2 , pkt -> size ) ; \n AV_WB24 ( header + 5 , pkt -> duration ) ; \n ffm_write_data ( s , header , FRAME_HEADER_SIZE , pts , 1 ) ; \n ffm_write_data ( s , pkt -> data , pkt -> size , pts , 0 ) ; \n return 0 ; \n }", "idx": 17290}
{"project": "FFmpeg", "commit_id": "1a2a1d90775b5be03254d123e4b617145a269572", "target": 0, "func": "static inline void range_dec_normalize ( APEContext * ctx ) \n { \n while ( ctx -> rc . range <= BOTTOM_VALUE ) { \n ctx -> rc . buffer = ( ctx -> rc . buffer << 8 ) | bytestream_get_byte ( & ctx -> ptr ) ; \n ctx -> rc . low = ( ctx -> rc . low << 8 ) | ( ( ctx -> rc . buffer >> 1 ) & 0xFF ) ; \n ctx -> rc . range <<= 8 ; \n } \n }", "idx": 17291}
{"project": "FFmpeg", "commit_id": "3b20ed85489a14cb5028c873d06960dbc5eef88a", "target": 0, "func": "static int read_rle_sgi ( uint8_t * out_buf , SgiState * s ) \n { \n uint8_t * dest_row ; \n unsigned int len = s -> height * s -> depth * 4 ; \n GetByteContext g_table = s -> g ; \n unsigned int y , z ; \n unsigned int start_offset ; \n int linesize , ret ; \n if ( len * 2 > bytestream2_get_bytes_left ( & s -> g ) ) { \n return AVERROR_INVALIDDATA ; \n } \n for ( z = 0 ; z < s -> depth ; z ++ ) { \n dest_row = out_buf ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n linesize = s -> width * s -> depth * s -> bytes_per_channel ; \n dest_row -= s -> linesize ; \n start_offset = bytestream2_get_be32 ( & g_table ) ; \n bytestream2_seek ( & s -> g , start_offset , SEEK_SET ) ; \n if ( s -> bytes_per_channel == 1 ) \n ret = expand_rle_row8 ( s , dest_row + z , linesize , s -> depth ) ; \n else \n ret = expand_rle_row16 ( s , ( uint16_t * ) dest_row + z , linesize , s -> depth ) ; \n if ( ret != s -> width ) \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 17292}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static int xvid_ff_2pass_destroy ( struct xvid_context * ref , \n xvid_plg_destroy_t * param ) { \n if ( ref -> twopassbuffer != NULL ) \n ref -> twopassbuffer [ 0 ] = 0 ; \n return 0 ; \n }", "idx": 17293}
{"project": "FFmpeg", "commit_id": "b15a9888a8f8e8cc9784ffd8d5d0307900fb78bb", "target": 1, "func": "static int sol_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n int ret ; \n if ( s -> pb -> eof_reached ) \n return AVERROR ( EIO ) ; \n ret = av_get_packet ( s -> pb , pkt , MAX_SIZE ) ; \n pkt -> stream_index = 0 ; \n pkt -> size = ret ; \n return 0 ; \n }", "idx": 17296}
{"project": "FFmpeg", "commit_id": "4ee247a2bdf2fbe81026a428d4affc46c81f28db", "target": 0, "func": "static int flv_write_trailer ( AVFormatContext * s ) \n { \n int64_t file_size ; \n AVIOContext * pb = s -> pb ; \n FLVContext * flv = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVCodecContext * enc = s -> streams [ i ] -> codec ; \n if ( enc -> codec_type == AVMEDIA_TYPE_VIDEO && \n enc -> codec_id == CODEC_ID_H264 ) { \n put_avc_eos_tag ( pb , flv -> last_video_ts ) ; \n } \n } \n file_size = avio_tell ( pb ) ; \n avio_seek ( pb , flv -> duration_offset , SEEK_SET ) ; \n put_amf_double ( pb , flv -> duration / ( double ) 1000 ) ; \n avio_seek ( pb , flv -> filesize_offset , SEEK_SET ) ; \n put_amf_double ( pb , file_size ) ; \n avio_seek ( pb , file_size , SEEK_SET ) ; \n return 0 ; \n }", "idx": 17319}
{"project": "FFmpeg", "commit_id": "d509c743b78da198af385fea362b632292cd00ad", "target": 1, "func": "static int dv_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n unsigned state ; \n RawDVContext * c = s -> priv_data ; \n c -> dv_demux = dv_init_demux ( s ) ; \n if ( ! c -> dv_demux ) \n return -1 ; \n state = get_be32 ( s -> pb ) ; \n while ( ( state & 0xffffff7f ) != 0x1f07003f ) { \n if ( url_feof ( s -> pb ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n state = ( state << 8 ) | get_byte ( s -> pb ) ; \n } \n AV_WB32 ( c -> buf , state ) ; \n if ( get_buffer ( s -> pb , c -> buf + 4 , DV_PROFILE_BYTES - 4 ) <= 0 || \n url_fseek ( s -> pb , - DV_PROFILE_BYTES , SEEK_CUR ) < 0 ) \n return AVERROR ( EIO ) ; \n c -> dv_demux -> sys = dv_frame_profile ( c -> buf ) ; \n if ( ! c -> dv_demux -> sys ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> bit_rate = av_rescale_q ( c -> dv_demux -> sys -> frame_size , ( AVRational ) { 8 , 1 } , \n c -> dv_demux -> sys -> time_base ) ; \n return 0 ; \n }", "idx": 17334}
{"project": "FFmpeg", "commit_id": "9525243f59f0a13e099612b66f7ba5d5d5293c70", "target": 1, "func": "void av_read_image_line ( uint16_t * dst , const uint8_t * data [ 4 ] , const int linesize [ 4 ] , \n const AVPixFmtDescriptor * desc , int x , int y , int c , int w , int read_pal_component ) \n { \n AVComponentDescriptor comp = desc -> comp [ c ] ; \n int plane = comp . plane ; \n int depth = comp . depth_minus1 + 1 ; \n int mask = ( 1 << depth ) - 1 ; \n int shift = comp . shift ; \n int step = comp . step_minus1 + 1 ; \n int flags = desc -> flags ; \n if ( flags & PIX_FMT_BITSTREAM ) { \n int skip = x * step + comp . offset_plus1 - 1 ; \n const uint8_t * p = data [ plane ] + y * linesize [ plane ] + ( skip >> 3 ) ; \n int shift = 8 - depth - ( skip & 7 ) ; \n while ( w -- ) { \n int val = ( * p >> shift ) & mask ; \n if ( read_pal_component ) \n val = data [ 1 ] [ 4 * val + c ] ; \n shift -= step ; \n p -= shift >> 3 ; \n shift &= 7 ; \n * dst ++ = val ; \n } \n } else { \n const uint8_t * p = data [ plane ] + y * linesize [ plane ] + x * step + comp . offset_plus1 - 1 ; \n while ( w -- ) { \n int val = flags & PIX_FMT_BE ? AV_RB16 ( p ) : AV_RL16 ( p ) ; \n val = ( val >> shift ) & mask ; \n if ( read_pal_component ) \n val = data [ 1 ] [ 4 * val + c ] ; \n p += step ; \n * dst ++ = val ; \n } \n } \n }", "idx": 17340}
{"project": "FFmpeg", "commit_id": "807d4b635567e51108ea3a6a774336321c3250e5", "target": 0, "func": "int attribute_align_arg av_buffersink_get_frame_flags ( AVFilterContext * ctx , AVFrame * frame , int flags ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n int ret ; \n AVFrame * cur_frame ; \n if ( ! av_fifo_size ( buf -> fifo ) ) { \n if ( inlink -> closed ) \n return AVERROR_EOF ; \n if ( flags & AV_BUFFERSINK_FLAG_NO_REQUEST ) \n return AVERROR ( EAGAIN ) ; \n if ( ( ret = ff_request_frame ( inlink ) ) < 0 ) \n return ret ; \n } \n if ( ! av_fifo_size ( buf -> fifo ) ) \n return AVERROR ( EINVAL ) ; \n if ( flags & AV_BUFFERSINK_FLAG_PEEK ) { \n cur_frame = * ( ( AVFrame * * ) av_fifo_peek2 ( buf -> fifo , 0 ) ) ; \n if ( ( ret = av_frame_ref ( frame , cur_frame ) ) < 0 ) \n return ret ; \n } else { \n av_fifo_generic_read ( buf -> fifo , & cur_frame , sizeof ( cur_frame ) , NULL ) ; \n av_frame_move_ref ( frame , cur_frame ) ; \n av_frame_free ( & cur_frame ) ; \n } \n return 0 ; \n }", "idx": 17343}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yvu9toyv12 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , \n uint8_t * ydst , uint8_t * udst , uint8_t * vdst , \n unsigned int width , unsigned int height , int lumStride , int chromStride ) \n { \n memcpy ( ydst , ysrc , width * height ) ; \n }", "idx": 17348}
{"project": "FFmpeg", "commit_id": "0ac83047f67bb56406c66d4ca664d3c0cb07c2f2", "target": 1, "func": "static void sub2video_copy_rect ( uint8_t * dst , int dst_linesize , int w , int h , \n AVSubtitleRect * r ) \n { \n uint32_t * pal , * dst2 ; \n uint8_t * src , * src2 ; \n int x , y ; \n if ( r -> type != SUBTITLE_BITMAP ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n return ; \n } \n if ( r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h ) { \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" ) ; \n return ; \n } \n dst += r -> y * dst_linesize + r -> x * 4 ; \n src = r -> pict . data [ 0 ] ; \n pal = ( uint32_t * ) r -> pict . data [ 1 ] ; \n for ( y = 0 ; y < r -> h ; y ++ ) { \n dst2 = ( uint32_t * ) dst ; \n src2 = src ; \n for ( x = 0 ; x < r -> w ; x ++ ) \n * ( dst2 ++ ) = pal [ * ( src2 ++ ) ] ; \n dst += dst_linesize ; \n src += r -> pict . linesize [ 0 ] ; \n } \n }", "idx": 17351}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "SchroVideoFormatEnum ff_get_schro_video_format_preset ( AVCodecContext * avctx ) \n { \n unsigned int num_formats = sizeof ( ff_schro_video_formats ) / \n sizeof ( ff_schro_video_formats [ 0 ] ) ; \n unsigned int idx = get_video_format_idx ( avctx ) ; \n return ( idx < num_formats ) ? ff_schro_video_formats [ idx ] : \n SCHRO_VIDEO_FORMAT_CUSTOM ; \n }", "idx": 17352}
{"project": "FFmpeg", "commit_id": "45d199d5b0b7f09eb9baa29929a3bd07ed46223b", "target": 0, "func": "static int aac_adtstoasc_init ( AVBSFContext * ctx ) \n { \n av_freep ( & ctx -> par_out -> extradata ) ; \n ctx -> par_out -> extradata_size = 0 ; \n return 0 ; \n }", "idx": 17356}
{"project": "FFmpeg", "commit_id": "a566c952f905639456966413fee0b5701867ddcd", "target": 1, "func": "static void mpegts_write_section ( MpegTSSection * s , uint8_t * buf , int len ) \n { \n unsigned int crc ; \n unsigned char packet [ TS_PACKET_SIZE ] ; \n const unsigned char * buf_ptr ; \n unsigned char * q ; \n int first , b , len1 , left ; \n crc = av_bswap32 ( av_crc ( av_crc_get_table ( AV_CRC_32_IEEE ) , \n -1 , buf , len - 4 ) ) ; \n buf [ len - 4 ] = ( crc >> 24 ) & 0xff ; \n buf [ len - 3 ] = ( crc >> 16 ) & 0xff ; \n buf [ len - 2 ] = ( crc >> 8 ) & 0xff ; \n buf [ len - 1 ] = crc & 0xff ; \n buf_ptr = buf ; \n while ( len > 0 ) { \n first = buf == buf_ptr ; \n q = packet ; \n * q ++ = 0x47 ; \n b = s -> pid >> 8 ; \n if ( first ) \n b |= 0x40 ; \n * q ++ = b ; \n * q ++ = s -> pid ; \n s -> cc = s -> cc + 1 & 0xf ; \n * q ++ = 0x10 | s -> cc ; \n if ( first ) \n * q ++ = 0 ; \n len1 = TS_PACKET_SIZE - ( q - packet ) ; \n if ( len1 > len ) \n len1 = len ; \n memcpy ( q , buf_ptr , len1 ) ; \n q += len1 ; \n left = TS_PACKET_SIZE - ( q - packet ) ; \n if ( left > 0 ) \n memset ( q , 0xff , left ) ; \n s -> write_packet ( s , packet ) ; \n buf_ptr += len1 ; \n len -= len1 ;", "idx": 17363}
{"project": "FFmpeg", "commit_id": "0af48e29f55a4e5824e6f7157ac94cf8b210aa84", "target": 1, "func": "static void decode_blocks ( SnowContext * s ) { \n int x , y ; \n int w = s -> b_width ; \n int h = s -> b_height ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n decode_q_branch ( s , 0 , x , y ) ; \n } \n } \n }", "idx": 17371}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void mpeg4_encode_gop_header ( MpegEncContext * s ) \n { \n int hours , minutes , seconds ; \n int64_t time ; \n put_bits ( & s -> pb , 16 , 0 ) ; \n put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; \n time = s -> current_picture_ptr -> f . pts ; \n if ( s -> reordered_input_picture [ 1 ] ) \n time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> f . pts ) ; \n time = time * s -> avctx -> time_base . num ; \n seconds = time / s -> avctx -> time_base . den ; \n minutes = seconds / 60 ; \n seconds %= 60 ; \n hours = minutes / 60 ; \n minutes %= 60 ; \n hours %= 24 ; \n put_bits ( & s -> pb , 5 , hours ) ; \n put_bits ( & s -> pb , 6 , minutes ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 6 , seconds ) ; \n put_bits ( & s -> pb , 1 , ! ! ( s -> flags & CODEC_FLAG_CLOSED_GOP ) ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n s -> last_time_base = time / s -> avctx -> time_base . den ; \n ff_mpeg4_stuffing ( & s -> pb ) ; \n }", "idx": 17373}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static int append_extradata ( APNGDemuxContext * ctx , AVIOContext * pb , int len ) \n { \n int previous_size = ctx -> extra_data_size ; \n int new_size , ret ; \n uint8_t * new_extradata ; \n if ( previous_size > INT_MAX - len ) \n return AVERROR_INVALIDDATA ; \n new_size = previous_size + len ; \n new_extradata = av_realloc ( ctx -> extra_data , new_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! new_extradata ) \n return AVERROR ( ENOMEM ) ; \n ctx -> extra_data = new_extradata ; \n ctx -> extra_data_size = new_size ; \n if ( ( ret = avio_read ( pb , ctx -> extra_data + previous_size , len ) ) < 0 ) \n return ret ; \n return previous_size ; \n }", "idx": 17380}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void libschroedinger_decode_buffer_free ( SchroBuffer * schro_buf , \n void * priv ) \n { \n av_freep ( & priv ) ; \n }", "idx": 17393}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_encode_header ( AVCodecContext * avctx , unsigned char * buf , size_t bufsize ) \n { \n #if 0  \n  \n  struct { \n uint32_t offset ; \n unsigned char unknown1 [ 3 ] ; \n unsigned char channel ; \n uint32_t freq ; \n uint32_t size ; \n uint32_t unknown2 ; \n uint32_t unknown3 ; \n uint32_t unknown4 ; \n } adxhdr ; \n #endif \n write_long ( buf + 0x00 , 0x80000000 | 0x20 ) ; \n write_long ( buf + 0x04 , 0x03120400 | avctx -> channels ) ; \n write_long ( buf + 0x08 , avctx -> sample_rate ) ; \n write_long ( buf + 0x0c , 0 ) ; \n write_long ( buf + 0x10 , 0x01040300 ) ; \n write_long ( buf + 0x14 , 0x00000000 ) ; \n write_long ( buf + 0x18 , 0x00000000 ) ; \n memcpy ( buf + 0x1c , \" \\0 \\0 \" , 8 ) ; \n return 0x20 + 4 ; \n }", "idx": 17395}
{"project": "FFmpeg", "commit_id": "254af56dd101bc756194dd080bb99e8f123500dd", "target": 1, "func": "static void read_tree ( GetBitContext * gb , Tree * tree ) \n { \n uint8_t tmp1 [ 16 ] , tmp2 [ 16 ] , * in = tmp1 , * out = tmp2 ; \n int i , t , len ; \n tree -> vlc_num = get_bits ( gb , 4 ) ; \n if ( ! tree -> vlc_num ) { \n for ( i = 0 ; i < 16 ; i ++ ) \n tree -> syms [ i ] = i ; \n return ; \n } \n if ( get_bits1 ( gb ) ) { \n len = get_bits ( gb , 3 ) ; \n memset ( tmp1 , 0 , sizeof ( tmp1 ) ) ; \n for ( i = 0 ; i <= len ; i ++ ) { \n tree -> syms [ i ] = get_bits ( gb , 4 ) ; \n tmp1 [ tree -> syms [ i ] ] = 1 ; \n } \n for ( i = 0 ; i < 16 ; i ++ ) \n if ( ! tmp1 [ i ] ) \n tree -> syms [ ++ len ] = i ; \n } else { \n len = get_bits ( gb , 2 ) ; \n for ( i = 0 ; i < 16 ; i ++ ) \n in [ i ] = i ; \n for ( i = 0 ; i <= len ; i ++ ) { \n int size = 1 << i ; \n for ( t = 0 ; t < 16 ; t += size << 1 ) \n merge ( gb , out + t , in + t , size ) ; \n FFSWAP ( uint8_t * , in , out ) ; \n } \n memcpy ( tree -> syms , in , 16 ) ; \n } \n }", "idx": 17399}
{"project": "FFmpeg", "commit_id": "fe479c9d63f0743fa064ac2a5c019284ba88277a", "target": 1, "func": "void avfilter_start_frame ( AVFilterLink * link , AVFilterPicRef * picref ) \n { \n void ( * start_frame ) ( AVFilterLink * , AVFilterPicRef * ) ; \n AVFilterPad * dst = & link_dpad ( link ) ; \n if ( ! ( start_frame = dst -> start_frame ) ) \n start_frame = avfilter_default_start_frame ; \n if ( ( dst -> min_perms & picref -> perms ) != dst -> min_perms || \n dst -> rej_perms & picref -> perms ) { \n link -> cur_pic = avfilter_default_get_video_buffer ( link , dst -> min_perms ) ; \n link -> srcpic = picref ; \n link -> cur_pic -> pts = link -> srcpic -> pts ; \n } \n else \n link -> cur_pic = picref ; \n start_frame ( link , link -> cur_pic ) ; \n }", "idx": 17403}
{"project": "FFmpeg", "commit_id": "fb96ac469a1d375b473868984f832e3a7cdfc24c", "target": 1, "func": "static int decode_syncpoint ( NUTContext * nut , int64_t * ts , int64_t * back_ptr ) \n { \n AVFormatContext * s = nut -> avf ; \n AVIOContext * bc = s -> pb ; \n int64_t end ; \n uint64_t tmp ; \n nut -> last_syncpoint_pos = avio_tell ( bc ) - 8 ; \n end = get_packetheader ( nut , bc , 1 , SYNCPOINT_STARTCODE ) ; \n end += avio_tell ( bc ) ; \n tmp = ffio_read_varlen ( bc ) ; \n * back_ptr = nut -> last_syncpoint_pos - 16 * ffio_read_varlen ( bc ) ; \n if ( * back_ptr < 0 ) \n return -1 ; \n ff_nut_reset_ts ( nut , nut -> time_base [ tmp % nut -> time_base_count ] , \n tmp / nut -> time_base_count ) ; \n if ( skip_reserved ( bc , end ) || ffio_get_checksum ( bc ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n * ts = tmp / s -> nb_streams * \n av_q2d ( nut -> time_base [ tmp % s -> nb_streams ] ) * AV_TIME_BASE ; \n ff_nut_add_sp ( nut , nut -> last_syncpoint_pos , * back_ptr , * ts ) ; \n return 0 ; \n }", "idx": 17416}
{"project": "FFmpeg", "commit_id": "442c3a8cb1785d74f8e2d7ab35b1862b7088436b", "target": 1, "func": "static inline void expand_category ( COOKContext * q , int * category , \n int * category_index ) \n { \n int i ; \n for ( i = 0 ; i < q -> num_vectors ; i ++ ) \n ++ category [ category_index [ i ] ] ; \n }", "idx": 17418}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static int gif_encode_close ( AVCodecContext * avctx ) \n { \n GIFContext * s = avctx -> priv_data ; \n av_frame_free ( & avctx -> coded_frame ) ; \n av_freep ( & s -> lzw ) ; \n av_freep ( & s -> buf ) ; \n return 0 ; \n }", "idx": 17419}
{"project": "FFmpeg", "commit_id": "341404f753fdbcddebb9fbce51f2ef057cceb79c", "target": 0, "func": "static av_cold int vqa_decode_end ( AVCodecContext * avctx ) \n { \n VqaContext * s = avctx -> priv_data ; \n av_free ( s -> codebook ) ; \n av_free ( s -> next_codebook_buffer ) ; \n av_free ( s -> decode_buffer ) ; \n if ( s -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> frame ) ; \n return 0 ; \n }", "idx": 17420}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pam_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n return 0 ; \n }", "idx": 17421}
{"project": "FFmpeg", "commit_id": "d135f3c514ac1723256c8e0f5cdd466fe98a2578", "target": 1, "func": "static void FUNC ( put_hevc_qpel_bi_w_h ) ( uint8_t * _dst , ptrdiff_t _dststride , uint8_t * _src , ptrdiff_t _srcstride , \n int16_t * src2 , \n int height , int denom , int wx0 , int wx1 , \n int ox0 , int ox1 , intptr_t mx , intptr_t my , int width ) \n { \n int x , y ; \n pixel * src = ( pixel * ) _src ; \n ptrdiff_t srcstride = _srcstride / sizeof ( pixel ) ; \n pixel * dst = ( pixel * ) _dst ; \n ptrdiff_t dststride = _dststride / sizeof ( pixel ) ; \n const int8_t * filter = ff_hevc_qpel_filters [ mx - 1 ] ; \n int shift = 14 + 1 - BIT_DEPTH ; \n int log2Wd = denom + shift - 1 ; \n ox0 = ox0 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n ox1 = ox1 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) \n dst [ x ] = av_clip_pixel ( ( ( QPEL_FILTER ( src , 1 ) >> ( BIT_DEPTH - 8 ) ) * wx1 + src2 [ x ] * wx0 + \n ( ( ox0 + ox1 + 1 ) << log2Wd ) ) >> ( log2Wd + 1 ) ) ; \n src += srcstride ; \n dst += dststride ; \n src2 += MAX_PB_SIZE ; \n } \n }", "idx": 17423}
{"project": "FFmpeg", "commit_id": "31c7c0e156975be615479948824c1528952c0731", "target": 1, "func": "static int mov_write_avid_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int i ; \n avio_wb32 ( pb , 24 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n if ( track -> enc -> color_range == AVCOL_RANGE_MPEG || \n track -> enc -> color_range == AVCOL_RANGE_UNSPECIFIED ) { \n avio_wb32 ( pb , 1 ) ; \n } else { \n avio_wb32 ( pb , 2 ) ; \n } \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 24 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 1 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 120 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , AV_RB32 ( track -> vos_data + 0x28 ) ) ; \n avio_wb32 ( pb , track -> enc -> width ) ; \n if ( track -> vos_data [ 5 ] & 2 ) { \n avio_wb32 ( pb , track -> enc -> height / 2 ) ; \n avio_wb32 ( pb , 2 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 4 ) ; \n } else { \n avio_wb32 ( pb , track -> enc -> height ) ; \n avio_wb32 ( pb , 1 ) ; \n avio_wb32 ( pb , 0 ) ; \n if ( track -> enc -> height == 1080 ) \n avio_wb32 ( pb , 5 ) ; \n else \n avio_wb32 ( pb , 6 ) ; \n } \n for ( i = 0 ; i < 10 ; i ++ ) \n avio_wb64 ( pb , 0 ) ; \n avio_wb32 ( pb , 0 ) ; \n return 0 ; \n }", "idx": 17429}
{"project": "FFmpeg", "commit_id": "f1d6f013b2078140fb701978d720abecde7cd73f", "target": 0, "func": "static int nprobe ( AVFormatContext * s , uint8_t * enc_header , int size , const uint8_t * n_val ) \n { \n OMAContext * oc = s -> priv_data ; \n uint32_t pos , taglen , datalen ; \n struct AVDES av_des ; \n if ( ! enc_header || ! n_val ) \n return -1 ; \n pos = OMA_ENC_HEADER_SIZE + oc -> k_size ; \n if ( ! memcmp ( & enc_header [ pos ] , \" \" , 4 ) ) \n pos += 32 ; \n if ( AV_RB32 ( & enc_header [ pos ] ) != oc -> rid ) \n av_log ( s , AV_LOG_DEBUG , \" \\n \" ) ; \n taglen = AV_RB32 ( & enc_header [ pos + 32 ] ) ; \n datalen = AV_RB32 ( & enc_header [ pos + 36 ] ) >> 4 ; \n if ( taglen + ( ( ( uint64_t ) datalen ) << 4 ) + 44 > size ) \n return -1 ; \n pos += 44 + taglen ; \n av_des_init ( & av_des , n_val , 192 , 1 ) ; \n while ( datalen -- > 0 ) { \n av_des_crypt ( & av_des , oc -> r_val , & enc_header [ pos ] , 2 , NULL , 1 ) ; \n kset ( s , oc -> r_val , NULL , 16 ) ; \n if ( ! rprobe ( s , enc_header , oc -> r_val ) ) \n return 0 ; \n pos += 16 ; \n } \n return -1 ; \n }", "idx": 17432}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb24ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int r = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int b = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n }", "idx": 17434}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2yuvXinC ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , int dstW , int chrDstW ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( uDest != NULL ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ i ] = av_clip_uint8 ( u >> 19 ) ; \n vDest [ i ] = av_clip_uint8 ( v >> 19 ) ; \n } \n }", "idx": 17436}
{"project": "FFmpeg", "commit_id": "dce778e0ea295db541e43b0850d3a7ef873996cc", "target": 0, "func": "static int mjpeg_decode_com ( MJpegDecodeContext * s ) \n { \n int i ; \n UINT8 * cbuf ; \n unsigned int len = get_bits ( & s -> gb , 16 ) - 2 ; \n cbuf = av_malloc ( len + 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) \n cbuf [ i ] = get_bits ( & s -> gb , 8 ) ; \n if ( cbuf [ i - 1 ] == ' \\n ' ) \n cbuf [ i - 1 ] = 0 ; \n else \n cbuf [ i ] = 0 ; \n printf ( \" \\n \" , cbuf ) ; \n if ( ! strcmp ( cbuf , \" \" ) ) \n { \n s -> buggy_avid = 1 ; \n } \n av_free ( cbuf ) ; \n return 0 ; \n }", "idx": 17437}
{"project": "FFmpeg", "commit_id": "37dd235658bc797667ec842abaed19169a36e6e5", "target": 1, "func": "static int matroska_parse_cluster ( MatroskaDemuxContext * matroska ) \n { \n MatroskaCluster cluster = { 0 } ; \n EbmlList * blocks_list ; \n MatroskaBlock * blocks ; \n int i , res ; \n int64_t pos = url_ftell ( matroska -> ctx -> pb ) ; \n matroska -> prev_pkt = NULL ; \n if ( matroska -> has_cluster_id ) { \n res = ebml_parse_id ( matroska , matroska_clusters , \n MATROSKA_ID_CLUSTER , & cluster ) ; \n pos -= 4 ; \n matroska -> has_cluster_id = 0 ; \n } else \n res = ebml_parse ( matroska , matroska_clusters , & cluster ) ; \n blocks_list = & cluster . blocks ; \n blocks = blocks_list -> elem ; \n for ( i = 0 ; i < blocks_list -> nb_elem ; i ++ ) \n if ( blocks [ i ] . bin . size > 0 ) { \n int is_keyframe = blocks [ i ] . non_simple ? ! blocks [ i ] . reference : -1 ; \n res = matroska_parse_block ( matroska , \n blocks [ i ] . bin . data , blocks [ i ] . bin . size , \n blocks [ i ] . bin . pos , cluster . timecode , \n blocks [ i ] . duration , is_keyframe , \n pos ) ; \n } \n ebml_free ( matroska_cluster , & cluster ) ; \n if ( res < 0 ) matroska -> done = 1 ; \n return res ; \n }", "idx": 17445}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static uint64_t get_v ( ByteIOContext * bc ) \n { \n uint64_t val = 0 ; \n for ( ; bytes_left ( bc ) > 0 ; ) \n { \n int tmp = get_byte ( bc ) ; \n if ( tmp & 0x80 ) \n val = ( val << 7 ) + tmp - 0x80 ; \n else \n return ( val << 7 ) + tmp ; \n } \n return -1 ; \n }", "idx": 17453}
{"project": "FFmpeg", "commit_id": "916ff02261f79e759d996c76670958276276bf2a", "target": 1, "func": "static av_cold int libgsm_close ( AVCodecContext * avctx ) { \n gsm_destroy ( avctx -> priv_data ) ; \n avctx -> priv_data = NULL ; \n return 0 ; \n }", "idx": 17455}
{"project": "FFmpeg", "commit_id": "6a2459059e469fdb835ff4abcbc3bae9781116b3", "target": 1, "func": "static int mov_open_dref ( ByteIOContext * * pb , char * src , MOVDref * ref ) \n { \n if ( ! url_fopen ( pb , ref -> path , URL_RDONLY ) ) \n return 0 ; \n if ( ref -> nlvl_to > 0 && ref -> nlvl_from > 0 ) { \n char filename [ 1024 ] ; \n char * src_path ; \n int i , l ; \n src_path = strrchr ( src , ' ' ) ; \n if ( src_path ) \n src_path ++ ; \n else \n src_path = src ; \n for ( i = 0 , l = strlen ( ref -> path ) - 1 ; l >= 0 ; l -- ) \n if ( ref -> path [ l ] == ' ' ) { \n if ( i == ref -> nlvl_to - 1 ) \n break ; \n else \n i ++ ; \n } \n if ( i == ref -> nlvl_to - 1 ) { \n memcpy ( filename , src , src_path - src ) ; \n filename [ src_path - src ] = 0 ; \n for ( i = 1 ; i < ref -> nlvl_from ; i ++ ) \n av_strlcat ( filename , \" \" , 1024 ) ; \n av_strlcat ( filename , ref -> path + l + 1 , 1024 ) ; \n if ( ! url_fopen ( pb , filename , URL_RDONLY ) ) \n return 0 ; \n } \n } \n return AVERROR ( ENOENT ) ; \n } ;", "idx": 17456}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_replaygain ( MOVContext * c , AVIOContext * pb , int size ) \n { \n int64_t end = avio_tell ( pb ) + size ; \n uint8_t * key = NULL , * val = NULL ; \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n uint8_t * * p ; \n uint32_t len , tag ; \n if ( end - avio_tell ( pb ) <= 12 ) \n break ; \n len = avio_rb32 ( pb ) ; \n tag = avio_rl32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n if ( len < 12 || len - 12 > end - avio_tell ( pb ) ) \n break ; \n len -= 12 ; \n if ( tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n p = & key ; \n else if ( tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && len > 4 ) { \n avio_skip ( pb , 4 ) ; \n len -= 4 ; \n p = & val ; \n } else \n break ; \n * p = av_malloc ( len + 1 ) ; \n if ( ! * p ) \n break ; \n avio_read ( pb , * p , len ) ; \n ( * p ) [ len ] = 0 ; \n } \n if ( key && val ) { \n av_dict_set ( & c -> fc -> metadata , key , val , \n AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL ) ; \n key = val = NULL ; \n } \n avio_seek ( pb , end , SEEK_SET ) ; \n av_freep ( & key ) ; \n av_freep ( & val ) ; \n return 0 ; \n }", "idx": 17483}
{"project": "FFmpeg", "commit_id": "5c22c90c1d5050f1206e46494b193320ac2397cb", "target": 1, "func": "static void vp9_superframe_close ( AVBSFContext * ctx ) \n { \n VP9BSFContext * s = ctx -> priv_data ; \n int n ; \n for ( n = 0 ; n < s -> n_cache ; n ++ ) \n av_packet_free ( & s -> cache [ n ] ) ; \n }", "idx": 17496}
{"project": "FFmpeg", "commit_id": "d38345878cbb89e4d8d33bd79f47836d4e9cd637", "target": 1, "func": "static int decode_dsw1 ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n const uint8_t * frame_start = frame ; \n const uint8_t * frame_end = frame + width * height ; \n int mask = 0x10000 , bitbuf = 0 ; \n int v , offset , count , segments ; \n segments = bytestream_get_le16 ( & src ) ; \n while ( segments -- ) { \n if ( mask == 0x10000 ) { \n if ( src >= src_end ) \n return -1 ; \n bitbuf = bytestream_get_le16 ( & src ) ; \n mask = 1 ; \n } \n if ( src_end - src < 2 || frame_end - frame < 2 ) \n return -1 ; \n if ( bitbuf & mask ) { \n v = bytestream_get_le16 ( & src ) ; \n offset = ( v & 0x1FFF ) << 1 ; \n count = ( ( v >> 13 ) + 2 ) << 1 ; \n if ( frame - offset < frame_start || frame_end - frame < count ) \n return -1 ; \n for ( v = 0 ; v < count ; v ++ ) \n frame [ v ] = frame [ v - offset ] ; \n frame += count ; \n } else if ( bitbuf & ( mask << 1 ) ) { \n frame += bytestream_get_le16 ( & src ) ; \n } else { \n * frame ++ = * src ++ ; \n * frame ++ = * src ++ ; \n } \n mask <<= 2 ; \n } \n return 0 ; \n }", "idx": 17501}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void draw_slice ( HYuvContext * s , AVFrame * frame , int y ) \n { \n int h , cy , i ; \n int offset [ AV_NUM_DATA_POINTERS ] ; \n if ( s -> avctx -> draw_horiz_band == NULL ) \n return ; \n h = y - s -> last_slice_end ; \n y -= h ; \n if ( s -> bitstream_bpp == 12 ) \n cy = y >> 1 ; \n else \n cy = y ; \n offset [ 0 ] = frame -> linesize [ 0 ] * y ; \n offset [ 1 ] = frame -> linesize [ 1 ] * cy ; \n offset [ 2 ] = frame -> linesize [ 2 ] * cy ; \n for ( i = 3 ; i < AV_NUM_DATA_POINTERS ; i ++ ) \n offset [ i ] = 0 ; \n emms_c ( ) ; \n s -> avctx -> draw_horiz_band ( s -> avctx , frame , offset , y , 3 , h ) ; \n s -> last_slice_end = y + h ; \n }", "idx": 17502}
{"project": "FFmpeg", "commit_id": "386aee6864c5cfc438785d2421b2f056450da014", "target": 0, "func": "static av_cold int asink_init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVABufferSinkParams * params ; \n if ( ! opaque ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } else \n params = ( AVABufferSinkParams * ) opaque ; \n buf -> sample_fmts = params -> sample_fmts ; \n buf -> channel_layouts = params -> channel_layouts ; \n buf -> packing_fmts = params -> packing_fmts ; \n return common_init ( ctx ) ; \n }", "idx": 17503}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "int vp78_decode_mb_row_sliced ( AVCodecContext * avctx , void * tdata , int jobnr , \n int threadnr , int is_vp7 ) \n { \n VP8Context * s = avctx -> priv_data ; \n VP8ThreadData * td = & s -> thread_data [ jobnr ] ; \n VP8ThreadData * next_td = NULL , * prev_td = NULL ; \n VP8Frame * curframe = s -> curframe ; \n int mb_y , num_jobs = s -> num_jobs ; \n int ret ; \n td -> thread_nr = threadnr ; \n for ( mb_y = jobnr ; mb_y < s -> mb_height ; mb_y += num_jobs ) { \n atomic_store ( & td -> thread_mb_pos , mb_y << 16 ) ; \n ret = s -> decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr ) ; \n if ( ret < 0 ) { \n update_pos ( td , s -> mb_height , INT_MAX & 0xFFFF ) ; \n return ret ; \n } \n if ( s -> deblock_filter ) \n s -> filter_mb_row ( avctx , tdata , jobnr , threadnr ) ; \n update_pos ( td , mb_y , INT_MAX & 0xFFFF ) ; \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n if ( avctx -> active_thread_type == FF_THREAD_FRAME ) \n ff_thread_report_progress ( & curframe -> tf , mb_y , 0 ) ; \n } \n return 0 ; \n }", "idx": 17507}
{"project": "FFmpeg", "commit_id": "86020073dbb9a3a9d1fbb76345b2ca29ba1f13d2", "target": 1, "func": "static void xa_decode ( short * out , const unsigned char * in , \n ADPCMChannelStatus * left , ADPCMChannelStatus * right , int inc ) \n { \n int i , j ; \n int shift , filter , f0 , f1 ; \n int s_1 , s_2 ; \n int d , s , t ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n shift = 12 - ( in [ 4 + i * 2 ] & 15 ) ; \n filter = in [ 4 + i * 2 ] >> 4 ; \n f0 = xa_adpcm_table [ filter ] [ 0 ] ; \n f1 = xa_adpcm_table [ filter ] [ 1 ] ; \n s_1 = left -> sample1 ; \n s_2 = left -> sample2 ; \n for ( j = 0 ; j < 28 ; j ++ ) { \n d = in [ 16 + i + j * 4 ] ; \n t = ( signed char ) ( d << 4 ) >> 4 ; \n s = ( t << shift ) + ( ( s_1 * f0 + s_2 * f1 + 32 ) >> 6 ) ; \n s_2 = s_1 ; \n s_1 = av_clip_int16 ( s ) ; \n * out = s_1 ; \n out += inc ; \n } \n if ( inc == 2 ) { \n left -> sample1 = s_1 ; \n left -> sample2 = s_2 ; \n s_1 = right -> sample1 ; \n s_2 = right -> sample2 ; \n out = out + 1 - 28 * 2 ; \n } \n shift = 12 - ( in [ 5 + i * 2 ] & 15 ) ; \n filter = in [ 5 + i * 2 ] >> 4 ; \n f0 = xa_adpcm_table [ filter ] [ 0 ] ; \n f1 = xa_adpcm_table [ filter ] [ 1 ] ; \n for ( j = 0 ; j < 28 ; j ++ ) { \n d = in [ 16 + i + j * 4 ] ; \n t = ( signed char ) d >> 4 ; \n s = ( t << shift ) + ( ( s_1 * f0 + s_2 * f1 + 32 ) >> 6 ) ; \n s_2 = s_1 ; \n s_1 = av_clip_int16 ( s ) ; \n * out = s_1 ; \n out += inc ; \n } \n if ( inc == 2 ) { \n right -> sample1 = s_1 ; \n right -> sample2 = s_2 ; \n out -= 1 ; \n } else { \n left -> sample1 = s_1 ; \n left -> sample2 = s_2 ; \n } \n } \n }", "idx": 17520}
{"project": "FFmpeg", "commit_id": "5ba62e89dfca540db03997668a8ec4571068d9e0", "target": 0, "func": "static int loco_decode_plane ( LOCOContext * l , uint8_t * data , int width , int height , \n int stride , const uint8_t * buf , int buf_size , int step ) \n { \n RICEContext rc ; \n int val ; \n int i , j ; \n if ( buf_size <= 0 ) \n return -1 ; \n init_get_bits8 ( & rc . gb , buf , buf_size ) ; \n rc . save = 0 ; \n rc . run = 0 ; \n rc . run2 = 0 ; \n rc . lossy = l -> lossy ; \n rc . sum = 8 ; \n rc . count = 1 ; \n val = loco_get_rice ( & rc ) ; \n data [ 0 ] = 128 + val ; \n for ( i = 1 ; i < width ; i ++ ) { \n val = loco_get_rice ( & rc ) ; \n data [ i * step ] = data [ i * step - step ] + val ; \n } \n data += stride ; \n for ( j = 1 ; j < height ; j ++ ) { \n val = loco_get_rice ( & rc ) ; \n data [ 0 ] = data [ - stride ] + val ; \n for ( i = 1 ; i < width ; i ++ ) { \n val = loco_get_rice ( & rc ) ; \n data [ i * step ] = loco_predict ( & data [ i * step ] , stride , step ) + val ; \n } \n data += stride ; \n } \n return ( get_bits_count ( & rc . gb ) + 7 ) >> 3 ; \n }", "idx": 17528}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "static void copy_bits ( PutBitContext * pb , UINT8 * src , int length ) \n { \n #if 1  \n  \n  int bytes = length >> 4 ; \n int bits = length & 15 ; \n int i ; \n for ( i = 0 ; i < bytes ; i ++ ) put_bits ( pb , 16 , be2me_16 ( ( ( uint16_t * ) src ) [ i ] ) ) ; \n put_bits ( pb , bits , be2me_16 ( ( ( uint16_t * ) src ) [ i ] ) >> ( 16 - bits ) ) ; \n #else \n int bytes = length >> 3 ; \n int bits = length & 7 ; \n int i ; \n for ( i = 0 ; i < bytes ; i ++ ) put_bits ( pb , 8 , src [ i ] ) ; \n put_bits ( pb , bits , src [ i ] >> ( 8 - bits ) ) ; \n #endif \n }", "idx": 17531}
{"project": "FFmpeg", "commit_id": "57835fc1aeaf0b3bbc0816b123a931ea39de758b", "target": 0, "func": "static void vb_decode_palette ( VBDecContext * c ) \n { \n int start , size , i ; \n start = bytestream_get_byte ( & c -> stream ) ; \n size = ( bytestream_get_byte ( & c -> stream ) - 1 ) & 0xFF ; \n if ( start + size > 255 ) { \n av_log ( c -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n for ( i = start ; i <= start + size ; i ++ ) \n c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ; \n }", "idx": 17532}
{"project": "FFmpeg", "commit_id": "e3329474a366de066b25e86f35f5abf9c5a4b7b2", "target": 1, "func": "static av_always_inline void avcodec_thread_park_workers ( ThreadContext * c , int thread_count ) \n { \n pthread_cond_wait ( & c -> last_job_cond , & c -> current_job_lock ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n }", "idx": 17538}
{"project": "FFmpeg", "commit_id": "55188278169c3a1838334d7aa47a1f7a40741690", "target": 1, "func": "static int xan_decode_frame_type1 ( AVCodecContext * avctx , AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n XanContext * s = avctx -> priv_data ; \n uint8_t * ybuf , * src = s -> scratch_buffer ; \n int cur , last ; \n int i , j ; \n int ret ; \n if ( ( ret = xan_decode_chroma ( avctx , avpkt ) ) != 0 ) \n return ret ; \n ret = xan_unpack_luma ( buf + 16 , avpkt -> size - 16 , src , \n s -> buffer_size >> 1 ) ; \n if ( ret ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n ybuf = s -> y_buffer ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n last = ( ybuf [ 0 ] + ( * src ++ << 1 ) ) & 0x3F ; \n ybuf [ 0 ] = last ; \n for ( j = 1 ; j < avctx -> width - 1 ; j += 2 ) { \n cur = ( ybuf [ j + 1 ] + ( * src ++ << 1 ) ) & 0x3F ; \n ybuf [ j ] = ( last + cur ) >> 1 ; \n ybuf [ j + 1 ] = cur ; \n last = cur ; \n } \n ybuf [ j ] = last ; \n ybuf += avctx -> width ; \n } \n src = s -> y_buffer ; \n ybuf = s -> pic . data [ 0 ] ; \n for ( j = 0 ; j < avctx -> height ; j ++ ) { \n for ( i = 0 ; i < avctx -> width ; i ++ ) \n ybuf [ i ] = ( src [ i ] << 2 ) | ( src [ i ] >> 3 ) ; \n src += avctx -> width ; \n ybuf += s -> pic . linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 17540}
{"project": "FFmpeg", "commit_id": "e825b5009f88a2ac78d05f960a747ddc6ad4ed22", "target": 1, "func": "static int image_probe ( AVProbeData * p ) \n { \n if ( av_str2id ( img_tags , p -> filename ) ) { \n if ( av_filename_number_test ( p -> filename ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return AVPROBE_SCORE_MAX / 2 ; \n } \n return 0 ; \n }", "idx": 17546}
{"project": "FFmpeg", "commit_id": "fcb1b0078d3810aa2d9270e1095c8b5835fc5667", "target": 1, "func": "uint8_t * av_packet_pack_dictionary ( AVDictionary * dict , int * size ) \n { \n AVDictionaryEntry * t = NULL ; \n uint8_t * data = NULL ; \n * size = 0 ; \n if ( ! dict ) \n return NULL ; \n while ( ( t = av_dict_get ( dict , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) { \n const int keylen = strlen ( t -> key ) ; \n const int valuelen = strlen ( t -> value ) ; \n const size_t new_size = * size + keylen + 1 + valuelen + 1 ; \n uint8_t * const new_data = av_realloc ( data , new_size ) ; \n if ( ! new_data ) \n goto fail ; \n data = new_data ; \n memcpy ( data + * size , t -> key , keylen + 1 ) ; \n memcpy ( data + * size + keylen + 1 , t -> value , valuelen + 1 ) ; \n * size = new_size ; \n } \n return data ; \n fail : \n av_freep ( & data ) ; \n * size = 0 ; \n return NULL ; \n }", "idx": 17549}
{"project": "FFmpeg", "commit_id": "fb75ad79cb8a00d42857b252e0049a0bbe90da66", "target": 1, "func": "int ff_celp_lp_synthesis_filter ( int16_t * out , const int16_t * filter_coeffs , \n const int16_t * in , int buffer_length , \n int filter_length , int stop_on_overflow , \n int shift , int rounder ) \n { \n int i , n ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n int sum = - rounder , sum1 ; \n for ( i = 1 ; i <= filter_length ; i ++ ) \n sum += filter_coeffs [ i - 1 ] * out [ n - i ] ; \n sum1 = ( ( - sum >> 12 ) + in [ n ] ) >> shift ; \n sum = av_clip_int16 ( sum1 ) ; \n if ( stop_on_overflow && sum != sum1 ) \n return 1 ; \n out [ n ] = sum ; \n } \n return 0 ; \n }", "idx": 17550}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , uint8_t * src , long width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm2 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 17559}
{"project": "FFmpeg", "commit_id": "c225da68cffbea11270a758ff42859194c980863", "target": 1, "func": "static void FUNC ( put_hevc_pel_bi_w_pixels ) ( uint8_t * _dst , ptrdiff_t _dststride , uint8_t * _src , ptrdiff_t _srcstride , \n int16_t * src2 , \n int height , int denom , int wx0 , int wx1 , \n int ox0 , int ox1 , intptr_t mx , intptr_t my , int width ) \n { \n int x , y ; \n pixel * src = ( pixel * ) _src ; \n ptrdiff_t srcstride = _srcstride / sizeof ( pixel ) ; \n pixel * dst = ( pixel * ) _dst ; \n ptrdiff_t dststride = _dststride / sizeof ( pixel ) ; \n int shift = 14 + 1 - BIT_DEPTH ; \n int log2Wd = denom + shift - 1 ; \n ox0 = ox0 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n ox1 = ox1 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n dst [ x ] = av_clip_pixel ( ( ( src [ x ] << ( 14 - BIT_DEPTH ) ) * wx1 + src2 [ x ] * wx0 + ( ( ox0 + ox1 + 1 ) << log2Wd ) ) >> ( log2Wd + 1 ) ) ; \n } \n src += srcstride ; \n dst += dststride ; \n src2 += MAX_PB_SIZE ; \n } \n }", "idx": 17561}
{"project": "FFmpeg", "commit_id": "9be6f0d2f8393100a11c8527c7ba18c1dc2f1450", "target": 0, "func": "static av_cold void common_init ( MpegEncContext * s ) \n { \n static int initialized = 0 ; \n switch ( s -> msmpeg4_version ) { \n case 1 : \n case 2 : \n s -> y_dc_scale_table = \n s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ; \n break ; \n case 3 : \n if ( s -> workaround_bugs ) { \n s -> y_dc_scale_table = old_ff_y_dc_scale_table ; \n s -> c_dc_scale_table = wmv1_c_dc_scale_table ; \n } else { \n s -> y_dc_scale_table = ff_mpeg4_y_dc_scale_table ; \n s -> c_dc_scale_table = ff_mpeg4_c_dc_scale_table ; \n } \n break ; \n case 4 : \n case 5 : \n s -> y_dc_scale_table = wmv1_y_dc_scale_table ; \n s -> c_dc_scale_table = wmv1_c_dc_scale_table ; \n break ; \n #if CONFIG_WMV3_DECODER || CONFIG_VC1_DECODER  \n  \n  case 6 : \n s -> y_dc_scale_table = wmv3_dc_scale_table ; \n s -> c_dc_scale_table = wmv3_dc_scale_table ; \n break ; \n #endif \n } \n if ( s -> msmpeg4_version >= 4 ) { \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> intra_scantable , wmv1_scantable [ 1 ] ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> intra_h_scantable , wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> intra_v_scantable , wmv1_scantable [ 3 ] ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> inter_scantable , wmv1_scantable [ 0 ] ) ; \n } \n if ( ! initialized ) { \n initialized = 1 ; \n init_h263_dc_for_msmpeg4 ( ) ; \n } \n }", "idx": 17564}
{"project": "FFmpeg", "commit_id": "626b6b769ced6d3e55d2661985ab2a1cb89f481e", "target": 0, "func": "static av_cold int libwebp_anim_encode_init ( AVCodecContext * avctx ) \n { \n int ret = ff_libwebp_encode_init_common ( avctx ) ; \n if ( ! ret ) { \n LibWebPAnimContext * s = avctx -> priv_data ; \n WebPAnimEncoderOptions enc_options ; \n WebPAnimEncoderOptionsInit ( & enc_options ) ; \n s -> enc = WebPAnimEncoderNew ( avctx -> width , avctx -> height , & enc_options ) ; \n if ( ! s -> enc ) \n return AVERROR ( EINVAL ) ; \n s -> prev_frame_pts = -1 ; \n s -> done = 0 ; \n } \n return ret ; \n }", "idx": 17566}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static av_cold int eightsvx_decode_close ( AVCodecContext * avctx ) \n { \n EightSvxContext * esc = avctx -> priv_data ; \n av_freep ( & esc -> samples ) ; \n esc -> samples_size = 0 ; \n esc -> samples_idx = 0 ; \n return 0 ; \n }", "idx": 17616}
{"project": "FFmpeg", "commit_id": "326b1ed93e25f2b2d505ee88325fabb190d8c275", "target": 0, "func": "static int scale_vaapi_query_formats ( AVFilterContext * avctx ) \n { \n enum AVPixelFormat pix_fmts [ ] = { \n AV_PIX_FMT_VAAPI , AV_PIX_FMT_NONE , \n } ; \n ff_formats_ref ( ff_make_format_list ( pix_fmts ) , \n & avctx -> inputs [ 0 ] -> out_formats ) ; \n ff_formats_ref ( ff_make_format_list ( pix_fmts ) , \n & avctx -> outputs [ 0 ] -> in_formats ) ; \n return 0 ; \n }", "idx": 17617}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_getc ( FTPContext * s ) \n { \n int len ; \n if ( s -> control_buf_ptr >= s -> control_buf_end ) { \n if ( s -> conn_control_block_flag ) \n return AVERROR_EXIT ; \n len = ffurl_read ( s -> conn_control , s -> control_buffer , CONTROL_BUFFER_SIZE ) ; \n if ( len < 0 ) { \n return len ; \n } else if ( ! len ) { \n return -1 ; \n } else { \n s -> control_buf_ptr = s -> control_buffer ; \n s -> control_buf_end = s -> control_buffer + len ; \n } \n } \n return * s -> control_buf_ptr ++ ; \n }", "idx": 17619}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void common_init ( MpegEncContext * s ) \n { \n static int inited = 0 ; \n switch ( s -> msmpeg4_version ) { \n case 1 : \n case 2 : \n s -> y_dc_scale_table = \n s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ; \n break ; \n case 3 : \n if ( s -> workaround_bugs ) { \n s -> y_dc_scale_table = old_ff_y_dc_scale_table ; \n s -> c_dc_scale_table = old_ff_c_dc_scale_table ; \n } else { \n s -> y_dc_scale_table = ff_mpeg4_y_dc_scale_table ; \n s -> c_dc_scale_table = ff_mpeg4_c_dc_scale_table ; \n } \n break ; \n case 4 : \n case 5 : \n s -> y_dc_scale_table = wmv1_y_dc_scale_table ; \n s -> c_dc_scale_table = wmv1_c_dc_scale_table ; \n break ; \n #if defined ( CONFIG_WMV3_DECODER ) || defined ( CONFIG_VC1_DECODER )  \n  \n  case 6 : \n s -> y_dc_scale_table = wmv3_dc_scale_table ; \n s -> c_dc_scale_table = wmv3_dc_scale_table ; \n break ; \n #endif \n } \n if ( s -> msmpeg4_version >= 4 ) { \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> intra_scantable , wmv1_scantable [ 1 ] ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> intra_h_scantable , wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> intra_v_scantable , wmv1_scantable [ 3 ] ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & s -> inter_scantable , wmv1_scantable [ 0 ] ) ; \n } \n if ( ! inited ) { \n inited = 1 ; \n init_h263_dc_for_msmpeg4 ( ) ; \n } \n }", "idx": 17644}
{"project": "FFmpeg", "commit_id": "21922dc5aefa3b5a75420d6f444da6a14e352726", "target": 0, "func": "static int read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n ByteIOContext * pb = s -> pb ; \n PutBitContext pbo ; \n uint16_t buf [ 8 * MAX_FRAME_SIZE + 2 ] ; \n int packet_size ; \n int sync ; \n uint16_t * src = buf ; \n int i , j , ret ; \n if ( url_feof ( pb ) ) \n return AVERROR_EOF ; \n sync = get_le16 ( pb ) ; \n packet_size = get_le16 ( pb ) / 8 ; \n assert ( packet_size < 8 * MAX_FRAME_SIZE ) ; \n ret = get_buffer ( pb , ( uint8_t * ) buf , ( 8 * packet_size ) * sizeof ( uint16_t ) ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ret != 8 * packet_size * sizeof ( uint16_t ) ) \n return AVERROR ( EIO ) ; \n av_new_packet ( pkt , packet_size ) ; \n init_put_bits ( & pbo , pkt -> data , packet_size ) ; \n for ( j = 0 ; j < packet_size ; j ++ ) \n for ( i = 0 ; i < 8 ; i ++ ) \n put_bits ( & pbo , 1 , AV_RL16 ( src ++ ) == BIT_1 ? 1 : 0 ) ; \n flush_put_bits ( & pbo ) ; \n pkt -> duration = 1 ; \n return 0 ; \n }", "idx": 17655}
{"project": "FFmpeg", "commit_id": "1527e689cfe3d1f0062f7d3935bad6ed027b3bc8", "target": 0, "func": "static void draw_slice ( AVFilterLink * inlink , int y , int h , int slice_dir ) \n { \n FadeContext * fade = inlink -> dst -> priv ; \n AVFilterBufferRef * outpic = inlink -> cur_buf ; \n uint8_t * p ; \n int i , j , plane ; \n if ( fade -> factor < 65536 ) { \n for ( i = 0 ; i < h ; i ++ ) { \n p = outpic -> data [ 0 ] + ( y + i ) * outpic -> linesize [ 0 ] ; \n for ( j = 0 ; j < inlink -> w * fade -> bpp ; j ++ ) { \n * p = ( * p * fade -> factor + 32768 ) >> 16 ; \n p ++ ; \n } \n } \n if ( outpic -> data [ 0 ] && outpic -> data [ 1 ] ) { \n for ( plane = 1 ; plane < 3 ; plane ++ ) { \n for ( i = 0 ; i < h ; i ++ ) { \n p = outpic -> data [ plane ] + ( ( y + i ) >> fade -> vsub ) * outpic -> linesize [ plane ] ; \n for ( j = 0 ; j < inlink -> w >> fade -> hsub ; j ++ ) { \n * p = ( ( * p - 128 ) * fade -> factor + 8421367 ) >> 16 ; \n p ++ ; \n } \n } \n } \n } \n } \n avfilter_draw_slice ( inlink -> dst -> outputs [ 0 ] , y , h , slice_dir ) ; \n }", "idx": 17686}
{"project": "FFmpeg", "commit_id": "3425501d3b09650c6b295ba225e02e97c002372c", "target": 0, "func": "static void fill_mbaff_ref_list ( H264Context * h ) { \n int list , i , j ; \n for ( list = 0 ; list < 2 ; list ++ ) { \n for ( i = 0 ; i < h -> ref_count [ list ] ; i ++ ) { \n Picture * frame = & h -> ref_list [ list ] [ i ] ; \n Picture * field = & h -> ref_list [ list ] [ 16 + 2 * i ] ; \n field [ 0 ] = * frame ; \n for ( j = 0 ; j < 3 ; j ++ ) \n field [ 0 ] . linesize [ j ] <<= 1 ; \n field [ 1 ] = field [ 0 ] ; \n for ( j = 0 ; j < 3 ; j ++ ) \n field [ 1 ] . data [ j ] += frame -> linesize [ j ] ; \n h -> luma_weight [ list ] [ 16 + 2 * i ] = h -> luma_weight [ list ] [ 16 + 2 * i + 1 ] = h -> luma_weight [ list ] [ i ] ; \n h -> luma_offset [ list ] [ 16 + 2 * i ] = h -> luma_offset [ list ] [ 16 + 2 * i + 1 ] = h -> luma_offset [ list ] [ i ] ; \n for ( j = 0 ; j < 2 ; j ++ ) { \n h -> chroma_weight [ list ] [ 16 + 2 * i ] [ j ] = h -> chroma_weight [ list ] [ 16 + 2 * i + 1 ] [ j ] = h -> chroma_weight [ list ] [ i ] [ j ] ; \n h -> chroma_offset [ list ] [ 16 + 2 * i ] [ j ] = h -> chroma_offset [ list ] [ 16 + 2 * i + 1 ] [ j ] = h -> chroma_offset [ list ] [ i ] [ j ] ; \n } \n } \n } \n for ( j = 0 ; j < h -> ref_count [ 1 ] ; j ++ ) { \n for ( i = 0 ; i < h -> ref_count [ 0 ] ; i ++ ) \n h -> implicit_weight [ j ] [ 16 + 2 * i ] = h -> implicit_weight [ j ] [ 16 + 2 * i + 1 ] = h -> implicit_weight [ j ] [ i ] ; \n memcpy ( h -> implicit_weight [ 16 + 2 * j ] , h -> implicit_weight [ j ] , sizeof ( * h -> implicit_weight ) ) ; \n memcpy ( h -> implicit_weight [ 16 + 2 * j + 1 ] , h -> implicit_weight [ j ] , sizeof ( * h -> implicit_weight ) ) ; \n } \n }", "idx": 17708}
{"project": "FFmpeg", "commit_id": "c9ff32215b433d505f251c1f212b1fa0a5e17b73", "target": 0, "func": "int av_opt_set_sample_fmt ( void * obj , const char * name , enum AVSampleFormat fmt , int search_flags ) \n { \n return set_format ( obj , name , fmt , search_flags , AV_OPT_TYPE_SAMPLE_FMT , \" \" , AV_SAMPLE_FMT_NB - 1 ) ; \n }", "idx": 17719}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( yuyvtoyuv422 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n long width , long height , \n long lumStride , long chromStride , long srcStride ) \n { \n long y ; \n const long chromWidth = - ( ( - width ) >> 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src , ydst , width ) ; \n RENAME ( extract_odd2 ) ( src , udst , vdst , chromWidth ) ; \n src += srcStride ; \n ydst += lumStride ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n #endif \n }", "idx": 17722}
{"project": "FFmpeg", "commit_id": "3118e3b137323785d131e1448c6718e9f649de73", "target": 0, "func": "void ff_lag_rac_init ( lag_rac * l , GetBitContext * gb , int length ) \n { \n int i , j , left ; \n align_get_bits ( gb ) ; \n left = get_bits_left ( gb ) >> 3 ; \n l -> bytestream_start = \n l -> bytestream = gb -> buffer + get_bits_count ( gb ) / 8 ; \n l -> bytestream_end = l -> bytestream_start + left ; \n l -> range = 0x80 ; \n l -> low = * l -> bytestream >> 1 ; \n l -> hash_shift = FFMAX ( l -> scale - 8 , 0 ) ; \n for ( i = j = 0 ; i < 256 ; i ++ ) { \n unsigned r = i << l -> hash_shift ; \n while ( l -> prob [ j + 1 ] <= r ) \n j ++ ; \n l -> range_hash [ i ] = j ; \n } \n l -> hash_shift += 23 ; \n }", "idx": 17724}
{"project": "FFmpeg", "commit_id": "f9b89b61f819535b4dbe6c3e9f0d6fc8becf64cb", "target": 1, "func": "static int ea_probe ( AVProbeData * p ) \n { \n switch ( AV_RL32 ( & p -> buf [ 0 ] ) ) { \n case ISNh_TAG : \n case SCHl_TAG : \n case SEAD_TAG : \n case SHEN_TAG : \n case kVGT_TAG : \n case MADk_TAG : \n case MPCh_TAG : \n case MVhd_TAG : \n case MVIh_TAG : \n break ; \n default : \n return 0 ; \n } \n if ( AV_RL32 ( & p -> buf [ 4 ] ) > 0xfffff && AV_RB32 ( & p -> buf [ 4 ] ) > 0xfffff ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 17728}
{"project": "FFmpeg", "commit_id": "47e3e1097e09da7f973908e09df15e3bb7c5e1f4", "target": 0, "func": "int locate_option ( int argc , char * * argv , const OptionDef * options , \n const char * optname ) \n { \n const OptionDef * po ; \n int i ; \n for ( i = 1 ; i < argc ; i ++ ) { \n const char * cur_opt = argv [ i ] ; \n if ( * cur_opt ++ != ' ' ) \n continue ; \n po = find_option ( options , cur_opt ) ; \n if ( ! po -> name && cur_opt [ 0 ] == ' ' && cur_opt [ 1 ] == ' ' ) \n po = find_option ( options , cur_opt + 2 ) ; \n if ( ( ! po -> name && ! strcmp ( cur_opt , optname ) ) || \n ( po -> name && ! strcmp ( optname , po -> name ) ) ) \n return i ; \n if ( ! po || po -> flags & HAS_ARG ) \n i ++ ; \n } \n return 0 ; \n }", "idx": 17730}
{"project": "FFmpeg", "commit_id": "979572365f2133f969f3f49ec6a99cc8739d2eba", "target": 1, "func": "static inline int asym_quant ( int c , int e , int qbits ) \n { \n int m ; \n c = ( ( ( c << e ) >> ( 24 - qbits ) ) + 1 ) >> 1 ; \n m = ( 1 << ( qbits - 1 ) ) ; \n if ( c >= m ) \n c = m - 1 ; \n av_assert2 ( c >= - m ) ; \n return c ; \n }", "idx": 17736}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static inline int compress_coef ( int * coefs , int num ) \n { \n int i , res = 0 ; \n for ( i = 0 ; i < num ; i ++ ) \n res += coef_test_compression ( coefs [ i ] ) ; \n return res == num ? 1 : 0 ; \n }", "idx": 17740}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void ff_simple_idct248_put ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n int i ; \n DCTELEM * ptr ; \n ptr = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n BF ( 0 ) ; \n BF ( 1 ) ; \n BF ( 2 ) ; \n BF ( 3 ) ; \n BF ( 4 ) ; \n BF ( 5 ) ; \n BF ( 6 ) ; \n BF ( 7 ) ; \n ptr += 2 * 8 ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n idctRowCondDC_8 ( block + i * 8 ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n idct4col_put ( dest + i , 2 * line_size , block + i ) ; \n idct4col_put ( dest + line_size + i , 2 * line_size , block + 8 + i ) ; \n } \n }", "idx": 17744}
{"project": "FFmpeg", "commit_id": "2cda1a16d0d34f1e936ed179c6f864bae1026b06", "target": 1, "func": "static int dvbsub_probe ( AVProbeData * p ) \n { \n int i , j , k ; \n const uint8_t * end = p -> buf + p -> buf_size ; \n int type , len ; \n int max_score = 0 ; \n for ( i = 0 ; i < p -> buf_size ; i ++ ) { \n if ( p -> buf [ i ] == 0x0f ) { \n const uint8_t * ptr = p -> buf + i ; \n uint8_t histogram [ 6 ] = { 0 } ; \n int min = 255 ; \n for ( j = 0 ; ptr + 6 < end ; j ++ ) { \n if ( * ptr != 0x0f ) \n break ; \n type = ptr [ 1 ] ; \n len = AV_RB16 ( ptr + 4 ) ; \n if ( type == 0x80 ) { \n ; \n } else if ( type >= 0x10 && type <= 0x14 ) { \n histogram [ type - 0x10 ] ++ ; \n } else \n break ; \n ptr += 6 + len ; \n } \n for ( k = 0 ; k < 4 ; k ++ ) { \n min = FFMIN ( min , histogram [ k ] ) ; \n } \n if ( min && j > max_score ) \n max_score = j ; \n } \n } \n if ( max_score > 5 ) \n return AVPROBE_SCORE_EXTENSION ; \n return 0 ; \n }", "idx": 17753}
{"project": "FFmpeg", "commit_id": "02cb7d4c9c3adfae84ef0d5646c2de944176f849", "target": 1, "func": "static av_cold int smvjpeg_decode_end ( AVCodecContext * avctx ) \n { \n SMVJpegDecodeContext * s = avctx -> priv_data ; \n MJpegDecodeContext * jpg = & s -> jpg ; \n int ret ; \n jpg -> picture_ptr = NULL ; \n av_frame_free ( & s -> picture [ 0 ] ) ; \n av_frame_free ( & s -> picture [ 1 ] ) ; \n ret = avcodec_close ( s -> avctx ) ; \n av_freep ( & s -> avctx ) ; \n return ret ; \n }", "idx": 17778}
{"project": "FFmpeg", "commit_id": "681868cbbe8a596860c454d34f259941e0c44d73", "target": 1, "func": "static void merge_context_after_encode ( MpegEncContext * dst , MpegEncContext * src ) { \n int i ; \n MERGE ( dct_count [ 0 ] ) ; \n MERGE ( dct_count [ 1 ] ) ; \n MERGE ( mv_bits ) ; \n MERGE ( i_tex_bits ) ; \n MERGE ( p_tex_bits ) ; \n MERGE ( i_count ) ; \n MERGE ( f_count ) ; \n MERGE ( b_count ) ; \n MERGE ( skip_count ) ; \n MERGE ( misc_bits ) ; \n MERGE ( er . error_count ) ; \n MERGE ( padding_bug_score ) ; \n MERGE ( current_picture . f -> error [ 0 ] ) ; \n MERGE ( current_picture . f -> error [ 1 ] ) ; \n MERGE ( current_picture . f -> error [ 2 ] ) ; \n if ( dst -> avctx -> noise_reduction ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n MERGE ( dct_error_sum [ 0 ] [ i ] ) ; \n MERGE ( dct_error_sum [ 1 ] [ i ] ) ; \n } \n } \n assert ( put_bits_count ( & src -> pb ) % 8 == 0 ) ; \n assert ( put_bits_count ( & dst -> pb ) % 8 == 0 ) ; \n avpriv_copy_bits ( & dst -> pb , src -> pb . buf , put_bits_count ( & src -> pb ) ) ; \n flush_put_bits ( & dst -> pb ) ; \n }", "idx": 17785}
{"project": "FFmpeg", "commit_id": "3f50965b28d0c4ef10dde0bf2f7a9f78fa36b378", "target": 0, "func": "static inline void h264_loop_filter_chroma_intra_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta ) \n { \n int d ; \n for ( d = 0 ; d < 8 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n pix [ - xstride ] = ( 2 * p1 + p0 + q1 + 2 ) >> 2 ; \n pix [ 0 ] = ( 2 * q1 + q0 + p1 + 2 ) >> 2 ; \n } \n pix += ystride ; \n } \n }", "idx": 17790}
{"project": "FFmpeg", "commit_id": "dfdb353cd565efbd1f64105ce7519ec809ad338d", "target": 0, "func": "real_parse_asm_rulebook ( AVFormatContext * s , AVStream * orig_st , \n const char * p )  \n { \n const char * end ; \n int n_rules , odd = 0 ; \n AVStream * st ; \n if ( * p == ' \\\" ' ) p ++ ; \n for ( n_rules = 0 ; s -> nb_streams < MAX_STREAMS ; ) { \n if ( ! ( end = strchr ( p , ' ' ) ) ) \n break ; \n if ( ! odd && end != p ) { \n if ( n_rules > 0 ) \n st = add_dstream ( s , orig_st ) ; \n else \n st = orig_st ; \n real_parse_asm_rule ( st , p , end ) ; \n n_rules ++ ; \n } \n p = end + 1 ; \n odd ^= 1 ; \n } \n }", "idx": 17791}
{"project": "FFmpeg", "commit_id": "4e926fb969acbb27415c2109d7339259875b6909", "target": 1, "func": "static void dwt_decode97_float ( DWTContext * s , float * t ) \n { \n int lev ; \n int w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; \n float * line = s -> f_linebuf ; \n float * data = t ; \n line += 5 ; \n for ( lev = 0 ; lev < s -> ndeclevels ; lev ++ ) { \n int lh = s -> linelen [ lev ] [ 0 ] , \n lv = s -> linelen [ lev ] [ 1 ] , \n mh = s -> mod [ lev ] [ 0 ] , \n mv = s -> mod [ lev ] [ 1 ] , \n lp ; \n float * l ; \n l = line + mh ; \n for ( lp = 0 ; lp < lv ; lp ++ ) { \n int i , j = 0 ; \n for ( i = mh ; i < lh ; i += 2 , j ++ ) \n l [ i ] = data [ w * lp + j ] * F_LFTG_K ; \n for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) \n l [ i ] = data [ w * lp + j ] ; \n sr_1d97_float ( line , mh , mh + lh ) ; \n for ( i = 0 ; i < lh ; i ++ ) \n data [ w * lp + i ] = l [ i ] ; \n } \n l = line + mv ; \n for ( lp = 0 ; lp < lh ; lp ++ ) { \n int i , j = 0 ; \n for ( i = mv ; i < lv ; i += 2 , j ++ ) \n l [ i ] = data [ w * j + lp ] * F_LFTG_K ; \n for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) \n l [ i ] = data [ w * j + lp ] ; \n sr_1d97_float ( line , mv , mv + lv ) ; \n for ( i = 0 ; i < lv ; i ++ ) \n data [ w * i + lp ] = l [ i ] ; \n } \n } \n }", "idx": 17798}
{"project": "FFmpeg", "commit_id": "c901ae944040855e05b25f8d81be6b6f327ce2a4", "target": 1, "func": "static int bitpacked_decode_yuv422p10 ( AVCodecContext * avctx , AVFrame * frame , \n AVPacket * avpkt ) \n { \n uint64_t frame_size = ( uint64_t ) avctx -> width * ( uint64_t ) avctx -> height * 20 ; \n uint64_t packet_size = avpkt -> size * 8 ; \n GetBitContext bc ; \n uint16_t * y , * u , * v ; \n int ret , i ; \n ret = ff_get_buffer ( avctx , frame , 0 ) ; \n if ( ret < 0 ) \n return ret ; \n y = ( uint16_t * ) frame -> data [ 0 ] ; \n u = ( uint16_t * ) frame -> data [ 1 ] ; \n v = ( uint16_t * ) frame -> data [ 2 ] ; \n if ( frame_size > packet_size ) \n return AVERROR_INVALIDDATA ; \n if ( avctx -> width % 2 ) \n return AVERROR_PATCHWELCOME ; \n ret = init_get_bits ( & bc , avpkt -> data , avctx -> width * avctx -> height * 20 ) ; \n if ( ret ) \n return ret ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n y = ( uint16_t * ) ( frame -> data [ 0 ] + i * frame -> linesize [ 0 ] ) ; \n u = ( uint16_t * ) ( frame -> data [ 1 ] + i * frame -> linesize [ 1 ] ) ; \n v = ( uint16_t * ) ( frame -> data [ 2 ] + i * frame -> linesize [ 2 ] ) ; \n for ( int j = 0 ; j < avctx -> width ; j += 2 ) { \n * u ++ = get_bits ( & bc , 10 ) ; \n * y ++ = get_bits ( & bc , 10 ) ; \n * v ++ = get_bits ( & bc , 10 ) ; \n * y ++ = get_bits ( & bc , 10 ) ; \n } \n } \n return 0 ; \n }", "idx": 17812}
{"project": "FFmpeg", "commit_id": "7620d48f2eab67812d8c535d12a98eaa754a1177", "target": 1, "func": "void ff_tls_init ( void ) \n { \n avpriv_lock_avformat ( ) ; \n #if CONFIG_OPENSSL  \n  \n  if ( ! openssl_init ) { \n SSL_library_init ( ) ; \n SSL_load_error_strings ( ) ; \n #if HAVE_THREADS  \n  \n  if ( ! CRYPTO_get_locking_callback ( ) ) { \n int i ; \n openssl_mutexes = av_malloc_array ( sizeof ( pthread_mutex_t ) , CRYPTO_num_locks ( ) ) ; \n for ( i = 0 ; i < CRYPTO_num_locks ( ) ; i ++ ) \n pthread_mutex_init ( & openssl_mutexes [ i ] , NULL ) ; \n CRYPTO_set_locking_callback ( openssl_lock ) ; \n #if ! defined ( WIN32 ) && OPENSSL_VERSION_NUMBER < 0x10000000  \n  \n  CRYPTO_set_id_callback ( openssl_thread_id ) ; \n #endif \n } \n #endif \n } \n openssl_init ++ ; \n #endif \n #if CONFIG_GNUTLS  \n  \n  #if HAVE_THREADS && GNUTLS_VERSION_NUMBER < 0x020b00  \n  \n  if ( gcry_control ( GCRYCTL_ANY_INITIALIZATION_P ) == 0 ) \n gcry_control ( GCRYCTL_SET_THREAD_CBS , & gcry_threads_pthread ) ; \n #endif \n gnutls_global_init ( ) ; \n #endif \n avpriv_unlock_avformat ( ) ; \n }", "idx": 17820}
{"project": "FFmpeg", "commit_id": "224bb46fb857dab589597bdab302ba8ba012008c", "target": 1, "func": "uint8_t * ff_AMediaCodec_getInputBuffer ( FFAMediaCodec * codec , size_t idx , size_t * out_size ) \n { \n uint8_t * ret = NULL ; \n JNIEnv * env = NULL ; \n jobject buffer = NULL ; \n JNI_GET_ENV_OR_RETURN ( env , codec , NULL ) ; \n if ( codec -> has_get_i_o_buffer ) { \n buffer = ( * env ) -> CallObjectMethod ( env , codec -> object , codec -> jfields . get_input_buffer_id , idx ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n } else { \n if ( ! codec -> input_buffers ) { \n codec -> input_buffers = ( * env ) -> CallObjectMethod ( env , codec -> object , codec -> jfields . get_input_buffers_id ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n codec -> input_buffers = ( * env ) -> NewGlobalRef ( env , codec -> input_buffers ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n } \n buffer = ( * env ) -> GetObjectArrayElement ( env , codec -> input_buffers , idx ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n } \n ret = ( * env ) -> GetDirectBufferAddress ( env , buffer ) ; \n * out_size = ( * env ) -> GetDirectBufferCapacity ( env , buffer ) ; \n fail : \n if ( buffer ) { \n ( * env ) -> DeleteLocalRef ( env , buffer ) ; \n } \n return ret ; \n }", "idx": 17831}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_slice ( AVCodecContext * avctx , void * tdata ) \n { \n FICContext * ctx = avctx -> priv_data ; \n FICThreadContext * tctx = tdata ; \n GetBitContext gb ; \n uint8_t * src = tctx -> src ; \n int slice_h = tctx -> slice_h ; \n int src_size = tctx -> src_size ; \n int y_off = tctx -> y_off ; \n int x , y , p ; \n init_get_bits ( & gb , src , src_size * 8 ) ; \n for ( p = 0 ; p < 3 ; p ++ ) { \n int stride = ctx -> frame -> linesize [ p ] ; \n uint8_t * dst = ctx -> frame -> data [ p ] + ( y_off >> ! ! p ) * stride ; \n for ( y = 0 ; y < ( slice_h >> ! ! p ) ; y += 8 ) { \n for ( x = 0 ; x < ( ctx -> aligned_width >> ! ! p ) ; x += 8 ) { \n int ret ; \n if ( ( ret = fic_decode_block ( ctx , & gb , dst + x , stride , tctx -> block ) ) != 0 ) \n return ret ; \n } \n dst += 8 * stride ; \n } \n } \n return 0 ; \n }", "idx": 17832}
{"project": "FFmpeg", "commit_id": "4332b01c30a446e9c177fe44761a612daa0334c7", "target": 1, "func": "av_cold int ff_huffyuv_alloc_temp ( HYuvContext * s ) \n { \n int i ; \n if ( s -> bitstream_bpp < 24 || s -> version > 2 ) { \n for ( i = 0 ; i < 3 ; i ++ ) { \n s -> temp [ i ] = av_malloc ( 2 * s -> width + 16 ) ; \n if ( ! s -> temp [ i ] ) \n return AVERROR ( ENOMEM ) ; \n s -> temp16 [ i ] = ( uint16_t * ) s -> temp [ i ] ; \n } \n } else { \n s -> temp [ 0 ] = av_mallocz ( 4 * s -> width + 16 ) ; \n if ( ! s -> temp [ 0 ] ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 17837}
{"project": "FFmpeg", "commit_id": "a67304d05f11b2377bf157a356d7ebb00f3e06dd", "target": 0, "func": "static void body ( uint32_t ABCD [ 4 ] , uint32_t X [ 16 ] ) \n { \n int i av_unused ; \n uint32_t t ; \n uint32_t a = ABCD [ 3 ] ; \n uint32_t b = ABCD [ 2 ] ; \n uint32_t c = ABCD [ 1 ] ; \n uint32_t d = ABCD [ 0 ] ; \n #if HAVE_BIGENDIAN  \n  \n  for ( i = 0 ; i < 16 ; i ++ ) \n X [ i ] = av_bswap32 ( X [ i ] ) ; \n #endif \n #if CONFIG_SMALL  \n  \n  for ( i = 0 ; i < 64 ; i ++ ) { \n CORE ( i , a , b , c , d ) ; \n t = d ; \n d = c ; \n c = b ; \n b = a ; \n a = t ; \n } \n #else \n #define CORE2 ( i )                                                         \\ \n  \n  CORE ( i , a , b , c , d ) ; CORE ( ( i + 1 ) , d , a , b , c ) ; \n CORE ( ( i + 2 ) , c , d , a , b ) ; CORE ( ( i + 3 ) , b , c , d , a )  \n #define CORE4 ( i )  CORE2(i); CORE2((i+4)); CORE2((i+8)); CORE2((i+12))  \n  \n  CORE4 ( 0 ) ; CORE4 ( 16 ) ; CORE4 ( 32 ) ; CORE4 ( 48 ) ; \n #endif \n ABCD [ 0 ] += d ; \n ABCD [ 1 ] += c ; \n ABCD [ 2 ] += b ; \n ABCD [ 3 ] += a ; \n }", "idx": 17840}
{"project": "FFmpeg", "commit_id": "12a419dacb479d663f04e316f9997568ef326965", "target": 0, "func": "static int v210_read_header ( AVFormatContext * ctx ) \n { \n V210DemuxerContext * s = ctx -> priv_data ; \n AVStream * st ; \n st = avformat_new_stream ( ctx , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = ctx -> iformat -> raw_codec_id ; \n avpriv_set_pts_info ( st , 64 , s -> framerate . den , s -> framerate . num ) ; \n st -> codec -> width = s -> width ; \n st -> codec -> height = s -> height ; \n st -> codec -> pix_fmt = ctx -> iformat -> raw_codec_id == AV_CODEC_ID_V210 ? \n AV_PIX_FMT_YUV422P10 : AV_PIX_FMT_YUV422P16 ; \n st -> codec -> bit_rate = av_rescale_q ( GET_PACKET_SIZE ( s -> width , s -> height ) , \n ( AVRational ) { 8 , 1 } , st -> time_base ) ; \n return 0 ; \n }", "idx": 17841}
{"project": "FFmpeg", "commit_id": "e8373143e11827b668495ff3323c3abedb3dc9da", "target": 0, "func": "static av_always_inline int process_frame ( WriterContext * w , \n InputFile * ifile , \n AVFrame * frame , AVPacket * pkt ) \n { \n AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; \n AVCodecContext * dec_ctx = ifile -> streams [ pkt -> stream_index ] . dec_ctx ; \n AVCodecParameters * par = ifile -> streams [ pkt -> stream_index ] . st -> codecpar ; \n AVSubtitle sub ; \n int ret = 0 , got_frame = 0 ; \n if ( dec_ctx -> codec ) { \n switch ( par -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n ret = avcodec_decode_video2 ( dec_ctx , frame , & got_frame , pkt ) ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n ret = avcodec_decode_audio4 ( dec_ctx , frame , & got_frame , pkt ) ; \n break ; \n case AVMEDIA_TYPE_SUBTITLE : \n ret = avcodec_decode_subtitle2 ( dec_ctx , & sub , & got_frame , pkt ) ; \n break ; \n } \n } \n if ( ret < 0 ) \n return ret ; \n ret = FFMIN ( ret , pkt -> size ) ; \n pkt -> data += ret ; \n pkt -> size -= ret ; \n if ( got_frame ) { \n int is_sub = ( par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ; \n nb_streams_frames [ pkt -> stream_index ] ++ ; \n if ( do_show_frames ) \n if ( is_sub ) \n show_subtitle ( w , & sub , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; \n else \n show_frame ( w , frame , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; \n if ( is_sub ) \n avsubtitle_free ( & sub ) ; \n } \n return got_frame ; \n }", "idx": 17850}
{"project": "FFmpeg", "commit_id": "8b43ee4054af799e388d380b379a13a60849c1b5", "target": 0, "func": "static int mov_read_stsd ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n int ret ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n sc -> stsd_count = avio_rb32 ( pb ) ; \n sc -> extradata = av_mallocz_array ( sc -> stsd_count , sizeof ( * sc -> extradata ) ) ; \n if ( ! sc -> extradata ) \n return AVERROR ( ENOMEM ) ; \n sc -> extradata_size = av_mallocz_array ( sc -> stsd_count , sizeof ( * sc -> extradata_size ) ) ; \n if ( ! sc -> extradata_size ) \n return AVERROR ( ENOMEM ) ; \n ret = ff_mov_read_stsd_entries ( c , pb , sc -> stsd_count ) ; \n if ( ret < 0 ) \n return ret ; \n av_freep ( & st -> codecpar -> extradata ) ; \n st -> codecpar -> extradata_size = sc -> extradata_size [ 0 ] ; \n if ( sc -> extradata_size [ 0 ] ) { \n st -> codecpar -> extradata = av_mallocz ( sc -> extradata_size [ 0 ] + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codecpar -> extradata ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( st -> codecpar -> extradata , sc -> extradata [ 0 ] , sc -> extradata_size [ 0 ] ) ; \n } \n return 0 ; \n }", "idx": 17851}
{"project": "FFmpeg", "commit_id": "ce09f9270a8bf43212dad58fcb73fee2900c364f", "target": 0, "func": "static void implicit_weight_table ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int ref0 , ref1 , i ; \n int cur_poc = s -> current_picture_ptr -> poc ; \n if ( h -> ref_count [ 0 ] == 1 && h -> ref_count [ 1 ] == 1 \n && h -> ref_list [ 0 ] [ 0 ] . poc + h -> ref_list [ 1 ] [ 0 ] . poc == 2 * cur_poc ) { \n h -> use_weight = 0 ; \n h -> use_weight_chroma = 0 ; \n return ; \n } \n h -> use_weight = 2 ; \n h -> use_weight_chroma = 2 ; \n h -> luma_log2_weight_denom = 5 ; \n h -> chroma_log2_weight_denom = 5 ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n h -> luma_weight_flag [ i ] = 0 ; \n h -> chroma_weight_flag [ i ] = 0 ; \n } \n for ( ref0 = 0 ; ref0 < h -> ref_count [ 0 ] ; ref0 ++ ) { \n int poc0 = h -> ref_list [ 0 ] [ ref0 ] . poc ; \n for ( ref1 = 0 ; ref1 < h -> ref_count [ 1 ] ; ref1 ++ ) { \n int poc1 = h -> ref_list [ 1 ] [ ref1 ] . poc ; \n int td = av_clip ( poc1 - poc0 , -128 , 127 ) ; \n if ( td ) { \n int tb = av_clip ( cur_poc - poc0 , -128 , 127 ) ; \n int tx = ( 16384 + ( FFABS ( td ) >> 1 ) ) / td ; \n int dist_scale_factor = av_clip ( ( tb * tx + 32 ) >> 6 , -1024 , 1023 ) >> 2 ; \n if ( dist_scale_factor < -64 || dist_scale_factor > 128 ) \n h -> implicit_weight [ ref0 ] [ ref1 ] = 32 ; \n else \n h -> implicit_weight [ ref0 ] [ ref1 ] = 64 - dist_scale_factor ; \n } else \n h -> implicit_weight [ ref0 ] [ ref1 ] = 32 ; \n } \n } \n }", "idx": 17852}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int ra144_encode_init ( AVCodecContext * avctx ) \n { \n RA144Context * ractx ; \n int ret ; \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> channels ) ; \n return -1 ; \n } \n avctx -> frame_size = NBLOCKS * BLOCKSIZE ; \n avctx -> delay = avctx -> frame_size ; \n avctx -> bit_rate = 8000 ; \n ractx = avctx -> priv_data ; \n ractx -> lpc_coef [ 0 ] = ractx -> lpc_tables [ 0 ] ; \n ractx -> lpc_coef [ 1 ] = ractx -> lpc_tables [ 1 ] ; \n ractx -> avctx = avctx ; \n ret = ff_lpc_init ( & ractx -> lpc_ctx , avctx -> frame_size , LPC_ORDER , \n FF_LPC_TYPE_LEVINSON ) ; \n if ( ret < 0 ) \n goto error ; \n ff_af_queue_init ( avctx , & ractx -> afq ) ; \n return 0 ; \n error : \n ra144_encode_close ( avctx ) ; \n return ret ; \n }", "idx": 17853}
{"project": "FFmpeg", "commit_id": "473f0f75a16b4d37bdaa943f75e4ae249212c1ba", "target": 1, "func": "static void * attribute_align_arg worker ( void * v ) \n { \n ThreadContext * c = v ; \n int our_job = c -> nb_jobs ; \n int nb_threads = c -> nb_threads ; \n unsigned int last_execute = 0 ; \n int self_id ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n self_id = c -> current_job ++ ; \n for ( ; ; ) { \n while ( our_job >= c -> nb_jobs ) { \n if ( c -> current_job == nb_threads + c -> nb_jobs ) \n pthread_cond_signal ( & c -> last_job_cond ) ; \n while ( last_execute == c -> current_execute && ! c -> done ) \n pthread_cond_wait ( & c -> current_job_cond , & c -> current_job_lock ) ; \n last_execute = c -> current_execute ; \n our_job = self_id ; \n if ( c -> done ) { \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n return NULL ; \n } \n } \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n c -> rets [ our_job % c -> nb_rets ] = c -> func ( c -> ctx , c -> arg , our_job , c -> nb_jobs ) ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n our_job = c -> current_job ++ ; \n } \n }", "idx": 17857}
{"project": "FFmpeg", "commit_id": "eb751f06db9f627c8b5c63d08836a39f7572bf56", "target": 1, "func": "static int mkv_field_order ( MatroskaDemuxContext * matroska , int64_t field_order ) \n { \n int major , minor , micro , bttb = 0 ; \n if ( sscanf ( matroska -> muxingapp , \" \" , & major , & minor , & micro ) == 3 ) \n bttb = ( major == 57 && minor >= 36 && minor <= 51 && micro >= 100 ) ; \n switch ( field_order ) { \n case MATROSKA_VIDEO_FIELDORDER_PROGRESSIVE : \n return AV_FIELD_PROGRESSIVE ; \n case MATROSKA_VIDEO_FIELDORDER_UNDETERMINED : \n return AV_FIELD_UNKNOWN ; \n case MATROSKA_VIDEO_FIELDORDER_TT : \n return AV_FIELD_TT ; \n case MATROSKA_VIDEO_FIELDORDER_BB : \n return AV_FIELD_BB ; \n case MATROSKA_VIDEO_FIELDORDER_BT : \n return bttb ? AV_FIELD_TB : AV_FIELD_BT ; \n case MATROSKA_VIDEO_FIELDORDER_TB : \n return bttb ? AV_FIELD_BT : AV_FIELD_TB ; \n default : \n return AV_FIELD_UNKNOWN ; \n } \n }", "idx": 17860}
{"project": "FFmpeg", "commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "target": 1, "func": "av_cold void ff_fft_init_arm ( FFTContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( have_vfp ( cpu_flags ) && ! have_vfpv3 ( cpu_flags ) ) { \n s -> fft_calc = ff_fft_calc_vfp ; \n #if CONFIG_MDCT  \n  \n  s -> imdct_half = ff_imdct_half_vfp ; \n #endif \n } \n if ( have_neon ( cpu_flags ) ) { \n s -> fft_permute = ff_fft_permute_neon ; \n s -> fft_calc = ff_fft_calc_neon ; \n #if CONFIG_MDCT  \n  \n  s -> imdct_calc = ff_imdct_calc_neon ; \n s -> imdct_half = ff_imdct_half_neon ; \n s -> mdct_calc = ff_mdct_calc_neon ; \n s -> mdct_permutation = FF_MDCT_PERM_INTERLEAVE ; \n #endif \n } \n }", "idx": 17861}
{"project": "FFmpeg", "commit_id": "c54286ab08e0c55dba72e4e9718e81b416e585d0", "target": 1, "func": "static int fourxm_probe ( AVProbeData * p ) \n { \n if ( ( AV_RL32 ( & p -> buf [ 0 ] ) != RIFF_TAG ) || \n ( AV_RL32 ( & p -> buf [ 8 ] ) != _4XMV_TAG ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 17868}
{"project": "FFmpeg", "commit_id": "15bd309af8302661838150de1905acc4df386d19", "target": 0, "func": "static int mov_write_stbl_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n int ret ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n mov_write_stsd_tag ( s , pb , mov , track ) ; \n mov_write_stts_tag ( pb , track ) ; \n if ( ( track -> par -> codec_type == AVMEDIA_TYPE_VIDEO || \n track -> par -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) && \n track -> has_keyframes && track -> has_keyframes < track -> entry ) \n mov_write_stss_tag ( pb , track , MOV_SYNC_SAMPLE ) ; \n if ( track -> mode == MODE_MOV && track -> flags & MOV_TRACK_STPS ) \n mov_write_stss_tag ( pb , track , MOV_PARTIAL_SYNC_SAMPLE ) ; \n if ( track -> par -> codec_type == AVMEDIA_TYPE_VIDEO && \n track -> flags & MOV_TRACK_CTTS && track -> entry ) { \n if ( ( ret = mov_write_ctts_tag ( pb , track ) ) < 0 ) \n return ret ; \n } \n mov_write_stsc_tag ( pb , track ) ; \n mov_write_stsz_tag ( pb , track ) ; \n mov_write_stco_tag ( pb , track ) ; \n if ( mov -> encryption_scheme == MOV_ENC_CENC_AES_CTR ) { \n ff_mov_cenc_write_stbl_atoms ( & track -> cenc , pb ) ; \n } \n if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) { \n mov_preroll_write_stbl_atoms ( pb , track ) ; \n } \n return update_size ( pb , pos ) ; \n }", "idx": 17873}
{"project": "FFmpeg", "commit_id": "36dc00de529fb4cd182e02f927597eef9514b886", "target": 0, "func": "avfilter_get_video_buffer_ref_from_arrays ( uint8_t * data [ 4 ] , int linesize [ 4 ] , int perms , \n int w , int h , enum PixelFormat format )  \n { \n AVFilterBuffer * pic = av_mallocz ( sizeof ( AVFilterBuffer ) ) ; \n AVFilterBufferRef * picref = av_mallocz ( sizeof ( AVFilterBufferRef ) ) ; \n if ( ! pic || ! picref ) \n goto fail ; \n picref -> buf = pic ; \n picref -> buf -> free = ff_avfilter_default_free_buffer ; \n if ( ! ( picref -> video = av_mallocz ( sizeof ( AVFilterBufferRefVideoProps ) ) ) ) \n goto fail ; \n picref -> video -> w = w ; \n picref -> video -> h = h ; \n picref -> perms = perms | AV_PERM_READ ; \n pic -> refcount = 1 ; \n picref -> type = AVMEDIA_TYPE_VIDEO ; \n picref -> format = format ; \n memcpy ( pic -> data , data , sizeof ( pic -> data ) ) ; \n memcpy ( pic -> linesize , linesize , sizeof ( pic -> linesize ) ) ; \n memcpy ( picref -> data , pic -> data , sizeof ( picref -> data ) ) ; \n memcpy ( picref -> linesize , pic -> linesize , sizeof ( picref -> linesize ) ) ; \n return picref ; \n fail : \n if ( picref && picref -> video ) \n av_free ( picref -> video ) ; \n av_free ( picref ) ; \n av_free ( pic ) ; \n return NULL ; \n }", "idx": 17882}
{"project": "FFmpeg", "commit_id": "dbc53ffc7c398f90ae1cf59e513d3882bc0dc188", "target": 1, "func": "static unsigned int mszh_decomp ( unsigned char * srcptr , int srclen , unsigned char * destptr , unsigned int destsize ) \n { \n unsigned char * destptr_bak = destptr ; \n unsigned char * destptr_end = destptr + destsize ; \n unsigned char mask = 0 ; \n unsigned char maskbit = 0 ; \n unsigned int ofs , cnt ; \n while ( srclen > 0 && destptr < destptr_end ) { \n if ( maskbit == 0 ) { \n mask = * srcptr ++ ; \n maskbit = 8 ; \n srclen -- ; \n continue ; \n } \n if ( ( mask & ( 1 << ( -- maskbit ) ) ) == 0 ) { \n if ( destptr + 4 > destptr_end ) \n break ; \n memcpy ( destptr , srcptr , 4 ) ; \n srclen -= 4 ; \n destptr += 4 ; \n srcptr += 4 ; \n } else { \n ofs = * srcptr ++ ; \n cnt = * srcptr ++ ; \n ofs += cnt * 256 ; \n cnt = ( ( cnt >> 3 ) & 0x1f ) + 1 ; \n ofs &= 0x7ff ; \n srclen -= 2 ; \n cnt *= 4 ; \n if ( destptr + cnt > destptr_end ) { \n cnt = destptr_end - destptr ; \n } \n for ( ; cnt > 0 ; cnt -- ) { \n * destptr = * ( destptr - ofs ) ; \n destptr ++ ; \n } \n } \n } \n return destptr - destptr_bak ; \n }", "idx": 17890}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) \n { \n GetByteContext * gb = & s -> gb ; \n RangeCoder * rc = & s -> rc ; \n unsigned totfr = pixel -> total_freq ; \n unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; \n int i , j , ret , c , cnt_c ; \n if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) \n return ret ; \n while ( x < 16 ) { \n cnt_x = pixel -> lookup [ x ] ; \n if ( value >= cumfr + cnt_x ) \n cumfr += cnt_x ; \n else \n break ; \n x ++ ; \n } \n c = x * 16 ; \n cnt_c = 0 ; \n while ( c < 256 ) { \n cnt_c = pixel -> freq [ c ] ; \n if ( value >= cumfr + cnt_c ) \n cumfr += cnt_c ; \n else \n break ; \n c ++ ; \n } \n s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ; \n pixel -> freq [ c ] = cnt_c + step ; \n pixel -> lookup [ x ] = cnt_x + step ; \n totfr += step ; \n if ( totfr > BOT ) { \n totfr = 0 ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; \n pixel -> freq [ i ] = nc ; \n totfr += nc ; \n } \n for ( i = 0 ; i < 16 ; i ++ ) { \n unsigned sum = 0 ; \n unsigned i16_17 = i << 4 ; \n for ( j = 0 ; j < 16 ; j ++ ) \n sum += pixel -> freq [ i16_17 + j ] ; \n pixel -> lookup [ i ] = sum ; \n } \n } \n pixel -> total_freq = totfr ; \n * rval = c & s -> cbits ; \n return 0 ; \n }", "idx": 17896}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_scalarproduct_float ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , \n const float * v1 , const float * v2 ) \n { \n float cprod , oprod ; \n int ret ; \n cprod = cdsp -> scalarproduct_float ( v1 , v2 , LEN ) ; \n oprod = fdsp -> scalarproduct_float ( v1 , v2 , LEN ) ; \n if ( ret = compare_floats ( & cprod , & oprod , 1 , ARBITRARY_SCALARPRODUCT_CONST ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n }", "idx": 17898}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_pasp ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n const int num = get_be32 ( pb ) ; \n const int den = get_be32 ( pb ) ; \n AVStream * const st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( den != 0 ) { \n if ( ( st -> sample_aspect_ratio . den != 1 || st -> sample_aspect_ratio . num ) && \n ( den != st -> sample_aspect_ratio . den || num != st -> sample_aspect_ratio . num ) ) \n av_log ( c -> fc , AV_LOG_WARNING , \n \" \\n \" , \n st -> sample_aspect_ratio . num , st -> sample_aspect_ratio . den ) ; \n st -> sample_aspect_ratio . num = num ; \n st -> sample_aspect_ratio . den = den ; \n } \n return 0 ; \n }", "idx": 17899}
{"project": "FFmpeg", "commit_id": "3e207bb1bd822ee1bce3e2de4c784702e0b6e24a", "target": 0, "func": "static void MPV_encode_defaults ( MpegEncContext * s ) { \n static int done = 0 ; \n MPV_common_defaults ( s ) ; \n if ( ! done ) { \n int i ; \n done = 1 ; \n for ( i = -16 ; i < 16 ; i ++ ) { \n default_fcode_tab [ i + MAX_MV ] = 1 ; \n } \n } \n s -> me . mv_penalty = default_mv_penalty ; \n s -> fcode_tab = default_fcode_tab ; \n }", "idx": 17900}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_get_file_handle ( URLContext * h ) \n { \n FTPContext * s = h -> priv_data ; \n av_dlog ( h , \" \\n \" ) ; \n if ( s -> conn_data ) \n return ffurl_get_file_handle ( s -> conn_data ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 17902}
{"project": "FFmpeg", "commit_id": "c16184e9baad4e4304d5bfb9340e8b5b6decad65", "target": 0, "func": "static void sdp_write_header ( char * buff , int size , struct sdp_session_level * s ) \n { \n av_strlcatf ( buff , size , \" \\r \\n \" \n \" \\r \\n \" \n \" \\r \\n \" \n \" \\r \\n \" \n \" \" AV_STRINGIFY ( LIBAVFORMAT_VERSION )  \" \\r \\n \" , \n s -> sdp_version , \n s -> id , s -> version , s -> src_addr , \n s -> start_time , s -> end_time , \n s -> name [ 0 ] ? s -> name : \" \" ) ; \n dest_write ( buff , size , s -> dst_addr , s -> ttl ) ; \n }", "idx": 17903}
{"project": "FFmpeg", "commit_id": "44e6eeb30de8e2d20db56284984da4615763525c", "target": 1, "func": "static int print_device_sources ( AVInputFormat * fmt , AVDictionary * opts ) \n { \n int ret , i ; \n AVFormatContext * dev = NULL ; \n AVDeviceInfoList * device_list = NULL ; \n AVDictionary * tmp_opts = NULL ; \n if ( ! fmt || ! fmt -> priv_class || ! AV_IS_INPUT_DEVICE ( fmt -> priv_class -> category ) ) \n return AVERROR ( EINVAL ) ; \n printf ( \" \\n \" , fmt -> name ) ; \n if ( ! fmt -> get_device_list ) { \n ret = AVERROR ( ENOSYS ) ; \n printf ( \" \\n \" ) ; \n goto fail ; \n } \n av_dict_copy ( & tmp_opts , opts , 0 ) ; \n if ( ( ret = avformat_open_input ( & dev , NULL , fmt , & tmp_opts ) ) < 0 ) { \n printf ( \" \\n \" , fmt -> name ) ; \n goto fail ; \n } \n if ( ( ret = avdevice_list_devices ( dev , & device_list ) ) < 0 ) { \n printf ( \" \\n \" ) ; \n goto fail ; \n } \n for ( i = 0 ; i < device_list -> nb_devices ; i ++ ) { \n printf ( \" \\n \" , device_list -> default_device == i ? \" \" : \" \" , \n device_list -> devices [ i ] -> device_name , device_list -> devices [ i ] -> device_description ) ; \n } \n fail : \n av_dict_free ( & tmp_opts ) ; \n avdevice_free_list_devices ( & device_list ) ; \n avformat_close_input ( & dev ) ; \n return ret ; \n }", "idx": 17905}
{"project": "FFmpeg", "commit_id": "4e745ea83eee0010c0e2f228f47d1394ed1e2170", "target": 0, "func": "void ff_ac3_bit_alloc_calc_bap ( int16_t * mask , int16_t * psd , int start , int end , \n int snr_offset , int floor , \n const uint8_t * bap_tab , uint8_t * bap ) \n { \n int i , j , end1 , v , address ; \n if ( snr_offset == -960 ) { \n memset ( bap , 0 , 256 ) ; \n return ; \n } \n i = start ; \n j = bin_to_band_tab [ start ] ; \n do { \n v = ( FFMAX ( mask [ j ] - snr_offset - floor , 0 ) & 0x1FE0 ) + floor ; \n end1 = FFMIN ( band_start_tab [ j ] + ff_ac3_critical_band_size_tab [ j ] , end ) ; \n for ( ; i < end1 ; i ++ ) { \n address = av_clip ( ( psd [ i ] - v ) >> 5 , 0 , 63 ) ; \n bap [ i ] = bap_tab [ address ] ; \n } \n } while ( end > band_start_tab [ j ++ ] ) ; \n }", "idx": 17911}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 3 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 17914}
{"project": "FFmpeg", "commit_id": "035e932d7c039030bd8142bf2f99cbbd1d3e92cf", "target": 0, "func": "static int vivo_probe ( AVProbeData * p ) \n { \n const unsigned char * buf = p -> buf ; \n unsigned c , length = 0 ; \n if ( * buf ++ != 0 ) \n return 0 ; \n c = * buf ++ ; \n length = c & 0x7F ; \n if ( c & 0x80 ) { \n c = * buf ++ ; \n length = ( length << 7 ) | ( c & 0x7F ) ; \n } \n if ( c & 0x80 || length > 1024 || length < 21 ) \n return 0 ; \n if ( memcmp ( buf , \" \\r \\n \" , 15 ) ) \n return 0 ; \n buf += 15 ; \n if ( * buf < ' ' && * buf > ' ' ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 17916}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int put_packetheader ( NUTContext * nut , ByteIOContext * bc , int max_size ) \n { \n put_flush_packet ( bc ) ; \n nut -> last_packet_start = nut -> packet_start ; \n nut -> packet_start += nut -> written_packet_size ; \n nut -> packet_size_pos = url_ftell ( bc ) ; \n nut -> written_packet_size = max_size ; \n put_v ( bc , nut -> written_packet_size ) ; \n put_v ( bc , nut -> packet_start - nut -> last_packet_start ) ; \n return 0 ; \n }", "idx": 17918}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "int mjpeg_init ( MpegEncContext * s ) \n { \n MJpegContext * m ; \n m = malloc ( sizeof ( MJpegContext ) ) ; \n if ( ! m ) \n return -1 ; \n build_huffman_codes ( m -> huff_size_dc_luminance , \n m -> huff_code_dc_luminance , \n bits_dc_luminance , \n val_dc_luminance ) ; \n build_huffman_codes ( m -> huff_size_dc_chrominance , \n m -> huff_code_dc_chrominance , \n bits_dc_chrominance , \n val_dc_chrominance ) ; \n build_huffman_codes ( m -> huff_size_ac_luminance , \n m -> huff_code_ac_luminance , \n bits_ac_luminance , \n val_ac_luminance ) ; \n build_huffman_codes ( m -> huff_size_ac_chrominance , \n m -> huff_code_ac_chrominance , \n bits_ac_chrominance , \n val_ac_chrominance ) ; \n s -> mjpeg_ctx = m ; \n return 0 ; \n }", "idx": 17927}
{"project": "FFmpeg", "commit_id": "7d132c544b2447ef5a6b04ca6f21e245d6a48986", "target": 1, "func": "int av_parse_color ( uint8_t * rgba_color , const char * color_string , void * log_ctx ) \n { \n if ( ! strcasecmp ( color_string , \" \" ) || ! strcasecmp ( color_string , \" \" ) ) { \n int rgba = ff_random_get_seed ( ) ; \n rgba_color [ 0 ] = rgba >> 24 ; \n rgba_color [ 1 ] = rgba >> 16 ; \n rgba_color [ 2 ] = rgba >> 8 ; \n rgba_color [ 3 ] = rgba ; \n } else \n if ( ! strncmp ( color_string , \" \" , 2 ) ) { \n char * tail ; \n int len = strlen ( color_string ) ; \n int rgba = strtol ( color_string , & tail , 16 ) ; \n if ( * tail || ( len != 8 && len != 10 ) ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , color_string ) ; \n return -1 ; \n } \n if ( len == 10 ) { \n rgba_color [ 3 ] = rgba ; \n rgba >>= 8 ; \n } \n rgba_color [ 0 ] = rgba >> 16 ; \n rgba_color [ 1 ] = rgba >> 8 ; \n rgba_color [ 2 ] = rgba ; \n } else { \n const ColorEntry * entry = bsearch ( color_string , \n color_table , \n FF_ARRAY_ELEMS ( color_table ) , \n sizeof ( ColorEntry ) , \n color_table_compare ) ; \n if ( ! entry ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , color_string ) ; \n return -1 ; \n } \n memcpy ( rgba_color , entry -> rgba_color , 4 ) ; \n } \n return 0 ; \n }", "idx": 17931}
{"project": "FFmpeg", "commit_id": "6cf31ef263d36f6b89d9b64f15ca81cef4f24901", "target": 1, "func": "static void use_normal_update_speed ( WmallDecodeCtx * s , int ich ) \n { \n int ilms , recent , icoef ; \n s -> update_speed [ ich ] = 8 ; \n for ( ilms = s -> cdlms_ttl [ ich ] ; ilms >= 0 ; ilms -- ) { \n recent = s -> cdlms [ ich ] [ ilms ] . recent ; \n if ( s -> bV3RTM ) { \n for ( icoef = 0 ; icoef < s -> cdlms [ ich ] [ ilms ] . order ; icoef ++ ) \n s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef + recent ] /= 2 ; \n } else { \n for ( icoef = 0 ; icoef < s -> cdlms [ ich ] [ ilms ] . order ; icoef ++ ) \n s -> cdlms [ ich ] [ ilms ] . lms_updates [ icoef ] /= 2 ; \n } \n } \n }", "idx": 17945}
{"project": "FFmpeg", "commit_id": "6956b048d8198dce5126c8942dece21cfb1a7978", "target": 1, "func": "static int load_textfile ( AVFilterContext * ctx ) \n { \n DrawTextContext * s = ctx -> priv ; \n int err ; \n uint8_t * textbuf ; \n size_t textbuf_size ; \n if ( ( err = av_file_map ( s -> textfile , & textbuf , & textbuf_size , 0 , ctx ) ) < 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n s -> textfile ) ; \n return err ; \n } \n if ( ! ( s -> text = av_realloc ( s -> text , textbuf_size + 1 ) ) ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( s -> text , textbuf , textbuf_size ) ; \n s -> text [ textbuf_size ] = 0 ; \n av_file_unmap ( textbuf , textbuf_size ) ; \n return 0 ; \n }", "idx": 17983}
{"project": "FFmpeg", "commit_id": "9fe73b0147d329bb03ea57c201dc99317cbf3c29", "target": 1, "func": "static int ftp_send_command ( FTPContext * s , const char * command , \n const int response_codes [ ] , char * * response ) \n { \n int err ; \n ff_dlog ( s , \" \" , command ) ; \n if ( response ) \n * response = NULL ; \n if ( ( err = ffurl_write ( s -> conn_control , command , strlen ( command ) ) ) < 0 ) \n return err ; \n if ( ! err ) \n return -1 ; \n if ( response_codes ) { \n return ftp_status ( s , response , response_codes ) ; \n } \n return 0 ; \n }", "idx": 17985}
{"project": "FFmpeg", "commit_id": "8dc72eeaf647736c287b59a3856a11904bedd58b", "target": 1, "func": "static int udp_socket_create ( UDPContext * s , struct sockaddr_storage * addr , \n socklen_t * addr_len , const char * localaddr ) \n { \n int udp_fd = -1 ; \n struct addrinfo * res0 = NULL , * res = NULL ; \n int family = AF_UNSPEC ; \n if ( ( ( struct sockaddr * ) & s -> dest_addr ) -> sa_family ) \n family = ( ( struct sockaddr * ) & s -> dest_addr ) -> sa_family ; \n res0 = udp_resolve_host ( localaddr [ 0 ] ? localaddr : NULL , s -> local_port , \n SOCK_DGRAM , family , AI_PASSIVE ) ; \n if ( res0 == 0 ) \n goto fail ; \n for ( res = res0 ; res ; res = res -> ai_next ) { \n udp_fd = ff_socket ( res -> ai_family , SOCK_DGRAM , 0 ) ; \n if ( udp_fd != -1 ) break ; \n log_net_error ( NULL , AV_LOG_ERROR , \" \" ) ; \n } \n if ( udp_fd < 0 ) \n goto fail ; \n memcpy ( addr , res -> ai_addr , res -> ai_addrlen ) ; \n * addr_len = res -> ai_addrlen ; \n freeaddrinfo ( res0 ) ; \n return udp_fd ; \n fail : \n if ( udp_fd >= 0 ) \n closesocket ( udp_fd ) ; \n if ( res0 ) \n freeaddrinfo ( res0 ) ; \n return -1 ; \n }", "idx": 17992}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void RENAME ( yuv2yuv1 ) ( int16_t * lumSrc , int16_t * chrSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest ) \n { \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = lumSrc [ i ] >> 7 ; \n if ( val & 256 ) { \n if ( val < 0 ) val = 0 ; \n else val = 255 ; \n } \n dest [ i ] = val ; \n } \n if ( uDest ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = chrSrc [ i ] >> 7 ; \n int v = chrSrc [ i + 2048 ] >> 7 ; \n if ( ( u | v ) & 256 ) { \n if ( u < 0 ) u = 0 ; \n else if ( u > 255 ) u = 255 ; \n if ( v < 0 ) v = 0 ; \n else if ( v > 255 ) v = 255 ; \n } \n uDest [ i ] = u ; \n vDest [ i ] = v ; \n } \n #endif \n }", "idx": 17994}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline void dv_encode_ac ( EncBlockInfo * bi , PutBitContext * pb_pool , \n int pb_size ) \n { \n int run ; \n int bits_left ; \n PutBitContext * pb = pb_pool ; \n int size = bi -> partial_bit_count ; \n uint32_t vlc = bi -> partial_bit_buffer ; \n bi -> partial_bit_count = bi -> partial_bit_buffer = 0 ; \n vlc_loop : \n for ( ; size > ( bits_left = put_bits_left ( pb ) ) ; pb ++ ) { \n if ( bits_left ) { \n size -= bits_left ; \n put_bits ( pb , bits_left , vlc >> size ) ; \n vlc = vlc & ( ( 1 << size ) - 1 ) ; \n } \n if ( pb_size == 1 ) { \n bi -> partial_bit_count = size ; \n bi -> partial_bit_buffer = vlc ; \n return ; \n } \n -- pb_size ; \n } \n put_bits ( pb , size , vlc ) ; \n run = 0 ; \n for ( ; bi -> cur_ac < 64 ; bi -> cur_ac ++ , run ++ ) { \n if ( bi -> mb [ bi -> cur_ac ] ) { \n size = dv_rl2vlc ( run , bi -> mb [ bi -> cur_ac ] , & vlc ) ; \n bi -> cur_ac ++ ; \n goto vlc_loop ; \n } \n } \n if ( bi -> cur_ac == 64 ) { \n size = 4 ; vlc = 6 ; \n bi -> cur_ac ++ ; \n goto vlc_loop ; \n } \n }", "idx": 17999}
{"project": "FFmpeg", "commit_id": "2540d884f3fd7cfac503e048112098967be2569a", "target": 0, "func": "static uint32_t get_generic_seed ( void ) \n { \n uint8_t tmp [ 120 ] ; \n struct AVSHA * sha = ( void * ) tmp ; \n clock_t last_t = 0 ; \n static uint64_t i = 0 ; \n static uint32_t buffer [ 512 ] = { 0 } ; \n unsigned char digest [ 20 ] ; \n uint64_t last_i = i ; \n av_assert0 ( sizeof ( tmp ) >= av_sha_size ) ; \n if ( TEST ) { \n memset ( buffer , 0 , sizeof ( buffer ) ) ; \n last_i = i = 0 ; \n } else { \n #ifdef AV_READ_TIME \n buffer [ 13 ] ^= AV_READ_TIME ( ) ; \n buffer [ 41 ] ^= AV_READ_TIME ( ) >> 32 ; \n #endif \n } \n for ( ; ; ) { \n clock_t t = clock ( ) ; \n if ( last_t == t ) { \n buffer [ i & 511 ] ++ ; \n } else { \n buffer [ ++ i & 511 ] += ( t - last_t ) % 3294638521U ; \n if ( last_i && i - last_i > 4 || i - last_i > 64 || TEST && i - last_i > 8 ) \n break ; \n } \n last_t = t ; \n } \n if ( TEST ) \n buffer [ 0 ] = buffer [ 1 ] = 0 ; \n av_sha_init ( sha , 160 ) ; \n av_sha_update ( sha , ( const uint8_t * ) buffer , sizeof ( buffer ) ) ; \n av_sha_final ( sha , digest ) ; \n return AV_RB32 ( digest ) + AV_RB32 ( digest + 16 ) ; \n }", "idx": 18001}
{"project": "FFmpeg", "commit_id": "eca38864a6ce5053e463b8d3fc22b22bc9a49578", "target": 0, "func": "int ff_vorbiscomment_write ( uint8_t * * p , AVDictionary * * m , \n const char * vendor_string ) \n { \n bytestream_put_le32 ( p , strlen ( vendor_string ) ) ; \n bytestream_put_buffer ( p , vendor_string , strlen ( vendor_string ) ) ; \n if ( * m ) { \n int count = av_dict_count ( * m ) ; \n AVDictionaryEntry * tag = NULL ; \n bytestream_put_le32 ( p , count ) ; \n while ( ( tag = av_dict_get ( * m , \" \" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) { \n unsigned int len1 = strlen ( tag -> key ) ; \n unsigned int len2 = strlen ( tag -> value ) ; \n bytestream_put_le32 ( p , len1 + 1 + len2 ) ; \n bytestream_put_buffer ( p , tag -> key , len1 ) ; \n bytestream_put_byte ( p , ' ' ) ; \n bytestream_put_buffer ( p , tag -> value , len2 ) ; \n } \n } else \n bytestream_put_le32 ( p , 0 ) ; \n return 0 ; \n }", "idx": 18012}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void yuv2yuv1_c ( SwsContext * c , const int16_t * lumSrc , \n const int16_t * chrUSrc , const int16_t * chrVSrc , \n const int16_t * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = ( lumSrc [ i ] + 64 ) >> 7 ; \n dest [ i ] = av_clip_uint8 ( val ) ; \n } \n if ( uDest ) \n for ( i = 0 ; i < chrDstW ; i ++ ) { \n int u = ( chrUSrc [ i ] + 64 ) >> 7 ; \n int v = ( chrVSrc [ i ] + 64 ) >> 7 ; \n uDest [ i ] = av_clip_uint8 ( u ) ; \n vDest [ i ] = av_clip_uint8 ( v ) ; \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = ( alpSrc [ i ] + 64 ) >> 7 ; \n aDest [ i ] = av_clip_uint8 ( val ) ; \n } \n }", "idx": 18035}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int teletext_close_decoder ( AVCodecContext * avctx ) \n { \n TeletextContext * ctx = avctx -> priv_data ; \n av_dlog ( avctx , \" \\n \" , ctx -> lines_processed ) ; \n while ( ctx -> nb_pages ) \n subtitle_rect_free ( & ctx -> pages [ -- ctx -> nb_pages ] . sub_rect ) ; \n av_freep ( & ctx -> pages ) ; \n vbi_decoder_delete ( ctx -> vbi ) ; \n ctx -> vbi = NULL ; \n ctx -> pts = AV_NOPTS_VALUE ; \n return 0 ; \n }", "idx": 18036}
{"project": "FFmpeg", "commit_id": "f694168d524d1c84f5f20f4260fcab1f4d8c11d7", "target": 1, "func": "static int ffm_write_packet ( AVFormatContext * s , int stream_index , \n UINT8 * buf , int size , int force_pts ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n FFMStream * fst = st -> priv_data ; \n INT64 pts ; \n UINT8 header [ FRAME_HEADER_SIZE ] ; \n int duration ; \n if ( st -> codec . codec_type == CODEC_TYPE_AUDIO ) { \n duration = ( ( float ) st -> codec . frame_size / st -> codec . sample_rate * 1000000.0 ) ; \n } else { \n duration = ( 1000000.0 * FRAME_RATE_BASE / ( float ) st -> codec . frame_rate ) ; \n } \n pts = fst -> pts ; \n header [ 0 ] = stream_index ; \n header [ 1 ] = 0 ; \n if ( st -> codec . coded_picture -> key_frame ) \n header [ 1 ] |= FLAG_KEY_FRAME ; \n header [ 2 ] = ( size >> 16 ) & 0xff ; \n header [ 3 ] = ( size >> 8 ) & 0xff ; \n header [ 4 ] = size & 0xff ; \n header [ 5 ] = ( duration >> 16 ) & 0xff ; \n header [ 6 ] = ( duration >> 8 ) & 0xff ; \n header [ 7 ] = duration & 0xff ; \n ffm_write_data ( s , header , FRAME_HEADER_SIZE , pts , 1 ) ; \n ffm_write_data ( s , buf , size , pts , 0 ) ; \n fst -> pts += duration ; \n return 0 ; \n }", "idx": 18070}
{"project": "FFmpeg", "commit_id": "76f7e70aa04fc5dbef5242b11cbf8fe4499f61d4", "target": 1, "func": "static int get_last_needed_nal ( H264Context * h ) \n { \n int nals_needed = 0 ; \n int i ; \n for ( i = 0 ; i < h -> pkt . nb_nals ; i ++ ) { \n H2645NAL * nal = & h -> pkt . nals [ i ] ; \n GetBitContext gb ; \n switch ( nal -> type ) { \n case H264_NAL_SPS : \n case H264_NAL_PPS : \n nals_needed = i ; \n break ; \n case H264_NAL_DPA : \n case H264_NAL_IDR_SLICE : \n case H264_NAL_SLICE : \n init_get_bits ( & gb , nal -> data + 1 , ( nal -> size - 1 ) * 8 ) ; \n if ( ! get_ue_golomb ( & gb ) ) \n nals_needed = i ; \n } \n } \n return nals_needed ; \n }", "idx": 18073}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void prepare_play ( void ) \n { \n AVOutputFormat * ofmt ; \n ofmt = guess_format ( \" \" , NULL , NULL ) ; \n if ( ! ofmt ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n opt_output_file ( audio_device ) ; \n }", "idx": 18082}
{"project": "FFmpeg", "commit_id": "e5b0cfb541035967f4b2fcc49a48c1103a8bce62", "target": 1, "func": "static int vorbis_parse_setup_hdr_modes ( vorbis_context * vc ) { \n GetBitContext * gb = & vc -> gb ; \n uint_fast8_t i ; \n vc -> mode_count = get_bits ( gb , 6 ) + 1 ; \n vc -> modes = av_mallocz ( vc -> mode_count * sizeof ( vorbis_mode ) ) ; \n AV_DEBUG ( \" \\n \" , vc -> mode_count ) ; \n for ( i = 0 ; i < vc -> mode_count ; ++ i ) { \n vorbis_mode * mode_setup = & vc -> modes [ i ] ; \n mode_setup -> blockflag = get_bits1 ( gb ) ; \n mode_setup -> windowtype = get_bits ( gb , 16 ) ; \n mode_setup -> transformtype = get_bits ( gb , 16 ) ; \n mode_setup -> mapping = get_bits ( gb , 8 ) ; \n AV_DEBUG ( \" \\n \" , i , mode_setup -> blockflag , mode_setup -> windowtype , mode_setup -> transformtype , mode_setup -> mapping ) ; \n } \n return 0 ; \n }", "idx": 18086}
{"project": "FFmpeg", "commit_id": "07cd8d5676a72d80661e9bfde0a26d83aca4d029", "target": 0, "func": "av_cold void ff_cavsdsp_init_x86 ( CAVSDSPContext * c , AVCodecContext * avctx ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n cavsdsp_init_mmx ( c , avctx ) ; \n #if HAVE_AMD3DNOW_INLINE  \n  \n  if ( INLINE_AMD3DNOW ( cpu_flags ) ) \n cavsdsp_init_3dnow ( c , avctx ) ; \n #endif \n #if HAVE_MMXEXT_INLINE  \n  \n  if ( INLINE_MMXEXT ( cpu_flags ) ) { \n DSPFUNC ( put , 0 , 16 , mmxext ) ; \n DSPFUNC ( put , 1 , 8 , mmxext ) ; \n DSPFUNC ( avg , 0 , 16 , mmxext ) ; \n DSPFUNC ( avg , 1 , 8 , mmxext ) ; \n } \n #endif \n #if HAVE_MMX_EXTERNAL  \n  \n  if ( EXTERNAL_MMXEXT ( cpu_flags ) ) { \n c -> avg_cavs_qpel_pixels_tab [ 0 ] [ 0 ] = avg_cavs_qpel16_mc00_mmxext ; \n c -> avg_cavs_qpel_pixels_tab [ 1 ] [ 0 ] = avg_cavs_qpel8_mc00_mmxext ; \n } \n #endif \n #if HAVE_SSE2_EXTERNAL  \n  \n  if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n c -> put_cavs_qpel_pixels_tab [ 0 ] [ 0 ] = put_cavs_qpel16_mc00_sse2 ; \n c -> avg_cavs_qpel_pixels_tab [ 0 ] [ 0 ] = avg_cavs_qpel16_mc00_sse2 ; \n } \n #endif \n }", "idx": 18092}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static int finish_frame ( AVCodecContext * avctx , AVFrame * pict ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n MpegEncContext * s = & r -> s ; \n int got_picture = 0 , ret ; \n ff_er_frame_end ( & s -> er ) ; \n ff_mpv_frame_end ( s ) ; \n s -> mb_num_left = 0 ; \n if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) \n ff_thread_report_progress ( & s -> current_picture_ptr -> tf , INT_MAX , 0 ) ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { \n if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> current_picture_ptr ) ; \n got_picture = 1 ; \n } else if ( s -> last_picture_ptr != NULL ) { \n if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> last_picture_ptr ) ; \n got_picture = 1 ; \n } \n return got_picture ; \n }", "idx": 18093}
{"project": "FFmpeg", "commit_id": "c661cb6672af5ebcb900ec8766b24761bd2ab011", "target": 0, "func": "static void init_parse_context ( OptionParseContext * octx , \n const OptionGroupDef * groups ) \n { \n static const OptionGroupDef global_group = { \" \" } ; \n const OptionGroupDef * g = groups ; \n int i ; \n memset ( octx , 0 , sizeof ( * octx ) ) ; \n while ( g -> name ) \n g ++ ; \n octx -> nb_groups = g - groups ; \n octx -> groups = av_mallocz ( sizeof ( * octx -> groups ) * octx -> nb_groups ) ; \n if ( ! octx -> groups ) \n exit ( 1 ) ; \n for ( i = 0 ; i < octx -> nb_groups ; i ++ ) \n octx -> groups [ i ] . group_def = & groups [ i ] ; \n octx -> global_opts . group_def = & global_group ; \n octx -> global_opts . arg = \" \" ; \n init_opts ( ) ; \n }", "idx": 18094}
{"project": "FFmpeg", "commit_id": "53c05b1eacd5f7dbfa3651b45e797adaea0a5ff8", "target": 0, "func": "static inline void write_back_non_zero_count ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n const int mb_xy = s -> mb_x + s -> mb_y * s -> mb_stride ; \n int n ; \n for ( n = 0 ; n < 16 + 4 + 4 ; n ++ ) \n h -> non_zero_count [ mb_xy ] [ n ] = h -> non_zero_count_cache [ scan8 [ n ] ] ; \n }", "idx": 18106}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_chapters ( WriterContext * w , AVFormatContext * fmt_ctx ) \n { \n int i ; \n writer_print_section_header ( w , SECTION_ID_CHAPTERS ) ; \n for ( i = 0 ; i < fmt_ctx -> nb_chapters ; i ++ ) { \n AVChapter * chapter = fmt_ctx -> chapters [ i ] ; \n writer_print_section_header ( w , SECTION_ID_CHAPTER ) ; \n print_int ( \" \" , chapter -> id ) ; \n print_q ( \" \" , chapter -> time_base , ' ' ) ; \n print_int ( \" \" , chapter -> start ) ; \n print_time ( \" \" , chapter -> start , & chapter -> time_base ) ; \n print_int ( \" \" , chapter -> end ) ; \n print_time ( \" \" , chapter -> end , & chapter -> time_base ) ; \n show_tags ( w , chapter -> metadata , SECTION_ID_CHAPTER_TAGS ) ; \n writer_print_section_footer ( w ) ; \n } \n writer_print_section_footer ( w ) ; \n }", "idx": 18132}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int mpc_probe ( AVProbeData * p ) \n { \n const uint8_t * d = p -> buf ; \n if ( p -> buf_size < 32 ) \n return 0 ; \n if ( d [ 0 ] == ' ' && d [ 1 ] == ' ' && d [ 2 ] == ' ' && ( d [ 3 ] == 0x17 || d [ 3 ] == 0x7 ) ) \n return AVPROBE_SCORE_MAX ; \n if ( d [ 0 ] == ' ' && d [ 1 ] == ' ' && d [ 2 ] == ' ' ) \n return AVPROBE_SCORE_MAX / 2 ; \n return 0 ; \n }", "idx": 18165}
{"project": "FFmpeg", "commit_id": "0a39c9ac0bfd7345fe676b4e2707d9cec3cbb553", "target": 0, "func": "av_cold void ff_hpeldsp_init_x86 ( HpelDSPContext * c , int flags ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( INLINE_MMX ( cpu_flags ) ) \n hpeldsp_init_mmx ( c , flags ) ; \n if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) \n hpeldsp_init_3dnow ( c , flags ) ; \n if ( EXTERNAL_MMXEXT ( cpu_flags ) ) \n hpeldsp_init_mmxext ( c , flags ) ; \n if ( EXTERNAL_SSE2_FAST ( cpu_flags ) ) \n hpeldsp_init_sse2_fast ( c , flags ) ; \n if ( CONFIG_VP3_DECODER ) \n ff_hpeldsp_vp3_init_x86 ( c , cpu_flags , flags ) ; \n }", "idx": 18166}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read_image ( uint8_t * * dst_data , int * plane_size , int plane_num , \n cl_mem src_cl_buf , size_t cl_buffer_size ) \n { \n int i , buffer_size = 0 , ret = 0 ; \n uint8_t * temp ; \n void * mapped ; \n cl_int status ; \n if ( ( unsigned int ) plane_num > 8 ) { \n return AVERROR ( EINVAL ) ; \n } \n for ( i = 0 ; i < plane_num ; i ++ ) { \n buffer_size += plane_size [ i ] ; \n } \n if ( buffer_size > cl_buffer_size ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n mapped = clEnqueueMapBuffer ( gpu_env . command_queue , src_cl_buf , \n CL_TRUE , CL_MAP_READ , 0 , buffer_size , \n 0 , NULL , NULL , & status ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n temp = mapped ; \n if ( ret >= 0 ) { \n for ( i = 0 ; i < plane_num ; i ++ ) { \n memcpy ( dst_data [ i ] , temp , plane_size [ i ] ) ; \n temp += plane_size [ i ] ; \n } \n } \n status = clEnqueueUnmapMemObject ( gpu_env . command_queue , src_cl_buf , mapped , 0 , NULL , NULL ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n return 0 ; \n }", "idx": 18168}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "static void rtsp_cmd_describe ( HTTPContext * c , const char * url ) \n { \n FFStream * stream ; \n char path1 [ 1024 ] ; \n const char * path ; \n uint8_t * content ; \n int content_length , len ; \n struct sockaddr_in my_addr ; \n url_split ( NULL , 0 , NULL , 0 , NULL , path1 , sizeof ( path1 ) , url ) ; \n path = path1 ; \n if ( * path == ' ' ) \n path ++ ; \n for ( stream = first_stream ; stream != NULL ; stream = stream -> next ) { \n if ( ! stream -> is_feed && stream -> fmt == & rtp_mux && \n ! strcmp ( path , stream -> filename ) ) { \n goto found ; \n } \n } \n rtsp_reply_error ( c , RTSP_STATUS_SERVICE ) ; \n return ; \n found : \n len = sizeof ( my_addr ) ; \n getsockname ( c -> fd , ( struct sockaddr * ) & my_addr , & len ) ; \n content_length = prepare_sdp_description ( stream , & content , my_addr . sin_addr ) ; \n if ( content_length < 0 ) { \n rtsp_reply_error ( c , RTSP_STATUS_INTERNAL ) ; \n return ; \n } \n rtsp_reply_header ( c , RTSP_STATUS_OK ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" , content_length ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n put_buffer ( c -> pb , content , content_length ) ; \n }", "idx": 18169}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static char * shorts2str ( int * sp , int count , const char * sep ) \n { \n int i ; \n char * ap , * ap0 ; \n if ( ! sep ) sep = \" \" ; \n ap = av_malloc ( ( 5 + strlen ( sep ) ) * count ) ; \n if ( ! ap ) \n return NULL ; \n ap0 = ap ; \n ap [ 0 ] = ' \\0 ' ; \n for ( i = 0 ; i < count ; i ++ ) { \n int l = snprintf ( ap , 5 + strlen ( sep ) , \" \" , sp [ i ] , sep ) ; \n ap += l ; \n } \n ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = ' \\0 ' ; \n return ap0 ; \n }", "idx": 18170}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8torgb16 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = ( ( uint16_t * ) palette ) [ src [ i ] ] ; \n }", "idx": 18174}
{"project": "FFmpeg", "commit_id": "0953736b7e97f6e121a0587a95434bf1857a27da", "target": 1, "func": "static int headroom ( int * la ) \n { \n int l ; \n if ( * la == 0 ) { \n return 31 ; \n } \n l = 30 - av_log2 ( FFABS ( * la ) ) ; \n * la <<= l ; \n return l ; \n }", "idx": 18177}
{"project": "FFmpeg", "commit_id": "0726b2d1ea4343698ff603cc32b824f5bce952c5", "target": 1, "func": "static int jpeg_read_close ( AVFormatContext * s1 ) \n { \n JpegContext * s = s1 -> priv_data ; \n av_free ( s ) ; \n return 0 ; \n }", "idx": 18182}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yuv422ptoyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n unsigned int width , unsigned int height , \n int lumStride , int chromStride , int dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 1 ) ; \n }", "idx": 18188}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) \n { \n int y ; \n unsigned char P [ 2 ] ; \n CHECK_STREAM_PTR ( 4 ) ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n P [ 0 ] = * s -> stream_ptr ++ ; \n P [ 1 ] = * s -> stream_ptr ++ ; \n } \n memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ; \n memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ; \n s -> pixel_ptr += s -> stride ; \n } \n return 0 ; \n }", "idx": 18201}
{"project": "FFmpeg", "commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "target": 1, "func": "static int process_work_frame ( AVFilterContext * ctx ) \n { \n FrameRateContext * s = ctx -> priv ; \n int64_t work_pts ; \n int interpolate ; \n int ret ; \n if ( ! s -> f1 ) \n return 0 ; \n if ( ! s -> f0 && ! s -> flush ) \n return 0 ; \n work_pts = s -> start_pts + av_rescale_q ( s -> n , av_inv_q ( s -> dest_frame_rate ) , s -> dest_time_base ) ; \n if ( work_pts >= s -> pts1 && ! s -> flush ) \n return 0 ; \n if ( ! s -> f0 ) { \n s -> work = av_frame_clone ( s -> f1 ) ; \n } else { \n if ( work_pts >= s -> pts1 + s -> delta && s -> flush ) \n return 0 ; \n interpolate = av_rescale ( work_pts - s -> pts0 , s -> max , s -> delta ) ; \n ff_dlog ( ctx , \" \\n \" , interpolate , s -> max ) ; \n if ( interpolate > s -> interp_end ) { \n s -> work = av_frame_clone ( s -> f1 ) ; \n } else if ( interpolate < s -> interp_start ) { \n s -> work = av_frame_clone ( s -> f0 ) ; \n } else { \n ret = blend_frames ( ctx , interpolate ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ret == 0 ) \n s -> work = av_frame_clone ( interpolate > ( s -> max >> 1 ) ? s -> f1 : s -> f0 ) ; \n } \n } \n if ( ! s -> work ) \n return AVERROR ( ENOMEM ) ; \n s -> work -> pts = work_pts ; \n s -> n ++ ; \n return 1 ; \n }", "idx": 18206}
{"project": "FFmpeg", "commit_id": "57ec555e8ef3c5ef1d77d48dc7cc868e56ddadc9", "target": 1, "func": "static void png_filter_row ( DSPContext * dsp , uint8_t * dst , int filter_type , \n uint8_t * src , uint8_t * top , int size , int bpp ) \n { \n int i ; \n switch ( filter_type ) { \n case PNG_FILTER_VALUE_NONE : \n memcpy ( dst , src , size ) ; \n break ; \n case PNG_FILTER_VALUE_SUB : \n dsp -> diff_bytes ( dst , src , src - bpp , size ) ; \n memcpy ( dst , src , bpp ) ; \n break ; \n case PNG_FILTER_VALUE_UP : \n dsp -> diff_bytes ( dst , src , top , size ) ; \n break ; \n case PNG_FILTER_VALUE_AVG : \n for ( i = 0 ; i < bpp ; i ++ ) \n dst [ i ] = src [ i ] - ( top [ i ] >> 1 ) ; \n for ( ; i < size ; i ++ ) \n dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 ) ; \n break ; \n case PNG_FILTER_VALUE_PAETH : \n for ( i = 0 ; i < bpp ; i ++ ) \n dst [ i ] = src [ i ] - top [ i ] ; \n sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp ) ; \n break ; \n } \n }", "idx": 18216}
{"project": "FFmpeg", "commit_id": "b9c8388710a06544812739eedc0a40d3451491dc", "target": 1, "func": "static void * ff_realloc_static ( void * ptr , unsigned int size ) \n { \n int i ; \n if ( ! ptr ) \n return av_mallocz_static ( size ) ; \n for ( i = 0 ; i < last_static ; i ++ ) { \n if ( array_static [ i ] == ptr ) { \n array_static [ i ] = av_realloc ( array_static [ i ] , size ) ; \n return array_static [ i ] ; \n } \n } \n return NULL ; \n }", "idx": 18287}
{"project": "FFmpeg", "commit_id": "8acab7ae5bbcb589c556425453ac3d851d35021f", "target": 1, "func": "static void oledate_to_iso8601 ( char * buf , int buf_size , int64_t value ) \n { \n time_t t = 631112400LL + 86400 * av_int2dbl ( value ) ; \n strftime ( buf , buf_size , \" \" , gmtime ( & t ) ) ; \n }", "idx": 18295}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * postproc_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 18305}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_and_aver_dst_16x16_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride ) ; \n }", "idx": 18307}
{"project": "FFmpeg", "commit_id": "0699dbb8478886826dedb1c33a0b74142a1cd863", "target": 0, "func": "int avfilter_open ( AVFilterContext * * filter_ctx , AVFilter * filter , const char * inst_name ) \n { \n AVFilterContext * ret ; \n * filter_ctx = NULL ; \n if ( ! filter ) \n return AVERROR ( EINVAL ) ; \n ret = av_mallocz ( sizeof ( AVFilterContext ) ) ; \n ret -> av_class = & avfilter_class ; \n ret -> filter = filter ; \n ret -> name = inst_name ? av_strdup ( inst_name ) : NULL ; \n if ( filter -> priv_size ) \n ret -> priv = av_mallocz ( filter -> priv_size ) ; \n ret -> input_count = pad_count ( filter -> inputs ) ; \n if ( ret -> input_count ) { \n ret -> input_pads = av_malloc ( sizeof ( AVFilterPad ) * ret -> input_count ) ; \n memcpy ( ret -> input_pads , filter -> inputs , sizeof ( AVFilterPad ) * ret -> input_count ) ; \n ret -> inputs = av_mallocz ( sizeof ( AVFilterLink * ) * ret -> input_count ) ; \n } \n ret -> output_count = pad_count ( filter -> outputs ) ; \n if ( ret -> output_count ) { \n ret -> output_pads = av_malloc ( sizeof ( AVFilterPad ) * ret -> output_count ) ; \n memcpy ( ret -> output_pads , filter -> outputs , sizeof ( AVFilterPad ) * ret -> output_count ) ; \n ret -> outputs = av_mallocz ( sizeof ( AVFilterLink * ) * ret -> output_count ) ; \n } \n * filter_ctx = ret ; \n return 0 ; \n }", "idx": 18308}
{"project": "FFmpeg", "commit_id": "e45226adc46e513a1bb39ec2b09fb7c77515ab14", "target": 1, "func": "static int make_cdt15_entry ( int p1 , int p2 , int16_t * cdt ) \n { \n int r , b , lo ; \n b = cdt [ p2 ] ; \n r = cdt [ p1 ] * 1024 ; \n lo = b + r ; \n return ( lo + ( lo * ( 1 << 16 ) ) ) * 2 ; \n }", "idx": 18313}
{"project": "FFmpeg", "commit_id": "e9a32230c3e05deff257cbfa1e5e3d86dc0e94e6", "target": 1, "func": "static int ogg_build_flac_headers ( AVCodecContext * avctx , \n OGGStreamContext * oggstream , int bitexact ) \n { \n const char * vendor = bitexact ? \" \" : LIBAVFORMAT_IDENT ; \n enum FLACExtradataFormat format ; \n uint8_t * streaminfo ; \n uint8_t * p ; \n if ( ! ff_flac_is_extradata_valid ( avctx , & format , & streaminfo ) ) \n return -1 ; \n oggstream -> header_len [ 0 ] = 51 ; \n oggstream -> header [ 0 ] = av_mallocz ( 51 ) ; \n p = oggstream -> header [ 0 ] ; \n bytestream_put_byte ( & p , 0x7F ) ; \n bytestream_put_buffer ( & p , \" \" , 4 ) ; \n bytestream_put_byte ( & p , 1 ) ; \n bytestream_put_byte ( & p , 0 ) ; \n bytestream_put_be16 ( & p , 1 ) ; \n bytestream_put_buffer ( & p , \" \" , 4 ) ; \n bytestream_put_byte ( & p , 0x00 ) ; \n bytestream_put_be24 ( & p , 34 ) ; \n bytestream_put_buffer ( & p , streaminfo , FLAC_STREAMINFO_SIZE ) ; \n oggstream -> header_len [ 1 ] = 1 + 3 + 4 + strlen ( vendor ) + 4 ; \n oggstream -> header [ 1 ] = av_mallocz ( oggstream -> header_len [ 1 ] ) ; \n p = oggstream -> header [ 1 ] ; \n bytestream_put_byte ( & p , 0x84 ) ; \n bytestream_put_be24 ( & p , oggstream -> header_len [ 1 ] - 4 ) ; \n bytestream_put_le32 ( & p , strlen ( vendor ) ) ; \n bytestream_put_buffer ( & p , vendor , strlen ( vendor ) ) ; \n bytestream_put_le32 ( & p , 0 ) ; \n return 0 ; \n }", "idx": 18314}
{"project": "FFmpeg", "commit_id": "e46ab997506e8aa84344c29553ebacca7993904c", "target": 1, "func": "static int ogg_restore ( AVFormatContext * s ) \n { \n struct ogg * ogg = s -> priv_data ; \n AVIOContext * bc = s -> pb ; \n struct ogg_state * ost = ogg -> state ; \n int i , err ; \n if ( ! ost ) \n return 0 ; \n ogg -> state = ost -> next ; \n for ( i = 0 ; i < ogg -> nstreams ; i ++ ) \n av_freep ( & ogg -> streams [ i ] . buf ) ; \n avio_seek ( bc , ost -> pos , SEEK_SET ) ; \n ogg -> page_pos = -1 ; \n ogg -> curidx = ost -> curidx ; \n ogg -> nstreams = ost -> nstreams ; \n if ( ( err = av_reallocp_array ( & ogg -> streams , ogg -> nstreams , \n sizeof ( * ogg -> streams ) ) ) < 0 ) { \n ogg -> nstreams = 0 ; \n return err ; \n } else \n memcpy ( ogg -> streams , ost -> streams , \n ost -> nstreams * sizeof ( * ogg -> streams ) ) ; \n av_free ( ost ) ; \n return 0 ; \n }", "idx": 18318}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffio_open2_wrapper ( struct AVFormatContext * s , AVIOContext * * pb , const char * url , int flags , \n const AVIOInterruptCB * int_cb , AVDictionary * * options ) \n { \n return avio_open2 ( pb , url , flags , int_cb , options ) ; \n }", "idx": 18322}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void put_pixels_clamped2_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n pixels [ 0 ] = cm [ block [ 0 ] ] ; \n pixels [ 1 ] = cm [ block [ 1 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 18330}
{"project": "FFmpeg", "commit_id": "c55427f8c8348af12b77b9601479769d701d8c99", "target": 1, "func": "int oggvorbis_init_encoder ( vorbis_info * vi , AVCodecContext * avccontext ) { \n if ( avccontext -> coded_frame -> quality ) \n return vorbis_encode_init_vbr ( vi , avccontext -> channels , \n avccontext -> sample_rate , ( float ) avccontext -> coded_frame -> quality / 1000 ) ; \n return vorbis_encode_init ( vi , avccontext -> channels , \n avccontext -> sample_rate , -1 , avccontext -> bit_rate , -1 ) ; \n }", "idx": 18334}
{"project": "FFmpeg", "commit_id": "bfa0f96586fe2c257cfa574ffb991da493a54da1", "target": 1, "func": "static av_cold int vp8_decode_free ( AVCodecContext * avctx ) \n { \n vp8_decode_flush_impl ( avctx , 0 , 1 ) ; \n release_queued_segmaps ( avctx -> priv_data , 1 ) ; \n return 0 ; \n }", "idx": 18336}
{"project": "FFmpeg", "commit_id": "0528226a05cc08b74197547fba0b1939bf68990d", "target": 0, "func": "static int a64_write_header ( AVFormatContext * s ) \n { \n AVCodecContext * avctx = s -> streams [ 0 ] -> codec ; \n uint8_t header [ 5 ] = { \n 0x00 , \n 0x40 , \n 0x00 , \n 0x00 , \n 0x00 \n } ; \n if ( avctx -> extradata_size < 4 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n switch ( avctx -> codec -> id ) { \n case AV_CODEC_ID_A64_MULTI : \n header [ 2 ] = 0x00 ; \n header [ 3 ] = AV_RB32 ( avctx -> extradata + 0 ) ; \n header [ 4 ] = 2 ; \n break ; \n case AV_CODEC_ID_A64_MULTI5 : \n header [ 2 ] = 0x01 ; \n header [ 3 ] = AV_RB32 ( avctx -> extradata + 0 ) ; \n header [ 4 ] = 3 ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n avio_write ( s -> pb , header , 2 ) ; \n return 0 ; \n }", "idx": 18337}
{"project": "FFmpeg", "commit_id": "476d301316aa5436c1d26cfc4858f36875637853", "target": 0, "func": "int ff_cbs_write_packet ( CodedBitstreamContext * ctx , \n AVPacket * pkt , \n CodedBitstreamFragment * frag ) \n { \n int err ; \n err = ff_cbs_write_fragment_data ( ctx , frag ) ; \n if ( err < 0 ) \n return err ; \n av_new_packet ( pkt , frag -> data_size ) ; \n if ( err < 0 ) \n return err ; \n memcpy ( pkt -> data , frag -> data , frag -> data_size ) ; \n pkt -> size = frag -> data_size ; \n return 0 ; \n }", "idx": 18365}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int sunrast_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 18367}
{"project": "FFmpeg", "commit_id": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8", "target": 0, "func": "int ff_v4l2_context_dequeue_frame ( V4L2Context * ctx , AVFrame * frame ) \n { \n V4L2Buffer * avbuf = NULL ; \n avbuf = v4l2_dequeue_v4l2buf ( ctx , ctx_to_m2mctx ( ctx ) -> draining ? 200 : -1 ) ; \n if ( ! avbuf ) { \n if ( ctx -> done ) \n return AVERROR_EOF ; \n return AVERROR ( EAGAIN ) ; \n } \n return ff_v4l2_buffer_buf_to_avframe ( frame , avbuf ) ; \n }", "idx": 18370}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFContext * mxf = arg ; \n int item_num = avio_rb32 ( pb ) ; \n int item_len = avio_rb32 ( pb ) ; \n if ( item_len != 18 ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( item_num > UINT_MAX / item_len ) \n return -1 ; \n mxf -> local_tags_count = item_num ; \n mxf -> local_tags = av_malloc ( item_num * item_len ) ; \n if ( ! mxf -> local_tags ) \n return -1 ; \n avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; \n return 0 ; \n }", "idx": 18376}
{"project": "FFmpeg", "commit_id": "60f50374f1955442dc987abc4a6c61c2109620c2", "target": 0, "func": "static int rpza_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n RpzaContext * s = avctx -> priv_data ; \n int ret ; \n bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n rpza_decode_stream ( s ) ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n * got_frame = 1 ; \n return avpkt -> size ; \n }", "idx": 18383}
{"project": "FFmpeg", "commit_id": "7434ba6d53b9a8858a6f965d9a4e60b5eb1316fe", "target": 1, "func": "static void http_log ( char * fmt , ... ) \n { \n va_list ap ; \n va_start ( ap , fmt ) ; \n if ( logfile ) \n vfprintf ( logfile , fmt , ap ) ; \n va_end ( ap ) ; \n }", "idx": 18387}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static void skip_block ( uint8_t * current , uint8_t * previous , int pitch , int x , int y ) { \n uint8_t * src ; \n uint8_t * dst ; \n int i ; \n src = & previous [ x + y * pitch ] ; \n dst = current ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n memcpy ( dst , src , 16 ) ; \n src += pitch ; \n dst += pitch ; \n } \n }", "idx": 18389}
{"project": "FFmpeg", "commit_id": "40393ac568db345b0388e1c99fc89f41a5b08037", "target": 1, "func": "static int mov_write_hdlr_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n const char * hdlr , * descr = NULL , * hdlr_type = NULL ; \n int64_t pos = avio_tell ( pb ) ; \n if ( ! track ) { \n hdlr = ( track -> mode == MODE_MOV ) ? \" \" : \" \\0 \\0 \\0 \\0 \" ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n hdlr_type = \" \" ; \n descr = \" \" ; \n } else if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n hdlr_type = \" \" ; \n descr = \" \" ; \n } else if ( track -> enc -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { \n if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) hdlr_type = \" \" ; \n else hdlr_type = \" \" ; \n descr = \" \" ; \n } else if ( track -> enc -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n hdlr_type = \" \" ; \n descr = \" \" ; \n } \n } \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_write ( pb , hdlr , 4 ) ; \n ffio_wfourcc ( pb , hdlr_type ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb32 ( pb , 0 ) ; \n if ( ! track || track -> mode == MODE_MOV ) \n avio_w8 ( pb , strlen ( descr ) ) ; \n avio_write ( pb , descr , strlen ( descr ) ) ; \n if ( track && track -> mode != MODE_MOV ) \n avio_w8 ( pb , 0 ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 18394}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void wmv2_idct_col ( short * b ) \n { \n int s1 , s2 ; \n int a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ; \n a1 = ( W1 * b [ 8 * 1 ] + W7 * b [ 8 * 7 ] + 4 ) >> 3 ; \n a7 = ( W7 * b [ 8 * 1 ] - W1 * b [ 8 * 7 ] + 4 ) >> 3 ; \n a5 = ( W5 * b [ 8 * 5 ] + W3 * b [ 8 * 3 ] + 4 ) >> 3 ; \n a3 = ( W3 * b [ 8 * 5 ] - W5 * b [ 8 * 3 ] + 4 ) >> 3 ; \n a2 = ( W2 * b [ 8 * 2 ] + W6 * b [ 8 * 6 ] + 4 ) >> 3 ; \n a6 = ( W6 * b [ 8 * 2 ] - W2 * b [ 8 * 6 ] + 4 ) >> 3 ; \n a0 = ( W0 * b [ 8 * 0 ] + W0 * b [ 8 * 4 ] ) >> 3 ; \n a4 = ( W0 * b [ 8 * 0 ] - W0 * b [ 8 * 4 ] ) >> 3 ; \n s1 = ( 181 * ( a1 - a5 + a7 - a3 ) + 128 ) >> 8 ; \n s2 = ( 181 * ( a1 - a5 - a7 + a3 ) + 128 ) >> 8 ; \n b [ 8 * 0 ] = ( a0 + a2 + a1 + a5 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 1 ] = ( a4 + a6 + s1 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 2 ] = ( a4 - a6 + s2 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 3 ] = ( a0 - a2 + a7 + a3 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 4 ] = ( a0 - a2 - a7 - a3 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 5 ] = ( a4 - a6 - s2 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 6 ] = ( a4 + a6 - s1 + ( 1 << 13 ) ) >> 14 ; \n b [ 8 * 7 ] = ( a0 + a2 - a1 - a5 + ( 1 << 13 ) ) >> 14 ; \n }", "idx": 18399}
{"project": "FFmpeg", "commit_id": "ba728c1a2527a02f239fdfaf118a618b758721db", "target": 1, "func": "static int init_resampler ( AVCodecContext * input_codec_context , \n AVCodecContext * output_codec_context , \n SwrContext * * resample_context ) \n { \n if ( input_codec_context -> sample_fmt != output_codec_context -> sample_fmt || \n input_codec_context -> channels != output_codec_context -> channels ) { \n int error ; \n * resample_context = swr_alloc_set_opts ( NULL , \n av_get_default_channel_layout ( output_codec_context -> channels ) , \n output_codec_context -> sample_fmt , \n output_codec_context -> sample_rate , \n av_get_default_channel_layout ( input_codec_context -> channels ) , \n input_codec_context -> sample_fmt , \n input_codec_context -> sample_rate , \n 0 , NULL ) ; \n if ( ! * resample_context ) { \n fprintf ( stderr , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n av_assert0 ( output_codec_context -> sample_rate == input_codec_context -> sample_rate ) ; \n if ( ( error = swr_init ( * resample_context ) ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n swr_free ( resample_context ) ; \n return error ; \n } \n } \n return 0 ; \n }", "idx": 18401}
{"project": "FFmpeg", "commit_id": "12936a4585bc293c0f88327d6840f49e8e744b62", "target": 1, "func": "static int decode_tsw1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) \n { \n const uint8_t * frame_start = frame ; \n const uint8_t * frame_end = frame + width * height ; \n int mask = 0x10000 , bitbuf = 0 ; \n int v , count , segments ; \n unsigned offset ; \n segments = bytestream2_get_le32 ( gb ) ; \n offset = bytestream2_get_le32 ( gb ) ; \n if ( segments == 0 && offset == frame_end - frame ) \n return 0 ; \n if ( frame_end - frame <= offset ) \n return AVERROR_INVALIDDATA ; \n frame += offset ; \n while ( segments -- ) { \n if ( bytestream2_get_bytes_left ( gb ) < 2 ) \n return AVERROR_INVALIDDATA ; \n if ( mask == 0x10000 ) { \n bitbuf = bytestream2_get_le16u ( gb ) ; \n mask = 1 ; \n } \n if ( frame_end - frame < 2 ) \n return AVERROR_INVALIDDATA ; \n if ( bitbuf & mask ) { \n v = bytestream2_get_le16 ( gb ) ; \n offset = ( v & 0x1FFF ) << 1 ; \n count = ( ( v >> 13 ) + 2 ) << 1 ; \n if ( frame - frame_start < offset || frame_end - frame < count ) \n return AVERROR_INVALIDDATA ; \n av_memcpy_backptr ( frame , offset , count ) ; \n frame += count ; \n } else { \n * frame ++ = bytestream2_get_byte ( gb ) ; \n * frame ++ = bytestream2_get_byte ( gb ) ; \n } \n mask <<= 1 ; \n } \n return 0 ; \n }", "idx": 18406}
{"project": "FFmpeg", "commit_id": "ce87711df563a9d2d0537a062b86bb91b15ea1a0", "target": 0, "func": "static int exif_add_metadata ( AVCodecContext * avctx , int count , int type , \n const char * name , const char * sep , \n GetByteContext * gb , int le , \n AVDictionary * * metadata ) \n { \n switch ( type ) { \n case 0 : \n av_log ( avctx , AV_LOG_WARNING , \n \" \\n \" , \n name , count ) ; \n return 0 ; \n case TIFF_DOUBLE : return ff_tadd_doubles_metadata ( count , name , sep , gb , le , metadata ) ; \n case TIFF_SSHORT : return ff_tadd_shorts_metadata ( count , name , sep , gb , le , 1 , metadata ) ; \n case TIFF_SHORT : return ff_tadd_shorts_metadata ( count , name , sep , gb , le , 0 , metadata ) ; \n case TIFF_SBYTE : return ff_tadd_bytes_metadata ( count , name , sep , gb , le , 1 , metadata ) ; \n case TIFF_BYTE : \n case TIFF_UNDEFINED : return ff_tadd_bytes_metadata ( count , name , sep , gb , le , 0 , metadata ) ; \n case TIFF_STRING : return ff_tadd_string_metadata ( count , name , gb , le , metadata ) ; \n case TIFF_SRATIONAL : \n case TIFF_RATIONAL : return ff_tadd_rational_metadata ( count , name , sep , gb , le , metadata ) ; \n case TIFF_SLONG : \n case TIFF_LONG : return ff_tadd_long_metadata ( count , name , sep , gb , le , metadata ) ; \n default : \n avpriv_request_sample ( avctx , \" \" , type ) ; \n return 0 ; \n } ; \n }", "idx": 18418}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int mtv_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 3 ) \n return 0 ; \n if ( * ( p -> buf ) != ' ' || * ( p -> buf + 1 ) != ' ' || * ( p -> buf + 2 ) != ' ' ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 18420}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int vmd_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 2 ) \n return 0 ; \n if ( AV_RL16 ( & p -> buf [ 0 ] ) != VMD_HEADER_SIZE - 2 ) \n return 0 ; \n return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 18421}
{"project": "FFmpeg", "commit_id": "6d6eabd399eb20b69d10234ef746f2d3d4c72dcb", "target": 1, "func": "static inline int mjpeg_decode_dc ( MJpegDecodeContext * s , int dc_index ) \n { \n int code ; \n code = get_vlc2 ( & s -> gb , s -> vlcs [ 0 ] [ dc_index ] . table , 9 , 2 ) ; \n if ( code < 0 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \n \" \\n \" , \n 0 , dc_index , & s -> vlcs [ 0 ] [ dc_index ] ) ; \n return 0xffff ; \n } \n if ( code ) \n return get_xbits ( & s -> gb , code ) ; \n else \n return 0 ; \n }", "idx": 18423}
{"project": "FFmpeg", "commit_id": "db42d93a61be26873be6115c57f5921b4dfdec14", "target": 1, "func": "static int mov_read_mfra ( MOVContext * c , AVIOContext * f ) \n { \n int64_t stream_size = avio_size ( f ) ; \n int64_t original_pos = avio_tell ( f ) ; \n int64_t seek_ret ; \n int32_t mfra_size ; \n int ret = -1 ; \n if ( ( seek_ret = avio_seek ( f , stream_size - 4 , SEEK_SET ) ) < 0 ) { \n ret = seek_ret ; \n goto fail ; \n } \n mfra_size = avio_rb32 ( f ) ; \n if ( mfra_size < 0 || mfra_size > stream_size ) { \n av_log ( c -> fc , AV_LOG_DEBUG , \" \\n \" ) ; \n goto fail ; \n } \n if ( ( seek_ret = avio_seek ( f , - mfra_size , SEEK_CUR ) ) < 0 ) { \n ret = seek_ret ; \n goto fail ; \n } \n if ( avio_rb32 ( f ) != mfra_size ) { \n av_log ( c -> fc , AV_LOG_DEBUG , \" \\n \" ) ; \n goto fail ; \n } \n if ( avio_rb32 ( f ) != MKBETAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n av_log ( c -> fc , AV_LOG_DEBUG , \" \\n \" ) ; \n goto fail ; \n } \n ret = 0 ; \n av_log ( c -> fc , AV_LOG_VERBOSE , \" \\n \" ) ; \n while ( ! read_tfra ( c , f ) ) { \n } \n fail : \n seek_ret = avio_seek ( f , original_pos , SEEK_SET ) ; \n if ( seek_ret < 0 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \n \" \\n \" ) ; \n ret = seek_ret ; \n } \n return ret ; \n }", "idx": 18429}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void idct4row ( DCTELEM * row ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n a0 = row [ 0 ] ; \n a1 = row [ 1 ] ; \n a2 = row [ 2 ] ; \n a3 = row [ 3 ] ; \n c0 = ( a0 + a2 ) * R3 + ( 1 << ( R_SHIFT - 1 ) ) ; \n c2 = ( a0 - a2 ) * R3 + ( 1 << ( R_SHIFT - 1 ) ) ; \n c1 = a1 * R1 + a3 * R2 ; \n c3 = a1 * R2 - a3 * R1 ; \n row [ 0 ] = ( c0 + c1 ) >> R_SHIFT ; \n row [ 1 ] = ( c2 + c3 ) >> R_SHIFT ; \n row [ 2 ] = ( c2 - c3 ) >> R_SHIFT ; \n row [ 3 ] = ( c0 - c1 ) >> R_SHIFT ; \n }", "idx": 18446}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb24tobgr32 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n for ( i = 0 ; 3 * i < src_size ; i ++ ) \n { \n dst [ 4 * i + 0 ] = src [ 3 * i + 2 ] ; \n dst [ 4 * i + 1 ] = src [ 3 * i + 1 ] ; \n dst [ 4 * i + 2 ] = src [ 3 * i + 0 ] ; \n dst [ 4 * i + 3 ] = 0 ; \n } \n }", "idx": 18453}
{"project": "FFmpeg", "commit_id": "18ce63a60e1bffc35b4df5d8a4f9a1ff1a96cb9a", "target": 1, "func": "libAVFilter_QueryVendorInfo ( libAVFilter * this , wchar_t * * info )  \n { \n dshowdebug ( \" \\n \" , this ) ; \n if ( ! info ) \n return E_POINTER ; \n * info = wcsdup ( L\" \" ) ; \n return S_OK ; \n }", "idx": 18455}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int compute_mb_distortion ( CinepakEncContext * s , AVPicture * a , AVPicture * b ) \n { \n int x , y , p , d , ret = 0 ; \n for ( y = 0 ; y < MB_SIZE ; y ++ ) { \n for ( x = 0 ; x < MB_SIZE ; x ++ ) { \n d = a -> data [ 0 ] [ x + y * a -> linesize [ 0 ] ] - b -> data [ 0 ] [ x + y * b -> linesize [ 0 ] ] ; \n ret += d * d ; \n } \n } \n if ( s -> pix_fmt == AV_PIX_FMT_YUV420P ) { \n for ( p = 1 ; p <= 2 ; p ++ ) { \n for ( y = 0 ; y < MB_SIZE / 2 ; y ++ ) { \n for ( x = 0 ; x < MB_SIZE / 2 ; x ++ ) { \n d = a -> data [ p ] [ x + y * a -> linesize [ p ] ] - b -> data [ p ] [ x + y * b -> linesize [ p ] ] ; \n ret += d * d ; \n } \n } \n } \n } \n return ret ; \n }", "idx": 18456}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static int vp8_decode_mb_row_sliced ( AVCodecContext * avctx , void * tdata , \n int jobnr , int threadnr ) \n { \n VP8Context * s = avctx -> priv_data ; \n VP8ThreadData * td = & s -> thread_data [ jobnr ] ; \n VP8ThreadData * next_td = NULL , * prev_td = NULL ; \n VP8Frame * curframe = s -> curframe ; \n int mb_y , num_jobs = s -> num_jobs ; \n td -> thread_nr = threadnr ; \n for ( mb_y = jobnr ; mb_y < s -> mb_height ; mb_y += num_jobs ) { \n if ( mb_y >= s -> mb_height ) \n break ; \n td -> thread_mb_pos = mb_y << 16 ; \n vp8_decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr ) ; \n if ( s -> deblock_filter ) \n vp8_filter_mb_row ( avctx , tdata , jobnr , threadnr ) ; \n update_pos ( td , mb_y , INT_MAX & 0xFFFF ) ; \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n if ( avctx -> active_thread_type == FF_THREAD_FRAME ) \n ff_thread_report_progress ( & curframe -> tf , mb_y , 0 ) ; \n } \n return 0 ; \n }", "idx": 18459}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb24tobgr32 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n for ( i = 0 ; 3 * i < src_size ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 4 * i + 0 ] = 0 ; \n dst [ 4 * i + 1 ] = src [ 3 * i + 0 ] ; \n dst [ 4 * i + 2 ] = src [ 3 * i + 1 ] ; \n dst [ 4 * i + 3 ] = src [ 3 * i + 2 ] ; \n #else \n dst [ 4 * i + 0 ] = src [ 3 * i + 2 ] ; \n dst [ 4 * i + 1 ] = src [ 3 * i + 1 ] ; \n dst [ 4 * i + 2 ] = src [ 3 * i + 0 ] ; \n dst [ 4 * i + 3 ] = 0 ; \n #endif \n } \n }", "idx": 18460}
{"project": "FFmpeg", "commit_id": "fc9b22dd2e5de851a89245b5357e710b93587278", "target": 0, "func": "static void build_udp_url ( char * buf , int buf_size , \n const char * hostname , int port , \n int local_port , int ttl ) \n { \n snprintf ( buf , buf_size , \" \n if ( local_port >= 0 ) \n url_add_option ( buf , buf_size , \" \" , local_port )  ; \n if ( ttl >= 0 ) \n url_add_option ( buf , buf_size , \" \" , ttl ) ; \n }", "idx": 18466}
{"project": "FFmpeg", "commit_id": "72237ef6e933527be7855cb266a2a4df4dcb8096", "target": 0, "func": "static int sub2video_prepare ( InputStream * ist ) \n { \n AVFormatContext * avf = input_files [ ist -> file_index ] -> ctx ; \n int i , w , h ; \n w = ist -> dec_ctx -> width ; \n h = ist -> dec_ctx -> height ; \n if ( ! ( w && h ) ) { \n for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { \n if ( avf -> streams [ i ] -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n w = FFMAX ( w , avf -> streams [ i ] -> codec -> width ) ; \n h = FFMAX ( h , avf -> streams [ i ] -> codec -> height ) ; \n } \n } \n if ( ! ( w && h ) ) { \n w = FFMAX ( w , 720 ) ; \n h = FFMAX ( h , 576 ) ; \n } \n av_log ( avf , AV_LOG_INFO , \" \\n \" , w , h ) ; \n } \n ist -> sub2video . w = ist -> dec_ctx -> width = ist -> resample_width = w ; \n ist -> sub2video . h = ist -> dec_ctx -> height = ist -> resample_height = h ; \n ist -> resample_pix_fmt = ist -> dec_ctx -> pix_fmt = AV_PIX_FMT_RGB32 ; \n ist -> sub2video . frame = av_frame_alloc ( ) ; \n if ( ! ist -> sub2video . frame ) \n return AVERROR ( ENOMEM ) ; \n ist -> sub2video . last_pts = INT64_MIN ; \n return 0 ; \n }", "idx": 18468}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "func": "static int compat_read ( AVFilterContext * ctx , AVFilterBufferRef * * pbuf , int nb_samples ) \n { \n AVFilterBufferRef * buf ; \n AVFrame * frame ; \n int ret ; \n if ( ! pbuf ) \n return ff_poll_frame ( ctx -> inputs [ 0 ] ) ; \n frame = av_frame_alloc ( ) ; \n if ( ! frame ) \n return AVERROR ( ENOMEM ) ; \n if ( ! nb_samples ) \n ret = av_buffersink_get_frame ( ctx , frame ) ; \n else \n ret = av_buffersink_get_samples ( ctx , frame , nb_samples ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( ctx -> inputs [ 0 ] -> type == AVMEDIA_TYPE_VIDEO ) { \n buf = avfilter_get_video_buffer_ref_from_arrays ( frame -> data , frame -> linesize , \n AV_PERM_READ , \n frame -> width , frame -> height , \n frame -> format ) ; \n } else { \n buf = avfilter_get_audio_buffer_ref_from_arrays ( frame -> extended_data , \n frame -> linesize [ 0 ] , AV_PERM_READ , \n frame -> nb_samples , \n frame -> format , \n frame -> channel_layout ) ; \n } \n if ( ! buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n avfilter_copy_frame_props ( buf , frame ) ; \n buf -> buf -> priv = frame ; \n buf -> buf -> free = compat_free_buffer ; \n * pbuf = buf ; \n return 0 ; \n fail : \n av_frame_free ( & frame ) ; \n return ret ; \n }", "idx": 18470}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static int mlib_YUV2ARGB420_32 ( SwsContext * c , uint8_t * src [ ] , int srcStride [ ] , int srcSliceY , \n int srcSliceH , uint8_t * dst [ ] , int dstStride [ ] ) { \n if ( c -> srcFormat == PIX_FMT_YUV422P ) { \n srcStride [ 1 ] *= 2 ; \n srcStride [ 2 ] *= 2 ; \n } \n assert ( srcStride [ 1 ] == srcStride [ 2 ] ) ; \n mlib_VideoColorYUV2ARGB420 ( dst [ 0 ] + srcSliceY * dstStride [ 0 ] , src [ 0 ] , src [ 1 ] , src [ 2 ] , c -> dstW , \n srcSliceH , dstStride [ 0 ] , srcStride [ 0 ] , srcStride [ 1 ] ) ; \n return srcSliceH ; \n }", "idx": 18480}
{"project": "FFmpeg", "commit_id": "3d7817048cb387de87600f2152075f78b37b60a6", "target": 1, "func": "static CodeBook unpack_codebook ( GetBitContext * gb , unsigned depth , \n unsigned size ) \n { \n unsigned i , j ; \n CodeBook cb = { 0 } ; \n if ( ! can_safely_read ( gb , size * 34 ) ) \n return cb ; \n if ( size >= INT_MAX / sizeof ( MacroBlock ) ) \n return cb ; \n cb . blocks = av_malloc ( size ? size * sizeof ( MacroBlock ) : 1 ) ; \n if ( ! cb . blocks ) \n return cb ; \n cb . depth = depth ; \n cb . size = size ; \n for ( i = 0 ; i < size ; i ++ ) { \n unsigned mask_bits = get_bits ( gb , 4 ) ; \n unsigned color0 = get_bits ( gb , 15 ) ; \n unsigned color1 = get_bits ( gb , 15 ) ; \n for ( j = 0 ; j < 4 ; j ++ ) { \n if ( mask_bits & ( 1 << j ) ) \n cb . blocks [ i ] . pixels [ j ] = color1 ; \n else \n cb . blocks [ i ] . pixels [ j ] = color0 ; \n } \n } \n return cb ; \n }", "idx": 18486}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static av_cold int pcx_init ( AVCodecContext * avctx ) { \n PCXContext * s = avctx -> priv_data ; \n avcodec_get_frame_defaults ( & s -> picture ) ; \n avctx -> coded_frame = & s -> picture ; \n return 0 ; \n }", "idx": 18492}
{"project": "FFmpeg", "commit_id": "77bc507f6f001b9f5fa75c664106261bd8f2c971", "target": 1, "func": "static void find_compressor ( char * compressor_name , int len , MOVTrack * track ) \n { \n AVDictionaryEntry * encoder ; \n int xdcam_res = ( track -> par -> width == 1280 && track -> par -> height == 720 ) \n || ( track -> par -> width == 1440 && track -> par -> height == 1080 ) \n || ( track -> par -> width == 1920 && track -> par -> height == 1080 ) ; \n if ( track -> mode == MODE_MOV && \n ( encoder = av_dict_get ( track -> st -> metadata , \" \" , NULL , 0 ) ) ) { \n av_strlcpy ( compressor_name , encoder -> value , 32 ) ; \n } else if ( track -> par -> codec_id == AV_CODEC_ID_MPEG2VIDEO && xdcam_res ) { \n int interlaced = track -> par -> field_order > AV_FIELD_PROGRESSIVE ; \n AVStream * st = track -> st ; \n int rate = av_q2d ( find_fps ( NULL , st ) ) ; \n av_strlcatf ( compressor_name , len , \" \" ) ; \n if ( track -> par -> format == AV_PIX_FMT_YUV422P ) { \n av_strlcatf ( compressor_name , len , \" \" ) ; \n } else if ( track -> par -> width == 1440 ) { \n av_strlcatf ( compressor_name , len , \" \" ) ; \n } else \n av_strlcatf ( compressor_name , len , \" \" ) ; \n av_strlcatf ( compressor_name , len , \" \" , track -> par -> height , interlaced ? ' ' : ' ' ) ; \n av_strlcatf ( compressor_name , len , \" \" , rate * ( interlaced + 1 ) ) ; \n } \n }", "idx": 18494}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "void ff_set_mpeg4_time ( MpegEncContext * s ) { \n if ( s -> pict_type == AV_PICTURE_TYPE_B ) { \n ff_mpeg4_init_direct_mv ( s ) ; \n } else { \n s -> last_time_base = s -> time_base ; \n s -> time_base = s -> time / s -> avctx -> time_base . den ; \n } \n }", "idx": 18496}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "static void alloc_picture ( void * opaque ) \n { \n VideoState * is = opaque ; \n VideoPicture * vp ; \n vp = & is -> pictq [ is -> pictq_windex ] ; \n if ( vp -> bmp ) \n SDL_FreeYUVOverlay ( vp -> bmp ) ; \n #if CONFIG_AVFILTER  \n  \n  if ( vp -> picref ) \n avfilter_unref_buffer ( vp -> picref ) ; \n vp -> picref = NULL ; \n vp -> width = is -> out_video_filter -> inputs [ 0 ] -> w ; \n vp -> height = is -> out_video_filter -> inputs [ 0 ] -> h ; \n vp -> pix_fmt = is -> out_video_filter -> inputs [ 0 ] -> format ; \n #else \n vp -> width = is -> video_st -> codec -> width ; \n vp -> height = is -> video_st -> codec -> height ; \n vp -> pix_fmt = is -> video_st -> codec -> pix_fmt ; \n #endif \n vp -> bmp = SDL_CreateYUVOverlay ( vp -> width , vp -> height , \n SDL_YV12_OVERLAY , \n screen ) ; \n if ( ! vp -> bmp || vp -> bmp -> pitches [ 0 ] < vp -> width ) { \n fprintf ( stderr , \" \\n \" \n \" \\\" \\\" \\n \" \n \" \\n \" , vp -> width , vp -> height ) ; \n do_exit ( is ) ; \n } \n SDL_LockMutex ( is -> pictq_mutex ) ; \n vp -> allocated = 1 ; \n SDL_CondSignal ( is -> pictq_cond ) ; \n SDL_UnlockMutex ( is -> pictq_mutex ) ; \n }", "idx": 18500}
{"project": "FFmpeg", "commit_id": "6c9c8b06b32013c58101f27991eae251bf4eb485", "target": 0, "func": "static void int_to_int16 ( int16_t * out , const int * inp ) \n { \n int i ; \n for ( i = 0 ; i < 30 ; i ++ ) \n * ( out ++ ) = * ( inp ++ ) ; \n }", "idx": 18502}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int decode_frame_adu ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n MPADecodeContext * s = avctx -> priv_data ; \n uint32_t header ; \n int len , ret ; \n len = buf_size ; \n if ( buf_size < HEADER_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( len > MPA_MAX_CODED_FRAME_SIZE ) \n len = MPA_MAX_CODED_FRAME_SIZE ; \n header = AV_RB32 ( buf ) | 0xffe00000 ; \n if ( ff_mpa_check_header ( header ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avpriv_mpegaudio_decode_header ( ( MPADecodeHeader * ) s , header ) ; \n avctx -> sample_rate = s -> sample_rate ; \n avctx -> channels = s -> nb_channels ; \n avctx -> channel_layout = s -> nb_channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO ; \n if ( ! avctx -> bit_rate ) \n avctx -> bit_rate = s -> bit_rate ; \n s -> frame_size = len ; \n s -> frame = data ; \n ret = mp_decode_frame ( s , NULL , buf , buf_size ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n * got_frame_ptr = 1 ; \n return buf_size ; \n }", "idx": 18504}
{"project": "FFmpeg", "commit_id": "44874b4f5ec2c605c70393573b9d85540ebc2d81", "target": 1, "func": "static inline void tm2_high_chroma ( int * data , int stride , int * last , int * CD , int * deltas ) \n { \n int i , j ; \n for ( j = 0 ; j < 2 ; j ++ ) { \n for ( i = 0 ; i < 2 ; i ++ ) { \n CD [ j ] += deltas [ i + j * 2 ] ; \n last [ i ] += CD [ j ] ; \n data [ i ] = last [ i ] ; \n } \n data += stride ; \n } \n }", "idx": 18509}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pcm_encode_close ( AVCodecContext * avctx ) \n { \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 18519}
{"project": "FFmpeg", "commit_id": "9be52d48d9137e05361dd1ffb6b1fb3677e1fb47", "target": 0, "func": "static void extract_exponents ( AC3EncodeContext * s ) \n { \n int blk , ch , i ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) { \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n AC3Block * block = & s -> blocks [ blk ] ; \n for ( i = 0 ; i < AC3_MAX_COEFS ; i ++ ) { \n int e ; \n int v = abs ( SCALE_COEF ( block -> mdct_coef [ ch ] [ i ] ) ) ; \n if ( v == 0 ) \n e = 24 ; \n else { \n e = 23 - av_log2 ( v ) + block -> exp_shift [ ch ] ; \n if ( e >= 24 ) { \n e = 24 ; \n block -> mdct_coef [ ch ] [ i ] = 0 ; \n } \n } \n block -> exp [ ch ] [ i ] = e ; \n } \n } \n } \n }", "idx": 18520}
{"project": "FFmpeg", "commit_id": "ecc3a139b8858553e4ec8b3f4dd04510c6c94b03", "target": 1, "func": "static int decode_extradata ( AVFormatContext * s , ADTSContext * adts , uint8_t * buf , int size ) \n { \n GetBitContext gb ; \n init_get_bits ( & gb , buf , size * 8 ) ; \n adts -> objecttype = get_bits ( & gb , 5 ) - 1 ; \n adts -> sample_rate_index = get_bits ( & gb , 4 ) ; \n adts -> channel_conf = get_bits ( & gb , 4 ) ; \n if ( adts -> objecttype > 3 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , adts -> objecttype ) ; \n return -1 ; \n } \n if ( adts -> sample_rate_index == 15 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( adts -> channel_conf == 0 ) { \n ff_log_missing_feature ( s , \" \" , 0 ) ; \n return -1 ; \n } \n adts -> write_adts = 1 ; \n return 0 ; \n }", "idx": 18527}
{"project": "FFmpeg", "commit_id": "83f238cbf0c038245d2b2dffa5beb0916e7c36d2", "target": 0, "func": "static void arm_idct_put ( UINT8 * dest , int line_size , DCTELEM * block ) \n { \n j_rev_dct_ARM ( block ) ; \n put_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 18532}
{"project": "FFmpeg", "commit_id": "b2955b6c5aed11026ec5c7164462899a10cdb937", "target": 0, "func": "static inline av_flatten int get_symbol_inline ( RangeCoder * c , uint8_t * state , \n int is_signed ) \n { \n if ( get_rac ( c , state + 0 ) ) \n return 0 ; \n else { \n int i , e , a ; \n e = 0 ; \n while ( get_rac ( c , state + 1 + FFMIN ( e , 9 ) ) ) \n e ++ ; \n a = 1 ; \n for ( i = e - 1 ; i >= 0 ; i -- ) \n a += a + get_rac ( c , state + 22 + FFMIN ( i , 9 ) ) ; \n e = - ( is_signed && get_rac ( c , state + 11 + FFMIN ( e , 10 ) ) ) ; \n return ( a ^ e ) - e ; \n } \n }", "idx": 18534}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_end ( AVFormatContext * oc , int write_trailer ) \n { \n int ret = 0 ; \n av_write_frame ( oc , NULL ) ; \n if ( write_trailer ) \n av_write_trailer ( oc ) ; \n avio_close ( oc -> pb ) ; \n return ret ; \n }", "idx": 18537}
{"project": "FFmpeg", "commit_id": "a0c71a575109f123978e345fa7eb4ac03cd4d3c3", "target": 0, "func": "AVStream * avformat_new_stream ( AVFormatContext * s , const AVCodec * c ) \n { \n AVStream * st ; \n int i ; \n if ( av_reallocp_array ( & s -> streams , s -> nb_streams + 1 , \n sizeof ( * s -> streams ) ) < 0 ) { \n s -> nb_streams = 0 ; \n return NULL ; \n } \n st = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! st ) \n return NULL ; \n if ( ! ( st -> info = av_mallocz ( sizeof ( * st -> info ) ) ) ) { \n av_free ( st ) ; \n return NULL ; \n } \n st -> codec = avcodec_alloc_context3 ( c ) ; \n if ( ! st -> codec ) { \n av_free ( st -> info ) ; \n av_free ( st ) ; \n return NULL ; \n } \n if ( s -> iformat ) { \n st -> codec -> bit_rate = 0 ; \n avpriv_set_pts_info ( st , 33 , 1 , 90000 ) ; \n } \n st -> index = s -> nb_streams ; \n st -> start_time = AV_NOPTS_VALUE ; \n st -> duration = AV_NOPTS_VALUE ; \n st -> cur_dts = 0 ; \n st -> first_dts = AV_NOPTS_VALUE ; \n st -> probe_packets = MAX_PROBE_PACKETS ; \n st -> last_IP_pts = AV_NOPTS_VALUE ; \n for ( i = 0 ; i < MAX_REORDER_DELAY + 1 ; i ++ ) \n st -> pts_buffer [ i ] = AV_NOPTS_VALUE ; \n st -> sample_aspect_ratio = ( AVRational ) { 0 , 1 } ; \n st -> info -> fps_first_dts = AV_NOPTS_VALUE ; \n st -> info -> fps_last_dts = AV_NOPTS_VALUE ; \n s -> streams [ s -> nb_streams ++ ] = st ; \n return st ; \n }", "idx": 18538}
{"project": "FFmpeg", "commit_id": "7dc75e8d4375a36a6a19a050f2bee6bd76c7a912", "target": 0, "func": "static int cdxa_probe ( AVProbeData * p ) \n { \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 8 ] == ' ' && p -> buf [ 9 ] == ' ' && \n p -> buf [ 10 ] == ' ' && p -> buf [ 11 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 18539}
{"project": "FFmpeg", "commit_id": "55f046be1193142536198957d1701d18881d3b7a", "target": 0, "func": "static int set_string_fmt ( void * obj , const AVOption * o , const char * val , uint8_t * dst , \n int fmt_nb , int ( ( * get_fmt ) ( const char * ) ) , const char * desc ) \n { \n int fmt ; \n if ( ! val || ! strcmp ( val , \" \" ) ) { \n fmt = -1 ; \n } else { \n fmt = get_fmt ( val ) ; \n if ( fmt == -1 ) { \n char * tail ; \n fmt = strtol ( val , & tail , 0 ) ; \n if ( * tail || ( unsigned ) fmt >= fmt_nb ) { \n av_log ( obj , AV_LOG_ERROR , \n \" \\\" \\\" \\n \" , val , desc ) ; \n return AVERROR ( EINVAL ) ; \n } \n } \n } \n * ( int * ) dst = fmt ; \n return 0 ; \n }", "idx": 18540}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_2r_to_dolby ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] - output [ 4 ] [ i ] - output [ 5 ] [ i ] ) ; \n output [ 2 ] [ i ] += ( output [ 3 ] [ i ] + output [ 4 ] [ i ] + output [ 5 ] [ i ] ) ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n memset ( output [ 5 ] , 0 , sizeof ( output [ 5 ] ) ) ; \n }", "idx": 18546}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static void rtsp_send_cmd ( AVFormatContext * s , \n const char * cmd , RTSPMessageHeader * reply , \n unsigned char * * content_ptr ) \n { \n rtsp_send_cmd_async ( s , cmd , reply , content_ptr ) ; \n rtsp_read_reply ( s , reply , content_ptr , 0 ) ; \n }", "idx": 18549}
{"project": "FFmpeg", "commit_id": "c77549c510370eaaa2e2bb1f15d1a30f29e30950", "target": 1, "func": "static int rtsp_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n RTSPState * rt = s -> priv_data ; \n int ret ; \n ret = ff_rtsp_connect ( s ) ; \n if ( ret ) \n return ret ; \n rt -> real_setup_cache = av_mallocz ( 2 * s -> nb_streams * sizeof ( * rt -> real_setup_cache ) ) ; \n if ( ! rt -> real_setup_cache ) \n return AVERROR ( ENOMEM ) ; \n rt -> real_setup = rt -> real_setup_cache + s -> nb_streams * sizeof ( * rt -> real_setup ) ; \n if ( ap -> initial_pause ) { \n } else { \n if ( rtsp_read_play ( s ) < 0 ) { \n ff_rtsp_close_streams ( s ) ; \n ff_rtsp_close_connections ( s ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n return 0 ; \n }", "idx": 18550}
{"project": "FFmpeg", "commit_id": "b61ba262a1e275f8129b7383d70fe48051b47fcf", "target": 1, "func": "static void mpc8_parse_seektable ( AVFormatContext * s , int64_t off ) \n { \n MPCContext * c = s -> priv_data ; \n int tag ; \n int64_t size , pos , ppos [ 2 ] ; \n uint8_t * buf ; \n int i , t , seekd ; \n GetBitContext gb ; \n avio_seek ( s -> pb , off , SEEK_SET ) ; \n mpc8_get_chunk_header ( s -> pb , & tag , & size ) ; \n if ( tag != TAG_SEEKTABLE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n if ( ! ( buf = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ) ) \n avio_read ( s -> pb , buf , size ) ; \n init_get_bits ( & gb , buf , size * 8 ) ; \n size = gb_get_v ( & gb ) ; \n if ( size > UINT_MAX / 4 || size > c -> samples / 1152 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n seekd = get_bits ( & gb , 4 ) ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n pos = gb_get_v ( & gb ) + c -> header_pos ; \n ppos [ 1 - i ] = pos ; \n av_add_index_entry ( s -> streams [ 0 ] , pos , i , 0 , 0 , AVINDEX_KEYFRAME ) ; \n for ( ; i < size ; i ++ ) { \n t = get_unary ( & gb , 1 , 33 ) << 12 ; \n t += get_bits ( & gb , 12 ) ; \n if ( t & 1 ) \n t = - ( t & ~ 1 ) ; \n pos = ( t >> 1 ) + ppos [ 0 ] * 2 - ppos [ 1 ] ; \n av_add_index_entry ( s -> streams [ 0 ] , pos , i << seekd , 0 , 0 , AVINDEX_KEYFRAME ) ; \n ppos [ 1 ] = ppos [ 0 ] ; \n ppos [ 0 ] = pos ; \n av_free ( buf ) ;", "idx": 18564}
{"project": "FFmpeg", "commit_id": "e09ae22ab7d9af7f1cbfd2445fa71ad9e7c28ee3", "target": 1, "func": "static void copy_bits ( PutBitContext * pb , \n const uint8_t * data , int size , \n GetBitContext * gb , int nbits ) \n { \n int rmn_bytes , rmn_bits ; \n rmn_bits = rmn_bytes = get_bits_left ( gb ) ; \n if ( rmn_bits < nbits ) \n rmn_bits &= 7 ; rmn_bytes >>= 3 ; \n if ( ( rmn_bits = FFMIN ( rmn_bits , nbits ) ) > 0 ) \n put_bits ( pb , rmn_bits , get_bits ( gb , rmn_bits ) ) ; \n ff_copy_bits ( pb , data + size - rmn_bytes , \n FFMIN ( nbits - rmn_bits , rmn_bytes << 3 ) ) ; \n }", "idx": 18579}
{"project": "FFmpeg", "commit_id": "d1016dccdcb10486245e5d7c186cc31af54b2a9c", "target": 0, "func": "static int xmv_read_close ( AVFormatContext * s ) \n { \n XMVDemuxContext * xmv = s -> priv_data ; \n av_free ( xmv -> audio ) ; \n av_free ( xmv -> audio_tracks ) ; \n return 0 ; \n }", "idx": 18582}
{"project": "FFmpeg", "commit_id": "d04956344d38ddd77ec61042ce57cd9021491c83", "target": 0, "func": "static void pack_yuv ( TiffEncoderContext * s , uint8_t * dst , int lnum ) \n { \n AVFrame * p = & s -> picture ; \n int i , j , k ; \n int w = ( s -> width - 1 ) / s -> subsampling [ 0 ] + 1 ; \n uint8_t * pu = & p -> data [ 1 ] [ lnum / s -> subsampling [ 1 ] * p -> linesize [ 1 ] ] ; \n uint8_t * pv = & p -> data [ 2 ] [ lnum / s -> subsampling [ 1 ] * p -> linesize [ 2 ] ] ; \n for ( i = 0 ; i < w ; i ++ ) { \n for ( j = 0 ; j < s -> subsampling [ 1 ] ; j ++ ) \n for ( k = 0 ; k < s -> subsampling [ 0 ] ; k ++ ) \n * dst ++ = p -> data [ 0 ] [ ( lnum + j ) * p -> linesize [ 0 ] + \n i * s -> subsampling [ 0 ] + k ] ; \n * dst ++ = * pu ++ ; \n * dst ++ = * pv ++ ; \n } \n }", "idx": 18592}
{"project": "FFmpeg", "commit_id": "d3cb302b88503c3111e25add196622110c056188", "target": 1, "func": "static int get_sot ( Jpeg2000DecoderContext * s , int n ) \n { \n Jpeg2000TilePart * tp ; \n uint16_t Isot ; \n uint32_t Psot ; \n uint8_t TPsot ; \n if ( bytestream2_get_bytes_left ( & s -> g ) < 8 ) \n Isot = bytestream2_get_be16u ( & s -> g ) ; \n if ( Isot ) { \n avpriv_request_sample ( s -> avctx , \" \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n Psot = bytestream2_get_be32u ( & s -> g ) ; \n TPsot = bytestream2_get_byteu ( & s -> g ) ; \n bytestream2_get_byteu ( & s -> g ) ; \n if ( Psot > bytestream2_get_bytes_left ( & s -> g ) + n + 2 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , Psot ) ; \n } \n if ( TPsot >= FF_ARRAY_ELEMS ( s -> tile [ Isot ] . tile_part ) ) { \n avpriv_request_sample ( s -> avctx , \" \" , TPsot ) ; \n return AVERROR_PATCHWELCOME ; \n } \n tp = s -> tile [ s -> curtileno ] . tile_part + TPsot ; \n tp -> tile_index = Isot ; \n tp -> tp_len = Psot ; \n tp -> tp_idx = TPsot ; \n if ( JPEG2000_SOD == bytestream2_get_be16 ( & s -> g ) ) { \n bytestream2_init ( & tp -> tpg , s -> g . buffer , tp -> tp_len - n - 4 ) ; \n bytestream2_skip ( & s -> g , tp -> tp_len - n - 4 ) ; \n } else { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n return 0 ; \n }", "idx": 18623}
{"project": "FFmpeg", "commit_id": "9d656110966fbdde0fd1d2e685f3ed3633ba3596", "target": 0, "func": "static int decode_subframe_lpc ( FLACContext * s , int channel , int pred_order ) \n { \n int sum , i , j ; \n int coeff_prec , qlevel ; \n int coeffs [ pred_order ] ; \n for ( i = 0 ; i < pred_order ; i ++ ) \n { \n s -> decoded [ channel ] [ i ] = get_sbits ( & s -> gb , s -> curr_bps ) ; \n } \n coeff_prec = get_bits ( & s -> gb , 4 ) + 1 ; \n if ( coeff_prec == 16 ) \n { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return -1 ; \n } \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , coeff_prec ) ; \n qlevel = get_sbits ( & s -> gb , 5 ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , qlevel ) ; \n assert ( qlevel >= 0 ) ; \n for ( i = 0 ; i < pred_order ; i ++ ) \n { \n coeffs [ i ] = get_sbits ( & s -> gb , coeff_prec ) ; \n } \n if ( decode_residuals ( s , channel , pred_order ) < 0 ) \n return -1 ; \n for ( i = pred_order ; i < s -> blocksize ; i ++ ) \n { \n sum = 0 ; \n for ( j = 0 ; j < pred_order ; j ++ ) \n sum += coeffs [ j ] * s -> decoded [ channel ] [ i - j - 1 ] ; \n s -> decoded [ channel ] [ i ] += sum >> qlevel ; \n } \n return 0 ; \n }", "idx": 18628}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int compare_floats ( const float * a , const float * b , int len , \n float max_diff ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n if ( fabsf ( a [ i ] - b [ i ] ) > max_diff ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , \n i , a [ i ] , b [ i ] , a [ i ] - b [ i ] ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 18630}
{"project": "FFmpeg", "commit_id": "5eef7bcd09ab1f73df6c70923dfa3f4ccd5b4190", "target": 1, "func": "static int mtv_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MTVDemuxContext * mtv = s -> priv_data ; \n ByteIOContext * pb = s -> pb ; \n int ret ; \n #if ! HAVE_BIGENDIAN  \n  \n  int i ; \n #endif \n if ( ( url_ftell ( pb ) - s -> data_offset + mtv -> img_segment_size ) % mtv -> full_segment_size ) \n { \n url_fskip ( pb , MTV_AUDIO_PADDING_SIZE ) ; \n ret = av_get_packet ( pb , pkt , MTV_ASUBCHUNK_DATA_SIZE ) ; \n if ( ret != MTV_ASUBCHUNK_DATA_SIZE ) \n return AVERROR ( EIO ) ; \n pkt -> pos -= MTV_AUDIO_PADDING_SIZE ; \n pkt -> stream_index = AUDIO_SID ; \n } else \n { \n ret = av_get_packet ( pb , pkt , mtv -> img_segment_size ) ; \n if ( ret != mtv -> img_segment_size ) \n return AVERROR ( EIO ) ; \n #if ! HAVE_BIGENDIAN  \n  \n  \n  \n  \n  \n  \n  for ( i = 0 ; i < mtv -> img_segment_size / 2 ; i ++ ) \n * ( ( uint16_t * ) pkt -> data + i ) = bswap_16 ( * ( ( uint16_t * ) pkt -> data + i ) ) ; \n #endif \n pkt -> stream_index = VIDEO_SID ; \n } \n return ret ; \n }", "idx": 18631}
{"project": "FFmpeg", "commit_id": "dd4b7badb416a5c2688da7310a7fe80fe4e4f209", "target": 1, "func": "static int64_t find_best_filter ( const DCAADPCMEncContext * s , const int32_t * in , int len ) \n { \n const premultiplied_coeffs * precalc_data = s -> private_data ; \n int i , j , k = 0 ; \n int vq ; \n int64_t err ; \n int64_t min_err = 1ll << 62 ; \n int64_t corr [ 15 ] ; \n for ( i = 0 ; i <= DCA_ADPCM_COEFFS ; i ++ ) \n for ( j = i ; j <= DCA_ADPCM_COEFFS ; j ++ ) \n corr [ k ++ ] = calc_corr ( in + 4 , len , i , j ) ; \n for ( i = 0 ; i < DCA_ADPCM_VQCODEBOOK_SZ ; i ++ ) { \n err = apply_filter ( ff_dca_adpcm_vb [ i ] , corr , * precalc_data ) ; \n if ( err < min_err ) { \n min_err = err ; \n vq = i ; \n } \n precalc_data ++ ; \n } \n return vq ; \n }", "idx": 18641}
{"project": "FFmpeg", "commit_id": "e4bb70838f0c3092a9b893f2210e7c303f0f2a4a", "target": 0, "func": "static int nut_read_packet ( AVFormatContext * avf , AVPacket * pkt ) { \n NUTContext * priv = avf -> priv_data ; \n nut_packet_t pd ; \n int ret ; \n while ( ( ret = nut_read_next_packet ( priv -> nut , & pd ) ) < 0 ) \n av_log ( avf , AV_LOG_ERROR , \" \\n \" , nut_error ( - ret ) ) ; \n if ( ret || av_new_packet ( pkt , pd . len ) < 0 ) return -1 ; \n if ( pd . flags & NUT_FLAG_KEY ) pkt -> flags |= PKT_FLAG_KEY ; \n pkt -> pts = pd . pts ; \n pkt -> stream_index = pd . stream ; \n pkt -> pos = url_ftell ( & avf -> pb ) ; \n ret = nut_read_frame ( priv -> nut , & pd . len , pkt -> data ) ; \n return ret ; \n }", "idx": 18651}
{"project": "FFmpeg", "commit_id": "2a351f6c5521c199b4285e4e42f2321e312170bd", "target": 0, "func": "int ff_request_frame ( AVFilterLink * link ) \n { \n int ret = -1 ; \n FF_TPRINTF_START ( NULL , request_frame ) ; ff_tlog_link ( NULL , link , 1 ) ; \n if ( link -> closed ) \n return AVERROR_EOF ; \n av_assert0 ( ! link -> frame_requested ) ; \n link -> frame_requested = 1 ; \n while ( link -> frame_requested ) { \n if ( link -> srcpad -> request_frame ) \n ret = link -> srcpad -> request_frame ( link ) ; \n else if ( link -> src -> inputs [ 0 ] ) \n ret = ff_request_frame ( link -> src -> inputs [ 0 ] ) ; \n if ( ret == AVERROR_EOF && link -> partial_buf ) { \n AVFrame * pbuf = link -> partial_buf ; \n link -> partial_buf = NULL ; \n ret = ff_filter_frame_framed ( link , pbuf ) ; \n } \n if ( ret < 0 ) { \n link -> frame_requested = 0 ; \n if ( ret == AVERROR_EOF ) \n link -> closed = 1 ; \n } else { \n av_assert0 ( ! link -> frame_requested || \n link -> flags & FF_LINK_FLAG_REQUEST_LOOP ) ; \n } \n } \n return ret ; \n }", "idx": 18659}
{"project": "FFmpeg", "commit_id": "53c05b1eacd5f7dbfa3651b45e797adaea0a5ff8", "target": 0, "func": "static void filter_frame ( H264Context * h ) { \n int mb_x = 0 ; \n int mb_y = 0 ; \n for ( mb_y = 0 ; mb_y < h -> s . mb_height ; mb_y ++ ) { \n for ( mb_x = 0 ; mb_x < h -> s . mb_width ; mb_x ++ ) { \n filter_mb ( h , mb_x , mb_y ) ; \n } \n } \n }", "idx": 18670}
{"project": "FFmpeg", "commit_id": "cd40c31ee9ad2cca6f3635950b002fd46be07e98", "target": 1, "func": "static int ebml_read_ascii ( AVIOContext * pb , int size , char * * str ) \n { \n av_free ( * str ) ; \n if ( ! ( * str = av_malloc ( size + 1 ) ) ) \n return AVERROR ( ENOMEM ) ; \n if ( avio_read ( pb , ( uint8_t * ) * str , size ) != size ) { \n av_freep ( str ) ; \n return AVERROR ( EIO ) ; \n } \n ( * str ) [ size ] = ' \\0 ' ; \n return 0 ; \n }", "idx": 18688}
{"project": "FFmpeg", "commit_id": "a4fe661157b22a353ecce51f5c717c42c8fe00b0", "target": 1, "func": "static int mov_probe ( AVProbeData * p ) \n { \n unsigned int offset ; \n uint32_t tag ; \n int score = 0 ; \n offset = 0 ; \n for ( ; ; ) { \n if ( ( offset + 8 ) > ( unsigned int ) p -> buf_size ) \n return score ; \n tag = AV_RL32 ( p -> buf + offset + 4 ) ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n return AVPROBE_SCORE_MAX ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n return AVPROBE_SCORE_MAX - 5 ; \n case MKTAG ( 0x82 , 0x82 , 0x7f , 0x7d ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n offset = AV_RB32 ( p -> buf + offset ) + offset ; \n score = AVPROBE_SCORE_MAX - 50 ; \n break ; \n default : \n return score ; \n } \n } \n }", "idx": 18703}
{"project": "FFmpeg", "commit_id": "57d24225595af78b0fd836d4d145f5d181e320a2", "target": 0, "func": "static int need_output ( void ) \n { \n int i ; \n for ( i = 0 ; i < nb_output_streams ; i ++ ) { \n OutputStream * ost = output_streams [ i ] ; \n OutputFile * of = output_files [ ost -> file_index ] ; \n AVFormatContext * os = output_files [ ost -> file_index ] -> ctx ; \n if ( ost -> is_past_recording_time || \n ( os -> pb && avio_tell ( os -> pb ) >= of -> limit_filesize ) ) \n continue ; \n if ( ost -> frame_number >= ost -> max_frames ) { \n int j ; \n for ( j = 0 ; j < of -> ctx -> nb_streams ; j ++ ) \n output_streams [ of -> ost_index + j ] -> is_past_recording_time = 1 ; \n continue ; \n } \n return 1 ; \n } \n return 0 ; \n }", "idx": 18713}
{"project": "FFmpeg", "commit_id": "725353525e73bbe5b6b4d01528252675f2417a02", "target": 1, "func": "static av_cold int ulti_decode_init ( AVCodecContext * avctx ) \n { \n UltimotionDecodeContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n s -> blocks = ( s -> width / 8 ) * ( s -> height / 8 ) ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; \n s -> ulti_codebook = ulti_codebook ; \n s -> frame = av_frame_alloc ( ) ; \n if ( ! s -> frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 18716}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc11_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_16x16_msa ( src - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 18734}
{"project": "FFmpeg", "commit_id": "391a1327bd076c25c2b2509ab7ae0081c443b94e", "target": 0, "func": "static void filter_line_c ( uint8_t * dst , \n uint8_t * prev , uint8_t * cur , uint8_t * next , \n int w , int refs , int parity , int mode ) \n { \n int x ; \n uint8_t * prev2 = parity ? prev : cur ; \n uint8_t * next2 = parity ? cur : next ; \n for ( x = 0 ; x < w ; x ++ ) { \n int c = cur [ - refs ] ; \n int d = ( prev2 [ 0 ] + next2 [ 0 ] ) >> 1 ; \n int e = cur [ + refs ] ; \n int temporal_diff0 = FFABS ( prev2 [ 0 ] - next2 [ 0 ] ) ; \n int temporal_diff1 = ( FFABS ( prev [ - refs ] - c ) + FFABS ( prev [ + refs ] - e ) ) >> 1 ; \n int temporal_diff2 = ( FFABS ( next [ - refs ] - c ) + FFABS ( next [ + refs ] - e ) ) >> 1 ; \n int diff = FFMAX3 ( temporal_diff0 >> 1 , temporal_diff1 , temporal_diff2 ) ; \n int spatial_pred = ( c + e ) >> 1 ; \n int spatial_score = FFABS ( cur [ - refs - 1 ] - cur [ + refs - 1 ] ) + FFABS ( c - e ) \n + FFABS ( cur [ - refs + 1 ] - cur [ + refs + 1 ] ) - 1 ; \n #define CHECK ( j ) \\ \n  \n  { int score = FFABS ( cur [ - refs - 1 + j ] - cur [ + refs - 1 - j ] ) \n + FFABS ( cur [ - refs + j ] - cur [ + refs - j ] ) \n + FFABS ( cur [ - refs + 1 + j ] - cur [ + refs + 1 - j ] ) ; \n if ( score < spatial_score ) { \n spatial_score = score ; \n spatial_pred = ( cur [ - refs + j ] + cur [ + refs - j ] ) >> 1 ; \n CHECK ( -1 )  CHECK ( -2 )  } } } }", "idx": 18750}
{"project": "FFmpeg", "commit_id": "bdf3d3bf9dce398acce608de77da205e08bdace3", "target": 0, "func": "static void opt_video_channel ( const char * arg ) \n { \n video_channel = strtol ( arg , NULL , 0 ) ; \n }", "idx": 18751}
{"project": "FFmpeg", "commit_id": "82f19afefe4f28db0e2eefbc2d06eee0def74a53", "target": 0, "func": "static int parse_tag ( AVFormatContext * s , const uint8_t * buf ) \n { \n int genre ; \n if ( ! ( buf [ 0 ] == ' ' && \n buf [ 1 ] == ' ' && \n buf [ 2 ] == ' ' ) ) \n return -1 ; \n get_string ( s , \" \" , buf + 3 , 30 ) ; \n get_string ( s , \" \" , buf + 33 , 30 ) ; \n get_string ( s , \" \" , buf + 63 , 30 ) ; \n get_string ( s , \" \" , buf + 93 , 4 ) ; \n get_string ( s , \" \" , buf + 97 , 30 ) ; \n if ( buf [ 125 ] == 0 && buf [ 126 ] != 0 ) \n av_metadata_set2 ( & s -> metadata , \" \" , av_d2str ( buf [ 126 ] ) , AV_METADATA_DONT_STRDUP_VAL ) ; \n genre = buf [ 127 ] ; \n if ( genre <= ID3v1_GENRE_MAX ) \n av_metadata_set2 ( & s -> metadata , \" \" , ff_id3v1_genre_str [ genre ] , 0 ) ; \n return 0 ; \n }", "idx": 18752}
{"project": "FFmpeg", "commit_id": "276df9d8210121f6d59b7876e1724ebe7a11f5e5", "target": 1, "func": "static void lame_window_init ( AacPsyContext * ctx , AVCodecContext * avctx ) { \n int i ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) { \n AacPsyChannel * pch = & ctx -> ch [ i ] ; \n if ( avctx -> flags & CODEC_FLAG_QSCALE ) \n pch -> attack_threshold = psy_vbr_map [ avctx -> global_quality / FF_QP2LAMBDA ] . st_lrm ; \n else \n pch -> attack_threshold = lame_calc_attack_threshold ( avctx -> bit_rate / avctx -> channels / 1000 ) ; \n for ( i = 0 ; i < AAC_NUM_BLOCKS_SHORT * PSY_LAME_NUM_SUBBLOCKS ; i ++ ) \n pch -> prev_energy_subshort [ i ] = 10.0f ; \n } \n }", "idx": 18758}
{"project": "FFmpeg", "commit_id": "8c2515bbb9800a3cdcc28aa19133302ba5f2da45", "target": 1, "func": "static void mc_block ( uint8_t * dst , uint8_t * src , uint8_t * tmp , int stride , int b_w , int b_h , int dx , int dy ) { \n int x , y ; \n START_TIMER \n for ( y  = 0 ; y < b_h + 5 ; y ++ ) { \n for ( x = 0 ; x < b_w ; x ++ ) { \n int a0 = src [ x ] ; \n int a1 = src [ x + 1 ] ; \n int a2 = src [ x + 2 ] ; \n int a3 = src [ x + 3 ] ; \n int a4 = src [ x + 4 ] ; \n int a5 = src [ x + 5 ] ; \n int am = 20 * ( a2 + a3 ) - 5 * ( a1 + a4 ) + ( a0 + a5 ) ; \n if ( dx < 8 ) tmp [ x ] = ( 32 * a2 * ( 8 - dx ) + am * dx + 128 ) >> 8 ; \n else tmp [ x ] = ( am * ( 16 - dx ) + 32 * a3 * ( dx - 8 ) + 128 ) >> 8 ; \n } \n tmp += stride ; \n src += stride ; \n } \n tmp -= ( b_h + 5 ) * stride ; \n for ( y = 0 ; y < b_h ; y ++ ) { \n for ( x = 0 ; x < b_w ; x ++ ) { \n int a0 = tmp [ x + 0 * stride ] ; \n int a1 = tmp [ x + 1 * stride ] ; \n int a2 = tmp [ x + 2 * stride ] ; \n int a3 = tmp [ x + 3 * stride ] ; \n int a4 = tmp [ x + 4 * stride ] ; \n int a5 = tmp [ x + 5 * stride ] ; \n int am = 20 * ( a2 + a3 ) - 5 * ( a1 + a4 ) + ( a0 + a5 ) ; \n if ( dy < 8 ) dst [ x ] = ( 32 * a2 * ( 8 - dy ) + am * dy + 128 ) >> 8 ; \n else dst [ x ] = ( am * ( 16 - dy ) + 32 * a3 * ( dy - 8 ) + 128 ) >> 8 ; \n } \n dst += stride ; \n tmp += stride ; \n } \n STOP_TIMER ( \" \" )  \n }", "idx": 18761}
{"project": "FFmpeg", "commit_id": "a736eb4a605f46d5ff96c7b32e55710ecd9cce89", "target": 1, "func": "static void latm_write_frame_header ( AVFormatContext * s , PutBitContext * bs ) \n { \n LATMContext * ctx = s -> priv_data ; \n AVCodecContext * avctx = s -> streams [ 0 ] -> codec ; \n GetBitContext gb ; \n int header_size ; \n put_bits ( bs , 1 , ! ! ctx -> counter ) ; \n if ( ! ctx -> counter ) { \n init_get_bits ( & gb , avctx -> extradata , avctx -> extradata_size * 8 ) ; \n put_bits ( bs , 1 , 0 ) ; \n put_bits ( bs , 1 , 1 ) ; \n put_bits ( bs , 6 , 0 ) ; \n put_bits ( bs , 4 , 0 ) ; \n put_bits ( bs , 3 , 0 ) ; \n if ( ctx -> object_type == AOT_ALS ) { \n header_size = avctx -> extradata_size - ( ctx -> off + 7 ) >> 3 ; \n avpriv_copy_bits ( bs , & avctx -> extradata [ ctx -> off ] , header_size ) ; \n } else { \n avpriv_copy_bits ( bs , avctx -> extradata , ctx -> off + 3 ) ; \n if ( ! ctx -> channel_conf ) { \n avpriv_copy_pce_data ( bs , & gb ) ; \n } \n } \n put_bits ( bs , 3 , 0 ) ; \n put_bits ( bs , 8 , 0xff ) ; \n put_bits ( bs , 1 , 0 ) ; \n put_bits ( bs , 1 , 0 ) ; \n } \n ctx -> counter ++ ; \n ctx -> counter %= ctx -> mod ; \n }", "idx": 18764}
{"project": "FFmpeg", "commit_id": "69619a13c3fef940cba545cf0a283ff22771dd71", "target": 1, "func": "static int matroska_probe ( AVProbeData * p ) \n { \n uint64_t total = 0 ; \n int len_mask = 0x80 , size = 1 , n = 1 , i ; \n if ( AV_RB32 ( p -> buf ) != EBML_ID_HEADER ) \n return 0 ; \n total = p -> buf [ 4 ] ; \n while ( size <= 8 && ! ( total & len_mask ) ) { \n size ++ ; \n len_mask >>= 1 ; \n } \n if ( size > 8 ) \n return 0 ; \n total &= ( len_mask - 1 ) ; \n while ( n < size ) \n total = ( total << 8 ) | p -> buf [ 4 + n ++ ] ; \n if ( p -> buf_size < 4 + size + total ) \n return 0 ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( matroska_doctypes ) ; i ++ ) { \n int probelen = strlen ( matroska_doctypes [ i ] ) ; \n for ( n = 4 + size ; n <= 4 + size + total - probelen ; n ++ ) \n if ( ! memcmp ( p -> buf + n , matroska_doctypes [ i ] , probelen ) ) \n return AVPROBE_SCORE_MAX ; \n } \n return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 18768}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8torgb32 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 3 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 0 ] ; \n #else \n dst [ 0 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 0 ] ; \n #endif \n dst += 4 ; \n } \n }", "idx": 18769}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_source_clip ( void * arg , AVIOContext * pb , int tag , int size , UID uid ) \n { \n MXFStructuralComponent * source_clip = arg ; \n switch ( tag ) { \n case 0x0202 : \n source_clip -> duration = avio_rb64 ( pb ) ; \n break ; \n case 0x1201 : \n source_clip -> start_position = avio_rb64 ( pb ) ; \n break ; \n case 0x1101 : \n avio_skip ( pb , 16 ) ; \n avio_read ( pb , source_clip -> source_package_uid , 16 ) ; \n break ; \n case 0x1102 : \n source_clip -> source_track_id = avio_rb32 ( pb ) ; \n break ; \n } \n return 0 ; \n }", "idx": 18772}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int copy_parameter_set ( void * * to , void * * from , int count , int size ) \n { \n int i ; \n for ( i = 0 ; i < count ; i ++ ) { \n if ( to [ i ] && ! from [ i ] ) { \n av_freep ( & to [ i ] ) ; \n } else if ( from [ i ] && ! to [ i ] ) { \n to [ i ] = av_malloc ( size ) ; \n if ( ! to [ i ] ) \n return AVERROR ( ENOMEM ) ; \n } \n if ( from [ i ] ) \n memcpy ( to [ i ] , from [ i ] , size ) ; \n } \n return 0 ; \n }", "idx": 18791}
{"project": "FFmpeg", "commit_id": "b1ade3d1821a29174963b28cd0caa5f7ed394998", "target": 0, "func": "int ff_celp_lp_synthesis_filter ( int16_t * out , \n const int16_t * filter_coeffs , \n const int16_t * in , \n int buffer_length , \n int filter_length , \n int stop_on_overflow , \n int rounder ) \n { \n int i , n ; \n filter_length ++ ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n int sum = rounder ; \n for ( i = 1 ; i < filter_length ; i ++ ) \n sum -= filter_coeffs [ i - 1 ] * out [ n - i ] ; \n sum = ( sum >> 12 ) + in [ n ] ; \n if ( sum + 0x8000 > 0xFFFFU ) { \n if ( stop_on_overflow ) \n return 1 ; \n sum = ( sum >> 31 ) ^ 32767 ; \n } \n out [ n ] = sum ; \n } \n return 0 ; \n }", "idx": 18802}
{"project": "FFmpeg", "commit_id": "46191a2da16f751e53d93646ae1388d421d12bee", "target": 1, "func": "static int mov_read_mac_string ( MOVContext * c , AVIOContext * pb , int len , \n char * dst , int dstlen ) \n { \n char * p = dst ; \n char * end = dst + dstlen - 1 ; \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n uint8_t t , c = avio_r8 ( pb ) ; \n if ( c < 0x80 && p < end ) \n * p ++ = c ; \n else \n PUT_UTF8 ( mac_to_unicode [ c - 0x80 ] , t , if ( p < end ) * p ++  = t ; ) ; \n } \n * p = 0 ; \n return p - dst ; \n }", "idx": 18821}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_h_strong_loop_filter ( uint8_t * src , const int stride , \n const int alpha , const int lims , \n const int dmode , const int chroma ) \n { \n rv40_strong_loop_filter ( src , stride , 1 , alpha , lims , dmode , chroma ) ; \n }", "idx": 18824}
{"project": "FFmpeg", "commit_id": "e6aed5f404a0983b2971c90e9022f6964a75de0b", "target": 1, "func": "static void copy_frame ( J2kEncoderContext * s ) \n { \n int tileno , compno , i , y , x ; \n uint8_t * line ; \n for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { \n J2kTile * tile = s -> tile + tileno ; \n if ( s -> planar ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n J2kComponent * comp = tile -> comp + compno ; \n int * dst = comp -> data ; \n line = s -> picture -> data [ compno ] \n + comp -> coord [ 1 ] [ 0 ] * s -> picture -> linesize [ compno ] \n + comp -> coord [ 0 ] [ 0 ] ; \n for ( y = comp -> coord [ 1 ] [ 0 ] ; y < comp -> coord [ 1 ] [ 1 ] ; y ++ ) { \n uint8_t * ptr = line ; \n for ( x = comp -> coord [ 0 ] [ 0 ] ; x < comp -> coord [ 0 ] [ 1 ] ; x ++ ) \n * dst ++ = * ptr ++ - ( 1 << 7 ) ; \n line += s -> picture -> linesize [ compno ] ; \n } \n } \n } else { \n line = s -> picture -> data [ 0 ] + tile -> comp [ 0 ] . coord [ 1 ] [ 0 ] * s -> picture -> linesize [ 0 ] \n + tile -> comp [ 0 ] . coord [ 0 ] [ 0 ] * s -> ncomponents ; \n i = 0 ; \n for ( y = tile -> comp [ 0 ] . coord [ 1 ] [ 0 ] ; y < tile -> comp [ 0 ] . coord [ 1 ] [ 1 ] ; y ++ ) { \n uint8_t * ptr = line ; \n for ( x = tile -> comp [ 0 ] . coord [ 0 ] [ 0 ] ; x < tile -> comp [ 0 ] . coord [ 0 ] [ 1 ] ; x ++ , i ++ ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n tile -> comp [ compno ] . data [ i ] = * ptr ++ - ( 1 << 7 ) ; \n } \n } \n line += s -> picture -> linesize [ 0 ] ; \n } \n } \n } \n }", "idx": 18825}
{"project": "FFmpeg", "commit_id": "aaec4e03e91f3f301d5720429a5da99b44e7e1bb", "target": 0, "func": "static int av_seek_frame_generic ( AVFormatContext * s , \n int stream_index , int64_t timestamp , int flags ) \n { \n int index ; \n AVStream * st ; \n AVIndexEntry * ie ; \n st = s -> streams [ stream_index ] ; \n index = av_index_search_timestamp ( st , timestamp , flags ) ; \n if ( index < 0 || index == st -> nb_index_entries - 1 ) { \n int i ; \n AVPacket pkt ; \n if ( st -> nb_index_entries ) { \n assert ( st -> index_entries ) ; \n ie = & st -> index_entries [ st -> nb_index_entries - 1 ] ; \n url_fseek ( s -> pb , ie -> pos , SEEK_SET ) ; \n av_update_cur_dts ( s , st , ie -> timestamp ) ; \n } else \n url_fseek ( s -> pb , 0 , SEEK_SET ) ; \n for ( i = 0 ; ; i ++ ) { \n int ret = av_read_frame ( s , & pkt ) ; \n if ( ret < 0 ) \n break ; \n av_free_packet ( & pkt ) ; \n if ( stream_index == pkt . stream_index ) { \n if ( ( pkt . flags & PKT_FLAG_KEY ) && pkt . dts > timestamp ) \n break ; \n } \n } \n index = av_index_search_timestamp ( st , timestamp , flags ) ; \n } \n if ( index < 0 ) \n return -1 ; \n av_read_frame_flush ( s ) ; \n if ( s -> iformat -> read_seek ) { \n if ( s -> iformat -> read_seek ( s , stream_index , timestamp , flags ) >= 0 ) \n return 0 ; \n } \n ie = & st -> index_entries [ index ] ; \n url_fseek ( s -> pb , ie -> pos , SEEK_SET ) ; \n av_update_cur_dts ( s , st , ie -> timestamp ) ; \n return 0 ; \n }", "idx": 18832}
{"project": "FFmpeg", "commit_id": "b5228e44c7f3a5eba537c8a39a45cfbf2961a28d", "target": 1, "func": "static void noise_scale ( int * coefs , int scale , int band_energy , int len ) \n { \n int ssign = scale < 0 ? -1 : 1 ; \n int s = FFABS ( scale ) ; \n unsigned int round ; \n int i , out , c = exp2tab [ s & 3 ] ; \n int nlz = 0 ; \n while ( band_energy > 0x7fff ) { \n band_energy >>= 1 ; \n nlz ++ ; \n } \n c /= band_energy ; \n s = 21 + nlz - ( s >> 2 ) ; \n if ( s > 0 ) { \n round = 1 << ( s - 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n out = ( int ) ( ( ( int64_t ) coefs [ i ] * c ) >> 32 ) ; \n coefs [ i ] = ( ( int ) ( out + round ) >> s ) * ssign ; \n } \n } \n else { \n s = s + 32 ; \n round = 1 << ( s - 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n out = ( int ) ( ( int64_t ) ( ( int64_t ) coefs [ i ] * c + round ) >> s ) ; \n coefs [ i ] = out * ssign ; \n } \n } \n }", "idx": 18842}
{"project": "FFmpeg", "commit_id": "e24c31b656254b2516befbde78aeaca0122a6010", "target": 1, "func": "int ff_dirac_golomb_read_16bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int16_t * dst = ( int16_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res , 0 , 0 ) ; \n #define APPEND_RESIDUE ( N , M )          \\ \n  \n  N |= M >> ( N ##  _bits ) ; \n N ##  _bits += ( M ##  _bits )  \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n res_bits = res = 0 ; \n } \n for ( i = 0 ; i < LUT_BITS ; i ++ ) \n dst [ c_idx + i ] = l -> ready [ i ] ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 18845}
{"project": "FFmpeg", "commit_id": "8ef740ce01abff3bc7df0f79803a3dc781d89daa", "target": 0, "func": "int ff_draw_slice ( AVFilterLink * link , int y , int h , int slice_dir ) \n { \n uint8_t * src [ 4 ] , * dst [ 4 ] ; \n int i , j , vsub , ret ; \n int ( * draw_slice ) ( AVFilterLink * , int , int , int ) ; \n FF_TPRINTF_START ( NULL , draw_slice ) ; ff_tlog_link ( NULL , link , 0 ) ; ff_tlog ( NULL , \" \\n \" , y , h , slice_dir ) ; \n if ( link -> src_buf ) { \n vsub = av_pix_fmt_descriptors [ link -> format ] . log2_chroma_h ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( link -> src_buf -> data [ i ] ) { \n src [ i ] = link -> src_buf -> data [ i ] + \n ( y >> ( i == 1 || i == 2 ? vsub : 0 ) ) * link -> src_buf -> linesize [ i ] ; \n dst [ i ] = link -> cur_buf -> data [ i ] + \n ( y >> ( i == 1 || i == 2 ? vsub : 0 ) ) * link -> cur_buf -> linesize [ i ] ; \n } else \n src [ i ] = dst [ i ] = NULL ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n int planew = \n av_image_get_linesize ( link -> format , link -> cur_buf -> video -> w , i ) ; \n if ( ! src [ i ] ) continue ; \n for ( j = 0 ; j < h >> ( i == 1 || i == 2 ? vsub : 0 ) ; j ++ ) { \n memcpy ( dst [ i ] , src [ i ] , planew ) ; \n src [ i ] += link -> src_buf -> linesize [ i ] ; \n dst [ i ] += link -> cur_buf -> linesize [ i ] ; \n } \n } \n } \n if ( ! ( draw_slice = link -> dstpad -> draw_slice ) ) \n draw_slice = default_draw_slice ; \n ret = draw_slice ( link , y , h , slice_dir ) ; \n if ( ret < 0 ) \n clear_link ( link ) ; \n return ret ; \n }", "idx": 18847}
{"project": "FFmpeg", "commit_id": "aac07a7a4c2c7a4a29cf6dbc88c1b9fdd191b99d", "target": 0, "func": "static int rm_read_index ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n unsigned int size , n_pkts , str_id , next_off , n , pos , pts ; \n AVStream * st ; \n do { \n if ( avio_rl32 ( pb ) != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return -1 ; \n size = avio_rb32 ( pb ) ; \n if ( size < 20 ) \n return -1 ; \n avio_skip ( pb , 2 ) ; \n n_pkts = avio_rb32 ( pb ) ; \n str_id = avio_rb16 ( pb ) ; \n next_off = avio_rb32 ( pb ) ; \n for ( n = 0 ; n < s -> nb_streams ; n ++ ) \n if ( s -> streams [ n ] -> id == str_id ) { \n st = s -> streams [ n ] ; \n break ; \n } \n if ( n == s -> nb_streams ) \n goto skip ; \n for ( n = 0 ; n < n_pkts ; n ++ ) { \n avio_skip ( pb , 2 ) ; \n pts = avio_rb32 ( pb ) ; \n pos = avio_rb32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n av_add_index_entry ( st , pos , pts , 0 , 0 , AVINDEX_KEYFRAME ) ; \n } \n skip : \n if ( next_off && avio_tell ( pb ) != next_off && \n avio_seek ( pb , next_off , SEEK_SET ) < 0 ) \n return -1 ; \n } while ( next_off ) ; \n return 0 ; \n }", "idx": 18850}
{"project": "FFmpeg", "commit_id": "8108551a5c4c4c9696582c73d000f94b12cd95a5", "target": 0, "func": "int gif_write ( ByteIOContext * pb , AVImageInfo * info ) \n { \n gif_image_write_header ( pb , info -> width , info -> height , \n ( uint32_t * ) info -> pict . data [ 1 ] ) ; \n gif_image_write_image ( pb , 0 , 0 , info -> width , info -> height , \n info -> pict . data [ 0 ] , info -> pict . linesize [ 0 ] , \n PIX_FMT_PAL8 ) ; \n put_byte ( pb , 0x3b ) ; \n put_flush_packet ( pb ) ; \n return 0 ; \n }", "idx": 18934}
{"project": "FFmpeg", "commit_id": "42fb414804419c3fc269c73ad049f218f8813ed0", "target": 0, "func": "static int mov_write_moov_tag ( ByteIOContext * pb , MOVContext * mov , \n AVFormatContext * s ) \n { \n int i ; \n offset_t pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n mov -> timescale = globalTimescale ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) { \n if ( mov -> tracks [ i ] . entry <= 0 ) continue ; \n if ( mov -> tracks [ i ] . enc -> codec_type == CODEC_TYPE_VIDEO ) { \n mov -> tracks [ i ] . timescale = mov -> tracks [ i ] . enc -> time_base . den ; \n mov -> tracks [ i ] . sampleDuration = mov -> tracks [ i ] . enc -> time_base . num ; \n } else if ( mov -> tracks [ i ] . enc -> codec_type == CODEC_TYPE_AUDIO ) { \n mov -> tracks [ i ] . timescale = mov -> tracks [ i ] . enc -> sample_rate ; \n mov -> tracks [ i ] . sampleDuration = mov -> tracks [ i ] . enc -> frame_size ; \n } \n mov -> tracks [ i ] . trackDuration = \n ( int64_t ) mov -> tracks [ i ] . sampleCount * mov -> tracks [ i ] . sampleDuration ; \n mov -> tracks [ i ] . time = mov -> time ; \n mov -> tracks [ i ] . trackID = i + 1 ; \n } \n mov_write_mvhd_tag ( pb , mov ) ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) { \n if ( mov -> tracks [ i ] . entry > 0 ) { \n mov_write_trak_tag ( pb , & ( mov -> tracks [ i ] ) ) ; \n } \n } \n if ( mov -> mode == MODE_PSP ) \n mov_write_uuidusmt_tag ( pb , s ) ; \n else \n mov_write_udta_tag ( pb , mov , s ) ; \n return updateSize ( pb , pos ) ; \n }", "idx": 18941}
{"project": "FFmpeg", "commit_id": "14bc7aaa860e4d71f4966d4679b3fab547f5e0af", "target": 1, "func": "static int check_video_codec_tag ( int codec_tag ) { \n if ( codec_tag <= 0 || codec_tag > 15 ) { \n return AVERROR ( ENOSYS ) ; \n } else \n return 0 ; \n }", "idx": 18950}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "void av_thread_message_queue_free ( AVThreadMessageQueue * * mq ) \n { \n #if HAVE_THREADS  \n  \n  if ( * mq ) { \n av_thread_message_flush ( * mq ) ; \n av_fifo_freep ( & ( * mq ) -> fifo ) ; \n pthread_cond_destroy ( & ( * mq ) -> cond ) ; \n pthread_mutex_destroy ( & ( * mq ) -> lock ) ; \n av_freep ( mq ) ; \n } \n #endif \n }", "idx": 18960}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void x8_init_block_index ( MpegEncContext * s ) { \n const int linesize = s -> current_picture . f . linesize [ 0 ] ; \n const int uvlinesize = s -> current_picture . f . linesize [ 1 ] ; \n s -> dest [ 0 ] = s -> current_picture . f . data [ 0 ] ; \n s -> dest [ 1 ] = s -> current_picture . f . data [ 1 ] ; \n s -> dest [ 2 ] = s -> current_picture . f . data [ 2 ] ; \n s -> dest [ 0 ] += s -> mb_y * linesize << 3 ; \n s -> dest [ 1 ] += ( s -> mb_y & ( ~ 1 ) ) * uvlinesize << 2 ; \n s -> dest [ 2 ] += ( s -> mb_y & ( ~ 1 ) ) * uvlinesize << 2 ; \n }", "idx": 18964}
{"project": "FFmpeg", "commit_id": "ae4cffd9fc5bc495692920d646d7d1462315cfa6", "target": 0, "func": "static inline void yuv2packedXinC ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , int dstW , int y ) \n { \n int i ; \n switch ( c -> dstFormat ) \n { \n case IMGFMT_RGB32 : \n case IMGFMT_BGR32 : \n YSCALE_YUV_2_RGBX_C ( uint32_t ) \n ( ( uint32_t * ) dest ) [ i2 + 0 ] = r [ Y1 ] + g [ Y1 ] + b [ Y1 ] ; \n ( ( uint32_t * ) dest ) [ i2 + 1 ] = r [ Y2 ] + g [ Y2 ] + b [ Y2 ] ; \n } \n break ; \n case IMGFMT_RGB24 : \n YSCALE_YUV_2_RGBX_C ( uint8_t ) \n ( ( uint8_t * ) dest ) [ 0 ] = r [ Y1 ] ; \n ( ( uint8_t * ) dest ) [ 1 ] = g [ Y1 ] ; \n ( ( uint8_t * ) dest ) [ 2 ] = b [ Y1 ] ; \n ( ( uint8_t * ) dest ) [ 3 ] = r [ Y2 ] ; \n ( ( uint8_t * ) dest ) [ 4 ] = g [ Y2 ] ; \n ( ( uint8_t * ) dest ) [ 5 ] = b [ Y2 ] ; \n ( ( uint8_t * ) dest ) += 6 ; \n }", "idx": 18976}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void filter_mb_mbaff_edgev ( H264Context * h , uint8_t * pix , int stride , const int16_t bS [ 7 ] , int bsi , int qp ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] ; \n h -> h264dsp . h264_h_loop_filter_luma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_luma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 19028}
{"project": "FFmpeg", "commit_id": "0faf3c3a25ede9ecfdb1cf68a0f8aef23c25197a", "target": 0, "func": "static int cudaupload_query_formats ( AVFilterContext * ctx ) \n { \n static const enum AVPixelFormat input_pix_fmts [ ] = { \n AV_PIX_FMT_NV12 , AV_PIX_FMT_YUV420P , AV_PIX_FMT_YUV444P , \n AV_PIX_FMT_NONE , \n } ; \n static const enum AVPixelFormat output_pix_fmts [ ] = { \n AV_PIX_FMT_CUDA , AV_PIX_FMT_NONE , \n } ; \n AVFilterFormats * in_fmts = ff_make_format_list ( input_pix_fmts ) ; \n AVFilterFormats * out_fmts = ff_make_format_list ( output_pix_fmts ) ; \n ff_formats_ref ( in_fmts , & ctx -> inputs [ 0 ] -> out_formats ) ; \n ff_formats_ref ( out_fmts , & ctx -> outputs [ 0 ] -> in_formats ) ; \n return 0 ; \n }", "idx": 19030}
{"project": "FFmpeg", "commit_id": "6c18f1cda2e2b2471ebf75d30d552cb0cb61b6ad", "target": 0, "func": "static void opt_audio_sample_fmt ( const char * arg ) \n { \n if ( strcmp ( arg , \" \" ) ) \n audio_sample_fmt = av_get_sample_fmt ( arg ) ; \n else { \n list_fmts ( av_get_sample_fmt_string , AV_SAMPLE_FMT_NB ) ; \n ffmpeg_exit ( 0 ) ; \n } \n }", "idx": 19032}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) \n { \n FlatContext * flat = wctx -> priv ; \n AVBPrint buf ; \n flat_print_key_prefix ( wctx ) ; \n av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; \n printf ( \" \" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; \n av_bprint_clear ( & buf ) ; \n printf ( \" \\\" \\\" \\n \" , flat_escape_value_str ( & buf , value ) ) ; \n av_bprint_finalize ( & buf , NULL ) ; \n }", "idx": 19034}
{"project": "FFmpeg", "commit_id": "56838103020385020469d1da076f0e4a6cbe15e5", "target": 1, "func": "static int rm_write_audio ( AVFormatContext * s , const uint8_t * buf , int size , int flags ) \n { \n uint8_t * buf1 ; \n RMMuxContext * rm = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n StreamInfo * stream = rm -> audio_stream ; \n int i ; \n buf1 = av_malloc ( size * sizeof ( uint8_t ) ) ; \n write_packet_header ( s , stream , size , ! ! ( flags & AV_PKT_FLAG_KEY ) ) ; \n if ( stream -> enc -> codec_id == AV_CODEC_ID_AC3 ) { \n for ( i = 0 ; i < size ; i += 2 ) { \n buf1 [ i ] = buf [ i + 1 ] ; \n buf1 [ i + 1 ] = buf [ i ] ; \n } \n avio_write ( pb , buf1 , size ) ; \n } else { \n avio_write ( pb , buf , size ) ; \n } \n stream -> nb_frames ++ ; \n av_free ( buf1 ) ; \n return 0 ; \n }", "idx": 19040}
{"project": "FFmpeg", "commit_id": "0cb7f8a26094c533b7dbe25897198953b6660f15", "target": 1, "func": "int ff_lzw_decode ( LZWState * p , uint8_t * buf , int len ) { \n int l , c , code , oc , fc ; \n uint8_t * sp ; \n struct LZWState * s = ( struct LZWState * ) p ; \n if ( s -> end_code < 0 ) \n return 0 ; \n l = len ; \n sp = s -> sp ; \n oc = s -> oc ; \n fc = s -> fc ; \n for ( ; ; ) { \n while ( sp > s -> stack ) { \n * buf ++ = * ( -- sp ) ; \n if ( ( -- l ) == 0 ) \n goto the_end ; \n } \n c = lzw_get_code ( s ) ; \n if ( c == s -> end_code ) { \n s -> end_code = -1 ; \n break ; \n } else if ( c == s -> clear_code ) { \n s -> cursize = s -> codesize + 1 ; \n s -> curmask = mask [ s -> cursize ] ; \n s -> slot = s -> newcodes ; \n s -> top_slot = 1 << s -> cursize ; \n fc = oc = -1 ; \n } else { \n code = c ; \n if ( code >= s -> slot ) { \n * sp ++ = fc ; \n code = oc ; \n } \n while ( code >= s -> newcodes ) { \n * sp ++ = s -> suffix [ code ] ; \n code = s -> prefix [ code ] ; \n } \n * sp ++ = code ; \n if ( s -> slot < s -> top_slot && oc >= 0 ) { \n s -> suffix [ s -> slot ] = code ; \n s -> prefix [ s -> slot ++ ] = oc ; \n } \n fc = code ; \n oc = c ; \n if ( s -> slot >= s -> top_slot - s -> extra_slot ) { \n if ( s -> cursize < LZW_MAXBITS ) { \n s -> top_slot <<= 1 ; \n s -> curmask = mask [ ++ s -> cursize ] ; \n } \n } \n } \n } \n the_end : \n s -> sp = sp ; \n s -> oc = oc ; \n s -> fc = fc ; \n return len - l ; \n }", "idx": 19046}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_vertical ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n const pixel4 a = ( ( pixel4 * ) ( src - stride ) ) [ 0 ] ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = a ; \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = a ; \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = a ; \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = a ; \n }", "idx": 19049}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void libschroedinger_free_frame ( void * data ) \n { \n FFSchroEncodedFrame * enc_frame = data ; \n av_freep ( & enc_frame -> p_encbuf ) ; \n av_free ( enc_frame ) ; \n }", "idx": 19054}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float quantize_band_cost ( struct AACEncContext * s , const float * in , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits , int rtz ) \n { \n return get_band_cost ( s , NULL , in , scaled , size , scale_idx , cb , lambda , uplim , bits ) ; \n }", "idx": 19055}
{"project": "FFmpeg", "commit_id": "a5e0dbf530d447f36099aed575b34e9258c5d75a", "target": 1, "func": "static void push_output_configuration ( AACContext * ac ) { \n if ( ac -> oc [ 1 ] . status == OC_LOCKED || ac -> oc [ 0 ] . status == OC_NONE ) { \n ac -> oc [ 0 ] = ac -> oc [ 1 ] ; \n } \n ac -> oc [ 1 ] . status = OC_NONE ; \n }", "idx": 19063}
{"project": "FFmpeg", "commit_id": "ac424b23e404a53bb88e36496fac94d2ff9dd775", "target": 1, "func": "pp_context * pp_get_context ( int width , int height , int cpuCaps ) { \n PPContext * c = av_mallocz ( sizeof ( PPContext ) ) ; \n int stride = FFALIGN ( width , 16 ) ; \n int qpStride = ( width + 15 ) / 16 + 2 ; \n c -> av_class = & av_codec_context_class ; \n if ( cpuCaps & PP_FORMAT ) { \n c -> hChromaSubSample = cpuCaps & 0x3 ; \n c -> vChromaSubSample = ( cpuCaps >> 4 ) & 0x3 ; \n } else { \n c -> hChromaSubSample = 1 ; \n c -> vChromaSubSample = 1 ; \n } \n if ( cpuCaps & PP_CPU_CAPS_AUTO ) { \n c -> cpuCaps = av_get_cpu_flags ( ) ; \n } else { \n c -> cpuCaps = 0 ; \n if ( cpuCaps & PP_CPU_CAPS_MMX ) c -> cpuCaps |= AV_CPU_FLAG_MMX ; \n if ( cpuCaps & PP_CPU_CAPS_MMX2 ) c -> cpuCaps |= AV_CPU_FLAG_MMXEXT ; \n if ( cpuCaps & PP_CPU_CAPS_3DNOW ) c -> cpuCaps |= AV_CPU_FLAG_3DNOW ; \n if ( cpuCaps & PP_CPU_CAPS_ALTIVEC ) c -> cpuCaps |= AV_CPU_FLAG_ALTIVEC ; \n } \n reallocBuffers ( c , width , height , stride , qpStride ) ; \n c -> frameNum = -1 ; \n return c ; \n }", "idx": 19066}
{"project": "FFmpeg", "commit_id": "e07c82688e8187dbafac489b7c15427252974021", "target": 1, "func": "static void store_slice_c ( uint8_t * dst , const int16_t * src , \n int dst_stride , int src_stride , \n int width , int height , int log2_scale ) \n { \n int y , x ; \n #define STORE ( pos )  do {                                                     \\ \n   \n  temp = ( ( src [ x + y * src_stride + pos ] << log2_scale ) + d [ pos ] ) >> 8 ; \n if ( temp & 0x100 ) temp = ~ ( temp >> 31 ) ; \n dst [ x + y * dst_stride + pos ] = temp ; \n } while ( 0 ) \n for ( y = 0 ; y < height ; y ++ ) { \n const uint8_t * d = dither [ y & 7 ] ; \n for ( x = 0 ; x < width ; x += 8 ) { \n int temp ; \n STORE ( 0 ) ; \n STORE ( 1 ) ; \n STORE ( 2 ) ; \n STORE ( 3 ) ; \n STORE ( 4 ) ; \n STORE ( 5 ) ; \n STORE ( 6 ) ; \n STORE ( 7 ) ; \n } \n } \n }", "idx": 19067}
{"project": "FFmpeg", "commit_id": "aa3c77998404cc32233cb76e961ca27db8565459", "target": 1, "func": "int av_append_packet ( AVIOContext * s , AVPacket * pkt , int size ) \n { \n int ret ; \n int old_size ; \n if ( ! pkt -> size ) \n return av_get_packet ( s , pkt , size ) ; \n old_size = pkt -> size ; \n ret = av_grow_packet ( pkt , size ) ; \n if ( ret < 0 ) \n return ret ; \n ret = avio_read ( s , pkt -> data + old_size , size ) ; \n av_shrink_packet ( pkt , old_size + FFMAX ( ret , 0 ) ) ; \n return ret ; \n }", "idx": 19073}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void down_heap ( uint32_t nr_heap , uint32_t * heap , uint32_t * weights ) \n { \n uint32_t val = 1 ; \n uint32_t val2 ; \n uint32_t initial_val = heap [ val ] ; \n while ( 1 ) { \n val2 = val << 1 ; \n if ( val2 > nr_heap ) \n break ; \n if ( val2 < nr_heap && weights [ heap [ val2 + 1 ] ] < weights [ heap [ val2 ] ] ) \n val2 ++ ; \n if ( weights [ initial_val ] < weights [ heap [ val2 ] ] ) \n break ; \n heap [ val ] = heap [ val2 ] ; \n val = val2 ; \n } \n heap [ val ] = initial_val ; \n }", "idx": 19077}
{"project": "FFmpeg", "commit_id": "571572fcddc16ebe3d60054ae5a2db05800c1d6d", "target": 1, "func": "void RENAME ( ff_init_mpadsp_tabs ) ( void ) \n { \n int i , j ; \n for ( i = 0 ; i < 36 ; i ++ ) { \n for ( j = 0 ; j < 4 ; j ++ ) { \n double d ; \n if ( j == 2 && i % 3 != 1 ) \n continue ; \n d = sin ( M_PI * ( i + 0.5 ) / 36.0 ) ; \n if ( j == 1 ) { \n if ( i >= 30 ) d = 0 ; \n else if ( i >= 24 ) d = sin ( M_PI * ( i - 18 + 0.5 ) / 12.0 ) ; \n else if ( i >= 18 ) d = 1 ; \n } else if ( j == 3 ) { \n if ( i < 6 ) d = 0 ; \n else if ( i < 12 ) d = sin ( M_PI * ( i - 6 + 0.5 ) / 12.0 ) ; \n else if ( i < 18 ) d = 1 ; \n } \n d *= 0.5 / cos ( M_PI * ( 2 * i + 19 ) / 72 ) ; \n if ( j == 2 ) \n RENAME ( ff_mdct_win ) [ j ] [ i / 3 ] = FIXHR ( ( d / ( 1 << 5 ) ) ) ; \n else { \n int idx = i < 18 ? i : i + ( MDCT_BUF_SIZE / 2 - 18 ) ; \n RENAME ( ff_mdct_win ) [ j ] [ idx ] = FIXHR ( ( d / ( 1 << 5 ) ) ) ; \n } \n } \n } \n for ( j = 0 ; j < 4 ; j ++ ) { \n for ( i = 0 ; i < MDCT_BUF_SIZE ; i += 2 ) { \n RENAME ( ff_mdct_win ) [ j + 4 ] [ i ] = RENAME ( ff_mdct_win ) [ j ] [ i ] ; \n RENAME ( ff_mdct_win ) [ j + 4 ] [ i + 1 ] = - RENAME ( ff_mdct_win ) [ j ] [ i + 1 ] ; \n } \n } \n }", "idx": 19079}
{"project": "FFmpeg", "commit_id": "7a4f74eed51f914e9bbfebaffd4a92ac6791f819", "target": 0, "func": "static void flush_dpb ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n int i ; \n memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ; \n ff_h264_flush_change ( h ) ; \n if ( h -> DPB ) \n for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) \n ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ; \n h -> cur_pic_ptr = NULL ; \n ff_h264_unref_picture ( h , & h -> cur_pic ) ; \n h -> mb_y = 0 ; \n ff_h264_free_tables ( h ) ; \n h -> context_initialized = 0 ; \n }", "idx": 19109}
{"project": "FFmpeg", "commit_id": "f56fe04de3cc4cdc6b618dfe7a3506fc2ea79795", "target": 0, "func": "void ff_mqc_init_contexts ( MqcState * mqc ) \n { \n int i ; \n memset ( mqc -> cx_states , 0 , sizeof ( mqc -> cx_states ) ) ; \n mqc -> cx_states [ MQC_CX_UNI ] = 2 * 46 ; \n mqc -> cx_states [ MQC_CX_RL ] = 2 * 3 ; \n mqc -> cx_states [ 0 ] = 2 * 4 ; \n for ( i = 0 ; i < 47 ; i ++ ) { \n ff_mqc_qe [ 2 * i ] = \n ff_mqc_qe [ 2 * i + 1 ] = cx_states [ i ] . qe ; \n ff_mqc_nlps [ 2 * i ] = 2 * cx_states [ i ] . nlps + cx_states [ i ] . sw ; \n ff_mqc_nlps [ 2 * i + 1 ] = 2 * cx_states [ i ] . nlps + 1 - cx_states [ i ] . sw ; \n ff_mqc_nmps [ 2 * i ] = 2 * cx_states [ i ] . nmps ; \n ff_mqc_nmps [ 2 * i + 1 ] = 2 * cx_states [ i ] . nmps + 1 ; \n } \n }", "idx": 19124}
{"project": "FFmpeg", "commit_id": "dcb2fb79b731d64eb3c268b9413b75f506861138", "target": 0, "func": "matroska_ebmlnum_uint ( uint8_t * data , \n uint32_t size , \n uint64_t * num )  \n { \n int len_mask = 0x80 , read = 1 , n = 1 , num_ffs = 0 ; \n uint64_t total ; \n if ( size <= 0 ) \n return AVERROR_INVALIDDATA ; \n total = data [ 0 ] ; \n while ( read <= 8 && ! ( total & len_mask ) ) { \n read ++ ; \n len_mask >>= 1 ; \n } \n if ( read > 8 ) \n return AVERROR_INVALIDDATA ; \n if ( ( total &= ( len_mask - 1 ) ) == len_mask - 1 ) \n num_ffs ++ ; \n if ( size < read ) \n return AVERROR_INVALIDDATA ; \n while ( n < read ) { \n if ( data [ n ] == 0xff ) \n num_ffs ++ ; \n total = ( total << 8 ) | data [ n ] ; \n n ++ ; \n } \n if ( ! total ) \n return AVERROR_INVALIDDATA ; \n if ( read == num_ffs ) \n * num = ( uint64_t ) -1 ; \n else \n * num = total ; \n return read ; \n }", "idx": 19146}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static PayloadContext * vorbis_new_extradata ( void ) \n { \n return av_mallocz ( sizeof ( PayloadContext ) ) ; \n }", "idx": 19147}
{"project": "FFmpeg", "commit_id": "d23727e0420b9f77f0d4cb28b43819b402f702e5", "target": 1, "func": "static int adx_decode ( ADXContext * c , int16_t * out , int offset , \n const uint8_t * in , int ch ) \n { \n ADXChannelState * prev = & c -> prev [ ch ] ; \n GetBitContext gb ; \n int scale = AV_RB16 ( in ) ; \n int i ; \n int s0 , s1 , s2 , d ; \n if ( scale & 0x8000 ) \n return -1 ; \n init_get_bits ( & gb , in + 2 , ( BLOCK_SIZE - 2 ) * 8 ) ; \n out += offset ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < BLOCK_SAMPLES ; i ++ ) { \n d = get_sbits ( & gb , 4 ) ; \n s0 = ( ( d << COEFF_BITS ) * scale + c -> coeff [ 0 ] * s1 + c -> coeff [ 1 ] * s2 ) >> COEFF_BITS ; \n s2 = s1 ; \n s1 = av_clip_int16 ( s0 ) ; \n * out ++ = s1 ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n return 0 ; \n }", "idx": 19158}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int mkv_write_tag ( AVFormatContext * s , AVDictionary * m , unsigned int elementid , \n unsigned int uid , ebml_master * tags ) \n { \n MatroskaMuxContext * mkv = s -> priv_data ; \n ebml_master tag , targets ; \n AVDictionaryEntry * t = NULL ; \n int ret ; \n if ( ! tags -> pos ) { \n ret = mkv_add_seekhead_entry ( mkv -> main_seekhead , MATROSKA_ID_TAGS , avio_tell ( s -> pb ) ) ; \n if ( ret < 0 ) return ret ; \n * tags = start_ebml_master ( s -> pb , MATROSKA_ID_TAGS , 0 ) ; \n } \n tag = start_ebml_master ( s -> pb , MATROSKA_ID_TAG , 0 ) ; \n targets = start_ebml_master ( s -> pb , MATROSKA_ID_TAGTARGETS , 0 ) ; \n if ( elementid ) \n put_ebml_uint ( s -> pb , elementid , uid ) ; \n end_ebml_master ( s -> pb , targets ) ; \n while ( ( t = av_dict_get ( m , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) \n if ( av_strcasecmp ( t -> key , \" \" ) && \n av_strcasecmp ( t -> key , \" \" ) ) \n mkv_write_simpletag ( s -> pb , t ) ; \n end_ebml_master ( s -> pb , tag ) ; \n return 0 ; \n }", "idx": 19169}
{"project": "FFmpeg", "commit_id": "ede0a5f9734cca077992a88b1da3e1596f252f94", "target": 0, "func": "static int rv34_set_deblock_coef ( RV34DecContext * r ) \n { \n MpegEncContext * s = & r -> s ; \n int mvmask = 0 , i , j ; \n int midx = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ; \n int16_t ( * motion_val ) [ 2 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ midx ] ; \n if ( s -> pict_type == FF_I_TYPE ) \n return 0 ; \n for ( j = 0 ; j < 16 ; j += 8 ) { \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( is_mv_diff_gt_3 ( motion_val + i , 1 ) ) \n mvmask |= 0x11 << ( j + i * 2 ) ; \n if ( is_mv_diff_gt_3 ( motion_val + i , s -> b8_stride ) ) \n mvmask |= 0x03 << ( j + i * 2 ) ; \n } \n motion_val += s -> b8_stride ; \n } \n return mvmask ; \n }", "idx": 19171}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static int avg_bits_per_pixel ( int pix_fmt ) \n { \n int bits ; \n const PixFmtInfo * pf ; \n pf = & pix_fmt_info [ pix_fmt ] ; \n if ( pf -> is_packed ) { \n switch ( pix_fmt ) { \n case PIX_FMT_RGB24 : \n case PIX_FMT_BGR24 : \n bits = 24 ; \n break ; \n case PIX_FMT_RGBA32 : \n bits = 32 ; \n break ; \n case PIX_FMT_RGB565 : \n case PIX_FMT_RGB555 : \n bits = 16 ; \n break ; \n case PIX_FMT_PAL8 : \n bits = 8 ; \n break ; \n default : \n bits = 32 ; \n break ; \n } \n } else { \n bits = pf -> depth ; \n bits += ( 2 * pf -> depth >> \n ( pf -> x_chroma_shift + pf -> x_chroma_shift ) ) ; \n } \n return bits ; \n }", "idx": 19195}
{"project": "FFmpeg", "commit_id": "fb845ffdd335a1efd6dfd43e8adeb530397b348e", "target": 1, "func": "static inline int get_lowest_part_list_y ( H264Context * h , Picture * pic , int n , \n int height , int y_offset , int list ) \n { \n int raw_my = h -> mv_cache [ list ] [ scan8 [ n ] ] [ 1 ] ; \n int filter_height = ( raw_my & 3 ) ? 2 : 0 ; \n int full_my = ( raw_my >> 2 ) + y_offset ; \n int top = full_my - filter_height ; \n int bottom = full_my + filter_height + height ; \n return FFMAX ( abs ( top ) , bottom ) ; \n }", "idx": 19214}
{"project": "FFmpeg", "commit_id": "5a396bb3a66a61a68b80f2369d0249729bf85e04", "target": 1, "func": "int avpriv_dv_produce_packet ( DVDemuxContext * c , AVPacket * pkt , \n uint8_t * buf , int buf_size ) \n { \n int size , i ; \n uint8_t * ppcm [ 4 ] = { 0 } ; \n if ( buf_size < DV_PROFILE_BYTES || \n ! ( c -> sys = avpriv_dv_frame_profile ( c -> sys , buf , buf_size ) ) || \n buf_size < c -> sys -> frame_size ) { \n return -1 ; \n } \n size = dv_extract_audio_info ( c , buf ) ; \n for ( i = 0 ; i < c -> ach ; i ++ ) { \n c -> audio_pkt [ i ] . size = size ; \n c -> audio_pkt [ i ] . pts = c -> abytes * 30000 * 8 / c -> ast [ i ] -> codec -> bit_rate ; \n ppcm [ i ] = c -> audio_buf [ i ] ; \n } \n dv_extract_audio ( buf , ppcm , c -> sys ) ; \n if ( c -> sys -> height == 720 ) { \n if ( buf [ 1 ] & 0x0C ) { \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n } else { \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n c -> abytes += size ; \n } \n } else { \n c -> abytes += size ; \n } \n size = dv_extract_video_info ( c , buf ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = buf ; \n pkt -> size = size ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> stream_index = c -> vst -> id ; \n pkt -> pts = c -> frames ; \n c -> frames ++ ; \n return size ; \n }", "idx": 19215}
{"project": "FFmpeg", "commit_id": "b89815f5199fd5e9a2d21417f827bf7c57244e84", "target": 1, "func": "static int parse_audio_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) \n { \n AVIOContext * pb = avctx -> pb ; \n if ( ! strcmp ( name , \" \" ) ) { \n st -> nb_frames = var_read_int ( pb , size ) ; \n } else if ( ! strcmp ( name , \" \" ) ) { \n st -> codec -> codec_id = var_read_int ( pb , size ) ; \n } else if ( ! strcmp ( name , \" \" ) ) { \n st -> codec -> codec_tag = var_read_int ( pb , size ) ; \n } else if ( ! strcmp ( name , \" \" ) ) { \n var_read_metadata ( avctx , name , size ) ; \n } else if ( ! strcmp ( name , \" \" ) ) { \n st -> codec -> channels = var_read_int ( pb , size ) ; \n st -> codec -> channel_layout = ( st -> codec -> channels == 1 ) ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO ; \n } else if ( ! strcmp ( name , \" \" ) ) { \n st -> codec -> sample_rate = var_read_int ( pb , size ) ; \n avpriv_set_pts_info ( st , 33 , 1 , st -> codec -> sample_rate ) ; \n } else if ( ! strcmp ( name , \" \" ) ) { \n st -> codec -> bits_per_coded_sample = var_read_int ( pb , size ) * 8 ; \n } else \n return -1 ; \n return 0 ; \n }", "idx": 19228}
{"project": "FFmpeg", "commit_id": "dbe29db8cb09fb39bd8dc5b25934e92279d0aa8d", "target": 1, "func": "static int decode_band_types ( AACContext * ac , enum BandType band_type [ 120 ] , \n int band_type_run_end [ 120 ] , GetBitContext * gb , \n IndividualChannelStream * ics ) \n { \n int g , idx = 0 ; \n const int bits = ( ics -> window_sequence [ 0 ] == EIGHT_SHORT_SEQUENCE ) ? 3 : 5 ; \n for ( g = 0 ; g < ics -> num_window_groups ; g ++ ) { \n int k = 0 ; \n while ( k < ics -> max_sfb ) { \n uint8_t sect_end = k ; \n int sect_len_incr ; \n int sect_band_type = get_bits ( gb , 4 ) ; \n if ( sect_band_type == 12 ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n do { \n sect_len_incr = get_bits ( gb , bits ) ; \n sect_end += sect_len_incr ; \n if ( get_bits_left ( gb ) < 0 ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , overread_err ) ; \n return -1 ; \n } \n if ( sect_end > ics -> max_sfb ) { \n av_log ( ac -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n sect_end , ics -> max_sfb ) ; \n return -1 ; \n } \n } while ( sect_len_incr == ( 1 << bits ) - 1 ) ; \n for ( ; k < sect_end ; k ++ ) { \n band_type [ idx ] = sect_band_type ; \n band_type_run_end [ idx ++ ] = sect_end ; \n } \n } \n } \n return 0 ; \n }", "idx": 19230}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_compose53i_dy_buffered ( dwt_compose_t * cs , slice_buffer * sb , int width , int height , int stride_line ) { \n int y = cs -> y ; \n int mirror0 = mirror ( y - 1 , height - 1 ) ; \n int mirror1 = mirror ( y , height - 1 ) ; \n int mirror2 = mirror ( y + 1 , height - 1 ) ; \n int mirror3 = mirror ( y + 2 , height - 1 ) ; \n DWTELEM * b0 = cs -> b0 ; \n DWTELEM * b1 = cs -> b1 ; \n DWTELEM * b2 = slice_buffer_get_line ( sb , mirror2 * stride_line ) ; \n DWTELEM * b3 = slice_buffer_get_line ( sb , mirror3 * stride_line ) ; \n { START_TIMER \n if ( mirror1 <= mirror3 )  vertical_compose53iL0 ( b1 , b2 , b3 , width ) ; \n if ( mirror0 <= mirror2 ) vertical_compose53iH0 ( b0 , b1 , b2 , width ) ; \n STOP_TIMER ( \" \" )  } \n { START_TIMER \n if ( y -1 >= 0 )  horizontal_compose53i ( b0 , width ) ; \n if ( mirror0 <= mirror2 ) horizontal_compose53i ( b1 , width ) ; \n STOP_TIMER ( \" \" )  } \n cs -> b0 = b2 ; \n cs -> b1 = b3 ; \n cs -> y += 2 ; \n }", "idx": 19244}
{"project": "FFmpeg", "commit_id": "99f296b30462e6b940aff712920a3fe6b8ba5cc6", "target": 0, "func": "static int gxf_packet ( AVFormatContext * s , AVPacket * pkt ) { \n ByteIOContext * pb = s -> pb ; \n pkt_type_t pkt_type ; \n int pkt_len ; \n while ( ! url_feof ( pb ) ) { \n int track_type , track_id , ret ; \n int field_nr ; \n int stream_index ; \n if ( ! parse_packet_header ( pb , & pkt_type , & pkt_len ) ) { \n if ( ! url_feof ( pb ) ) \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( pkt_type == PKT_FLT ) { \n gxf_read_index ( s , pkt_len ) ; \n continue ; \n } \n if ( pkt_type != PKT_MEDIA ) { \n url_fskip ( pb , pkt_len ) ; \n continue ; \n } \n if ( pkt_len < 16 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n continue ; \n } \n pkt_len -= 16 ; \n track_type = get_byte ( pb ) ; \n track_id = get_byte ( pb ) ; \n stream_index = get_sindex ( s , track_id , track_type ) ; \n if ( stream_index < 0 ) \n return stream_index ; \n field_nr = get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; \n ret = av_get_packet ( pb , pkt , pkt_len ) ; \n pkt -> stream_index = stream_index ; \n pkt -> dts = field_nr ; \n return ret ; \n } \n return AVERROR ( EIO ) ; \n }", "idx": 19258}
{"project": "FFmpeg", "commit_id": "1c6183233d56fb27a4a154e7e64ecab98bd877f1", "target": 0, "func": "static av_cold void init_mv_table ( MVTable * tab ) \n { \n int i , x , y ; \n tab -> table_mv_index = av_malloc ( sizeof ( uint16_t ) * 4096 ) ; \n for ( i = 0 ; i < 4096 ; i ++ ) \n tab -> table_mv_index [ i ] = tab -> n ; \n for ( i = 0 ; i < tab -> n ; i ++ ) { \n x = tab -> table_mvx [ i ] ; \n y = tab -> table_mvy [ i ] ; \n tab -> table_mv_index [ ( x << 6 ) | y ] = i ; \n } \n }", "idx": 19293}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int xvid_strip_vol_header ( AVCodecContext * avctx , \n AVPacket * pkt , \n unsigned int header_len , \n unsigned int frame_len ) { \n int vo_len = 0 , i ; \n for ( i = 0 ; i < header_len - 3 ; i ++ ) { \n if ( pkt -> data [ i ] == 0x00 && \n pkt -> data [ i + 1 ] == 0x00 && \n pkt -> data [ i + 2 ] == 0x01 && \n pkt -> data [ i + 3 ] == 0xB6 ) { \n vo_len = i ; \n break ; \n } \n } \n if ( vo_len > 0 ) { \n if ( avctx -> extradata == NULL ) { \n avctx -> extradata = av_malloc ( vo_len ) ; \n memcpy ( avctx -> extradata , pkt -> data , vo_len ) ; \n avctx -> extradata_size = vo_len ; \n } \n memmove ( pkt -> data , & pkt -> data [ vo_len ] , frame_len - vo_len ) ; \n pkt -> size = frame_len - vo_len ; \n } \n return 0 ; \n }", "idx": 19304}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC ( ff_simple_idct_add ) ( uint8_t * dest_ , int line_size , DCTELEM * block ) \n { \n pixel * dest = ( pixel * ) dest_ ; \n int i ; \n line_size /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 8 ; i ++ ) \n FUNC ( idctRowCondDC ) ( block + i * 8 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) \n FUNC ( idctSparseColAdd ) ( dest + i , line_size , block + i ) ; \n }", "idx": 19314}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int setup_partitions ( VP8Context * s , const uint8_t * buf , int buf_size ) \n { \n const uint8_t * sizes = buf ; \n int i ; \n s -> num_coeff_partitions = 1 << vp8_rac_get_uint ( & s -> c , 2 ) ; \n buf += 3 * ( s -> num_coeff_partitions - 1 ) ; \n buf_size -= 3 * ( s -> num_coeff_partitions - 1 ) ; \n if ( buf_size < 0 ) \n return -1 ; \n for ( i = 0 ; i < s -> num_coeff_partitions - 1 ; i ++ ) { \n int size = AV_RL24 ( sizes + 3 * i ) ; \n if ( buf_size - size < 0 ) \n return -1 ; \n ff_vp56_init_range_decoder ( & s -> coeff_partition [ i ] , buf , size ) ; \n buf += size ; \n buf_size -= size ; \n } \n ff_vp56_init_range_decoder ( & s -> coeff_partition [ i ] , buf , buf_size ) ; \n return 0 ; \n }", "idx": 19316}
{"project": "FFmpeg", "commit_id": "e0706e9cc8f30a8242d2b140edace7bf76170506", "target": 0, "func": "static int get_rice_un ( GetBitContext * gb , int k ) \n { \n unsigned int v = get_unary ( gb , 1 , 128 ) ; \n return ( v << k ) | get_bits_long ( gb , k ) ; \n }", "idx": 19319}
{"project": "FFmpeg", "commit_id": "bf00a73ace9b1aba790b75dcb26d43adfceb769f", "target": 0, "func": "static void qmf_32_subbands ( DCAContext * s , int chans , \n float samples_in [ 32 ] [ 8 ] , float * samples_out , \n float scale ) \n { \n const float * prCoeff ; \n int i ; \n int sb_act = s -> subband_activity [ chans ] ; \n int subindex ; \n scale *= sqrt ( 1 / 8.0 ) ; \n if ( ! s -> multirate_inter ) \n prCoeff = fir_32bands_nonperfect ; \n else \n prCoeff = fir_32bands_perfect ; \n for ( subindex = 0 ; subindex < 8 ; subindex ++ ) { \n for ( i = 0 ; i < sb_act ; i ++ ) { \n uint32_t v = AV_RN32A ( & samples_in [ i ] [ subindex ] ) ^ ( ( i - 1 ) & 2 ) << 30 ; \n AV_WN32A ( & s -> raXin [ i ] , v ) ; \n } \n for ( ; i < 32 ; i ++ ) \n s -> raXin [ i ] = 0.0 ; \n s -> synth . synth_filter_float ( & s -> imdct , \n s -> subband_fir_hist [ chans ] , & s -> hist_index [ chans ] , \n s -> subband_fir_noidea [ chans ] , prCoeff , \n samples_out , s -> raXin , scale ) ; \n samples_out += 32 ; \n } \n }", "idx": 19320}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int64_t av_get_channel_layout ( const char * name ) \n { \n int i = 0 ; \n do { \n if ( ! strcmp ( channel_layout_map [ i ] . name , name ) ) \n return channel_layout_map [ i ] . layout ; \n i ++ ; \n } while ( channel_layout_map [ i ] . name ) ; \n return 0 ; \n }", "idx": 19323}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int vmdvideo_decode_init ( AVCodecContext * avctx ) \n { \n VmdVideoContext * s = avctx -> priv_data ; \n int i ; \n unsigned int * palette32 ; \n int palette_index = 0 ; \n unsigned char r , g , b ; \n unsigned char * vmd_header ; \n unsigned char * raw_palette ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n if ( s -> avctx -> extradata_size != VMD_HEADER_SIZE ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n VMD_HEADER_SIZE ) ; \n return -1 ; \n } \n vmd_header = ( unsigned char * ) avctx -> extradata ; \n s -> unpack_buffer_size = AV_RL32 ( & vmd_header [ 800 ] ) ; \n s -> unpack_buffer = av_malloc ( s -> unpack_buffer_size ) ; \n if ( ! s -> unpack_buffer ) \n return -1 ; \n raw_palette = & vmd_header [ 28 ] ; \n palette32 = ( unsigned int * ) s -> palette ; \n for ( i = 0 ; i < PALETTE_COUNT ; i ++ ) { \n r = raw_palette [ palette_index ++ ] * 4 ; \n g = raw_palette [ palette_index ++ ] * 4 ; \n b = raw_palette [ palette_index ++ ] * 4 ; \n palette32 [ i ] = ( r << 16 ) | ( g << 8 ) | ( b ) ; \n } \n s -> frame . data [ 0 ] = s -> prev_frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 19334}
{"project": "FFmpeg", "commit_id": "474d858fd9551b45a17e1f3a4322de1a88e749b9", "target": 0, "func": "static void set_port ( struct sockaddr_storage * ss , int port ) \n { \n sockaddr_union ssu = ( sockaddr_union ) { . storage = * ss } ; \n if ( ss -> ss_family == AF_INET ) \n ssu . in . sin_port = htons ( port ) ; \n #if HAVE_STRUCT_SOCKADDR_IN6  \n  \n  else if ( ss -> ss_family == AF_INET6 )  \n ssu . in6 . sin6_port = htons ( port ) ; \n #endif \n * ss = ssu . storage ; \n }", "idx": 19345}
{"project": "FFmpeg", "commit_id": "1ac5abb1d062b6ca983d494068bb9fd30390a941", "target": 1, "func": "static void store_slice16_c ( uint16_t * dst , const uint16_t * src , \n int dst_linesize , int src_linesize , \n int width , int height , int log2_scale , \n const uint8_t dither [ 8 ] [ 8 ] ) \n { \n int y , x ; \n #define STORE16 ( pos )  do {                                                   \\ \n   \n  temp = ( ( src [ x + y * src_linesize + pos ] << log2_scale ) + ( d [ pos ] >> 1 ) ) >> 5 ; \n if ( temp & 0x400 ) \n temp = ~ ( temp >> 31 ) ; \n dst [ x + y * dst_linesize + pos ] = temp ; \n } while ( 0 ) \n for ( y = 0 ; y < height ; y ++ ) { \n const uint8_t * d = dither [ y ] ; \n for ( x = 0 ; x < width ; x += 8 ) { \n int temp ; \n STORE16 ( 0 ) ; \n STORE16 ( 1 ) ; \n STORE16 ( 2 ) ; \n STORE16 ( 3 ) ; \n STORE16 ( 4 ) ; \n STORE16 ( 5 ) ; \n STORE16 ( 6 ) ; \n STORE16 ( 7 ) ; \n } \n } \n }", "idx": 19352}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_pngdsp_init_x86 ( PNGDSPContext * dsp ) \n { \n #if HAVE_YASM  \n  \n  int flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( flags & AV_CPU_FLAG_MMX ) \n dsp -> add_bytes_l2 = ff_add_bytes_l2_mmx ; \n #endif \n if ( flags & AV_CPU_FLAG_MMXEXT ) \n dsp -> add_paeth_prediction = ff_add_png_paeth_prediction_mmx2 ; \n if ( flags & AV_CPU_FLAG_SSE2 ) \n dsp -> add_bytes_l2 = ff_add_bytes_l2_sse2 ; \n if ( flags & AV_CPU_FLAG_SSSE3 ) \n dsp -> add_paeth_prediction = ff_add_png_paeth_prediction_ssse3 ; \n #endif \n }", "idx": 19360}
{"project": "FFmpeg", "commit_id": "464ccb01447b91717cf580b870e636514701ce4f", "target": 1, "func": "static int decode_plane ( Indeo3DecodeContext * ctx , AVCodecContext * avctx , \n Plane * plane , const uint8_t * data , int32_t data_size , \n int32_t strip_width ) \n { \n Cell curr_cell ; \n int num_vectors ; \n num_vectors = bytestream_get_le32 ( & data ) ; \n ctx -> mc_vectors = num_vectors ? data : 0 ; \n init_get_bits ( & ctx -> gb , & data [ num_vectors * 2 ] , data_size << 3 ) ; \n ctx -> skip_bits = 0 ; \n ctx -> need_resync = 0 ; \n ctx -> last_byte = data + data_size - 1 ; \n curr_cell . xpos = curr_cell . ypos = 0 ; \n curr_cell . width = plane -> width >> 2 ; \n curr_cell . height = plane -> height >> 2 ; \n curr_cell . tree = 0 ; \n curr_cell . mv_ptr = 0 ; \n return parse_bintree ( ctx , avctx , plane , INTRA_NULL , & curr_cell , CELL_STACK_MAX , strip_width ) ; \n }", "idx": 19362}
{"project": "FFmpeg", "commit_id": "28215b3700723da0c0beb93945702b6fb2b3596d", "target": 1, "func": "void ff_float_init_arm_vfp ( DSPContext * c , AVCodecContext * avctx ) \n { \n c -> vector_fmul = vector_fmul_vfp ; \n c -> vector_fmul_reverse = vector_fmul_reverse_vfp ; \n #ifdef HAVE_ARMV6 \n c -> float_to_int16 = float_to_int16_vfp ; \n #endif \n }", "idx": 19365}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void rv34_idct_dc_add_c ( uint8_t * dst , ptrdiff_t stride , int dc ) \n { \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i , j ; \n cm += ( 13 * 13 * dc + 0x200 ) >> 10 ; \n for ( i = 0 ; i < 4 ; i ++ ) \n { \n for ( j = 0 ; j < 4 ; j ++ ) \n dst [ j ] = cm [ dst [ j ] ] ; \n dst += stride ; \n } \n }", "idx": 19393}
{"project": "FFmpeg", "commit_id": "28bf81c90d36a55cf76e2be913c5215ebebf61f2", "target": 1, "func": "void SwScale_Init ( ) { \n int i ; \n for ( i = 0 ; i < 768 ; i ++ ) { \n int c = MIN ( MAX ( i - 256 , 0 ) , 255 ) ; \n clip_table [ i ] = c ; \n yuvtab_2568 [ c ] = clip_yuvtab_2568 [ i ] = ( 0x2568 * ( c - 16 ) ) + ( 256 << 13 ) ; \n yuvtab_3343 [ c ] = clip_yuvtab_3343 [ i ] = 0x3343 * ( c - 128 ) ; \n yuvtab_0c92 [ c ] = clip_yuvtab_0c92 [ i ] = -0x0c92 * ( c - 128 ) ; \n yuvtab_1a1e [ c ] = clip_yuvtab_1a1e [ i ] = -0x1a1e * ( c - 128 ) ; \n yuvtab_40cf [ c ] = clip_yuvtab_40cf [ i ] = 0x40cf * ( c - 128 ) ; \n } \n for ( i = 0 ; i < 768 ; i ++ ) \n { \n int v = clip_table [ i ] ; \n clip_table16b [ i ] = v >> 3 ; \n clip_table16g [ i ] = ( v << 3 ) & 0x07E0 ; \n clip_table16r [ i ] = ( v << 8 ) & 0xF800 ; \n clip_table15b [ i ] = v >> 3 ; \n clip_table15g [ i ] = ( v << 2 ) & 0x03E0 ; \n clip_table15r [ i ] = ( v << 7 ) & 0x7C00 ; \n } \n }", "idx": 19396}
{"project": "FFmpeg", "commit_id": "1ba08c94f5bb4d1c3c2d3651b5e01edb4ce172e2", "target": 1, "func": "static float * put_vector ( vorbis_enc_codebook * book , PutBitContext * pb , \n float * num ) \n { \n int i , entry = -1 ; \n float distance = FLT_MAX ; \n assert ( book -> dimentions ) ; \n for ( i = 0 ; i < book -> nentries ; i ++ ) { \n float * vec = book -> dimentions + i * book -> ndimentions , d = book -> pow2 [ i ] ; \n int j ; \n if ( ! book -> lens [ i ] ) \n continue ; \n for ( j = 0 ; j < book -> ndimentions ; j ++ ) \n d -= vec [ j ] * num [ j ] ; \n if ( distance > d ) { \n entry = i ; \n distance = d ; \n } \n } \n put_codeword ( pb , book , entry ) ; \n return & book -> dimentions [ entry * book -> ndimentions ] ; \n }", "idx": 19399}
{"project": "FFmpeg", "commit_id": "94d4237a7a294ce80e1e577b38e9c93e8882aff9", "target": 0, "func": "static av_always_inline int coeff_abs_level_remaining_decode ( HEVCContext * s , int rc_rice_param ) \n { \n int prefix = 0 ; \n int suffix = 0 ; \n int last_coeff_abs_level_remaining ; \n int i ; \n while ( prefix < CABAC_MAX_BIN && get_cabac_bypass ( & s -> HEVClc -> cc ) ) \n prefix ++ ; \n if ( prefix == CABAC_MAX_BIN ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , prefix ) ; \n return 0 ; \n } \n if ( prefix < 3 ) { \n for ( i = 0 ; i < rc_rice_param ; i ++ ) \n suffix = ( suffix << 1 ) | get_cabac_bypass ( & s -> HEVClc -> cc ) ; \n last_coeff_abs_level_remaining = ( prefix << rc_rice_param ) + suffix ; \n } else { \n int prefix_minus3 = prefix - 3 ; \n for ( i = 0 ; i < prefix_minus3 + rc_rice_param ; i ++ ) \n suffix = ( suffix << 1 ) | get_cabac_bypass ( & s -> HEVClc -> cc ) ; \n last_coeff_abs_level_remaining = ( ( ( 1 << prefix_minus3 ) + 3 - 1 ) \n << rc_rice_param ) + suffix ; \n } \n return last_coeff_abs_level_remaining ; \n }", "idx": 19407}
{"project": "FFmpeg", "commit_id": "e1a43a414677258b1e01d3f9a8f40bfc74be4223", "target": 0, "func": "AVFilterContext * avfilter_graph_get_filter ( AVFilterGraph * graph , char * name ) \n { \n int i ; \n if ( ! name ) \n return NULL ; \n for ( i = 0 ; i < graph -> filter_count ; i ++ ) \n if ( graph -> filters [ i ] -> name && ! strcmp ( name , graph -> filters [ i ] -> name ) ) \n return graph -> filters [ i ] ; \n return NULL ; \n }", "idx": 19410}
{"project": "FFmpeg", "commit_id": "79a54f30c8ba02cbf2b02c650120246b260977ec", "target": 1, "func": "static int compensate_volume ( AVFilterContext * ctx ) \n { \n struct SOFAlizerContext * s = ctx -> priv ; \n float compensate ; \n float energy = 0 ; \n float * ir ; \n int m ; \n if ( s -> sofa . ncid ) { \n struct NCSofa * sofa = & s -> sofa ; \n m = find_m ( s , 0 , 0 , 1 ) ; \n ir = sofa -> data_ir + 2 * m * sofa -> n_samples ; \n if ( sofa -> n_samples & 31 ) { \n energy = avpriv_scalarproduct_float_c ( ir , ir , sofa -> n_samples ) ; \n } else { \n energy = s -> fdsp -> scalarproduct_float ( ir , ir , sofa -> n_samples ) ; \n } \n compensate = 256 / ( sofa -> n_samples * sqrt ( energy ) ) ; \n av_log ( ctx , AV_LOG_DEBUG , \" \\n \" , compensate ) ; \n ir = sofa -> data_ir ; \n s -> fdsp -> vector_fmul_scalar ( ir , ir , compensate , sofa -> n_samples * sofa -> m_dim * 2 ) ; \n emms_c ( ) ; \n } \n return 0 ; \n }", "idx": 19424}
{"project": "FFmpeg", "commit_id": "6899e6e56065d9365963e02690dc9e2ce7866050", "target": 1, "func": "static int get_delayed_pic ( DiracContext * s , AVFrame * picture , int * got_frame ) \n { \n DiracFrame * out = s -> delay_frames [ 0 ] ; \n int i , out_idx = 0 ; \n int ret ; \n for ( i = 1 ; s -> delay_frames [ i ] ; i ++ ) \n if ( s -> delay_frames [ i ] -> avframe -> display_picture_number < out -> avframe -> display_picture_number ) { \n out = s -> delay_frames [ i ] ; \n out_idx = i ; \n } \n for ( i = out_idx ; s -> delay_frames [ i ] ; i ++ ) \n s -> delay_frames [ i ] = s -> delay_frames [ i + 1 ] ; \n if ( out ) { \n out -> reference ^= DELAYED_PIC_REF ; \n * got_frame = 1 ; \n if ( ( ret = av_frame_ref ( picture , out -> avframe ) ) < 0 ) \n return ret ; \n } \n return 0 ; \n }", "idx": 19428}
{"project": "FFmpeg", "commit_id": "515b69f8f8e9a24cfaee95d8c1f63f265d8582fe", "target": 0, "func": "void checkasm_check_h264qpel ( void ) \n { \n LOCAL_ALIGNED_16 ( uint8_t , buf0 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_16 ( uint8_t , buf1 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_16 ( uint8_t , dst0 ,  [ BUF_SIZE ] ) ; \n LOCAL_ALIGNED_16 ( uint8_t , dst1 ,  [ BUF_SIZE ] ) ; \n H264QpelContext h ; \n int op , bit_depth , i , j ; \n for ( op = 0 ; op < 2 ; op ++ ) { \n qpel_mc_func ( * tab ) [ 16 ] = op ? h . avg_h264_qpel_pixels_tab : h . put_h264_qpel_pixels_tab ; \n const char * op_name = op ? \" \" : \" \" ; \n for ( bit_depth = 8 ; bit_depth <= 10 ; bit_depth ++ ) { \n ff_h264qpel_init ( & h , bit_depth ) ; \n for ( i = 0 ; i < ( op ? 3 : 4 ) ; i ++ ) { \n int size = 16 >> i ; \n for ( j = 0 ; j < 16 ; j ++ ) \n if ( check_func ( tab [ i ] [ j ] , \" \" , op_name , size , j & 3 , j >> 2 , bit_depth ) ) { \n randomize_buffers ( ) ; \n call_ref ( dst0 , src0 , ( ptrdiff_t ) size * SIZEOF_PIXEL ) ; \n call_new ( dst1 , src1 , ( ptrdiff_t ) size * SIZEOF_PIXEL ) ; \n if ( memcmp ( buf0 , buf1 , BUF_SIZE ) || memcmp ( dst0 , dst1 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( dst1 , src1 , ( ptrdiff_t ) size * SIZEOF_PIXEL ) ; \n } \n } \n } \n report ( \" \" , op_name ) ; \n } \n }", "idx": 19436}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "static void copy_context_before_encode ( MpegEncContext * d , MpegEncContext * s , int type ) { \n int i ; \n memcpy ( d -> last_mv , s -> last_mv , 2 * 2 * 2 * sizeof ( int ) ) ; \n d -> mb_incr = s -> mb_incr ; \n for ( i = 0 ; i < 3 ; i ++ ) \n d -> last_dc [ i ] = s -> last_dc [ i ] ; \n d -> mv_bits = s -> mv_bits ; \n d -> i_tex_bits = s -> i_tex_bits ; \n d -> p_tex_bits = s -> p_tex_bits ; \n d -> i_count = s -> i_count ; \n d -> p_count = s -> p_count ; \n d -> skip_count = s -> skip_count ; \n d -> misc_bits = s -> misc_bits ; \n d -> last_bits = 0 ; \n d -> mb_skiped = s -> mb_skiped ; \n }", "idx": 19439}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_bits ( Jpeg2000DecoderContext * s , int n ) \n { \n int res = 0 ; \n if ( s -> buf_end - s -> buf < ( ( n - s -> bit_index ) >> 8 ) ) \n return AVERROR ( EINVAL ) ; \n while ( -- n >= 0 ) { \n res <<= 1 ; \n if ( s -> bit_index == 0 ) { \n s -> bit_index = 7 + ( * s -> buf != 0xff ) ; \n s -> buf ++ ; \n } \n s -> bit_index -- ; \n res |= ( * s -> buf >> s -> bit_index ) & 1 ; \n } \n return res ; \n }", "idx": 19440}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred16x16_vertical_add ) ( uint8_t * pix , const int * block_offset , \n const int16_t * block , \n ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n FUNCC ( pred4x4_vertical_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 19446}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static void h264_free_extradata ( PayloadContext * data ) \n { \n #ifdef DEBUG \n int ii ; \n for ( ii = 0 ; ii < 32 ; ii ++ ) { \n if ( data -> packet_types_received [ ii ] ) \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , \n data -> packet_types_received [ ii ] , ii ) ; \n } \n #endif \n assert ( data ) ; \n assert ( data -> cookie == MAGIC_COOKIE ) ; \n data -> cookie = DEAD_COOKIE ; \n av_free ( data ) ; \n }", "idx": 19448}
{"project": "FFmpeg", "commit_id": "b8b21dee0f0b4bcc1888067c497d6e838859d2cd", "target": 0, "func": "static const UID * mxf_get_mpeg2_codec_ul ( AVCodecContext * avctx ) \n { \n int long_gop = avctx -> gop_size > 1 || avctx -> has_b_frames ; \n if ( avctx -> profile == 4 ) { \n if ( avctx -> level == 8 ) \n return & mxf_mpeg2_codec_uls [ 0 + long_gop ] ; \n else if ( avctx -> level == 4 ) \n return & mxf_mpeg2_codec_uls [ 4 + long_gop ] ; \n else if ( avctx -> level == 6 ) \n return & mxf_mpeg2_codec_uls [ 8 + long_gop ] ; \n } else if ( avctx -> profile == 0 ) { \n if ( avctx -> level == 5 ) \n return & mxf_mpeg2_codec_uls [ 2 + long_gop ] ; \n else if ( avctx -> level == 2 ) \n return & mxf_mpeg2_codec_uls [ 6 + long_gop ] ; \n } \n return NULL ; \n }", "idx": 19458}
{"project": "FFmpeg", "commit_id": "96dce6f7ceaa8d3c7eddd241213bec82e84e7f7a", "target": 0, "func": "static void free_packet_list ( AVPacketList * pktl ) \n { \n AVPacketList * cur ; \n while ( pktl ) { \n cur = pktl ; \n pktl = cur -> next ; \n av_free_packet ( & cur -> pkt ) ; \n av_free ( cur ) ; \n } \n }", "idx": 19459}
{"project": "FFmpeg", "commit_id": "57cd6d709565e84e84385f8f2a9641ca3fa718be", "target": 1, "func": "void ff_vorbis_floor1_render_list ( vorbis_floor1_entry * list , int values , \n uint16_t * y_list , int * flag , \n int multiplier , float * out , int samples ) \n { \n int lx , ly , i ; \n lx = 0 ; \n ly = y_list [ 0 ] * multiplier ; \n for ( i = 1 ; i < values ; i ++ ) { \n int pos = list [ i ] . sort ; \n if ( flag [ pos ] ) { \n int x1 = list [ pos ] . x ; \n int y1 = y_list [ pos ] * multiplier ; \n if ( lx < samples ) \n render_line ( lx , ly , FFMIN ( x1 , samples ) , y1 , out ) ; \n lx = x1 ; \n ly = y1 ; \n } \n if ( lx >= samples ) \n break ; \n } \n if ( lx < samples ) \n render_line ( lx , ly , samples , ly , out ) ; \n }", "idx": 19467}
{"project": "FFmpeg", "commit_id": "aefdb735c3df9480c1ca9bcf4a3835bd66271bd1", "target": 0, "func": "static void channel_weighting ( float * su1 , float * su2 , int * p3 ) \n { \n int band , nsample ; \n float w [ 2 ] [ 2 ] ; \n if ( p3 [ 1 ] != 7 || p3 [ 3 ] != 7 ) { \n get_channel_weights ( p3 [ 1 ] , p3 [ 0 ] , w [ 0 ] ) ; \n get_channel_weights ( p3 [ 3 ] , p3 [ 2 ] , w [ 1 ] ) ; \n for ( band = 1 ; band < 4 ; band ++ ) { \n for ( nsample = 0 ; nsample < 8 ; nsample ++ ) { \n su1 [ band * 256 + nsample ] *= INTERPOLATE ( w [ 0 ] [ 0 ] , w [ 0 ] [ 1 ] , nsample ) ; \n su2 [ band * 256 + nsample ] *= INTERPOLATE ( w [ 1 ] [ 0 ] , w [ 1 ] [ 1 ] , nsample ) ; \n } \n for ( ; nsample < 256 ; nsample ++ ) { \n su1 [ band * 256 + nsample ] *= w [ 1 ] [ 0 ] ; \n su2 [ band * 256 + nsample ] *= w [ 1 ] [ 1 ] ; \n } \n } \n } \n }", "idx": 19468}
{"project": "FFmpeg", "commit_id": "1303d62d8416fa315a0cc7bbbe35cfdab787ea92", "target": 0, "func": "static int read_packet ( ByteIOContext * pb , uint8_t * buf , int raw_packet_size ) \n { \n int skip , len ; \n for ( ; ; ) { \n len = get_buffer ( pb , buf , TS_PACKET_SIZE ) ; \n if ( len != TS_PACKET_SIZE ) \n return AVERROR ( EIO ) ; \n if ( buf [ 0 ] != 0x47 ) { \n url_fseek ( pb , - TS_PACKET_SIZE , SEEK_CUR ) ; \n if ( mpegts_resync ( pb ) < 0 ) \n return AVERROR_INVALIDDATA ; \n else \n continue ; \n } else { \n skip = raw_packet_size - TS_PACKET_SIZE ; \n if ( skip > 0 ) \n url_fskip ( pb , skip ) ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 19493}
{"project": "FFmpeg", "commit_id": "11ab1e409ff272c8c0bce62f48a3767546547c6c", "target": 0, "func": "av_cold void ff_fft_init_arm ( FFTContext * s ) \n { \n if ( HAVE_NEON ) { \n s -> fft_permute = ff_fft_permute_neon ; \n s -> fft_calc = ff_fft_calc_neon ; \n s -> imdct_calc = ff_imdct_calc_neon ; \n s -> imdct_half = ff_imdct_half_neon ; \n s -> mdct_calc = ff_mdct_calc_neon ; \n s -> permutation = FF_MDCT_PERM_INTERLEAVE ; \n } \n }", "idx": 19495}
{"project": "FFmpeg", "commit_id": "332f9ac4e31ce5e6d0c42ac9e0229d7d1b2b4d60", "target": 0, "func": "static void change_qscale ( MpegEncContext * s , int dquant ) \n { \n s -> qscale += dquant ; \n if ( s -> qscale < 1 ) \n s -> qscale = 1 ; \n else if ( s -> qscale > 31 ) \n s -> qscale = 31 ; \n s -> y_dc_scale = s -> y_dc_scale_table [ s -> qscale ] ; \n s -> c_dc_scale = s -> c_dc_scale_table [ s -> qscale ] ; \n }", "idx": 19514}
{"project": "FFmpeg", "commit_id": "d218a86a0da7b2630828d31393d52295f0e311e9", "target": 0, "func": "void av_set_pts_info ( AVStream * s , int pts_wrap_bits , \n unsigned int pts_num , unsigned int pts_den ) \n { \n unsigned int gcd = av_gcd ( pts_num , pts_den ) ; \n s -> pts_wrap_bits = pts_wrap_bits ; \n s -> time_base . num = pts_num / gcd ; \n s -> time_base . den = pts_den / gcd ; \n if ( gcd > 1 ) \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , s -> index , gcd ) ; \n }", "idx": 19534}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int msvideo1_decode_init ( AVCodecContext * avctx ) \n { \n Msvideo1Context * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( s -> avctx -> palctrl ) { \n s -> mode_8bit = 1 ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n } else { \n s -> mode_8bit = 0 ; \n avctx -> pix_fmt = PIX_FMT_RGB555 ; \n } \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 19535}
{"project": "FFmpeg", "commit_id": "732ce18eab8c409c92cf89b16e2d1d8e7113d7cd", "target": 1, "func": "static void convert_matrix ( DSPContext * dsp , int ( * qmat ) [ 64 ] , uint16_t ( * qmat16 ) [ 2 ] [ 64 ] , \n const uint16_t * quant_matrix , int bias , int qmin , int qmax ) \n { \n int qscale ; \n for ( qscale = qmin ; qscale <= qmax ; qscale ++ ) { \n int i ; \n if ( dsp -> fdct == ff_jpeg_fdct_islow \n #ifdef FAAN_POSTSCALE \n || dsp -> fdct == ff_faandct \n #endif \n ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n const int j = dsp -> idct_permutation [ i ] ; \n qmat [ qscale ] [ i ] = ( int ) ( ( uint64_t_C ( 1 ) << QMAT_SHIFT ) / \n ( qscale * quant_matrix [ j ] ) ) ; \n } \n } else if ( dsp -> fdct == fdct_ifast \n #ifndef FAAN_POSTSCALE \n || dsp -> fdct == ff_faandct \n #endif \n ) { \n for ( i = 0 ; i < 64 ; i ++ ) { \n const int j = dsp -> idct_permutation [ i ] ; \n qmat [ qscale ] [ i ] = ( int ) ( ( uint64_t_C ( 1 ) << ( QMAT_SHIFT + 14 ) ) / \n ( aanscales [ i ] * qscale * quant_matrix [ j ] ) ) ; \n } \n } else { \n for ( i = 0 ; i < 64 ; i ++ ) { \n const int j = dsp -> idct_permutation [ i ] ; \n qmat [ qscale ] [ i ] = ( int ) ( ( uint64_t_C ( 1 ) << QMAT_SHIFT ) / ( qscale * quant_matrix [ j ] ) ) ; \n qmat16 [ qscale ] [ 0 ] [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ j ] ) ; \n if ( qmat16 [ qscale ] [ 0 ] [ i ] == 0 || qmat16 [ qscale ] [ 0 ] [ i ] == 128 * 256 ) qmat16 [ qscale ] [ 0 ] [ i ] = 128 * 256 - 1 ; \n qmat16 [ qscale ] [ 1 ] [ i ] = ROUNDED_DIV ( bias << ( 16 - QUANT_BIAS_SHIFT ) , qmat16 [ qscale ] [ 0 ] [ i ] ) ; \n } \n } \n } \n }", "idx": 19536}
{"project": "FFmpeg", "commit_id": "3ee8ca9b0894df3aaf5086c643283cb58ef9763d", "target": 0, "func": "static int ass_decode_frame ( AVCodecContext * avctx , void * data , int * got_sub_ptr , \n AVPacket * avpkt ) \n { \n const char * ptr = avpkt -> data ; \n int len , size = avpkt -> size ; \n ff_ass_init ( data ) ; \n while ( size > 0 ) { \n len = ff_ass_add_rect ( data , ptr , 0 , 0 \n , 1 ) ; \n if ( len < 0 ) \n return len ; \n ptr += len ; \n size -= len ; \n } \n * got_sub_ptr = avpkt -> size > 0 ; \n return avpkt -> size ; \n }", "idx": 19548}
{"project": "FFmpeg", "commit_id": "675cfb2f86a0bd76b0784da0c7ec9a9225e37353", "target": 1, "func": "static int parse_dsd_diin ( AVFormatContext * s , AVStream * st , uint64_t eof ) \n { \n AVIOContext * pb = s -> pb ; \n while ( avio_tell ( pb ) + 12 <= eof ) { \n uint32_t tag = avio_rl32 ( pb ) ; \n uint64_t size = avio_rb64 ( pb ) ; \n uint64_t orig_pos = avio_tell ( pb ) ; \n const char * metadata_tag = NULL ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : metadata_tag = \" \" ; break ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : metadata_tag = \" \" ; break ; \n } \n if ( metadata_tag && size > 4 ) { \n unsigned int tag_size = avio_rb32 ( pb ) ; \n int ret = get_metadata ( s , metadata_tag , FFMIN ( tag_size , size - 4 ) ) ; \n if ( ret < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , metadata_tag ) ; \n return ret ; \n } \n } \n avio_skip ( pb , size - ( avio_tell ( pb ) - orig_pos ) + ( size & 1 ) ) ; \n } \n return 0 ; \n }", "idx": 19551}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget_short ( const uint8_t * * p , int le ) \n { \n unsigned v = le ? AV_RL16 ( * p ) : AV_RB16 ( * p ) ; \n * p += 2 ; \n return v ; \n }", "idx": 19552}
{"project": "FFmpeg", "commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "target": 1, "func": "void checkasm_check_vf_interlace ( void ) \n { \n check_lowpass_line ( 8 ) ; \n report ( \" \" ) ; \n check_lowpass_line ( 16 ) ; \n report ( \" \" ) ; \n }", "idx": 19553}
{"project": "FFmpeg", "commit_id": "4fdb41a84bc4cbc50600f1ba5ab6af64c69ca092", "target": 1, "func": "static int eval_refl ( int * refl , const int16_t * coefs , RA144Context * ractx ) \n { \n int b , i , j ; \n int buffer1 [ 10 ] ; \n int buffer2 [ 10 ] ; \n int * bp1 = buffer1 ; \n int * bp2 = buffer2 ; \n for ( i = 0 ; i < 10 ; i ++ ) \n buffer2 [ i ] = coefs [ i ] ; \n refl [ 9 ] = bp2 [ 9 ] ; \n if ( ( unsigned ) bp2 [ 9 ] + 0x1000 > 0x1fff ) { \n av_log ( ractx , AV_LOG_ERROR , \" \\n \" ) ; \n return 1 ; \n } \n for ( i = 8 ; i >= 0 ; i -- ) { \n b = 0x1000 - ( ( bp2 [ i + 1 ] * bp2 [ i + 1 ] ) >> 12 ) ; \n if ( ! b ) \n b = -2 ; \n for ( j = 0 ; j <= i ; j ++ ) \n bp1 [ j ] = ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) >> 12 ) ) * ( 0x1000000 / b ) ) >> 12 ; \n refl [ i ] = bp1 [ i ] ; \n if ( ( unsigned ) bp1 [ i ] + 0x1000 > 0x1fff ) \n return 1 ; \n FFSWAP ( int * , bp1 , bp2 ) ; \n } \n return 0 ; \n }", "idx": 19561}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_connect_data_connection ( URLContext * h ) \n { \n int err ; \n char buf [ CONTROL_BUFFER_SIZE ] , opts_format [ 20 ] ; \n AVDictionary * opts = NULL ; \n FTPContext * s = h -> priv_data ; \n if ( ! s -> conn_data ) { \n if ( ( err = ftp_passive_mode ( s ) ) < 0 ) { \n av_dlog ( h , \" \\n \" ) ; \n return err ; \n } \n ff_url_join ( buf , sizeof ( buf ) , \" \" , NULL , s -> hostname , s -> server_data_port , NULL ) ; \n if ( s -> rw_timeout != -1 ) { \n snprintf ( opts_format , sizeof ( opts_format ) , \" \" , s -> rw_timeout ) ; \n av_dict_set ( & opts , \" \" , opts_format , 0 ) ; \n } \n err = ffurl_open ( & s -> conn_data , buf , AVIO_FLAG_READ_WRITE , \n & h -> interrupt_callback , & opts ) ; \n av_dict_free ( & opts ) ; \n if ( err < 0 ) \n return err ; \n if ( s -> position ) \n if ( ( err = ftp_restart ( s , s -> position ) ) < 0 ) \n return err ; \n } \n s -> state = READY ; \n return 0 ; \n }", "idx": 19569}
{"project": "FFmpeg", "commit_id": "6c7d3ead79af2de091ff74cb2e29770882cbae99", "target": 0, "func": "static void schedule_refresh ( VideoState * is , int delay ) \n { \n if ( ! delay ) delay = 1 ; \n SDL_AddTimer ( delay , sdl_refresh_timer_cb , is ) ; \n }", "idx": 19596}
{"project": "FFmpeg", "commit_id": "37b3361e755361d4ff14a2973df001c0140d98d6", "target": 0, "func": "static inline void encode_dc ( MpegEncContext * s , int diff , int component ) \n { \n if ( ( ( unsigned ) ( diff + 255 ) ) >= 511 ) { \n int index ; \n if ( diff < 0 ) { \n index = av_log2_16bit ( -2 * diff ) ; \n diff -- ; \n } else { \n index = av_log2_16bit ( 2 * diff ) ; \n } \n if ( component == 0 ) \n put_bits ( & s -> pb , \n ff_mpeg12_vlc_dc_lum_bits [ index ] + index , \n ( ff_mpeg12_vlc_dc_lum_code [ index ] << index ) + \n ( diff & ( ( 1 << index ) - 1 ) ) ) ; \n else \n put_bits ( & s -> pb , \n ff_mpeg12_vlc_dc_chroma_bits [ index ] + index , \n ( ff_mpeg12_vlc_dc_chroma_code [ index ] << index ) + \n ( diff & ( ( 1 << index ) - 1 ) ) ) ; \n } else { \n if ( component == 0 ) \n put_bits ( & s -> pb , \n mpeg1_lum_dc_uni [ diff + 255 ] & 0xFF , \n mpeg1_lum_dc_uni [ diff + 255 ] >> 8 ) ; \n else \n put_bits ( & s -> pb , \n mpeg1_chr_dc_uni [ diff + 255 ] & 0xFF , \n mpeg1_chr_dc_uni [ diff + 255 ] >> 8 ) ; \n } \n }", "idx": 19598}
{"project": "FFmpeg", "commit_id": "50b4468598cbc032c0ec4597df9637f71b9ef664", "target": 0, "func": "int av_fifo_generic_read ( AVFifoBuffer * f , int buf_size , void ( * func ) ( void * , void * , int ) , void * dest ) \n { \n int size = av_fifo_size ( f ) ; \n if ( size < buf_size ) \n return -1 ; \n while ( buf_size > 0 ) { \n int len = FFMIN ( f -> end - f -> rptr , buf_size ) ; \n if ( func ) func ( dest , f -> rptr , len ) ; \n else { \n memcpy ( dest , f -> rptr , len ) ; \n dest = ( uint8_t * ) dest + len ; \n } \n av_fifo_drain ( f , len ) ; \n buf_size -= len ; \n } \n return 0 ; \n }", "idx": 19602}
{"project": "FFmpeg", "commit_id": "79eff9132581af69fbbd2674337b75fad29aa306", "target": 0, "func": "void av_opt_set_defaults ( void * s ) \n { \n av_opt_set_defaults2 ( s , 0 , 0 ) ; \n }", "idx": 19609}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( yv12toyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 19610}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void adx_decode ( short * out , const unsigned char * in , PREV * prev ) \n { \n int scale = ( ( in [ 0 ] << 8 ) | ( in [ 1 ] ) ) ; \n int i ; \n int s0 , s1 , s2 , d ; \n in += 2 ; \n s1 = prev -> s1 ; \n s2 = prev -> s2 ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n d = in [ i ] ; \n d = ( ( signed char ) d >> 4 ) ; \n s0 = ( BASEVOL * d * scale + SCALE1 * s1 - SCALE2 * s2 ) >> 14 ; \n CLIP ( s0 ) ; \n * out ++ = s0 ; \n s2 = s1 ; \n s1 = s0 ; \n d = in [ i ] ; \n d = ( ( signed char ) ( d << 4 ) >> 4 ) ; \n s0 = ( BASEVOL * d * scale + SCALE1 * s1 - SCALE2 * s2 ) >> 14 ; \n CLIP ( s0 ) ; \n * out ++ = s0 ; \n s2 = s1 ; \n s1 = s0 ; \n } \n prev -> s1 = s1 ; \n prev -> s2 = s2 ; \n }", "idx": 19614}
{"project": "FFmpeg", "commit_id": "fcd19d6c8db514b017662166d014ac8560fbe8f5", "target": 1, "func": "static void jpeg2000_dec_cleanup ( Jpeg2000DecoderContext * s ) \n { \n int tileno , compno ; \n for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { \n if ( s -> tile [ tileno ] . comp ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n Jpeg2000Component * comp = s -> tile [ tileno ] . comp + compno ; \n Jpeg2000CodingStyle * codsty = s -> tile [ tileno ] . codsty + compno ; \n ff_jpeg2000_cleanup ( comp , codsty ) ; \n } \n av_freep ( & s -> tile [ tileno ] . comp ) ; \n } \n } \n av_freep ( & s -> tile ) ; \n s -> numXtiles = s -> numYtiles = 0 ; \n }", "idx": 19623}
{"project": "FFmpeg", "commit_id": "65c7bb9ec4f521a46577a1e87d71ad9a8deee6cd", "target": 0, "func": "static void vc1_overlap_block ( MpegEncContext * s , DCTELEM block [ 64 ] , int n , int do_hor , int do_vert ) \n { \n int i ; \n if ( do_hor ) { \n } \n if ( do_vert ) { \n } \n for ( i = 0 ; i < 64 ; i ++ ) \n block [ i ] += 128 ; \n }", "idx": 19628}
{"project": "FFmpeg", "commit_id": "25b6837f7cacd691b19cbc12b9dad1ce84a318a1", "target": 0, "func": "static int32_t parse_gain ( const char * gain ) \n { \n char * fraction ; \n int scale = 10000 ; \n int32_t mb = 0 ; \n int db ; \n if ( ! gain ) \n return INT32_MIN ; \n gain += strspn ( gain , \" \\t \" ) ; \n db = strtol ( gain , & fraction , 0 ) ; \n if ( * fraction ++ == ' ' ) { \n while ( av_isdigit ( * fraction ) && scale ) { \n mb += scale * ( * fraction - ' ' ) ; \n scale /= 10 ; \n fraction ++ ; \n } \n } \n if ( abs ( db ) > ( INT32_MAX - mb ) / 100000 ) \n return INT32_MIN ; \n return db * 100000 + FFSIGN ( db ) * mb ; \n }", "idx": 19629}
{"project": "FFmpeg", "commit_id": "26f6b8c571bcff7b325c7d6cc226c625dd465f8e", "target": 1, "func": "int ffurl_read ( URLContext * h , unsigned char * buf , int size ) \n { \n if ( h -> flags & AVIO_FLAG_WRITE ) \n return AVERROR ( EIO ) ; \n return retry_transfer_wrapper ( h , buf , size , 1 , h -> prot -> url_read ) ; \n }", "idx": 19630}
{"project": "FFmpeg", "commit_id": "ff100c9dd97d2f1f456ff38b192edf84f9744738", "target": 1, "func": "static int webm_dash_manifest_read_header ( AVFormatContext * s ) \n { \n char * buf ; \n int ret = matroska_read_header ( s ) ; \n MatroskaTrack * tracks ; \n MatroskaDemuxContext * matroska = s -> priv_data ; \n if ( ret ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n if ( ! matroska -> is_live ) { \n buf = av_asprintf ( \" \" , matroska -> duration ) ; \n if ( ! buf ) return AVERROR ( ENOMEM ) ; \n av_dict_set ( & s -> streams [ 0 ] -> metadata , DURATION , buf , 0 ) ; \n av_free ( buf ) ; \n av_dict_set_int ( & s -> streams [ 0 ] -> metadata , INITIALIZATION_RANGE , avio_tell ( s -> pb ) - 5 , 0 ) ; \n buf = strrchr ( s -> filename , ' ' ) ; \n av_dict_set ( & s -> streams [ 0 ] -> metadata , FILENAME , buf ? ++ buf : s -> filename , 0 ) ; \n tracks = matroska -> tracks . elem ; \n av_dict_set_int ( & s -> streams [ 0 ] -> metadata , TRACK_NUMBER , tracks [ 0 ] . num , 0 ) ; \n return matroska -> is_live ? 0 : webm_dash_manifest_cues ( s ) ;", "idx": 19634}
{"project": "FFmpeg", "commit_id": "2dd0da787ce5008d4d1b8f461fbd1288c32e2c38", "target": 1, "func": "static int mp3_write_audio_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MP3Context * mp3 = s -> priv_data ; \n if ( pkt -> data && pkt -> size >= 4 ) { \n MPADecodeHeader c ; \n int av_unused base ; \n avpriv_mpegaudio_decode_header ( & c , AV_RB32 ( pkt -> data ) ) ; \n if ( ! mp3 -> initial_bitrate ) \n mp3 -> initial_bitrate = c . bit_rate ; \n if ( ( c . bit_rate == 0 ) || ( mp3 -> initial_bitrate != c . bit_rate ) ) \n mp3 -> has_variable_bitrate = 1 ; \n #ifdef FILTER_VBR_HEADERS \n base = 4 + xing_offtbl [ c . lsf == 1 ] [ c . nb_channels == 1 ] ; \n if ( base + 4 <= pkt -> size ) { \n uint32_t v = AV_RB32 ( pkt -> data + base ) ; \n if ( MKBETAG ( ' ' , ' ' , ' ' , ' ' ) == v || MKBETAG ( ' ' , ' ' , ' ' , ' ' ) == v ) \n return 0 ; \n } \n base = 4 + 32 ; \n if ( base + 4 <= pkt -> size && MKBETAG ( ' ' , ' ' , ' ' , ' ' ) == AV_RB32 ( pkt -> data + base ) ) \n return 0 ; \n #endif \n if ( mp3 -> xing_offset ) \n mp3_xing_add_frame ( mp3 , pkt ) ; \n } \n return ff_raw_write_packet ( s , pkt ) ; \n }", "idx": 19636}
{"project": "FFmpeg", "commit_id": "9487fb4dea3498eb4711eb023f43199f68701b1e", "target": 1, "func": "yuv2422_1_c_template ( SwsContext * c , const int16_t * buf0 , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf0 , uint8_t * dest , int dstW , \n int uvalpha , int y , enum PixelFormat target )  \n { \n const int16_t * ubuf0 = ubuf [ 0 ] , * vbuf0 = vbuf [ 0 ] ; \n int i ; \n if ( uvalpha < 2048 ) { \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = buf0 [ i * 2 ] >> 7 ; \n int Y2 = buf0 [ i * 2 + 1 ] >> 7 ; \n int U = ubuf0 [ i ] >> 7 ; \n int V = vbuf0 [ i ] >> 7 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n } else { \n const int16_t * ubuf1 = ubuf [ 1 ] , * vbuf1 = vbuf [ 1 ] ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = buf0 [ i * 2 ] >> 7 ; \n int Y2 = buf0 [ i * 2 + 1 ] >> 7 ; \n int U = ( ubuf0 [ i ] + ubuf1 [ i ] ) >> 8 ; \n int V = ( vbuf0 [ i ] + vbuf1 [ i ] ) >> 8 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n } \n }", "idx": 19639}
{"project": "FFmpeg", "commit_id": "21b5990da461e4f83cf53994715ed42e22cce9e0", "target": 0, "func": "void * av_fast_realloc ( void * ptr , unsigned int * size , size_t min_size ) \n { \n if ( min_size < * size ) \n return ptr ; \n min_size = FFMAX ( min_size + min_size / 16 + 32 , min_size ) ; \n ptr = av_realloc ( ptr , min_size ) ; \n if ( ! ptr ) \n min_size = 0 ; \n * size = min_size ; \n return ptr ; \n }", "idx": 19651}
{"project": "FFmpeg", "commit_id": "39185ec4faa9ef33954dbf2394444e045b632673", "target": 0, "func": "static inline int decode_residual_inter ( AVSContext * h ) \n { \n int block ; \n int cbp = get_ue_golomb ( & h -> gb ) ; \n if ( cbp > 63 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n h -> cbp = cbp_tab [ cbp ] [ 1 ] ; \n if ( h -> cbp && ! h -> qp_fixed ) \n h -> qp = ( h -> qp + get_se_golomb ( & h -> gb ) ) & 63 ; \n for ( block = 0 ; block < 4 ; block ++ ) \n if ( h -> cbp & ( 1 << block ) ) \n decode_residual_block ( h , & h -> gb , inter_dec , 0 , h -> qp , \n h -> cy + h -> luma_scan [ block ] , h -> l_stride ) ; \n decode_residual_chroma ( h ) ; \n return 0 ; \n }", "idx": 19652}
{"project": "FFmpeg", "commit_id": "6e42ccb9dbc13836cd52cda594f819d17af9afa2", "target": 0, "func": "static int decode_pulses ( Pulse * pulse , GetBitContext * gb , \n const uint16_t * swb_offset , int num_swb ) \n { \n int i , pulse_swb ; \n pulse -> num_pulse = get_bits ( gb , 2 ) + 1 ; \n pulse_swb = get_bits ( gb , 6 ) ; \n if ( pulse_swb >= num_swb ) \n return -1 ; \n pulse -> pos [ 0 ] = swb_offset [ pulse_swb ] ; \n pulse -> pos [ 0 ] += get_bits ( gb , 5 ) ; \n if ( pulse -> pos [ 0 ] > 1023 ) \n return -1 ; \n pulse -> amp [ 0 ] = get_bits ( gb , 4 ) ; \n for ( i = 1 ; i < pulse -> num_pulse ; i ++ ) { \n pulse -> pos [ i ] = get_bits ( gb , 5 ) + pulse -> pos [ i - 1 ] ; \n if ( pulse -> pos [ i ] > 1023 ) \n return -1 ; \n pulse -> amp [ i ] = get_bits ( gb , 4 ) ; \n } \n return 0 ; \n }", "idx": 19653}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int aiff_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 16 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 8 ] == ' ' && p -> buf [ 9 ] == ' ' && \n p -> buf [ 10 ] == ' ' && ( p -> buf [ 11 ] == ' ' || p -> buf [ 11 ] == ' ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 19655}
{"project": "FFmpeg", "commit_id": "44272c1cccfb92415801ae60693a7ed04e458916", "target": 1, "func": "void avformat_close_input ( AVFormatContext * * ps ) \n { \n AVFormatContext * s = * ps ; \n AVIOContext * pb = ( s -> iformat -> flags & AVFMT_NOFILE ) || ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ? \n NULL : s -> pb ; \n flush_packet_queue ( s ) ; \n if ( s -> iformat -> read_close ) \n s -> iformat -> read_close ( s ) ; \n avformat_free_context ( s ) ; \n * ps = NULL ; \n avio_close ( pb ) ; \n }", "idx": 19658}
{"project": "FFmpeg", "commit_id": "68caef9d48c4f1540b1b3181ebe7062a3417c62a", "target": 1, "func": "av_cold void ff_vp9dsp_init ( VP9DSPContext * dsp , int bpp , int bitexact ) \n { \n if ( bpp == 8 ) { \n ff_vp9dsp_init_8 ( dsp ) ; \n } else if ( bpp == 10 ) { \n ff_vp9dsp_init_10 ( dsp ) ; \n } else { \n av_assert0 ( bpp == 12 ) ; \n ff_vp9dsp_init_12 ( dsp ) ; \n } \n if ( ARCH_X86 ) ff_vp9dsp_init_x86 ( dsp , bpp , bitexact ) ; \n if ( ARCH_MIPS ) ff_vp9dsp_init_mips ( dsp , bpp ) ; \n }", "idx": 19663}
{"project": "FFmpeg", "commit_id": "f36aec3b5e18c4c167612d0051a6d5b6144b3552", "target": 1, "func": "static int mace6_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n const uint8_t * buf , int buf_size ) \n { \n int16_t * samples = data ; \n MACEContext * ctx = avctx -> priv_data ; \n int i , j ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) { \n int16_t * output = samples + i ; \n for ( j = 0 ; j < buf_size / avctx -> channels ; j ++ ) { \n uint8_t pkt = buf [ i + j * avctx -> channels ] ; \n chomp6 ( & ctx -> chd [ i ] , output , pkt >> 5 , MACEtab1 , MACEtab2 , \n 8 , avctx -> channels ) ; \n output += avctx -> channels << 1 ; \n chomp6 ( & ctx -> chd [ i ] , output , ( pkt >> 3 ) & 3 , MACEtab3 , MACEtab4 , \n 4 , avctx -> channels ) ; \n output += avctx -> channels << 1 ; \n chomp6 ( & ctx -> chd [ i ] , output , pkt & 7 , MACEtab1 , MACEtab2 , \n 8 , avctx -> channels ) ; \n output += avctx -> channels << 1 ; \n } \n } \n * data_size = 2 * 6 * buf_size ; \n return buf_size ; \n }", "idx": 19670}
{"project": "FFmpeg", "commit_id": "d9a9f50a3683b577e9c391ce8cab9edc9b239fcb", "target": 0, "func": "static int pix_norm1_c ( uint8_t * pix , int line_size ) \n { \n int s , i , j ; \n uint32_t * sq = ff_squareTbl + 256 ; \n s = 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n for ( j = 0 ; j < 16 ; j += 8 ) { \n #if 0  \n  \n  s += sq [ pix [ 0 ] ] ; \n s += sq [ pix [ 1 ] ] ; \n s += sq [ pix [ 2 ] ] ; \n s += sq [ pix [ 3 ] ] ; \n s += sq [ pix [ 4 ] ] ; \n s += sq [ pix [ 5 ] ] ; \n s += sq [ pix [ 6 ] ] ; \n s += sq [ pix [ 7 ] ] ; \n #else \n #if LONG_MAX > 2147483647  \n  \n  register uint64_t x = * ( uint64_t * ) pix ; \n s += sq [ x & 0xff ] ; \n s += sq [ ( x >> 8 ) & 0xff ] ; \n s += sq [ ( x >> 16 ) & 0xff ] ; \n s += sq [ ( x >> 24 ) & 0xff ] ; \n s += sq [ ( x >> 32 ) & 0xff ] ; \n s += sq [ ( x >> 40 ) & 0xff ] ; \n s += sq [ ( x >> 48 ) & 0xff ] ; \n s += sq [ ( x >> 56 ) & 0xff ] ; \n #else \n register uint32_t x = * ( uint32_t * ) pix ; \n s += sq [ x & 0xff ] ; \n s += sq [ ( x >> 8 ) & 0xff ] ; \n s += sq [ ( x >> 16 ) & 0xff ] ; \n s += sq [ ( x >> 24 ) & 0xff ] ; \n x = * ( uint32_t * ) ( pix + 4 ) ; \n s += sq [ x & 0xff ] ; \n s += sq [ ( x >> 8 ) & 0xff ] ; \n s += sq [ ( x >> 16 ) & 0xff ] ; \n s += sq [ ( x >> 24 ) & 0xff ] ; \n #endif \n #endif \n pix += 8 ; \n } \n pix += line_size - 16 ; \n } \n return s ; \n }", "idx": 19676}
{"project": "FFmpeg", "commit_id": "7656c4c6e66f8a787d384f027ad824cc1677fda1", "target": 0, "func": "static void restore_median ( uint8_t * src , int step , int stride , \n int width , int height , int slices , int rmode ) \n { \n int i , j , slice ; \n int A , B , C ; \n uint8_t * bsrc ; \n int slice_start , slice_height ; \n const int cmask = ~ rmode ; \n for ( slice = 0 ; slice < slices ; slice ++ ) { \n slice_start = ( ( slice * height ) / slices ) & cmask ; \n slice_height = ( ( ( ( slice + 1 ) * height ) / slices ) & cmask ) - \n slice_start ; \n bsrc = src + slice_start * stride ; \n bsrc [ 0 ] += 0x80 ; \n A = bsrc [ 0 ] ; \n for ( i = step ; i < width * step ; i += step ) { \n bsrc [ i ] += A ; \n A = bsrc [ i ] ; \n } \n bsrc += stride ; \n if ( slice_height == 1 ) \n continue ; \n C = bsrc [ - stride ] ; \n bsrc [ 0 ] += C ; \n A = bsrc [ 0 ] ; \n for ( i = step ; i < width * step ; i += step ) { \n B = bsrc [ i - stride ] ; \n bsrc [ i ] += mid_pred ( A , B , ( uint8_t ) ( A + B - C ) ) ; \n C = B ; \n A = bsrc [ i ] ; \n } \n bsrc += stride ; \n for ( j = 2 ; j < slice_height ; j ++ ) { \n for ( i = 0 ; i < width * step ; i += step ) { \n B = bsrc [ i - stride ] ; \n bsrc [ i ] += mid_pred ( A , B , ( uint8_t ) ( A + B - C ) ) ; \n C = B ; \n A = bsrc [ i ] ; \n } \n bsrc += stride ; \n } \n } \n }", "idx": 19677}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "static void mpeg4_encode_gop_header ( MpegEncContext * s ) { \n int hours , minutes , seconds ; \n int64_t time ; \n put_bits ( & s -> pb , 16 , 0 ) ; \n put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; \n time = s -> current_picture_ptr -> pts ; \n if ( s -> reordered_input_picture [ 1 ] ) \n time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> pts ) ; \n time = time * s -> avctx -> time_base . num ; \n seconds = time / s -> avctx -> time_base . den ; \n minutes = seconds / 60 ; seconds %= 60 ; \n hours = minutes / 60 ; minutes %= 60 ; \n hours %= 24 ; \n put_bits ( & s -> pb , 5 , hours ) ; \n put_bits ( & s -> pb , 6 , minutes ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 6 , seconds ) ; \n put_bits ( & s -> pb , 1 , ! ! ( s -> flags & CODEC_FLAG_CLOSED_GOP ) ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n s -> last_time_base = time / s -> avctx -> time_base . den ; \n ff_mpeg4_stuffing ( & s -> pb ) ; \n }", "idx": 19680}
{"project": "FFmpeg", "commit_id": "362271d72fc38cd1f4b076aff9a12b1104c26760", "target": 0, "func": "static int mv_read_packet ( AVFormatContext * avctx , AVPacket * pkt ) \n { \n MvContext * mv = avctx -> priv_data ; \n AVIOContext * pb = avctx -> pb ; \n AVStream * st = avctx -> streams [ mv -> stream_index ] ; \n const AVIndexEntry * index ; \n int frame = mv -> frame [ mv -> stream_index ] ; \n int ret ; \n uint64_t pos ; \n if ( frame < st -> nb_frames ) { \n index = & st -> index_entries [ frame ] ; \n pos = avio_tell ( pb ) ; \n if ( index -> pos > pos ) \n avio_skip ( pb , index -> pos - pos ) ; \n else if ( index -> pos < pos ) { \n if ( ! pb -> seekable ) \n return AVERROR ( EIO ) ; \n ret = avio_seek ( pb , index -> pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ret = av_get_packet ( pb , pkt , index -> size ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = mv -> stream_index ; \n pkt -> pts = index -> timestamp ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n mv -> frame [ mv -> stream_index ] ++ ; \n mv -> eof_count = 0 ; \n } else { \n mv -> eof_count ++ ; \n if ( mv -> eof_count >= avctx -> nb_streams ) \n return AVERROR_EOF ; \n } \n mv -> stream_index ++ ; \n if ( mv -> stream_index >= avctx -> nb_streams ) \n mv -> stream_index = 0 ; \n return 0 ; \n }", "idx": 19690}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel8_mc10_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_8w_msa ( src - 2 , stride , dst , stride , 8 , 0 ) ; \n }", "idx": 19692}
{"project": "FFmpeg", "commit_id": "6470abc740367cc881c181db866891f8dd1d342f", "target": 0, "func": "static AVFrame * apply_palette ( AVFilterLink * inlink , AVFrame * in ) \n { \n int x , y , w , h ; \n AVFilterContext * ctx = inlink -> dst ; \n PaletteUseContext * s = ctx -> priv ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFrame * out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; \n if ( ! out ) { \n av_frame_free ( & in ) ; \n return NULL ; \n } \n av_frame_copy_props ( out , in ) ; \n set_processing_window ( s -> diff_mode , s -> last_in , in , \n s -> last_out , out , & x , & y , & w , & h ) ; \n av_frame_free ( & s -> last_in ) ; \n av_frame_free ( & s -> last_out ) ; \n s -> last_in = av_frame_clone ( in ) ; \n s -> last_out = av_frame_clone ( out ) ; \n if ( ! s -> last_in || ! s -> last_out || \n av_frame_make_writable ( s -> last_in ) < 0 ) { \n av_frame_free ( & in ) ; \n av_frame_free ( & out ) ; \n return NULL ; \n } \n ff_dlog ( ctx , \" \\n \" , \n w , h , x , y , x + w , y + h , in -> width , in -> height ) ; \n if ( s -> set_frame ( s , out , in , x , y , w , h ) < 0 ) { \n av_frame_free ( & out ) ; \n return NULL ; \n } \n memcpy ( out -> data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ; \n if ( s -> calc_mean_err ) \n debug_mean_error ( s , in , out , inlink -> frame_count_out ) ; \n av_frame_free ( & in ) ; \n return out ; \n }", "idx": 19694}
{"project": "FFmpeg", "commit_id": "4ffbe3f3a5d9892841d9bc31d859916c2c61123f", "target": 1, "func": "static int mkv_add_cuepoint ( mkv_cues * cues , int stream , int64_t ts , int64_t cluster_pos ) \n { \n mkv_cuepoint * entries = cues -> entries ; \n entries = av_realloc ( entries , ( cues -> num_entries + 1 ) * sizeof ( mkv_cuepoint ) ) ; \n if ( entries == NULL ) \n return AVERROR ( ENOMEM ) ; \n if ( ts < 0 ) \n return 0 ; \n entries [ cues -> num_entries ] . pts = ts ; \n entries [ cues -> num_entries ] . tracknum = stream + 1 ; \n entries [ cues -> num_entries ++ ] . cluster_pos = cluster_pos - cues -> segment_offset ; \n cues -> entries = entries ; \n return 0 ; \n }", "idx": 19706}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_top_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n const int dc = ( src [ - stride ] + src [ 1 - stride ] + src [ 2 - stride ] + src [ 3 - stride ] + 2 ) >> 2 ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( dc ) ; \n }", "idx": 19715}
{"project": "FFmpeg", "commit_id": "6706a2986c48e3f20f1274b24345e6555d8f0f48", "target": 1, "func": "static void store_slice_mmx ( uint8_t * dst , const uint16_t * src , \n int dst_stride , int src_stride , \n int width , int height , int log2_scale , \n const uint8_t dither [ 8 ] [ 8 ] ) \n { \n int y ; \n for ( y = 0 ; y < height ; y ++ ) { \n uint8_t * dst1 = dst ; \n const int16_t * src1 = src ; \n __asm__ volatile ( \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n : \" + r \" ( src1 ) , \" \" ( dst1 ) \n : \" \" ( dst + width ) , \" \" ( dither [ y ] ) , \" \" ( log2_scale ) , \" \" ( MAX_LEVEL - log2_scale ) \n ) ; \n src += src_stride ; \n dst += dst_stride ; \n } \n }", "idx": 19718}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "av_cold int ff_vc2enc_init_transforms ( VC2TransformContext * s , int p_width , int p_height ) \n { \n s -> vc2_subband_dwt [ VC2_TRANSFORM_9_7 ] = vc2_subband_dwt_97 ; \n s -> vc2_subband_dwt [ VC2_TRANSFORM_5_3 ] = vc2_subband_dwt_53 ; \n s -> vc2_subband_dwt [ VC2_TRANSFORM_HAAR ] = vc2_subband_dwt_haar ; \n s -> vc2_subband_dwt [ VC2_TRANSFORM_HAAR_S ] = vc2_subband_dwt_haar_shift ; \n s -> buffer = av_malloc ( 2 * p_width * p_height * sizeof ( dwtcoef ) ) ; \n if ( ! s -> buffer ) \n return 1 ; \n return 0 ; \n }", "idx": 19719}
{"project": "FFmpeg", "commit_id": "0023ea4e20b0bec70e1dedb7f1183dd58f9122d8", "target": 1, "func": "static void fill_buffer ( AVIOContext * s ) \n { \n int max_buffer_size = s -> max_packet_size ? \n s -> max_packet_size : IO_BUFFER_SIZE ; \n uint8_t * dst = s -> buf_end - s -> buffer + max_buffer_size < s -> buffer_size ? \n s -> buf_end : s -> buffer ; \n int len = s -> buffer_size - ( dst - s -> buffer ) ; \n if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end ) \n s -> eof_reached = 1 ; \n if ( s -> eof_reached ) \n return ; \n if ( s -> update_checksum && dst == s -> buffer ) { \n if ( s -> buf_end > s -> checksum_ptr ) \n s -> checksum = s -> update_checksum ( s -> checksum , s -> checksum_ptr , \n s -> buf_end - s -> checksum_ptr ) ; \n s -> checksum_ptr = s -> buffer ; \n } \n if ( s -> read_packet && s -> orig_buffer_size && s -> buffer_size > s -> orig_buffer_size ) { \n if ( dst == s -> buffer ) { \n ffio_set_buf_size ( s , s -> orig_buffer_size ) ; \n s -> checksum_ptr = dst = s -> buffer ; \n } \n av_assert0 ( len >= s -> orig_buffer_size ) ; \n len = s -> orig_buffer_size ; \n } \n if ( s -> read_packet ) \n len = s -> read_packet ( s -> opaque , dst , len ) ; \n else \n len = 0 ; \n if ( len <= 0 ) { \n s -> eof_reached = 1 ; \n if ( len < 0 ) \n s -> error = len ; \n } else { \n s -> pos += len ; \n s -> buf_ptr = dst ; \n s -> buf_end = dst + len ; \n s -> bytes_read += len ; \n } \n }", "idx": 19720}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int get_number ( void * obj , const char * name , const AVOption * * o_out , double * num , int * den , int64_t * intnum ) \n { \n const AVOption * o = av_opt_find ( obj , name , NULL , 0 , 0 ) ; \n void * dst ; \n if ( ! o || o -> offset <= 0 ) \n goto error ; \n dst = ( ( uint8_t * ) obj ) + o -> offset ; \n if ( o_out ) * o_out = o ; \n switch ( o -> type ) { \n case FF_OPT_TYPE_FLAGS : * intnum = * ( unsigned int * ) dst ; return 0 ; \n case FF_OPT_TYPE_INT : * intnum = * ( int * ) dst ; return 0 ; \n case FF_OPT_TYPE_INT64 : * intnum = * ( int64_t * ) dst ; return 0 ; \n case FF_OPT_TYPE_FLOAT : * num = * ( float * ) dst ; return 0 ; \n case FF_OPT_TYPE_DOUBLE : * num = * ( double * ) dst ; return 0 ; \n case FF_OPT_TYPE_RATIONAL : * intnum = ( ( AVRational * ) dst ) -> num ; \n * den = ( ( AVRational * ) dst ) -> den ; \n return 0 ; \n } \n error : \n * den = * intnum = 0 ; \n return -1 ; \n }", "idx": 19723}
{"project": "FFmpeg", "commit_id": "45286a625c6ced1f5c4c842244cbb4509429abba", "target": 1, "func": "int ff_h264_field_end ( H264Context * h , H264SliceContext * sl , int in_setup ) \n { \n AVCodecContext * const avctx = h -> avctx ; \n int err = 0 ; \n h -> mb_y = 0 ; \n if ( ! in_setup && ! h -> droppable ) \n ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , \n h -> picture_structure == PICT_BOTTOM_FIELD ) ; \n if ( in_setup || ! ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( ! h -> droppable ) { \n err = ff_h264_execute_ref_pic_marking ( h ) ; \n h -> poc . prev_poc_msb = h -> poc . poc_msb ; \n h -> poc . prev_poc_lsb = h -> poc . poc_lsb ; \n } \n h -> poc . prev_frame_num_offset = h -> poc . frame_num_offset ; \n h -> poc . prev_frame_num = h -> poc . frame_num ; \n } \n if ( avctx -> hwaccel ) { \n if ( avctx -> hwaccel -> end_frame ( avctx ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n #if CONFIG_ERROR_RESILIENCE  \n  \n  \n  if ( ! FIELD_PICTURE ( h ) && h -> enable_er ) { \n h264_set_erpic ( & sl -> er . cur_pic , h -> cur_pic_ptr ) ; \n h264_set_erpic ( & sl -> er . last_pic , \n sl -> ref_count [ 0 ] ? sl -> ref_list [ 0 ] [ 0 ] . parent : NULL ) ; \n h264_set_erpic ( & sl -> er . next_pic , \n sl -> ref_count [ 1 ] ? sl -> ref_list [ 1 ] [ 0 ] . parent : NULL ) ; \n ff_er_frame_end ( & sl -> er ) ; \n } \n #endif \n emms_c ( ) ; \n h -> current_slice = 0 ; \n return err ; \n }", "idx": 19729}
{"project": "FFmpeg", "commit_id": "7ad742b2247a0d6f742a656892b4963fa77744dd", "target": 1, "func": "static AVFrame * alloc_frame ( enum AVPixelFormat pixfmt , int w , int h ) \n { \n AVFrame * frame = av_frame_alloc ( ) ; \n if ( ! frame ) \n return NULL ; \n frame -> format = pixfmt ; \n frame -> width = w ; \n frame -> height = h ; \n if ( av_frame_get_buffer ( frame , 32 ) < 0 ) \n return NULL ; \n return frame ; \n }", "idx": 19731}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static av_cold int pcx_end ( AVCodecContext * avctx ) { \n PCXContext * s = avctx -> priv_data ; \n if ( s -> picture . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> picture ) ; \n return 0 ; \n }", "idx": 19735}
{"project": "FFmpeg", "commit_id": "a4c32c9a63142b602820800742f2d543b58cd278", "target": 1, "func": "static void init_frame_decoder ( APEContext * ctx ) \n { \n int i ; \n init_entropy_decoder ( ctx ) ; \n init_predictor_decoder ( ctx ) ; \n for ( i = 0 ; i < APE_FILTER_LEVELS ; i ++ ) { \n if ( ! ape_filter_orders [ ctx -> fset ] [ i ] ) \n break ; \n init_filter ( ctx , ctx -> filters [ i ] , ctx -> filterbuf [ i ] , \n ape_filter_orders [ ctx -> fset ] [ i ] ) ; \n } \n }", "idx": 19738}
{"project": "FFmpeg", "commit_id": "7df3b426bbfbd7efd9a0f56393e3cc78413b0869", "target": 1, "func": "static void mxf_write_preface ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n mxf_write_metadata_key ( pb , 0x012f00 ) ; \n PRINT_KEY ( s , \" \" , pb -> buf_ptr - 16 ) ; \n klv_encode_ber_length ( pb , 130 + 16 * mxf -> essence_container_count ) ; \n mxf_write_local_tag ( pb , 16 , 0x3C0A ) ; \n mxf_write_uuid ( pb , Preface , 0 ) ; \n PRINT_KEY ( s , \" \" , pb -> buf_ptr - 16 ) ; \n mxf_write_local_tag ( pb , 8 , 0x3B02 ) ; \n avio_wb64 ( pb , mxf -> timestamp ) ; \n mxf_write_local_tag ( pb , 2 , 0x3B05 ) ; \n avio_wb16 ( pb , 258 ) ; \n mxf_write_local_tag ( pb , 16 + 8 , 0x3B06 ) ; \n mxf_write_refs_count ( pb , 1 ) ; \n mxf_write_uuid ( pb , Identification , 0 ) ; \n mxf_write_local_tag ( pb , 16 , 0x3B03 ) ; \n mxf_write_uuid ( pb , ContentStorage , 0 ) ; \n mxf_write_local_tag ( pb , 16 , 0x3B09 ) ; \n avio_write ( pb , op1a_ul , 16 ) ; \n mxf_write_local_tag ( pb , 8 + 16 * mxf -> essence_container_count , 0x3B0A ) ; \n mxf_write_essence_container_refs ( s ) ; \n mxf_write_local_tag ( pb , 8 , 0x3B0B ) ; \n avio_wb64 ( pb , 0 ) ; \n }", "idx": 19746}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n const uint8_t * buf0 , int buf_size ) \n { \n ADXContext * c = avctx -> priv_data ; \n short * samples = data ; \n const uint8_t * buf = buf0 ; \n int rest = buf_size ; \n if ( ! c -> header_parsed ) { \n int hdrsize = adx_decode_header ( avctx , buf , rest ) ; \n if ( hdrsize == 0 ) return -1 ; \n c -> header_parsed = 1 ; \n buf += hdrsize ; \n rest -= hdrsize ; \n } \n if ( c -> in_temp ) { \n int copysize = 18 * avctx -> channels - c -> in_temp ; \n memcpy ( c -> dec_temp + c -> in_temp , buf , copysize ) ; \n rest -= copysize ; \n buf += copysize ; \n if ( avctx -> channels == 1 ) { \n adx_decode ( samples , c -> dec_temp , c -> prev ) ; \n samples += 32 ; \n } else { \n adx_decode_stereo ( samples , c -> dec_temp , c -> prev ) ; \n samples += 32 * 2 ; \n } \n } \n if ( avctx -> channels == 1 ) { \n while ( rest >= 18 ) { \n adx_decode ( samples , buf , c -> prev ) ; \n rest -= 18 ; \n buf += 18 ; \n samples += 32 ; \n } \n } else { \n while ( rest >= 18 * 2 ) { \n adx_decode_stereo ( samples , buf , c -> prev ) ; \n rest -= 18 * 2 ; \n buf += 18 * 2 ; \n samples += 32 * 2 ; \n } \n } \n c -> in_temp = rest ; \n if ( rest ) { \n memcpy ( c -> dec_temp , buf , rest ) ; \n buf += rest ; \n } \n * data_size = ( uint8_t * ) samples - ( uint8_t * ) data ; \n return buf - buf0 ; \n }", "idx": 19749}
{"project": "FFmpeg", "commit_id": "1918057c8a3bc37c27e476d16736fe8bc76afd34", "target": 0, "func": "static void spatial_compose53i ( IDWTELEM * buffer , int width , int height , int stride ) { \n dwt_compose_t cs ; \n spatial_compose53i_init ( & cs , buffer , height , stride ) ; \n while ( cs . y <= height ) \n spatial_compose53i_dy ( & cs , buffer , width , height , stride ) ; \n }", "idx": 19753}
{"project": "FFmpeg", "commit_id": "c854102da773fa898cc6dbc8ca474b1088ce5f12", "target": 0, "func": "static void assert_codec_experimental ( AVCodecContext * c , int encoder ) \n { \n const char * codec_string = encoder ? \" \" : \" \" ; \n AVCodec * codec ; \n if ( c -> codec -> capabilities & CODEC_CAP_EXPERIMENTAL && \n c -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" \n \" \\n \\n \" , \n codec_string , c -> codec -> name ) ; \n codec = encoder ? avcodec_find_encoder ( c -> codec -> id ) : avcodec_find_decoder ( c -> codec -> id ) ; \n if ( ! ( codec -> capabilities & CODEC_CAP_EXPERIMENTAL ) ) \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , \n codec_string , codec -> name ) ; \n exit ( 1 ) ; \n } \n }", "idx": 19754}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pnm_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 19756}
{"project": "FFmpeg", "commit_id": "2f014567cfd63e58156f60666f1a61ba147276ab", "target": 1, "func": "static const uint8_t * avc_mp4_find_startcode ( const uint8_t * start , const uint8_t * end , int nal_length_size ) \n { \n int res = 0 ; \n if ( end - start < nal_length_size ) \n return NULL ; \n while ( nal_length_size -- ) \n res = ( res << 8 ) | * start ++ ; \n if ( start + res > end || res < 0 || start + res < start ) \n return NULL ; \n return start + res ; \n }", "idx": 19769}
{"project": "FFmpeg", "commit_id": "52268def10f33e36ca1190906c8235f4e91fcf24", "target": 1, "func": "static int thp_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) == MKTAG ( ' ' , ' ' , ' ' , ' \\0 ' ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 19773}
{"project": "FFmpeg", "commit_id": "1aa708988ac131cf7d5c8bd59aca256a7c974df9", "target": 1, "func": "static int handle_packets ( MpegTSContext * ts , int nb_packets ) \n { \n AVFormatContext * s = ts -> stream ; \n uint8_t packet [ TS_PACKET_SIZE ] ; \n int packet_num , ret = 0 ; \n if ( avio_tell ( s -> pb ) != ts -> last_pos ) { \n int i ; \n av_dlog ( ts -> stream , \" \\n \" ) ; \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) { \n if ( ts -> pids [ i ] ) { \n if ( ts -> pids [ i ] -> type == MPEGTS_PES ) { \n PESContext * pes = ts -> pids [ i ] -> u . pes_filter . opaque ; \n av_freep ( & pes -> buffer ) ; \n pes -> data_index = 0 ; \n pes -> state = MPEGTS_SKIP ; \n } \n ts -> pids [ i ] -> last_cc = -1 ; \n } \n } \n } \n ts -> stop_parse = 0 ; \n packet_num = 0 ; \n for ( ; ; ) { \n if ( ts -> stop_parse > 0 ) \n break ; \n packet_num ++ ; \n if ( nb_packets != 0 && packet_num >= nb_packets ) \n break ; \n ret = read_packet ( s , packet , ts -> raw_packet_size ) ; \n if ( ret != 0 ) \n break ; \n ret = handle_packet ( ts , packet ) ; \n if ( ret != 0 ) \n break ; \n } \n ts -> last_pos = avio_tell ( s -> pb ) ; \n return ret ; \n }", "idx": 19775}
{"project": "FFmpeg", "commit_id": "af9ec3dd1d9e90ec8134b01074b7beb01a1beb1a", "target": 1, "func": "AVInputFormat * av_probe_input_format3 ( AVProbeData * pd , int is_opened , int * score_ret ) \n { \n AVProbeData lpd = * pd ; \n AVInputFormat * fmt1 = NULL , * fmt ; \n int score , nodat = 0 , score_max = 0 ; \n if ( lpd . buf_size > 10 && ff_id3v2_match ( lpd . buf , ID3v2_DEFAULT_MAGIC ) ) { \n int id3len = ff_id3v2_tag_len ( lpd . buf ) ; \n if ( lpd . buf_size > id3len + 16 ) { \n lpd . buf += id3len ; \n lpd . buf_size -= id3len ; \n } else \n nodat = 1 ; \n } \n fmt = NULL ; \n while ( ( fmt1 = av_iformat_next ( fmt1 ) ) ) { \n if ( ! is_opened == ! ( fmt1 -> flags & AVFMT_NOFILE ) ) \n continue ; \n score = 0 ; \n if ( fmt1 -> read_probe ) { \n score = fmt1 -> read_probe ( & lpd ) ; \n if ( fmt1 -> extensions && av_match_ext ( lpd . filename , fmt1 -> extensions ) ) \n score = FFMAX ( score , nodat ? AVPROBE_SCORE_MAX / 4 - 1 : 1 ) ; \n } else if ( fmt1 -> extensions ) { \n if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) ) { \n score = 50 ; \n } \n } \n if ( score > score_max ) { \n score_max = score ; \n fmt = fmt1 ; \n } else if ( score == score_max ) \n fmt = NULL ; \n } \n * score_ret = score_max ; \n return fmt ; \n }", "idx": 19780}
{"project": "FFmpeg", "commit_id": "088eca28164c8cd3b72b0c3d3f9e3fe5ee5cb28f", "target": 1, "func": "static inline int available_samples ( AVFrame * out ) \n { \n int bytes_per_sample = av_get_bytes_per_sample ( out -> format ) ; \n int samples = out -> linesize [ 0 ] / bytes_per_sample ; \n if ( av_sample_fmt_is_planar ( out -> format ) ) { \n return samples ; \n } else { \n int channels = av_get_channel_layout_nb_channels ( out -> channel_layout ) ; \n return samples / channels ; \n } \n }", "idx": 19784}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static int rv40_v_loop_filter_strength ( uint8_t * src , int stride , \n int beta , int beta2 , int edge , \n int * p1 , int * q1 ) \n { \n return rv40_loop_filter_strength ( src , 1 , stride , beta , beta2 , edge , p1 , q1 ) ; \n }", "idx": 19789}
{"project": "FFmpeg", "commit_id": "5430839144c6da0160e8e0cfb0c8db01de432e94", "target": 1, "func": "static int cmv_process_header ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) \n { \n int pal_start , pal_count , i , ret , fps ; \n if ( buf_end - buf < 16 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n s -> width = AV_RL16 ( & buf [ 4 ] ) ; \n s -> height = AV_RL16 ( & buf [ 6 ] ) ; \n ret = ff_set_dimensions ( s -> avctx , s -> width , s -> height ) ; \n if ( ret < 0 ) \n return ret ; \n fps = AV_RL16 ( & buf [ 10 ] ) ; \n if ( fps > 0 ) \n s -> avctx -> time_base = ( AVRational ) { 1 , fps } ; \n pal_start = AV_RL16 ( & buf [ 12 ] ) ; \n pal_count = AV_RL16 ( & buf [ 14 ] ) ; \n buf += 16 ; \n for ( i = pal_start ; i < pal_start + pal_count && i < AVPALETTE_COUNT && buf_end - buf >= 3 ; i ++ ) { \n s -> palette [ i ] = AV_RB24 ( buf ) ; \n buf += 3 ; \n return 0 ;", "idx": 19797}
{"project": "FFmpeg", "commit_id": "3cb0bec6870cf0bb7879f7bfd4119ef39a02a464", "target": 1, "func": "static void handle_child_exit ( int sig ) \n { \n pid_t pid ; \n int status ; \n while ( ( pid = waitpid ( -1 , & status , WNOHANG ) ) > 0 ) { \n FFServerStream * feed ; \n for ( feed = config . first_feed ; feed ; feed = feed -> next ) { \n if ( feed -> pid == pid ) { \n int uptime = time ( 0 ) - feed -> pid_start ; \n feed -> pid = 0 ; \n fprintf ( stderr , \" \\n \" , feed -> filename , pid , status , uptime ) ; \n if ( uptime < 30 ) \n feed -> child_argv = 0 ; \n } \n } \n } \n need_to_start_children = 1 ; \n }", "idx": 19804}
{"project": "FFmpeg", "commit_id": "bc7e128a6e8e2a79d0ff7cab5e8a799b3ea042ea", "target": 1, "func": "static int wsaud_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVIOContext * pb = s -> pb ; \n unsigned char preamble [ AUD_CHUNK_PREAMBLE_SIZE ] ; \n unsigned int chunk_size ; \n int ret = 0 ; \n AVStream * st = s -> streams [ 0 ] ; \n if ( avio_read ( pb , preamble , AUD_CHUNK_PREAMBLE_SIZE ) != \n AUD_CHUNK_PREAMBLE_SIZE ) \n return AVERROR ( EIO ) ; \n if ( AV_RL32 ( & preamble [ 4 ] ) != AUD_CHUNK_SIGNATURE ) \n chunk_size = AV_RL16 ( & preamble [ 0 ] ) ; \n if ( st -> codecpar -> codec_id == AV_CODEC_ID_WESTWOOD_SND1 ) { \n int out_size = AV_RL16 ( & preamble [ 2 ] ) ; \n if ( ( ret = av_new_packet ( pkt , chunk_size + 4 ) ) < 0 ) \n return ret ; \n if ( ( ret = avio_read ( pb , & pkt -> data [ 4 ] , chunk_size ) ) != chunk_size ) \n return ret < 0 ? ret : AVERROR ( EIO ) ; \n AV_WL16 ( & pkt -> data [ 0 ] , out_size ) ; \n AV_WL16 ( & pkt -> data [ 2 ] , chunk_size ) ; \n pkt -> duration = out_size ; \n } else { \n ret = av_get_packet ( pb , pkt , chunk_size ) ; \n if ( ret != chunk_size ) \n return AVERROR ( EIO ) ; \n pkt -> duration = ( chunk_size * 2 ) / st -> codecpar -> channels ; \n pkt -> stream_index = st -> index ; \n return ret ;", "idx": 19807}
{"project": "FFmpeg", "commit_id": "301cc4f37050ed5c08aec8de6d4e22ede2ce9a9f", "target": 1, "func": "static const AVOption * av_set_number ( void * obj , const char * name , double num , int den , int64_t intnum ) { \n const AVOption * o = av_find_opt ( obj , name , NULL , 0 , 0 ) ; \n void * dst ; \n if ( ! o || o -> offset <= 0 ) \n return NULL ; \n if ( o -> max * den < num * intnum || o -> min * den > num * intnum ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , num , name ) ; \n return NULL ; \n } \n dst = ( ( uint8_t * ) obj ) + o -> offset ; \n switch ( o -> type ) { \n case FF_OPT_TYPE_FLAGS : \n case FF_OPT_TYPE_INT : * ( int * ) dst = llrint ( num / den ) * intnum ; break ; \n case FF_OPT_TYPE_INT64 : * ( int64_t * ) dst = llrint ( num / den ) * intnum ; break ; \n case FF_OPT_TYPE_FLOAT : * ( float * ) dst = num * intnum / den ; break ; \n case FF_OPT_TYPE_DOUBLE : * ( double * ) dst = num * intnum / den ; break ; \n case FF_OPT_TYPE_RATIONAL : \n if ( ( int ) num == num ) * ( AVRational * ) dst = ( AVRational ) { num * intnum , den } ; \n else * ( AVRational * ) dst = av_d2q ( num * intnum / den , 1 << 24 ) ; \n break ; \n default : \n return NULL ; \n } \n return o ; \n }", "idx": 19812}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static void jpeg2000_flush ( Jpeg2000DecoderContext * s ) \n { \n if ( * s -> buf == 0xff ) \n s -> buf ++ ; \n s -> bit_index = 8 ; \n s -> buf ++ ; \n }", "idx": 19813}
{"project": "FFmpeg", "commit_id": "ba4ffc2b48832c7ca95ac6e48f8c4f23aa4ad3a6", "target": 1, "func": "static void flush_dpb ( AVCodecContext * avctx ) { \n H264Context * h = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n h -> delayed_pic [ i ] = NULL ; \n h -> delayed_output_pic = NULL ; \n idr ( h ) ; \n }", "idx": 19816}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME ( yuv2yuyv422_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n x86_reg uv_off = c -> uv_off << 1 ; \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \"  \n YSCALEYUV2PACKED ( % % REGBP , % 5 , % 6 ) \n WRITEYUY2 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) , \" \" ( uv_off ) \n ) ; \n }", "idx": 19819}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed16 ( AVCodecContext * avctx , const AVFrame * frame , opj_image_t * image ) \n { \n int compno ; \n int x ; \n int y ; \n int * image_line ; \n int frame_index ; \n const int numcomps = image -> numcomps ; \n uint16_t * frame_ptr = ( uint16_t * ) frame -> data [ 0 ] ; \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n if ( image -> comps [ compno ] . w > frame -> linesize [ 0 ] / numcomps ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n for ( y = 0 ; y < avctx -> height ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n frame_index = y * ( frame -> linesize [ 0 ] / 2 ) + compno ; \n for ( x = 0 ; x < avctx -> width ; ++ x ) { \n image_line [ x ] = frame_ptr [ frame_index ] ; \n frame_index += numcomps ; \n } \n for ( ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - 1 ] ; \n } \n } \n for ( ; y < image -> comps [ compno ] . h ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n for ( x = 0 ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - image -> comps [ compno ] . w ] ; \n } \n } \n } \n return 1 ; \n }", "idx": 19826}
{"project": "FFmpeg", "commit_id": "fc06ee6ee377cc3b512dff8f02057e26311bc4da", "target": 1, "func": "static int mm_decode_inter ( MmContext * s , int half_horiz , int half_vert ) \n { \n int data_off = bytestream2_get_le16 ( & s -> gb ) , y ; \n GetByteContext data_ptr ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < data_off ) \n return AVERROR_INVALIDDATA ; \n bytestream2_init ( & data_ptr , s -> gb . buffer + data_off , bytestream2_get_bytes_left ( & s -> gb ) - data_off ) ; \n while ( s -> gb . buffer < data_ptr . buffer_start ) { \n int i , j ; \n int length = bytestream2_get_byte ( & s -> gb ) ; \n int x = bytestream2_get_byte ( & s -> gb ) + ( ( length & 0x80 ) << 1 ) ; \n length &= 0x7F ; \n if ( length == 0 ) { \n y += x ; \n continue ; \n } \n if ( y + half_vert >= s -> avctx -> height ) \n return 0 ; \n for ( i = 0 ; i < length ; i ++ ) { \n int replace_array = bytestream2_get_byte ( & s -> gb ) ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n int replace = ( replace_array >> ( 7 - j ) ) & 1 ; \n if ( replace ) { \n int color = bytestream2_get_byte ( & data_ptr ) ; \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n if ( half_vert ) { \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n } \n } \n x += 1 + half_horiz ; \n } \n } \n y += 1 + half_vert ; \n } \n return 0 ; \n }", "idx": 19830}
{"project": "FFmpeg", "commit_id": "5255acc6beb61ef30f43bc2c746b0b487815f76d", "target": 1, "func": "static av_cold int decode_end ( AVCodecContext * avctx ) \n { \n ALSDecContext * ctx = avctx -> priv_data ; \n av_freep ( & ctx -> sconf . chan_pos ) ; \n ff_bgmc_end ( & ctx -> bgmc_lut , & ctx -> bgmc_lut_status ) ; \n av_freep ( & ctx -> const_block ) ; \n av_freep ( & ctx -> shift_lsbs ) ; \n av_freep ( & ctx -> opt_order ) ; \n av_freep ( & ctx -> store_prev_samples ) ; \n av_freep ( & ctx -> use_ltp ) ; \n av_freep ( & ctx -> ltp_lag ) ; \n av_freep ( & ctx -> ltp_gain ) ; \n av_freep ( & ctx -> ltp_gain_buffer ) ; \n av_freep ( & ctx -> quant_cof ) ; \n av_freep ( & ctx -> lpc_cof ) ; \n av_freep ( & ctx -> quant_cof_buffer ) ; \n av_freep ( & ctx -> lpc_cof_buffer ) ; \n av_freep ( & ctx -> lpc_cof_reversed_buffer ) ; \n av_freep ( & ctx -> prev_raw_samples ) ; \n av_freep ( & ctx -> raw_samples ) ; \n av_freep ( & ctx -> raw_buffer ) ; \n av_freep ( & ctx -> chan_data ) ; \n av_freep ( & ctx -> chan_data_buffer ) ; \n av_freep ( & ctx -> reverted_channels ) ; \n return 0 ; \n }", "idx": 19832}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int xan_decode_init ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n if ( ( avctx -> codec -> id == CODEC_ID_XAN_WC3 ) && \n ( s -> avctx -> palctrl == NULL ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n avctx -> has_b_frames = 0 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n y_r_table [ i ] = Y_R * i ; \n y_g_table [ i ] = Y_G * i ; \n y_b_table [ i ] = Y_B * i ; \n u_r_table [ i ] = U_R * i ; \n u_g_table [ i ] = U_G * i ; \n u_b_table [ i ] = U_B * i ; \n v_r_table [ i ] = V_R * i ; \n v_g_table [ i ] = V_G * i ; \n v_b_table [ i ] = V_B * i ; \n } \n s -> buffer1 = av_malloc ( avctx -> width * avctx -> height ) ; \n s -> buffer2 = av_malloc ( avctx -> width * avctx -> height ) ; \n if ( ! s -> buffer1 || ! s -> buffer2 ) \n return 0 ; \n }", "idx": 19836}
{"project": "FFmpeg", "commit_id": "e924967fd5ec240cf97022f054cb02a0bc7101d9", "target": 1, "func": "static void process_tns_coeffs ( TemporalNoiseShaping * tns , double * coef_raw , \n int * order_p , int w , int filt ) \n { \n int i , j , order = * order_p ; \n int * idx = tns -> coef_idx [ w ] [ filt ] ; \n float * lpc = tns -> coef [ w ] [ filt ] ; \n float temp [ TNS_MAX_ORDER ] = { 0.0f } , out [ TNS_MAX_ORDER ] = { 0.0f } ; \n if ( ! order ) \n return ; \n for ( i = 0 ; i < order ; i ++ ) { \n idx [ i ] = quant_array_idx ( coef_raw [ i ] , tns_tmp2_map_0_4 , 16 ) ; \n lpc [ i ] = tns_tmp2_map_0_4 [ idx [ i ] ] ; \n } \n for ( i = order - 1 ; i > -1 ; i -- ) { \n lpc [ i ] = ( fabs ( lpc [ i ] ) > 0.1f ) ? lpc [ i ] : 0.0f ; \n if ( lpc [ i ] != 0.0 ) { \n order = i ; \n break ; \n } \n } \n out [ 0 ] = 1.0f ; \n for ( i = 1 ; i <= order ; i ++ ) { \n for ( j = 1 ; j < i ; j ++ ) { \n temp [ j ] = out [ j ] + lpc [ i ] * out [ i - j ] ; \n } \n for ( j = 1 ; j <= i ; j ++ ) { \n out [ j ] = temp [ j ] ; \n } \n out [ i ] = lpc [ i - 1 ] ; \n } \n * order_p = order ; \n memcpy ( lpc , out , TNS_MAX_ORDER * sizeof ( float ) ) ; \n }", "idx": 19841}
{"project": "FFmpeg", "commit_id": "2391e46430fa2af28542124dbcfc935c0a5ce82c", "target": 0, "func": "int ff_mpv_lowest_referenced_row ( MpegEncContext * s , int dir ) \n { \n int my_max = INT_MIN , my_min = INT_MAX , qpel_shift = ! s -> quarter_sample ; \n int my , off , i , mvs ; \n if ( s -> picture_structure != PICT_FRAME || s -> mcsel ) \n goto unhandled ; \n switch ( s -> mv_type ) { \n case MV_TYPE_16X16 : \n mvs = 1 ; \n break ; \n case MV_TYPE_16X8 : \n mvs = 2 ; \n break ; \n case MV_TYPE_8X8 : \n mvs = 4 ; \n break ; \n default : \n goto unhandled ; \n } \n for ( i = 0 ; i < mvs ; i ++ ) { \n my = s -> mv [ dir ] [ i ] [ 1 ] << qpel_shift ; \n my_max = FFMAX ( my_max , my ) ; \n my_min = FFMIN ( my_min , my ) ; \n } \n off = ( FFMAX ( - my_min , my_max ) + 63 ) >> 6 ; \n return FFMIN ( FFMAX ( s -> mb_y + off , 0 ) , s -> mb_height - 1 ) ; \n unhandled : \n return s -> mb_height - 1 ; \n }", "idx": 19842}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "unsigned long get_checksum ( ByteIOContext * s ) { \n s -> checksum = s -> update_checksum ( s -> checksum , s -> checksum_ptr , s -> buf_ptr - s -> checksum_ptr ) ; \n s -> checksum_ptr = NULL ; \n return s -> checksum ; \n }", "idx": 19850}
{"project": "FFmpeg", "commit_id": "26a7d6a301b9b6c67153c87d42db145cdc0e57cf", "target": 0, "func": "static int decode_rle_bpp2 ( AVCodecContext * avctx , AVFrame * p , GetByteContext * gbc ) \n { \n int offset = avctx -> width ; \n uint8_t * outdata = p -> data [ 0 ] ; \n int i , j ; \n for ( i = 0 ; i < avctx -> height ; i ++ ) { \n int size , left , code , pix ; \n uint8_t * out = outdata ; \n int pos = 0 ; \n size = left = bytestream2_get_be16 ( gbc ) ; \n if ( bytestream2_get_bytes_left ( gbc ) < size ) \n return AVERROR_INVALIDDATA ; \n while ( left > 0 ) { \n code = bytestream2_get_byte ( gbc ) ; \n if ( code & 0x80 ) { \n pix = bytestream2_get_byte ( gbc ) ; \n for ( j = 0 ; j < 257 - code ; j ++ ) { \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0xC0 ) >> 6 ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0x30 ) >> 4 ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0x0C ) >> 2 ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0x03 ) ; \n } \n left -= 2 ; \n } else { \n for ( j = 0 ; j < code + 1 ; j ++ ) { \n pix = bytestream2_get_byte ( gbc ) ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0xC0 ) >> 6 ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0x30 ) >> 4 ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0x0C ) >> 2 ; \n if ( pos < offset ) \n out [ pos ++ ] = ( pix & 0x03 ) ; \n } \n left -= 1 + ( code + 1 ) ; \n } \n } \n outdata += p -> linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 19851}
{"project": "FFmpeg", "commit_id": "185142a5ea93ef723f70a3ea43797f6c8827eb79", "target": 0, "func": "void ff_fmt_convert_init_x86 ( FmtConvertContext * c , AVCodecContext * avctx ) \n { \n int mm_flags = av_get_cpu_flags ( ) ; \n if ( mm_flags & AV_CPU_FLAG_MMX ) { \n #if HAVE_YASM  \n  \n  c -> float_interleave = float_interleave_mmx ; \n if ( mm_flags & AV_CPU_FLAG_3DNOW ) { \n if ( ! ( avctx -> flags & CODEC_FLAG_BITEXACT ) ) { \n c -> float_to_int16 = ff_float_to_int16_3dnow ; \n c -> float_to_int16_interleave = float_to_int16_interleave_3dnow ; \n } \n } \n if ( mm_flags & AV_CPU_FLAG_3DNOWEXT ) { \n if ( ! ( avctx -> flags & CODEC_FLAG_BITEXACT ) ) { \n c -> float_to_int16_interleave = float_to_int16_interleave_3dn2 ; \n } \n } \n #endif \n if ( mm_flags & AV_CPU_FLAG_SSE ) { \n c -> int32_to_float_fmul_scalar = int32_to_float_fmul_scalar_sse ; \n #if HAVE_YASM  \n  \n  c -> float_to_int16 = ff_float_to_int16_sse ; \n c -> float_to_int16_interleave = float_to_int16_interleave_sse ; \n c -> float_interleave = float_interleave_sse ; \n #endif \n } \n if ( mm_flags & AV_CPU_FLAG_SSE2 ) { \n c -> int32_to_float_fmul_scalar = int32_to_float_fmul_scalar_sse2 ; \n #if HAVE_YASM  \n  \n  c -> float_to_int16 = ff_float_to_int16_sse2 ; \n c -> float_to_int16_interleave = float_to_int16_interleave_sse2 ; \n #endif \n } \n } \n }", "idx": 19852}
{"project": "FFmpeg", "commit_id": "24fee95321c1463360ba7042d026dae021854360", "target": 1, "func": "static int update_offset ( RTMPContext * rt , int size ) \n { \n int old_flv_size ; \n if ( rt -> flv_off < rt -> flv_size ) { \n old_flv_size = rt -> flv_size ; \n rt -> flv_size += size + 15 ; \n } else { \n old_flv_size = 0 ; \n rt -> flv_size = size + 15 ; \n rt -> flv_off = 0 ; \n } \n return old_flv_size ; \n }", "idx": 19855}
{"project": "FFmpeg", "commit_id": "6e20554a6d33e92b81dc3cfed6082e03bff2a7f8", "target": 1, "func": "static void decode_mb ( MadContext * t , int inter ) \n { \n MpegEncContext * s = & t -> s ; \n int mv_map = 0 ; \n int mv_x , mv_y ; \n int j ; \n if ( inter ) { \n int v = decode210 ( & s -> gb ) ; \n if ( v < 2 ) { \n mv_map = v ? get_bits ( & s -> gb , 6 ) : 63 ; \n mv_x = decode_motion ( & s -> gb ) ; \n mv_y = decode_motion ( & s -> gb ) ; \n } else { \n mv_map = 0 ; \n } \n } \n for ( j = 0 ; j < 6 ; j ++ ) { \n if ( mv_map & ( 1 << j ) ) { \n int add = 2 * decode_motion ( & s -> gb ) ; \n comp_block ( t , s -> mb_x , s -> mb_y , j , mv_x , mv_y , add ) ; \n } else { \n s -> dsp . clear_block ( t -> block ) ; \n decode_block_intra ( t , t -> block ) ; \n idct_put ( t , t -> block , s -> mb_x , s -> mb_y , j ) ; \n } \n } \n }", "idx": 19874}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static int adx_decode_header ( AVCodecContext * avctx , const unsigned char * buf , size_t bufsize ) \n { \n int offset ; \n int channels , freq , size ; \n offset = is_adx ( buf , bufsize ) ; \n if ( offset == 0 ) return 0 ; \n channels = buf [ 7 ] ; \n freq = read_long ( buf + 8 ) ; \n size = read_long ( buf + 12 ) ; \n avctx -> sample_rate = freq ; \n avctx -> channels = channels ; \n avctx -> bit_rate = freq * channels * 18 * 8 / 32 ; \n return offset ; \n }", "idx": 19881}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "int ff_ps_apply ( AVCodecContext * avctx , PSContext * ps , float L [ 2 ] [ 38 ] [ 64 ] , float R [ 2 ] [ 38 ] [ 64 ] , int top ) \n { \n float Lbuf [ 91 ] [ 32 ] [ 2 ] ; \n float Rbuf [ 91 ] [ 32 ] [ 2 ] ; \n const int len = 32 ; \n int is34 = ps -> is34bands ; \n top += NR_BANDS [ is34 ] - 64 ; \n memset ( ps -> delay + top , 0 , ( NR_BANDS [ is34 ] - top ) * sizeof ( ps -> delay [ 0 ] ) ) ; \n if ( top < NR_ALLPASS_BANDS [ is34 ] ) \n memset ( ps -> ap_delay + top , 0 , ( NR_ALLPASS_BANDS [ is34 ] - top ) * sizeof ( ps -> ap_delay [ 0 ] ) ) ; \n hybrid_analysis ( Lbuf , ps -> in_buf , L , is34 , len ) ; \n decorrelation ( ps , Rbuf , Lbuf , is34 ) ; \n stereo_processing ( ps , Lbuf , Rbuf , is34 ) ; \n hybrid_synthesis ( L , Lbuf , is34 , len ) ; \n hybrid_synthesis ( R , Rbuf , is34 , len ) ; \n return 0 ; \n }", "idx": 19885}
{"project": "FFmpeg", "commit_id": "f18d2dff1194b34b79dc7641aafe54d1df349e40", "target": 0, "func": "static void bl_intrp ( EVRCContext * e , float * ex , float delay ) \n { \n float * f ; \n int offset , i , coef_idx ; \n int16_t t ; \n offset = lrintf ( fabs ( delay ) ) ; \n t = ( offset - delay + 0.5 ) * 8.0 + 0.5 ; \n if ( t == 8 ) { \n t = 0 ; \n offset -- ; \n } \n f = ex - offset - 8 ; \n coef_idx = t * ( 2 * 8 + 1 ) ; \n ex [ 0 ] = 0.0 ; \n for ( i = 0 ; i < 2 * 8 + 1 ; i ++ ) \n ex [ 0 ] += e -> interpolation_coeffs [ coef_idx + i ] * f [ i ] ; \n }", "idx": 19887}
{"project": "FFmpeg", "commit_id": "b1e242bc565665420661e016127fe07b4b615ecb", "target": 1, "func": "static uint32_t epic_decode_pixel_pred ( ePICContext * dc , int x , int y , \n const uint32_t * curr_row , \n const uint32_t * above_row ) \n { \n uint32_t N , W , NW , pred ; \n unsigned delta ; \n int GN , GW , GNW , R , G , B ; \n if ( x && y ) { \n W = curr_row [ x - 1 ] ; \n N = above_row [ x ] ; \n NW = above_row [ x - 1 ] ; \n GN = ( N >> G_shift ) & 0xFF ; \n GW = ( W >> G_shift ) & 0xFF ; \n GNW = ( NW >> G_shift ) & 0xFF ; \n G = epic_decode_component_pred ( dc , GN , GW , GNW ) ; \n R = G + epic_decode_component_pred ( dc , \n ( ( N >> R_shift ) & 0xFF ) - GN , \n ( ( W >> R_shift ) & 0xFF ) - GW , \n ( ( NW >> R_shift ) & 0xFF ) - GNW ) ; \n B = G + epic_decode_component_pred ( dc , \n ( ( N >> B_shift ) & 0xFF ) - GN , \n ( ( W >> B_shift ) & 0xFF ) - GW , \n ( ( NW >> B_shift ) & 0xFF ) - GNW ) ; \n } else { \n if ( x ) \n pred = curr_row [ x - 1 ] ; \n else \n pred = above_row [ x ] ; \n delta = ff_els_decode_unsigned ( & dc -> els_ctx , & dc -> unsigned_rung ) ; \n R = ( ( pred >> R_shift ) & 0xFF ) - TOSIGNED ( delta ) ; \n delta = ff_els_decode_unsigned ( & dc -> els_ctx , & dc -> unsigned_rung ) ; \n G = ( ( pred >> G_shift ) & 0xFF ) - TOSIGNED ( delta ) ; \n delta = ff_els_decode_unsigned ( & dc -> els_ctx , & dc -> unsigned_rung ) ; \n B = ( ( pred >> B_shift ) & 0xFF ) - TOSIGNED ( delta ) ; \n return ( R << R_shift ) | ( G << G_shift ) | ( B << B_shift ) ;", "idx": 19898}
{"project": "FFmpeg", "commit_id": "2ee380aefbb92c89e8e9c7aa5846aa404919ec7c", "target": 1, "func": "int ff_vaapi_render_picture ( struct vaapi_context * vactx , VASurfaceID surface ) \n { \n VABufferID va_buffers [ 3 ] ; \n unsigned int n_va_buffers = 0 ; \n vaUnmapBuffer ( vactx -> display , vactx -> pic_param_buf_id ) ; \n va_buffers [ n_va_buffers ++ ] = vactx -> pic_param_buf_id ; \n if ( vactx -> iq_matrix_buf_id ) { \n vaUnmapBuffer ( vactx -> display , vactx -> iq_matrix_buf_id ) ; \n va_buffers [ n_va_buffers ++ ] = vactx -> iq_matrix_buf_id ; \n } \n if ( vactx -> bitplane_buf_id ) { \n vaUnmapBuffer ( vactx -> display , vactx -> bitplane_buf_id ) ; \n va_buffers [ n_va_buffers ++ ] = vactx -> bitplane_buf_id ; \n } \n if ( vaBeginPicture ( vactx -> display , vactx -> context_id , \n surface ) != VA_STATUS_SUCCESS ) \n return -1 ; \n if ( vaRenderPicture ( vactx -> display , vactx -> context_id , \n va_buffers , n_va_buffers ) != VA_STATUS_SUCCESS ) \n return -1 ; \n if ( vaRenderPicture ( vactx -> display , vactx -> context_id , \n vactx -> slice_buf_ids , \n vactx -> n_slice_buf_ids ) != VA_STATUS_SUCCESS ) \n return -1 ; \n if ( vaEndPicture ( vactx -> display , vactx -> context_id ) != VA_STATUS_SUCCESS ) \n return -1 ; \n }", "idx": 19905}
{"project": "FFmpeg", "commit_id": "ef4dc3e55b677b27f6e8f471946c711bcf92da82", "target": 1, "func": "static int write_number ( void * obj , const AVOption * o , void * dst , double num , int den , int64_t intnum ) \n { \n if ( o -> max * den < num * intnum || o -> min * den > num * intnum ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , \n num * intnum / den , o -> name ) ; \n return AVERROR ( ERANGE ) ; \n } \n switch ( o -> type ) { \n case AV_OPT_TYPE_FLAGS : \n case AV_OPT_TYPE_INT : * ( int * ) dst = llrint ( num / den ) * intnum ; break ; \n case AV_OPT_TYPE_INT64 : * ( int64_t * ) dst = llrint ( num / den ) * intnum ; break ; \n case AV_OPT_TYPE_FLOAT : * ( float * ) dst = num * intnum / den ; break ; \n case AV_OPT_TYPE_DOUBLE : * ( double * ) dst = num * intnum / den ; break ; \n case AV_OPT_TYPE_RATIONAL : \n if ( ( int ) num == num ) * ( AVRational * ) dst = ( AVRational ) { num * intnum , den } ; \n else * ( AVRational * ) dst = av_d2q ( num * intnum / den , 1 << 24 ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 19911}
{"project": "FFmpeg", "commit_id": "4bd869eb7c8416942f12b61db6439d2bfc474456", "target": 1, "func": "static int calc_add_mv ( RV34DecContext * r , int dir , int val ) \n { \n int mul = dir ? - r -> mv_weight2 : r -> mv_weight1 ; \n return ( val * mul + 0x2000 ) >> 14 ; \n }", "idx": 19914}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "func": "static void put_line ( uint8_t * dst , int size , int width , const int * runs ) \n { \n PutBitContext pb ; \n int run , mode = ~ 0 , pix_left = width , run_idx = 0 ; \n init_put_bits ( & pb , dst , size * 8 ) ; \n while ( pix_left > 0 ) { \n run = runs [ run_idx ++ ] ; \n mode = ~ mode ; \n pix_left -= run ; \n for ( ; run > 16 ; run -= 16 ) \n put_sbits ( & pb , 16 , mode ) ; \n if ( run ) \n put_sbits ( & pb , run , mode ) ; \n } \n flush_put_bits ( & pb ) ; \n }", "idx": 19915}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) \n { \n flat_print_key_prefix ( wctx ) ; \n printf ( \" \\n \" , key , value ) ; \n }", "idx": 19920}
{"project": "FFmpeg", "commit_id": "50b4468598cbc032c0ec4597df9637f71b9ef664", "target": 0, "func": "void av_fifo_write ( AVFifoBuffer * f , const uint8_t * buf , int size ) \n { \n while ( size > 0 ) { \n int len = FFMIN ( f -> end - f -> wptr , size ) ; \n memcpy ( f -> wptr , buf , len ) ; \n f -> wptr += len ; \n if ( f -> wptr >= f -> end ) \n f -> wptr = f -> buffer ; \n buf += len ; \n size -= len ; \n } \n }", "idx": 19921}
{"project": "FFmpeg", "commit_id": "162f1fbc147bbff6e23b4df1e587cec5d5111052", "target": 0, "func": "static int handle_packets ( MpegTSContext * ts , int nb_packets ) \n { \n AVFormatContext * s = ts -> stream ; \n uint8_t packet [ TS_PACKET_SIZE ] ; \n int packet_num , ret = 0 ; \n if ( avio_tell ( s -> pb ) != ts -> last_pos ) { \n int i ; \n av_dlog ( \" \\n \" ) ; \n for ( i = 0 ; i < NB_PID_MAX ; i ++ ) { \n if ( ts -> pids [ i ] && ts -> pids [ i ] -> type == MPEGTS_PES ) { \n PESContext * pes = ts -> pids [ i ] -> u . pes_filter . opaque ; \n av_freep ( & pes -> buffer ) ; \n ts -> pids [ i ] -> last_cc = -1 ; \n pes -> data_index = 0 ; \n pes -> state = MPEGTS_SKIP ; \n } \n } \n } \n ts -> stop_parse = 0 ; \n packet_num = 0 ; \n for ( ; ; ) { \n if ( ts -> stop_parse > 0 ) \n break ; \n packet_num ++ ; \n if ( nb_packets != 0 && packet_num >= nb_packets ) \n break ; \n ret = read_packet ( s , packet , ts -> raw_packet_size ) ; \n if ( ret != 0 ) \n break ; \n ret = handle_packet ( ts , packet ) ; \n if ( ret != 0 ) \n break ; \n } \n ts -> last_pos = avio_tell ( s -> pb ) ; \n return ret ; \n }", "idx": 19922}
{"project": "FFmpeg", "commit_id": "6a4832caaede15e3d918b1408ff83fe30324507b", "target": 0, "func": "DIRAC_PIXOP ( put , ff_put , mmx )  \n DIRAC_PIXOP ( avg , ff_avg , mmx )  \n DIRAC_PIXOP ( avg , ff_avg , mmxext )  \n void ff_put_dirac_pixels16_sse2 ( uint8_t * dst , const uint8_t * src [ 5 ] , int stride , int h ) \n { \n if ( h & 3 ) \n ff_put_dirac_pixels16_c ( dst , src , stride , h ) ; \n else \n ff_put_pixels16_sse2 ( dst , src [ 0 ] , stride , h ) ; \n }", "idx": 19924}
{"project": "FFmpeg", "commit_id": "8813d55fa5978660d9f4e7dbe1f50da9922be08d", "target": 0, "func": "int ff_vaapi_commit_slices ( FFVAContext * vactx ) \n { \n VABufferID * slice_buf_ids ; \n VABufferID slice_param_buf_id , slice_data_buf_id ; \n if ( vactx -> slice_count == 0 ) \n return 0 ; \n slice_buf_ids = \n av_fast_realloc ( vactx -> slice_buf_ids , \n & vactx -> slice_buf_ids_alloc , \n ( vactx -> n_slice_buf_ids + 2 ) * sizeof ( slice_buf_ids [ 0 ] ) ) ; \n if ( ! slice_buf_ids ) \n return -1 ; \n vactx -> slice_buf_ids = slice_buf_ids ; \n slice_param_buf_id = 0 ; \n if ( vaCreateBuffer ( vactx -> display , vactx -> context_id , \n VASliceParameterBufferType , \n vactx -> slice_param_size , \n vactx -> slice_count , vactx -> slice_params , \n & slice_param_buf_id ) != VA_STATUS_SUCCESS ) \n return -1 ; \n vactx -> slice_count = 0 ; \n slice_data_buf_id = 0 ; \n if ( vaCreateBuffer ( vactx -> display , vactx -> context_id , \n VASliceDataBufferType , \n vactx -> slice_data_size , \n 1 , ( void * ) vactx -> slice_data , \n & slice_data_buf_id ) != VA_STATUS_SUCCESS ) \n return -1 ; \n vactx -> slice_data = NULL ; \n vactx -> slice_data_size = 0 ; \n slice_buf_ids [ vactx -> n_slice_buf_ids ++ ] = slice_param_buf_id ; \n slice_buf_ids [ vactx -> n_slice_buf_ids ++ ] = slice_data_buf_id ; \n return 0 ; \n }", "idx": 19931}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mjpeg_decode_init ( AVCodecContext * avctx ) \n { \n MJpegDecodeContext * s = avctx -> priv_data ; \n MpegEncContext s2 ; \n s -> avctx = avctx ; \n memset ( & s2 , 0 , sizeof ( MpegEncContext ) ) ; \n s2 . flags = avctx -> flags ; \n s2 . avctx = avctx ; \n s2 . width = 8 ; \n s2 . height = 8 ; \n if ( MPV_common_init ( & s2 ) < 0 ) \n return -1 ; \n s -> scantable = s2 . intra_scantable ; \n s -> idct_put = s2 . idct_put ; \n MPV_common_end ( & s2 ) ; \n s -> mpeg_enc_ctx_allocated = 0 ; \n s -> buffer_size = 102400 ; \n s -> buffer = av_malloc ( s -> buffer_size ) ; \n if ( ! s -> buffer ) \n return -1 ; \n s -> start_code = -1 ; \n s -> first_picture = 1 ; \n s -> org_width = avctx -> width ; \n s -> org_height = avctx -> height ; \n build_vlc ( & s -> vlcs [ 0 ] [ 0 ] , bits_dc_luminance , val_dc_luminance , 12 ) ; \n build_vlc ( & s -> vlcs [ 0 ] [ 1 ] , bits_dc_chrominance , val_dc_chrominance , 12 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 0 ] , bits_ac_luminance , val_ac_luminance , 251 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 1 ] , bits_ac_chrominance , val_ac_chrominance , 251 ) ; \n if ( avctx -> flags & CODEC_FLAG_EXTERN_HUFF ) \n { \n printf ( \" \\n \" ) ; \n init_get_bits ( & s -> gb , avctx -> extradata , avctx -> extradata_size ) ; \n mjpeg_decode_dht ( s ) ; \n } \n return 0 ; \n }", "idx": 19942}
{"project": "FFmpeg", "commit_id": "44cde38c8acbef7d5250e6d1b52b1020871e093b", "target": 0, "func": "static int cbs_read_se_golomb ( CodedBitstreamContext * ctx , BitstreamContext * bc , \n const char * name , int32_t * write_to , \n int32_t range_min , int32_t range_max ) \n { \n int32_t value ; \n int position ; \n if ( ctx -> trace_enable ) { \n char bits [ 65 ] ; \n uint32_t v ; \n unsigned int k ; \n int i , j ; \n position = bitstream_tell ( bc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n k = bitstream_read_bit ( bc ) ; \n bits [ i ] = k ? ' ' : ' ' ; \n if ( k ) \n break ; \n } \n if ( i >= 32 ) { \n av_log ( ctx -> log_ctx , AV_LOG_ERROR , \" \" \n \" \" \n \" \\n \" , name ) ; \n return AVERROR_INVALIDDATA ; \n } \n v = 1 ; \n for ( j = 0 ; j < i ; j ++ ) { \n k = bitstream_read_bit ( bc ) ; \n bits [ i + j + 1 ] = k ? ' ' : ' ' ; \n v = v << 1 | k ; \n } \n bits [ i + j + 1 ] = 0 ; \n if ( v & 1 ) \n value = - ( int32_t ) ( v / 2 ) ; \n else \n value = v / 2 ; \n ff_cbs_trace_syntax_element ( ctx , position , name , bits , value ) ; \n } else { \n value = get_se_golomb_long ( bc ) ; \n } \n if ( value < range_min || value > range_max ) { \n av_log ( ctx -> log_ctx , AV_LOG_ERROR , \" \" \n \" \" PRId32 \" \" PRId32 \" \" PRId32 \" \\n \" , \n name , value , range_min , range_max ) ; \n return AVERROR_INVALIDDATA ; \n } \n * write_to = value ; \n return 0 ; \n }", "idx": 19953}
{"project": "FFmpeg", "commit_id": "64fbf5e263a0698c6cf6e0580feebe9a6f502ae5", "target": 1, "func": "static int parse_inputs ( const char * * buf , AVFilterInOut * * currInputs , \n AVFilterInOut * * openLinks , AVClass * log_ctx ) \n { \n int pad = 0 ; \n while ( * * buf == ' ' ) { \n char * name = parse_link_name ( buf , log_ctx ) ; \n AVFilterInOut * match ; \n if ( ! name ) \n return -1 ; \n match = extract_inout ( name , openLinks ) ; \n if ( match ) { \n if ( match -> type != LinkTypeOut ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\\" \\\" \\n \" , match -> name ) ; \n return -1 ; \n } \n } else { \n match = av_mallocz ( sizeof ( AVFilterInOut ) ) ; \n match -> name = name ; \n match -> type = LinkTypeIn ; \n match -> pad_idx = pad ; \n } \n insert_inout ( currInputs , match ) ; \n * buf += consume_whitespace ( * buf ) ; \n pad ++ ; \n } \n return pad ; \n }", "idx": 19972}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void do_video_stats ( OutputStream * ost , int frame_size ) \n { \n AVCodecContext * enc ; \n int frame_number ; \n double ti1 , bitrate , avg_bitrate ; \n if ( ! vstats_file ) { \n vstats_file = fopen ( vstats_filename , \" \" ) ; \n if ( ! vstats_file ) { \n perror ( \" \" ) ; \n exit ( 1 ) ; \n } \n } \n enc = ost -> st -> codec ; \n if ( enc -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n frame_number = ost -> frame_number ; \n fprintf ( vstats_file , \" \" , frame_number , enc -> coded_frame -> quality / ( float ) FF_QP2LAMBDA ) ; \n if ( enc -> flags & CODEC_FLAG_PSNR ) \n fprintf ( vstats_file , \" \" , psnr ( enc -> coded_frame -> error [ 0 ] / ( enc -> width * enc -> height * 255.0 * 255.0 ) ) ) ; \n fprintf ( vstats_file , \" \" , frame_size ) ; \n ti1 = ost -> sync_opts * av_q2d ( enc -> time_base ) ; \n if ( ti1 < 0.01 ) \n ti1 = 0.01 ; \n bitrate = ( frame_size * 8 ) / av_q2d ( enc -> time_base ) / 1000.0 ; \n avg_bitrate = ( double ) ( video_size * 8 ) / ti1 / 1000.0 ; \n fprintf ( vstats_file , \" \" , \n ( double ) video_size / 1024 , ti1 , bitrate , avg_bitrate ) ; \n fprintf ( vstats_file , \" \\n \" , av_get_picture_type_char ( enc -> coded_frame -> pict_type ) ) ; \n } \n }", "idx": 19975}
{"project": "FFmpeg", "commit_id": "6998a9f4c4e069f515c50614179f4cfc7d0184f5", "target": 1, "func": "static int parse_icy ( HTTPContext * s , const char * tag , const char * p ) \n { \n int len = 4 + strlen ( p ) + strlen ( tag ) ; \n int is_first = ! s -> icy_metadata_headers ; \n int ret ; \n if ( s -> icy_metadata_headers ) \n len += strlen ( s -> icy_metadata_headers ) ; \n if ( ( ret = av_reallocp ( & s -> icy_metadata_headers , len ) ) < 0 ) \n return ret ; \n av_strlcatf ( s -> icy_metadata_headers , len , \" \\n \" , tag , p ) ; \n return 0 ; \n }", "idx": 19984}
{"project": "FFmpeg", "commit_id": "910e3668170d2e1e56dc28f8b722232a218e4b9a", "target": 1, "func": "static av_cold void decode_init_vlc ( void ) { \n static int done = 0 ; \n if ( ! done ) { \n int i ; \n done = 1 ; \n init_vlc ( & chroma_dc_coeff_token_vlc , CHROMA_DC_COEFF_TOKEN_VLC_BITS , 4 * 5 , \n & chroma_dc_coeff_token_len [ 0 ] , 1 , 1 , \n & chroma_dc_coeff_token_bits [ 0 ] , 1 , 1 , 1 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n init_vlc ( & coeff_token_vlc [ i ] , COEFF_TOKEN_VLC_BITS , 4 * 17 , \n & coeff_token_len [ i ] [ 0 ] , 1 , 1 , \n & coeff_token_bits [ i ] [ 0 ] , 1 , 1 , 1 ) ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n init_vlc ( & chroma_dc_total_zeros_vlc [ i ] , CHROMA_DC_TOTAL_ZEROS_VLC_BITS , 4 , \n & chroma_dc_total_zeros_len [ i ] [ 0 ] , 1 , 1 , \n & chroma_dc_total_zeros_bits [ i ] [ 0 ] , 1 , 1 , 1 ) ; \n } \n for ( i = 0 ; i < 15 ; i ++ ) { \n init_vlc ( & total_zeros_vlc [ i ] , TOTAL_ZEROS_VLC_BITS , 16 , \n & total_zeros_len [ i ] [ 0 ] , 1 , 1 , \n & total_zeros_bits [ i ] [ 0 ] , 1 , 1 , 1 ) ; \n } \n for ( i = 0 ; i < 6 ; i ++ ) { \n init_vlc ( & run_vlc [ i ] , RUN_VLC_BITS , 7 , \n & run_len [ i ] [ 0 ] , 1 , 1 , \n & run_bits [ i ] [ 0 ] , 1 , 1 , 1 ) ; \n } \n init_vlc ( & run7_vlc , RUN7_VLC_BITS , 16 , \n & run_len [ 6 ] [ 0 ] , 1 , 1 , \n & run_bits [ 6 ] [ 0 ] , 1 , 1 , 1 ) ; \n } \n }", "idx": 19985}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "static int dct_quantize_c ( MpegEncContext * s , \n DCTELEM * block , int n , \n int qscale , int * overflow ) \n { \n int i , j , level , last_non_zero , q ; \n const int * qmat ; \n int bias ; \n int max = 0 ; \n unsigned int threshold1 , threshold2 ; \n av_fdct ( block ) ; \n block_permute ( block ) ; \n if ( s -> mb_intra ) { \n if ( ! s -> h263_aic ) { \n if ( n < 4 ) \n q = s -> y_dc_scale ; \n else \n q = s -> c_dc_scale ; \n q = q << 3 ; \n } else \n q = 1 << 3 ; \n block [ 0 ] = ( block [ 0 ] + ( q >> 1 ) ) / q ; \n i = 1 ; \n last_non_zero = 0 ; \n qmat = s -> q_intra_matrix [ qscale ] ; \n bias = s -> intra_quant_bias << ( QMAT_SHIFT - 3 - QUANT_BIAS_SHIFT ) ; \n } else { \n i = 0 ; \n last_non_zero = -1 ; \n qmat = s -> q_inter_matrix [ qscale ] ; \n bias = s -> inter_quant_bias << ( QMAT_SHIFT - 3 - QUANT_BIAS_SHIFT ) ; \n } \n threshold1 = ( 1 << ( QMAT_SHIFT - 3 ) ) - bias - 1 ; \n threshold2 = threshold1 << 1 ; \n for ( ; i < 64 ; i ++ ) { \n j = zigzag_direct [ i ] ; \n level = block [ j ] ; \n level = level * qmat [ j ] ; \n if ( ( ( unsigned ) ( level + threshold1 ) ) > threshold2 ) { \n if ( level > 0 ) { \n level = ( bias + level ) >> ( QMAT_SHIFT - 3 ) ; \n block [ j ] = level ; \n } else { \n level = ( bias - level ) >> ( QMAT_SHIFT - 3 ) ; \n block [ j ] = - level ; \n } \n max |= level ; \n last_non_zero = i ; \n } else { \n block [ j ] = 0 ; \n } \n } \n * overflow = s -> max_qcoeff < max ; \n return last_non_zero ; \n }", "idx": 20002}
{"project": "FFmpeg", "commit_id": "6c5b98d40b8eeec14174fb9602acbf4b0c924981", "target": 0, "func": "static void radix_sort ( RCCMPEntry * data , int size ) \n { \n int buckets [ RADIX_PASSES ] [ NBUCKETS ] ; \n RCCMPEntry * tmp = av_malloc_array ( size , sizeof ( * tmp ) ) ; \n radix_count ( data , size , buckets ) ; \n radix_sort_pass ( tmp , data , size , buckets [ 0 ] , 0 ) ; \n radix_sort_pass ( data , tmp , size , buckets [ 1 ] , 1 ) ; \n if ( buckets [ 2 ] [ NBUCKETS - 1 ] || buckets [ 3 ] [ NBUCKETS - 1 ] ) { \n radix_sort_pass ( tmp , data , size , buckets [ 2 ] , 2 ) ; \n radix_sort_pass ( data , tmp , size , buckets [ 3 ] , 3 ) ; \n } \n av_free ( tmp ) ; \n }", "idx": 20003}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += ( output [ 2 ] [ i ] + output [ 4 ] [ i ] ) ; \n output [ 2 ] [ i ] += ( output [ 3 ] [ i ] + output [ 4 ] [ i ] ) ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 20004}
{"project": "FFmpeg", "commit_id": "1c9215e580b6436d1aff3c0118ef01269712ebd9", "target": 0, "func": "static int check ( AVIOContext * pb , int64_t pos , uint32_t * ret_header ) \n { \n int64_t ret = avio_seek ( pb , pos , SEEK_SET ) ; \n unsigned header ; \n MPADecodeHeader sd ; \n if ( ret < 0 ) \n return ret ; \n header = avio_rb32 ( pb ) ; \n if ( ff_mpa_check_header ( header ) < 0 ) \n return -1 ; \n if ( avpriv_mpegaudio_decode_header ( & sd , header ) == 1 ) \n return -1 ; \n if ( ret_header ) \n * ret_header = header ; \n return sd . frame_size ; \n }", "idx": 20006}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "func": "void ff_put_h264_qpel4_mc30_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hz_qrt_4w_msa ( src - 2 , stride , dst , stride , 4 , 1 ) ; \n }", "idx": 20007}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "av_cold void ff_wmv2_common_init ( Wmv2Context * w ) \n { \n MpegEncContext * const s = & w -> s ; \n ff_blockdsp_init ( & s -> bdsp , s -> avctx ) ; \n ff_wmv2dsp_init ( & w -> wdsp ) ; \n s -> idsp . perm_type = w -> wdsp . idct_perm ; \n ff_init_scantable_permutation ( s -> idsp . idct_permutation , \n w -> wdsp . idct_perm ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> abt_scantable [ 0 ] , \n ff_wmv2_scantableA ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & w -> abt_scantable [ 1 ] , \n ff_wmv2_scantableB ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , \n ff_wmv1_scantable [ 1 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , \n ff_wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , \n ff_wmv1_scantable [ 3 ] ) ; \n ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , \n ff_wmv1_scantable [ 0 ] ) ; \n s -> idsp . idct_put = w -> wdsp . idct_put ; \n s -> idsp . idct_add = w -> wdsp . idct_add ; \n s -> idsp . idct = NULL ; \n }", "idx": 20013}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_put_h264_qpel16_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n copy_width16_msa ( src , stride , dst , stride , 16 ) ; \n }", "idx": 20015}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgba32_to_rgb24 ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n const uint8_t * s ; \n uint8_t * d ; \n int src_wrap , dst_wrap , j , y ; \n unsigned int v ; \n s = src -> data [ 0 ] ; \n src_wrap = src -> linesize [ 0 ] - width * 4 ; \n d = dst -> data [ 0 ] ; \n dst_wrap = dst -> linesize [ 0 ] - width * 3 ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( j = 0 ; j < width ; j ++ ) { \n v = * ( uint32_t * ) s ; \n s += 4 ; \n d [ 0 ] = v >> 16 ; \n d [ 1 ] = v >> 8 ; \n d [ 2 ] = v ; \n d += 3 ; \n } \n s += src_wrap ; \n d += dst_wrap ; \n } \n }", "idx": 20020}
{"project": "FFmpeg", "commit_id": "ba4bcb191aa8b5fa66131544bf9ebf1f17ff7d9a", "target": 0, "func": "int opt_codec_debug ( void * optctx , const char * opt , const char * arg ) \n { \n av_log_set_level ( AV_LOG_DEBUG ) ; \n return opt_default ( NULL , opt , arg ) ; \n }", "idx": 20021}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int get_packetheader ( NUTContext * nut , ByteIOContext * bc , int calculate_checksum ) \n { \n int64_t start , size ; \n size = get_v ( bc ) ; \n init_checksum ( bc , calculate_checksum ? av_crc04C11DB7_update : NULL , 1 ) ; \n return size ; \n }", "idx": 20025}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int put_v ( ByteIOContext * bc , uint64_t val ) \n { \n int i ; \n if ( bytes_left ( bc ) < 1 ) \n return -1 ; \n val &= 0x7FFFFFFFFFFFFFFFULL ; \n i = get_length ( val ) ; \n for ( i -= 7 ; i > 0 ; i -= 7 ) { \n put_byte ( bc , 0x80 | ( val >> i ) ) ; \n } \n put_byte ( bc , val & 0x7f ) ; \n return 0 ; \n }", "idx": 20028}
{"project": "FFmpeg", "commit_id": "20c38f2e7085ce02c19df965d02ecdf5628f11b8", "target": 1, "func": "static MOVFragmentStreamInfo * get_current_frag_stream_info ( \n MOVFragmentIndex * frag_index ) \n { \n MOVFragmentIndexItem * item = & frag_index -> item [ frag_index -> current ] ; \n if ( item -> current >= 0 && item -> current < item -> nb_stream_info ) \n return & item -> stream_info [ item -> current ] ; \n }", "idx": 20033}
{"project": "FFmpeg", "commit_id": "94e58e5770d2a2295a13240f51ddba583e6d5360", "target": 1, "func": "static void mm_decode_intra ( MmContext * s , int half_horiz , int half_vert , const uint8_t * buf , int buf_size ) \n { \n int i , x , y ; \n i = 0 ; x = 0 ; y = 0 ; \n while ( i < buf_size ) { \n int run_length , color ; \n if ( buf [ i ] & 0x80 ) { \n run_length = 1 ; \n color = buf [ i ] ; \n i ++ ; \n } else { \n run_length = ( buf [ i ] & 0x7f ) + 2 ; \n color = buf [ i + 1 ] ; \n i += 2 ; \n } \n if ( half_horiz ) \n run_length *= 2 ; \n if ( color ) { \n memset ( s -> frame . data [ 0 ] + y * s -> frame . linesize [ 0 ] + x , color , run_length ) ; \n if ( half_vert ) \n memset ( s -> frame . data [ 0 ] + ( y + 1 ) * s -> frame . linesize [ 0 ] + x , color , run_length ) ; \n } \n x += run_length ; \n if ( x >= s -> avctx -> width ) { \n x = 0 ; \n y += 1 + half_vert ; \n } \n } \n }", "idx": 20046}
{"project": "FFmpeg", "commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "target": 1, "func": "static void dnxhd_decode_dct_block_10_444 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n dnxhd_decode_dct_block ( ctx , row , n , 6 , 32 , 6 ) ; \n }", "idx": 20047}
{"project": "FFmpeg", "commit_id": "e8acf0edeae0b5ef53233c49015b07cc9711f20c", "target": 0, "func": "int redir_open ( AVFormatContext * * ic_ptr , ByteIOContext * f ) \n { \n char buf [ 4096 ] , * q ; \n int c ; \n AVFormatContext * ic = NULL ; \n c = url_fgetc ( f ) ; \n while ( c != URL_EOF ) { \n for ( ; ; ) { \n if ( ! redir_isspace ( c ) ) \n break ; \n c = url_fgetc ( f ) ; \n } \n if ( c == URL_EOF ) \n break ; \n q = buf ; \n for ( ; ; ) { \n if ( c == URL_EOF || redir_isspace ( c ) ) \n break ; \n if ( ( q - buf ) < sizeof ( buf ) - 1 ) \n * q ++ = c ; \n c = url_fgetc ( f ) ; \n } \n * q = ' \\0 ' ; \n if ( av_open_input_file ( & ic , buf , NULL , 0 , NULL ) == 0 ) \n break ; \n } \n * ic_ptr = ic ; \n if ( ! ic ) \n return AVERROR ( EIO ) ; \n else \n return 0 ; \n }", "idx": 20051}
{"project": "FFmpeg", "commit_id": "2c492e94fc9d8a5e998b25f4d0390c95f2d4674f", "target": 0, "func": "static void mpeg1_skip_picture ( MpegEncContext * s , int pict_num ) \n { \n assert ( s -> codec_id == CODEC_ID_MPEG1VIDEO ) ; \n put_header ( s , PICTURE_START_CODE ) ; \n put_bits ( & s -> pb , 10 , pict_num & 0x3ff ) ; \n put_bits ( & s -> pb , 3 , P_TYPE ) ; \n put_bits ( & s -> pb , 16 , 0xffff ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 3 , 1 ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n put_header ( s , SLICE_MIN_START_CODE ) ; \n put_bits ( & s -> pb , 5 , 1 ) ; \n put_bits ( & s -> pb , 1 , 0 ) ; \n encode_mb_skip_run ( s , 0 ) ; \n put_bits ( & s -> pb , 3 , 1 ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n encode_mb_skip_run ( s , s -> mb_width * s -> mb_height - 2 ) ; \n put_bits ( & s -> pb , 3 , 1 ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n put_bits ( & s -> pb , 1 , 1 ) ; \n }", "idx": 20091}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_qcx ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q ) \n { \n int i , x ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR_INVALIDDATA ; \n x = bytestream_get_byte ( & s -> buf ) ; \n q -> nguardbits = x >> 5 ; \n q -> quantsty = x & 0x1f ; \n if ( q -> quantsty == JPEG2000_QSTY_NONE ) { \n n -= 3 ; \n if ( s -> buf_end - s -> buf < n ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < n ; i ++ ) \n q -> expn [ i ] = bytestream_get_byte ( & s -> buf ) >> 3 ; \n } else if ( q -> quantsty == JPEG2000_QSTY_SI ) { \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR_INVALIDDATA ; \n x = bytestream_get_be16 ( & s -> buf ) ; \n q -> expn [ 0 ] = x >> 11 ; \n q -> mant [ 0 ] = x & 0x7ff ; \n for ( i = 1 ; i < JPEG2000_MAX_DECLEVELS * 3 ; i ++ ) { \n int curexpn = FFMAX ( 0 , q -> expn [ 0 ] - ( i - 1 ) / 3 ) ; \n q -> expn [ i ] = curexpn ; \n q -> mant [ i ] = q -> mant [ 0 ] ; \n } \n } else { \n n = ( n - 3 ) >> 1 ; \n if ( s -> buf_end - s -> buf < n ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < n ; i ++ ) { \n x = bytestream_get_be16 ( & s -> buf ) ; \n q -> expn [ i ] = x >> 11 ; \n q -> mant [ i ] = x & 0x7ff ; \n } \n } \n return 0 ; \n }", "idx": 20116}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_intra_pred8x8_mode_emuedge ( int mode , int mb_x , int mb_y ) \n { \n switch ( mode ) { \n case DC_PRED8x8 : \n return check_dc_pred8x8_mode ( mode , mb_x , mb_y ) ; \n case VERT_PRED8x8 : \n return ! mb_y ? DC_127_PRED8x8 : mode ; \n case HOR_PRED8x8 : \n return ! mb_x ? DC_129_PRED8x8 : mode ; \n case PLANE_PRED8x8 : \n return check_tm_pred8x8_mode ( mode , mb_x , mb_y ) ; \n } \n return mode ; \n }", "idx": 20119}
{"project": "FFmpeg", "commit_id": "0726b2d1ea4343698ff603cc32b824f5bce952c5", "target": 1, "func": "static int jpeg_write_trailer ( AVFormatContext * s1 ) \n { \n JpegContext * s = s1 -> priv_data ; \n av_free ( s ) ; \n return 0 ; \n }", "idx": 20120}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void filter_mb_mbaff_edgecv ( H264Context * h , uint8_t * pix , int stride , const int16_t bS [ 7 ] , int bsi , int qp ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n int alpha = alpha_table [ index_a ] ; \n int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 * bsi ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 * bsi ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 * bsi ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 * bsi ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_mbaff_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 20122}
{"project": "FFmpeg", "commit_id": "38129c26c51b933d7db423f904ba0cd6a88ca1ed", "target": 0, "func": "int cmdutils_read_file ( const char * filename , char * * bufptr , size_t * size ) \n { \n int ret ; \n FILE * f = fopen ( filename , \" \" ) ; \n if ( ! f ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , filename , \n strerror ( errno ) ) ; \n return AVERROR ( errno ) ; \n } \n fseek ( f , 0 , SEEK_END ) ; \n * size = ftell ( f ) ; \n fseek ( f , 0 , SEEK_SET ) ; \n * bufptr = av_malloc ( * size + 1 ) ; \n if ( ! * bufptr ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n fclose ( f ) ; \n return AVERROR ( ENOMEM ) ; \n } \n ret = fread ( * bufptr , 1 , * size , f ) ; \n if ( ret < * size ) { \n av_free ( * bufptr ) ; \n if ( ferror ( f ) ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , \n filename , strerror ( errno ) ) ; \n ret = AVERROR ( errno ) ; \n } else \n ret = AVERROR_EOF ; \n } else { \n ret = 0 ; \n ( * bufptr ) [ ( * size ) ++ ] = ' \\0 ' ; \n } \n fclose ( f ) ; \n return ret ; \n }", "idx": 20123}
{"project": "FFmpeg", "commit_id": "d0eb91ad0451cdb6c062b2d4760bfa7f8bb4db6b", "target": 0, "func": "static int tcp_write ( URLContext * h , const uint8_t * buf , int size ) \n { \n TCPContext * s = h -> priv_data ; \n int ret , size1 , fd_max , len ; \n fd_set wfds ; \n struct timeval tv ; \n size1 = size ; \n while ( size > 0 ) { \n if ( url_interrupt_cb ( ) ) \n return AVERROR ( EINTR ) ; \n fd_max = s -> fd ; \n FD_ZERO ( & wfds ) ; \n FD_SET ( s -> fd , & wfds ) ; \n tv . tv_sec = 0 ; \n tv . tv_usec = 100 * 1000 ; \n ret = select ( fd_max + 1 , NULL , & wfds , NULL , & tv ) ; \n if ( ret > 0 && FD_ISSET ( s -> fd , & wfds ) ) { \n len = send ( s -> fd , buf , size , 0 ) ; \n if ( len < 0 ) { \n if ( ff_neterrno ( ) != FF_NETERROR ( EINTR ) && \n ff_neterrno ( ) != FF_NETERROR ( EAGAIN ) ) \n return ff_neterrno ( ) ; \n continue ; \n } \n size -= len ; \n buf += len ; \n } else if ( ret < 0 ) { \n if ( ff_neterrno ( ) == FF_NETERROR ( EINTR ) ) \n continue ; \n return -1 ; \n } \n } \n return size1 - size ; \n }", "idx": 20132}
{"project": "FFmpeg", "commit_id": "3715d841a619f1cbc4776d9b00575dae6fb6534a", "target": 0, "func": "static int alloc_buffer ( InputStream * ist , FrameBuffer * * pbuf ) \n { \n AVCodecContext * s = ist -> st -> codec ; \n FrameBuffer * buf = av_mallocz ( sizeof ( * buf ) ) ; \n int ret ; \n const int pixel_size = av_pix_fmt_descriptors [ s -> pix_fmt ] . comp [ 0 ] . step_minus1 + 1 ; \n int h_chroma_shift , v_chroma_shift ; \n int edge = 32 ; \n int w = s -> width , h = s -> height ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ! ( s -> flags & CODEC_FLAG_EMU_EDGE ) ) { \n w += 2 * edge ; \n h += 2 * edge ; \n } \n avcodec_align_dimensions ( s , & w , & h ) ; \n if ( ( ret = av_image_alloc ( buf -> base , buf -> linesize , w , h , \n s -> pix_fmt , 32 ) ) < 0 ) { \n av_freep ( & buf ) ; \n return ret ; \n } \n memset ( buf -> base [ 0 ] , 128 , ret ) ; \n avcodec_get_chroma_sub_sample ( s -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ; \n for ( int i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n const int h_shift = i == 0 ? 0 : h_chroma_shift ; \n const int v_shift = i == 0 ? 0 : v_chroma_shift ; \n if ( s -> flags & CODEC_FLAG_EMU_EDGE ) \n buf -> data [ i ] = buf -> base [ i ] ; \n else \n buf -> data [ i ] = buf -> base [ i ] + \n FFALIGN ( ( buf -> linesize [ i ] * edge >> v_shift ) + \n ( pixel_size * edge >> h_shift ) , 32 ) ; \n } \n buf -> w = s -> width ; \n buf -> h = s -> height ; \n buf -> pix_fmt = s -> pix_fmt ; \n buf -> ist = ist ; \n * pbuf = buf ; \n return 0 ; \n }", "idx": 20134}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "static av_cold int tqi_decode_init ( AVCodecContext * avctx ) \n { \n TqiContext * t = avctx -> priv_data ; \n ff_blockdsp_init ( & t -> bdsp , avctx ) ; \n ff_bswapdsp_init ( & t -> bsdsp ) ; \n ff_idctdsp_init ( & t -> idsp , avctx ) ; \n ff_init_scantable_permutation ( t -> idsp . idct_permutation , FF_IDCT_PERM_NONE ) ; \n ff_init_scantable ( t -> idsp . idct_permutation , & t -> intra_scantable , ff_zigzag_direct ) ; \n avctx -> framerate = ( AVRational ) { 15 , 1 } ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n ff_mpeg12_init_vlcs ( ) ; \n return 0 ; \n }", "idx": 20135}
{"project": "FFmpeg", "commit_id": "5331773cc33ba26b9e26ace643d926219e46a17b", "target": 0, "func": "static void id3v2_read_internal ( AVIOContext * pb , AVDictionary * * metadata , \n AVFormatContext * s , const char * magic , \n ID3v2ExtraMeta * * extra_meta ) \n { \n int len , ret ; \n uint8_t buf [ ID3v2_HEADER_SIZE ] ; \n int found_header ; \n int64_t off ; \n do { \n off = avio_tell ( pb ) ; \n ret = avio_read ( pb , buf , ID3v2_HEADER_SIZE ) ; \n if ( ret != ID3v2_HEADER_SIZE ) { \n avio_seek ( pb , off , SEEK_SET ) ; \n break ; \n } \n found_header = ff_id3v2_match ( buf , magic ) ; \n if ( found_header ) { \n len = ( ( buf [ 6 ] & 0x7f ) << 21 ) | \n ( ( buf [ 7 ] & 0x7f ) << 14 ) | \n ( ( buf [ 8 ] & 0x7f ) << 7 ) | \n ( buf [ 9 ] & 0x7f ) ; \n id3v2_parse ( pb , metadata , s , len , buf [ 3 ] , buf [ 5 ] , extra_meta ) ; \n } else { \n avio_seek ( pb , off , SEEK_SET ) ; \n } \n } while ( found_header ) ; \n ff_metadata_conv ( metadata , NULL , ff_id3v2_34_metadata_conv ) ; \n ff_metadata_conv ( metadata , NULL , id3v2_2_metadata_conv ) ; \n ff_metadata_conv ( metadata , NULL , ff_id3v2_4_metadata_conv ) ; \n merge_date ( metadata ) ; \n }", "idx": 20142}
{"project": "FFmpeg", "commit_id": "c04643a2c24564aed96a5b0760de8bf02eb305c6", "target": 0, "func": "void check_audio_video_inputs ( int * has_video_ptr , int * has_audio_ptr ) \n { \n int has_video , has_audio , i , j ; \n AVFormatContext * ic ; \n has_video = 0 ; \n has_audio = 0 ; \n for ( j = 0 ; j < nb_input_files ; j ++ ) { \n ic = input_files [ j ] ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n AVCodecContext * enc = & ic -> streams [ i ] -> codec ; \n switch ( enc -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n has_audio = 1 ; \n break ; \n case CODEC_TYPE_VIDEO : \n has_video = 1 ; \n break ; \n default : \n abort ( ) ; \n } \n } \n } \n * has_video_ptr = has_video ; \n * has_audio_ptr = has_audio ; \n }", "idx": 20153}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_packet ( AVFormatContext * s1 , \n AVPacket * pkt ) \n { \n GifState * s = s1 -> priv_data ; \n int ret ; \n ret = gif_parse_next_image ( s ) ; \n if ( ret < 0 ) \n return ret ; \n if ( av_new_packet ( pkt , s -> screen_width * s -> screen_height * 3 ) ) { \n return AVERROR ( EIO ) ; \n } \n pkt -> stream_index = 0 ; \n memcpy ( pkt -> data , s -> image_buf , s -> screen_width * s -> screen_height * 3 ) ; \n return 0 ; \n }", "idx": 20171}
{"project": "FFmpeg", "commit_id": "8ca9a68f1905ff871690be38348d62a25aef2a8f", "target": 1, "func": "static int decode_residuals ( FLACContext * s , int32_t * decoded , int pred_order ) \n { \n int i , tmp , partition , method_type , rice_order ; \n int rice_bits , rice_esc ; \n int samples ; \n method_type = get_bits ( & s -> gb , 2 ) ; \n if ( method_type > 1 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n method_type ) ; \n rice_order = get_bits ( & s -> gb , 4 ) ; \n samples = s -> blocksize >> rice_order ; \n if ( pred_order > samples ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n pred_order , samples ) ; \n rice_bits = 4 + method_type ; \n rice_esc = ( 1 << rice_bits ) - 1 ; \n decoded += pred_order ; \n i = pred_order ; \n for ( partition = 0 ; partition < ( 1 << rice_order ) ; partition ++ ) { \n tmp = get_bits ( & s -> gb , rice_bits ) ; \n if ( tmp == rice_esc ) { \n tmp = get_bits ( & s -> gb , 5 ) ; \n for ( ; i < samples ; i ++ ) \n * decoded ++ = get_sbits_long ( & s -> gb , tmp ) ; \n } else { \n for ( ; i < samples ; i ++ ) { \n * decoded ++ = get_sr_golomb_flac ( & s -> gb , tmp , INT_MAX , 0 ) ; \n i = 0 ; \n return 0 ;", "idx": 20172}
{"project": "FFmpeg", "commit_id": "b4054100f675b395204f1a0471fba0b06fe08e9f", "target": 1, "func": "static void close_decoder ( QSVContext * q ) \n { \n QSVFrame * cur ; \n if ( q -> session ) \n MFXVideoDECODE_Close ( q -> session ) ; \n while ( q -> async_fifo && av_fifo_size ( q -> async_fifo ) ) { \n QSVFrame * out_frame ; \n mfxSyncPoint * sync ; \n av_fifo_generic_read ( q -> async_fifo , & out_frame , sizeof ( out_frame ) , NULL ) ; \n av_fifo_generic_read ( q -> async_fifo , & sync , sizeof ( sync ) , NULL ) ; \n av_freep ( & sync ) ; \n } \n cur = q -> work_frames ; \n while ( cur ) { \n q -> work_frames = cur -> next ; \n av_frame_free ( & cur -> frame ) ; \n av_freep ( & cur ) ; \n cur = q -> work_frames ; \n } \n q -> engine_ready = 0 ; \n q -> reinit_pending = 0 ; \n }", "idx": 20176}
{"project": "FFmpeg", "commit_id": "60ab4480423769ac3db487aba5232b187036c7ea", "target": 0, "func": "static inline int ape_decode_value_3860 ( APEContext * ctx , GetBitContext * gb , \n APERice * rice ) \n { \n unsigned int x , overflow ; \n overflow = get_unary ( gb , 1 , get_bits_left ( gb ) ) ; \n if ( ctx -> fileversion > 3880 ) { \n while ( overflow >= 16 ) { \n overflow -= 16 ; \n rice -> k += 4 ; \n } \n } \n if ( ! rice -> k ) \n x = overflow ; \n else \n x = ( overflow << rice -> k ) + get_bits ( gb , rice -> k ) ; \n rice -> ksum += x - ( rice -> ksum + 8 >> 4 ) ; \n if ( rice -> ksum < ( rice -> k ? 1 << ( rice -> k + 4 ) : 0 ) ) \n rice -> k -- ; \n else if ( rice -> ksum >= ( 1 << ( rice -> k + 5 ) ) && rice -> k < 24 ) \n rice -> k ++ ; \n if ( x & 1 ) \n return ( x >> 1 ) + 1 ; \n else \n return - ( x >> 1 ) ; \n }", "idx": 20178}
{"project": "FFmpeg", "commit_id": "f8bed30d8b176fa030f6737765338bb4a2bcabc9", "target": 0, "func": "void ff_vc1dsp_init_altivec ( VC1DSPContext * dsp ) \n { \n if ( ! ( av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) ) \n return ; \n dsp -> vc1_inv_trans_8x8 = vc1_inv_trans_8x8_altivec ; \n dsp -> vc1_inv_trans_8x4 = vc1_inv_trans_8x4_altivec ; \n dsp -> put_no_rnd_vc1_chroma_pixels_tab [ 0 ] = put_no_rnd_vc1_chroma_mc8_altivec ; \n dsp -> avg_no_rnd_vc1_chroma_pixels_tab [ 0 ] = avg_no_rnd_vc1_chroma_mc8_altivec ; \n }", "idx": 20210}
{"project": "FFmpeg", "commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "target": 0, "func": "int ff_alloc_picture ( MpegEncContext * s , Picture * pic , int shared ) \n { \n int i , ret ; \n if ( shared ) { \n assert ( pic -> f . data [ 0 ] ) ; \n pic -> shared = 1 ; \n } else { \n assert ( ! pic -> f . data [ 0 ] ) ; \n if ( alloc_frame_buffer ( s , pic ) < 0 ) \n return -1 ; \n s -> linesize = pic -> f . linesize [ 0 ] ; \n s -> uvlinesize = pic -> f . linesize [ 1 ] ; \n } \n if ( ! pic -> qscale_table_buf ) \n ret = alloc_picture_tables ( s , pic ) ; \n else \n ret = make_tables_writable ( pic ) ; \n if ( ret < 0 ) \n goto fail ; \n if ( s -> encoding ) { \n pic -> mb_var = ( uint16_t * ) pic -> mb_var_buf -> data ; \n pic -> mc_mb_var = ( uint16_t * ) pic -> mc_mb_var_buf -> data ; \n pic -> mb_mean = pic -> mb_mean_buf -> data ; \n } \n pic -> mbskip_table = pic -> mbskip_table_buf -> data ; \n pic -> qscale_table = pic -> qscale_table_buf -> data + 2 * s -> mb_stride + 1 ; \n pic -> mb_type = ( uint32_t * ) pic -> mb_type_buf -> data + 2 * s -> mb_stride + 1 ; \n if ( pic -> motion_val_buf [ 0 ] ) { \n for ( i = 0 ; i < 2 ; i ++ ) { \n pic -> motion_val [ i ] = ( int16_t ( * ) [ 2 ] ) pic -> motion_val_buf [ i ] -> data + 4 ; \n pic -> ref_index [ i ] = pic -> ref_index_buf [ i ] -> data ; \n } \n } \n return 0 ; \n fail : \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n ff_mpeg_unref_picture ( s , pic ) ; \n free_picture_tables ( pic ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 20224}
{"project": "FFmpeg", "commit_id": "7c91b3021c7af9bea6b65f51d645f7574a883870", "target": 0, "func": "int av_image_check_size ( unsigned int w , unsigned int h , int log_offset , void * log_ctx ) \n { \n ImgUtils imgutils = { & imgutils_class , log_offset , log_ctx } ; \n if ( ( int ) w > 0 && ( int ) h > 0 && ( w + 128 ) * ( uint64_t ) ( h + 128 ) < INT_MAX / 8 ) \n return 0 ; \n av_log ( & imgutils , AV_LOG_ERROR , \" \\n \" , w , h ) ; \n return AVERROR ( EINVAL ) ; \n }", "idx": 20244}
{"project": "FFmpeg", "commit_id": "3e033da84782e12ed529e6a88dd53b6a72199e8e", "target": 1, "func": "ff_rm_retrieve_cache ( AVFormatContext * s , AVIOContext * pb , \n AVStream * st , RMStream * ast , AVPacket * pkt )  \n { \n RMDemuxContext * rm = s -> priv_data ; \n assert ( rm -> audio_pkt_cnt > 0 ) ; \n if ( st -> codec -> codec_id == CODEC_ID_AAC ) \n av_get_packet ( pb , pkt , ast -> sub_packet_lengths [ ast -> sub_packet_cnt - rm -> audio_pkt_cnt ] ) ; \n else { \n av_new_packet ( pkt , st -> codec -> block_align ) ; \n memcpy ( pkt -> data , ast -> pkt . data + st -> codec -> block_align * \n ( ast -> sub_packet_h * ast -> audio_framesize / st -> codec -> block_align - rm -> audio_pkt_cnt ) , \n st -> codec -> block_align ) ; \n } \n rm -> audio_pkt_cnt -- ; \n if ( ( pkt -> pts = ast -> audiotimestamp ) != AV_NOPTS_VALUE ) { \n ast -> audiotimestamp = AV_NOPTS_VALUE ; \n pkt -> flags = AV_PKT_FLAG_KEY ; \n } else \n pkt -> flags = 0 ; \n pkt -> stream_index = st -> index ; \n return rm -> audio_pkt_cnt ; \n }", "idx": 20266}
{"project": "FFmpeg", "commit_id": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc", "target": 0, "func": "static AVFrame * get_video_buffer ( AVFilterLink * inlink , int w , int h ) \n { \n PadContext * s = inlink -> dst -> priv ; \n AVFrame * frame = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , \n w + ( s -> w - s -> in_w ) , \n h + ( s -> h - s -> in_h ) ) ; \n int plane ; \n if ( ! frame ) \n return NULL ; \n frame -> width = w ; \n frame -> height = h ; \n for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { \n int hsub = s -> draw . hsub [ plane ] ; \n int vsub = s -> draw . vsub [ plane ] ; \n frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] + \n ( s -> y >> vsub ) * frame -> linesize [ plane ] ; \n } \n return frame ; \n }", "idx": 20272}
{"project": "FFmpeg", "commit_id": "c2b0ce70add2a7dd6e792341c21278cb94820684", "target": 0, "func": "int64_t ff_start_tag ( AVIOContext * pb , const char * tag ) \n { \n ffio_wfourcc ( pb , tag ) ; \n avio_wl32 ( pb , 0 ) ; \n return avio_tell ( pb ) ; \n }", "idx": 20273}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "AVCodecContext * avcodec_alloc_context3 ( const AVCodec * codec ) \n { \n AVCodecContext * avctx = av_malloc ( sizeof ( AVCodecContext ) ) ; \n if ( avctx == NULL ) return NULL ; \n if ( avcodec_get_context_defaults3 ( avctx , codec ) < 0 ) { \n av_free ( avctx ) ; \n return NULL ; \n } \n return avctx ; \n }", "idx": 20275}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static uint16_t roundToInt16 ( int64_t f ) { \n int r = ( f + ( 1 << 15 ) ) >> 16 ; \n if ( r < -0x7FFF ) return 0x8000 ; \n else if ( r > 0x7FFF ) return 0x7FFF ; \n else return r ; \n }", "idx": 20314}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void scale_coefficients ( AC3EncodeContext * s ) \n { \n return ; \n }", "idx": 20316}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_dds1 ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n const uint8_t * frame_start = frame ; \n const uint8_t * frame_end = frame + width * height ; \n int mask = 0x10000 , bitbuf = 0 ; \n int i , v , offset , count , segments ; \n segments = bytestream_get_le16 ( & src ) ; \n while ( segments -- ) { \n if ( mask == 0x10000 ) { \n if ( src >= src_end ) \n return -1 ; \n bitbuf = bytestream_get_le16 ( & src ) ; \n mask = 1 ; \n } \n if ( src_end - src < 2 || frame_end - frame < 2 ) \n return -1 ; \n if ( bitbuf & mask ) { \n v = bytestream_get_le16 ( & src ) ; \n offset = ( v & 0x1FFF ) << 2 ; \n count = ( ( v >> 13 ) + 2 ) << 1 ; \n if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) \n return -1 ; \n for ( i = 0 ; i < count ; i ++ ) { \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; \n frame += 2 ; \n } \n } else if ( bitbuf & ( mask << 1 ) ) { \n frame += bytestream_get_le16 ( & src ) * 2 ; \n } else { \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = * src ++ ; \n frame += 2 ; \n frame [ 0 ] = frame [ 1 ] = \n frame [ width ] = frame [ width + 1 ] = * src ++ ; \n frame += 2 ; \n } \n mask <<= 2 ; \n } \n return 0 ; \n }", "idx": 20317}
{"project": "FFmpeg", "commit_id": "6d2df3c00a7899e9c06e3a460d64e4d0ccde0fae", "target": 1, "func": "static int init_input_threads ( void ) \n { \n int i , ret ; \n if ( nb_input_files == 1 ) \n return 0 ; \n for ( i = 0 ; i < nb_input_files ; i ++ ) { \n InputFile * f = input_files [ i ] ; \n if ( f -> ctx -> pb ? ! f -> ctx -> pb -> seekable : \n strcmp ( f -> ctx -> iformat -> name , \" \" ) ) \n f -> non_blocking = 1 ; \n ret = av_thread_message_queue_alloc ( & f -> in_thread_queue , \n 8 , sizeof ( AVPacket ) ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ( ret = pthread_create ( & f -> thread , NULL , input_thread , f ) ) ) \n return AVERROR ( ret ) ; \n } \n return 0 ; \n }", "idx": 20319}
{"project": "FFmpeg", "commit_id": "a2f55f22b342202e6925561b9ee0b7ec76e8bcd0", "target": 0, "func": "static const MXFCodecUL * mxf_get_essence_container_ul ( enum CodecID type ) \n { \n const MXFCodecUL * uls = ff_mxf_essence_container_uls ; \n while ( uls -> id != CODEC_ID_NONE ) { \n if ( uls -> id == type ) \n break ; \n uls ++ ; \n } \n return uls ; \n }", "idx": 20322}
{"project": "FFmpeg", "commit_id": "ac726a4f0cd2fb8619b478af51312a4282215f0e", "target": 0, "func": "static int amovie_request_frame ( AVFilterLink * outlink ) \n { \n MovieContext * movie = outlink -> src -> priv ; \n int ret ; \n if ( movie -> is_done ) \n return AVERROR_EOF ; \n do { \n if ( ( ret = amovie_get_samples ( outlink ) ) < 0 ) \n return ret ; \n } while ( ! movie -> samplesref ) ; \n ff_filter_samples ( outlink , avfilter_ref_buffer ( movie -> samplesref , ~ 0 ) ) ; \n avfilter_unref_buffer ( movie -> samplesref ) ; \n movie -> samplesref = NULL ; \n return 0 ; \n }", "idx": 20323}
{"project": "FFmpeg", "commit_id": "7373b3ad043cc3417d80c55ccdb620b08cd271bf", "target": 0, "func": "static av_cold int pcm_decode_init ( AVCodecContext * avctx ) \n { \n PCMDecode * s = avctx -> priv_data ; \n int i ; \n if ( avctx -> channels <= 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n switch ( avctx -> codec -> id ) { \n case AV_CODEC_ID_PCM_ALAW : \n for ( i = 0 ; i < 256 ; i ++ ) \n s -> table [ i ] = alaw2linear ( i ) ; \n break ; \n case AV_CODEC_ID_PCM_MULAW : \n for ( i = 0 ; i < 256 ; i ++ ) \n s -> table [ i ] = ulaw2linear ( i ) ; \n break ; \n default : \n break ; \n } \n avctx -> sample_fmt = avctx -> codec -> sample_fmts [ 0 ] ; \n if ( avctx -> sample_fmt == AV_SAMPLE_FMT_S32 ) \n avctx -> bits_per_raw_sample = av_get_bits_per_sample ( avctx -> codec -> id ) ; \n avcodec_get_frame_defaults ( & s -> frame ) ; \n avctx -> coded_frame = & s -> frame ; \n return 0 ; \n }", "idx": 20324}
{"project": "FFmpeg", "commit_id": "67afcefb35932b420998f6f3fda46c7c85848a3f", "target": 0, "func": "static void vda_h264_uninit ( AVCodecContext * avctx ) \n { \n VDAContext * vda = avctx -> internal -> priv_data ; \n av_freep ( & vda -> bitstream ) ; \n }", "idx": 20326}
{"project": "FFmpeg", "commit_id": "8df8a87e3fd5bd0c3dabc676aae8fd84992932dc", "target": 1, "func": "static void cmv_process_header ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) \n { \n int pal_start , pal_count , i ; \n if ( buf + 16 >= buf_end ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return ; \n } \n s -> width = AV_RL16 ( & buf [ 4 ] ) ; \n s -> height = AV_RL16 ( & buf [ 6 ] ) ; \n if ( s -> avctx -> width != s -> width || s -> avctx -> height != s -> height ) \n avcodec_set_dimensions ( s -> avctx , s -> width , s -> height ) ; \n s -> avctx -> time_base . num = 1 ; \n s -> avctx -> time_base . den = AV_RL16 ( & buf [ 10 ] ) ; \n pal_start = AV_RL16 ( & buf [ 12 ] ) ; \n pal_count = AV_RL16 ( & buf [ 14 ] ) ; \n buf += 16 ; \n for ( i = pal_start ; i < pal_start + pal_count && i < AVPALETTE_COUNT && buf + 2 < buf_end ; i ++ ) { \n s -> palette [ i ] = AV_RB24 ( buf ) ; \n buf += 3 ; \n } \n }", "idx": 20330}
{"project": "FFmpeg", "commit_id": "9487fb4dea3498eb4711eb023f43199f68701b1e", "target": 1, "func": "yuv2422_2_c_template ( SwsContext * c , const int16_t * buf [ 2 ] , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf [ 2 ] , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n const int16_t * buf0 = buf [ 0 ] , * buf1 = buf [ 1 ] , \n * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] , \n * vbuf0 = vbuf [ 0 ] , * vbuf1 = vbuf [ 1 ] ; \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n }", "idx": 20334}
{"project": "FFmpeg", "commit_id": "47f1596ecef3304f20be1be2dc6978989334608f", "target": 1, "func": "static int dxtory_decode_v1_410 ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size ) \n { \n int h , w ; \n uint8_t * Y1 , * Y2 , * Y3 , * Y4 , * U , * V ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * 9L / 8 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n Y1 = pic -> data [ 0 ] ; \n Y2 = pic -> data [ 0 ] + pic -> linesize [ 0 ] ; \n Y3 = pic -> data [ 0 ] + pic -> linesize [ 0 ] * 2 ; \n Y4 = pic -> data [ 0 ] + pic -> linesize [ 0 ] * 3 ; \n U = pic -> data [ 1 ] ; \n V = pic -> data [ 2 ] ; \n for ( h = 0 ; h < avctx -> height ; h += 4 ) { \n for ( w = 0 ; w < avctx -> width ; w += 4 ) { \n AV_COPY32 ( Y1 + w , src ) ; \n AV_COPY32 ( Y2 + w , src + 4 ) ; \n AV_COPY32 ( Y3 + w , src + 8 ) ; \n AV_COPY32 ( Y4 + w , src + 12 ) ; \n U [ w >> 2 ] = src [ 16 ] + 0x80 ; \n V [ w >> 2 ] = src [ 17 ] + 0x80 ; \n src += 18 ; \n } \n Y1 += pic -> linesize [ 0 ] << 2 ; \n Y2 += pic -> linesize [ 0 ] << 2 ; \n Y3 += pic -> linesize [ 0 ] << 2 ; \n Y4 += pic -> linesize [ 0 ] << 2 ; \n U += pic -> linesize [ 1 ] ; \n V += pic -> linesize [ 2 ] ; \n } \n return 0 ; \n }", "idx": 20336}
{"project": "FFmpeg", "commit_id": "a417d041f03d725b0e159136e063538f0cee786a", "target": 0, "func": "static void dnxhd_decode_dct_block ( DNXHDContext * ctx , DCTELEM * block , int n , int qscale ) \n { \n int i , j , index , index2 ; \n int level , component , sign ; \n const uint8_t * weigth_matrix ; \n if ( n & 2 ) { \n component = 1 + ( n & 1 ) ; \n weigth_matrix = ctx -> cid_table -> chroma_weigth ; \n } else { \n component = 0 ; \n weigth_matrix = ctx -> cid_table -> luma_weigth ; \n } \n ctx -> last_dc [ component ] += dnxhd_decode_dc ( ctx ) ; \n block [ 0 ] = ctx -> last_dc [ component ] ; \n for ( i = 1 ; ; i ++ ) { \n index = get_vlc2 ( & ctx -> gb , ctx -> ac_vlc . table , DNXHD_VLC_BITS , 2 ) ; \n level = ctx -> cid_table -> ac_level [ index ] ; \n if ( ! level ) { \n return ; \n } \n sign = get_sbits ( & ctx -> gb , 1 ) ; \n if ( ctx -> cid_table -> ac_index_flag [ index ] ) { \n level += get_bits ( & ctx -> gb , ctx -> cid_table -> index_bits ) << 6 ; \n } \n if ( ctx -> cid_table -> ac_run_flag [ index ] ) { \n index2 = get_vlc2 ( & ctx -> gb , ctx -> run_vlc . table , DNXHD_VLC_BITS , 2 ) ; \n i += ctx -> cid_table -> run [ index2 ] ; \n } \n j = ctx -> scantable . permutated [ i ] ; \n level = ( 2 * level + 1 ) * qscale * weigth_matrix [ i ] ; \n if ( weigth_matrix [ i ] != 32 ) \n level += 32 ; \n level >>= 6 ; \n level = ( level ^ sign ) - sign ; \n if ( i > 63 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , n , i ) ; \n return ; \n } \n block [ j ] = level ; \n } \n }", "idx": 20337}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char * avutil_configuration ( void ) \n { \n return FFMPEG_CONFIGURATION ; \n }", "idx": 20339}
{"project": "FFmpeg", "commit_id": "e211e255aa399d68239ffa42c9cc7a52eb3d55a9", "target": 1, "func": "void ff_bink_idct_put_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n DCTELEM temp [ 64 ] ; \n for ( i = 0 ; i < 8 ; i ++ ) \n bink_idct_col ( & temp [ i ] , & block [ i ] ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n IDCT_ROW ( ( & dest [ i * linesize ] ) , ( & temp [ 8 * i ] ) ) ; \n } \n }", "idx": 20342}
{"project": "FFmpeg", "commit_id": "c898431ca5ef2a997fe9388b650f658fb60783e5", "target": 1, "func": "static int nsv_read_header ( AVFormatContext * s ) \n { \n NSVContext * nsv = s -> priv_data ; \n int i , err ; \n av_dlog ( s , \" \\n \" , __FUNCTION__ ) ; \n av_dlog ( s , \" \\n \" , s -> filename ) ; \n nsv -> state = NSV_UNSYNC ; \n nsv -> ahead [ 0 ] . data = nsv -> ahead [ 1 ] . data = NULL ; \n for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES ; i ++ ) { \n if ( nsv_resync ( s ) < 0 ) \n return -1 ; \n if ( nsv -> state == NSV_FOUND_NSVF ) \n err = nsv_parse_NSVf_header ( s ) ; \n if ( nsv -> state == NSV_FOUND_NSVS ) { \n err = nsv_parse_NSVs_header ( s ) ; \n break ; \n } \n } \n if ( s -> nb_streams < 1 ) \n return -1 ; \n err = nsv_read_chunk ( s , 1 ) ; \n av_dlog ( s , \" \\n \" ) ; \n return err ; \n }", "idx": 20347}
{"project": "FFmpeg", "commit_id": "08797c599df5371909f6924d732b654f8892cc91", "target": 0, "func": "static int get_best_header ( FLACParseContext * fpc , const uint8_t * * poutbuf , \n int * poutbuf_size ) \n { \n FLACHeaderMarker * header = fpc -> best_header ; \n FLACHeaderMarker * child = header -> best_child ; \n if ( ! child ) { \n * poutbuf_size = av_fifo_size ( fpc -> fifo_buf ) - header -> offset ; \n } else { \n * poutbuf_size = child -> offset - header -> offset ; \n check_header_mismatch ( fpc , header , child , 0 ) ; \n } \n if ( header -> fi . channels != fpc -> avctx -> channels || \n ( ! fpc -> avctx -> channel_layout && header -> fi . channels <= 6 ) ) { \n fpc -> avctx -> channels = header -> fi . channels ; \n ff_flac_set_channel_layout ( fpc -> avctx ) ; \n } \n fpc -> avctx -> sample_rate = header -> fi . samplerate ; \n fpc -> pc -> duration = header -> fi . blocksize ; \n * poutbuf = flac_fifo_read_wrap ( fpc , header -> offset , * poutbuf_size , \n & fpc -> wrap_buf , \n & fpc -> wrap_buf_allocated_size ) ; \n fpc -> best_header_valid = 0 ; \n if ( child ) \n return child -> offset - av_fifo_size ( fpc -> fifo_buf ) ; \n return 0 ; \n }", "idx": 20350}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_avg_h264_qpel16_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avg_width16_msa ( src , stride , dst , stride , 16 ) ; \n }", "idx": 20353}
{"project": "FFmpeg", "commit_id": "38d7cc22f7782de2e7aca8eda2c2c2996f7f5700", "target": 0, "func": "static inline int init_pfa_reindex_tabs ( MDCT15Context * s ) \n { \n int i , j ; \n const int b_ptwo = s -> ptwo_fft . nbits ; \n const int l_ptwo = 1 << b_ptwo ; \n const int inv_1 = l_ptwo << ( ( 4 - b_ptwo ) & 3 ) ; \n const int inv_2 = 0xeeeeeeef & ( ( 1U << b_ptwo ) - 1 ) ; \n s -> pfa_prereindex = av_malloc ( 15 * l_ptwo * sizeof ( * s -> pfa_prereindex ) ) ; \n if ( ! s -> pfa_prereindex ) \n return 1 ; \n s -> pfa_postreindex = av_malloc ( 15 * l_ptwo * sizeof ( * s -> pfa_postreindex ) ) ; \n if ( ! s -> pfa_postreindex ) \n return 1 ; \n for ( i = 0 ; i < l_ptwo ; i ++ ) { \n for ( j = 0 ; j < 15 ; j ++ ) { \n const int q_pre = ( ( l_ptwo * j ) / 15 + i ) >> b_ptwo ; \n const int q_post = ( ( ( j * inv_1 ) / 15 ) + ( i * inv_2 ) ) >> b_ptwo ; \n const int k_pre = 15 * i + ( ( j - q_pre * 15 ) << b_ptwo ) ; \n const int k_post = i * inv_2 * 15 + j * inv_1 - 15 * q_post * l_ptwo ; \n s -> pfa_prereindex [ i * 15 + j ] = k_pre ; \n s -> pfa_postreindex [ k_post ] = l_ptwo * j + i ; \n } \n } \n return 0 ; \n }", "idx": 20354}
{"project": "FFmpeg", "commit_id": "0c1959b056f6ccaa2eee2c824352ba93c8e36d52", "target": 0, "func": "static void mxf_write_identification ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n const char * company = \" \" ; \n const char * product = \" \" ; \n const char * version ; \n int length ; \n mxf_write_metadata_key ( pb , 0x013000 ) ; \n PRINT_KEY ( s , \" \" , pb -> buf_ptr - 16 ) ; \n version = s -> streams [ 0 ] -> codec -> flags & CODEC_FLAG_BITEXACT ? \n \" \" : AV_STRINGIFY ( LIBAVFORMAT_VERSION ) ; \n length = 84 + ( strlen ( company ) + strlen ( product ) + strlen ( version ) ) * 2 ; \n klv_encode_ber_length ( pb , length ) ; \n mxf_write_local_tag ( pb , 16 , 0x3C0A ) ; \n mxf_write_uuid ( pb , Identification , 0 ) ; \n PRINT_KEY ( s , \" \" , pb -> buf_ptr - 16 ) ; \n mxf_write_local_tag ( pb , 16 , 0x3C09 ) ; \n mxf_write_uuid ( pb , Identification , 1 ) ; \n mxf_write_local_tag_utf16 ( pb , 0x3C01 , company ) ; \n mxf_write_local_tag_utf16 ( pb , 0x3C02 , product ) ; \n mxf_write_local_tag_utf16 ( pb , 0x3C04 , version ) ; \n mxf_write_local_tag ( pb , 16 , 0x3C05 ) ; \n mxf_write_uuid ( pb , Identification , 2 ) ; \n mxf_write_local_tag ( pb , 8 , 0x3C06 ) ; \n avio_wb64 ( pb , mxf -> timestamp ) ; \n }", "idx": 20355}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int hls_write_trailer ( struct AVFormatContext * s ) \n { \n HLSContext * hls = s -> priv_data ; \n AVFormatContext * oc = hls -> avf ; \n av_write_trailer ( oc ) ; \n avio_closep ( & oc -> pb ) ; \n avformat_free_context ( oc ) ; \n av_free ( hls -> basename ) ; \n append_entry ( hls , hls -> duration ) ; \n hls_window ( s , 1 ) ; \n free_entries ( hls ) ; \n return 0 ; \n }", "idx": 20381}
{"project": "FFmpeg", "commit_id": "c8d36d254e298a51ea569b2557451d26499d0f88", "target": 0, "func": "static int g726_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n G726Context * c = avctx -> priv_data ; \n int16_t * samples = data ; \n GetBitContext gb ; \n init_get_bits ( & gb , buf , buf_size * 8 ) ; \n while ( get_bits_count ( & gb ) + c -> code_size <= buf_size * 8 ) \n * samples ++ = g726_decode ( c , get_bits ( & gb , c -> code_size ) ) ; \n if ( buf_size * 8 != get_bits_count ( & gb ) ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n * data_size = ( uint8_t * ) samples - ( uint8_t * ) data ; \n return buf_size ; \n }", "idx": 20382}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_mono_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) \n samples [ i + 256 ] = samples [ i ] ; \n }", "idx": 20383}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuvj444p ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n int src_wrap , x , y ; \n int r , g , b ; \n uint8_t * lum , * cb , * cr ; \n const uint8_t * p ; \n lum = dst -> data [ 0 ] ; \n cb = dst -> data [ 1 ] ; \n cr = dst -> data [ 2 ] ; \n src_wrap = src -> linesize [ 0 ] - width * BPP ; \n p = src -> data [ 0 ] ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n RGB_IN ( r , g , b , p ) ; \n lum [ 0 ] = RGB_TO_Y ( r , g , b ) ; \n cb [ 0 ] = RGB_TO_U ( r , g , b , 0 ) ; \n cr [ 0 ] = RGB_TO_V ( r , g , b , 0 ) ; \n cb ++ ; \n cr ++ ; \n lum ++ ; \n } \n p += src_wrap ; \n lum += dst -> linesize [ 0 ] - width ; \n cb += dst -> linesize [ 1 ] - width ; \n cr += dst -> linesize [ 2 ] - width ; \n } \n }", "idx": 20386}
{"project": "FFmpeg", "commit_id": "70205f1799252c3363a5bb5ea7ea5df090f2c88f", "target": 0, "func": "static int vf_open ( vf_instance_t * vf , char * args ) { \n vf -> config = config ; \n vf -> put_image = put_image ; \n vf -> get_image = get_image ; \n vf -> query_format = query_format ; \n vf -> uninit = uninit ; \n vf -> control = control ; \n vf -> priv = malloc ( sizeof ( struct vf_priv_s ) ) ; \n memset ( vf -> priv , 0 , sizeof ( struct vf_priv_s ) ) ; \n if ( args ) sscanf ( args , \" \" , & vf -> priv -> qp , & vf -> priv -> mode ) ; \n if ( vf -> priv -> qp < 0 ) \n vf -> priv -> qp = 0 ; \n init_thres2 ( ) ; \n switch ( vf -> priv -> mode ) { \n case 0 : requantize = hardthresh_c ; break ; \n case 1 : requantize = softthresh_c ; break ; \n default : \n case 2 : requantize = mediumthresh_c ; break ; \n } \n #if HAVE_MMX  \n  \n  if ( ff_gCpuCaps . hasMMX ) { \n dctB = dctB_mmx ; \n } \n #endif \n #if 0  \n  \n  if ( ff_gCpuCaps . hasMMX ) { \n switch ( vf -> priv -> mode ) { \n case 0 : requantize = hardthresh_mmx ; break ; \n case 1 : requantize = softthresh_mmx ; break ; \n } \n } \n #endif \n return 1 ; \n }", "idx": 20387}
{"project": "FFmpeg", "commit_id": "b888abe1be9f0b3c75273c28e9a7b58fe47d5ec4", "target": 0, "func": "static int eval_refl ( int * refl , const int16_t * coefs , RA144Context * ractx ) \n { \n int b , c , i ; \n unsigned int u ; \n int buffer1 [ 10 ] ; \n int buffer2 [ 10 ] ; \n int * bp1 = buffer1 ; \n int * bp2 = buffer2 ; \n for ( i = 0 ; i < 10 ; i ++ ) \n buffer2 [ i ] = coefs [ i ] ; \n refl [ 9 ] = bp2 [ 9 ] ; \n if ( ( unsigned ) bp2 [ 9 ] + 0x1000 > 0x1fff ) { \n av_log ( ractx , AV_LOG_ERROR , \" \\n \" ) ; \n return 1 ; \n } \n for ( c = 8 ; c >= 0 ; c -- ) { \n b = 0x1000 - ( ( bp2 [ c + 1 ] * bp2 [ c + 1 ] ) >> 12 ) ; \n if ( ! b ) \n b = -2 ; \n for ( u = 0 ; u <= c ; u ++ ) \n bp1 [ u ] = ( ( bp2 [ u ] - ( ( refl [ c + 1 ] * bp2 [ c - u ] ) >> 12 ) ) * ( 0x1000000 / b ) ) >> 12 ; \n refl [ c ] = bp1 [ c ] ; \n if ( ( unsigned ) bp1 [ c ] + 0x1000 > 0x1fff ) \n return 1 ; \n FFSWAP ( int * , bp1 , bp2 ) ; \n } \n return 0 ; \n }", "idx": 20389}
{"project": "FFmpeg", "commit_id": "21b37480291e827ad6af26df283f734381a9fb75", "target": 0, "func": "static char * sdp_media_attributes ( char * buff , int size , AVCodecContext * c , int payload_type ) \n { \n char * config = NULL ; \n switch ( c -> codec_id ) { \n case CODEC_ID_MPEG4 : \n if ( c -> flags & CODEC_FLAG_GLOBAL_HEADER ) { \n config = extradata2config ( c -> extradata , c -> extradata_size ) ; \n } \n av_strlcatf ( buff , size , \" \\r \\n \" \n \" \\r \\n \" , \n payload_type , \n payload_type , config ? config : \" \" ) ; \n break ; \n case CODEC_ID_AAC : \n if ( c -> flags & CODEC_FLAG_GLOBAL_HEADER ) { \n config = extradata2config ( c -> extradata , c -> extradata_size ) ; \n } else { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return NULL ; \n } \n if ( config == NULL ) { \n return NULL ; \n } \n av_strlcatf ( buff , size , \" \\r \\n \" \n \" \" \n \" \" \n \" \\r \\n \" , \n payload_type , c -> sample_rate , c -> channels , \n payload_type , config ) ; \n break ; \n default : \n break ; \n } \n av_free ( config ) ; \n return buff ; \n }", "idx": 20390}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "static int mpegvideo_parse ( AVCodecParserContext * s , \n AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n ParseContext1 * pc1 = s -> priv_data ; \n ParseContext * pc = & pc1 -> pc ; \n int next ; \n if ( s -> flags & PARSER_FLAG_COMPLETE_FRAMES ) { \n next = buf_size ; \n } else { \n next = ff_mpeg1_find_frame_end ( pc , buf , buf_size ) ; \n if ( ff_combine_frame ( pc , next , & buf , & buf_size ) < 0 ) { \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n } \n } \n mpegvideo_extract_headers ( s , avctx , buf , buf_size ) ; \n #if 0  \n  \n  printf ( \" \\n \" , \n s -> pict_type , ( double ) avctx -> time_base . den / avctx -> time_base . num , s -> repeat_pict ) ; \n #endif \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n return next ; \n }", "idx": 20391}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static int libschroedinger_encode_close ( AVCodecContext * avctx ) \n { \n SchroEncoderParams * p_schro_params = avctx -> priv_data ; \n schro_encoder_free ( p_schro_params -> encoder ) ; \n ff_schro_queue_free ( & p_schro_params -> enc_frame_queue , \n libschroedinger_free_frame ) ; \n if ( p_schro_params -> enc_buf_size ) \n av_freep ( & p_schro_params -> enc_buf ) ; \n av_freep ( & p_schro_params -> format ) ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 20393}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static inline int mpeg4_is_resync ( MpegEncContext * s ) { \n const int bits_count = get_bits_count ( & s -> gb ) ; \n if ( s -> workaround_bugs & FF_BUG_NO_PADDING ) { \n return 0 ; \n } \n if ( bits_count + 8 >= s -> gb . size * 8 ) { \n int v = show_bits ( & s -> gb , 8 ) ; \n v |= 0x7F >> ( 7 - ( bits_count & 7 ) ) ; \n if ( v == 0x7F ) \n return 1 ; \n } else { \n if ( show_bits ( & s -> gb , 16 ) == ff_mpeg4_resync_prefix [ bits_count & 7 ] ) { \n int len ; \n GetBitContext gb = s -> gb ; \n skip_bits ( & s -> gb , 1 ) ; \n align_get_bits ( & s -> gb ) ; \n for ( len = 0 ; len < 32 ; len ++ ) { \n if ( get_bits1 ( & s -> gb ) ) break ; \n } \n s -> gb = gb ; \n if ( len >= ff_mpeg4_get_video_packet_prefix_length ( s ) ) \n return 1 ; \n } \n } \n return 0 ; \n }", "idx": 20416}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_hv_qrt_and_aver_dst_16x16_msa ( const uint8_t * src_x , \n const uint8_t * src_y , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src_x , src_y , src_stride , \n dst , dst_stride ) ; \n src_x += 8 ; \n src_y += 8 ; \n dst += 8 ; \n } \n src_x += ( 8 * src_stride ) - 16 ; \n src_y += ( 8 * src_stride ) - 16 ; \n dst += ( 8 * dst_stride ) - 16 ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src_x , src_y , src_stride , \n dst , dst_stride ) ; \n src_x += 8 ; \n src_y += 8 ; \n dst += 8 ; \n } \n }", "idx": 20427}
{"project": "FFmpeg", "commit_id": "7d89f7cbf3ccd98f9a5f58db97effa9afd2d571a", "target": 1, "func": "static int crypto_close ( URLContext * h ) \n { \n CryptoContext * c = h -> priv_data ; \n if ( c -> hd ) \n ffurl_close ( c -> hd ) ; \n av_freep ( & c -> aes ) ; \n av_freep ( & c -> key ) ; \n av_freep ( & c -> iv ) ; \n return 0 ; \n }", "idx": 20448}
{"project": "FFmpeg", "commit_id": "3fa8f263abf90650b62d43cb532cdb8cc5bd7c13", "target": 1, "func": "int swr_convert_frame ( SwrContext * s , \n AVFrame * out , const AVFrame * in ) \n { \n int ret , setup = 0 ; \n if ( ! swr_is_initialized ( s ) ) { \n if ( ( ret = swr_config_frame ( s , out , in ) ) < 0 ) \n return ret ; \n if ( ( ret = swr_init ( s ) ) < 0 ) \n return ret ; \n setup = 1 ; \n } else { \n if ( ( ret = config_changed ( s , out , in ) ) ) \n return ret ; \n } \n if ( out ) { \n if ( ! out -> linesize [ 0 ] ) { \n out -> nb_samples = swr_get_delay ( s , s -> out_sample_rate ) \n + in -> nb_samples * ( int64_t ) s -> out_sample_rate / s -> in_sample_rate \n + 3 ; \n if ( ( ret = av_frame_get_buffer ( out , 0 ) ) < 0 ) { \n if ( setup ) \n swr_close ( s ) ; \n return ret ; \n } \n } else { \n if ( ! out -> nb_samples ) \n out -> nb_samples = available_samples ( out ) ; \n } \n } \n return convert_frame ( s , out , in ) ; \n }", "idx": 20452}
{"project": "FFmpeg", "commit_id": "b425b81fd2040f173051efc0f1413f2101ba993e", "target": 1, "func": "static int sdp_probe ( AVProbeData * p1 ) \n { \n const char * p = p1 -> buf , * p_end = p1 -> buf + p1 -> buf_size ; \n while ( p < p_end && * p != ' \\0 ' ) { \n if ( p + sizeof ( \" \" ) - 1 < p_end && \n av_strstart ( p , \" \" , NULL ) ) \n return AVPROBE_SCORE_EXTENSION ; \n while ( p < p_end - 1 && * p != ' \\n ' ) p ++ ; \n if ( ++ p >= p_end ) \n break ; \n if ( * p == ' \\r ' ) \n p ++ ; \n } \n return 0 ; \n }", "idx": 20459}
{"project": "FFmpeg", "commit_id": "fec9ccb7e6fdc6844b1e2d1bb95436b36f47a412", "target": 0, "func": "int avcodec_decode_audio ( AVCodecContext * avctx , int16_t * samples , \n int * frame_size_ptr , \n uint8_t * buf , int buf_size ) \n { \n int ret ; \n * frame_size_ptr = 0 ; \n ret = avctx -> codec -> decode ( avctx , samples , frame_size_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n return ret ; \n }", "idx": 20460}
{"project": "FFmpeg", "commit_id": "1171d938af219aa1217a472391bc392f6e698386", "target": 1, "func": "static int init_input ( AVFormatContext * s , const char * filename , AVDictionary * * options ) \n { \n int ret ; \n AVProbeData pd = { filename , NULL , 0 } ; \n if ( s -> iformat && ! strlen ( filename ) ) \n return 0 ; \n if ( s -> pb ) { \n s -> flags |= AVFMT_FLAG_CUSTOM_IO ; \n if ( ! s -> iformat ) \n return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , 0 ) ; \n else if ( s -> iformat -> flags & AVFMT_NOFILE ) \n av_log ( s , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n return 0 ; \n } \n if ( ( s -> iformat && s -> iformat -> flags & AVFMT_NOFILE ) || \n ( ! s -> iformat && ( s -> iformat = av_probe_input_format ( & pd , 0 ) ) ) ) \n return 0 ; \n if ( ( ret = avio_open2 ( & s -> pb , filename , AVIO_FLAG_READ , \n & s -> interrupt_callback , options ) ) < 0 ) \n return ret ; \n if ( s -> iformat ) \n return 0 ; \n return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , 0 ) ; \n }", "idx": 20475}
{"project": "FFmpeg", "commit_id": "103f9c261a68299125b99c542e20f5541051d2c9", "target": 0, "func": "static inline void skip_hdr_extension ( GetBitContext * gb ) \n { \n int i , len ; \n do { \n len = get_bits ( gb , 8 ) ; \n for ( i = 0 ; i < len ; i ++ ) skip_bits ( gb , 8 ) ; \n } while ( len ) ; \n }", "idx": 20493}
{"project": "FFmpeg", "commit_id": "f3ace85d8869c3dddd2d28d064002d0d912e3624", "target": 0, "func": "int av_opt_set_dict2 ( void * obj , AVDictionary * * options , int search_flags ) \n { \n AVDictionaryEntry * t = NULL ; \n AVDictionary * tmp = NULL ; \n int ret = 0 ; \n if ( ! options ) \n return 0 ; \n while ( ( t = av_dict_get ( * options , \" \" , t , AV_DICT_IGNORE_SUFFIX ) ) ) { \n ret = av_opt_set ( obj , t -> key , t -> value , search_flags ) ; \n if ( ret == AVERROR_OPTION_NOT_FOUND ) \n av_dict_set ( & tmp , t -> key , t -> value , 0 ) ; \n else if ( ret < 0 ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , t -> key , t -> value ) ; \n break ; \n } \n ret = 0 ; \n } \n av_dict_free ( options ) ; \n * options = tmp ; \n return ret ; \n }", "idx": 20504}
{"project": "FFmpeg", "commit_id": "5331773cc33ba26b9e26ace643d926219e46a17b", "target": 0, "func": "void ff_id3v2_read_dict ( AVIOContext * pb , AVDictionary * * metadata , \n const char * magic , ID3v2ExtraMeta * * extra_meta ) \n { \n id3v2_read_internal ( pb , metadata , NULL , magic , extra_meta ) ; \n }", "idx": 20514}
{"project": "FFmpeg", "commit_id": "fa5d299496c15e992240914ae05b92d9b74eb3c4", "target": 0, "func": "static void idct ( uint8_t * dst , int dst_linesize , int src [ 64 ] ) \n { \n int i , j , k ; \n double tmp [ 64 ] ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n for ( j = 0 ; j < 8 ; j ++ ) { \n double sum = 0.0 ; \n for ( k = 0 ; k < 8 ; k ++ ) \n sum += c [ k * 8 + j ] * src [ 8 * i + k ] ; \n tmp [ 8 * i + j ] = sum ; \n } \n } \n for ( j = 0 ; j < 8 ; j ++ ) { \n for ( i = 0 ; i < 8 ; i ++ ) { \n double sum = 0.0 ; \n for ( k = 0 ; k < 8 ; k ++ ) \n sum += c [ k * 8 + i ] * tmp [ 8 * k + j ] ; \n dst [ dst_linesize * i + j ] = av_clip_uint8 ( ( int ) floor ( sum + 0.5 ) ) ; \n } \n } \n }", "idx": 20522}
{"project": "FFmpeg", "commit_id": "6a4832caaede15e3d918b1408ff83fe30324507b", "target": 0, "func": "void ff_avg_dirac_pixels32_sse2 ( uint8_t * dst , const uint8_t * src [ 5 ] , int stride , int h ) \n { \n if ( h & 3 ) { \n ff_avg_dirac_pixels32_c ( dst , src , stride , h ) ; \n } else { \n ff_avg_pixels16_sse2 ( dst , src [ 0 ] , stride , h ) ; \n ff_avg_pixels16_sse2 ( dst + 16 , src [ 0 ] + 16 , stride , h ) ; \n } \n }", "idx": 20537}
{"project": "FFmpeg", "commit_id": "e3751aa6ec8147ab7ca2649d4daadf8d4dce27d5", "target": 0, "func": "static int ra288_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , const uint8_t * buf , \n int buf_size ) \n { \n int16_t * out = data ; \n int i , j ; \n RA288Context * ractx = avctx -> priv_data ; \n GetBitContext gb ; \n if ( buf_size < avctx -> block_align ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , \n buf_size , avctx -> block_align ) ; \n return 0 ; \n } \n init_get_bits ( & gb , buf , avctx -> block_align * 8 ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n float gain = amptable [ get_bits ( & gb , 3 ) ] ; \n int cb_coef = get_bits ( & gb , 6 + ( i & 1 ) ) ; \n decode ( ractx , gain , cb_coef ) ; \n for ( j = 0 ; j < 5 ; j ++ ) \n * ( out ++ ) = 8 * ractx -> sp_block [ 4 - j ] ; \n if ( ( i & 7 ) == 3 ) \n backward_filter ( ractx ) ; \n } \n * data_size = ( char * ) out - ( char * ) data ; \n return avctx -> block_align ; \n }", "idx": 20538}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel8_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_8x8_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 20539}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "static int slice_decode_thread ( AVCodecContext * c , void * arg ) { \n MpegEncContext * s = * ( void * * ) arg ; \n const uint8_t * buf = s -> gb . buffer ; \n int mb_y = s -> start_mb_y ; \n const int field_pic = s -> picture_structure != PICT_FRAME ; \n s -> error_count = ( 3 * ( s -> end_mb_y - s -> start_mb_y ) * s -> mb_width ) >> field_pic ; \n for ( ; ; ) { \n uint32_t start_code ; \n int ret ; \n ret = mpeg_decode_slice ( ( Mpeg1Context * ) s , mb_y , & buf , s -> gb . buffer_end - buf ) ; \n emms_c ( ) ; \n if ( ret < 0 ) { \n if ( s -> resync_mb_x >= 0 && s -> resync_mb_y >= 0 ) \n ff_er_add_slice ( s , s -> resync_mb_x , s -> resync_mb_y , s -> mb_x , s -> mb_y , AC_ERROR | DC_ERROR | MV_ERROR ) ; \n } else { \n ff_er_add_slice ( s , s -> resync_mb_x , s -> resync_mb_y , s -> mb_x - 1 , s -> mb_y , AC_END | DC_END | MV_END ) ; \n } \n if ( s -> mb_y == s -> end_mb_y ) \n return 0 ; \n start_code = -1 ; \n buf = ff_find_start_code ( buf , s -> gb . buffer_end , & start_code ) ; \n mb_y = ( start_code - SLICE_MIN_START_CODE ) << field_pic ; \n if ( s -> picture_structure == PICT_BOTTOM_FIELD ) \n mb_y ++ ; \n if ( mb_y < 0 || mb_y >= s -> end_mb_y ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 20543}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel16_mc12_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_16w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 16 , 0 ) ; \n }", "idx": 20544}
{"project": "FFmpeg", "commit_id": "aac8b76983e340bc744d3542d676f72efa3b474f", "target": 0, "func": "static void filter_mb_edgech ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 4 ] , int qp ) { \n int i ; \n const int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = ( alpha_table + 52 ) [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) \n tc [ i ] = bS [ i ] ? ( tc0_table + 52 ) [ index_a ] [ bS [ i ] - 1 ] + 1 : 0 ; \n h -> s . dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 20545}
{"project": "FFmpeg", "commit_id": "9ccbc672aa341d3cb4c4159e1e746ef0693ee138", "target": 0, "func": "int ff_wmv2_decode_picture_header ( MpegEncContext * s ) \n { \n Wmv2Context * const w = ( Wmv2Context * ) s ; \n int code ; \n #if 0  \n  \n  { \n int i ; \n for ( i = 0 ; i < s -> gb . size * 8 ; i ++ ) \n printf ( \" \" , get_bits1 ( & s -> gb ) ) ; \n printf ( \" \\n \" ) ; \n return -1 ; \n } \n #endif \n if ( s -> picture_number == 0 ) \n decode_ext_header ( w ) ; \n s -> pict_type = get_bits1 ( & s -> gb ) + 1 ; \n if ( s -> pict_type == I_TYPE ) { \n code = get_bits ( & s -> gb , 7 ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , code ) ; \n } \n s -> chroma_qscale = s -> qscale = get_bits ( & s -> gb , 5 ) ; \n if ( s -> qscale < 0 ) \n return -1 ; \n return 0 ; \n }", "idx": 20565}
{"project": "FFmpeg", "commit_id": "e59c28b16660b8f86ef05c7f0db4db89e62ed55f", "target": 1, "func": "static inline short adpcm_ms_expand_nibble ( ADPCMChannelStatus * c , int nibble ) \n { \n int predictor ; \n predictor = ( ( ( c -> sample1 ) * ( c -> coeff1 ) ) + ( ( c -> sample2 ) * ( c -> coeff2 ) ) ) / 64 ; \n predictor += ( ( nibble & 0x08 ) ? ( nibble - 0x10 ) : ( nibble ) ) * c -> idelta ; \n c -> sample2 = c -> sample1 ; \n c -> sample1 = av_clip_int16 ( predictor ) ; \n c -> idelta = ( ff_adpcm_AdaptationTable [ ( int ) nibble ] * c -> idelta ) >> 8 ; \n if ( c -> idelta < 16 ) c -> idelta = 16 ; \n return c -> sample1 ; ", "idx": 20578}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "func": "void ff_lzw_decode_tail ( LZWState * p ) \n { \n struct LZWState * s = ( struct LZWState * ) p ; \n while ( ! s -> eob_reached ) \n lzw_get_code ( s ) ; \n }", "idx": 20580}
{"project": "FFmpeg", "commit_id": "d135f3c514ac1723256c8e0f5cdd466fe98a2578", "target": 1, "func": "static void FUNC ( put_hevc_qpel_bi_w_v ) ( uint8_t * _dst , ptrdiff_t _dststride , uint8_t * _src , ptrdiff_t _srcstride , \n int16_t * src2 , \n int height , int denom , int wx0 , int wx1 , \n int ox0 , int ox1 , intptr_t mx , intptr_t my , int width ) \n { \n int x , y ; \n pixel * src = ( pixel * ) _src ; \n ptrdiff_t srcstride = _srcstride / sizeof ( pixel ) ; \n pixel * dst = ( pixel * ) _dst ; \n ptrdiff_t dststride = _dststride / sizeof ( pixel ) ; \n const int8_t * filter = ff_hevc_qpel_filters [ my - 1 ] ; \n int shift = 14 + 1 - BIT_DEPTH ; \n int log2Wd = denom + shift - 1 ; \n ox0 = ox0 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n ox1 = ox1 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) \n dst [ x ] = av_clip_pixel ( ( ( QPEL_FILTER ( src , srcstride ) >> ( BIT_DEPTH - 8 ) ) * wx1 + src2 [ x ] * wx0 + \n ( ( ox0 + ox1 + 1 ) << log2Wd ) ) >> ( log2Wd + 1 ) ) ; \n src += srcstride ; \n dst += dststride ; \n src2 += MAX_PB_SIZE ; \n } \n }", "idx": 20591}
{"project": "FFmpeg", "commit_id": "b9589f5a770ec2357ab7920a5fabe8510b8601f9", "target": 0, "func": "static void apply_param_change ( AVCodecContext * avctx , AVPacket * avpkt ) \n { \n int size = 0 ; \n const uint8_t * data ; \n uint32_t flags ; \n if ( ! ( avctx -> codec -> capabilities & CODEC_CAP_PARAM_CHANGE ) ) \n return ; \n data = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PARAM_CHANGE , & size ) ; \n if ( ! data || size < 4 ) \n return ; \n flags = bytestream_get_le32 ( & data ) ; \n size -= 4 ; \n if ( size < 4 ) \n return ; \n if ( flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT ) { \n avctx -> channels = bytestream_get_le32 ( & data ) ; \n size -= 4 ; \n } \n if ( flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT ) { \n if ( size < 8 ) \n return ; \n avctx -> channel_layout = bytestream_get_le64 ( & data ) ; \n size -= 8 ; \n } \n if ( size < 4 ) \n return ; \n if ( flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE ) { \n avctx -> sample_rate = bytestream_get_le32 ( & data ) ; \n size -= 4 ; \n } \n if ( flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS ) { \n if ( size < 8 ) \n return ; \n avctx -> width = bytestream_get_le32 ( & data ) ; \n avctx -> height = bytestream_get_le32 ( & data ) ; \n avcodec_set_dimensions ( avctx , avctx -> width , avctx -> height ) ; \n size -= 8 ; \n } \n }", "idx": 20595}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel8_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_8w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 8 ) ; \n }", "idx": 20615}
{"project": "FFmpeg", "commit_id": "354b757300186ed7a7e36682e8faf5cdc4ad63c1", "target": 0, "func": "static void mxf_read_pixel_layout ( ByteIOContext * pb , MXFDescriptor * descriptor ) \n { \n int code , value , ofs = 0 ; \n char layout [ 16 ] = { } ; \n do { \n code = get_byte ( pb ) ; \n value = get_byte ( pb ) ; \n dprintf ( NULL , \" \\n \" , code ) ; \n if ( ofs < 16 ) { \n layout [ ofs ++ ] = code ; \n layout [ ofs ++ ] = value ; \n } \n } while ( code != 0 ) ; \n ff_mxf_decode_pixel_layout ( layout , & descriptor -> pix_fmt ) ; \n }", "idx": 20619}
{"project": "FFmpeg", "commit_id": "120119225a5363f89822addb472085631d2157bc", "target": 1, "func": "int avfilter_default_query_formats ( AVFilterContext * ctx ) \n { \n enum AVMediaType type = ctx -> inputs [ 0 ] ? ctx -> inputs [ 0 ] -> type : \n ctx -> outputs [ 0 ] ? ctx -> outputs [ 0 ] -> type : \n AVMEDIA_TYPE_VIDEO ; \n avfilter_set_common_formats ( ctx , avfilter_all_formats ( type ) ) ; \n return 0 ; \n }", "idx": 20622}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static void decode_v4_vector ( CinepakEncContext * s , AVPicture * sub_pict , int * v4_vector , strip_info * info ) \n { \n int i , x , y , entry_size = s -> pix_fmt == AV_PIX_FMT_YUV420P ? 6 : 4 ; \n for ( i = y = 0 ; y < 4 ; y += 2 ) { \n for ( x = 0 ; x < 4 ; x += 2 , i ++ ) { \n sub_pict -> data [ 0 ] [ x + y * sub_pict -> linesize [ 0 ] ] = info -> v4_codebook [ v4_vector [ i ] * entry_size ] ; \n sub_pict -> data [ 0 ] [ x + 1 + y * sub_pict -> linesize [ 0 ] ] = info -> v4_codebook [ v4_vector [ i ] * entry_size + 1 ] ; \n sub_pict -> data [ 0 ] [ x + ( y + 1 ) * sub_pict -> linesize [ 0 ] ] = info -> v4_codebook [ v4_vector [ i ] * entry_size + 2 ] ; \n sub_pict -> data [ 0 ] [ x + 1 + ( y + 1 ) * sub_pict -> linesize [ 0 ] ] = info -> v4_codebook [ v4_vector [ i ] * entry_size + 3 ] ; \n if ( s -> pix_fmt == AV_PIX_FMT_YUV420P ) { \n sub_pict -> data [ 1 ] [ ( x >> 1 ) + ( y >> 1 ) * sub_pict -> linesize [ 1 ] ] = info -> v4_codebook [ v4_vector [ i ] * entry_size + 4 ] ; \n sub_pict -> data [ 2 ] [ ( x >> 1 ) + ( y >> 1 ) * sub_pict -> linesize [ 2 ] ] = info -> v4_codebook [ v4_vector [ i ] * entry_size + 5 ] ; \n } \n } \n } \n }", "idx": 20628}
{"project": "FFmpeg", "commit_id": "548459080b1bd698a2e475e5d177b6e7d2538537", "target": 1, "func": "static int fic_decode_block ( FICContext * ctx , GetBitContext * gb , \n uint8_t * dst , int stride , int16_t * block , int * is_p ) \n { \n int i , num_coeff ; \n if ( get_bits1 ( gb ) ) { \n * is_p = 1 ; \n return 0 ; \n } \n memset ( block , 0 , sizeof ( * block ) * 64 ) ; \n num_coeff = get_bits ( gb , 7 ) ; \n if ( num_coeff > 64 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < num_coeff ; i ++ ) \n block [ ff_zigzag_direct [ i ] ] = get_se_golomb ( gb ) * \n ctx -> qmat [ ff_zigzag_direct [ i ] ] ; \n fic_idct_put ( dst , stride , block ) ; \n return 0 ; \n }", "idx": 20630}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuv2yuv1 ) ( int16_t * lumSrc , int16_t * chrSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , long dstW , long chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest != NULL ) \n { \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = lumSrc [ i ] >> 7 ; \n if ( val & 256 ) { \n if ( val < 0 ) val = 0 ; \n else val = 255 ; \n } \n dest [ i ] = val ; \n } \n if ( uDest != NULL ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = chrSrc [ i ] >> 7 ; \n int v = chrSrc [ i + 2048 ] >> 7 ; \n if ( ( u | v ) & 256 ) { \n if ( u < 0 ) u = 0 ; \n else if ( u > 255 ) u = 255 ; \n if ( v < 0 ) v = 0 ; \n else if ( v > 255 ) v = 255 ; \n } \n uDest [ i ] = u ; \n vDest [ i ] = v ; \n } \n #endif \n }", "idx": 20632}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static av_always_inline int normal_limit ( uint8_t * p , ptrdiff_t stride , \n int E , int I ) \n { \n LOAD_PIXELS \n return  simple_limit ( p , stride , E ) && \n FFABS ( p3 - p2 ) <= I && \n FFABS ( p2 - p1 ) <= I && \n FFABS ( p1 - p0 ) <= I && \n FFABS ( q3 - q2 ) <= I && \n FFABS ( q2 - q1 ) <= I && \n FFABS ( q1 - q0 ) <= I ; \n }", "idx": 20635}
{"project": "FFmpeg", "commit_id": "24057c83207d6ea8bfd824155ac37be8a33dfd0c", "target": 0, "func": "static int cmv_process_header ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) \n { \n int pal_start , pal_count , i , ret ; \n if ( buf_end - buf < 16 ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n s -> width = AV_RL16 ( & buf [ 4 ] ) ; \n s -> height = AV_RL16 ( & buf [ 6 ] ) ; \n ret = ff_set_dimensions ( s -> avctx , s -> width , s -> height ) ; \n if ( ret < 0 ) \n return ret ; \n s -> avctx -> time_base . num = 1 ; \n s -> avctx -> time_base . den = AV_RL16 ( & buf [ 10 ] ) ; \n pal_start = AV_RL16 ( & buf [ 12 ] ) ; \n pal_count = AV_RL16 ( & buf [ 14 ] ) ; \n buf += 16 ; \n for ( i = pal_start ; i < pal_start + pal_count && i < AVPALETTE_COUNT && buf_end - buf >= 3 ; i ++ ) { \n s -> palette [ i ] = AV_RB24 ( buf ) ; \n buf += 3 ; \n } \n return 0 ; \n }", "idx": 20636}
{"project": "FFmpeg", "commit_id": "609d5db8035c868be034892a33762779a40ab8b9", "target": 1, "func": "void avformat_free_context ( AVFormatContext * s ) \n { \n int i ; \n if ( ! s ) \n return ; \n av_opt_free ( s ) ; \n if ( s -> iformat && s -> iformat -> priv_class && s -> priv_data ) \n av_opt_free ( s -> priv_data ) ; \n if ( s -> oformat && s -> oformat -> priv_class && s -> priv_data ) \n av_opt_free ( s -> priv_data ) ; \n for ( i = s -> nb_streams - 1 ; i >= 0 ; i -- ) { \n ff_free_stream ( s , s -> streams [ i ] ) ; \n } \n for ( i = s -> nb_programs - 1 ; i >= 0 ; i -- ) { \n av_dict_free ( & s -> programs [ i ] -> metadata ) ; \n av_freep ( & s -> programs [ i ] -> stream_index ) ; \n av_freep ( & s -> programs [ i ] ) ; \n } \n av_freep ( & s -> programs ) ; \n av_freep ( & s -> priv_data ) ; \n while ( s -> nb_chapters -- ) { \n av_dict_free ( & s -> chapters [ s -> nb_chapters ] -> metadata ) ; \n av_freep ( & s -> chapters [ s -> nb_chapters ] ) ; \n } \n av_freep ( & s -> chapters ) ; \n av_dict_free ( & s -> metadata ) ; \n av_freep ( & s -> streams ) ; \n av_freep ( & s -> internal ) ; \n av_free ( s ) ; \n }", "idx": 20637}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_NONE_mips ( struct AACEncContext * s , \n PutBitContext * pb , const float * in , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits ) \n { \n av_assert0 ( 0 ) ; \n return 0 ; \n }", "idx": 20640}
{"project": "FFmpeg", "commit_id": "9dca02ee541120de2a96c387faed9a4e033a60fd", "target": 1, "func": "sigterm_handler ( int sig )  \n { \n received_sigterm = sig ; \n received_nb_signals ++ ; \n term_exit_sigsafe ( ) ; \n if ( received_nb_signals > 3 ) \n exit_program ( 123 ) ; \n }", "idx": 20646}
{"project": "FFmpeg", "commit_id": "d8b33a99897f1faa8036fbdb6a6d48af9c10730f", "target": 1, "func": "static int tta_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n TTAContext * c = s -> priv_data ; \n AVStream * st = s -> streams [ 0 ] ; \n int size , ret ; \n if ( c -> currentframe > c -> totalframes ) \n return -1 ; \n size = st -> index_entries [ c -> currentframe ] . size ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> dts = st -> index_entries [ c -> currentframe ++ ] . timestamp ; \n return ret ; \n }", "idx": 20655}
{"project": "FFmpeg", "commit_id": "687fae2b42f247e537afdb5b8d86e991d3fbb2db", "target": 1, "func": "static void stream_seek ( VideoState * is , int64_t pos , int rel ) \n { \n is -> seek_pos = pos ; \n is -> seek_req = 1 ; \n is -> seek_flags = rel < 0 ? AVSEEK_FLAG_BACKWARD : 0 ; \n }", "idx": 20656}
{"project": "FFmpeg", "commit_id": "f225003d17364cd38fd28f268ae2b29abd8e5024", "target": 1, "func": "static inline void dxt3_block_internal ( uint8_t * dst , ptrdiff_t stride , \n const uint8_t * block ) \n { \n int x , y ; \n uint32_t colors [ 4 ] ; \n uint16_t color0 = AV_RL16 ( block + 8 ) ; \n uint16_t color1 = AV_RL16 ( block + 10 ) ; \n uint32_t code = AV_RL32 ( block + 12 ) ; \n extract_color ( colors , color0 , color1 , 1 , 0 ) ; \n for ( y = 0 ; y < 4 ; y ++ ) { \n const uint16_t alpha_code = AV_RL16 ( block + 2 * y ) ; \n uint8_t alpha_values [ 4 ] ; \n alpha_values [ 0 ] = ( ( alpha_code >> 0 ) & 0x0F ) * 17 ; \n alpha_values [ 1 ] = ( ( alpha_code >> 4 ) & 0x0F ) * 17 ; \n alpha_values [ 2 ] = ( ( alpha_code >> 8 ) & 0x0F ) * 17 ; \n alpha_values [ 3 ] = ( ( alpha_code >> 12 ) & 0x0F ) * 17 ; \n for ( x = 0 ; x < 4 ; x ++ ) { \n uint8_t alpha = alpha_values [ x ] ; \n uint32_t pixel = colors [ code & 3 ] | ( alpha << 24 ) ; \n code >>= 2 ; \n AV_WL32 ( dst + x * 4 , pixel ) ; \n } \n dst += stride ; \n } \n }", "idx": 20666}
{"project": "FFmpeg", "commit_id": "9e73f6d1f9a242ea0b2fdb3bf22890d2a4422be0", "target": 1, "func": "static int find_unused_picture ( MpegEncContext * s , int shared ) \n { \n int i ; \n if ( shared ) { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . f . data [ 0 ] == NULL ) \n return i ; \n } \n } else { \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( pic_is_unused ( s , & s -> picture [ i ] ) ) \n return i ; \n } \n } \n av_log ( s -> avctx , AV_LOG_FATAL , \n \" \\n \" ) ; \n abort ( ) ; \n return -1 ; \n }", "idx": 20668}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc32_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_and_aver_dst_16w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 16 , 1 ) ; \n }", "idx": 20672}
{"project": "FFmpeg", "commit_id": "9ebe6e391071690dbee79a645c51b14bd55c2ff4", "target": 1, "func": "static int read_quant_table ( RangeCoder * c , int16_t * quant_table , int scale ) { \n int v ; \n int i = 0 ; \n uint8_t state [ CONTEXT_SIZE ] ; \n memset ( state , 128 , sizeof ( state ) ) ; \n for ( v = 0 ; i < 128 ; v ++ ) { \n int len = get_symbol ( c , state , 0 ) + 1 ; \n if ( len + i > 128 ) return -1 ; \n while ( len -- ) { \n quant_table [ i ] = scale * v ; \n i ++ ; \n } \n } \n for ( i = 1 ; i < 128 ; i ++ ) { \n quant_table [ 256 - i ] = - quant_table [ i ] ; \n } \n quant_table [ 128 ] = - quant_table [ 127 ] ; \n return 2 * v - 1 ; \n }", "idx": 20678}
{"project": "FFmpeg", "commit_id": "ddaf33f5bba59f013a4191a4b22ba83c420cce38", "target": 0, "func": "static int parse_read_intervals ( const char * intervals_spec ) \n { \n int ret , n , i ; \n char * p , * spec = av_strdup ( intervals_spec ) ; \n if ( ! spec ) \n return AVERROR ( ENOMEM ) ; \n for ( n = 0 , p = spec ; * p ; p ++ ) \n if ( * p == ' ' ) \n n ++ ; \n n ++ ; \n read_intervals = av_malloc ( n * sizeof ( * read_intervals ) ) ; \n if ( ! read_intervals ) { \n ret = AVERROR ( ENOMEM ) ; \n goto end ; \n } \n read_intervals_nb = n ; \n p = spec ; \n for ( i = 0 ; i < n ; i ++ ) { \n char * next = strchr ( p , ' ' ) ; \n if ( next ) \n * next ++ = 0 ; \n read_intervals [ i ] . id = i ; \n ret = parse_read_interval ( p , & read_intervals [ i ] ) ; \n if ( ret < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , \n i , p ) ; \n goto end ; \n } \n av_log ( NULL , AV_LOG_VERBOSE , \" \" ) ; \n log_read_interval ( & read_intervals [ i ] , NULL , AV_LOG_VERBOSE ) ; \n p = next ; \n av_assert0 ( i <= read_intervals_nb ) ; \n } \n av_assert0 ( i == read_intervals_nb ) ; \n end : \n av_free ( spec ) ; \n return ret ; \n }", "idx": 20679}
{"project": "FFmpeg", "commit_id": "86e574928536ee5249d9cf4da9f5d8714611d706", "target": 0, "func": "static char * var_read_string ( AVIOContext * pb , int size ) \n { \n int n ; \n char * str = av_malloc ( size + 1 ) ; \n if ( ! str ) \n return NULL ; \n n = avio_get_str ( pb , size , str , size + 1 ) ; \n if ( n < size ) \n avio_skip ( pb , size - n ) ; \n return str ; \n }", "idx": 20687}
{"project": "FFmpeg", "commit_id": "6c2dbff7f08ccbf69adb23ada48bb36ba796e772", "target": 0, "func": "static char * ctime1 ( char * buf2 , int buf_size ) \n { \n time_t ti ; \n char * p ; \n ti = time ( NULL ) ; \n p = ctime ( & ti ) ; \n av_strlcpy ( buf2 , p , buf_size ) ; \n p = buf2 + strlen ( p ) - 1 ; \n if ( * p == ' \\n ' ) \n * p = ' \\0 ' ; \n return buf2 ; \n }", "idx": 20688}
{"project": "FFmpeg", "commit_id": "cdc48860a8cbb0080acc0732b2e1c689cea03777", "target": 1, "func": "static int execute_decode_slices ( H264Context * h , int context_count ) \n { \n MpegEncContext * const s = & h -> s ; \n AVCodecContext * const avctx = s -> avctx ; \n H264Context * hx ; \n int i ; \n if ( s -> avctx -> hwaccel || \n s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) \n return 0 ; \n if ( context_count == 1 ) { \n return decode_slice ( avctx , & h ) ; \n } else { \n for ( i = 1 ; i < context_count ; i ++ ) { \n hx = h -> thread_context [ i ] ; \n hx -> s . err_recognition = avctx -> err_recognition ; \n hx -> s . error_count = 0 ; \n hx -> x264_build = h -> x264_build ; \n } \n avctx -> execute ( avctx , decode_slice , h -> thread_context , \n NULL , context_count , sizeof ( void * ) ) ; \n hx = h -> thread_context [ context_count - 1 ] ; \n s -> mb_x = hx -> s . mb_x ; \n s -> mb_y = hx -> s . mb_y ; \n s -> droppable = hx -> s . droppable ; \n s -> picture_structure = hx -> s . picture_structure ; \n for ( i = 1 ; i < context_count ; i ++ ) \n h -> s . error_count += h -> thread_context [ i ] -> s . error_count ; \n } \n return 0 ; \n }", "idx": 20706}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static void encode_subband ( SnowContext * s , SubBand * b , DWTELEM * src , DWTELEM * parent , int stride , int orientation ) { \n encode_subband_c0run ( s , b , src , parent , stride , orientation ) ; \n }", "idx": 20708}
{"project": "FFmpeg", "commit_id": "378a5b9c5f1a8b51dee3b954713d18f330fbb027", "target": 0, "func": "static int ffm_write_write_index ( int fd , int64_t pos ) \n { \n uint8_t buf [ 8 ] ; \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) \n buf [ i ] = ( pos >> ( 56 - i * 8 ) ) & 0xff ; \n lseek ( fd , 8 , SEEK_SET ) ; \n if ( write ( fd , buf , 8 ) != 8 ) \n return AVERROR ( EIO ) ; \n return 8 ; \n }", "idx": 20754}
{"project": "FFmpeg", "commit_id": "33684b9c12b74c0140fb91e8150263db4a48d55e", "target": 0, "func": "static int atrac1_decode_frame ( AVCodecContext * avctx , void * data , \n int * data_size , AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AT1Ctx * q = avctx -> priv_data ; \n int ch , ret , i ; \n GetBitContext gb ; \n float * samples = data ; \n if ( buf_size < 212 * q -> channels ) { \n av_log ( q , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( ch = 0 ; ch < q -> channels ; ch ++ ) { \n AT1SUCtx * su = & q -> SUs [ ch ] ; \n init_get_bits ( & gb , & buf [ 212 * ch ] , 212 * 8 ) ; \n ret = at1_parse_bsm ( & gb , su -> log2_block_count ) ; \n if ( ret < 0 ) \n return ret ; \n ret = at1_unpack_dequant ( & gb , su , q -> spec ) ; \n if ( ret < 0 ) \n return ret ; \n ret = at1_imdct_block ( su , q ) ; \n if ( ret < 0 ) \n return ret ; \n at1_subband_synthesis ( q , su , q -> out_samples [ ch ] ) ; \n } \n if ( q -> channels == 1 ) { \n memcpy ( samples , q -> out_samples [ 0 ] , AT1_SU_SAMPLES * 4 ) ; \n } else { \n for ( i = 0 ; i < AT1_SU_SAMPLES ; i ++ ) { \n samples [ i * 2 ] = q -> out_samples [ 0 ] [ i ] ; \n samples [ i * 2 + 1 ] = q -> out_samples [ 1 ] [ i ] ; \n } \n } \n * data_size = q -> channels * AT1_SU_SAMPLES * sizeof ( * samples ) ; \n return avctx -> block_align ; \n }", "idx": 20757}
{"project": "FFmpeg", "commit_id": "53ea595eec984e3109310e8bb7ff4b5786d91057", "target": 1, "func": "static inline int mov_stsc_index_valid ( int index , int count ) \n { \n return index + 1 < count ; \n }", "idx": 20765}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void fft_test ( AC3MDCTContext * mdct , AVLFG * lfg ) \n { \n IComplex in [ FN ] , in1 [ FN ] ; \n int k , n , i ; \n float sum_re , sum_im , a ; \n for ( i = 0 ; i < FN ; i ++ ) { \n in [ i ] . re = av_lfg_get ( lfg ) % 65535 - 32767 ; \n in [ i ] . im = av_lfg_get ( lfg ) % 65535 - 32767 ; \n in1 [ i ] = in [ i ] ; \n } \n fft ( mdct , in , 7 ) ; \n for ( k = 0 ; k < FN ; k ++ ) { \n sum_re = 0 ; \n sum_im = 0 ; \n for ( n = 0 ; n < FN ; n ++ ) { \n a = -2 * M_PI * ( n * k ) / FN ; \n sum_re += in1 [ n ] . re * cos ( a ) - in1 [ n ] . im * sin ( a ) ; \n sum_im += in1 [ n ] . re * sin ( a ) + in1 [ n ] . im * cos ( a ) ; \n } \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , \n k , in [ k ] . re , in [ k ] . im , sum_re / FN , sum_im / FN ) ; \n } \n }", "idx": 20775}
{"project": "FFmpeg", "commit_id": "b5bfb9f9de911846c43b52a7469b3cb413055492", "target": 0, "func": "static void correlate_slice_buffered ( SnowContext * s , slice_buffer * sb , SubBand * b , DWTELEM * src , int stride , int inverse , int use_median , int start_y , int end_y ) { \n const int w = b -> width ; \n int x , y ; \n DWTELEM * line ; \n DWTELEM * prev ; \n if ( start_y != 0 ) \n line = slice_buffer_get_line ( sb , ( ( start_y - 1 ) * b -> stride_line ) + b -> buf_y_offset ) + b -> buf_x_offset ; \n for ( y = start_y ; y < end_y ; y ++ ) { \n prev = line ; \n line = slice_buffer_get_line ( sb , ( y * b -> stride_line ) + b -> buf_y_offset ) + b -> buf_x_offset ; \n for ( x = 0 ; x < w ; x ++ ) { \n if ( x ) { \n if ( use_median ) { \n if ( y && x + 1 < w ) line [ x ] += mid_pred ( line [ x - 1 ] , prev [ x ] , prev [ x + 1 ] ) ; \n else line [ x ] += line [ x - 1 ] ; \n } else { \n if ( y ) line [ x ] += mid_pred ( line [ x - 1 ] , prev [ x ] , line [ x - 1 ] + prev [ x ] - prev [ x - 1 ] ) ; \n else line [ x ] += line [ x - 1 ] ; \n } \n } else { \n if ( y ) line [ x ] += prev [ x ] ; \n } \n } \n } \n }", "idx": 20776}
{"project": "FFmpeg", "commit_id": "fd88a257015f183f5ec3bff393a2f6cf7c117c02", "target": 0, "func": "static void rv34_idct_add_c ( uint8_t * dst , ptrdiff_t stride , DCTELEM * block ) { \n int temp [ 16 ] ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i ; \n rv34_row_transform ( temp , block ) ; \n memset ( block , 0 , 16 * sizeof ( DCTELEM ) ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = 13 * ( temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ) + 0x200 ; \n const int z1 = 13 * ( temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ) + 0x200 ; \n const int z2 = 7 * temp [ 4 * 1 + i ] - 17 * temp [ 4 * 3 + i ] ; \n const int z3 = 17 * temp [ 4 * 1 + i ] + 7 * temp [ 4 * 3 + i ] ; \n dst [ 0 ] = cm [ dst [ 0 ] + ( ( z0 + z3 ) >> 10 ) ] ; \n dst [ 1 ] = cm [ dst [ 1 ] + ( ( z1 + z2 ) >> 10 ) ] ; \n dst [ 2 ] = cm [ dst [ 2 ] + ( ( z1 - z2 ) >> 10 ) ] ; \n dst [ 3 ] = cm [ dst [ 3 ] + ( ( z0 - z3 ) >> 10 ) ] ; \n dst += stride ; \n } \n }", "idx": 20778}
{"project": "FFmpeg", "commit_id": "2ffead98ddd384f61cdf6b1cb3f36592f54cd34a", "target": 1, "func": "static av_always_inline void emulated_edge_mc ( uint8_t * buf , const uint8_t * src , \n ptrdiff_t linesize_arg , \n int block_w , int block_h , \n int src_x , int src_y , \n int w , int h , \n emu_edge_core_func * core_fn ) \n { \n int start_y , start_x , end_y , end_x , src_y_add = 0 ; \n int linesize = linesize_arg ; \n if ( ! w || ! h ) \n return ; \n if ( src_y >= h ) { \n src -= src_y * linesize ; \n src_y_add = h - 1 ; \n src_y = h - 1 ; \n } else if ( src_y <= - block_h ) { \n src -= src_y * linesize ; \n src_y_add = 1 - block_h ; \n src_y = 1 - block_h ; \n } \n if ( src_x >= w ) { \n src += w - 1 - src_x ; \n src_x = w - 1 ; \n } else if ( src_x <= - block_w ) { \n src += 1 - block_w - src_x ; \n src_x = 1 - block_w ; \n } \n start_y = FFMAX ( 0 , - src_y ) ; \n start_x = FFMAX ( 0 , - src_x ) ; \n end_y = FFMIN ( block_h , h - src_y ) ; \n end_x = FFMIN ( block_w , w - src_x ) ; \n av_assert2 ( start_x < end_x && block_w > 0 ) ; \n av_assert2 ( start_y < end_y && block_h > 0 ) ; \n src += ( src_y_add + start_y ) * linesize + start_x ; \n buf += start_x ; \n core_fn ( buf , src , linesize , start_y , end_y , \n block_h , start_x , end_x , block_w ) ; \n }", "idx": 20782}
{"project": "FFmpeg", "commit_id": "55db06af64d1acb7c3e304d61e7a1f265139d27a", "target": 0, "func": "const uint8_t * avpriv_find_start_code ( const uint8_t * av_restrict p , \n const uint8_t * end , \n uint32_t * av_restrict state ) \n { \n int i ; \n assert ( p <= end ) ; \n if ( p >= end ) \n return end ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n uint32_t tmp = * state << 8 ; \n * state = tmp + * ( p ++ ) ; \n if ( tmp == 0x100 || p == end ) \n return p ; \n } \n while ( p < end ) { \n if ( p [ -1 ] > 1 ) p += 3 ; \n else if ( p [ -2 ] ) p += 2 ; \n else if ( p [ -3 ] | ( p [ -1 ] - 1 ) ) p ++ ; \n else { \n p ++ ; \n break ; \n } \n } \n p = FFMIN ( p , end ) - 4 ; \n * state = AV_RB32 ( p ) ; \n return p + 4 ; \n }", "idx": 20789}
{"project": "FFmpeg", "commit_id": "7c1835c52a4be2e4e996f83c91a8d5a147b01100", "target": 0, "func": "static int mpeg4video_probe ( AVProbeData * probe_packet ) \n { \n uint32_t temp_buffer = -1 ; \n int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; \n int i ; \n for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { \n temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ; \n if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) \n continue ; \n if ( temp_buffer == VOP_START_CODE ) VOP ++ ; \n else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ; \n else if ( temp_buffer < 0x120 ) VO ++ ; \n else if ( temp_buffer < 0x130 ) VOL ++ ; \n else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) \n && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; \n } \n if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) \n return VOP + VO > 4 ? AVPROBE_SCORE_EXTENSION : AVPROBE_SCORE_EXTENSION / 2 ; \n return 0 ; \n }", "idx": 20825}
{"project": "FFmpeg", "commit_id": "a90de11dba816f57d01cf10b02eaaf90de24d5bb", "target": 1, "func": "void * av_malloc ( unsigned int size ) \n { \n void * ptr = NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  long diff ; \n #endif \n if ( size > ( INT_MAX - 16 ) ) \n return NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  ptr = malloc ( size + 16 ) ; \n if ( ! ptr ) \n return ptr ; \n diff = ( ( - ( long ) ptr - 1 ) & 15 ) + 1 ; \n ptr = ( char * ) ptr + diff ; \n ( ( char * ) ptr ) [ -1 ] = diff ; \n #elif HAVE_POSIX_MEMALIGN  \n  \n  posix_memalign ( & ptr , 16 , size ) ; \n #elif HAVE_MEMALIGN  \n  \n  ptr = memalign ( 16 , size ) ; \n #else \n ptr = malloc ( size ) ; \n #endif \n return ptr ; \n }", "idx": 20833}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static inline int l2_unscale_group ( int steps , int mant , int scale_factor ) \n { \n int shift , mod , val ; \n shift = scale_factor_modshift [ scale_factor ] ; \n mod = shift & 3 ; \n shift >>= 2 ; \n val = ( 2 * ( mant - ( steps >> 1 ) ) ) * scale_factor_mult2 [ steps >> 2 ] [ mod ] ; \n return ( val + ( 1 << ( shift - 1 ) ) ) >> shift ; \n }", "idx": 20842}
{"project": "FFmpeg", "commit_id": "ce81e47c911fcff4f006b3b14b40a396eaa77696", "target": 1, "func": "static void arith2_normalise ( ArithCoder * c ) \n { \n while ( ( c -> high >> 15 ) - ( c -> low >> 15 ) < 2 ) { \n if ( ( c -> low ^ c -> high ) & 0x10000 ) { \n c -> high ^= 0x8000 ; \n c -> value ^= 0x8000 ; \n c -> low ^= 0x8000 ; \n } \n c -> high = c -> high << 8 & 0xFFFFFF | 0xFF ; \n c -> value = c -> value << 8 & 0xFFFFFF | bytestream2_get_byte ( c -> gbc . gB ) ; \n c -> low = c -> low << 8 & 0xFFFFFF ; \n } \n }", "idx": 20845}
{"project": "FFmpeg", "commit_id": "71da0a5c9750e9fd0c9609470f610d32952923eb", "target": 1, "func": "void ff_eval_coefs ( int * coefs , const int * refl ) \n { \n int buffer [ LPC_ORDER ] ; \n int * b1 = buffer ; \n int * b2 = coefs ; \n int i , j ; \n for ( i = 0 ; i < LPC_ORDER ; i ++ ) { \n b1 [ i ] = refl [ i ] * 16 ; \n for ( j = 0 ; j < i ; j ++ ) \n b1 [ j ] = ( ( refl [ i ] * b2 [ i - j - 1 ] ) >> 12 ) + b2 [ j ] ; \n FFSWAP ( int * , b1 , b2 ) ; \n } \n for ( i = 0 ; i < LPC_ORDER ; i ++ ) \n coefs [ i ] >>= 4 ; \n }", "idx": 20847}
{"project": "FFmpeg", "commit_id": "49e5dcbce5f9e08ec375fd54c413148beb81f1d7", "target": 1, "func": "static int ff_h261_resync ( H261Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int left , ret ; \n if ( show_bits ( & s -> gb , 15 ) == 0 ) { \n ret = h261_decode_gob_header ( h ) ; \n if ( ret >= 0 ) \n return 0 ; \n } \n s -> gb = s -> last_resync_gb ; \n align_get_bits ( & s -> gb ) ; \n left = s -> gb . size_in_bits - get_bits_count ( & s -> gb ) ; \n for ( ; left > 15 + 1 + 4 + 5 ; left -= 8 ) { \n if ( show_bits ( & s -> gb , 15 ) == 0 ) { \n GetBitContext bak = s -> gb ; \n ret = h261_decode_gob_header ( h ) ; \n if ( ret >= 0 ) \n return 0 ; \n s -> gb = bak ; \n } \n skip_bits ( & s -> gb , 8 ) ; \n } \n return -1 ; \n }", "idx": 20849}
{"project": "FFmpeg", "commit_id": "6c4b87d3d6ae08a6da16b4616626b4d2a726afbf", "target": 0, "func": "static int thp_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n ThpDemuxContext * thp = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n unsigned int size ; \n int ret ; \n if ( thp -> audiosize == 0 ) { \n if ( thp -> frame >= thp -> framecnt ) \n return AVERROR_EOF ; \n avio_seek ( pb , thp -> next_frame , SEEK_SET ) ; \n thp -> next_frame += thp -> next_framesz ; \n thp -> next_framesz = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n size = avio_rb32 ( pb ) ; \n if ( thp -> has_audio ) \n thp -> audiosize = avio_rb32 ( pb ) ; \n else \n thp -> frame ++ ; \n ret = av_get_packet ( pb , pkt , size ) ; \n if ( ret != size ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n pkt -> stream_index = thp -> video_stream_index ; \n } else { \n ret = av_get_packet ( pb , pkt , thp -> audiosize ) ; \n if ( ret != thp -> audiosize ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n pkt -> stream_index = thp -> audio_stream_index ; \n if ( thp -> audiosize >= 8 ) \n pkt -> duration = AV_RB32 ( & pkt -> data [ 4 ] ) ; \n thp -> audiosize = 0 ; \n thp -> frame ++ ; \n } \n return 0 ; \n }", "idx": 20852}
{"project": "FFmpeg", "commit_id": "60991ad6ae61e131085891c37e8e517b5014ce21", "target": 1, "func": "static int alloc_buffer ( AVCodecContext * s , InputStream * ist , FrameBuffer * * pbuf ) \n { \n FrameBuffer * buf = av_mallocz ( sizeof ( * buf ) ) ; \n int i , ret ; \n const int pixel_size = av_pix_fmt_descriptors [ s -> pix_fmt ] . comp [ 0 ] . step_minus1 + 1 ; \n int h_chroma_shift , v_chroma_shift ; \n int edge = 32 ; \n int w = s -> width , h = s -> height ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ! ( s -> flags & CODEC_FLAG_EMU_EDGE ) ) { \n w += 2 * edge ; \n h += 2 * edge ; \n } \n avcodec_align_dimensions ( s , & w , & h ) ; \n if ( ( ret = av_image_alloc ( buf -> base , buf -> linesize , w , h , \n s -> pix_fmt , 32 ) ) < 0 ) { \n av_freep ( & buf ) ; \n return ret ; \n } \n memset ( buf -> base [ 0 ] , 128 , ret ) ; \n avcodec_get_chroma_sub_sample ( s -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n const int h_shift = i == 0 ? 0 : h_chroma_shift ; \n const int v_shift = i == 0 ? 0 : v_chroma_shift ; \n if ( s -> flags & CODEC_FLAG_EMU_EDGE ) \n buf -> data [ i ] = buf -> base [ i ] ; \n else \n buf -> data [ i ] = buf -> base [ i ] + \n FFALIGN ( ( buf -> linesize [ i ] * edge >> v_shift ) + \n ( pixel_size * edge >> h_shift ) , 32 ) ; \n } \n buf -> w = s -> width ; \n buf -> h = s -> height ; \n buf -> pix_fmt = s -> pix_fmt ; \n buf -> ist = ist ; \n * pbuf = buf ; \n return 0 ; \n }", "idx": 20858}
{"project": "FFmpeg", "commit_id": "1f6d0d42c53cde5e33e92c4529b774c256157f89", "target": 1, "func": "static int nsv_read_close ( AVFormatContext * s ) \n { \n NSVContext * nsv = s -> priv_data ; \n av_freep ( & nsv -> nsvs_file_offset ) ; \n av_freep ( & nsv -> nsvs_timestamps ) ; \n #if 0  \n  \n  \n  \n  for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n NSVStream * ast = st -> priv_data ; \n if ( ast ) { \n av_free ( ast -> index_entries ) ; \n av_free ( ast ) ; \n } \n av_free ( st -> codec -> palctrl ) ; \n } \n #endif \n return 0 ; \n }", "idx": 20864}
{"project": "FFmpeg", "commit_id": "daca33659d12fd85062bc1798f4eb7ffeb83cc3c", "target": 1, "func": "static void assert_codec_experimental ( AVCodecContext * c , int encoder ) \n { \n const char * codec_string = encoder ? \" \" : \" \" ; \n AVCodec * codec ; \n if ( c -> codec -> capabilities & CODEC_CAP_EXPERIMENTAL && \n c -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL ) { \n av_log ( NULL , AV_LOG_ERROR , \" \" \n \" \\n \\n \" , \n codec_string , c -> codec -> name ) ; \n codec = encoder ? avcodec_find_encoder ( codec -> id ) : avcodec_find_decoder ( codec -> id ) ; \n if ( ! ( codec -> capabilities & CODEC_CAP_EXPERIMENTAL ) ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , \n codec_string , codec -> name ) ; \n ffmpeg_exit ( 1 ) ; \n } \n }", "idx": 20866}
{"project": "FFmpeg", "commit_id": "c54eef46f990722ed65fd1ad1da3d0fc50806eb5", "target": 1, "func": "int av_grow_packet ( AVPacket * pkt , int grow_by ) \n { \n int new_size ; \n av_assert0 ( ( unsigned ) pkt -> size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ( unsigned ) grow_by > \n INT_MAX - ( pkt -> size + AV_INPUT_BUFFER_PADDING_SIZE ) ) \n return -1 ; \n new_size = pkt -> size + grow_by + AV_INPUT_BUFFER_PADDING_SIZE ; \n if ( pkt -> buf ) { \n size_t data_offset ; \n uint8_t * old_data = pkt -> data ; \n if ( pkt -> data == NULL ) { \n data_offset = 0 ; \n pkt -> data = pkt -> buf -> data ; \n } else { \n data_offset = pkt -> data - pkt -> buf -> data ; \n if ( data_offset > INT_MAX - new_size ) \n return -1 ; \n } \n if ( new_size + data_offset > pkt -> buf -> size ) { \n int ret = av_buffer_realloc ( & pkt -> buf , new_size + data_offset ) ; \n if ( ret < 0 ) { \n pkt -> data = old_data ; \n return ret ; \n } \n pkt -> data = pkt -> buf -> data + data_offset ; \n } \n } else { \n pkt -> buf = av_buffer_alloc ( new_size ) ; \n if ( ! pkt -> buf ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( pkt -> buf -> data , pkt -> data , pkt -> size ) ; \n pkt -> data = pkt -> buf -> data ; \n } \n pkt -> size += grow_by ; \n memset ( pkt -> data + pkt -> size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; \n return 0 ; \n }", "idx": 20873}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void get_pixels_altivec ( int16_t * restrict block , const uint8_t * pixels , \n ptrdiff_t line_size ) \n { \n int i ; \n vec_u8 perm = vec_lvsl ( 0 , pixels ) ; \n const vec_u8 zero = ( const vec_u8 ) vec_splat_u8 ( 0 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n vec_u8 pixl = vec_ld ( 0 , pixels ) ; \n vec_u8 pixr = vec_ld ( 7 , pixels ) ; \n vec_u8 bytes = vec_perm ( pixl , pixr , perm ) ; \n vec_s16 shorts = ( vec_s16 ) vec_mergeh ( zero , bytes ) ; \n vec_st ( shorts , i * 16 , ( vec_s16 * ) block ) ; \n pixels += line_size ; \n } \n }", "idx": 20880}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "int avpriv_snprintf ( char * restrict s , size_t n , const char * restrict fmt , ... ) \n { \n va_list ap ; \n int ret ; \n va_start ( ap , fmt ) ; \n ret = avpriv_vsnprintf ( s , n , fmt , ap ) ; \n va_end ( ap ) ; \n return ret ; \n }", "idx": 20889}
{"project": "FFmpeg", "commit_id": "5569146d48f06564e8fa393424782cceed510916", "target": 0, "func": "int avpriv_adx_decode_header ( AVCodecContext * avctx , const uint8_t * buf , \n int bufsize , int * header_size , int * coeff ) \n { \n int offset , cutoff ; \n if ( bufsize < 24 ) \n return AVERROR_INVALIDDATA ; \n if ( AV_RB16 ( buf ) != 0x8000 ) \n return AVERROR_INVALIDDATA ; \n offset = AV_RB16 ( buf + 2 ) + 4 ; \n if ( bufsize >= offset && memcmp ( buf + offset - 6 , \" \" , 6 ) ) \n return AVERROR_INVALIDDATA ; \n if ( buf [ 4 ] != 3 || buf [ 5 ] != 18 || buf [ 6 ] != 4 ) { \n avpriv_request_sample ( avctx , \" \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n avctx -> channels = buf [ 7 ] ; \n if ( avctx -> channels <= 0 || avctx -> channels > 2 ) \n return AVERROR_INVALIDDATA ; \n avctx -> sample_rate = AV_RB32 ( buf + 8 ) ; \n if ( avctx -> sample_rate < 1 || \n avctx -> sample_rate > INT_MAX / ( avctx -> channels * BLOCK_SIZE * 8 ) ) \n return AVERROR_INVALIDDATA ; \n avctx -> bit_rate = avctx -> sample_rate * avctx -> channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES ; \n if ( coeff ) { \n cutoff = AV_RB16 ( buf + 16 ) ; \n ff_adx_calculate_coeffs ( cutoff , avctx -> sample_rate , COEFF_BITS , coeff ) ; \n } \n * header_size = offset ; \n return 0 ; \n }", "idx": 20892}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_proresdsp_x86_init ( ProresDSPContext * dsp ) \n { \n #if ARCH_X86_64 && HAVE_YASM  \n  \n  int flags = av_get_cpu_flags ( ) ; \n if ( flags & AV_CPU_FLAG_SSE2 ) { \n dsp -> idct_permutation_type = FF_TRANSPOSE_IDCT_PERM ; \n dsp -> idct_put = ff_prores_idct_put_10_sse2 ; \n } \n if ( flags & AV_CPU_FLAG_SSE4 ) { \n dsp -> idct_permutation_type = FF_TRANSPOSE_IDCT_PERM ; \n dsp -> idct_put = ff_prores_idct_put_10_sse4 ; \n } \n #if HAVE_AVX  \n  \n  if ( flags & AV_CPU_FLAG_AVX ) { \n dsp -> idct_permutation_type = FF_TRANSPOSE_IDCT_PERM ; \n dsp -> idct_put = ff_prores_idct_put_10_avx ; \n } \n #endif \n #endif \n }", "idx": 20932}
{"project": "FFmpeg", "commit_id": "63edd2f98994bb6d4ca3a70c14fb93d177feea2c", "target": 0, "func": "static void print_all_libs_info ( int flags , int level ) \n { \n PRINT_LIB_INFO ( avutil , AVUTIL , flags , level ) ; \n PRINT_LIB_INFO ( avcodec , AVCODEC , flags , level ) ; \n PRINT_LIB_INFO ( avformat , AVFORMAT , flags , level ) ; \n PRINT_LIB_INFO ( avdevice , AVDEVICE , flags , level ) ; \n PRINT_LIB_INFO ( avfilter , AVFILTER , flags , level ) ; \n PRINT_LIB_INFO ( avresample , AVRESAMPLE , flags , level ) ; \n PRINT_LIB_INFO ( swscale , SWSCALE , flags , level ) ; \n PRINT_LIB_INFO ( swresample , SWRESAMPLE , flags , level ) ; \n #if CONFIG_POSTPROC  \n  \n  PRINT_LIB_INFO ( postproc , POSTPROC , flags , level ) ; \n #endif \n }", "idx": 20943}
{"project": "FFmpeg", "commit_id": "c661cb6672af5ebcb900ec8766b24761bd2ab011", "target": 0, "func": "static int match_group_separator ( const OptionGroupDef * groups , const char * opt ) \n { \n const OptionGroupDef * p = groups ; \n while ( p -> name ) { \n if ( p -> sep && ! strcmp ( p -> sep , opt ) ) \n return p - groups ; \n p ++ ; \n } \n return -1 ; \n }", "idx": 20959}
{"project": "FFmpeg", "commit_id": "ca4544409e32d692504b44e4ae804c3538993904", "target": 0, "func": "get_pointer_coordinates ( int * x , int * y , Display * dpy , AVFormatContext * s1 )  \n { \n Window mrootwindow , childwindow ; \n int dummy ; \n mrootwindow = DefaultRootWindow ( dpy ) ; \n if ( XQueryPointer ( dpy , mrootwindow , & mrootwindow , & childwindow , \n x , y , & dummy , & dummy , ( unsigned int * ) & dummy ) ) { \n } else { \n av_log ( s1 , AV_LOG_INFO , \" \\n \" ) ; \n * x = -1 ; \n * y = -1 ; \n } \n }", "idx": 21003}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init ( PixblockDSPContext * c , AVCodecContext * avctx ) \n { \n const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; \n c -> diff_pixels = diff_pixels_c ; \n switch ( avctx -> bits_per_raw_sample ) { \n case 9 : \n case 10 : \n case 12 : \n case 14 : \n c -> get_pixels = get_pixels_16_c ; \n break ; \n default : \n if ( avctx -> bits_per_raw_sample <= 8 || avctx -> codec_type != AVMEDIA_TYPE_VIDEO ) { \n c -> get_pixels = get_pixels_8_c ; \n } \n break ; \n } \n if ( ARCH_ALPHA ) \n ff_pixblockdsp_init_alpha ( c , avctx , high_bit_depth ) ; \n if ( ARCH_ARM ) \n ff_pixblockdsp_init_arm ( c , avctx , high_bit_depth ) ; \n if ( ARCH_PPC ) \n ff_pixblockdsp_init_ppc ( c , avctx , high_bit_depth ) ; \n if ( ARCH_X86 ) \n ff_pixblockdsp_init_x86 ( c , avctx , high_bit_depth ) ; \n if ( ARCH_MIPS ) \n ff_pixblockdsp_init_mips ( c , avctx , high_bit_depth ) ; \n }", "idx": 21005}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static int poll_frame ( AVFilterLink * link ) \n { \n AVFilterContext * s = link -> src ; \n OverlayContext * over = s -> priv ; \n int ret = avfilter_poll_frame ( s -> inputs [ OVERLAY ] ) ; \n if ( ret == AVERROR_EOF ) \n ret = ! ! over -> overpicref ; \n return ret && avfilter_poll_frame ( s -> inputs [ MAIN ] ) ; \n }", "idx": 21013}
{"project": "FFmpeg", "commit_id": "282bb02839b1ce73963c8e3ee46804f1ade8b12a", "target": 1, "func": "static int get_qcx ( J2kDecoderContext * s , int n , J2kQuantStyle * q ) \n { \n int i , x ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR ( EINVAL ) ; \n x = bytestream_get_byte ( & s -> buf ) ; \n q -> nguardbits = x >> 5 ; \n q -> quantsty = x & 0x1f ; \n if ( q -> quantsty == J2K_QSTY_NONE ) { \n n -= 3 ; \n if ( s -> buf_end - s -> buf < n ) \n return AVERROR ( EINVAL ) ; \n for ( i = 0 ; i < n ; i ++ ) \n q -> expn [ i ] = bytestream_get_byte ( & s -> buf ) >> 3 ; \n } else if ( q -> quantsty == J2K_QSTY_SI ) { \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR ( EINVAL ) ; \n x = bytestream_get_be16 ( & s -> buf ) ; \n q -> expn [ 0 ] = x >> 11 ; \n q -> mant [ 0 ] = x & 0x7ff ; \n for ( i = 1 ; i < 32 * 3 ; i ++ ) { \n int curexpn = FFMAX ( 0 , q -> expn [ 0 ] - ( i - 1 ) / 3 ) ; \n q -> expn [ i ] = curexpn ; \n q -> mant [ i ] = q -> mant [ 0 ] ; \n } \n } else { \n n = ( n - 3 ) >> 1 ; \n if ( s -> buf_end - s -> buf < n ) \n return AVERROR ( EINVAL ) ; \n for ( i = 0 ; i < n ; i ++ ) { \n x = bytestream_get_be16 ( & s -> buf ) ; \n q -> expn [ i ] = x >> 11 ; \n q -> mant [ i ] = x & 0x7ff ; \n } \n } \n return 0 ; \n }", "idx": 21016}
{"project": "FFmpeg", "commit_id": "b1a4b735f9b03840803413cb725216d15d5213a7", "target": 1, "func": "yuv2plane1_16_c_template ( const int32_t *  src , uint16_t * dest , int dstW , \n int big_endian , int output_bits ) \n { \n int i ; \n int shift = 19 - output_bits ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = src [ i ] + ( 1 << ( shift - 1 ) ) ; \n output_pixel ( & dest [ i ] , val , 0 , uint ) ; \n } \n }", "idx": 21018}
{"project": "FFmpeg", "commit_id": "f1d8763a02b5fce9a7d9789e049d74a45b15e1e8", "target": 1, "func": "void ff_update_duplicate_context ( MpegEncContext * dst , MpegEncContext * src ) \n { \n MpegEncContext bak ; \n int i ; \n backup_duplicate_context ( & bak , dst ) ; \n memcpy ( dst , src , sizeof ( MpegEncContext ) ) ; \n backup_duplicate_context ( dst , & bak ) ; \n for ( i = 0 ; i < 12 ; i ++ ) { \n dst -> pblocks [ i ] = & dst -> block [ i ] ; \n } \n }", "idx": 21019}
{"project": "FFmpeg", "commit_id": "948b54763b6c851b2a0bec6702cd9c419065fdb6", "target": 1, "func": "static uint32_t softfloat_mul ( uint32_t x , uint64_t mantissa ) \n { \n uint64_t l = x * ( mantissa & 0xffffffff ) ; \n uint64_t h = x * ( mantissa >> 32 ) ; \n h += l >> 32 ; \n l &= 0xffffffff ; \n l += 1 << av_log2 ( h >> 21 ) ; \n h += l >> 32 ; \n return h >> 20 ; \n }", "idx": 21027}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_compose53i_dy ( dwt_compose_t * cs , DWTELEM * buffer , int width , int height , int stride ) { \n int y = cs -> y ; \n DWTELEM * b0 = cs -> b0 ; \n DWTELEM * b1 = cs -> b1 ; \n DWTELEM * b2 = buffer + mirror ( y + 1 , height - 1 ) * stride ; \n DWTELEM * b3 = buffer + mirror ( y + 2 , height - 1 ) * stride ; \n { START_TIMER \n if ( b1 <= b3 )  vertical_compose53iL0 ( b1 , b2 , b3 , width ) ; \n if ( b0 <= b2 ) vertical_compose53iH0 ( b0 , b1 , b2 , width ) ; \n STOP_TIMER ( \" \" )  } \n { START_TIMER \n if ( y -1 >= 0 )  horizontal_compose53i ( b0 , width ) ; \n if ( b0 <= b2 ) horizontal_compose53i ( b1 , width ) ; \n STOP_TIMER ( \" \" )  } \n cs -> b0 = b2 ; \n cs -> b1 = b3 ; \n cs -> y += 2 ; \n }", "idx": 21031}
{"project": "FFmpeg", "commit_id": "3e0f7126b53b395d9e79df57b2e626eb99ad846b", "target": 1, "func": "static void inner_add_yblock_bw_16_obmc_32_mmx ( const uint8_t * obmc , const long obmc_stride , uint8_t * * block , int b_w , long b_h , \n int src_x , int src_y , long src_stride , slice_buffer * sb , int add , uint8_t * dst8 ) { \n snow_inner_add_yblock_mmx_header \n snow_inner_add_yblock_mmx_start ( \" mm1 \" , \" mm5 \" , \" 3 \" , \" 0 \" , \" 0 \" )  \n snow_inner_add_yblock_mmx_accum ( \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_accum ( \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_accum ( \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_mix ( \" \" , \" \" )  \n snow_inner_add_yblock_mmx_start ( \" \" , \" \" , \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_accum ( \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_accum ( \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_accum ( \" \" , \" \" , \" \" )  \n snow_inner_add_yblock_mmx_mix ( \" \" , \" \" )  \n snow_inner_add_yblock_mmx_end ( \" \" )  \n }", "idx": 21036}
{"project": "FFmpeg", "commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "target": 1, "func": "static void blend_frames16_c ( BLEND_FUNC_PARAMS ) \n { \n int line , pixel ; \n uint16_t * dstw = ( uint16_t * ) dst ; \n uint16_t * src1w = ( uint16_t * ) src1 ; \n uint16_t * src2w = ( uint16_t * ) src2 ; \n width /= 2 ; \n src1_linesize /= 2 ; \n src2_linesize /= 2 ; \n dst_linesize /= 2 ; \n for ( line = 0 ; line < height ; line ++ ) { \n for ( pixel = 0 ; pixel < width ; pixel ++ ) \n dstw [ pixel ] = ( ( src1w [ pixel ] * factor1 ) + ( src2w [ pixel ] * factor2 ) + half ) >> shift ; \n src1w += src1_linesize ; \n src2w += src2_linesize ; \n dstw += dst_linesize ; \n } \n }", "idx": 21038}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int cinepak_encode_frame ( AVCodecContext * avctx , unsigned char * buf , int buf_size , void * data ) \n { \n CinepakEncContext * s = avctx -> priv_data ; \n AVFrame * frame = data ; \n int ret ; \n s -> lambda = frame -> quality ? frame -> quality - 1 : 2 * FF_LAMBDA_SCALE ; \n frame -> key_frame = s -> curframe == 0 ; \n frame -> pict_type = frame -> key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ; \n ret = rd_frame ( s , frame , buf , buf_size ) ; \n FFSWAP ( AVFrame , s -> last_frame , s -> best_frame ) ; \n if ( ++ s -> curframe >= s -> keyint ) \n s -> curframe = 0 ; \n return ret ; \n }", "idx": 21039}
{"project": "FFmpeg", "commit_id": "dce25564cc554cc85c8c28928b1b8d3f965c1b16", "target": 1, "func": "static int mov_read_mdhd ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n int version = get_byte ( pb ) ; \n int lang ; \n if ( version > 1 ) \n return -1 ; \n get_be24 ( pb ) ; \n if ( version == 1 ) { \n get_be64 ( pb ) ; \n get_be64 ( pb ) ; \n } else { \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n } \n sc -> time_scale = get_be32 ( pb ) ; \n st -> duration = ( version == 1 ) ? get_be64 ( pb ) : get_be32 ( pb ) ; \n lang = get_be16 ( pb ) ; \n ff_mov_lang_to_iso639 ( lang , st -> language ) ; \n get_be16 ( pb ) ; \n return 0 ; \n }", "idx": 21041}
{"project": "FFmpeg", "commit_id": "1509c018bd5b054a2354e20021ccbac9c934d213", "target": 1, "func": "static int analyze ( const uint8_t * buf , int size , int packet_size , int * index ) \n { \n int stat [ TS_MAX_PACKET_SIZE ] ; \n int i ; \n int x = 0 ; \n int best_score = 0 ; \n memset ( stat , 0 , packet_size * sizeof ( int ) ) ; \n for ( x = i = 0 ; i < size - 3 ; i ++ ) { \n if ( buf [ i ] == 0x47 && ! ( buf [ i + 1 ] & 0x80 ) && ( buf [ i + 3 ] & 0x30 ) ) { \n stat [ x ] ++ ; \n if ( stat [ x ] > best_score ) { \n best_score = stat [ x ] ; \n if ( index ) \n * index = x ; \n } \n } \n x ++ ; \n if ( x == packet_size ) \n x = 0 ; \n } \n return best_score ; \n }", "idx": 21051}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( chrRangeFromJpeg ) ( int16_t * dst , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n dst [ i ] = ( dst [ i ] * 1799 + 4081085 ) >> 11 ; \n dst [ i + VOFW ] = ( dst [ i + VOFW ] * 1799 + 4081085 ) >> 11 ; \n } \n }", "idx": 21067}
{"project": "FFmpeg", "commit_id": "79a0ec1af4817bb7b989803b9f460d1e4acaf7b7", "target": 1, "func": "AVFilterFormats * avfilter_merge_formats ( AVFilterFormats * a , AVFilterFormats * b ) \n { \n AVFilterFormats * ret ; \n unsigned i , j , k = 0 ; \n ret = av_mallocz ( sizeof ( AVFilterFormats ) ) ; \n ret -> formats = av_malloc ( sizeof ( * ret -> formats ) * FFMIN ( a -> format_count , \n b -> format_count ) ) ; \n for ( i = 0 ; i < a -> format_count ; i ++ ) \n for ( j = 0 ; j < b -> format_count ; j ++ ) \n if ( a -> formats [ i ] == b -> formats [ j ] ) \n ret -> formats [ k ++ ] = a -> formats [ i ] ; \n ret -> format_count = k ; \n if ( ! ret -> format_count ) { \n av_free ( ret -> formats ) ; \n av_free ( ret ) ; \n return NULL ; \n } \n ret -> refs = av_malloc ( sizeof ( AVFilterFormats * * ) * ( a -> refcount + b -> refcount ) ) ; \n merge_ref ( ret , a ) ; \n merge_ref ( ret , b ) ; \n return ret ; \n }", "idx": 21073}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static av_always_inline int simple_limit ( uint8_t * p , ptrdiff_t stride , int flim ) \n { \n LOAD_PIXELS \n return  2 * FFABS ( p0 - q0 ) + ( FFABS ( p1 - q1 ) >> 1 ) <= flim ; \n }", "idx": 21075}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_conn_control_block_control ( void * data ) \n { \n FTPContext * s = data ; \n return s -> conn_control_block_flag ; \n }", "idx": 21077}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static int probe_file ( const char * filename ) \n { \n AVFormatContext * fmt_ctx ; \n int ret , i ; \n if ( ( ret = open_input_file ( & fmt_ctx , filename ) ) ) \n return ret ; \n if ( do_show_packets ) \n show_packets ( fmt_ctx ) ; \n if ( do_show_streams ) \n for ( i = 0 ; i < fmt_ctx -> nb_streams ; i ++ ) \n show_stream ( fmt_ctx , i ) ; \n if ( do_show_format ) \n show_format ( fmt_ctx ) ; \n close_input_file ( & fmt_ctx ) ; \n return 0 ; \n }", "idx": 21078}
{"project": "FFmpeg", "commit_id": "668673f10ce225d26a96f1aeb62066e8c641c85a", "target": 1, "func": "static int parse_outputs ( const char * * buf , AVFilterInOut * * curr_inputs , \n AVFilterInOut * * open_inputs , \n AVFilterInOut * * open_outputs , AVClass * log_ctx ) \n { \n int ret , pad = 0 ; \n while ( * * buf == ' ' ) { \n char * name = parse_link_name ( buf , log_ctx ) ; \n AVFilterInOut * match ; \n AVFilterInOut * input = * curr_inputs ; \n * curr_inputs = ( * curr_inputs ) -> next ; \n if ( ! name ) \n match = extract_inout ( name , open_inputs ) ; \n if ( match ) { \n if ( ( ret = link_filter ( input -> filter_ctx , input -> pad_idx , \n match -> filter_ctx , match -> pad_idx , log_ctx ) ) < 0 ) \n return ret ; \n av_free ( match -> name ) ; \n av_free ( name ) ; \n av_free ( match ) ; \n av_free ( input ) ; \n } else { \n input -> name = name ; \n insert_inout ( open_outputs , input ) ; \n * buf += strspn ( * buf , WHITESPACES ) ; \n pad ++ ; \n return pad ;", "idx": 21081}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static int roq_encode_frame ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * frame , int * got_packet ) \n { \n RoqContext * enc = avctx -> priv_data ; \n int size , ret ; \n enc -> avctx = avctx ; \n enc -> frame_to_enc = frame ; \n if ( frame -> quality ) \n enc -> lambda = frame -> quality - 1 ; \n else \n enc -> lambda = 2 * ROQ_LAMBDA_SCALE ; \n size = ( ( enc -> width * enc -> height / 64 ) * 138 + 7 ) / 8 + 256 * ( 6 + 4 ) + 8 ; \n if ( ( ret = ff_alloc_packet ( pkt , size ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , size ) ; \n return ret ; \n } \n enc -> out_buf = pkt -> data ; \n if ( enc -> framesSinceKeyframe == avctx -> gop_size ) \n enc -> framesSinceKeyframe = 0 ; \n if ( enc -> first_frame ) { \n if ( ff_get_buffer ( avctx , enc -> current_frame , 0 ) || \n ff_get_buffer ( avctx , enc -> last_frame , 0 ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n roq_write_video_info_chunk ( enc ) ; \n enc -> first_frame = 0 ; \n } \n roq_encode_video ( enc ) ; \n pkt -> size = enc -> out_buf - pkt -> data ; \n if ( enc -> framesSinceKeyframe == 1 ) \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n * got_packet = 1 ; \n return 0 ; \n }", "idx": 21111}
{"project": "FFmpeg", "commit_id": "cc13bc8c4f0f4afa30d0b94c3f3a369ccd2aaf0b", "target": 0, "func": "static int parse_nal_units ( AVCodecParserContext * s , const uint8_t * buf , \n int buf_size , AVCodecContext * avctx ) \n { \n HEVCParserContext * ctx = s -> priv_data ; \n int ret , i ; \n ret = ff_h2645_packet_split ( & ctx -> pkt , buf , buf_size , avctx , 0 , 0 , \n AV_CODEC_ID_HEVC ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < ctx -> pkt . nb_nals ; i ++ ) { \n H2645NAL * nal = & ctx -> pkt . nals [ i ] ; \n switch ( nal -> type ) { \n case NAL_VPS : ff_hevc_decode_nal_vps ( & nal -> gb , avctx , & ctx -> ps ) ; break ; \n case NAL_SPS : ff_hevc_decode_nal_sps ( & nal -> gb , avctx , & ctx -> ps , 1 ) ; break ; \n case NAL_PPS : ff_hevc_decode_nal_pps ( & nal -> gb , avctx , & ctx -> ps ) ; break ; \n case NAL_TRAIL_R : \n case NAL_TRAIL_N : \n case NAL_TSA_N : \n case NAL_TSA_R : \n case NAL_STSA_N : \n case NAL_STSA_R : \n case NAL_BLA_W_LP : \n case NAL_BLA_W_RADL : \n case NAL_BLA_N_LP : \n case NAL_IDR_W_RADL : \n case NAL_IDR_N_LP : \n case NAL_CRA_NUT : \n case NAL_RADL_N : \n case NAL_RADL_R : \n case NAL_RASL_N : \n case NAL_RASL_R : \n if ( buf == avctx -> extradata ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , nal -> type ) ; \n return AVERROR_INVALIDDATA ; \n } \n hevc_parse_slice_header ( s , nal , avctx ) ; \n break ; \n } \n } \n return 0 ; \n }", "idx": 21113}
{"project": "FFmpeg", "commit_id": "9f6431c8f6c4e92e3f6ea2f3bc8f58677a7e7ce3", "target": 0, "func": "static int get_channel_idx ( char * * map , int * ch , char delim , int max_ch ) \n { \n char * next = split ( * map , delim ) ; \n int len ; \n int n = 0 ; \n if ( ! next && delim == ' ' ) \n return AVERROR ( EINVAL ) ; \n if ( ! * map ) \n return AVERROR ( EINVAL ) ; \n len = strlen ( * map ) ; \n sscanf ( * map , \" \" , ch , & n ) ; \n if ( n != len ) \n return AVERROR ( EINVAL ) ; \n if ( * ch < 0 || * ch > max_ch ) \n return AVERROR ( EINVAL ) ; \n * map = next ; \n return 0 ; \n }", "idx": 21114}
{"project": "FFmpeg", "commit_id": "4a71da0f3ab7f5542decd11c81994f849d5b2c78", "target": 1, "func": "static int decode_residual_block ( AVSContext * h , GetBitContext * gb , \n const struct dec_2dvlc * r , int esc_golomb_order , \n int qp , uint8_t * dst , int stride ) { \n int i , level_code , esc_code , level , run , mask ; \n DCTELEM level_buf [ 65 ] ; \n uint8_t run_buf [ 65 ] ; \n DCTELEM * block = h -> block ; \n for ( i = 0 ; i < 65 ; i ++ ) { \n level_code = get_ue_code ( gb , r -> golomb_order ) ; \n if ( level_code >= ESCAPE_CODE ) { \n run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 ; \n esc_code = get_ue_code ( gb , esc_golomb_order ) ; \n level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ) ; \n while ( level > r -> inc_limit ) \n r ++ ; \n mask = - ( level_code & 1 ) ; \n level = ( level ^ mask ) - mask ; \n } else { \n level = r -> rltab [ level_code ] [ 0 ] ; \n if ( ! level ) \n break ; \n run = r -> rltab [ level_code ] [ 1 ] ; \n r += r -> rltab [ level_code ] [ 2 ] ; \n } \n level_buf [ i ] = level ; \n run_buf [ i ] = run ; \n } \n if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , \n ff_cavs_dequant_shift [ qp ] , i ) ) \n return -1 ; \n h -> cdsp . cavs_idct8_add ( dst , block , stride ) ; \n h -> s . dsp . clear_block ( block ) ; \n return 0 ; \n }", "idx": 21115}
{"project": "FFmpeg", "commit_id": "a8d02f2bc90e8d963f1a95f7a75de520259bb2d2", "target": 1, "func": "static int pcm_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n PCMDecode * s = avctx -> priv_data ; \n int n ; \n short * samples ; \n uint8_t * src ; \n samples = data ; \n src = buf ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_PCM_S16LE : \n n = buf_size >> 1 ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = src [ 0 ] | ( src [ 1 ] << 8 ) ; \n src += 2 ; \n } \n break ; \n case CODEC_ID_PCM_S16BE : \n n = buf_size >> 1 ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = ( src [ 0 ] << 8 ) | src [ 1 ] ; \n src += 2 ; \n } \n break ; \n case CODEC_ID_PCM_U16LE : \n n = buf_size >> 1 ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = ( src [ 0 ] | ( src [ 1 ] << 8 ) ) - 0x8000 ; \n src += 2 ; \n } \n break ; \n case CODEC_ID_PCM_U16BE : \n n = buf_size >> 1 ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = ( ( src [ 0 ] << 8 ) | src [ 1 ] ) - 0x8000 ; \n src += 2 ; \n } \n break ; \n case CODEC_ID_PCM_S8 : \n n = buf_size ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = src [ 0 ] << 8 ; \n src ++ ; \n } \n break ; \n case CODEC_ID_PCM_U8 : \n n = buf_size ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = ( ( int ) src [ 0 ] - 128 ) << 8 ; \n src ++ ; \n } \n break ; \n case CODEC_ID_PCM_ALAW : \n case CODEC_ID_PCM_MULAW : \n n = buf_size ; \n for ( ; n > 0 ; n -- ) { \n * samples ++ = s -> table [ src [ 0 ] ] ; \n src ++ ; \n } \n break ; \n default : \n return -1 ; \n } \n * data_size = ( uint8_t * ) samples - ( uint8_t * ) data ; \n return src - buf ; \n }", "idx": 21119}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "void FUNCC ( ff_h264_idct8_dc_add ) ( uint8_t * _dst , int16_t * block , int stride ) { \n int i , j ; \n int dc = ( ( ( dctcoef * ) block ) [ 0 ] + 32 ) >> 6 ; \n pixel * dst = ( pixel * ) _dst ; \n stride >>= sizeof ( pixel ) - 1 ; \n for ( j = 0 ; j < 8 ; j ++ ) \n { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = av_clip_pixel ( dst [ i ] + dc ) ; \n dst += stride ; \n } \n }", "idx": 21120}
{"project": "FFmpeg", "commit_id": "f57119b8e58cb5437c3ab40d797293ecb9b4a894", "target": 1, "func": "static void truncpasses ( Jpeg2000EncoderContext * s , Jpeg2000Tile * tile ) \n { \n int precno , compno , reslevelno , bandno , cblkno , lev ; \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n Jpeg2000Component * comp = tile -> comp + compno ; \n for ( reslevelno = 0 , lev = codsty -> nreslevels - 1 ; reslevelno < codsty -> nreslevels ; reslevelno ++ , lev -- ) { \n Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { \n int bandpos = bandno + ( reslevelno > 0 ) ; \n Jpeg2000Band * band = reslevel -> band + bandno ; \n Jpeg2000Prec * prec = band -> prec + precno ; \n for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_height * prec -> nb_codeblocks_width ; cblkno ++ ) { \n Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; \n cblk -> ninclpasses = getcut ( cblk , s -> lambda , \n ( int64_t ) dwt_norms [ codsty -> transform == FF_DWT53 ] [ bandpos ] [ lev ] * ( int64_t ) band -> i_stepsize >> 16 ) ; \n } \n } \n } \n } \n } \n }", "idx": 21125}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static int send_extradata ( APNGDemuxContext * ctx , AVPacket * pkt ) \n { \n if ( ! ctx -> extra_data_updated ) { \n uint8_t * side_data = av_packet_new_side_data ( pkt , AV_PKT_DATA_NEW_EXTRADATA , ctx -> extra_data_size ) ; \n if ( ! side_data ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( side_data , ctx -> extra_data , ctx -> extra_data_size ) ; \n ctx -> extra_data_updated = 1 ; \n } \n return 0 ; \n }", "idx": 21133}
{"project": "FFmpeg", "commit_id": "dd0bfc3a6a310e3e3674ce7742672d689a9a0e93", "target": 0, "func": "static void cin_decode_rle ( const unsigned char * src , int src_size , \n unsigned char * dst , int dst_size ) \n { \n int len , code ; \n unsigned char * dst_end = dst + dst_size ; \n const unsigned char * src_end = src + src_size ; \n while ( src < src_end && dst < dst_end ) { \n code = * src ++ ; \n if ( code & 0x80 ) { \n len = code - 0x7F ; \n memset ( dst , * src ++ , FFMIN ( len , dst_end - dst ) ) ; \n } else { \n len = code + 1 ; \n memcpy ( dst , src , FFMIN ( len , dst_end - dst ) ) ; \n src += len ; \n } \n dst += len ; \n } \n }", "idx": 21140}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void init_rl ( RLTable * rl ) \n { \n int8_t max_level [ MAX_RUN + 1 ] , max_run [ MAX_LEVEL + 1 ] ; \n uint8_t index_run [ MAX_RUN + 1 ] ; \n int last , run , level , start , end , i ; \n for ( last = 0 ; last < 2 ; last ++ ) { \n if ( last == 0 ) { \n start = 0 ; \n end = rl -> last ; \n } else { \n start = rl -> last ; \n end = rl -> n ; \n } \n memset ( max_level , 0 , MAX_RUN + 1 ) ; \n memset ( max_run , 0 , MAX_LEVEL + 1 ) ; \n memset ( index_run , rl -> n , MAX_RUN + 1 ) ; \n for ( i = start ; i < end ; i ++ ) { \n run = rl -> table_run [ i ] ; \n level = rl -> table_level [ i ] ; \n if ( index_run [ run ] == rl -> n ) \n index_run [ run ] = i ; \n if ( level > max_level [ run ] ) \n max_level [ run ] = level ; \n if ( run > max_run [ level ] ) \n max_run [ level ] = run ; \n } \n rl -> max_level [ last ] = av_malloc ( MAX_RUN + 1 ) ; \n memcpy ( rl -> max_level [ last ] , max_level , MAX_RUN + 1 ) ; \n rl -> max_run [ last ] = av_malloc ( MAX_LEVEL + 1 ) ; \n memcpy ( rl -> max_run [ last ] , max_run , MAX_LEVEL + 1 ) ; \n rl -> index_run [ last ] = av_malloc ( MAX_RUN + 1 ) ; \n memcpy ( rl -> index_run [ last ] , index_run , MAX_RUN + 1 ) ; \n } \n }", "idx": 21145}
{"project": "FFmpeg", "commit_id": "e9a9ca1936ea2853cdfb8913d44711d240eec60d", "target": 1, "func": "static void free_buffers ( AVCodecContext * avctx ) \n { \n CFHDContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n av_freep ( & s -> plane [ i ] . idwt_buf ) ; \n av_freep ( & s -> plane [ i ] . idwt_tmp ) ; \n } \n s -> a_height = 0 ; \n s -> a_width = 0 ; \n }", "idx": 21147}
{"project": "FFmpeg", "commit_id": "db0a52d611d7319c8a1186829a50e29b9dfed63b", "target": 0, "func": "av_const int ff_h263_aspect_to_info ( AVRational aspect ) { \n int i ; \n if ( aspect . num == 0 ) aspect = ( AVRational ) { 1 , 1 } ; \n for ( i = 1 ; i < 6 ; i ++ ) { \n if ( av_cmp_q ( ff_h263_pixel_aspect [ i ] , aspect ) == 0 ) { \n return i ; \n } \n } \n return FF_ASPECT_EXTENDED ; \n }", "idx": 21149}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int filter_samples ( AVFilterLink * inlink , AVFilterBufferRef * samplesref ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n int i , ret = 0 ; \n for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) { \n ret = ff_filter_samples ( inlink -> dst -> outputs [ i ] , \n avfilter_ref_buffer ( samplesref , ~ AV_PERM_WRITE ) ) ; \n if ( ret < 0 ) \n break ; \n } \n avfilter_unref_buffer ( samplesref ) ; \n return ret ; \n }", "idx": 21150}
{"project": "FFmpeg", "commit_id": "b015872c0d0823e70776e98b865509ec1287e2f6", "target": 0, "func": "av_cold void ff_huffyuvdsp_init_ppc ( HuffYUVDSPContext * c ) \n { \n #if HAVE_ALTIVEC && HAVE_BIGENDIAN  \n  \n  if ( ! PPC_ALTIVEC ( av_get_cpu_flags ( ) ) ) \n return ; \n c -> add_bytes = add_bytes_altivec ; \n #endif \n }", "idx": 21151}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sr_1d97_float ( float * p , int i0 , int i1 ) \n { \n int i ; \n if ( i1 <= i0 + 1 ) { \n if ( i0 == 1 ) \n p [ 1 ] *= F_LFTG_K / 2 ; \n else \n p [ 0 ] *= F_LFTG_X / 2 ; \n return ; \n } \n extend97_float ( p , i0 , i1 ) ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 + 2 ; i ++ ) \n p [ 2 * i ] -= F_LFTG_DELTA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i + 1 ] -= F_LFTG_GAMMA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) ; \n for ( i = i0 / 2 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i ] += F_LFTG_BETA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) ; \n for ( i = i0 / 2 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i + 1 ] += F_LFTG_ALPHA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) ; \n }", "idx": 21156}
{"project": "FFmpeg", "commit_id": "022d22e5810d1c90f618fddd751b1f03502d6021", "target": 1, "func": "static int dca_find_frame_end ( DCAParseContext * pc1 , const uint8_t * buf , \n int buf_size ) \n { \n int start_found , i ; \n uint32_t state ; \n ParseContext * pc = & pc1 -> pc ; \n start_found = pc -> frame_start_found ; \n state = pc -> state ; \n i = 0 ; \n if ( ! start_found ) { \n for ( i = 0 ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n if ( IS_MARKER ( state , i , buf , buf_size ) ) { \n if ( ! pc1 -> lastmarker || state == pc1 -> lastmarker || pc1 -> lastmarker == DCA_HD_MARKER ) { \n start_found = 1 ; \n pc1 -> lastmarker = state ; \n break ; \n } \n } \n } \n } \n if ( start_found ) { \n for ( ; i < buf_size ; i ++ ) { \n pc1 -> size ++ ; \n state = ( state << 8 ) | buf [ i ] ; \n if ( state == DCA_HD_MARKER && ! pc1 -> hd_pos ) \n pc1 -> hd_pos = pc1 -> size ; \n if ( IS_MARKER ( state , i , buf , buf_size ) && ( state == pc1 -> lastmarker || pc1 -> lastmarker == DCA_HD_MARKER ) ) { \n if ( pc1 -> framesize > pc1 -> size ) \n continue ; \n if ( ! pc1 -> framesize ) { \n pc1 -> framesize = pc1 -> hd_pos ? pc1 -> hd_pos : pc1 -> size ; \n } \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n pc1 -> size = 0 ; \n return i - 3 ; \n } \n } \n } \n pc -> frame_start_found = start_found ; \n pc -> state = state ; \n return END_NOT_FOUND ; \n }", "idx": 21157}
{"project": "FFmpeg", "commit_id": "10bbf6cf622f8a954c6cc694ca07c24f989c99af", "target": 1, "func": "static int read_quant_tables ( RangeCoder * c , \n int16_t quant_table [ MAX_CONTEXT_INPUTS ] [ 256 ] ) \n { \n int i ; \n int context_count = 1 ; \n for ( i = 0 ; i < 5 ; i ++ ) { \n context_count *= read_quant_table ( c , quant_table [ i ] , context_count ) ; \n if ( context_count > 32768U ) { \n return AVERROR_INVALIDDATA ; \n } \n } \n return ( context_count + 1 ) / 2 ; \n }", "idx": 21159}
{"project": "FFmpeg", "commit_id": "6e1b1a27a4034c578018d5042b3c8228278c4cd6", "target": 1, "func": "int av_copy_packet_side_data ( AVPacket * pkt , AVPacket * src ) \n { \n if ( src -> side_data_elems ) { \n int i ; \n DUP_DATA ( pkt -> side_data , src -> side_data , \n src -> side_data_elems * sizeof ( * src -> side_data ) , 0 , ALLOC_MALLOC ) ; \n memset ( pkt -> side_data , 0 , \n src -> side_data_elems * sizeof ( * src -> side_data ) ) ; \n for ( i = 0 ; i < src -> side_data_elems ; i ++ ) { \n DUP_DATA ( pkt -> side_data [ i ] . data , src -> side_data [ i ] . data , \n src -> side_data [ i ] . size , 1 , ALLOC_MALLOC ) ; \n pkt -> side_data [ i ] . size = src -> side_data [ i ] . size ; \n pkt -> side_data [ i ] . type = src -> side_data [ i ] . type ; \n } \n } \n return 0 ; \n failed_alloc : \n av_destruct_packet ( pkt ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 21161}
{"project": "FFmpeg", "commit_id": "4bff9ef9d0781c4de228bf1f85634d2706fc589b", "target": 0, "func": "static inline void RENAME ( rgb32tobgr32 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" \" REG_a \" \" REG_a \" \\n \\t \" \n ASMALIGN16 \n \" \\n \\t \" \n PREFETCH \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \"  MANGLE ( mask32r )  \" \\n \\t \" \n \" \"  MANGLE ( mask32g )  \" \\n \\t \" \n \" \"  MANGLE ( mask32b )  \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n :: \" r \" ( src ) , \" \" ( dst ) , \" \" ( src_size - 7 ) \n : \" % \" \n ) ; \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #else \n unsigned i ; \n unsigned num_pixels = src_size >> 2 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 4 * i + 1 ] = src [ 4 * i + 3 ] ; \n dst [ 4 * i + 2 ] = src [ 4 * i + 2 ] ; \n dst [ 4 * i + 3 ] = src [ 4 * i + 1 ] ; \n #else \n dst [ 4 * i + 0 ] = src [ 4 * i + 2 ] ; \n dst [ 4 * i + 1 ] = src [ 4 * i + 1 ] ; \n dst [ 4 * i + 2 ] = src [ 4 * i + 0 ] ; \n #endif \n } \n #endif \n }", "idx": 21162}
{"project": "FFmpeg", "commit_id": "0ceca269b66ec12a23bf0907bd2c220513cdbf16", "target": 0, "func": "static int read_block ( ALSDecContext * ctx , ALSBlockData * bd ) \n { \n GetBitContext * gb = & ctx -> gb ; \n * bd -> shift_lsbs = 0 ; \n if ( get_bits1 ( gb ) ) { \n if ( read_var_block_data ( ctx , bd ) ) \n return -1 ; \n } else { \n read_const_block_data ( ctx , bd ) ; \n } \n return 0 ; \n }", "idx": 21163}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "static int init_input ( AVFormatContext * s , const char * filename , \n AVDictionary * * options ) \n { \n int ret ; \n AVProbeData pd = { filename , NULL , 0 } ; \n int score = AVPROBE_SCORE_RETRY ; \n if ( s -> pb ) { \n s -> flags |= AVFMT_FLAG_CUSTOM_IO ; \n if ( ! s -> iformat ) \n return av_probe_input_buffer2 ( s -> pb , & s -> iformat , filename , \n s , 0 , s -> format_probesize ) ; \n else if ( s -> iformat -> flags & AVFMT_NOFILE ) \n av_log ( s , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n return 0 ; \n } \n if ( ( s -> iformat && s -> iformat -> flags & AVFMT_NOFILE ) || \n ( ! s -> iformat && ( s -> iformat = av_probe_input_format2 ( & pd , 0 , & score ) ) ) ) \n return score ; \n if ( ( ret = avio_open2 ( & s -> pb , filename , AVIO_FLAG_READ | s -> avio_flags , \n & s -> interrupt_callback , options ) ) < 0 ) \n return ret ; \n if ( s -> iformat ) \n return 0 ; \n return av_probe_input_buffer2 ( s -> pb , & s -> iformat , filename , \n s , 0 , s -> format_probesize ) ; \n }", "idx": 21164}
{"project": "FFmpeg", "commit_id": "c693af1951a0074a29ce39b69736ff0cf33b41d2", "target": 0, "func": "static int inet_aton ( const char * str , struct in_addr * add ) \n { \n return inet_aton ( str , add ) ; \n }", "idx": 21165}
{"project": "FFmpeg", "commit_id": "a75d22445ecb7adbe3fb8f705cb4fd9aa0d6b5ee", "target": 1, "func": "static int opt_show_format_entry ( void * optctx , const char * opt , const char * arg ) \n { \n char * buf = av_asprintf ( \" \" , arg ) ; \n int ret ; \n av_log ( NULL , AV_LOG_WARNING , \n \" \\n \" , \n opt , arg ) ; \n ret = opt_show_entries ( optctx , opt , buf ) ; \n av_free ( buf ) ; \n return ret ; \n }", "idx": 21172}
{"project": "FFmpeg", "commit_id": "c7efffcb443fe5a2134833f62987b3a999e0701e", "target": 1, "func": "int ff_set_systematic_pal ( uint32_t pal [ 256 ] , enum PixelFormat pix_fmt ) { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n int r , g , b ; \n switch ( pix_fmt ) { \n case PIX_FMT_RGB8 : \n r = ( i >> 5 ) * 36 ; \n g = ( ( i >> 2 ) & 7 ) * 36 ; \n b = ( i & 3 ) * 85 ; \n break ; \n case PIX_FMT_BGR8 : \n b = ( i >> 6 ) * 85 ; \n g = ( ( i >> 3 ) & 7 ) * 36 ; \n r = ( i & 7 ) * 36 ; \n break ; \n case PIX_FMT_RGB4_BYTE : \n r = ( i >> 3 ) * 255 ; \n g = ( ( i >> 1 ) & 3 ) * 85 ; \n b = ( i & 1 ) * 255 ; \n break ; \n case PIX_FMT_BGR4_BYTE : \n b = ( i >> 3 ) * 255 ; \n g = ( ( i >> 1 ) & 3 ) * 85 ; \n r = ( i & 1 ) * 255 ; \n break ; \n case PIX_FMT_GRAY8 : \n r = b = g = i ; \n break ; \n } \n pal [ i ] = b + ( g << 8 ) + ( r << 16 ) ; \n } \n return 0 ; \n }", "idx": 21174}
{"project": "FFmpeg", "commit_id": "1deec58ba308f66280e388071dbcc223c3728595", "target": 1, "func": "static AVFilterContext * create_filter_with_args ( const char * filt , void * opaque ) \n { \n AVFilterContext * ret ; \n char * filter = av_strdup ( filt ) ; \n char * name , * args ; \n name = filter ; \n if ( ( args = strchr ( filter , ' ' ) ) ) { \n if ( args == filter ) \n goto fail ; \n * args ++ = 0 ; \n } \n av_log ( NULL , AV_LOG_INFO , \" \\\" \\\" \\\" \\\" \\n \" , \n name , args ? args : \" \" ) ; \n if ( ( ret = avfilter_create_by_name ( name , NULL ) ) ) { \n if ( avfilter_init_filter ( ret , args , opaque ) ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n avfilter_destroy ( ret ) ; \n goto fail ; \n } \n } else av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n fail : \n return NULL ; \n }", "idx": 21177}
{"project": "FFmpeg", "commit_id": "bb60142f562ef9ca7f34bd69abe059d56ea1cbf1", "target": 1, "func": "static int set_string_binary ( void * obj , const AVOption * o , const char * val , uint8_t * * dst ) \n { \n int * lendst = ( int * ) ( dst + 1 ) ; \n uint8_t * bin , * ptr ; \n int len = strlen ( val ) ; \n av_freep ( dst ) ; \n * lendst = 0 ; \n if ( len & 1 ) \n return AVERROR ( EINVAL ) ; \n len /= 2 ; \n ptr = bin = av_malloc ( len ) ; \n while ( * val ) { \n int a = hexchar2int ( * val ++ ) ; \n int b = hexchar2int ( * val ++ ) ; \n if ( a < 0 || b < 0 ) { \n av_free ( bin ) ; \n return AVERROR ( EINVAL ) ; \n } \n * ptr ++ = ( a << 4 ) | b ; \n } \n * dst = bin ; \n * lendst = len ; \n return 0 ; \n }", "idx": 21178}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_rv34dsp_init_x86 ( RV34DSPContext * c , DSPContext * dsp ) \n { \n #if HAVE_YASM  \n  \n  int mm_flags = av_get_cpu_flags ( ) ; \n if ( mm_flags & AV_CPU_FLAG_MMX ) \n c -> rv34_idct_dc_add = ff_rv34_idct_dc_add_mmx ; \n if ( mm_flags & AV_CPU_FLAG_MMXEXT ) { \n c -> rv34_inv_transform_dc = ff_rv34_idct_dc_noround_mmx2 ; \n c -> rv34_idct_add = ff_rv34_idct_add_mmx2 ; \n } \n if ( mm_flags & AV_CPU_FLAG_SSE4 ) \n c -> rv34_idct_dc_add = ff_rv34_idct_dc_add_sse4 ; \n #endif \n }", "idx": 21194}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "static void common_end ( SnowContext * s ) { \n av_freep ( & s -> spatial_dwt_buffer ) ; \n av_freep ( & s -> mb_band . buf ) ; \n av_freep ( & s -> mv_band [ 0 ] . buf ) ; \n av_freep ( & s -> mv_band [ 1 ] . buf ) ; \n av_freep ( & s -> m . me . scratchpad ) ; \n av_freep ( & s -> m . me . map ) ; \n av_freep ( & s -> m . me . score_map ) ; \n av_freep ( & s -> mb_type ) ; \n av_freep ( & s -> mb_mean ) ; \n av_freep ( & s -> dummy ) ; \n av_freep ( & s -> motion_val8 ) ; \n av_freep ( & s -> motion_val16 ) ; \n }", "idx": 21205}
{"project": "FFmpeg", "commit_id": "5d9e4eaa6d991718b24c7ce24318ee91419f593a", "target": 0, "func": "static int read_matrix_params ( MLPDecodeContext * m , SubStream * s , GetBitContext * gbp ) \n { \n unsigned int mat , ch ; \n s -> num_primitive_matrices = get_bits ( gbp , 4 ) ; \n m -> matrix_changed ++ ; \n for ( mat = 0 ; mat < s -> num_primitive_matrices ; mat ++ ) { \n int frac_bits , max_chan ; \n s -> matrix_out_ch [ mat ] = get_bits ( gbp , 4 ) ; \n frac_bits = get_bits ( gbp , 4 ) ; \n s -> lsb_bypass [ mat ] = get_bits1 ( gbp ) ; \n if ( s -> matrix_out_ch [ mat ] > s -> max_matrix_channel ) { \n av_log ( m -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n s -> matrix_out_ch [ mat ] ) ; \n return -1 ; \n } \n if ( frac_bits > 14 ) { \n av_log ( m -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n max_chan = s -> max_matrix_channel ; \n if ( ! s -> noise_type ) \n max_chan += 2 ; \n for ( ch = 0 ; ch <= max_chan ; ch ++ ) { \n int coeff_val = 0 ; \n if ( get_bits1 ( gbp ) ) \n coeff_val = get_sbits ( gbp , frac_bits + 2 ) ; \n s -> matrix_coeff [ mat ] [ ch ] = coeff_val << ( 14 - frac_bits ) ; \n } \n if ( s -> noise_type ) \n s -> matrix_noise_shift [ mat ] = get_bits ( gbp , 4 ) ; \n else \n s -> matrix_noise_shift [ mat ] = 0 ; \n } \n return 0 ; \n }", "idx": 21220}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int libgsm_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n int ret ; \n gsm_signal * samples = ( gsm_signal * ) frame -> data [ 0 ] ; \n struct gsm_state * state = avctx -> priv_data ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , avctx -> block_align ) ) ) \n return ret ; \n switch ( avctx -> codec_id ) { \n case AV_CODEC_ID_GSM : \n gsm_encode ( state , samples , avpkt -> data ) ; \n break ; \n case AV_CODEC_ID_GSM_MS : \n gsm_encode ( state , samples , avpkt -> data ) ; \n gsm_encode ( state , samples + GSM_FRAME_SIZE , avpkt -> data + 32 ) ; \n } \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 21221}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_dc_add_mmx2 ( uint8_t * dst , int16_t * block , int stride ) \n { \n int dc = ( block [ 0 ] + 32 ) >> 6 ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( dc ) \n ) ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + m \" \n \" + m \" \n \" + m \" \n \" + m \" \n ) ; \n }", "idx": 21223}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_xvmc_field_end ( MpegEncContext * s ) \n { \n struct xvmc_pix_fmt * render = ( struct xvmc_pix_fmt * ) s -> current_picture . f -> data [ 2 ] ; \n assert ( render ) ; \n if ( render -> filled_mv_blocks_num > 0 ) \n ff_mpeg_draw_horiz_band ( s , 0 , 0 ) ; \n }", "idx": 21224}
{"project": "FFmpeg", "commit_id": "aafed1175df76603e94c99a7748968780d6548d2", "target": 1, "func": "static int channelmap_config_input ( AVFilterLink * inlink ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ChannelMapContext * s = ctx -> priv ; \n int i , err = 0 ; \n const char * channel_name ; \n char layout_name [ 256 ] ; \n if ( s -> mode == MAP_PAIR_STR_INT || s -> mode == MAP_PAIR_STR_STR ) { \n for ( i = 0 ; i < s -> nch ; i ++ ) { \n s -> map [ i ] . in_channel_idx = av_get_channel_layout_channel_index ( \n inlink -> channel_layout , s -> map [ i ] . in_channel ) ; \n if ( s -> map [ i ] . in_channel_idx < 0 ) { \n channel_name = av_get_channel_name ( s -> map [ i ] . in_channel ) ; \n av_get_channel_layout_string ( layout_name , sizeof ( layout_name ) , \n 0 , inlink -> channel_layout ) ; \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n channel_name , layout_name ) ; \n err = AVERROR ( EINVAL ) ; \n } \n } \n } \n return err ; \n }", "idx": 21227}
{"project": "FFmpeg", "commit_id": "a849ebb54e187a70eabc69cbd1b1a342e6587ec3", "target": 0, "func": "static int unpack_parse_unit ( DiracParseUnit * pu , DiracParseContext * pc , \n int offset ) \n { \n int8_t * start ; \n if ( offset < 0 || pc -> index - 13 < offset ) \n return 0 ; \n start = pc -> buffer + offset ; \n pu -> pu_type = start [ 4 ] ; \n pu -> next_pu_offset = AV_RB32 ( start + 5 ) ; \n pu -> prev_pu_offset = AV_RB32 ( start + 9 ) ; \n if ( pu -> pu_type == 0x10 && pu -> next_pu_offset == 0 ) \n pu -> next_pu_offset = 13 ; \n if ( pu -> next_pu_offset && pu -> next_pu_offset < 13 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , pu -> next_pu_offset ) ; \n return 0 ; \n } \n if ( pu -> prev_pu_offset && pu -> prev_pu_offset < 13 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , pu -> prev_pu_offset ) ; \n return 0 ; \n } \n return 1 ; \n }", "idx": 21233}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void quantize_all ( DCAEncContext * c ) \n { \n int sample , band , ch ; \n for ( sample = 0 ; sample < SUBBAND_SAMPLES ; sample ++ ) \n for ( band = 0 ; band < 32 ; band ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n c -> quantized [ sample ] [ band ] [ ch ] = quantize_value ( c -> subband [ sample ] [ band ] [ ch ] , c -> quant [ band ] [ ch ] ) ; \n }", "idx": 21234}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "func": "static void skip_input ( DBEContext * s , int nb_words ) \n { \n s -> input += nb_words * s -> word_bytes ; \n s -> input_size -= nb_words ; \n }", "idx": 21239}
{"project": "FFmpeg", "commit_id": "695a766bff4cd8414a84e58159506d72b4e44892", "target": 0, "func": "static int64_t ff_read_timestamp ( AVFormatContext * s , int stream_index , int64_t * ppos , int64_t pos_limit , \n int64_t ( * read_timestamp ) ( struct AVFormatContext * , int , int64_t * , int64_t ) ) \n { \n return wrap_timestamp ( s -> streams [ stream_index ] , read_timestamp ( s , stream_index , ppos , pos_limit ) ) ; \n }", "idx": 21248}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static void process_synthesis_subpackets ( QDM2Context * q , QDM2SubPNode * list ) \n { \n QDM2SubPNode * nodes [ 4 ] ; \n nodes [ 0 ] = qdm2_search_subpacket_type_in_list ( list , 9 ) ; \n if ( nodes [ 0 ] != NULL ) \n process_subpacket_9 ( q , nodes [ 0 ] ) ; \n nodes [ 1 ] = qdm2_search_subpacket_type_in_list ( list , 10 ) ; \n if ( nodes [ 1 ] != NULL ) \n process_subpacket_10 ( q , nodes [ 1 ] ) ; \n else \n process_subpacket_10 ( q , NULL ) ; \n nodes [ 2 ] = qdm2_search_subpacket_type_in_list ( list , 11 ) ; \n if ( nodes [ 0 ] != NULL && nodes [ 1 ] != NULL && nodes [ 2 ] != NULL ) \n process_subpacket_11 ( q , nodes [ 2 ] ) ; \n else \n process_subpacket_11 ( q , NULL ) ; \n nodes [ 3 ] = qdm2_search_subpacket_type_in_list ( list , 12 ) ; \n if ( nodes [ 0 ] != NULL && nodes [ 1 ] != NULL && nodes [ 3 ] != NULL ) \n process_subpacket_12 ( q , nodes [ 3 ] ) ; \n else \n process_subpacket_12 ( q , NULL ) ; \n }", "idx": 21253}
{"project": "FFmpeg", "commit_id": "281bde27894f994d0982ab9283f15d6073ae352c", "target": 0, "func": "static int udp_close ( URLContext * h ) \n { \n UDPContext * s = h -> priv_data ; \n int ret ; \n if ( s -> is_multicast && ( h -> flags & AVIO_FLAG_READ ) ) \n udp_leave_multicast_group ( s -> udp_fd , ( struct sockaddr * ) & s -> dest_addr ) ; \n closesocket ( s -> udp_fd ) ; \n av_fifo_free ( s -> fifo ) ; \n #if HAVE_PTHREADS  \n  \n  if ( s -> thread_started ) { \n pthread_cancel ( s -> circular_buffer_thread ) ; \n ret = pthread_join ( s -> circular_buffer_thread , NULL ) ; \n if ( ret != 0 ) \n av_log ( h , AV_LOG_ERROR , \" \\n \" , strerror ( ret ) ) ; \n } \n pthread_mutex_destroy ( & s -> mutex ) ; \n pthread_cond_destroy ( & s -> cond ) ; \n #endif \n return 0 ; \n }", "idx": 21255}
{"project": "FFmpeg", "commit_id": "1ecb63cd1c1a4ddc5efed4abbc3158b969d8c5e4", "target": 0, "func": "static void decode_profile_tier_level ( GetBitContext * gb , AVCodecContext * avctx , \n PTLCommon * ptl ) \n { \n int i ; \n ptl -> profile_space = get_bits ( gb , 2 ) ; \n ptl -> tier_flag = get_bits1 ( gb ) ; \n ptl -> profile_idc = get_bits ( gb , 5 ) ; \n if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN ) \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN_10 ) \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else if ( ptl -> profile_idc == FF_PROFILE_HEVC_MAIN_STILL_PICTURE ) \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n else \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" , ptl -> profile_idc ) ; \n for ( i = 0 ; i < 32 ; i ++ ) \n ptl -> profile_compatibility_flag [ i ] = get_bits1 ( gb ) ; \n ptl -> progressive_source_flag = get_bits1 ( gb ) ; \n ptl -> interlaced_source_flag = get_bits1 ( gb ) ; \n ptl -> non_packed_constraint_flag = get_bits1 ( gb ) ; \n ptl -> frame_only_constraint_flag = get_bits1 ( gb ) ; \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 12 ) ; \n }", "idx": 21264}
{"project": "FFmpeg", "commit_id": "e2ff436ef64589de8486517352e17f513886e15b", "target": 1, "func": "int attribute_align_arg avcodec_decode_audio3 ( AVCodecContext * avctx , int16_t * samples , \n int * frame_size_ptr , \n AVPacket * avpkt ) \n { \n AVFrame frame ; \n int ret , got_frame = 0 ; \n if ( avctx -> get_buffer != avcodec_default_get_buffer ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n ret = avcodec_decode_audio4 ( avctx , & frame , & got_frame , avpkt ) ; \n if ( ret >= 0 && got_frame ) { \n int ch , plane_size ; \n int planar = av_sample_fmt_is_planar ( avctx -> sample_fmt ) ; \n int data_size = av_samples_get_buffer_size ( & plane_size , avctx -> channels , \n frame . nb_samples , \n avctx -> sample_fmt , 1 ) ; \n if ( * frame_size_ptr < data_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" , * frame_size_ptr , data_size ) ; \n return AVERROR ( EINVAL ) ; \n } \n memcpy ( samples , frame . extended_data [ 0 ] , plane_size ) ; \n if ( planar && avctx -> channels > 1 ) { \n uint8_t * out = ( ( uint8_t * ) samples ) + plane_size ; \n for ( ch = 1 ; ch < avctx -> channels ; ch ++ ) { \n memcpy ( out , frame . extended_data [ ch ] , plane_size ) ; \n out += plane_size ; \n } \n } \n * frame_size_ptr = data_size ; \n } else { \n * frame_size_ptr = 0 ; \n } \n return ret ; \n }", "idx": 21289}
{"project": "FFmpeg", "commit_id": "830f7f189f7b41221b29d40e8127cf54a140ae86", "target": 1, "func": "static int64_t mmsh_seek ( URLContext * h , int64_t pos , int whence ) \n { \n MMSHContext * mmsh = h -> priv_data ; \n MMSContext * mms = & mmsh -> mms ; \n if ( pos == 0 && whence == SEEK_CUR ) \n return mms -> asf_header_read_size + mms -> remaining_in_len + mmsh -> chunk_seq * mms -> asf_packet_len ; \n return AVERROR ( ENOSYS ) ; \n }", "idx": 21298}
{"project": "FFmpeg", "commit_id": "366484fff1720977b8591e3a90fbef9f4885e53c", "target": 0, "func": "static int smjpeg_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n SMJPEGContext * sc = s -> priv_data ; \n uint32_t dtype , ret , size , timestamp ; \n int64_t pos ; \n if ( s -> pb -> eof_reached ) \n return AVERROR_EOF ; \n pos = avio_tell ( s -> pb ) ; \n dtype = avio_rl32 ( s -> pb ) ; \n switch ( dtype ) { \n case SMJPEG_SNDD : \n timestamp = avio_rb32 ( s -> pb ) ; \n size = avio_rb32 ( s -> pb ) ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = sc -> audio_stream_index ; \n pkt -> pts = timestamp ; \n pkt -> pos = pos ; \n break ; \n case SMJPEG_VIDD : \n timestamp = avio_rb32 ( s -> pb ) ; \n size = avio_rb32 ( s -> pb ) ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> stream_index = sc -> video_stream_index ; \n pkt -> pts = timestamp ; \n pkt -> pos = pos ; \n break ; \n case SMJPEG_DONE : \n ret = AVERROR_EOF ; \n break ; \n default : \n av_log ( s , AV_LOG_ERROR , \" \\n \" , dtype ) ; \n ret = AVERROR_INVALIDDATA ; \n break ; \n } \n return ret ; \n }", "idx": 21304}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid6_cx ( float ( * in ) [ 2 ] , float ( * out ) [ 32 ] [ 2 ] , const float ( * filter ) [ 7 ] [ 2 ] , int len ) \n { \n int i , j , ssb ; \n int N = 8 ; \n float temp [ 8 ] [ 2 ] ; \n for ( i = 0 ; i < len ; i ++ , in ++ ) { \n for ( ssb = 0 ; ssb < N ; ssb ++ ) { \n float sum_re = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 0 ] , sum_im = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 1 ] ; \n for ( j = 0 ; j < 6 ; j ++ ) { \n float in0_re = in [ j ] [ 0 ] ; \n float in0_im = in [ j ] [ 1 ] ; \n float in1_re = in [ 12 - j ] [ 0 ] ; \n float in1_im = in [ 12 - j ] [ 1 ] ; \n sum_re += filter [ ssb ] [ j ] [ 0 ] * ( in0_re + in1_re ) - filter [ ssb ] [ j ] [ 1 ] * ( in0_im - in1_im ) ; \n sum_im += filter [ ssb ] [ j ] [ 0 ] * ( in0_im + in1_im ) + filter [ ssb ] [ j ] [ 1 ] * ( in0_re - in1_re ) ; \n } \n temp [ ssb ] [ 0 ] = sum_re ; \n temp [ ssb ] [ 1 ] = sum_im ; \n } \n out [ 0 ] [ i ] [ 0 ] = temp [ 6 ] [ 0 ] ; \n out [ 0 ] [ i ] [ 1 ] = temp [ 6 ] [ 1 ] ; \n out [ 1 ] [ i ] [ 0 ] = temp [ 7 ] [ 0 ] ; \n out [ 1 ] [ i ] [ 1 ] = temp [ 7 ] [ 1 ] ; \n out [ 2 ] [ i ] [ 0 ] = temp [ 0 ] [ 0 ] ; \n out [ 2 ] [ i ] [ 1 ] = temp [ 0 ] [ 1 ] ; \n out [ 3 ] [ i ] [ 0 ] = temp [ 1 ] [ 0 ] ; \n out [ 3 ] [ i ] [ 1 ] = temp [ 1 ] [ 1 ] ; \n out [ 4 ] [ i ] [ 0 ] = temp [ 2 ] [ 0 ] + temp [ 5 ] [ 0 ] ; \n out [ 4 ] [ i ] [ 1 ] = temp [ 2 ] [ 1 ] + temp [ 5 ] [ 1 ] ; \n out [ 5 ] [ i ] [ 0 ] = temp [ 3 ] [ 0 ] + temp [ 4 ] [ 0 ] ; \n out [ 5 ] [ i ] [ 1 ] = temp [ 3 ] [ 1 ] + temp [ 4 ] [ 1 ] ; \n } \n }", "idx": 21323}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuv1 ) ( SwsContext * c , const int16_t * lumSrc , \n const int16_t * chrUSrc , const int16_t * chrVSrc , \n const int16_t * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n int p = 4 ; \n const int16_t * src [ 4 ] = { alpSrc + dstW , lumSrc + dstW , chrUSrc + chrDstW , chrVSrc + chrDstW } ; \n uint8_t * dst [ 4 ] = { aDest , dest , uDest , vDest } ; \n x86_reg counter [ 4 ] = { dstW , dstW , chrDstW , chrDstW } ; \n while ( p -- ) { \n if ( dst [ p ] ) { \n __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n MOVNTQ ( % % mm0 , ( % 1 , % % REGa ) ) \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( src [ p ] ) , \" \" ( dst [ p ] + counter [ p ] ) , \n \" \" ( - counter [ p ] ) \n : \" % \" \n ) ; \n } \n } \n }", "idx": 21327}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static char * ts_value_string ( char * buf , int buf_size , int64_t ts ) \n { \n if ( ts == AV_NOPTS_VALUE ) { \n snprintf ( buf , buf_size , \" \" ) ; \n } else { \n snprintf ( buf , buf_size , \" \" PRId64 , ts ) ; \n } \n return buf ; \n }", "idx": 21329}
{"project": "FFmpeg", "commit_id": "65daa942eb51c348e205ae3a54f77b8781907a81", "target": 1, "func": "static int decode_bdlt ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n const uint8_t * frame_end = frame + width * height ; \n uint8_t * line_ptr ; \n int count , lines , segments ; \n count = bytestream_get_le16 ( & src ) ; \n if ( count >= height || width * count < 0 ) \n return -1 ; \n frame += width * count ; \n lines = bytestream_get_le16 ( & src ) ; \n if ( frame + lines * width > frame_end || src >= src_end ) \n return -1 ; \n while ( lines -- ) { \n line_ptr = frame ; \n frame += width ; \n segments = * src ++ ; \n while ( segments -- ) { \n if ( src_end - src < 3 ) \n return -1 ; \n line_ptr += * src ++ ; \n if ( line_ptr >= frame ) \n return -1 ; \n count = ( int8_t ) * src ++ ; \n if ( count >= 0 ) { \n if ( line_ptr + count > frame || src_end - src < count ) \n return -1 ; \n bytestream_get_buffer ( & src , line_ptr , count ) ; \n } else { \n count = - count ; \n if ( line_ptr + count > frame || src >= src_end ) \n return -1 ; \n memset ( line_ptr , * src ++ , count ) ; \n } \n line_ptr += count ; \n } \n } \n return 0 ; \n }", "idx": 21331}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_xvmc_pack_pblocks ( MpegEncContext * s , int cbp ) \n { \n int i , j = 0 ; \n const int mb_block_count = 4 + ( 1 << s -> chroma_format ) ; \n cbp <<= 12 - mb_block_count ; \n for ( i = 0 ; i < mb_block_count ; i ++ ) { \n if ( cbp & ( 1 << 11 ) ) \n s -> pblocks [ i ] = & s -> block [ j ++ ] ; \n else \n s -> pblocks [ i ] = NULL ; \n cbp += cbp ; \n } \n }", "idx": 21349}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_h_lpf_luma_inter_msa ( uint8_t * data , int img_width , \n int alpha , int beta , int8_t * tc ) \n { \n uint8_t bs0 = 1 ; \n uint8_t bs1 = 1 ; \n uint8_t bs2 = 1 ; \n uint8_t bs3 = 1 ; \n if ( tc [ 0 ] < 0 ) \n bs0 = 0 ; \n if ( tc [ 1 ] < 0 ) \n bs1 = 0 ; \n if ( tc [ 2 ] < 0 ) \n bs2 = 0 ; \n if ( tc [ 3 ] < 0 ) \n bs3 = 0 ; \n avc_loopfilter_luma_inter_edge_ver_msa ( data , \n bs0 , bs1 , bs2 , bs3 , \n tc [ 0 ] , tc [ 1 ] , tc [ 2 ] , tc [ 3 ] , \n alpha , beta , img_width ) ; \n }", "idx": 21360}
{"project": "FFmpeg", "commit_id": "65340c976c664b94427ac50f5d03b0e77883c108", "target": 1, "func": "static void free_buffers ( VP8Context * s ) \n { \n int i ; \n if ( s -> thread_data ) \n for ( i = 0 ; i < MAX_THREADS ; i ++ ) { \n av_freep ( & s -> thread_data [ i ] . filter_strength ) ; \n av_freep ( & s -> thread_data [ i ] . edge_emu_buffer ) ; \n } \n av_freep ( & s -> thread_data ) ; \n av_freep ( & s -> macroblocks_base ) ; \n av_freep ( & s -> intra4x4_pred_mode_top ) ; \n av_freep ( & s -> top_nnz ) ; \n av_freep ( & s -> top_border ) ; \n s -> macroblocks = NULL ; \n }", "idx": 21373}
{"project": "FFmpeg", "commit_id": "e2ad0b66fa273c5c823978e8f601f2c0d9ee42f8", "target": 0, "func": "int avpicture_fill ( AVPicture * picture , uint8_t * ptr , \n enum AVPixelFormat pix_fmt , int width , int height ) \n { \n int ret ; \n if ( ( ret = av_image_check_size ( width , height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = av_image_fill_linesizes ( picture -> linesize , pix_fmt , width ) ) < 0 ) \n return ret ; \n return av_image_fill_pointers ( picture -> data , pix_fmt , \n height , ptr , picture -> linesize ) ; \n }", "idx": 21398}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void decode_init_vlc ( H264Context * h ) { \n static int done = 0 ; \n if ( ! done ) { \n int i ; \n done = 1 ; \n init_vlc ( & chroma_dc_coeff_token_vlc , CHROMA_DC_COEFF_TOKEN_VLC_BITS , 4 * 5 , \n & chroma_dc_coeff_token_len [ 0 ] , 1 , 1 , \n & chroma_dc_coeff_token_bits [ 0 ] , 1 , 1 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n init_vlc ( & coeff_token_vlc [ i ] , COEFF_TOKEN_VLC_BITS , 4 * 17 , \n & coeff_token_len [ i ] [ 0 ] , 1 , 1 , \n & coeff_token_bits [ i ] [ 0 ] , 1 , 1 ) ; \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n init_vlc ( & chroma_dc_total_zeros_vlc [ i ] , CHROMA_DC_TOTAL_ZEROS_VLC_BITS , 4 , \n & chroma_dc_total_zeros_len [ i ] [ 0 ] , 1 , 1 , \n & chroma_dc_total_zeros_bits [ i ] [ 0 ] , 1 , 1 ) ; \n } \n for ( i = 0 ; i < 15 ; i ++ ) { \n init_vlc ( & total_zeros_vlc [ i ] , TOTAL_ZEROS_VLC_BITS , 16 , \n & total_zeros_len [ i ] [ 0 ] , 1 , 1 , \n & total_zeros_bits [ i ] [ 0 ] , 1 , 1 ) ; \n } \n for ( i = 0 ; i < 6 ; i ++ ) { \n init_vlc ( & run_vlc [ i ] , RUN_VLC_BITS , 7 , \n & run_len [ i ] [ 0 ] , 1 , 1 , \n & run_bits [ i ] [ 0 ] , 1 , 1 ) ; \n } \n init_vlc ( & run7_vlc , RUN7_VLC_BITS , 16 , \n & run_len [ 6 ] [ 0 ] , 1 , 1 , \n & run_bits [ 6 ] [ 0 ] , 1 , 1 ) ; \n } \n }", "idx": 21404}
{"project": "FFmpeg", "commit_id": "e4e02a7d4726e9370127741eb2873d6671d3f0c3", "target": 1, "func": "int av_buffersink_poll_frame ( AVFilterContext * ctx ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVFilterLink * inlink = ctx -> inputs [ 0 ] ; \n av_assert0 ( ! strcmp ( ctx -> filter -> name , \" \" ) || ! strcmp ( ctx -> filter -> name , \" \" ) ) ; \n return av_fifo_size ( buf -> fifo ) / sizeof ( AVFilterBufferRef * ) + ff_poll_frame ( inlink ) ; \n }", "idx": 21405}
{"project": "FFmpeg", "commit_id": "5449a787c953f40f0f4312e6f5897775904ffc45", "target": 1, "func": "static void mmap_release_buffer ( AVPacket * pkt ) \n { \n struct v4l2_buffer buf ; \n int res , fd ; \n struct buff_data * buf_descriptor = pkt -> priv ; \n memset ( & buf , 0 , sizeof ( struct v4l2_buffer ) ) ; \n buf . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n buf . memory = V4L2_MEMORY_MMAP ; \n buf . index = buf_descriptor -> index ; \n fd = buf_descriptor -> fd ; \n av_free ( buf_descriptor ) ; \n res = ioctl ( fd , VIDIOC_QBUF , & buf ) ; \n if ( res < 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n pkt -> data = NULL ; \n pkt -> size = 0 ;", "idx": 21408}
{"project": "FFmpeg", "commit_id": "69dde1ad36b7d95b8b9268f414aa6c076212ed41", "target": 0, "func": "static int mov_write_moov_tag ( ByteIOContext * pb , MOVContext * mov ) \n { \n int pos , i ; \n pos = url_ftell ( pb ) ; \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n mov -> timescale = globalTimescale ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) { \n if ( mov -> tracks [ i ] . entry <= 0 ) continue ; \n if ( mov -> tracks [ i ] . enc -> codec_type == CODEC_TYPE_VIDEO ) { \n mov -> tracks [ i ] . timescale = mov -> tracks [ i ] . enc -> frame_rate ; \n mov -> tracks [ i ] . sampleDuration = mov -> tracks [ i ] . enc -> frame_rate_base ; \n } \n else if ( mov -> tracks [ i ] . enc -> codec_type == CODEC_TYPE_AUDIO ) { \n if ( mov -> tracks [ i ] . enc -> codec_id == CODEC_ID_AMR_NB ) { \n mov -> tracks [ i ] . sampleDuration = 160 ; \n mov -> tracks [ i ] . timescale = 8000 ; \n } \n else { \n mov -> tracks [ i ] . timescale = mov -> tracks [ i ] . enc -> sample_rate ; \n mov -> tracks [ i ] . sampleDuration = mov -> tracks [ i ] . enc -> frame_size ; \n } \n } \n mov -> tracks [ i ] . trackDuration = \n mov -> tracks [ i ] . sampleCount * mov -> tracks [ i ] . sampleDuration ; \n mov -> tracks [ i ] . time = mov -> time ; \n mov -> tracks [ i ] . trackID = i + 1 ; \n } \n mov_write_mvhd_tag ( pb , mov ) ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) { \n if ( mov -> tracks [ i ] . entry > 0 ) { \n mov_write_trak_tag ( pb , & ( mov -> tracks [ i ] ) ) ; \n } \n } \n return updateSize ( pb , pos ) ; \n }", "idx": 21420}
{"project": "FFmpeg", "commit_id": "2aadff2e44fa27664ccd1b0a63829e61bf82e939", "target": 0, "func": "static void build_chunks ( MOVTrack * trk ) \n { \n int i ; \n MOVIentry * chunk = & trk -> cluster [ 0 ] ; \n uint64_t chunkSize = chunk -> size ; \n chunk -> chunkNum = 1 ; \n trk -> chunkCount = 1 ; \n for ( i = 1 ; i < trk -> entry ; i ++ ) { \n if ( chunk -> pos + chunkSize == trk -> cluster [ i ] . pos ) { \n chunkSize += trk -> cluster [ i ] . size ; \n chunk -> samplesInChunk += trk -> cluster [ i ] . entries ; \n } else { \n trk -> cluster [ i ] . chunkNum = chunk -> chunkNum + 1 ; \n chunk = & trk -> cluster [ i ] ; \n chunkSize = chunk -> size ; \n trk -> chunkCount ++ ; \n } \n } \n }", "idx": 21465}
{"project": "FFmpeg", "commit_id": "0a82f5275f719e6e369a807720a2c3603aa0ddd9", "target": 1, "func": "void ff_lag_rac_init ( lag_rac * l , GetBitContext * gb , int length ) \n { \n int i , j ; \n align_get_bits ( gb ) ; \n l -> bytestream_start = \n l -> bytestream = gb -> buffer + get_bits_count ( gb ) / 8 ; \n l -> bytestream_end = l -> bytestream_start + length ; \n l -> range = 0x80 ; \n l -> low = * l -> bytestream >> 1 ; \n l -> hash_shift = FFMAX ( l -> scale - 8 , 0 ) ; \n for ( i = j = 0 ; i < 256 ; i ++ ) { \n unsigned r = i << l -> hash_shift ; \n while ( l -> prob [ j + 1 ] <= r ) \n j ++ ; \n l -> range_hash [ i ] = j ; \n } \n l -> hash_shift += 23 ; \n }", "idx": 21469}
{"project": "FFmpeg", "commit_id": "5ca0106879079d7f82bb9335638674292794f74c", "target": 0, "func": "static inline void decode_residual_inter ( AVSContext * h ) { \n int block ; \n h -> cbp = cbp_tab [ get_ue_golomb ( & h -> s . gb ) ] [ 1 ] ; \n if ( h -> cbp && ! h -> qp_fixed ) \n h -> qp += get_se_golomb ( & h -> s . gb ) ; \n for ( block = 0 ; block < 4 ; block ++ ) \n if ( h -> cbp & ( 1 << block ) ) \n decode_residual_block ( h , & h -> s . gb , inter_2dvlc , 0 , h -> qp , \n h -> cy + h -> luma_scan [ block ] , h -> l_stride ) ; \n decode_residual_chroma ( h ) ; \n }", "idx": 21475}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "int avpriv_mpa_decode_header ( AVCodecContext * avctx , uint32_t head , int * sample_rate , int * channels , int * frame_size , int * bit_rate ) \n { \n MPADecodeHeader s1 , * s = & s1 ; \n if ( ff_mpa_check_header ( head ) != 0 ) \n return -1 ; \n if ( avpriv_mpegaudio_decode_header ( s , head ) != 0 ) { \n return -1 ; \n } \n switch ( s -> layer ) { \n case 1 : \n avctx -> codec_id = AV_CODEC_ID_MP1 ; \n * frame_size = 384 ; \n break ; \n case 2 : \n avctx -> codec_id = AV_CODEC_ID_MP2 ; \n * frame_size = 1152 ; \n break ; \n default : \n case 3 : \n if ( avctx -> codec_id != AV_CODEC_ID_MP3ADU ) \n avctx -> codec_id = AV_CODEC_ID_MP3 ; \n if ( s -> lsf ) \n * frame_size = 576 ; \n else \n * frame_size = 1152 ; \n break ; \n } \n * sample_rate = s -> sample_rate ; \n * channels = s -> nb_channels ; \n * bit_rate = s -> bit_rate ; \n return s -> frame_size ; \n }", "idx": 21486}
{"project": "FFmpeg", "commit_id": "e021eeb9f06f4f4d83690d07b47cdcc4172a61e1", "target": 0, "func": "static int get_key ( const char * * ropts , const char * delim , char * key , unsigned key_size ) \n { \n unsigned key_pos = 0 ; \n const char * opts = * ropts ; \n opts += strspn ( opts , WHITESPACES ) ; \n while ( is_key_char ( * opts ) ) { \n key [ key_pos ++ ] = * opts ; \n if ( key_pos == key_size ) \n key_pos -- ; \n ( opts ) ++ ; \n } \n opts += strspn ( opts , WHITESPACES ) ; \n if ( ! * opts || ! strchr ( delim , * opts ) ) \n return AVERROR ( EINVAL ) ; \n opts ++ ; \n key [ key_pos ++ ] = 0 ; \n if ( key_pos == key_size ) \n key [ key_pos - 4 ] = key [ key_pos - 3 ] = key [ key_pos - 2 ] = ' ' ; \n * ropts = opts ; \n return 0 ; \n }", "idx": 21502}
{"project": "FFmpeg", "commit_id": "2bf4aa2e937737deb781706673f806d4388cf796", "target": 0, "func": "static void generate_len_table ( uint8_t * dst , uint64_t * stats , int size ) { \n heap_elem_t h [ size ] ; \n int up [ 2 * size ] ; \n int len [ 2 * size ] ; \n int offset , i , next ; \n for ( offset = 1 ; ; offset <<= 1 ) { \n for ( i = 0 ; i < size ; i ++ ) { \n h [ i ] . name = i ; \n h [ i ] . val = ( stats [ i ] << 8 ) + offset ; \n } \n for ( i = size / 2 - 1 ; i >= 0 ; i -- ) \n heap_sift ( h , i , size ) ; \n for ( next = size ; next < size * 2 - 1 ; next ++ ) { \n uint64_t min1v = h [ 0 ] . val ; \n up [ h [ 0 ] . name ] = next ; \n h [ 0 ] . val = INT64_MAX ; \n heap_sift ( h , 0 , size ) ; \n up [ h [ 0 ] . name ] = next ; \n h [ 0 ] . name = next ; \n h [ 0 ] . val += min1v ; \n heap_sift ( h , 0 , size ) ; \n } \n len [ 2 * size - 2 ] = 0 ; \n for ( i = 2 * size - 3 ; i >= size ; i -- ) \n len [ i ] = len [ up [ i ] ] + 1 ; \n for ( i = 0 ; i < size ; i ++ ) { \n dst [ i ] = len [ up [ i ] ] + 1 ; \n if ( dst [ i ] > 32 ) break ; \n } \n if ( i == size ) break ; \n } \n }", "idx": 21504}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_MPV_encode_init_x86 ( MpegEncContext * s ) \n { \n int mm_flags = av_get_cpu_flags ( ) ; \n const int dct_algo = s -> avctx -> dct_algo ; \n if ( dct_algo == FF_DCT_AUTO || dct_algo == FF_DCT_MMX ) { \n #if HAVE_MMX_INLINE  \n  \n  if ( mm_flags & AV_CPU_FLAG_MMX && HAVE_MMX ) \n s -> dct_quantize = dct_quantize_MMX ; \n #endif \n #if HAVE_MMXEXT_INLINE  \n  \n  if ( mm_flags & AV_CPU_FLAG_MMXEXT && HAVE_MMXEXT ) \n s -> dct_quantize = dct_quantize_MMX2 ; \n #endif \n #if HAVE_SSE2_INLINE  \n  \n  if ( mm_flags & AV_CPU_FLAG_SSE2 && HAVE_SSE2 ) \n s -> dct_quantize = dct_quantize_SSE2 ; \n #endif \n #if HAVE_SSSE3_INLINE  \n  \n  if ( mm_flags & AV_CPU_FLAG_SSSE3 ) \n s -> dct_quantize = dct_quantize_SSSE3 ; \n #endif \n } \n }", "idx": 21512}
{"project": "FFmpeg", "commit_id": "8813d55fa5978660d9f4e7dbe1f50da9922be08d", "target": 0, "func": "int ff_vaapi_render_picture ( FFVAContext * vactx , VASurfaceID surface ) \n { \n VABufferID va_buffers [ 3 ] ; \n unsigned int n_va_buffers = 0 ; \n if ( ! vactx -> pic_param_buf_id ) \n return 0 ; \n vaUnmapBuffer ( vactx -> display , vactx -> pic_param_buf_id ) ; \n va_buffers [ n_va_buffers ++ ] = vactx -> pic_param_buf_id ; \n if ( vactx -> iq_matrix_buf_id ) { \n vaUnmapBuffer ( vactx -> display , vactx -> iq_matrix_buf_id ) ; \n va_buffers [ n_va_buffers ++ ] = vactx -> iq_matrix_buf_id ; \n } \n if ( vactx -> bitplane_buf_id ) { \n vaUnmapBuffer ( vactx -> display , vactx -> bitplane_buf_id ) ; \n va_buffers [ n_va_buffers ++ ] = vactx -> bitplane_buf_id ; \n } \n if ( vaBeginPicture ( vactx -> display , vactx -> context_id , \n surface ) != VA_STATUS_SUCCESS ) \n return -1 ; \n if ( vaRenderPicture ( vactx -> display , vactx -> context_id , \n va_buffers , n_va_buffers ) != VA_STATUS_SUCCESS ) \n return -1 ; \n if ( vaRenderPicture ( vactx -> display , vactx -> context_id , \n vactx -> slice_buf_ids , \n vactx -> n_slice_buf_ids ) != VA_STATUS_SUCCESS ) \n return -1 ; \n if ( vaEndPicture ( vactx -> display , vactx -> context_id ) != VA_STATUS_SUCCESS ) \n return -1 ; \n return 0 ; \n }", "idx": 21573}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static int normalize_samples ( AC3EncodeContext * s ) \n { \n int v = 14 - log2_tab ( s , s -> windowed_samples , AC3_WINDOW_SIZE ) ; \n lshift_tab ( s -> windowed_samples , AC3_WINDOW_SIZE , v ) ; \n return v - 9 ; \n }", "idx": 21577}
{"project": "FFmpeg", "commit_id": "0e3afacd4d8fbe1c21e0bc16bd707809cd87380f", "target": 0, "func": "static int add_tonal_components ( float * spectrum , int num_components , \n TonalComponent * components ) \n { \n int i , j , last_pos = -1 ; \n float * input , * output ; \n for ( i = 0 ; i < num_components ; i ++ ) { \n last_pos = FFMAX ( components [ i ] . pos + components [ i ] . num_coefs , last_pos ) ; \n input = components [ i ] . coef ; \n output = & spectrum [ components [ i ] . pos ] ; \n for ( j = 0 ; j < components [ i ] . num_coefs ; j ++ ) \n output [ i ] += input [ i ] ; \n } \n return last_pos ; \n }", "idx": 21582}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed8 ( AVCodecContext * avctx , const AVFrame * frame , opj_image_t * image ) \n { \n int compno ; \n int x ; \n int y ; \n int * image_line ; \n int frame_index ; \n const int numcomps = image -> numcomps ; \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n if ( image -> comps [ compno ] . w > frame -> linesize [ 0 ] / numcomps ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n for ( y = 0 ; y < avctx -> height ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n frame_index = y * frame -> linesize [ 0 ] + compno ; \n for ( x = 0 ; x < avctx -> width ; ++ x ) { \n image_line [ x ] = frame -> data [ 0 ] [ frame_index ] ; \n frame_index += numcomps ; \n } \n for ( ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - 1 ] ; \n } \n } \n for ( ; y < image -> comps [ compno ] . h ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n for ( x = 0 ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - image -> comps [ compno ] . w ] ; \n } \n } \n } \n return 1 ; \n }", "idx": 21594}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "static av_cold int decode_init ( AVCodecContext * avctx ) \n { \n ASV1Context * const a = avctx -> priv_data ; \n const int scale = avctx -> codec_id == AV_CODEC_ID_ASV1 ? 1 : 2 ; \n int i ; \n if ( avctx -> extradata_size < 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n ff_asv_common_init ( avctx ) ; \n ff_blockdsp_init ( & a -> bdsp , avctx ) ; \n ff_idctdsp_init ( & a -> idsp , avctx ) ; \n init_vlcs ( a ) ; \n ff_init_scantable ( a -> idsp . idct_permutation , & a -> scantable , ff_asv_scantab ) ; \n avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; \n a -> inv_qscale = avctx -> extradata [ 0 ] ; \n if ( a -> inv_qscale == 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( avctx -> codec_id == AV_CODEC_ID_ASV1 ) \n a -> inv_qscale = 6 ; \n else \n a -> inv_qscale = 10 ; \n } \n for ( i = 0 ; i < 64 ; i ++ ) { \n int index = ff_asv_scantab [ i ] ; \n a -> intra_matrix [ i ] = 64 * scale * ff_mpeg1_default_intra_matrix [ index ] / \n a -> inv_qscale ; \n } \n return 0 ; \n }", "idx": 21597}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgecv ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 21600}
{"project": "FFmpeg", "commit_id": "2875745d354ab0ebc4af1ebaca5c5a8d26ccdc03", "target": 0, "func": "enum AVCodecID ff_get_pcm_codec_id ( int bps , int flt , int be , int sflags ) \n { \n if ( bps > 64U ) \n return AV_CODEC_ID_NONE ; \n if ( flt ) { \n switch ( bps ) { \n case 32 : \n return be ? AV_CODEC_ID_PCM_F32BE : AV_CODEC_ID_PCM_F32LE ; \n case 64 : \n return be ? AV_CODEC_ID_PCM_F64BE : AV_CODEC_ID_PCM_F64LE ; \n default : \n return AV_CODEC_ID_NONE ; \n } \n } else { \n bps += 7 ; \n bps >>= 3 ; \n if ( sflags & ( 1 << ( bps - 1 ) ) ) { \n switch ( bps ) { \n case 1 : \n return AV_CODEC_ID_PCM_S8 ; \n case 2 : \n return be ? AV_CODEC_ID_PCM_S16BE : AV_CODEC_ID_PCM_S16LE ; \n case 3 : \n return be ? AV_CODEC_ID_PCM_S24BE : AV_CODEC_ID_PCM_S24LE ; \n case 4 : \n return be ? AV_CODEC_ID_PCM_S32BE : AV_CODEC_ID_PCM_S32LE ; \n default : \n return AV_CODEC_ID_NONE ; \n } \n } else { \n switch ( bps ) { \n case 1 : \n return AV_CODEC_ID_PCM_U8 ; \n case 2 : \n return be ? AV_CODEC_ID_PCM_U16BE : AV_CODEC_ID_PCM_U16LE ; \n case 3 : \n return be ? AV_CODEC_ID_PCM_U24BE : AV_CODEC_ID_PCM_U24LE ; \n case 4 : \n return be ? AV_CODEC_ID_PCM_U32BE : AV_CODEC_ID_PCM_U32LE ; \n default : \n return AV_CODEC_ID_NONE ; \n } \n } \n } \n }", "idx": 21604}
{"project": "FFmpeg", "commit_id": "e3331706fcc9888ee85f0b9f763e4d006b178c14", "target": 0, "func": "static void start_frame ( AVFilterLink * inlink , AVFilterBufferRef * inpicref ) \n { \n PadContext * pad = inlink -> dst -> priv ; \n AVFilterBufferRef * outpicref = avfilter_ref_buffer ( inpicref , ~ 0 ) ; \n int plane ; \n inlink -> dst -> outputs [ 0 ] -> out_buf = outpicref ; \n for ( plane = 0 ; plane < 4 && outpicref -> data [ plane ] ; plane ++ ) { \n int hsub = ( plane == 1 || plane == 2 ) ? pad -> hsub : 0 ; \n int vsub = ( plane == 1 || plane == 2 ) ? pad -> vsub : 0 ; \n outpicref -> data [ plane ] -= ( pad -> x >> hsub ) * pad -> line_step [ plane ] + \n ( pad -> y >> vsub ) * outpicref -> linesize [ plane ] ; \n } \n outpicref -> video -> w = pad -> w ; \n outpicref -> video -> h = pad -> h ; \n avfilter_start_frame ( inlink -> dst -> outputs [ 0 ] , outpicref ) ; \n }", "idx": 21606}
{"project": "FFmpeg", "commit_id": "b12d21733975f9001eecb480fc28e5e4473b1327", "target": 0, "func": "static int thread_init ( AVCodecContext * avctx ) \n { \n int i ; \n ThreadContext * c ; \n int thread_count = avctx -> thread_count ; \n if ( ! thread_count ) { \n int nb_cpus = get_logical_cpus ( avctx ) ; \n if ( nb_cpus > 1 ) \n thread_count = avctx -> thread_count = nb_cpus + 1 ; \n } \n if ( thread_count <= 1 ) { \n avctx -> active_thread_type = 0 ; \n return 0 ; \n } \n c = av_mallocz ( sizeof ( ThreadContext ) ) ; \n if ( ! c ) \n return -1 ; \n c -> workers = av_mallocz ( sizeof ( pthread_t ) * thread_count ) ; \n if ( ! c -> workers ) { \n av_free ( c ) ; \n return -1 ; \n } \n avctx -> thread_opaque = c ; \n c -> current_job = 0 ; \n c -> job_count = 0 ; \n c -> job_size = 0 ; \n c -> done = 0 ; \n pthread_cond_init ( & c -> current_job_cond , NULL ) ; \n pthread_cond_init ( & c -> last_job_cond , NULL ) ; \n pthread_mutex_init ( & c -> current_job_lock , NULL ) ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n for ( i = 0 ; i < thread_count ; i ++ ) { \n if ( pthread_create ( & c -> workers [ i ] , NULL , worker , avctx ) ) { \n avctx -> thread_count = i ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n ff_thread_free ( avctx ) ; \n return -1 ; \n } \n } \n avcodec_thread_park_workers ( c , thread_count ) ; \n avctx -> execute = avcodec_thread_execute ; \n avctx -> execute2 = avcodec_thread_execute2 ; \n return 0 ; \n }", "idx": 21608}
{"project": "FFmpeg", "commit_id": "550bda741cfe0e471a70e40529a9ab02d31b7049", "target": 1, "func": "av_cold void ff_dsputil_init_alpha ( DSPContext * c , AVCodecContext * avctx ) \n { \n const int high_bit_depth = avctx -> bits_per_raw_sample > 8 ; \n if ( amask ( AMASK_MVI ) == 0 ) { \n c -> put_pixels_clamped = put_pixels_clamped_mvi_asm ; \n c -> add_pixels_clamped = add_pixels_clamped_mvi_asm ; \n if ( ! high_bit_depth ) \n c -> get_pixels = get_pixels_mvi ; \n c -> diff_pixels = diff_pixels_mvi ; \n c -> sad [ 0 ] = pix_abs16x16_mvi_asm ; \n c -> sad [ 1 ] = pix_abs8x8_mvi ; \n c -> pix_abs [ 0 ] [ 0 ] = pix_abs16x16_mvi_asm ; \n c -> pix_abs [ 1 ] [ 0 ] = pix_abs8x8_mvi ; \n c -> pix_abs [ 0 ] [ 1 ] = pix_abs16x16_x2_mvi ; \n c -> pix_abs [ 0 ] [ 2 ] = pix_abs16x16_y2_mvi ; \n c -> pix_abs [ 0 ] [ 3 ] = pix_abs16x16_xy2_mvi ; \n } \n put_pixels_clamped_axp_p = c -> put_pixels_clamped ; \n add_pixels_clamped_axp_p = c -> add_pixels_clamped ; \n if ( ! avctx -> lowres && avctx -> bits_per_raw_sample <= 8 && \n ( avctx -> idct_algo == FF_IDCT_AUTO || \n avctx -> idct_algo == FF_IDCT_SIMPLEALPHA ) ) { \n c -> idct_put = ff_simple_idct_put_axp ; \n c -> idct_add = ff_simple_idct_add_axp ; \n c -> idct = ff_simple_idct_axp ; \n } \n }", "idx": 21610}
{"project": "FFmpeg", "commit_id": "a878dfa4f57d068eb69fb6614f7a4a20f769ee7b", "target": 0, "func": "av_cold int ff_ffv1_init_slice_state ( FFV1Context * f , FFV1Context * fs ) \n { \n int j ; \n fs -> plane_count = f -> plane_count ; \n fs -> transparency = f -> transparency ; \n for ( j = 0 ; j < f -> plane_count ; j ++ ) { \n PlaneContext * const p = & fs -> plane [ j ] ; \n if ( fs -> ac ) { \n if ( ! p -> state ) \n p -> state = av_malloc_array ( p -> context_count , CONTEXT_SIZE * \n sizeof ( uint8_t ) ) ; \n if ( ! p -> state ) \n return AVERROR ( ENOMEM ) ; \n } else { \n if ( ! p -> vlc_state ) \n p -> vlc_state = av_malloc_array ( p -> context_count , sizeof ( VlcState ) ) ; \n if ( ! p -> vlc_state ) \n return AVERROR ( ENOMEM ) ; \n } \n } \n if ( fs -> ac > 1 ) { \n for ( j = 1 ; j < 256 ; j ++ ) { \n fs -> c . one_state [ j ] = f -> state_transition [ j ] ; \n fs -> c . zero_state [ 256 - j ] = 256 - fs -> c . one_state [ j ] ; \n } \n } \n return 0 ; \n }", "idx": 21629}
{"project": "FFmpeg", "commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "target": 1, "func": "static void close_slave ( TeeSlave * tee_slave ) \n { \n AVFormatContext * avf ; \n unsigned i ; \n avf = tee_slave -> avf ; \n for ( i = 0 ; i < avf -> nb_streams ; ++ i ) { \n AVBitStreamFilterContext * bsf_next , * bsf = tee_slave -> bsfs [ i ] ; \n while ( bsf ) { \n bsf_next = bsf -> next ; \n av_bitstream_filter_close ( bsf ) ; \n bsf = bsf_next ; \n } \n } \n av_freep ( & tee_slave -> stream_map ) ; \n av_freep ( & tee_slave -> bsfs ) ; \n ff_format_io_close ( avf , & avf -> pb ) ; \n avformat_free_context ( avf ) ; \n tee_slave -> avf = NULL ; \n }", "idx": 21637}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static void vp8_idct_dc_add4uv_c ( uint8_t * dst , int16_t block [ 4 ] [ 16 ] , \n ptrdiff_t stride ) \n { \n vp8_idct_dc_add_c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \n }", "idx": 21650}
{"project": "FFmpeg", "commit_id": "a6a2282c25abe43e352010a7c3fbc92994c0bc1c", "target": 0, "func": "static av_cold int rv30_decode_init ( AVCodecContext * avctx ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n int ret ; \n r -> rv30 = 1 ; \n if ( ( ret = ff_rv34_decode_init ( avctx ) ) < 0 ) \n return ret ; \n if ( avctx -> extradata_size < 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n r -> rpr = ( avctx -> extradata [ 1 ] & 7 ) >> 1 ; \n r -> rpr = FFMIN ( r -> rpr + 1 , 3 ) ; \n if ( avctx -> extradata_size - 8 < ( r -> rpr - 1 ) * 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n 6 + r -> rpr * 2 , avctx -> extradata_size ) ; \n return AVERROR ( EINVAL ) ; \n } \n r -> parse_slice_header = rv30_parse_slice_header ; \n r -> decode_intra_types = rv30_decode_intra_types ; \n r -> decode_mb_info = rv30_decode_mb_info ; \n r -> loop_filter = rv30_loop_filter ; \n r -> luma_dc_quant_i = rv30_luma_dc_quant ; \n r -> luma_dc_quant_p = rv30_luma_dc_quant ; \n return 0 ; \n }", "idx": 21659}
{"project": "FFmpeg", "commit_id": "c2409a7c5b1c1f43ee8b00c13ed41edc0321db0b", "target": 0, "func": "static av_cold int vmdaudio_decode_init ( AVCodecContext * avctx ) \n { \n VmdAudioContext * s = avctx -> priv_data ; \n if ( avctx -> channels < 1 || avctx -> channels > 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( avctx -> block_align < 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n avctx -> channel_layout = avctx -> channels == 1 ? AV_CH_LAYOUT_MONO : \n AV_CH_LAYOUT_STEREO ; \n if ( avctx -> bits_per_coded_sample == 16 ) \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n else \n avctx -> sample_fmt = AV_SAMPLE_FMT_U8 ; \n s -> out_bps = av_get_bytes_per_sample ( avctx -> sample_fmt ) ; \n s -> chunk_size = avctx -> block_align + avctx -> channels * ( s -> out_bps == 2 ) ; \n avcodec_get_frame_defaults ( & s -> frame ) ; \n avctx -> coded_frame = & s -> frame ; \n av_log ( avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , \n avctx -> channels , avctx -> bits_per_coded_sample , avctx -> block_align , \n avctx -> sample_rate ) ; \n return 0 ; \n }", "idx": 21661}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_blck ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n memset ( frame , 0 , width * height ) ; \n return 0 ; \n }", "idx": 21669}
{"project": "FFmpeg", "commit_id": "b5d2bf964be338bf8e86a01619646332729b434e", "target": 1, "func": "static inline int decode_bytes ( const uint8_t * inbuffer , uint8_t * out , int bytes ) \n { \n static const uint32_t tab [ 4 ] = { \n AV_BE2NE32C ( 0x37c511f2 ) , AV_BE2NE32C ( 0xf237c511 ) , \n AV_BE2NE32C ( 0x11f237c5 ) , AV_BE2NE32C ( 0xc511f237 ) , \n } ; \n int i , off ; \n uint32_t c ; \n const uint32_t * buf ; \n uint32_t * obuf = ( uint32_t * ) out ; \n off = ( intptr_t ) inbuffer & 3 ; \n buf = ( const uint32_t * ) ( inbuffer - off ) ; \n c = tab [ off ] ; \n bytes += 3 + off ; \n for ( i = 0 ; i < bytes / 4 ; i ++ ) \n obuf [ i ] = c ^ buf [ i ] ; \n return off ; \n }", "idx": 21676}
{"project": "FFmpeg", "commit_id": "d8edf1b515ae9fbcea2103305241d130c16e1003", "target": 0, "func": "static inline void rv40_weak_loop_filter ( uint8_t * src , const int step , \n const int filter_p1 , const int filter_q1 , \n const int alpha , const int beta , \n const int lim_p0q0 , \n const int lim_q1 , const int lim_p1 , \n const int diff_p1p0 , const int diff_q1q0 , \n const int diff_p1p2 , const int diff_q1q2 ) \n { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int t , u , diff ; \n t = src [ 0 * step ] - src [ -1 * step ] ; \n if ( ! t ) \n return ; \n u = ( alpha * FFABS ( t ) ) >> 7 ; \n if ( u > 3 - ( filter_p1 && filter_q1 ) ) \n return ; \n t <<= 2 ; \n if ( filter_p1 && filter_q1 ) \n t += src [ -2 * step ] - src [ 1 * step ] ; \n diff = CLIP_SYMM ( ( t + 4 ) >> 3 , lim_p0q0 ) ; \n src [ -1 * step ] = cm [ src [ -1 * step ] + diff ] ; \n src [ 0 * step ] = cm [ src [ 0 * step ] - diff ] ; \n if ( FFABS ( diff_p1p2 ) <= beta && filter_p1 ) { \n t = ( diff_p1p0 + diff_p1p2 - diff ) >> 1 ; \n src [ -2 * step ] = cm [ src [ -2 * step ] - CLIP_SYMM ( t , lim_p1 ) ] ; \n } \n if ( FFABS ( diff_q1q2 ) <= beta && filter_q1 ) { \n t = ( diff_q1q0 + diff_q1q2 + diff ) >> 1 ; \n src [ 1 * step ] = cm [ src [ 1 * step ] - CLIP_SYMM ( t , lim_q1 ) ] ; \n } \n }", "idx": 21678}
{"project": "FFmpeg", "commit_id": "3715d841a619f1cbc4776d9b00575dae6fb6534a", "target": 0, "func": "static av_cold int alloc_buffers ( AVCodecContext * avctx , AACEncContext * s ) \n { \n FF_ALLOCZ_OR_GOTO ( avctx , s -> buffer . samples , 3 * 1024 * s -> channels * sizeof ( s -> buffer . samples [ 0 ] ) , alloc_fail ) ; \n FF_ALLOCZ_OR_GOTO ( avctx , s -> cpe , sizeof ( ChannelElement ) * s -> chan_map [ 0 ] , alloc_fail ) ; \n FF_ALLOCZ_OR_GOTO ( avctx , avctx -> extradata , 5 + FF_INPUT_BUFFER_PADDING_SIZE , alloc_fail ) ; \n for ( int ch = 0 ; ch < s -> channels ; ch ++ ) \n s -> planar_samples [ ch ] = s -> buffer . samples + 3 * 1024 * ch ; \n return 0 ; \n alloc_fail : \n return AVERROR ( ENOMEM ) ; \n }", "idx": 21684}
{"project": "FFmpeg", "commit_id": "7303962f1467e302906561be53ca4d51abbe5522", "target": 0, "func": "void ff_aac_update_ltp ( AACEncContext * s , SingleChannelElement * sce ) \n { \n int i , j , lag ; \n float corr , s0 , s1 , max_corr = 0.0f ; \n float * samples = & s -> planar_samples [ s -> cur_channel ] [ 1024 ] ; \n float * pred_signal = & sce -> ltp_state [ 0 ] ; \n int samples_num = 2048 ; \n if ( s -> profile != FF_PROFILE_AAC_LTP ) \n return ; \n for ( i = 0 ; i < samples_num ; i ++ ) { \n s0 = s1 = 0.0f ; \n for ( j = 0 ; j < samples_num ; j ++ ) { \n if ( j + 1024 < i ) \n continue ; \n s0 += samples [ j ] * pred_signal [ j - i + 1024 ] ; \n s1 += pred_signal [ j - i + 1024 ] * pred_signal [ j - i + 1024 ] ; \n } \n corr = s1 > 0.0f ? s0 / sqrt ( s1 ) : 0.0f ; \n if ( corr > max_corr ) { \n max_corr = corr ; \n lag = i ; \n } \n } \n lag = av_clip_uintp2 ( lag , 11 ) ; \n if ( ! lag ) { \n sce -> ics . ltp . lag = lag ; \n return ; \n } \n s0 = s1 = 0.0f ; \n for ( i = 0 ; i < lag ; i ++ ) { \n s0 += samples [ i ] ; \n s1 += pred_signal [ i - lag + 1024 ] ; \n } \n sce -> ics . ltp . coef_idx = quant_array_idx ( s0 / s1 , ltp_coef , 8 ) ; \n sce -> ics . ltp . coef = ltp_coef [ sce -> ics . ltp . coef_idx ] ; \n if ( lag < 1024 ) \n samples_num = lag + 1024 ; \n for ( i = 0 ; i < samples_num ; i ++ ) \n pred_signal [ i + 1024 ] = sce -> ics . ltp . coef * pred_signal [ i - lag + 1024 ] ; \n memset ( & pred_signal [ samples_num ] , 0 , ( 2048 - samples_num ) * sizeof ( float ) ) ; \n sce -> ics . ltp . lag = lag ; \n }", "idx": 21686}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_biweight_h264_pixels4_8_msa ( uint8_t * dst , uint8_t * src , \n int stride , int height , \n int log2_denom , int weight_dst , \n int weight_src , int offset ) \n { \n avc_biwgt_4width_msa ( src , stride , \n dst , stride , \n height , log2_denom , \n weight_src , weight_dst , offset ) ; \n }", "idx": 21687}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void clear_blocks_dcbz128_ppc ( DCTELEM * blocks ) \n { \n POWERPC_TBL_DECLARE ( powerpc_clear_blocks_dcbz128 , 1 ) ; \n register int misal = ( ( unsigned long ) blocks & 0x0000007f ) ; \n register int i = 0 ; \n POWERPC_TBL_START_COUNT ( powerpc_clear_blocks_dcbz128 , 1 ) ; \n #if 1  \n  \n  if ( misal ) { \n memset ( blocks , 0 , sizeof ( DCTELEM ) * 6 * 64 ) ; \n } \n else \n for ( ; i < sizeof ( DCTELEM ) * 6 * 64 ; i += 128 ) { \n asm volatile ( \" \" : : \" \" ( blocks ) , \" \" ( i ) : \" \" ) ; \n } \n #else \n memset ( blocks , 0 , sizeof ( DCTELEM ) * 6 * 64 ) ; \n #endif \n POWERPC_TBL_STOP_COUNT ( powerpc_clear_blocks_dcbz128 , 1 ) ; \n }", "idx": 21688}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_h261_encode_init ( MpegEncContext * s ) { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_rl ( & h261_rl_tcoeff ) ; \n } \n s -> min_qcoeff = -127 ; \n s -> max_qcoeff = 127 ; \n s -> y_dc_scale_table = \n s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ; \n }", "idx": 21697}
{"project": "FFmpeg", "commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "target": 1, "func": "static int dxtory_decode_v1_rgb ( AVCodecContext * avctx , AVFrame * pic , \n const uint8_t * src , int src_size , \n int id , int bpp ) \n { \n int h ; \n uint8_t * dst ; \n int ret ; \n if ( src_size < avctx -> width * avctx -> height * bpp ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> pix_fmt = id ; \n if ( ( ret = ff_get_buffer ( avctx , pic , 0 ) ) < 0 ) \n return ret ; \n dst = pic -> data [ 0 ] ; \n for ( h = 0 ; h < avctx -> height ; h ++ ) { \n memcpy ( dst , src , avctx -> width * bpp ) ; \n src += avctx -> width * bpp ; \n dst += pic -> linesize [ 0 ] ; \n } \n return 0 ; \n }", "idx": 21701}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_smi ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return AVERROR_INVALIDDATA ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + 0x5a + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = 0x5a + atom . size ; \n memcpy ( st -> codec -> extradata , \" \" , 4 ) ; \n avio_read ( pb , st -> codec -> extradata + 0x5a , atom . size ) ; \n av_log ( c -> fc , AV_LOG_TRACE , \" \" PRId64 \" \\n \" , atom . size , st -> codec -> extradata + 0x5a ) ; \n return 0 ; \n }", "idx": 21709}
{"project": "FFmpeg", "commit_id": "37e0b997a8d6695abb0dd4bac886a86104d68a3c", "target": 0, "func": "AVFilterFormats * avfilter_merge_formats ( AVFilterFormats * a , AVFilterFormats * b ) \n { \n AVFilterFormats * ret ; \n unsigned i , j , k = 0 ; \n ret = av_mallocz ( sizeof ( AVFilterFormats ) ) ; \n ret -> formats = av_malloc ( sizeof ( * ret -> formats ) * FFMIN ( a -> format_count , \n b -> format_count ) ) ; \n for ( i = 0 ; i < a -> format_count ; i ++ ) \n for ( j = 0 ; j < b -> format_count ; j ++ ) \n if ( a -> formats [ i ] == b -> formats [ j ] ) \n ret -> formats [ k ++ ] = a -> formats [ i ] ; \n if ( ! ( ret -> format_count = k ) ) { \n av_free ( ret -> formats ) ; \n av_free ( ret ) ; \n return NULL ; \n } \n ret -> refs = av_malloc ( sizeof ( AVFilterFormats * * ) * ( a -> refcount + b -> refcount ) ) ; \n for ( i = 0 ; i < a -> refcount ; i ++ ) { \n ret -> refs [ ret -> refcount ] = a -> refs [ i ] ; \n * ret -> refs [ ret -> refcount ++ ] = ret ; \n } \n for ( i = 0 ; i < b -> refcount ; i ++ ) { \n ret -> refs [ ret -> refcount ] = b -> refs [ i ] ; \n * ret -> refs [ ret -> refcount ++ ] = ret ; \n } \n av_free ( a -> refs ) ; \n av_free ( a -> formats ) ; \n av_free ( a ) ; \n av_free ( b -> refs ) ; \n av_free ( b -> formats ) ; \n av_free ( b ) ; \n return ret ; \n }", "idx": 21710}
{"project": "FFmpeg", "commit_id": "d8edf1b515ae9fbcea2103305241d130c16e1003", "target": 0, "func": "static void rv40_v_loop_filter ( uint8_t * src , int stride , int dmode , \n int lim_q1 , int lim_p1 , \n int alpha , int beta , int beta2 , int chroma , int edge ) { \n rv40_adaptive_loop_filter ( src , 1 , stride , dmode , lim_q1 , lim_p1 , \n alpha , beta , beta2 , chroma , edge ) ; \n }", "idx": 21711}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void lfe_downsample ( DCAEncContext * c , const int32_t * input ) \n { \n const int lfech = lfe_index [ c -> channel_config ] ; \n int i , j , lfes ; \n int32_t hist [ 512 ] ; \n int32_t accum ; \n int hist_start = 0 ; \n for ( i = 0 ; i < 512 ; i ++ ) \n hist [ i ] = c -> history [ i ] [ c -> channels - 1 ] ; \n for ( lfes = 0 ; lfes < DCA_LFE_SAMPLES ; lfes ++ ) { \n accum = 0 ; \n for ( i = hist_start , j = 0 ; i < 512 ; i ++ , j ++ ) \n accum += mul32 ( hist [ i ] , lfe_fir_64i [ j ] ) ; \n for ( i = 0 ; i < hist_start ; i ++ , j ++ ) \n accum += mul32 ( hist [ i ] , lfe_fir_64i [ j ] ) ; \n c -> downsampled_lfe [ lfes ] = accum ; \n for ( i = 0 ; i < 64 ; i ++ ) \n hist [ i + hist_start ] = input [ ( lfes * 64 + i ) * c -> channels + lfech ] ; \n hist_start = ( hist_start + 64 ) & 511 ; \n } \n }", "idx": 21712}
{"project": "FFmpeg", "commit_id": "274aa1d02f12aba969b280139cf79907134dcd89", "target": 0, "func": "static int indeo3_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n const uint8_t * buf , int buf_size ) \n { \n Indeo3DecodeContext * s = avctx -> priv_data ; \n uint8_t * src , * dest ; \n int y ; \n iv_decode_frame ( s , buf , buf_size ) ; \n if ( s -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> frame ) ; \n s -> frame . reference = 0 ; \n if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n src = s -> cur_frame -> Ybuf ; \n dest = s -> frame . data [ 0 ] ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n memcpy ( dest , src , s -> cur_frame -> y_w ) ; \n src += s -> cur_frame -> y_w ; \n dest += s -> frame . linesize [ 0 ] ; \n } \n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) \n { \n src = s -> cur_frame -> Ubuf ; \n dest = s -> frame . data [ 1 ] ; \n for ( y = 0 ; y < s -> height / 4 ; y ++ ) { \n memcpy ( dest , src , s -> cur_frame -> uv_w ) ; \n src += s -> cur_frame -> uv_w ; \n dest += s -> frame . linesize [ 1 ] ; \n } \n src = s -> cur_frame -> Vbuf ; \n dest = s -> frame . data [ 2 ] ; \n for ( y = 0 ; y < s -> height / 4 ; y ++ ) { \n memcpy ( dest , src , s -> cur_frame -> uv_w ) ; \n src += s -> cur_frame -> uv_w ; \n dest += s -> frame . linesize [ 2 ] ; \n } \n } \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 21713}
{"project": "FFmpeg", "commit_id": "3ebc7e04dea6072400d91c1c90eb3911754cee06", "target": 0, "func": "static void filter_mb_edgech ( H264Context * h , uint8_t * pix , int stride , int bS [ 4 ] , int qp ) { \n int i , d ; \n const int index_a = clip ( qp + h -> slice_alpha_c0_offset , 0 , 51 ) ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ clip ( qp + h -> slice_beta_offset , 0 , 51 ) ] ; \n const int pix_next = stride ; \n for ( i = 0 ; i < 4 ; i ++ ) \n { \n if ( bS [ i ] == 0 ) { \n pix += 2 ; \n continue ; \n } \n for ( d = 0 ; d < 2 ; d ++ ) { \n const uint8_t p0 = pix [ -1 * pix_next ] ; \n const uint8_t p1 = pix [ -2 * pix_next ] ; \n const uint8_t q0 = pix [ 0 ] ; \n const uint8_t q1 = pix [ 1 * pix_next ] ; \n if ( abs ( p0 - q0 ) >= alpha || \n abs ( p1 - p0 ) >= beta || \n abs ( q1 - q0 ) >= beta ) { \n pix ++ ; \n continue ; \n } \n if ( bS [ i ] < 4 ) { \n int tc = tc0_table [ index_a ] [ bS [ i ] - 1 ] + 1 ; \n int i_delta = clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - pix_next ] = clip ( p0 + i_delta , 0 , 255 ) ; \n pix [ 0 ] = clip ( q0 - i_delta , 0 , 255 ) ; \n } \n else \n { \n pix [ - pix_next ] = ( 2 * p1 + p0 + q1 + 2 ) >> 2 ; \n pix [ 0 ] = ( 2 * q1 + q0 + p1 + 2 ) >> 2 ; \n } \n pix ++ ; \n } \n } \n }", "idx": 21714}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "av_cold void ff_dsputil_init_armv5te ( DSPContext * c , AVCodecContext * avctx ) \n { \n if ( avctx -> bits_per_raw_sample <= 8 && \n ( avctx -> idct_algo == FF_IDCT_AUTO || \n avctx -> idct_algo == FF_IDCT_SIMPLEARMV5TE ) ) { \n c -> idct_put = ff_simple_idct_put_armv5te ; \n c -> idct_add = ff_simple_idct_add_armv5te ; \n c -> idct = ff_simple_idct_armv5te ; \n c -> idct_permutation_type = FF_NO_IDCT_PERM ; \n } \n c -> prefetch = ff_prefetch_arm ; \n }", "idx": 21727}
{"project": "FFmpeg", "commit_id": "2ed0f76655a76cc49f8a1a1d59e545f5906e7924", "target": 1, "func": "static void free_tables ( H264Context * h ) { \n int i ; \n H264Context * hx ; \n av_freep ( & h -> intra4x4_pred_mode ) ; \n av_freep ( & h -> chroma_pred_mode_table ) ; \n av_freep ( & h -> cbp_table ) ; \n av_freep ( & h -> mvd_table [ 0 ] ) ; \n av_freep ( & h -> mvd_table [ 1 ] ) ; \n av_freep ( & h -> direct_table ) ; \n av_freep ( & h -> non_zero_count ) ; \n av_freep ( & h -> slice_table_base ) ; \n h -> slice_table = NULL ; \n av_freep ( & h -> list_counts ) ; \n av_freep ( & h -> mb2b_xy ) ; \n av_freep ( & h -> mb2br_xy ) ; \n for ( i = 0 ; i < MAX_THREADS ; i ++ ) { \n hx = h -> thread_context [ i ] ; \n if ( ! hx ) continue ; \n av_freep ( & hx -> top_borders [ 1 ] ) ; \n av_freep ( & hx -> top_borders [ 0 ] ) ; \n av_freep ( & hx -> s . obmc_scratchpad ) ; \n av_freep ( & hx -> rbsp_buffer [ 1 ] ) ; \n av_freep ( & hx -> rbsp_buffer [ 0 ] ) ; \n hx -> rbsp_buffer_size [ 0 ] = 0 ; \n hx -> rbsp_buffer_size [ 1 ] = 0 ; \n if ( i ) av_freep ( & h -> thread_context [ i ] ) ; \n } \n }", "idx": 21747}
{"project": "FFmpeg", "commit_id": "5eaaffaf64d1854493f0fe9ec822eed1b3cd9fe1", "target": 0, "func": "av_cold void ff_mpadsp_init ( MPADSPContext * s ) \n { \n DCTContext dct ; \n ff_dct_init ( & dct , 5 , DCT_II ) ; \n ff_init_mpadsp_tabs_float ( ) ; \n ff_init_mpadsp_tabs_fixed ( ) ; \n s -> apply_window_float = ff_mpadsp_apply_window_float ; \n s -> apply_window_fixed = ff_mpadsp_apply_window_fixed ; \n s -> dct32_float = dct . dct32 ; \n s -> dct32_fixed = ff_dct32_fixed ; \n s -> imdct36_blocks_float = ff_imdct36_blocks_float ; \n s -> imdct36_blocks_fixed = ff_imdct36_blocks_fixed ; \n if ( ARCH_AARCH64 ) ff_mpadsp_init_aarch64 ( s ) ; \n if ( ARCH_ARM ) ff_mpadsp_init_arm ( s ) ; \n if ( ARCH_PPC ) ff_mpadsp_init_ppc ( s ) ; \n if ( ARCH_X86 ) ff_mpadsp_init_x86 ( s ) ; \n if ( HAVE_MIPSFPU ) ff_mpadsp_init_mipsfpu ( s ) ; \n if ( HAVE_MIPSDSP ) ff_mpadsp_init_mipsdsp ( s ) ; \n }", "idx": 21754}
{"project": "FFmpeg", "commit_id": "cb78d14cf9b5ab59b4a9177f390f5e1abff58644", "target": 0, "func": "static int get_range_off ( int * off , int * y_rng , int * uv_rng , \n enum AVColorRange rng , int depth ) \n { \n switch ( rng ) { \n case AVCOL_RANGE_MPEG : \n * off = 16 << ( depth - 8 ) ; \n * y_rng = 219 << ( depth - 8 ) ; \n * uv_rng = 224 << ( depth - 8 ) ; \n break ; \n case AVCOL_RANGE_JPEG : \n * off = 0 ; \n * y_rng = * uv_rng = ( 256 << ( depth - 8 ) ) - 1 ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 21755}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16intra_sse2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 2 ) { \n if ( nnzc [ scan8 [ i + 0 ] ] | nnzc [ scan8 [ i + 1 ] ] ) \n ff_x264_add8x4_idct_sse2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n else if ( block [ i * 16 ] | block [ i * 16 + 16 ] ) \n ff_h264_idct_dc_add8_mmx2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n } \n }", "idx": 21758}
{"project": "FFmpeg", "commit_id": "d509c743b78da198af385fea362b632292cd00ad", "target": 1, "func": "static int dvvideo_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n DVVideoContext * s = avctx -> priv_data ; \n s -> sys = dv_frame_profile ( buf ) ; \n if ( ! s -> sys || buf_size < s -> sys -> frame_size || dv_init_dynamic_tables ( s -> sys ) ) \n return -1 ; \n if ( s -> picture . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> picture ) ; \n s -> picture . reference = 0 ; \n s -> picture . key_frame = 1 ; \n s -> picture . pict_type = FF_I_TYPE ; \n avctx -> pix_fmt = s -> sys -> pix_fmt ; \n avctx -> time_base = s -> sys -> time_base ; \n avcodec_set_dimensions ( avctx , s -> sys -> width , s -> sys -> height ) ; \n if ( avctx -> get_buffer ( avctx , & s -> picture ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> picture . interlaced_frame = 1 ; \n s -> picture . top_field_first = 0 ; \n s -> buf = buf ; \n avctx -> execute ( avctx , dv_decode_video_segment , s -> sys -> work_chunks , NULL , \n dv_work_pool_size ( s -> sys ) , sizeof ( DVwork_chunk ) ) ; \n emms_c ( ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> picture ; \n return s -> sys -> frame_size ; \n }", "idx": 21772}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel4_mc32_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_4w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 4 , 1 ) ; \n }", "idx": 21785}
{"project": "FFmpeg", "commit_id": "81efc03f5883cf17a1ad6acedfbb876163d7d06a", "target": 0, "func": "static void put_ebml_utf8 ( ByteIOContext * pb , unsigned int elementid , char * str ) \n { \n put_ebml_binary ( pb , elementid , str , strlen ( str ) ) ; \n }", "idx": 21786}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static void compute_antialias_fixed ( MPADecodeContext * s , GranuleDef * g ) \n { \n int32_t * ptr , * csa ; \n int n , i ; \n if ( g -> block_type == 2 ) { \n if ( ! g -> switch_point ) \n return ; \n n = 1 ; \n } else { \n n = SBLIMIT - 1 ; \n } \n ptr = g -> sb_hybrid + 18 ; \n for ( i = n ; i > 0 ; i -- ) { \n int tmp0 , tmp1 , tmp2 ; \n csa = & csa_table [ 0 ] [ 0 ] ; \n #define INT_AA ( j )  \\ \n  \n  tmp0 = ptr [ -1 - j ] ; \n tmp1 = ptr [ j ] ; \n tmp2 = MULH ( tmp0 + tmp1 , csa [ 0 + 4 * j ] ) ; \n ptr [ -1 - j ] = 4 * ( tmp2 - MULH ( tmp1 , csa [ 2 + 4 * j ] ) ) ; \n ptr [ j ] = 4 * ( tmp2 + MULH ( tmp0 , csa [ 3 + 4 * j ] ) ) ; \n INT_AA ( 0 )  \n INT_AA ( 1 )  \n INT_AA ( 2 )  \n INT_AA ( 3 )  \n INT_AA ( 4 )  \n INT_AA ( 5 )  \n INT_AA ( 6 )  \n INT_AA ( 7 )  \n ptr += 18 ; \n } \n }", "idx": 21787}
{"project": "FFmpeg", "commit_id": "9100d4d6327b077c44e5fdbc8082255f11953978", "target": 1, "func": "static void av_estimate_timings_from_bit_rate ( AVFormatContext * ic ) \n { \n int64_t filesize , duration ; \n int bit_rate , i ; \n AVStream * st ; \n if ( ic -> bit_rate == 0 ) { \n bit_rate = 0 ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n bit_rate += st -> codec -> bit_rate ; \n } \n ic -> bit_rate = bit_rate ; \n } \n if ( ic -> duration == AV_NOPTS_VALUE && \n ic -> bit_rate != 0 && \n ic -> file_size != 0 ) { \n filesize = ic -> file_size ; \n if ( filesize > 0 ) { \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n duration = av_rescale ( 8 * filesize , st -> time_base . den , ic -> bit_rate * ( int64_t ) st -> time_base . num ) ; \n if ( st -> duration == AV_NOPTS_VALUE ) \n st -> duration = duration ; \n } \n } \n } \n }", "idx": 21790}
{"project": "FFmpeg", "commit_id": "3c70251780647d49e09522bbe22758c841e37a9a", "target": 1, "func": "static void sr_1d97_int ( int32_t * p , int i0 , int i1 ) \n { \n int i ; \n if ( i1 <= i0 + 1 ) { \n if ( i0 == 1 ) \n p [ 1 ] = ( p [ 1 ] * I_LFTG_K + ( 1 << 16 ) ) >> 17 ; \n else \n p [ 0 ] = ( p [ 0 ] * I_LFTG_X + ( 1 << 15 ) ) >> 16 ; \n return ; \n } \n extend97_int ( p , i0 , i1 ) ; \n for ( i = ( i0 >> 1 ) - 1 ; i < ( i1 >> 1 ) + 2 ; i ++ ) \n p [ 2 * i ] -= ( I_LFTG_DELTA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = ( i0 >> 1 ) - 1 ; i < ( i1 >> 1 ) + 1 ; i ++ ) \n p [ 2 * i + 1 ] -= ( I_LFTG_GAMMA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = ( i0 >> 1 ) ; i < ( i1 >> 1 ) + 1 ; i ++ ) \n p [ 2 * i ] += ( I_LFTG_BETA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = ( i0 >> 1 ) ; i < ( i1 >> 1 ) ; i ++ ) \n p [ 2 * i + 1 ] += ( I_LFTG_ALPHA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 << 15 ) ) >> 16 ; \n }", "idx": 21791}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void fft ( AC3MDCTContext * mdct , IComplex * z , int ln ) \n { \n int j , l , np , np2 ; \n int nblocks , nloops ; \n register IComplex * p , * q ; \n int tmp_re , tmp_im ; \n np = 1 << ln ; \n for ( j = 0 ; j < np ; j ++ ) { \n int k = av_reverse [ j ] >> ( 8 - ln ) ; \n if ( k < j ) \n FFSWAP ( IComplex , z [ k ] , z [ j ] ) ; \n } \n p = & z [ 0 ] ; \n j = np >> 1 ; \n do { \n BF ( p [ 0 ] . re , p [ 0 ] . im , p [ 1 ] . re , p [ 1 ] . im , \n p [ 0 ] . re , p [ 0 ] . im , p [ 1 ] . re , p [ 1 ] . im ) ; \n p += 2 ; \n } while ( -- j ) ; \n p = & z [ 0 ] ; \n j = np >> 2 ; \n do { \n BF ( p [ 0 ] . re , p [ 0 ] . im , p [ 2 ] . re , p [ 2 ] . im , \n p [ 0 ] . re , p [ 0 ] . im , p [ 2 ] . re , p [ 2 ] . im ) ; \n BF ( p [ 1 ] . re , p [ 1 ] . im , p [ 3 ] . re , p [ 3 ] . im , \n p [ 1 ] . re , p [ 1 ] . im , p [ 3 ] . im , - p [ 3 ] . re ) ; \n p += 4 ; \n } while ( -- j ) ; \n nblocks = np >> 3 ; \n nloops = 1 << 2 ; \n np2 = np >> 1 ; \n do { \n p = z ; \n q = z + nloops ; \n for ( j = 0 ; j < nblocks ; j ++ ) { \n BF ( p -> re , p -> im , q -> re , q -> im , \n p -> re , p -> im , q -> re , q -> im ) ; \n p ++ ; \n q ++ ; \n for ( l = nblocks ; l < np2 ; l += nblocks ) { \n CMUL ( tmp_re , tmp_im , mdct -> costab [ l ] , - mdct -> sintab [ l ] , q -> re , q -> im ) ; \n BF ( p -> re , p -> im , q -> re , q -> im , \n p -> re , p -> im , tmp_re , tmp_im ) ; \n p ++ ; \n q ++ ; \n } \n p += nloops ; \n q += nloops ; \n } \n nblocks = nblocks >> 1 ; \n nloops = nloops << 1 ; \n } while ( nblocks ) ; \n }", "idx": 21793}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int mjpeg_decode_init ( AVCodecContext * avctx ) \n { \n MJpegDecodeContext * s = avctx -> priv_data ; \n MpegEncContext s2 ; \n s -> avctx = avctx ; \n memset ( & s2 , 0 , sizeof ( MpegEncContext ) ) ; \n s2 . avctx = avctx ; \n dsputil_init ( & s2 . dsp , avctx ) ; \n DCT_common_init ( & s2 ) ; \n s -> scantable = s2 . intra_scantable ; \n s -> idct_put = s2 . dsp . idct_put ; \n s -> mpeg_enc_ctx_allocated = 0 ; \n s -> buffer_size = 102400 ; \n s -> buffer = av_malloc ( s -> buffer_size ) ; \n if ( ! s -> buffer ) \n return -1 ; \n s -> start_code = -1 ; \n s -> first_picture = 1 ; \n s -> org_height = avctx -> coded_height ; \n build_vlc ( & s -> vlcs [ 0 ] [ 0 ] , bits_dc_luminance , val_dc_luminance , 12 ) ; \n build_vlc ( & s -> vlcs [ 0 ] [ 1 ] , bits_dc_chrominance , val_dc_chrominance , 12 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 0 ] , bits_ac_luminance , val_ac_luminance , 251 ) ; \n build_vlc ( & s -> vlcs [ 1 ] [ 1 ] , bits_ac_chrominance , val_ac_chrominance , 251 ) ; \n if ( avctx -> flags & CODEC_FLAG_EXTERN_HUFF ) \n { \n av_log ( avctx , AV_LOG_INFO , \" \\n \" ) ; \n init_get_bits ( & s -> gb , avctx -> extradata , avctx -> extradata_size * 8 ) ; \n mjpeg_decode_dht ( s ) ; \n } \n return 0 ; \n }", "idx": 21795}
{"project": "FFmpeg", "commit_id": "083300bea935d125b83f60d7030f78a7ffb0f3df", "target": 1, "func": "int ff_thread_ref_frame ( ThreadFrame * dst , ThreadFrame * src ) \n { \n int ret ; \n dst -> owner = src -> owner ; \n ret = av_frame_ref ( dst -> f , src -> f ) ; \n if ( ret < 0 ) \n return ret ; \n av_assert0 ( ! dst -> progress ) ; \n if ( src -> progress && \n ! ( dst -> progress = av_buffer_ref ( src -> progress ) ) ) { \n ff_thread_release_buffer ( dst -> owner , dst ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 21797}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static void do_udp_write ( void * arg , void * buf , int size ) { \n URLContext * h = arg ; \n UDPContext * s = h -> priv_data ; \n int ret ; \n if ( ! ( h -> flags & AVIO_FLAG_NONBLOCK ) ) { \n ret = ff_network_wait_fd ( s -> udp_fd , 1 ) ; \n if ( ret < 0 ) { \n s -> circular_buffer_error = ret ; \n return ; \n } \n } \n if ( ! s -> is_connected ) { \n ret = sendto ( s -> udp_fd , buf , size , 0 , \n ( struct sockaddr * ) & s -> dest_addr , \n s -> dest_addr_len ) ; \n } else \n ret = send ( s -> udp_fd , buf , size , 0 ) ; \n s -> circular_buffer_error = ret ; \n }", "idx": 21805}
{"project": "FFmpeg", "commit_id": "20d1f6fec1aa2a33c4cf8162e72ca88ead3d389d", "target": 1, "func": "av_cold struct  FFPsyPreprocessContext * ff_psy_preprocess_init ( AVCodecContext * avctx ) \n { \n FFPsyPreprocessContext * ctx ; \n int i ; \n float cutoff_coeff = 0 ; \n ctx = av_mallocz ( sizeof ( FFPsyPreprocessContext ) ) ; \n ctx -> avctx = avctx ; \n if ( avctx -> cutoff > 0 ) \n cutoff_coeff = 2.0 * avctx -> cutoff / avctx -> sample_rate ; \n if ( cutoff_coeff ) \n ctx -> fcoeffs = ff_iir_filter_init_coeffs ( FF_FILTER_TYPE_BUTTERWORTH , FF_FILTER_MODE_LOWPASS , \n FILT_ORDER , cutoff_coeff , 0.0 , 0.0 ) ; \n if ( ctx -> fcoeffs ) { \n ctx -> fstate = av_mallocz ( sizeof ( ctx -> fstate [ 0 ] ) * avctx -> channels ) ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) \n ctx -> fstate [ i ] = ff_iir_filter_init_state ( FILT_ORDER ) ; \n } \n return ctx ; \n }", "idx": 21806}
{"project": "FFmpeg", "commit_id": "cb079b1b2bb1f7d0609ea7196090802a2788913a", "target": 1, "func": "static void png_filter_row ( PNGDSPContext * dsp , uint8_t * dst , int filter_type , \n uint8_t * src , uint8_t * last , int size , int bpp ) \n { \n int i , p , r , g , b , a ; \n switch ( filter_type ) { \n case PNG_FILTER_VALUE_NONE : \n memcpy ( dst , src , size ) ; \n break ; \n case PNG_FILTER_VALUE_SUB : \n for ( i = 0 ; i < bpp ; i ++ ) { \n dst [ i ] = src [ i ] ; \n } \n if ( bpp == 4 ) { \n p = * ( int * ) dst ; \n for ( ; i < size ; i += bpp ) { \n int s = * ( int * ) ( src + i ) ; \n p = ( ( s & 0x7f7f7f7f ) + ( p & 0x7f7f7f7f ) ) ^ ( ( s ^ p ) & 0x80808080 ) ; \n * ( int * ) ( dst + i ) = p ; \n } \n } else { \n #define OP_SUB ( x , s , l )  x+s  \n  \n  UNROLL_FILTER ( OP_SUB ) ; \n } \n break ; \n case PNG_FILTER_VALUE_UP : \n dsp -> add_bytes_l2 ( dst , src , last , size ) ; \n break ; \n case PNG_FILTER_VALUE_AVG : \n for ( i = 0 ; i < bpp ; i ++ ) { \n p = ( last [ i ] >> 1 ) ; \n dst [ i ] = p + src [ i ] ; \n } \n #define OP_AVG ( x , s , l )  (((x + l) >> 1) + s) & 0xff  \n  \n  UNROLL_FILTER ( OP_AVG ) ; \n break ; \n case PNG_FILTER_VALUE_PAETH : \n for ( i = 0 ; i < bpp ; i ++ ) { \n p = last [ i ] ; \n dst [ i ] = p + src [ i ] ; \n } \n if ( bpp > 2 && size > 4 ) { \n int w = bpp == 4 ? size : size - 3 ; \n dsp -> add_paeth_prediction ( dst + i , src + i , last + i , w - i , bpp ) ; \n i = w ; \n } \n ff_add_png_paeth_prediction ( dst + i , src + i , last + i , size - i , bpp ) ; \n break ; \n } \n }", "idx": 21811}
{"project": "FFmpeg", "commit_id": "5331773cc33ba26b9e26ace643d926219e46a17b", "target": 0, "func": "void ff_id3v2_read ( AVFormatContext * s , const char * magic , \n ID3v2ExtraMeta * * extra_meta ) \n { \n id3v2_read_internal ( s -> pb , & s -> metadata , s , magic , extra_meta ) ; \n }", "idx": 21816}
{"project": "FFmpeg", "commit_id": "c4e2a535b3a8b192c144acfaa9f1a7bc8b7f99f3", "target": 1, "func": "static inline void ff_mpeg4_set_one_direct_mv ( MpegEncContext * s , int mx , int my , int i ) { \n static const int tab_size = sizeof ( s -> direct_scale_mv [ 0 ] ) / sizeof ( int16_t ) ; \n static const int tab_bias = ( tab_size / 2 ) ; \n int xy = s -> block_index [ i ] ; \n uint16_t time_pp = s -> pp_time ; \n uint16_t time_pb = s -> pb_time ; \n int p_mx , p_my ; \n p_mx = s -> next_picture . motion_val [ 0 ] [ xy ] [ 0 ] ; \n if ( ( unsigned ) ( p_mx + tab_bias ) < tab_size ) { \n s -> mv [ 0 ] [ i ] [ 0 ] = s -> direct_scale_mv [ 0 ] [ p_mx + tab_bias ] + mx ; \n s -> mv [ 1 ] [ i ] [ 0 ] = mx ? s -> mv [ 0 ] [ i ] [ 0 ] - p_mx \n : s -> direct_scale_mv [ 1 ] [ p_mx + tab_bias ] ; \n } else { \n s -> mv [ 0 ] [ i ] [ 0 ] = p_mx * time_pb / time_pp + mx ; \n s -> mv [ 1 ] [ i ] [ 0 ] = mx ? s -> mv [ 0 ] [ i ] [ 0 ] - p_mx \n : p_mx * ( time_pb - time_pp ) / time_pp ; \n } \n p_my = s -> next_picture . motion_val [ 0 ] [ xy ] [ 1 ] ; \n if ( ( unsigned ) ( p_my + tab_bias ) < tab_size ) { \n s -> mv [ 0 ] [ i ] [ 1 ] = s -> direct_scale_mv [ 0 ] [ p_my + tab_bias ] + my ; \n s -> mv [ 1 ] [ i ] [ 1 ] = my ? s -> mv [ 0 ] [ i ] [ 1 ] - p_my \n : s -> direct_scale_mv [ 1 ] [ p_my + tab_bias ] ; \n } else { \n s -> mv [ 0 ] [ i ] [ 1 ] = p_my * time_pb / time_pp + my ; \n s -> mv [ 1 ] [ i ] [ 1 ] = my ? s -> mv [ 0 ] [ i ] [ 1 ] - p_my \n : p_my * ( time_pb - time_pp ) / time_pp ; \n } \n }", "idx": 21825}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( rgb24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , long width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  assert ( src1 == src2 ) ; \n RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_RGB24 ) ; \n #else \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) { \n int r = src1 [ 3 * i + 0 ] ; \n int g = src1 [ 3 * i + 1 ] ; \n int b = src1 [ 3 * i + 2 ] ; \n dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; \n } \n #endif \n }", "idx": 21827}
{"project": "FFmpeg", "commit_id": "67f9bbbb3f6295ca27da7c367f31c6d65339dd4a", "target": 1, "func": "static int noise ( AVBitStreamFilterContext * bsfc , AVCodecContext * avctx , const char * args , \n uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size , int keyframe ) { \n unsigned int * state = bsfc -> priv_data ; \n int amount = args ? atoi ( args ) : ( * state % 10001 + 1 ) ; \n int i ; \n if ( amount <= 0 ) \n return AVERROR ( EINVAL ) ; \n * poutbuf = av_malloc ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n memcpy ( * poutbuf , buf , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n for ( i = 0 ; i < buf_size ; i ++ ) { \n ( * state ) += ( * poutbuf ) [ i ] + 1 ; \n if ( * state % amount == 0 ) \n ( * poutbuf ) [ i ] = * state ; \n } \n return 1 ; \n }", "idx": 21833}
{"project": "FFmpeg", "commit_id": "91767360d86ac786571593ab11c7291010ab3829", "target": 0, "func": "static void to_meta_with_crop ( AVCodecContext * avctx , AVFrame * p , int * dest ) \n { \n int blockx , blocky , x , y ; \n int luma = 0 ; \n int height = FFMIN ( avctx -> height , C64YRES ) ; \n int width = FFMIN ( avctx -> width , C64XRES ) ; \n uint8_t * src = p -> data [ 0 ] ; \n for ( blocky = 0 ; blocky < C64YRES ; blocky += 8 ) { \n for ( blockx = 0 ; blockx < C64XRES ; blockx += 8 ) { \n for ( y = blocky ; y < blocky + 8 && y < C64YRES ; y ++ ) { \n for ( x = blockx ; x < blockx + 8 && x < C64XRES ; x += 2 ) { \n if ( x < width && y < height ) { \n luma = ( src [ ( x + 0 + y * p -> linesize [ 0 ] ) ] + \n src [ ( x + 1 + y * p -> linesize [ 0 ] ) ] ) / 2 ; \n dest [ 0 ] = luma ; \n } \n dest ++ ; \n } \n } \n } \n } \n }", "idx": 21837}
{"project": "FFmpeg", "commit_id": "4bfdd967a6b2908c9562f9a0ec731e5745cfa796", "target": 0, "func": "static int jpeg2000_read_bitstream_packets ( Jpeg2000DecoderContext * s ) \n { \n int ret = 0 ; \n int tileno ; \n for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { \n Jpeg2000Tile * tile = s -> tile + tileno ; \n if ( ret = init_tile ( s , tileno ) ) \n return ret ; \n s -> g = tile -> tile_part [ 0 ] . tpg ; \n if ( ret = jpeg2000_decode_packets ( s , tile ) ) \n return ret ; \n } \n return 0 ; \n }", "idx": 21838}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuvX_ar ) ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , \n int chrFilterSize , const int16_t * * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n if ( uDest ) { \n x86_reg uv_off = c -> uv_off ; \n YSCALEYUV2YV12X_ACCURATE ( CHR_MMX_FILTER_OFFSET , uDest , chrDstW , 0 )  \n YSCALEYUV2YV12X_ACCURATE ( CHR_MMX_FILTER_OFFSET , vDest - uv_off , chrDstW + uv_off , uv_off )  \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) { \n YSCALEYUV2YV12X_ACCURATE ( ALP_MMX_FILTER_OFFSET , aDest , dstW , 0 )  \n } \n YSCALEYUV2YV12X_ACCURATE ( LUM_MMX_FILTER_OFFSET , dest , dstW , 0 )  \n }", "idx": 21839}
{"project": "FFmpeg", "commit_id": "6369ba3c9cc74becfaad2a8882dff3dd3e7ae3c0", "target": 0, "func": "av_cold void ff_dsputil_init_x86 ( DSPContext * c , AVCodecContext * avctx ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n #if HAVE_7REGS && HAVE_INLINE_ASM  \n  \n  if ( cpu_flags & AV_CPU_FLAG_CMOV ) \n c -> add_hfyu_median_prediction = ff_add_hfyu_median_prediction_cmov ; \n #endif \n if ( cpu_flags & AV_CPU_FLAG_MMX ) \n dsputil_init_mmx ( c , avctx , cpu_flags ) ; \n if ( cpu_flags & AV_CPU_FLAG_MMXEXT ) \n dsputil_init_mmxext ( c , avctx , cpu_flags ) ; \n if ( cpu_flags & AV_CPU_FLAG_SSE ) \n dsputil_init_sse ( c , avctx , cpu_flags ) ; \n if ( cpu_flags & AV_CPU_FLAG_SSE2 ) \n dsputil_init_sse2 ( c , avctx , cpu_flags ) ; \n if ( cpu_flags & AV_CPU_FLAG_SSSE3 ) \n dsputil_init_ssse3 ( c , avctx , cpu_flags ) ; \n if ( cpu_flags & AV_CPU_FLAG_SSE4 ) \n dsputil_init_sse4 ( c , avctx , cpu_flags ) ; \n if ( CONFIG_ENCODERS ) \n ff_dsputilenc_init_mmx ( c , avctx ) ; \n }", "idx": 21840}
{"project": "FFmpeg", "commit_id": "ce99efc6ffedc7a8fbcc23690d9ff9f7e6f4bf44", "target": 0, "func": "matroska_read_close ( AVFormatContext * s )  \n { \n MatroskaDemuxContext * matroska = s -> priv_data ; \n int n = 0 ; \n if ( matroska -> writing_app ) \n av_free ( matroska -> writing_app ) ; \n if ( matroska -> muxing_app ) \n av_free ( matroska -> muxing_app ) ; \n if ( matroska -> index ) \n av_free ( matroska -> index ) ; \n if ( matroska -> packets != NULL ) { \n for ( n = 0 ; n < matroska -> num_packets ; n ++ ) { \n av_free_packet ( matroska -> packets [ n ] ) ; \n av_free ( matroska -> packets [ n ] ) ; \n } \n av_free ( matroska -> packets ) ; \n } \n for ( n = 0 ; n < matroska -> num_tracks ; n ++ ) { \n MatroskaTrack * track = matroska -> tracks [ n ] ; \n if ( track -> codec_id ) \n av_free ( track -> codec_id ) ; \n if ( track -> codec_name ) \n av_free ( track -> codec_name ) ; \n if ( track -> codec_priv ) \n av_free ( track -> codec_priv ) ; \n if ( track -> name ) \n av_free ( track -> name ) ; \n if ( track -> language ) \n av_free ( track -> language ) ; \n av_free ( track ) ; \n } \n memset ( matroska , 0 , sizeof ( MatroskaDemuxContext ) ) ; \n return 0 ; \n }", "idx": 21842}
{"project": "FFmpeg", "commit_id": "1eaae7abb8f208fefb4e8b9e983e61b2499206a3", "target": 0, "func": "av_cold int ff_intrax8_common_init ( IntraX8Context * w , IDCTDSPContext * idsp , \n MpegEncContext * const s ) \n { \n int ret = x8_vlc_init ( ) ; \n if ( ret < 0 ) \n return ret ; \n w -> idsp = * idsp ; \n w -> s = s ; \n w -> prediction_table = av_mallocz ( s -> mb_width * 2 * 2 ) ; \n if ( ! w -> prediction_table ) \n return AVERROR ( ENOMEM ) ; \n ff_init_scantable ( w -> idsp . idct_permutation , & w -> scantable [ 0 ] , \n ff_wmv1_scantable [ 0 ] ) ; \n ff_init_scantable ( w -> idsp . idct_permutation , & w -> scantable [ 1 ] , \n ff_wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( w -> idsp . idct_permutation , & w -> scantable [ 2 ] , \n ff_wmv1_scantable [ 3 ] ) ; \n ff_intrax8dsp_init ( & w -> dsp ) ; \n return 0 ; \n }", "idx": 21844}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_header1 ( GifState * s ) \n { \n ByteIOContext * f = s -> f ; \n uint8_t sig [ 6 ] ; \n int ret , v , n ; \n int has_global_palette ; \n ret = get_buffer ( f , sig , 6 ) ; \n if ( ret != 6 ) \n return -1 ; \n if ( memcmp ( sig , gif87a_sig , 6 ) != 0 && \n memcmp ( sig , gif89a_sig , 6 ) != 0 ) \n return -1 ; \n s -> transparent_color_index = -1 ; \n s -> screen_width = get_le16 ( f ) ; \n s -> screen_height = get_le16 ( f ) ; \n if ( ( unsigned ) s -> screen_width > 32767 \n || ( unsigned ) s -> screen_height > 32767 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n v = get_byte ( f ) ; \n s -> color_resolution = ( ( v & 0x70 ) >> 4 ) + 1 ; \n has_global_palette = ( v & 0x80 ) ; \n s -> bits_per_pixel = ( v & 0x07 ) + 1 ; \n s -> background_color_index = get_byte ( f ) ; \n get_byte ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" , \n s -> screen_width , s -> screen_height , s -> bits_per_pixel , \n has_global_palette ) ; \n #endif \n if ( has_global_palette ) { \n n = 1 << s -> bits_per_pixel ; \n get_buffer ( f , s -> global_palette , n * 3 ) ; \n } \n return 0 ; \n }", "idx": 21847}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4y_c ( uint8_t * dst , int16_t block [ 4 ] [ 16 ] , ptrdiff_t stride ) \n { \n vp8_idct_dc_add_c ( dst + 0 , block [ 0 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 4 , block [ 1 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 8 , block [ 2 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + 12 , block [ 3 ] , stride ) ; \n }", "idx": 21862}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int find_optimal_param ( uint32_t sum , int n ) \n { \n int k ; \n uint32_t sum2 ; \n if ( sum <= n >> 1 ) \n return 0 ; \n sum2 = sum - ( n >> 1 ) ; \n k = av_log2 ( n < 256 ? FASTDIV ( sum2 , n ) : sum2 / n ) ; \n return FFMIN ( k , MAX_RICE_PARAM ) ; \n }", "idx": 21905}
{"project": "FFmpeg", "commit_id": "1e3f77b53a803a6c63fa64829f1be557b8226288", "target": 1, "func": "static void RENAME ( uyvytoyuv420 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n int width , int height , \n int lumStride , int chromStride , int srcStride ) \n { \n int y ; \n const int chromWidth = FF_CEIL_RSHIFT ( width , 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src + 1 , ydst , width ) ; \n if ( y & 1 ) { \n RENAME ( extract_even2avg ) ( src - srcStride , src , udst , vdst , chromWidth ) ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n src += srcStride ; \n ydst += lumStride ; \n } \n __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n }", "idx": 21924}
{"project": "FFmpeg", "commit_id": "a00676e48e49a3d794d6d2063ceca539e945a4a4", "target": 1, "func": "static int read_motion_values ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b ) \n { \n int t , sign , v ; \n const uint8_t * dec_end ; \n CHECK_READ_VAL ( gb , b , t ) ; \n dec_end = b -> cur_dec + t ; \n if ( dec_end > b -> data_end ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( get_bits1 ( gb ) ) { \n v = get_bits ( gb , 4 ) ; \n if ( v ) { \n sign = - get_bits1 ( gb ) ; \n v = ( v ^ sign ) - sign ; \n } \n memset ( b -> cur_dec , v , t ) ; \n b -> cur_dec += t ; \n } else { \n do { \n v = GET_HUFF ( gb , b -> tree ) ; \n if ( v ) { \n sign = - get_bits1 ( gb ) ; \n v = ( v ^ sign ) - sign ; \n } \n * b -> cur_dec ++ = v ; \n } while ( b -> cur_dec < dec_end ) ; \n } \n return 0 ; \n }", "idx": 21929}
{"project": "FFmpeg", "commit_id": "10931720cd55d83e0b933b8a9bb0795fd9e48875", "target": 1, "func": "int av_image_fill_linesizes ( int linesizes [ 4 ] , enum PixelFormat pix_fmt , int width ) \n { \n int i ; \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n int max_step [ 4 ] ; \n int max_step_comp [ 4 ] ; \n memset ( linesizes , 0 , 4 * sizeof ( linesizes [ 0 ] ) ) ; \n if ( ( unsigned ) pix_fmt >= PIX_FMT_NB || desc -> flags & PIX_FMT_HWACCEL ) \n return AVERROR ( EINVAL ) ; \n if ( desc -> flags & PIX_FMT_BITSTREAM ) { \n if ( width > ( INT_MAX - 7 ) / ( desc -> comp [ 0 ] . step_minus1 + 1 ) ) \n return AVERROR ( EINVAL ) ; \n linesizes [ 0 ] = ( width * ( desc -> comp [ 0 ] . step_minus1 + 1 ) + 7 ) >> 3 ; \n return 0 ; \n } \n av_image_fill_max_pixsteps ( max_step , max_step_comp , desc ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n int s = ( max_step_comp [ i ] == 1 || max_step_comp [ i ] == 2 ) ? desc -> log2_chroma_w : 0 ; \n int shifted_w = ( ( width + ( 1 << s ) - 1 ) ) >> s ; \n if ( max_step [ i ] > INT_MAX / shifted_w ) \n return AVERROR ( EINVAL ) ; \n linesizes [ i ] = max_step [ i ] * shifted_w ; \n } \n return 0 ; \n }", "idx": 21931}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static av_cold int libschroedinger_decode_close ( AVCodecContext * avctx ) \n { \n SchroDecoderParams * p_schro_params = avctx -> priv_data ; \n schro_decoder_free ( p_schro_params -> decoder ) ; \n av_freep ( & p_schro_params -> format ) ; \n ff_schro_queue_free ( & p_schro_params -> dec_frame_queue , \n libschroedinger_decode_frame_free ) ; \n return 0 ; \n }", "idx": 21934}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void parse_forced_key_frames ( char * kf , OutputStream * ost , \n AVCodecContext * avctx ) \n { \n char * p ; \n int n = 1 , i ; \n int64_t t ; \n for ( p = kf ; * p ; p ++ ) \n if ( * p == ' ' ) \n n ++ ; \n ost -> forced_kf_count = n ; \n ost -> forced_kf_pts = av_malloc ( sizeof ( * ost -> forced_kf_pts ) * n ) ; \n if ( ! ost -> forced_kf_pts ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n p = kf ; \n for ( i = 0 ; i < n ; i ++ ) { \n char * next = strchr ( p , ' ' ) ; \n if ( next ) \n * next ++ = 0 ; \n t = parse_time_or_die ( \" \" , p , 1 ) ; \n ost -> forced_kf_pts [ i ] = av_rescale_q ( t , AV_TIME_BASE_Q , avctx -> time_base ) ; \n p = next ; \n } \n }", "idx": 21935}
{"project": "FFmpeg", "commit_id": "2fc354f90d61f5f1bb75dbdd808a502dec69cf99", "target": 0, "func": "static int check_output_constraints ( InputStream * ist , OutputStream * ost ) \n { \n OutputFile * of = output_files [ ost -> file_index ] ; \n int ist_index = input_files [ ist -> file_index ] -> ist_index + ist -> st -> index ; \n if ( ost -> source_index != ist_index ) \n return 0 ; \n if ( of -> start_time && ist -> pts < of -> start_time ) \n return 0 ; \n if ( of -> recording_time != INT64_MAX && \n av_compare_ts ( ist -> pts , AV_TIME_BASE_Q , of -> recording_time + of -> start_time , \n ( AVRational ) { 1 , 1000000 } ) >= 0 ) { \n ost -> is_past_recording_time = 1 ; \n return 0 ; \n } \n return 1 ; \n }", "idx": 21937}
{"project": "FFmpeg", "commit_id": "7c7e7c44a6eb68eca861e45cb2ce78f582b12c69", "target": 1, "func": "static av_cold int decode_init_thread_copy ( AVCodecContext * avctx ) \n { \n HYuvContext * s = avctx -> priv_data ; \n int i , ret ; \n if ( ( ret = ff_huffyuv_alloc_temp ( s ) ) < 0 ) { \n ff_huffyuv_common_end ( s ) ; \n return ret ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) \n s -> vlc [ i ] . table = NULL ; \n if ( s -> version >= 2 ) { \n if ( ( ret = read_huffman_tables ( s , avctx -> extradata + 4 , \n avctx -> extradata_size ) ) < 0 ) \n return ret ; \n } else { \n if ( ( ret = read_old_huffman_tables ( s ) ) < 0 ) \n return ret ; \n } \n return 0 ; \n }", "idx": 21942}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int cin_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 18 ) \n return 0 ; \n if ( AV_RL32 ( & p -> buf [ 0 ] ) != 0x55AA0000 ) \n return 0 ; \n if ( AV_RL32 ( & p -> buf [ 12 ] ) != 22050 || p -> buf [ 16 ] != 16 || p -> buf [ 17 ] != 0 ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 21944}
{"project": "FFmpeg", "commit_id": "d0df2934ca63a1d5c31602e6558f341bd738bd07", "target": 0, "func": "static void validate_thread_parameters ( AVCodecContext * avctx ) \n { \n int frame_threading_supported = ( avctx -> codec -> capabilities & CODEC_CAP_FRAME_THREADS ) \n && ! ( avctx -> flags & CODEC_FLAG_TRUNCATED ) \n && ! ( avctx -> flags & CODEC_FLAG_LOW_DELAY ) \n && ! ( avctx -> flags2 & CODEC_FLAG2_CHUNKS ) ; \n if ( avctx -> thread_count == 1 ) { \n avctx -> active_thread_type = 0 ; \n } else if ( frame_threading_supported && ( avctx -> thread_type & FF_THREAD_FRAME ) ) { \n avctx -> active_thread_type = FF_THREAD_FRAME ; \n } else { \n avctx -> active_thread_type = FF_THREAD_SLICE ; \n } \n }", "idx": 21946}
{"project": "FFmpeg", "commit_id": "55188278169c3a1838334d7aa47a1f7a40741690", "target": 1, "func": "static int xan_unpack_luma ( const uint8_t * src , const int src_size , \n uint8_t * dst , const int dst_size ) \n { \n int tree_size , eof ; \n const uint8_t * tree ; \n int bits , mask ; \n int tree_root , node ; \n const uint8_t * dst_end = dst + dst_size ; \n const uint8_t * src_end = src + src_size ; \n tree_size = * src ++ ; \n eof = * src ++ ; \n tree = src - eof * 2 - 2 ; \n tree_root = eof + tree_size ; \n src += tree_size * 2 ; \n node = tree_root ; \n bits = * src ++ ; \n mask = 0x80 ; \n for ( ; ; ) { \n int bit = ! ! ( bits & mask ) ; \n mask >>= 1 ; \n node = tree [ node * 2 + bit ] ; \n if ( node == eof ) \n break ; \n if ( node < eof ) { \n * dst ++ = node ; \n if ( dst > dst_end ) \n break ; \n node = tree_root ; \n } \n if ( ! mask ) { \n bits = * src ++ ; \n if ( src > src_end ) \n break ; \n mask = 0x80 ; \n } \n } \n return dst != dst_end ; \n }", "idx": 21947}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_probe ( AVProbeData * p ) \n { \n int score ; \n quvi_t q ; \n QUVIcode rc ; \n rc = quvi_init ( & q ) ; \n if ( rc != QUVI_OK ) \n return AVERROR ( ENOMEM ) ; \n score = quvi_supported ( q , ( char * ) p -> filename ) == QUVI_OK ? AVPROBE_SCORE_EXTENSION : 0 ; \n quvi_close ( & q ) ; \n return score ; \n }", "idx": 21954}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr16 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x7E0 ) >> 5 ; \n b = ( rgb & 0xF800 ) >> 11 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x3F ) << 5 ) | ( ( r & 0x1F ) << 11 ) ; \n } \n }", "idx": 21955}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb15ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d0 = ( ( uint32_t * ) src1 ) [ i ] ; \n int dl = ( d0 & 0x03E07C1F ) ; \n int dh = ( ( d0 >> 5 ) & 0x03E0F81F ) ; \n int dh2 = ( dh >> 11 ) + ( dh << 21 ) ; \n int d = dh2 + dl ; \n int g = d & 0x7F ; \n int r = ( d >> 10 ) & 0x7F ; \n int b = d >> 21 ; \n dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 - 3 ) ) + 128 ; \n dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 - 3 ) ) + 128 ; \n } \n }", "idx": 21959}
{"project": "FFmpeg", "commit_id": "24cdc39e9dfd2b98e96c96387903bd41313bd0dd", "target": 1, "func": "const char * av_get_string ( void * obj , const char * name , const AVOption * * o_out , char * buf , int buf_len ) { \n const AVOption * o = av_find_opt ( obj , name , NULL , 0 , 0 ) ; \n void * dst ; \n if ( ! o || o -> offset <= 0 ) \n return NULL ; \n if ( o -> type != FF_OPT_TYPE_STRING && ( ! buf || ! buf_len ) ) \n return NULL ; \n dst = ( ( uint8_t * ) obj ) + o -> offset ; \n if ( o_out ) * o_out = o ; \n if ( o -> type == FF_OPT_TYPE_STRING ) \n return dst ; \n switch ( o -> type ) { \n case FF_OPT_TYPE_FLAGS : snprintf ( buf , buf_len , \" \" , * ( int * ) dst ) ; break ; \n case FF_OPT_TYPE_INT : snprintf ( buf , buf_len , \" \" , * ( int * ) dst ) ; break ; \n case FF_OPT_TYPE_INT64 : snprintf ( buf , buf_len , \" \" PRId64 , * ( int64_t * ) dst ) ; break ; \n case FF_OPT_TYPE_FLOAT : snprintf ( buf , buf_len , \" \" , * ( float * ) dst ) ; break ; \n case FF_OPT_TYPE_DOUBLE : snprintf ( buf , buf_len , \" \" , * ( double * ) dst ) ; break ; \n case FF_OPT_TYPE_RATIONAL : snprintf ( buf , buf_len , \" \" , ( ( AVRational * ) dst ) -> num , ( ( AVRational * ) dst ) -> den ) ; break ; \n default : return NULL ; \n } \n return buf ; \n }", "idx": 21960}
{"project": "FFmpeg", "commit_id": "50ce510ac4e3ed093c051738242a9a75aeeb36ce", "target": 0, "func": "static void * attribute_align_arg worker ( void * v ) \n { \n AVCodecContext * avctx = v ; \n SliceThreadContext * c = avctx -> internal -> thread_ctx ; \n unsigned last_execute = 0 ; \n int our_job = c -> job_count ; \n int thread_count = avctx -> thread_count ; \n int self_id ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n self_id = c -> current_job ++ ; \n for ( ; ; ) { \n while ( our_job >= c -> job_count ) { \n if ( c -> current_job == thread_count + c -> job_count ) \n pthread_cond_signal ( & c -> last_job_cond ) ; \n while ( last_execute == c -> current_execute && ! c -> done ) \n pthread_cond_wait ( & c -> current_job_cond , & c -> current_job_lock ) ; \n last_execute = c -> current_execute ; \n our_job = self_id ; \n if ( c -> done ) { \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n return NULL ; \n } \n } \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n c -> rets [ our_job % c -> rets_count ] = c -> func ? c -> func ( avctx , ( char * ) c -> args + our_job * c -> job_size ) : \n c -> func2 ( avctx , c -> args , our_job , self_id ) ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n our_job = c -> current_job ++ ; \n } \n }", "idx": 21975}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static av_cold int wmv2_decode_init ( AVCodecContext * avctx ) { \n Wmv2Context * const w = avctx -> priv_data ; \n if ( avctx -> idct_algo == FF_IDCT_AUTO ) { \n avctx -> idct_algo = FF_IDCT_WMV2 ; \n } \n if ( ff_msmpeg4_decode_init ( avctx ) < 0 ) \n return -1 ; \n ff_wmv2_common_init ( w ) ; \n ff_intrax8_common_init ( & w -> x8 , & w -> s ) ; \n return 0 ; \n }", "idx": 21984}
{"project": "FFmpeg", "commit_id": "c0220c768c7fc933a76c863ebbb0abdf68a88533", "target": 1, "func": "static inline int divide3 ( int x ) \n { \n return ( ( x + 1 ) * 21845 + 10922 ) >> 16 ; \n }", "idx": 21985}
{"project": "FFmpeg", "commit_id": "a625e13208ad0ebf1554aa73c9bf41452520f176", "target": 0, "func": "static void av_always_inline filter_mb_edgeh ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> h264dsp . h264_v_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 21986}
{"project": "FFmpeg", "commit_id": "1918057c8a3bc37c27e476d16736fe8bc76afd34", "target": 0, "func": "static void spatial_compose97i ( IDWTELEM * buffer , int width , int height , int stride ) { \n dwt_compose_t cs ; \n spatial_compose97i_init ( & cs , buffer , height , stride ) ; \n while ( cs . y <= height ) \n spatial_compose97i_dy ( & cs , buffer , width , height , stride ) ; \n }", "idx": 21988}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static void * get_surface ( const AVFrame * frame ) \n { \n return frame -> data [ 3 ] ; \n }", "idx": 21989}
{"project": "FFmpeg", "commit_id": "d50aa006fb3430bedc3872ba10e028a714499625", "target": 1, "func": "static void add_entry ( TiffEncoderContext * s , \n enum TiffTags tag , enum TiffTypes type , int count , \n const void * ptr_val ) \n { \n uint8_t * entries_ptr = s -> entries + 12 * s -> num_entries ; \n av_assert0 ( s -> num_entries < TIFF_MAX_ENTRY ) ; \n bytestream_put_le16 ( & entries_ptr , tag ) ; \n bytestream_put_le16 ( & entries_ptr , type ) ; \n bytestream_put_le32 ( & entries_ptr , count ) ; \n if ( type_sizes [ type ] * count <= 4 ) { \n tnput ( & entries_ptr , count , ptr_val , type , 0 ) ; \n } else { \n bytestream_put_le32 ( & entries_ptr , * s -> buf - s -> buf_start ) ; \n check_size ( s , count * type_sizes2 [ type ] ) ; \n tnput ( s -> buf , count , ptr_val , type , 0 ) ; \n } \n s -> num_entries ++ ; \n }", "idx": 21992}
{"project": "FFmpeg", "commit_id": "4860625236475da20d0da954017e8c7fe412dea2", "target": 1, "func": "yuv2422_2_c_template ( SwsContext * c , const int16_t * buf [ 2 ] , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf [ 2 ] , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n const int16_t * buf0 = buf [ 0 ] , * buf1 = buf [ 1 ] , \n * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] , \n * vbuf0 = vbuf [ 0 ] , * vbuf1 = vbuf [ 1 ] ; \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( ( dstW + 1 ) >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n Y1 = av_clip_uint8 ( Y1 ) ; \n Y2 = av_clip_uint8 ( Y2 ) ; \n U = av_clip_uint8 ( U ) ; \n V = av_clip_uint8 ( V ) ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n }", "idx": 22000}
{"project": "FFmpeg", "commit_id": "206167a295a5c28cec3c38f7308835b0b7e0618f", "target": 1, "func": "SYNTH_FILTER_FUNC ( sse2 ) \n SYNTH_FILTER_FUNC ( avx )  \n av_cold void ff_synth_filter_init_x86 ( SynthFilterContext * s ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( EXTERNAL_SSE ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_sse ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n s -> synth_filter_float = synth_filter_avx ; \n } \n }", "idx": 22007}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_init ( AVCodecContext * avctx ) \n { \n int ret = AVERROR ( EINVAL ) ; \n struct dirent * entry ; \n char node [ PATH_MAX ] ; \n DIR * dirp ; \n V4L2m2mContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n dirp = opendir ( \" \" ) ; \n if ( ! dirp ) \n return AVERROR ( errno ) ; \n for ( entry = readdir ( dirp ) ; entry ; entry = readdir ( dirp ) ) { \n if ( strncmp ( entry -> d_name , \" \" , 5 ) ) \n continue ; \n snprintf ( node , sizeof ( node ) , \" \" , entry -> d_name ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , node ) ; \n strncpy ( s -> devname , node , strlen ( node ) + 1 ) ; \n ret = v4l2_probe_driver ( s ) ; \n if ( ! ret ) \n break ; \n } \n closedir ( dirp ) ; \n if ( ret ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n memset ( s -> devname , 0 , sizeof ( s -> devname ) ) ; \n return ret ; \n } \n av_log ( s -> avctx , AV_LOG_INFO , \" \\n \" , node ) ; \n return v4l2_configure_contexts ( s ) ; \n }", "idx": 22012}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "func": "static int decode_frame_ilbm ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n IffContext * s = avctx -> priv_data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n const uint8_t * buf_end = buf + buf_size ; \n int y , plane ; \n if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( y = 0 ; y < avctx -> height ; y ++ ) { \n uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; \n memset ( row , 0 , avctx -> pix_fmt == PIX_FMT_PAL8 ? avctx -> width : ( avctx -> width * 4 ) ) ; \n for ( plane = 0 ; plane < avctx -> bits_per_coded_sample && buf < buf_end ; plane ++ ) { \n if ( avctx -> pix_fmt == PIX_FMT_PAL8 ) { \n decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , avctx -> bits_per_coded_sample , plane ) ; \n } else { \n decodeplane32 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , avctx -> bits_per_coded_sample , plane ) ; \n } \n buf += s -> planesize ; \n } \n } \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 22014}
{"project": "FFmpeg", "commit_id": "78987a88a88b28d93d03ed6c228bcb33f178444f", "target": 1, "func": "static int get_std_framerate ( int i ) \n { \n if ( i < 60 * 12 ) \n return i * 1001 ; \n else \n return ( ( const int [ ] ) { 24 , 30 , 60 , 12 , 15 } ) [ i - 60 * 12 ] * 1000 * 12 ; \n }", "idx": 22023}
{"project": "FFmpeg", "commit_id": "8e87d146d798ca25d8f3a4520a6deb7946b39d73", "target": 1, "func": "static void subband_scale ( int * dst , int * src , int scale , int offset , int len ) \n { \n int ssign = scale < 0 ? -1 : 1 ; \n int s = FFABS ( scale ) ; \n unsigned int round ; \n int i , out , c = exp2tab [ s & 3 ] ; \n s = offset - ( s >> 2 ) ; \n if ( s > 31 ) { \n for ( i = 0 ; i < len ; i ++ ) { \n dst [ i ] = 0 ; \n } \n } else if ( s > 0 ) { \n round = 1 << ( s - 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n out = ( int ) ( ( ( int64_t ) src [ i ] * c ) >> 32 ) ; \n dst [ i ] = ( ( int ) ( out + round ) >> s ) * ssign ; \n } \n } \n else { \n s = s + 32 ; \n round = 1U << ( s - 1 ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n out = ( int ) ( ( int64_t ) ( ( int64_t ) src [ i ] * c + round ) >> s ) ; \n dst [ i ] = out * ssign ; \n } \n } \n }", "idx": 22026}
{"project": "FFmpeg", "commit_id": "7e4881a2d074a7dfba7ee1990b3e17c9276f985d", "target": 0, "func": "static int atrac3_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n ATRAC3Context * q = avctx -> priv_data ; \n int result = 0 ; \n const uint8_t * databuf ; \n float * samples = data ; \n if ( buf_size < avctx -> block_align ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" , buf_size ) ; \n * data_size = 0 ; \n return buf_size ; \n } \n if ( q -> scrambled_stream ) { \n decode_bytes ( buf , q -> decoded_bytes_buffer , avctx -> block_align ) ; \n databuf = q -> decoded_bytes_buffer ; \n } else { \n databuf = buf ; \n } \n result = decodeFrame ( q , databuf , q -> channels == 2 ? q -> outSamples : & samples ) ; \n if ( result != 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( q -> channels == 2 ) { \n q -> fmt_conv . float_interleave ( samples , ( const float * * ) q -> outSamples , \n 1024 , 2 ) ; \n } \n * data_size = 1024 * q -> channels * av_get_bytes_per_sample ( avctx -> sample_fmt ) ; \n return avctx -> block_align ; \n }", "idx": 22032}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flic_probe ( AVProbeData * p ) \n { \n int magic_number ; \n if ( p -> buf_size < 6 ) \n return 0 ; \n magic_number = AV_RL16 ( & p -> buf [ 4 ] ) ; \n if ( ( magic_number != FLIC_FILE_MAGIC_1 ) && \n ( magic_number != FLIC_FILE_MAGIC_2 ) && \n ( magic_number != FLIC_FILE_MAGIC_3 ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 22033}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int jp2_find_codestream ( J2kDecoderContext * s ) \n { \n uint32_t atom_size ; \n int found_codestream = 0 , search_range = 10 ; \n s -> buf += 12 ; \n while ( ! found_codestream && search_range && s -> buf_end - s -> buf >= 8 ) { \n atom_size = AV_RB32 ( s -> buf ) ; \n if ( AV_RB32 ( s -> buf + 4 ) == JP2_CODESTREAM ) { \n found_codestream = 1 ; \n s -> buf += 8 ; \n } else { \n if ( s -> buf_end - s -> buf < atom_size ) \n return 0 ; \n s -> buf += atom_size ; \n search_range -- ; \n } \n } \n if ( found_codestream ) \n return 1 ; \n return 0 ; \n }", "idx": 22035}
{"project": "FFmpeg", "commit_id": "8a701ef7ddbb2d80ef77b14287d286fc9760f131", "target": 1, "func": "static int decode_pic_timing ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n HEVCSPS * sps = ( HEVCSPS * ) s -> sps_list [ s -> active_seq_parameter_set_id ] -> data ; \n if ( ! sps ) \n return ( AVERROR ( ENOMEM ) ) ; \n if ( sps -> vui . frame_field_info_present_flag ) { \n int pic_struct = get_bits ( gb , 4 ) ; \n s -> picture_struct = AV_PICTURE_STRUCTURE_UNKNOWN ; \n if ( pic_struct == 2 ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n s -> picture_struct = AV_PICTURE_STRUCTURE_BOTTOM_FIELD ; \n } else if ( pic_struct == 1 ) { \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n s -> picture_struct = AV_PICTURE_STRUCTURE_TOP_FIELD ; \n } \n get_bits ( gb , 2 ) ; \n get_bits ( gb , 1 ) ; \n } \n return 1 ; \n }", "idx": 22039}
{"project": "FFmpeg", "commit_id": "bcaa9099b3648b47060e1724a97dc98b63c83702", "target": 1, "func": "static int decode_rle ( uint8_t * bitmap , int linesize , int w , int h , \n const uint8_t * buf , int start , int buf_size , int is_8bit ) \n { \n GetBitContext gb ; \n int bit_len ; \n int x , y , len , color ; \n uint8_t * d ; \n if ( start >= buf_size ) \n bit_len = ( buf_size - start ) * 8 ; \n init_get_bits ( & gb , buf + start , bit_len ) ; \n x = 0 ; \n y = 0 ; \n d = bitmap ; \n for ( ; ; ) { \n if ( get_bits_count ( & gb ) > bit_len ) \n if ( is_8bit ) \n len = decode_run_8bit ( & gb , & color ) ; \n else \n len = decode_run_2bit ( & gb , & color ) ; \n len = FFMIN ( len , w - x ) ; \n memset ( d + x , color , len ) ; \n x += len ; \n if ( x >= w ) { \n y ++ ; \n if ( y >= h ) \n break ; \n d += linesize ; \n x = 0 ; \n align_get_bits ( & gb ) ; \n } \n } \n return 0 ; \n }", "idx": 22041}
{"project": "FFmpeg", "commit_id": "3359246d9a47c3f4418d994853efe17324a0159b", "target": 1, "func": "static int mxf_read_seek ( AVFormatContext * s , int stream_index , int64_t sample_time , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n int64_t seconds ; \n if ( ! s -> bit_rate ) \n return AVERROR_INVALIDDATA ; \n if ( sample_time < 0 ) \n sample_time = 0 ; \n seconds = av_rescale ( sample_time , st -> time_base . num , st -> time_base . den ) ; \n avio_seek ( s -> pb , ( s -> bit_rate * seconds ) >> 3 , SEEK_SET ) ; \n ff_update_cur_dts ( s , st , sample_time ) ; \n return 0 ; \n }", "idx": 22054}
{"project": "FFmpeg", "commit_id": "de64d8cf171c6ecdca22d57f0bdd7efec95d0c0e", "target": 1, "func": "static void qtrle_decode_1bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) \n { \n int rle_code ; \n int pixel_ptr = 0 ; \n int row_inc = s -> frame . linesize [ 0 ] ; \n unsigned char pi0 , pi1 ; \n unsigned char * rgb = s -> frame . data [ 0 ] ; \n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; \n int skip ; \n while ( lines_to_change ) { \n CHECK_STREAM_PTR ( 2 ) ; \n skip = s -> buf [ stream_ptr ++ ] ; \n rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ; \n if ( rle_code == 0 ) \n break ; \n if ( skip & 0x80 ) { \n lines_to_change -- ; \n row_ptr += row_inc ; \n pixel_ptr = row_ptr + 2 * ( skip & 0x7f ) ; \n } else \n pixel_ptr += 2 * skip ; \n CHECK_PIXEL_PTR ( 0 ) ; \n if ( rle_code < 0 ) { \n rle_code = - rle_code ; \n CHECK_STREAM_PTR ( 2 ) ; \n pi0 = s -> buf [ stream_ptr ++ ] ; \n pi1 = s -> buf [ stream_ptr ++ ] ; \n CHECK_PIXEL_PTR ( rle_code * 2 ) ; \n while ( rle_code -- ) { \n rgb [ pixel_ptr ++ ] = pi0 ; \n rgb [ pixel_ptr ++ ] = pi1 ; \n } \n } else { \n rle_code *= 2 ; \n CHECK_STREAM_PTR ( rle_code ) ; \n CHECK_PIXEL_PTR ( rle_code ) ; \n while ( rle_code -- ) \n rgb [ pixel_ptr ++ ] = s -> buf [ stream_ptr ++ ] ; \n } \n } \n }", "idx": 22062}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_mjpeg_init ( AVCodecContext * avctx ) \n { \n return ff_vaapi_encode_init ( avctx , & vaapi_encode_type_mjpeg ) ; \n }", "idx": 22087}
{"project": "FFmpeg", "commit_id": "d7e14c0d103a2c9cca6c50568e09b40d6f48ea19", "target": 0, "func": "static inline int is_yuv_planar ( const PixFmtInfo * ps ) \n { \n return ( ps -> color_type == FF_COLOR_YUV || \n ps -> color_type == FF_COLOR_YUV_JPEG ) && \n ps -> pixel_type == FF_PIXEL_PLANAR ; \n }", "idx": 22088}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_create_kernel ( AVOpenCLKernelEnv * env , const char * kernel_name ) \n { \n cl_int status ; \n int i , ret = 0 ; \n LOCK_OPENCL ; \n if ( strlen ( kernel_name ) + 1 > AV_OPENCL_MAX_KERNEL_NAME_SIZE ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , kernel_name ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n if ( ! env -> kernel ) { \n if ( gpu_env . kernel_count >= MAX_KERNEL_NUM ) { \n av_log ( & openclutils , AV_LOG_ERROR , \n \" \\n \" , \n kernel_name , MAX_KERNEL_NUM ) ; \n ret = AVERROR ( EINVAL ) ; \n goto end ; \n } \n for ( i = 0 ; i < gpu_env . program_count ; i ++ ) { \n env -> kernel = clCreateKernel ( gpu_env . programs [ i ] , kernel_name , & status ) ; \n if ( status == CL_SUCCESS ) \n break ; \n } \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n ret = AVERROR_EXTERNAL ; \n goto end ; \n } \n gpu_env . kernel_count ++ ; \n env -> command_queue = gpu_env . command_queue ; \n av_strlcpy ( env -> kernel_name , kernel_name , sizeof ( env -> kernel_name ) ) ; \n } \n end : \n UNLOCK_OPENCL ; \n return ret ; \n }", "idx": 22090}
{"project": "FFmpeg", "commit_id": "f5695926235c9b2a60af07b21c2d6f1db990cc2a", "target": 0, "func": "static int pulse_write_packet ( AVFormatContext * h , AVPacket * pkt ) \n { \n PulseData * s = h -> priv_data ; \n int size = pkt -> size ; \n uint8_t * buf = pkt -> data ; \n int error ; \n if ( s -> stream_index != pkt -> stream_index ) \n return 0 ; \n if ( ( error = pa_simple_write ( s -> pa , buf , size , & error ) ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , pa_strerror ( error ) ) ; \n return AVERROR ( EIO ) ; \n } \n return 0 ; \n }", "idx": 22092}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_1_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * ubuf0 , const uint16_t * ubuf1 , \n const uint16_t * vbuf0 , const uint16_t * vbuf1 , \n const uint16_t * abuf0 , uint8_t * dest , int dstW , \n int uvalpha , enum PixelFormat dstFormat , \n int flags , int y , enum PixelFormat target )  \n { \n int i ; \n if ( uvalpha < 2048 ) { \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = buf0 [ i * 2 ] >> 7 ; \n int Y2 = buf0 [ i * 2 + 1 ] >> 7 ; \n int U = ubuf1 [ i ] >> 7 ; \n int V = vbuf1 [ i ] >> 7 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n } else { \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = buf0 [ i * 2 ] >> 7 ; \n int Y2 = buf0 [ i * 2 + 1 ] >> 7 ; \n int U = ( ubuf0 [ i ] + ubuf1 [ i ] ) >> 8 ; \n int V = ( vbuf0 [ i ] + vbuf1 [ i ] ) >> 8 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n } \n }", "idx": 22117}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static void encode_signal_range ( VC2EncContext * s ) \n { \n int idx ; \n AVCodecContext * avctx = s -> avctx ; \n const AVPixFmtDescriptor * fmt = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; \n const int depth = fmt -> comp [ 0 ] . depth ; \n if ( depth == 8 && avctx -> color_range == AVCOL_RANGE_JPEG ) { \n idx = 1 ; \n s -> bpp = 1 ; \n s -> diff_offset = 128 ; \n } else if ( depth == 8 && ( avctx -> color_range == AVCOL_RANGE_MPEG || \n avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ) ) { \n idx = 2 ; \n s -> bpp = 1 ; \n s -> diff_offset = 128 ; \n } else if ( depth == 10 ) { \n idx = 3 ; \n s -> bpp = 2 ; \n s -> diff_offset = 512 ; \n } else { \n idx = 4 ; \n s -> bpp = 2 ; \n s -> diff_offset = 2048 ; \n } \n put_bits ( & s -> pb , 1 , ! s -> strict_compliance ) ; \n if ( ! s -> strict_compliance ) \n put_vc2_ue_uint ( & s -> pb , idx ) ; \n }", "idx": 22123}
{"project": "FFmpeg", "commit_id": "08b098169be079c4f124a351fda6764fbcd10e79", "target": 1, "func": "static inline int decode_alpha_block ( const SHQContext * s , GetBitContext * gb , uint8_t last_alpha [ 16 ] , uint8_t * dest , int linesize ) \n { \n uint8_t block [ 128 ] ; \n int i = 0 , x , y ; \n memset ( block , 0 , sizeof ( block ) ) ; \n { \n OPEN_READER ( re , gb ) ; \n for ( ; ; ) { \n int run , level ; \n UPDATE_CACHE_LE ( re , gb ) ; \n GET_VLC ( run , re , gb , ff_dc_alpha_run_vlc_le . table , ALPHA_VLC_BITS , 2 ) ; \n if ( run == 128 ) break ; \n i += run ; \n if ( i >= 128 ) \n return AVERROR_INVALIDDATA ; \n UPDATE_CACHE_LE ( re , gb ) ; \n GET_VLC ( level , re , gb , ff_dc_alpha_level_vlc_le . table , ALPHA_VLC_BITS , 2 ) ; \n block [ i ++ ] = level ; \n } \n CLOSE_READER ( re , gb ) ; \n } \n for ( y = 0 ; y < 8 ; y ++ ) { \n for ( x = 0 ; x < 16 ; x ++ ) { \n last_alpha [ x ] -= block [ y * 16 + x ] ; \n } \n memcpy ( dest , last_alpha , 16 ) ; \n dest += linesize ; \n } \n return 0 ; \n }", "idx": 22131}
{"project": "FFmpeg", "commit_id": "3b9dd906d18f4cd801ceedd20d800a7e53074be9", "target": 0, "func": "static void copy_block ( uint16_t * pdest , uint16_t * psrc , int block_size , int pitch ) \n { \n int y ; \n for ( y = 0 ; y != block_size ; y ++ , pdest += pitch , psrc += pitch ) \n memcpy ( pdest , psrc , block_size * sizeof ( pdest [ 0 ] ) ) ; \n }", "idx": 22134}
{"project": "FFmpeg", "commit_id": "f1ffb01ee9fd3a15c395c3cf6ff362ac5cd668d0", "target": 0, "func": "static double get_audio_clock ( VideoState * is ) \n { \n double pts ; \n int hw_buf_size , bytes_per_sec ; \n pts = is -> audio_clock ; \n hw_buf_size = audio_write_get_buf_size ( is ) ; \n bytes_per_sec = 0 ; \n if ( is -> audio_st ) { \n bytes_per_sec = is -> audio_st -> codec -> sample_rate * \n 2 * is -> audio_st -> codec -> channels ; \n } \n if ( bytes_per_sec ) \n pts -= ( double ) hw_buf_size / bytes_per_sec ; \n return pts ; \n }", "idx": 22136}
{"project": "FFmpeg", "commit_id": "7f4ec4364bc4a73036660c1c6a3c4801db524e9e", "target": 0, "func": "uint8_t * ff_stream_new_side_data ( AVStream * st , enum AVPacketSideDataType type , \n int size ) \n { \n AVPacketSideData * sd , * tmp ; \n int i ; \n uint8_t * data = av_malloc ( size ) ; \n if ( ! data ) \n return NULL ; \n for ( i = 0 ; i < st -> nb_side_data ; i ++ ) { \n sd = & st -> side_data [ i ] ; \n if ( sd -> type == type ) { \n av_freep ( & sd -> data ) ; \n sd -> data = data ; \n sd -> size = size ; \n return sd -> data ; \n } \n } \n tmp = av_realloc_array ( st -> side_data , st -> nb_side_data + 1 , sizeof ( * tmp ) ) ; \n if ( ! tmp ) { \n av_freep ( & data ) ; \n return NULL ; \n } \n st -> side_data = tmp ; \n st -> nb_side_data ++ ; \n sd = & st -> side_data [ st -> nb_side_data - 1 ] ; \n sd -> type = type ; \n sd -> data = data ; \n sd -> size = size ; \n return data ; \n }", "idx": 22138}
{"project": "FFmpeg", "commit_id": "ac47e014bbaf5163871a8beb7522015e0bc27615", "target": 0, "func": "static int adts_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n ADTSContext * adts = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n uint8_t buf [ ADTS_HEADER_SIZE ] ; \n if ( ! pkt -> size ) \n return 0 ; \n if ( adts -> write_adts ) { \n ff_adts_write_frame_header ( adts , buf , pkt -> size , adts -> pce_size ) ; \n avio_write ( pb , buf , ADTS_HEADER_SIZE ) ; \n if ( adts -> pce_size ) { \n avio_write ( pb , adts -> pce_data , adts -> pce_size ) ; \n adts -> pce_size = 0 ; \n } \n } \n avio_write ( pb , pkt -> data , pkt -> size ) ; \n avio_flush ( pb ) ; \n return 0 ; \n }", "idx": 22148}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void generate_silence ( uint8_t * buf , enum AVSampleFormat sample_fmt , size_t size ) \n { \n int fill_char = 0x00 ; \n if ( sample_fmt == AV_SAMPLE_FMT_U8 ) \n fill_char = 0x80 ; \n memset ( buf , fill_char , size ) ; \n }", "idx": 22164}
{"project": "FFmpeg", "commit_id": "a7e7417c41c2c85495b74074b96989c5d68bae22", "target": 0, "func": "void ff_ac3_bit_alloc_calc_psd ( int8_t * exp , int start , int end , int16_t * psd , \n int16_t * band_psd ) \n { \n int bin , j , k , end1 , v ; \n for ( bin = start ; bin < end ; bin ++ ) { \n psd [ bin ] = ( 3072 - ( exp [ bin ] << 7 ) ) ; \n } \n j = start ; \n k = bin_to_band_tab [ start ] ; \n do { \n v = psd [ j ++ ] ; \n end1 = FFMIN ( band_start_tab [ k + 1 ] , end ) ; \n for ( ; j < end1 ; j ++ ) { \n int adr = FFMIN ( FFABS ( v - psd [ j ] ) >> 1 , 255 ) ; \n v = FFMAX ( v , psd [ j ] ) + ff_ac3_log_add_tab [ adr ] ; \n } \n band_psd [ k ] = v ; \n k ++ ; \n } while ( end > band_start_tab [ k ] ) ; \n }", "idx": 22171}
{"project": "FFmpeg", "commit_id": "d8edf1b515ae9fbcea2103305241d130c16e1003", "target": 0, "func": "static void rv40_h_loop_filter ( uint8_t * src , int stride , int dmode , \n int lim_q1 , int lim_p1 , \n int alpha , int beta , int beta2 , int chroma , int edge ) { \n rv40_adaptive_loop_filter ( src , stride , 1 , dmode , lim_q1 , lim_p1 , \n alpha , beta , beta2 , chroma , edge ) ; \n }", "idx": 22182}
{"project": "FFmpeg", "commit_id": "d629f3edaa39b48ac92ac5e5ae8440e35805b792", "target": 0, "func": "static int mono_decode ( COOKContext * q , COOKSubpacket * p , float * mlt_buffer ) \n { \n int category_index [ 128 ] ; \n int quant_index_table [ 102 ] ; \n int category [ 128 ] ; \n int ret ; \n memset ( & category , 0 , sizeof ( category ) ) ; \n memset ( & category_index , 0 , sizeof ( category_index ) ) ; \n if ( ( ret = decode_envelope ( q , p , quant_index_table ) ) < 0 ) \n return ret ; \n q -> num_vectors = get_bits ( & q -> gb , p -> log2_numvector_size ) ; \n categorize ( q , p , quant_index_table , category , category_index ) ; \n expand_category ( q , category , category_index ) ; \n decode_vectors ( q , p , category , quant_index_table , mlt_buffer ) ; \n return 0 ; \n }", "idx": 22193}
{"project": "FFmpeg", "commit_id": "fea471347218be0b8d1313b8f14ea9512e555d76", "target": 0, "func": "static int cuvid_test_dummy_decoder ( AVCodecContext * avctx , \n const CUVIDPARSERPARAMS * cuparseinfo , \n int probed_width , \n int probed_height ) \n { \n CuvidContext * ctx = avctx -> priv_data ; \n CUVIDDECODECREATEINFO cuinfo ; \n CUvideodecoder cudec = 0 ; \n int ret = 0 ; \n memset ( & cuinfo , 0 , sizeof ( cuinfo ) ) ; \n cuinfo . CodecType = cuparseinfo -> CodecType ; \n cuinfo . ChromaFormat = cudaVideoChromaFormat_420 ; \n cuinfo . OutputFormat = cudaVideoSurfaceFormat_NV12 ; \n cuinfo . ulWidth = probed_width ; \n cuinfo . ulHeight = probed_height ; \n cuinfo . ulTargetWidth = cuinfo . ulWidth ; \n cuinfo . ulTargetHeight = cuinfo . ulHeight ; \n cuinfo . target_rect . left = 0 ; \n cuinfo . target_rect . top = 0 ; \n cuinfo . target_rect . right = cuinfo . ulWidth ; \n cuinfo . target_rect . bottom = cuinfo . ulHeight ; \n cuinfo . ulNumDecodeSurfaces = ctx -> nb_surfaces ; \n cuinfo . ulNumOutputSurfaces = 1 ; \n cuinfo . ulCreationFlags = cudaVideoCreate_PreferCUVID ; \n cuinfo . bitDepthMinus8 = 0 ; \n cuinfo . DeinterlaceMode = cudaVideoDeinterlaceMode_Weave ; \n ret = CHECK_CU ( ctx -> cvdl -> cuvidCreateDecoder ( & cudec , & cuinfo ) ) ; \n if ( ret < 0 ) \n return ret ; \n ret = CHECK_CU ( ctx -> cvdl -> cuvidDestroyDecoder ( cudec ) ) ; \n if ( ret < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 22195}
{"project": "FFmpeg", "commit_id": "091bc6ca8c643bfece2c70ff2404c7b31574e1f1", "target": 0, "func": "static void mm_decode_inter ( MmContext * s , int half_horiz , int half_vert , const uint8_t * buf , int buf_size ) \n { \n const int data_ptr = 2 + AV_RL16 ( & buf [ 0 ] ) ; \n int d , r , y ; \n d = data_ptr ; r = 2 ; y = 0 ; \n while ( r < data_ptr ) { \n int i , j ; \n int length = buf [ r ] & 0x7f ; \n int x = buf [ r + 1 ] + ( ( buf [ r ] & 0x80 ) << 1 ) ; \n r += 2 ; \n if ( length == 0 ) { \n y += x ; \n continue ; \n } \n for ( i = 0 ; i < length ; i ++ ) { \n for ( j = 0 ; j < 8 ; j ++ ) { \n int replace = ( buf [ r + i ] >> ( 7 - j ) ) & 1 ; \n if ( replace ) { \n int color = buf [ d ] ; \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n if ( half_vert ) { \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x ] = color ; \n if ( half_horiz ) \n s -> frame . data [ 0 ] [ ( y + 1 ) * s -> frame . linesize [ 0 ] + x + 1 ] = color ; \n } \n d ++ ; \n } \n x += half_horiz ? 2 : 1 ; \n } \n } \n r += length ; \n y += half_vert ? 2 : 1 ; \n } \n }", "idx": 22206}
{"project": "FFmpeg", "commit_id": "159ab4625bd3641e79b564335be8069dca881978", "target": 1, "func": "static int hevc_decode_nal_units ( const uint8_t * buf , int buf_size , HEVCParamSets * ps , \n int is_nalff , int nal_length_size , void * logctx ) \n { \n int i ; \n int ret = 0 ; \n H2645Packet pkt = { 0 } ; \n ret = ff_h2645_packet_split ( & pkt , buf , buf_size , logctx , is_nalff , nal_length_size , AV_CODEC_ID_HEVC , 1 ) ; \n if ( ret < 0 ) { \n goto done ; \n } \n for ( i = 0 ; i < pkt . nb_nals ; i ++ ) { \n H2645NAL * nal = & pkt . nals [ i ] ; \n switch ( nal -> type ) { \n case HEVC_NAL_VPS : ff_hevc_decode_nal_vps ( & nal -> gb , logctx , ps ) ; break ; \n case HEVC_NAL_SPS : ff_hevc_decode_nal_sps ( & nal -> gb , logctx , ps , 1 ) ; break ; \n case HEVC_NAL_PPS : ff_hevc_decode_nal_pps ( & nal -> gb , logctx , ps ) ; break ; \n default : \n av_log ( logctx , AV_LOG_VERBOSE , \" \\n \" , nal -> type ) ; \n break ; \n } \n } \n done : \n ff_h2645_packet_uninit ( & pkt ) ; \n return ret ; \n }", "idx": 22225}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static int rv40_h_loop_filter_strength ( uint8_t * src , int stride , \n int beta , int beta2 , int edge , \n int * p1 , int * q1 ) \n { \n return rv40_loop_filter_strength ( src , stride , 1 , beta , beta2 , edge , p1 , q1 ) ; \n }", "idx": 22239}
{"project": "FFmpeg", "commit_id": "6a287fd7ce5ea69f4eeadda6a049d669eb8efb46", "target": 0, "func": "static int gxf_interleave_packet ( AVFormatContext * s , AVPacket * out , AVPacket * pkt , int flush ) \n { \n GXFContext * gxf = s -> priv_data ; \n AVPacket new_pkt ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n if ( s -> streams [ i ] -> codec -> codec_type == CODEC_TYPE_AUDIO ) { \n GXFStreamContext * sc = & gxf -> streams [ i ] ; \n if ( pkt && pkt -> stream_index == i ) { \n av_fifo_write ( & sc -> audio_buffer , pkt -> data , pkt -> size ) ; \n pkt = NULL ; \n } \n if ( flush || av_fifo_size ( & sc -> audio_buffer ) >= GXF_AUDIO_PACKET_SIZE ) { \n if ( ! pkt && gxf_new_audio_packet ( gxf , sc , & new_pkt , flush ) > 0 ) { \n pkt = & new_pkt ; \n break ; \n } \n } \n } \n } \n return av_interleave_packet_per_dts ( s , out , pkt , flush ) ; \n }", "idx": 22241}
{"project": "FFmpeg", "commit_id": "dc3c3758ce6368aa2f0a9a9b544bce2e130cc4e1", "target": 1, "func": "static int thp_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n ThpDemuxContext * thp = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n unsigned int size ; \n int ret ; \n if ( thp -> audiosize == 0 ) { \n if ( thp -> frame >= thp -> framecnt ) \n return AVERROR_EOF ; \n avio_seek ( pb , thp -> next_frame , SEEK_SET ) ; \n thp -> next_frame += FFMAX ( thp -> next_framesz , 1 ) ; \n thp -> next_framesz = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n size = avio_rb32 ( pb ) ; \n if ( thp -> has_audio ) \n thp -> audiosize = avio_rb32 ( pb ) ; \n else \n thp -> frame ++ ; \n ret = av_get_packet ( pb , pkt , size ) ; \n if ( ret != size ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n pkt -> stream_index = thp -> video_stream_index ; \n } else { \n ret = av_get_packet ( pb , pkt , thp -> audiosize ) ; \n if ( ret != thp -> audiosize ) { \n av_free_packet ( pkt ) ; \n return AVERROR ( EIO ) ; \n } \n pkt -> stream_index = thp -> audio_stream_index ; \n if ( thp -> audiosize >= 8 ) \n pkt -> duration = AV_RB32 ( & pkt -> data [ 4 ] ) ; \n thp -> audiosize = 0 ; \n thp -> frame ++ ; \n } \n return 0 ; \n }", "idx": 22249}
{"project": "FFmpeg", "commit_id": "857cd1f33bcf86005529af2a77f861f884327be5", "target": 0, "func": "static int RENAME ( resample_common ) ( ResampleContext * c , \n DELEM * dst , const DELEM * src , \n int n , int update_ctx ) \n { \n int dst_index ; \n int index = c -> index ; \n int frac = c -> frac ; \n int sample_index = index >> c -> phase_shift ; \n index &= c -> phase_mask ; \n for ( dst_index = 0 ; dst_index < n ; dst_index ++ ) { \n FELEM * filter = ( ( FELEM * ) c -> filter_bank ) + c -> filter_alloc * index ; \n FELEM2 val = 0 ; \n int i ; \n for ( i = 0 ; i < c -> filter_length ; i ++ ) { \n val += src [ sample_index + i ] * ( FELEM2 ) filter [ i ] ; \n } \n OUT ( dst [ dst_index ] , val ) ; \n frac += c -> dst_incr_mod ; \n index += c -> dst_incr_div ; \n if ( frac >= c -> src_incr ) { \n frac -= c -> src_incr ; \n index ++ ; \n } \n sample_index += index >> c -> phase_shift ; \n index &= c -> phase_mask ; \n } \n if ( update_ctx ) { \n c -> frac = frac ; \n c -> index = index ; \n } \n return sample_index ; \n }", "idx": 22251}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , \n uint8_t * ptr , const int linesizes [ 4 ] ) \n { \n int i , total_size , size [ 4 ] , has_plane [ 4 ] ; \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ; \n memset ( size , 0 , sizeof ( size ) ) ; \n memset ( has_plane , 0 , sizeof ( has_plane ) ) ; \n if ( ( unsigned ) pix_fmt >= PIX_FMT_NB || desc -> flags & PIX_FMT_HWACCEL ) \n return AVERROR ( EINVAL ) ; \n data [ 0 ] = ptr ; \n if ( linesizes [ 0 ] > ( INT_MAX - 1024 ) / height ) \n return AVERROR ( EINVAL ) ; \n size [ 0 ] = linesizes [ 0 ] * height ; \n if ( desc -> flags & PIX_FMT_PAL ) { \n size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ; \n data [ 1 ] = ptr + size [ 0 ] ; \n return size [ 0 ] + 256 * 4 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) \n has_plane [ desc -> comp [ i ] . plane ] = 1 ; \n total_size = size [ 0 ] ; \n for ( i = 1 ; i < 4 && has_plane [ i ] ; i ++ ) { \n int h , s = ( i == 1 || i == 2 ) ? desc -> log2_chroma_h : 0 ; \n data [ i ] = data [ i - 1 ] + size [ i - 1 ] ; \n h = ( height + ( 1 << s ) - 1 ) >> s ; \n if ( linesizes [ i ] > INT_MAX / h ) \n return AVERROR ( EINVAL ) ; \n size [ i ] = h * linesizes [ i ] ; \n if ( total_size > INT_MAX - size [ i ] ) \n return AVERROR ( EINVAL ) ; \n total_size += size [ i ] ; \n } \n return total_size ; \n }", "idx": 22253}
{"project": "FFmpeg", "commit_id": "a6cd817a544e4e526f18391bd2c7112dc12d2f94", "target": 1, "func": "static int msf_probe ( AVProbeData * p ) \n { \n if ( memcmp ( p -> buf , \" \" , 3 ) ) \n return 0 ; \n if ( AV_RB32 ( p -> buf + 8 ) <= 0 ) \n return 0 ; \n if ( AV_RB32 ( p -> buf + 16 ) <= 0 ) \n return 0 ; \n return AVPROBE_SCORE_MAX / 3 * 2 ; \n }", "idx": 22266}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_enda ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n int little_endian = get_be16 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , little_endian ) ; \n if ( little_endian == 1 ) { \n switch ( st -> codec -> codec_id ) { \n case CODEC_ID_PCM_S24BE : \n st -> codec -> codec_id = CODEC_ID_PCM_S24LE ; \n break ; \n case CODEC_ID_PCM_S32BE : \n st -> codec -> codec_id = CODEC_ID_PCM_S32LE ; \n break ; \n case CODEC_ID_PCM_F32BE : \n st -> codec -> codec_id = CODEC_ID_PCM_F32LE ; \n break ; \n case CODEC_ID_PCM_F64BE : \n st -> codec -> codec_id = CODEC_ID_PCM_F64LE ; \n break ; \n default : \n break ; \n } \n } \n return 0 ; \n }", "idx": 22295}
{"project": "FFmpeg", "commit_id": "d9837434a91dbb3632df335414aad538e5b0a6e9", "target": 0, "func": "static inline int decode_scalar ( GetBitContext * gb , int k , int limit , int readsamplesize ) { \n int x = get_unary_0_9 ( gb ) ; \n if ( x > 8 ) { \n x = get_bits ( gb , readsamplesize ) ; \n } else { \n if ( k >= limit ) \n k = limit ; \n if ( k != 1 ) { \n int extrabits = show_bits ( gb , k ) ; \n x = ( x << k ) - x ; \n if ( extrabits > 1 ) { \n x += extrabits - 1 ; \n skip_bits ( gb , k ) ; \n } else \n skip_bits ( gb , k - 1 ) ; \n } \n } \n return x ; \n }", "idx": 22296}
{"project": "FFmpeg", "commit_id": "315b0f974252120cfacb0346954a2d817dff279a", "target": 0, "func": "static void opt_b_frames ( const char * arg ) \n { \n b_frames = atoi ( arg ) ; \n if ( b_frames > FF_MAX_B_FRAMES ) { \n fprintf ( stderr , \" \\n \\n \" , FF_MAX_B_FRAMES ) ; \n exit ( 1 ) ; \n } else if ( b_frames < 1 ) { \n fprintf ( stderr , \" \\n \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 22297}
{"project": "FFmpeg", "commit_id": "e1219cdaf9fb4bc8cea410e1caf802373c1bfe51", "target": 0, "func": "static char * shorts2str ( int16_t * sp , int count , const char * sep ) \n { \n int i ; \n char * ap , * ap0 ; \n if ( ! sep ) sep = \" \" ; \n ap = av_malloc ( ( 5 + strlen ( sep ) ) * count ) ; \n if ( ! ap ) \n return NULL ; \n ap0 = ap ; \n ap [ 0 ] = ' \\0 ' ; \n for ( i = 0 ; i < count ; i ++ ) { \n int l = snprintf ( ap , 5 + strlen ( sep ) , \" \" , sp [ i ] , sep ) ; \n ap += l ; \n } \n ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = ' \\0 ' ; \n return ap0 ; \n }", "idx": 22301}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "int ff_raw_video_read_header ( AVFormatContext * s ) \n { \n AVStream * st ; \n FFRawVideoDemuxerContext * s1 = s -> priv_data ; \n AVRational framerate ; \n int ret = 0 ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = s -> iformat -> raw_codec_id ; \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n if ( ( ret = av_parse_video_rate ( & framerate , s1 -> framerate ) ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , s1 -> framerate ) ; \n goto fail ; \n } \n st -> r_frame_rate = st -> avg_frame_rate = framerate ; \n avpriv_set_pts_info ( st , 64 , framerate . den , framerate . num ) ; \n fail : \n return ret ; \n }", "idx": 22304}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb15to16 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n register const uint8_t * s = src ; \n register uint8_t * d = dst ; \n register const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \n __asm__ volatile ( \" \" :: \" \" ( mask15s ) ) ; \n mm_end = end - 15 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * d ) \n : \" m \" ( * s ) \n ) ; \n d += 16 ; \n s += 16 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n mm_end = end - 3 ; \n while ( s < mm_end ) { \n register unsigned x = * ( ( const uint32_t * ) s ) ; \n * ( ( uint32_t * ) d ) = ( x & 0x7FFF7FFF ) + ( x & 0x7FE07FE0 ) ; \n d += 4 ; \n s += 4 ; \n } \n if ( s < end ) { \n register unsigned short x = * ( ( const uint16_t * ) s ) ; \n * ( ( uint16_t * ) d ) = ( x & 0x7FFF ) + ( x & 0x7FE0 ) ; \n } \n }", "idx": 22317}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void FUNC ( idctSparseColPut ) ( pixel * dest , int line_size , \n DCTELEM * col ) \n { \n int a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; \n INIT_CLIP ; \n IDCT_COLS ; \n dest [ 0 ] = CLIP ( ( a0 + b0 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a1 + b1 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a2 + b2 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a3 + b3 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a3 - b3 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a2 - b2 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a1 - b1 ) >> COL_SHIFT ) ; \n dest += line_size ; \n dest [ 0 ] = CLIP ( ( a0 - b0 ) >> COL_SHIFT ) ; \n }", "idx": 22321}
{"project": "FFmpeg", "commit_id": "62b1e3b1031e901105d78e831120de8e4c3e0013", "target": 1, "func": "static int aasc_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AascContext * s = avctx -> priv_data ; \n int compr , i , stride , ret ; \n if ( buf_size < 4 ) \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n compr = AV_RL32 ( buf ) ; \n buf += 4 ; \n buf_size -= 4 ; \n switch ( compr ) { \n case 0 : \n stride = ( avctx -> width * 3 + 3 ) & ~ 3 ; \n for ( i = avctx -> height - 1 ; i >= 0 ; i -- ) { \n memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , buf , avctx -> width * 3 ) ; \n buf += stride ; \n } \n break ; \n case 1 : \n bytestream2_init ( & s -> gb , buf , buf_size ) ; \n ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , 8 , & s -> gb ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , compr ) ; \n } \n * got_frame = 1 ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n return buf_size ; \n }", "idx": 22324}
{"project": "FFmpeg", "commit_id": "311107a65d0105044d1691b5e85d6f30879b0eb4", "target": 0, "func": "int check_codec_match ( AVCodecContext * ccf , AVCodecContext * ccs , int stream ) \n { \n int matches = 1 ; \n #define CHECK_CODEC ( x )   (ccf->x != ccs->x)  \n  \n  if ( CHECK_CODEC ( codec_id ) || CHECK_CODEC ( codec_type ) ) { \n http_log ( \" \\n \" , stream ) ; \n matches = 0 ; \n } else if ( CHECK_CODEC ( bit_rate ) || CHECK_CODEC ( flags ) ) { \n http_log ( \" \\n \" , stream ) ; \n matches = 0 ; \n } else if ( ccf -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n if ( CHECK_CODEC ( time_base . den ) || \n CHECK_CODEC ( time_base . num ) || \n CHECK_CODEC ( width ) || \n CHECK_CODEC ( height ) ) { \n http_log ( \" \\n \" , stream ) ; \n matches = 0 ; \n } \n } else if ( ccf -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n if ( CHECK_CODEC ( sample_rate ) || \n CHECK_CODEC ( channels ) || \n CHECK_CODEC ( frame_size ) ) { \n http_log ( \" \\n \" , stream ) ; \n matches = 0 ; \n } \n } else { \n http_log ( \" \\n \" , stream ) ; \n matches = 0 ; \n } \n return matches ; \n }", "idx": 22332}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "AVFilter * * av_filter_next ( AVFilter * * filter ) \n { \n return filter ? ++ filter : & registered_avfilters [ 0 ] ; \n }", "idx": 22344}
{"project": "FFmpeg", "commit_id": "d9293648147013403de729958ea4c19a5b6c40e4", "target": 1, "func": "static void get_tag ( AVFormatContext * s , const char * key , int type , int len , int type2_size ) \n { \n char * value ; \n int64_t off = avio_tell ( s -> pb ) ; \n if ( ( unsigned ) len >= ( UINT_MAX - 1 ) / 2 ) \n return ; \n value = av_malloc ( 2 * len + 1 ) ; \n if ( ! value ) \n goto finish ; \n if ( type == 0 ) { \n avio_get_str16le ( s -> pb , len , value , 2 * len + 1 ) ; \n } else if ( type == -1 ) { \n avio_read ( s -> pb , value , len ) ; \n value [ len ] = 0 ; \n } else if ( type == 1 ) { \n if ( ! strcmp ( key , \" \" ) ) { \n asf_read_picture ( s , len ) ; \n } else if ( ! strcmp ( key , \" \" ) ) { \n get_id3_tag ( s , len ) ; \n } else { \n av_log ( s , AV_LOG_VERBOSE , \" \\n \" , key ) ; \n } \n goto finish ; \n } else if ( type > 1 && type <= 5 ) { \n uint64_t num = get_value ( s -> pb , type , type2_size ) ; \n snprintf ( value , len , \" \" PRIu64 , num ) ; \n } else if ( type == 6 ) { \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , key ) ; \n goto finish ; \n } else { \n av_log ( s , AV_LOG_DEBUG , \n \" \\n \" , type , key ) ; \n goto finish ; \n } \n if ( * value ) \n av_dict_set ( & s -> metadata , key , value , 0 ) ; \n finish : \n av_freep ( & value ) ; \n avio_seek ( s -> pb , off + len , SEEK_SET ) ; \n }", "idx": 22351}
{"project": "FFmpeg", "commit_id": "d509c743b78da198af385fea362b632292cd00ad", "target": 1, "func": "int dv_produce_packet ( DVDemuxContext * c , AVPacket * pkt , \n uint8_t * buf , int buf_size ) \n { \n int size , i ; \n uint8_t * ppcm [ 4 ] = { 0 } ; \n if ( buf_size < DV_PROFILE_BYTES || \n ! ( c -> sys = dv_frame_profile ( buf ) ) || \n buf_size < c -> sys -> frame_size ) { \n return -1 ; \n } \n size = dv_extract_audio_info ( c , buf ) ; \n for ( i = 0 ; i < c -> ach ; i ++ ) { \n c -> audio_pkt [ i ] . size = size ; \n c -> audio_pkt [ i ] . pts = c -> abytes * 30000 * 8 / c -> ast [ i ] -> codec -> bit_rate ; \n ppcm [ i ] = c -> audio_buf [ i ] ; \n } \n dv_extract_audio ( buf , ppcm , c -> sys ) ; \n c -> abytes += size ; \n if ( c -> sys -> height == 720 ) { \n if ( buf [ 1 ] & 0x0C ) \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n else \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n } \n size = dv_extract_video_info ( c , buf ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = buf ; \n pkt -> size = size ; \n pkt -> flags |= PKT_FLAG_KEY ; \n pkt -> stream_index = c -> vst -> id ; \n pkt -> pts = c -> frames ; \n c -> frames ++ ; \n return size ; \n }", "idx": 22356}
{"project": "FFmpeg", "commit_id": "271c869cc3285dac2b6f2663a87c70bf3ba2b04f", "target": 1, "func": "int ff_rtmp_packet_create ( RTMPPacket * pkt , int channel_id , RTMPPacketType type , \n int timestamp , int size ) \n { \n pkt -> data = av_malloc ( size ) ; \n if ( ! pkt -> data ) \n return AVERROR ( ENOMEM ) ; \n pkt -> data_size = size ; \n pkt -> channel_id = channel_id ; \n pkt -> type = type ; \n pkt -> timestamp = timestamp ; \n pkt -> extra = 0 ; \n pkt -> ts_delta = 0 ; \n return 0 ; ", "idx": 22357}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8l_vertical ) ( uint8_t * _src , int has_topleft , int has_topright , int _stride ) \n { \n int y ; \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n PREDICT_8x8_LOAD_TOP ; \n src [ 0 ] = t0 ; \n src [ 1 ] = t1 ; \n src [ 2 ] = t2 ; \n src [ 3 ] = t3 ; \n src [ 4 ] = t4 ; \n src [ 5 ] = t5 ; \n src [ 6 ] = t6 ; \n src [ 7 ] = t7 ; \n for ( y = 1 ; y < 8 ; y ++ ) { \n ( ( pixel4 * ) ( src + y * stride ) ) [ 0 ] = ( ( pixel4 * ) src ) [ 0 ] ; \n ( ( pixel4 * ) ( src + y * stride ) ) [ 1 ] = ( ( pixel4 * ) src ) [ 1 ] ; \n } \n }", "idx": 22362}
{"project": "FFmpeg", "commit_id": "a71abb714e350b017e1e0c1607e343e1e2f2f8a9", "target": 0, "func": "static int check_intra_pred_mode ( int mode , int mb_x , int mb_y ) \n { \n if ( mode == DC_PRED8x8 ) { \n if ( ! ( mb_x | mb_y ) ) \n mode = DC_128_PRED8x8 ; \n else if ( ! mb_y ) \n mode = LEFT_DC_PRED8x8 ; \n else if ( ! mb_x ) \n mode = TOP_DC_PRED8x8 ; \n } \n return mode ; \n }", "idx": 22363}
{"project": "FFmpeg", "commit_id": "23fe14bb20888038b91e62b16d50fe0b75043a10", "target": 1, "func": "static void vmdaudio_loadsound ( VmdAudioContext * s , unsigned char * data , \n uint8_t * buf , int silence ) \n { \n if ( s -> channels == 2 ) { \n if ( ( s -> block_align & 0x01 ) == 0 ) { \n if ( silence ) \n memset ( data , 0 , s -> block_align * 2 ) ; \n else \n vmdaudio_decode_audio ( s , data , buf , 1 ) ; \n } else { \n if ( silence ) \n memset ( data , 0 , s -> block_align * 2 ) ; \n } \n } else { \n } \n }", "idx": 22371}
{"project": "FFmpeg", "commit_id": "130c6497d2e511d1363cb51ddf68dc9cc2c2f987", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFilterBufferRef * cur_buf ) \n { \n AlphaExtractContext * extract = inlink -> dst -> priv ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * out_buf = \n ff_get_video_buffer ( outlink , AV_PERM_WRITE , outlink -> w , outlink -> h ) ; \n int ret ; \n if ( ! out_buf ) { \n ret = AVERROR ( ENOMEM ) ; \n goto end ; \n } \n avfilter_copy_buffer_ref_props ( out_buf , cur_buf ) ; \n if ( extract -> is_packed_rgb ) { \n int x , y ; \n uint8_t * pin , * pout ; \n for ( y = 0 ; y < out_buf -> video -> h ; y ++ ) { \n pin = cur_buf -> data [ 0 ] + y * cur_buf -> linesize [ 0 ] + extract -> rgba_map [ A ] ; \n pout = out_buf -> data [ 0 ] + y * out_buf -> linesize [ 0 ] ; \n for ( x = 0 ; x < out_buf -> video -> w ; x ++ ) { \n * pout = * pin ; \n pout += 1 ; \n pin += 4 ; \n } \n } \n } else { \n const int linesize = FFMIN ( out_buf -> linesize [ Y ] , cur_buf -> linesize [ A ] ) ; \n int y ; \n for ( y = 0 ; y < out_buf -> video -> h ; y ++ ) { \n memcpy ( out_buf -> data [ Y ] + y * out_buf -> linesize [ Y ] , \n cur_buf -> data [ A ] + y * cur_buf -> linesize [ A ] , \n linesize ) ; \n } \n } \n ret = ff_filter_frame ( outlink , out_buf ) ; \n end : \n avfilter_unref_buffer ( cur_buf ) ; \n return ret ; \n }", "idx": 22380}
{"project": "FFmpeg", "commit_id": "313b52fbfff47ed934cdeccaebda9b3406466575", "target": 1, "func": "static av_cold int alac_decode_init ( AVCodecContext * avctx ) \n { \n ALACContext * alac = avctx -> priv_data ; \n alac -> avctx = avctx ; \n alac -> context_initialized = 0 ; \n alac -> numchannels = alac -> avctx -> channels ; \n return 0 ; \n }", "idx": 22382}
{"project": "FFmpeg", "commit_id": "de7d29063133b240a9fe2c26049b35a6a028c8a1", "target": 1, "func": "AVRational av_d2q ( double d , int max ) \n { \n AVRational a ; \n #define LOG2   0.69314718055994530941723212145817656807550013436025  \n  \n  int exponent ; \n int64_t den ; \n if ( isnan ( d ) ) \n return ( AVRational ) { 0 , 0 } ; \n if ( isinf ( d ) ) \n return ( AVRational ) { d < 0 ? -1 : 1 , 0 } ; \n exponent = FFMAX ( ( int ) ( log ( fabs ( d ) + 1e-20 ) / LOG2 ) , 0 ) ; \n den = 1LL << ( 61 - exponent ) ; \n av_reduce ( & a . num , & a . den , ( int64_t ) ( d * den + 0.5 ) , den , max ) ; \n return a ; \n }", "idx": 22386}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static void selfTest ( uint8_t * src [ 3 ] , int stride [ 3 ] , int w , int h ) { \n enum PixelFormat srcFormat , dstFormat ; \n int srcW , srcH , dstW , dstH ; \n int flags ; \n for ( srcFormat = 0 ; srcFormat < PIX_FMT_NB ; srcFormat ++ ) { \n for ( dstFormat = 0 ; dstFormat < PIX_FMT_NB ; dstFormat ++ ) { \n printf ( \" \\n \" , \n sws_format_name ( srcFormat ) , \n sws_format_name ( dstFormat ) ) ; \n srcW = w ; \n srcH = h ; \n for ( dstW = w - w / 3 ; dstW <= 4 * w / 3 ; dstW += w / 3 ) { \n for ( dstH = h - h / 3 ; dstH <= 4 * h / 3 ; dstH += h / 3 ) { \n for ( flags = 1 ; flags < 33 ; flags *= 2 ) { \n int res ; \n res = doTest ( src , stride , w , h , srcFormat , dstFormat , \n srcW , srcH , dstW , dstH , flags ) ; \n if ( res < 0 ) { \n dstW = 4 * w / 3 ; \n dstH = 4 * h / 3 ; \n flags = 33 ; \n } \n } \n } \n } \n } \n } \n }", "idx": 22388}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "static int dct_max8x8_c ( MpegEncContext * s , uint8_t * src1 , \n uint8_t * src2 , ptrdiff_t stride , int h ) \n { \n LOCAL_ALIGNED_16 ( int16_t , temp ,  [ 64 ] ) ; \n int sum = 0 , i ; \n av_assert2 ( h == 8 ) ; \n s -> pdsp . diff_pixels ( temp , src1 , src2 , stride ) ; \n s -> fdsp . fdct ( temp ) ; \n for ( i = 0 ; i < 64 ; i ++ ) \n sum = FFMAX ( sum , FFABS ( temp [ i ] ) ) ; \n return sum ; \n }", "idx": 22390}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_l00_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 = 0 ; \n uint64_t out0 , out1 ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src0 += src [ lp_cnt * stride - 1 ] ; \n } \n src0 = ( src0 + 2 ) >> 2 ; \n out0 = src0 * 0x0101010101010101 ; \n out1 = 0x8080808080808080 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SD ( out0 , src ) ; \n SD ( out1 , src + stride * 4 ) ; \n src += stride ; \n } \n }", "idx": 22391}
{"project": "FFmpeg", "commit_id": "a483aae7d8bcd37b50bb86345606bbcd2301110b", "target": 0, "func": "static void copy_parameter_set ( void * * to , void * * from , int count , int size ) \n { \n int i ; \n for ( i = 0 ; i < count ; i ++ ) { \n if ( to [ i ] && ! from [ i ] ) \n av_freep ( & to [ i ] ) ; \n else if ( from [ i ] && ! to [ i ] ) \n to [ i ] = av_malloc ( size ) ; \n if ( from [ i ] ) \n memcpy ( to [ i ] , from [ i ] , size ) ; \n } \n }", "idx": 22393}
{"project": "FFmpeg", "commit_id": "255d4e717faa98ab783401acd68a278af32f6360", "target": 0, "func": "alloc_parameter_set ( H264Context * h , void * * vec , const unsigned int id , const unsigned int max , \n const size_t size , const char * name )  \n { \n if ( id >= max ) { \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , name , id ) ; \n return NULL ; \n } \n if ( ! vec [ id ] ) { \n vec [ id ] = av_mallocz ( size ) ; \n if ( vec [ id ] == NULL ) \n av_log ( h -> s . avctx , AV_LOG_ERROR , \" \\n \" , name ) ; \n } \n return vec [ id ] ; \n }", "idx": 22395}
{"project": "FFmpeg", "commit_id": "7c79ec66b6cc25a150d33d7397c8f4310b77e70f", "target": 0, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * ref ) \n { \n FrameStepContext * framestep = inlink -> dst -> priv ; \n if ( ! ( framestep -> frame_count ++ % framestep -> frame_step ) ) { \n framestep -> frame_selected = 1 ; \n return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , ref ) ; \n } else { \n framestep -> frame_selected = 0 ; \n av_frame_free ( & ref ) ; \n return 0 ; \n } \n }", "idx": 22396}
{"project": "FFmpeg", "commit_id": "53df079a730043cd0aa330c9aba7950034b1424f", "target": 1, "func": "static void allocate_buffers ( ALACContext * alac ) \n { \n int chan ; \n for ( chan = 0 ; chan < alac -> numchannels ; chan ++ ) { \n alac -> predicterror_buffer [ chan ] = \n av_malloc ( alac -> setinfo_max_samples_per_frame * 4 ) ; \n alac -> outputsamples_buffer [ chan ] = \n av_malloc ( alac -> setinfo_max_samples_per_frame * 4 ) ; \n alac -> wasted_bits_buffer [ chan ] = av_malloc ( alac -> setinfo_max_samples_per_frame * 4 ) ; \n } \n }", "idx": 22447}
{"project": "FFmpeg", "commit_id": "e7a5854d23e139f5352b59e094387823dbf82522", "target": 0, "func": "static int amr_wb_encode_frame ( AVCodecContext * avctx , \n unsigned char * frame \n , int buf_size , void * data \n ) \n { \n AMRWBContext * s ; \n int size ; \n s = ( AMRWBContext * ) avctx -> priv_data ; \n s -> mode = getWBBitrateMode ( avctx -> bit_rate ) ; \n size = E_IF_encode ( s -> state , s -> mode , data , frame , s -> allow_dtx ) ; \n return size ; \n }", "idx": 22455}
{"project": "FFmpeg", "commit_id": "69494fd5c50742cb7d9ad9ca45b154ab9c33fa19", "target": 0, "func": "static void lag_pred_line ( LagarithContext * l , uint8_t * buf , \n int width , int stride , int line ) \n { \n int L , TL ; \n L = buf [ width - stride - 1 ] ; \n if ( ! line ) { \n L = l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , \n width - 1 , buf [ 0 ] ) ; \n return ; \n } else if ( line == 1 ) { \n TL = l -> avctx -> pix_fmt == PIX_FMT_YUV420P ? buf [ - stride ] : L ; \n } else { \n TL = buf [ width - ( 2 * stride ) - 1 ] ; \n } \n add_lag_median_prediction ( buf , buf - stride , buf , \n width , & L , & TL ) ; \n }", "idx": 22457}
{"project": "FFmpeg", "commit_id": "d38c173dfb4bbee19ec341202c6c79bb0aa2cdad", "target": 0, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * src_buffer ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ATempoContext * atempo = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n int ret = 0 ; \n int n_in = src_buffer -> nb_samples ; \n int n_out = ( int ) ( 0.5 + ( ( double ) n_in ) / atempo -> tempo ) ; \n const uint8_t * src = src_buffer -> data [ 0 ] ; \n const uint8_t * src_end = src + n_in * atempo -> stride ; \n while ( src < src_end ) { \n if ( ! atempo -> dst_buffer ) { \n atempo -> dst_buffer = ff_get_audio_buffer ( outlink , n_out ) ; \n av_frame_copy_props ( atempo -> dst_buffer , src_buffer ) ; \n atempo -> dst = atempo -> dst_buffer -> data [ 0 ] ; \n atempo -> dst_end = atempo -> dst + n_out * atempo -> stride ; \n } \n yae_apply ( atempo , & src , src_end , & atempo -> dst , atempo -> dst_end ) ; \n if ( atempo -> dst == atempo -> dst_end ) { \n ret = push_samples ( atempo , outlink , n_out ) ; \n if ( ret < 0 ) \n goto end ; \n atempo -> request_fulfilled = 1 ; \n } \n } \n atempo -> nsamples_in += n_in ; \n end : \n av_frame_free ( & src_buffer ) ; \n return ret ; \n }", "idx": 22461}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static void add_to_pool ( BufferPoolEntry * buf ) \n { \n AVBufferPool * pool ; \n BufferPoolEntry * cur , * end = buf ; \n if ( ! buf ) \n return ; \n pool = buf -> pool ; \n while ( end -> next ) \n end = end -> next ; \n while ( ( cur = avpriv_atomic_ptr_cas ( ( void * volatile * ) & pool -> pool , NULL , buf ) ) ) { \n cur = get_pool ( pool ) ; \n end -> next = cur ; \n while ( end -> next ) \n end = end -> next ; \n } \n }", "idx": 22488}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_read_seek ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n LibQuviContext * qc = s -> priv_data ; \n return av_seek_frame ( qc -> fmtctx , stream_index , timestamp , flags ) ; \n }", "idx": 22493}
{"project": "FFmpeg", "commit_id": "5688fd77b57f1dd454990dc6fe48c6a3a1729eca", "target": 0, "func": "void ff_limiter_init_x86 ( LimiterDSPContext * dsp , int bpp ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( ARCH_X86_64 && EXTERNAL_SSE2 ( cpu_flags ) ) { \n if ( bpp <= 8 ) { \n dsp -> limiter = ff_limiter_8bit_sse2 ; \n } \n } \n if ( ARCH_X86_64 && EXTERNAL_SSE4 ( cpu_flags ) ) { \n if ( bpp > 8 ) { \n dsp -> limiter = ff_limiter_16bit_sse4 ; \n } \n } \n }", "idx": 22501}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static void dump ( unsigned char * buf , size_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n if ( ( i & 15 ) == 0 ) printf ( \" \" , i ) ; \n printf ( \" \" , buf [ i ] ) ; \n if ( ( i & 15 ) == 15 ) printf ( \" \\n \" ) ; \n } \n printf ( \" \\n \" ) ; \n }", "idx": 22505}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "static int mpegts_raw_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int ret , i ; \n int64_t pcr_h , next_pcr_h , pos ; \n int pcr_l , next_pcr_l ; \n uint8_t pcr_buf [ 12 ] ; \n uint8_t * data ; \n if ( av_new_packet ( pkt , TS_PACKET_SIZE ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n pkt -> pos = avio_tell ( s -> pb ) ; \n ret = read_packet ( s , pkt -> data , ts -> raw_packet_size , & data ) ; \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return ret ; \n } \n if ( data != pkt -> data ) \n memcpy ( pkt -> data , data , ts -> raw_packet_size ) ; \n finished_reading_packet ( s , ts -> raw_packet_size ) ; \n if ( ts -> mpeg2ts_compute_pcr ) { \n if ( parse_pcr ( & pcr_h , & pcr_l , pkt -> data ) == 0 ) { \n pos = avio_tell ( s -> pb ) ; \n for ( i = 0 ; i < MAX_PACKET_READAHEAD ; i ++ ) { \n avio_seek ( s -> pb , pos + i * ts -> raw_packet_size , SEEK_SET ) ; \n avio_read ( s -> pb , pcr_buf , 12 ) ; \n if ( parse_pcr ( & next_pcr_h , & next_pcr_l , pcr_buf ) == 0 ) { \n ts -> pcr_incr = ( ( next_pcr_h - pcr_h ) * 300 + ( next_pcr_l - pcr_l ) ) / \n ( i + 1 ) ; \n break ; \n } \n } \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n ts -> cur_pcr = pcr_h * 300 + pcr_l ; \n } \n pkt -> pts = ts -> cur_pcr ; \n pkt -> duration = ts -> pcr_incr ; \n ts -> cur_pcr += ts -> pcr_incr ; \n } \n pkt -> stream_index = 0 ; \n return 0 ; \n }", "idx": 22508}
{"project": "FFmpeg", "commit_id": "e1c48b7aaedc5deb6f22ced02dfe4f356bf3f421", "target": 0, "func": "static void png_save2 ( const char * filename , uint32_t * bitmap , int w , int h ) \n { \n int x , y , v ; \n FILE * f ; \n char fname [ 40 ] , fname2 [ 40 ] ; \n char command [ 1024 ] ; \n snprintf ( fname , 40 , \" \" , filename ) ; \n f = fopen ( fname , \" \" ) ; \n if ( ! f ) { \n perror ( fname ) ; \n exit ( 1 ) ; \n } \n fprintf ( f , \" \\n \" \n \" \\n \" \n \" \\n \" , \n w , h , 255 ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n v = bitmap [ y * w + x ] ; \n putc ( ( v >> 16 ) & 0xff , f ) ; \n putc ( ( v >> 8 ) & 0xff , f ) ; \n putc ( ( v >> 0 ) & 0xff , f ) ; \n } \n } \n fclose ( f ) ; \n snprintf ( fname2 , 40 , \" \" , filename ) ; \n f = fopen ( fname2 , \" \" ) ; \n if ( ! f ) { \n perror ( fname2 ) ; \n exit ( 1 ) ; \n } \n fprintf ( f , \" \\n \" \n \" \\n \" \n \" \\n \" , \n w , h , 255 ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n v = bitmap [ y * w + x ] ; \n putc ( ( v >> 24 ) & 0xff , f ) ; \n } \n } \n fclose ( f ) ; \n snprintf ( command , 1024 , \" \" , fname2 , fname , filename ) ; \n system ( command ) ; \n snprintf ( command , 1024 , \" \" , fname , fname2 ) ; \n system ( command ) ; \n }", "idx": 22512}
{"project": "FFmpeg", "commit_id": "322428c851980396485d4c6bb4cfe79db43467f8", "target": 1, "func": "int av_opencl_init ( AVDictionary * options , AVOpenCLExternalEnv * ext_opencl_env ) \n { \n int ret = 0 ; \n AVDictionaryEntry * opt_build_entry ; \n AVDictionaryEntry * opt_platform_entry ; \n AVDictionaryEntry * opt_device_entry ; \n LOCK_OPENCL \n if ( ! gpu_env . init_count ) { \n opt_platform_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n opt_device_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n gpu_env . usr_spec_dev_info . platform_idx = -1 ; \n gpu_env . usr_spec_dev_info . dev_idx = -1 ; \n if ( opt_platform_entry ) { \n gpu_env . usr_spec_dev_info . platform_idx = strtol ( opt_platform_entry -> value , NULL , 10 ) ; \n } \n if ( opt_device_entry ) { \n gpu_env . usr_spec_dev_info . dev_idx = strtol ( opt_device_entry -> value , NULL , 10 ) ; \n } \n ret = init_opencl_env ( & gpu_env , ext_opencl_env ) ; \n if ( ret < 0 ) \n goto end ; \n } \n opt_build_entry = av_dict_get ( options , \" \" , NULL , 0 ) ; \n if ( opt_build_entry ) \n ret = compile_kernel_file ( & gpu_env , opt_build_entry -> value ) ; \n else \n ret = compile_kernel_file ( & gpu_env , NULL ) ; \n if ( ret < 0 ) \n goto end ; \n av_assert1 ( gpu_env . kernel_code_count > 0 ) ; \n gpu_env . init_count ++ ; \n end : \n UNLOCK_OPENCL  \n return ret ; \n }", "idx": 22517}
{"project": "FFmpeg", "commit_id": "84a6bc23570c17ce91071e41431103f709c0d595", "target": 0, "func": "static int32_t tag_tree_size ( uint16_t w , uint16_t h ) \n { \n uint32_t res = 0 ; \n while ( w > 1 || h > 1 ) { \n res += w * h ; \n if ( res + 1 >= INT32_MAX ) \n return -1 ; \n w = ( w + 1 ) >> 1 ; \n h = ( h + 1 ) >> 1 ; \n } \n return ( int32_t ) ( res + 1 ) ; \n }", "idx": 22521}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_2r_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] = ( output [ 2 ] [ i ] + output [ 3 ] [ i ] + output [ 4 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 22524}
{"project": "FFmpeg", "commit_id": "18b94669372d3d4b6c51e347587ea64acef9dbb8", "target": 1, "func": "static void ebml_free ( EbmlSyntax * syntax , void * data ) \n { \n int i , j ; \n for ( i = 0 ; syntax [ i ] . id ; i ++ ) { \n void * data_off = ( char * ) data + syntax [ i ] . data_offset ; \n switch ( syntax [ i ] . type ) { \n case EBML_STR : \n case EBML_UTF8 : \n av_freep ( data_off ) ; \n break ; \n case EBML_BIN : \n av_freep ( & ( ( EbmlBin * ) data_off ) -> data ) ; \n break ; \n case EBML_LEVEL1 : \n case EBML_NEST : \n if ( syntax [ i ] . list_elem_size ) { \n EbmlList * list = data_off ; \n char * ptr = list -> elem ; \n for ( j = 0 ; j < list -> nb_elem ; \n j ++ , ptr += syntax [ i ] . list_elem_size ) \n ebml_free ( syntax [ i ] . def . n , ptr ) ; \n av_freep ( & list -> elem ) ; \n } else \n ebml_free ( syntax [ i ] . def . n , data_off ) ; \n default : \n break ; \n } \n } \n }", "idx": 22528}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "int av_thread_message_queue_alloc ( AVThreadMessageQueue * * mq , \n unsigned nelem , \n unsigned elsize ) \n { \n #if HAVE_THREADS  \n  \n  AVThreadMessageQueue * rmq ; \n int ret = 0 ; \n if ( nelem > INT_MAX / elsize ) \n return AVERROR ( EINVAL ) ; \n if ( ! ( rmq = av_mallocz ( sizeof ( * rmq ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n if ( ( ret = pthread_mutex_init ( & rmq -> lock , NULL ) ) ) { \n av_free ( rmq ) ; \n return AVERROR ( ret ) ; \n } \n if ( ( ret = pthread_cond_init ( & rmq -> cond , NULL ) ) ) { \n pthread_mutex_destroy ( & rmq -> lock ) ; \n av_free ( rmq ) ; \n return AVERROR ( ret ) ; \n } \n if ( ! ( rmq -> fifo = av_fifo_alloc ( elsize * nelem ) ) ) { \n pthread_cond_destroy ( & rmq -> cond ) ; \n pthread_mutex_destroy ( & rmq -> lock ) ; \n av_free ( rmq ) ; \n return AVERROR ( ret ) ; \n } \n rmq -> elsize = elsize ; \n * mq = rmq ; \n return 0 ; \n #else \n * mq = NULL ; \n return AVERROR ( ENOSYS ) ; \n #endif \n }", "idx": 22530}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "static void xvid_idct_put ( uint8_t * dest , ptrdiff_t line_size , int16_t * block ) \n { \n ff_xvid_idct ( block ) ; \n ff_put_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 22532}
{"project": "FFmpeg", "commit_id": "3c6607eb6f946ed3e108db3f0694cab7e5a5df7e", "target": 1, "func": "int attribute_align_arg avcodec_encode_video2 ( AVCodecContext * avctx , \n AVPacket * avpkt , \n const AVFrame * frame , \n int * got_packet_ptr ) \n { \n int ret ; \n int user_packet = ! ! avpkt -> data ; \n * got_packet_ptr = 0 ; \n if ( ! ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) && ! frame ) { \n av_free_packet ( avpkt ) ; \n av_init_packet ( avpkt ) ; \n avpkt -> size = 0 ; \n return 0 ; \n } \n if ( av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) ) \n return AVERROR ( EINVAL ) ; \n av_assert0 ( avctx -> codec -> encode2 ) ; \n ret = avctx -> codec -> encode2 ( avctx , avpkt , frame , got_packet_ptr ) ; \n if ( ! ret ) { \n if ( ! * got_packet_ptr ) \n avpkt -> size = 0 ; \n else if ( ! ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) ) \n avpkt -> pts = avpkt -> dts = frame -> pts ; \n if ( ! user_packet && avpkt -> data ) { \n uint8_t * new_data = av_realloc ( avpkt -> data , avpkt -> size ) ; \n if ( new_data ) \n avpkt -> data = new_data ; \n } \n avctx -> frame_number ++ ; \n } \n if ( ret < 0 || ! * got_packet_ptr ) \n av_free_packet ( avpkt ) ; \n emms_c ( ) ; \n return ret ; \n }", "idx": 22533}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int get_str ( ByteIOContext * bc , char * string , int maxlen ) { \n int len = get_v ( bc ) ; \n if ( len && maxlen ) \n get_buffer ( bc , string , FFMIN ( len , maxlen ) ) ; \n while ( len > maxlen ) { \n get_byte ( bc ) ; \n len -- ; \n } \n if ( maxlen ) \n string [ FFMIN ( len , maxlen - 1 ) ] = 0 ; \n if ( maxlen == len ) \n return -1 ; \n else \n return 0 ; \n }", "idx": 22535}
{"project": "FFmpeg", "commit_id": "09d5929f3721613fbb9ac9e74265c89c70df2ce0", "target": 1, "func": "static int tag_tree_decode ( Jpeg2000DecoderContext * s , Jpeg2000TgtNode * node , \n int threshold ) \n { \n Jpeg2000TgtNode * stack [ 30 ] ; \n int sp = -1 , curval = 0 ; \n while ( node && ! node -> vis ) { \n stack [ ++ sp ] = node ; \n node = node -> parent ; \n } \n if ( node ) \n curval = node -> val ; \n else \n curval = stack [ sp ] -> val ; \n while ( curval < threshold && sp >= 0 ) { \n if ( curval < stack [ sp ] -> val ) \n curval = stack [ sp ] -> val ; \n while ( curval < threshold ) { \n int ret ; \n if ( ( ret = get_bits ( s , 1 ) ) > 0 ) { \n stack [ sp ] -> vis ++ ; \n break ; \n } else if ( ! ret ) \n curval ++ ; \n else \n return ret ; \n } \n stack [ sp ] -> val = curval ; \n sp -- ; \n } \n return curval ; \n }", "idx": 22537}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel4_mc22_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_mid_4w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 4 ) ; \n }", "idx": 22564}
{"project": "FFmpeg", "commit_id": "2192f89368d837a4d960a1cabf5475fdeff697e7", "target": 1, "func": "static void load_module ( const char * filename ) \n { \n void * dll ; \n void ( * init_func ) ( void ) ; \n dll = dlopen ( filename , RTLD_NOW ) ; \n if ( ! dll ) { \n fprintf ( stderr , \" \\n \" , \n filename , dlerror ( ) ) ; \n } \n init_func = dlsym ( dll , \" \" ) ; \n if ( ! init_func ) { \n fprintf ( stderr , \n \" \\n \" , \n filename ) ; \n dlclose ( dll ) ; \n } \n init_func ( ) ; \n }", "idx": 22576}
{"project": "FFmpeg", "commit_id": "0a41f47dc17b49acaff6fe469a6ab358986cc449", "target": 0, "func": "DVDemuxContext * avpriv_dv_init_demux ( AVFormatContext * s ) \n { \n DVDemuxContext * c ; \n c = av_mallocz ( sizeof ( DVDemuxContext ) ) ; \n if ( ! c ) \n return NULL ; \n c -> vst = avformat_new_stream ( s , NULL ) ; \n if ( ! c -> vst ) { \n av_free ( c ) ; \n return NULL ; \n } \n c -> sys = NULL ; \n c -> fctx = s ; \n memset ( c -> ast , 0 , sizeof ( c -> ast ) ) ; \n c -> ach = 0 ; \n c -> frames = 0 ; \n c -> abytes = 0 ; \n c -> vst -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n c -> vst -> codec -> codec_id = CODEC_ID_DVVIDEO ; \n c -> vst -> codec -> bit_rate = 25000000 ; \n c -> vst -> start_time = 0 ; \n return c ; \n }", "idx": 22577}
{"project": "FFmpeg", "commit_id": "15cea3695daf3f6363794594982e3816ddc8d90b", "target": 1, "func": "int ff_read_riff_info ( AVFormatContext * s , int64_t size ) \n { \n int64_t start , end , cur ; \n AVIOContext * pb = s -> pb ; \n start = avio_tell ( pb ) ; \n end = start + size ; \n while ( ( cur = avio_tell ( pb ) ) >= 0 && cur <= end - 8 \n ) { \n uint32_t chunk_code ; \n int64_t chunk_size ; \n char key [ 5 ] = { 0 } ; \n char * value ; \n chunk_code = avio_rl32 ( pb ) ; \n chunk_size = avio_rl32 ( pb ) ; \n if ( chunk_size > end || end - chunk_size < cur || chunk_size == UINT_MAX ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n chunk_size += ( chunk_size & 1 ) ; \n value = av_malloc ( chunk_size + 1 ) ; \n if ( ! value ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n AV_WL32 ( key , chunk_code ) ; \n if ( avio_read ( pb , value , chunk_size ) != chunk_size ) { \n av_freep ( key ) ; \n av_freep ( value ) ; \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n value [ chunk_size ] = 0 ; \n av_dict_set ( & s -> metadata , key , value , AV_DICT_DONT_STRDUP_VAL ) ; \n } \n return 0 ; \n }", "idx": 22578}
{"project": "FFmpeg", "commit_id": "62b1e3b1031e901105d78e831120de8e4c3e0013", "target": 1, "func": "static int aasc_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AascContext * s = avctx -> priv_data ; \n int compr , i , stride , ret ; \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n compr = AV_RL32 ( buf ) ; \n buf += 4 ; \n buf_size -= 4 ; \n switch ( compr ) { \n case 0 : \n stride = ( avctx -> width * 3 + 3 ) & ~ 3 ; \n if ( buf_size < stride * avctx -> height ) \n for ( i = avctx -> height - 1 ; i >= 0 ; i -- ) { \n memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , buf , avctx -> width * 3 ) ; \n buf += stride ; \n } \n break ; \n case 1 : \n bytestream2_init ( & s -> gb , buf , buf_size ) ; \n ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , 8 , & s -> gb ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , compr ) ; \n } \n * got_frame = 1 ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n return buf_size ; \n }", "idx": 22585}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static av_always_inline void filter_common ( uint8_t * p , ptrdiff_t stride , \n int is4tap ) \n { \n LOAD_PIXELS \n int a , f1 , f2 ; \n const uint8_t * cm = ff_crop_tab + MAX_NEG_CROP ; \n a = 3 * ( q0 - p0 ) ; \n if ( is4tap ) \n a += clip_int8 ( p1 - q1 ) ; \n a = clip_int8 ( a ) ; \n f1 = FFMIN ( a + 4 , 127 ) >> 3 ; \n f2 = FFMIN ( a + 3 , 127 ) >> 3 ; \n p [ -1 * stride ] = cm [ p0 + f2 ] ; \n p [ 0 * stride ] = cm [ q0 - f1 ] ; \n if ( ! is4tap ) { \n a = ( f1 + 1 ) >> 1 ; \n p [ -2 * stride ] = cm [ p1 + a ] ; \n p [ 1 * stride ] = cm [ q1 - a ] ; \n } \n }", "idx": 22586}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int ffm_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size >= 4 && \n p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && p -> buf [ 2 ] == ' ' && \n p -> buf [ 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX + 1 ; \n return 0 ; \n }", "idx": 22590}
{"project": "FFmpeg", "commit_id": "eb5049227033d946add93c0714bb8a28d94166f1", "target": 1, "func": "static int dxv_decompress_raw ( AVCodecContext * avctx ) \n { \n DXVContext * ctx = avctx -> priv_data ; \n GetByteContext * gbc = & ctx -> gbc ; \n bytestream2_get_buffer ( gbc , ctx -> tex_data , ctx -> tex_size ) ; \n return 0 ; \n }", "idx": 22596}
{"project": "FFmpeg", "commit_id": "6e3ea4461fa9a77964efd2fa7ed1250dd1c8d43d", "target": 0, "func": "static int mxf_read_local_tags ( MXFContext * mxf , KLVPacket * klv , int ( * read_child ) ( ) , int ctx_size , enum MXFMetadataSetType type ) \n { \n ByteIOContext * pb = mxf -> fc -> pb ; \n MXFMetadataSet * ctx = ctx_size ? av_mallocz ( ctx_size ) : mxf ; \n uint64_t klv_end = url_ftell ( pb ) + klv -> length ; \n if ( ! ctx ) \n return -1 ; \n while ( url_ftell ( pb ) + 4 < klv_end ) { \n int tag = get_be16 ( pb ) ; \n int size = get_be16 ( pb ) ; \n uint64_t next = url_ftell ( pb ) + size ; \n UID uid ; \n if ( ! size ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \" \\n \" , tag ) ; \n continue ; \n } \n if ( tag > 0x7FFF ) { \n int i ; \n for ( i = 0 ; i < mxf -> local_tags_count ; i ++ ) { \n int local_tag = AV_RB16 ( mxf -> local_tags + i * 18 ) ; \n if ( local_tag == tag ) { \n memcpy ( uid , mxf -> local_tags + i * 18 + 2 , 16 ) ; \n dprintf ( mxf -> fc , \" \\n \" , local_tag ) ; \n #ifdef DEBUG \n PRINT_KEY ( mxf -> fc , \" \" , uid ) ; \n #endif \n } \n } \n } \n if ( ctx_size && tag == 0x3C0A ) \n get_buffer ( pb , ctx -> uid , 16 ) ; \n else \n read_child ( ctx , pb , tag , size , uid ) ; \n url_fseek ( pb , next , SEEK_SET ) ; \n } \n if ( ctx_size ) ctx -> type = type ; \n return ctx_size ? mxf_add_metadata_set ( mxf , ctx ) : 0 ; \n }", "idx": 22599}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_unpacked8 ( AVCodecContext * avctx , const AVFrame * frame , opj_image_t * image ) \n { \n int compno ; \n int x ; \n int y ; \n int width ; \n int height ; \n int * image_line ; \n int frame_index ; \n const int numcomps = image -> numcomps ; \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n if ( image -> comps [ compno ] . w > frame -> linesize [ compno ] ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n width = avctx -> width / image -> comps [ compno ] . dx ; \n height = avctx -> height / image -> comps [ compno ] . dy ; \n for ( y = 0 ; y < height ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n frame_index = y * frame -> linesize [ compno ] ; \n for ( x = 0 ; x < width ; ++ x ) \n image_line [ x ] = frame -> data [ compno ] [ frame_index ++ ] ; \n for ( ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - 1 ] ; \n } \n } \n for ( ; y < image -> comps [ compno ] . h ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n for ( x = 0 ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - image -> comps [ compno ] . w ] ; \n } \n } \n } \n return 1 ; \n }", "idx": 22606}
{"project": "FFmpeg", "commit_id": "e92a78a4095d69d876bef189225608a35166dc4a", "target": 1, "func": "void ff_write_pass1_stats ( MpegEncContext * s ) \n { \n snprintf ( s -> avctx -> stats_out , 256 , \n \" \" \n \" \\n \" , \n s -> current_picture_ptr -> f . display_picture_number , \n s -> current_picture_ptr -> f . coded_picture_number , \n s -> pict_type , \n s -> current_picture . f . quality , \n s -> i_tex_bits , \n s -> p_tex_bits , \n s -> mv_bits , \n s -> misc_bits , \n s -> f_code , \n s -> b_code , \n s -> current_picture . mc_mb_var_sum , \n s -> current_picture . mb_var_sum , \n s -> i_count , s -> skip_count , \n s -> header_bits ) ; \n }", "idx": 22608}
{"project": "FFmpeg", "commit_id": "1f467220cfd1664782b1fe210bbc9342ad460fd2", "target": 1, "func": "static int draw_slice ( AVFilterLink * inlink , int y0 , int h , int slice_dir ) \n { \n AlphaExtractContext * extract = inlink -> dst -> priv ; \n AVFilterBufferRef * cur_buf = inlink -> cur_buf ; \n AVFilterBufferRef * out_buf = inlink -> dst -> outputs [ 0 ] -> out_buf ; \n if ( extract -> is_packed_rgb ) { \n int x , y ; \n uint8_t * pin , * pout ; \n for ( y = y0 ; y < ( y0 + h ) ; y ++ ) { \n pin = cur_buf -> data [ 0 ] + y * cur_buf -> linesize [ 0 ] + extract -> rgba_map [ A ] ; \n pout = out_buf -> data [ 0 ] + y * out_buf -> linesize [ 0 ] ; \n for ( x = 0 ; x < out_buf -> video -> w ; x ++ ) { \n * pout = * pin ; \n pout += 1 ; \n pin += 4 ; \n } \n } \n } else if ( cur_buf -> linesize [ A ] == out_buf -> linesize [ Y ] ) { \n const int linesize = cur_buf -> linesize [ A ] ; \n memcpy ( out_buf -> data [ Y ] + y0 * linesize , \n cur_buf -> data [ A ] + y0 * linesize , \n linesize * h ) ; \n } else { \n const int linesize = FFMIN ( out_buf -> linesize [ Y ] , cur_buf -> linesize [ A ] ) ; \n int y ; \n for ( y = y0 ; y < ( y0 + h ) ; y ++ ) { \n memcpy ( out_buf -> data [ Y ] + y * out_buf -> linesize [ Y ] , \n cur_buf -> data [ A ] + y * cur_buf -> linesize [ A ] , \n linesize ) ; \n } \n } \n return ff_draw_slice ( inlink -> dst -> outputs [ 0 ] , y0 , h , slice_dir ) ; \n }", "idx": 22614}
{"project": "FFmpeg", "commit_id": "bc0a603c7888c1faf4db580829e103b21442b6e4", "target": 1, "func": "static int sad16_altivec ( void * v , uint8_t * pix1 , uint8_t * pix2 , int line_size , int h ) \n { \n int i ; \n int s ; \n const vector unsigned  int zero = ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; \n vector unsigned  char perm1 , perm2 , * pix1v , * pix2v ; \n vector unsigned  char t1 , t2 , t3 , t4 , t5 ; \n vector unsigned  int sad ; \n vector signed  int sumdiffs ; \n sad = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n perm1 = vec_lvsl ( 0 , pix1 ) ; \n pix1v = ( vector unsigned char * ) pix1 ; \n perm2 = vec_lvsl ( 0 , pix2 ) ; \n pix2v = ( vector unsigned char * ) pix2 ; \n t1 = vec_perm ( pix1v [ 0 ] , pix1v [ 1 ] , perm1 ) ; \n t2 = vec_perm ( pix2v [ 0 ] , pix2v [ 1 ] , perm2 ) ; \n t3 = vec_max ( t1 , t2 ) ; \n t4 = vec_min ( t1 , t2 ) ; \n t5 = vec_sub ( t3 , t4 ) ; \n sad = vec_sum4s ( t5 , sad ) ; \n pix1 += line_size ; \n pix2 += line_size ; \n } \n sumdiffs = vec_sums ( ( vector signed int ) sad , ( vector signed int ) zero ) ; \n sumdiffs = vec_splat ( sumdiffs , 3 ) ; \n vec_ste ( sumdiffs , 0 , & s ) ; \n return s ; \n }", "idx": 22616}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb8tobgr8 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint8_t rgb ; \n rgb = src [ i ] ; \n r = ( rgb & 0x07 ) ; \n g = ( rgb & 0x38 ) >> 3 ; \n b = ( rgb & 0xC0 ) >> 6 ; \n dst [ i ] = ( ( b << 1 ) & 0x07 ) | ( ( g & 0x07 ) << 3 ) | ( ( r & 0x03 ) << 6 ) ; \n } \n }", "idx": 22617}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int mov_read_close ( AVFormatContext * s ) \n { \n MOVContext * mov = s -> priv_data ; \n int i , j ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n MOVStreamContext * sc = st -> priv_data ; \n av_freep ( & sc -> ctts_data ) ; \n for ( j = 0 ; j < sc -> drefs_count ; j ++ ) { \n av_freep ( & sc -> drefs [ j ] . path ) ; \n av_freep ( & sc -> drefs [ j ] . dir ) ; \n } \n av_freep ( & sc -> drefs ) ; \n if ( sc -> pb && sc -> pb != s -> pb ) \n avio_close ( sc -> pb ) ; \n av_freep ( & sc -> chunk_offsets ) ; \n av_freep ( & sc -> stsc_data ) ; \n av_freep ( & sc -> sample_sizes ) ; \n av_freep ( & sc -> keyframes ) ; \n av_freep ( & sc -> stts_data ) ; \n av_freep ( & sc -> stps_data ) ; \n av_freep ( & sc -> rap_group ) ; \n av_freep ( & sc -> display_matrix ) ; \n } \n if ( mov -> dv_demux ) { \n avformat_free_context ( mov -> dv_fctx ) ; \n mov -> dv_fctx = NULL ; \n } \n av_freep ( & mov -> trex_data ) ; \n return 0 ; \n }", "idx": 22629}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int color_request_frame ( AVFilterLink * link ) \n { \n ColorContext * color = link -> src -> priv ; \n AVFilterBufferRef * picref = ff_get_video_buffer ( link , AV_PERM_WRITE , color -> w , color -> h ) ; \n int ret ; \n picref -> video -> pixel_aspect = ( AVRational ) { 1 , 1 } ; \n picref -> pts = color -> pts ++ ; \n picref -> pos = -1 ; \n ret = ff_start_frame ( link , avfilter_ref_buffer ( picref , ~ 0 ) ) ; \n if ( ret < 0 ) \n goto fail ; \n ff_draw_rectangle ( picref -> data , picref -> linesize , \n color -> line , color -> line_step , color -> hsub , color -> vsub , \n 0 , 0 , color -> w , color -> h ) ; \n ret = ff_draw_slice ( link , 0 , color -> h , 1 ) ; \n if ( ret < 0 ) \n goto fail ; \n ret = ff_end_frame ( link ) ; \n fail : \n avfilter_unref_buffer ( picref ) ; \n return ret ; \n }", "idx": 22630}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "int ffv1_init_slice_state ( FFV1Context * f , FFV1Context * fs ) \n { \n int j ; \n fs -> plane_count = f -> plane_count ; \n fs -> transparency = f -> transparency ; \n for ( j = 0 ; j < f -> plane_count ; j ++ ) { \n PlaneContext * const p = & fs -> plane [ j ] ; \n if ( fs -> ac ) { \n if ( ! p -> state ) \n p -> state = av_malloc ( CONTEXT_SIZE * p -> context_count * \n sizeof ( uint8_t ) ) ; \n if ( ! p -> state ) \n return AVERROR ( ENOMEM ) ; \n } else { \n if ( ! p -> vlc_state ) \n p -> vlc_state = av_malloc ( p -> context_count * sizeof ( VlcState ) ) ; \n if ( ! p -> vlc_state ) \n return AVERROR ( ENOMEM ) ; \n } \n } \n if ( fs -> ac > 1 ) { \n for ( j = 1 ; j < 256 ; j ++ ) { \n fs -> c . one_state [ j ] = f -> state_transition [ j ] ; \n fs -> c . zero_state [ 256 - j ] = 256 - fs -> c . one_state [ j ] ; \n } \n } \n return 0 ; \n }", "idx": 22633}
{"project": "FFmpeg", "commit_id": "9a162146ca6cc12ef7ad4a15164349482885962c", "target": 1, "func": "av_cold void ff_snow_common_end ( SnowContext * s ) \n { \n int plane_index , level , orientation , i ; \n av_freep ( & s -> spatial_dwt_buffer ) ; \n av_freep ( & s -> temp_dwt_buffer ) ; \n av_freep ( & s -> spatial_idwt_buffer ) ; \n av_freep ( & s -> temp_idwt_buffer ) ; \n av_freep ( & s -> run_buffer ) ; \n s -> m . me . temp = NULL ; \n av_freep ( & s -> m . me . scratchpad ) ; \n av_freep ( & s -> m . me . map ) ; \n av_freep ( & s -> m . me . score_map ) ; \n av_freep ( & s -> m . obmc_scratchpad ) ; \n av_freep ( & s -> block ) ; \n av_freep ( & s -> scratchbuf ) ; \n av_freep ( & s -> emu_edge_buffer ) ; \n for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { \n av_freep ( & s -> ref_mvs [ i ] ) ; \n av_freep ( & s -> ref_scores [ i ] ) ; \n if ( s -> last_picture [ i ] -> data [ 0 ] ) { \n av_assert0 ( s -> last_picture [ i ] -> data [ 0 ] != s -> current_picture -> data [ 0 ] ) ; \n } \n av_frame_free ( & s -> last_picture [ i ] ) ; \n } \n for ( plane_index = 0 ; plane_index < s -> nb_planes ; plane_index ++ ) { \n for ( level = s -> spatial_decomposition_count - 1 ; level >= 0 ; level -- ) { \n for ( orientation = level ? 1 : 0 ; orientation < 4 ; orientation ++ ) { \n SubBand * b = & s -> plane [ plane_index ] . band [ level ] [ orientation ] ; \n av_freep ( & b -> x_coeff ) ; \n } \n } \n } \n av_frame_free ( & s -> mconly_picture ) ; \n av_frame_free ( & s -> current_picture ) ; \n }", "idx": 22646}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb32tobgr24 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 2 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 3 * i + 0 ] = src [ 4 * i + 2 ] ; \n dst [ 3 * i + 1 ] = src [ 4 * i + 1 ] ; \n dst [ 3 * i + 2 ] = src [ 4 * i + 0 ] ; \n } \n }", "idx": 22650}
{"project": "FFmpeg", "commit_id": "bc29acdc76fdbf70700cdc2f85fc2afb46e19e47", "target": 0, "func": "static int ftp_store ( FTPContext * s ) \n { \n char command [ CONTROL_BUFFER_SIZE ] ; \n const int stor_codes [ ] = { 150 , 0 } ; \n snprintf ( command , sizeof ( command ) , \" \\r \\n \" , s -> path ) ; \n if ( ! ftp_send_command ( s , command , stor_codes , NULL ) ) \n return AVERROR ( EIO ) ; \n s -> state = UPLOADING ; \n return 0 ; \n }", "idx": 22656}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "enum AVPixelFormat avpriv_fmt_v4l2ff ( uint32_t v4l2_fmt , enum AVCodecID codec_id ) \n { \n int i ; \n for ( i = 0 ; avpriv_fmt_conversion_table [ i ] . codec_id != AV_CODEC_ID_NONE ; i ++ ) { \n if ( avpriv_fmt_conversion_table [ i ] . v4l2_fmt == v4l2_fmt && \n avpriv_fmt_conversion_table [ i ] . codec_id == codec_id ) { \n return avpriv_fmt_conversion_table [ i ] . ff_fmt ; \n } \n } \n return AV_PIX_FMT_NONE ; \n }", "idx": 22657}
{"project": "FFmpeg", "commit_id": "e1b8271949d3b70e820b8e08c542ad1586c96f9d", "target": 0, "func": "static void check_consistency ( FFFrameQueue * fq ) \n { \n #if ASSERT_LEVEL >= 2  \n  \n  uint64_t nb_samples = 0 ; \n size_t i ; \n av_assert0 ( fq -> queued == fq -> total_frames_head - fq -> total_frames_tail ) ; \n for ( i = 0 ; i < fq -> queued ; i ++ ) \n nb_samples += bucket ( fq , i ) -> frame -> nb_samples ; \n av_assert0 ( nb_samples == fq -> total_samples_head - fq -> total_samples_tail ) ; \n #endif \n }", "idx": 22663}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static int swf_write_audio ( AVFormatContext * s , const uint8_t * buf , int size ) \n { \n ByteIOContext * pb = & s -> pb ; \n put_swf_tag ( s , TAG_STREAMBLOCK | TAG_LONG ) ; \n put_buffer ( pb , buf , size ) ; \n put_swf_end_tag ( s ) ; \n put_flush_packet ( & s -> pb ) ; \n return 0 ; \n }", "idx": 22670}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_h265_init_fixed_qp ( AVCodecContext * avctx ) \n { \n VAAPIEncodeContext * ctx = avctx -> priv_data ; \n VAAPIEncodeH265Context * priv = ctx -> priv_data ; \n VAAPIEncodeH265Options * opt = ctx -> codec_options ; \n priv -> fixed_qp_p = opt -> qp ; \n if ( avctx -> i_quant_factor > 0.0 ) \n priv -> fixed_qp_idr = ( int ) ( ( priv -> fixed_qp_p * avctx -> i_quant_factor + \n avctx -> i_quant_offset ) + 0.5 ) ; \n else \n priv -> fixed_qp_idr = priv -> fixed_qp_p ; \n if ( avctx -> b_quant_factor > 0.0 ) \n priv -> fixed_qp_b = ( int ) ( ( priv -> fixed_qp_p * avctx -> b_quant_factor + \n avctx -> b_quant_offset ) + 0.5 ) ; \n else \n priv -> fixed_qp_b = priv -> fixed_qp_p ; \n av_log ( avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , \n priv -> fixed_qp_idr , priv -> fixed_qp_p , priv -> fixed_qp_b ) ; \n return 0 ; \n }", "idx": 22674}
{"project": "FFmpeg", "commit_id": "d89dc06a96c32e5ccf9d56d7bc8549e84dfbc517", "target": 1, "func": "static inline void xchg_mb_border ( H264Context * h , uint8_t * src_y , uint8_t * src_cb , uint8_t * src_cr , int linesize , int uvlinesize , int xchg ) { \n MpegEncContext * const s = & h -> s ; \n int temp8 , i ; \n uint64_t temp64 ; \n src_y -= linesize + 1 ; \n src_cb -= uvlinesize + 1 ; \n src_cr -= uvlinesize + 1 ; \n #define XCHG ( a , b , t , xchg ) \\ \n  \n  t = a ; \n if ( xchg ) \n a = b ; \n b = t ; \n for ( i = 0 ; i < 17 ; i ++ ) { \n XCHG ( h -> left_border [ i ] , src_y [ i * linesize ] , temp8 , xchg ) ; \n } \n XCHG ( * ( uint64_t * ) ( h -> top_border [ s -> mb_x ] + 0 ) , * ( uint64_t * ) ( src_y + 1 ) , temp64 , xchg ) ; \n XCHG ( * ( uint64_t * ) ( h -> top_border [ s -> mb_x ] + 8 ) , * ( uint64_t * ) ( src_y + 9 ) , temp64 , 1 ) ; \n if ( ! ( s -> flags & CODEC_FLAG_GRAY ) ) { \n for ( i = 0 ; i < 9 ; i ++ ) { \n XCHG ( h -> left_border [ i + 17 ] , src_cb [ i * uvlinesize ] , temp8 , xchg ) ; \n XCHG ( h -> left_border [ i + 17 + 9 ] , src_cr [ i * uvlinesize ] , temp8 , xchg ) ; \n } \n XCHG ( * ( uint64_t * ) ( h -> top_border [ s -> mb_x ] + 16 ) , * ( uint64_t * ) ( src_cb + 1 ) , temp64 , 1 ) ; \n XCHG ( * ( uint64_t * ) ( h -> top_border [ s -> mb_x ] + 24 ) , * ( uint64_t * ) ( src_cr + 1 ) , temp64 , 1 ) ; \n } \n }", "idx": 22679}
{"project": "FFmpeg", "commit_id": "37ecd67b5e149e55d71b1d8950abc5476d56999a", "target": 1, "func": "void ff_free_stream ( AVFormatContext * s , AVStream * st ) { \n av_assert0 ( s -> nb_streams > 0 ) ; \n av_assert0 ( s -> streams [ s -> nb_streams - 1 ] == st ) ; \n if ( st -> codec ) { \n avcodec_close ( st -> codec ) ; \n } \n if ( st -> parser ) { \n av_parser_close ( st -> parser ) ; \n } \n if ( st -> attached_pic . data ) \n av_free_packet ( & st -> attached_pic ) ; \n av_dict_free ( & st -> metadata ) ; \n av_freep ( & st -> probe_data . buf ) ; \n av_freep ( & st -> index_entries ) ; \n av_freep ( & st -> codec -> extradata ) ; \n av_freep ( & st -> codec -> subtitle_header ) ; \n av_freep ( & st -> codec ) ; \n av_freep ( & st -> priv_data ) ; \n if ( st -> info ) \n av_freep ( & st -> info -> duration_error ) ; \n av_freep ( & st -> info ) ; \n av_freep ( & s -> streams [ -- s -> nb_streams ] ) ; \n }", "idx": 22685}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred8x16_vertical_add ) ( uint8_t * pix , const int * block_offset , \n const int16_t * block , ptrdiff_t stride ) \n { \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) \n FUNCC ( pred4x4_vertical_add ) ( pix + block_offset [ i ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n for ( i = 4 ; i < 8 ; i ++ ) \n FUNCC ( pred4x4_vertical_add ) ( pix + block_offset [ i + 4 ] , block + i * 16 * sizeof ( pixel ) , stride ) ; \n }", "idx": 22690}
{"project": "FFmpeg", "commit_id": "46cb2f6a2928a7fa4bee3f09b0475ccb8cdd2064", "target": 1, "func": "static int cmv_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n CmvContext * s = avctx -> priv_data ; \n const uint8_t * buf_end = buf + buf_size ; \n if ( AV_RL32 ( buf ) == MVIh_TAG || AV_RB32 ( buf ) == MVIh_TAG ) { \n cmv_process_header ( s , buf + EA_PREAMBLE_SIZE , buf_end ) ; \n return buf_size ; \n } \n if ( av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) \n return -1 ; \n if ( s -> last2_frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> last2_frame ) ; \n FFSWAP ( AVFrame , s -> last_frame , s -> last2_frame ) ; \n FFSWAP ( AVFrame , s -> frame , s -> last_frame ) ; \n s -> frame . reference = 1 ; \n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID ; \n if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ; \n buf += EA_PREAMBLE_SIZE ; \n if ( ( buf [ 0 ] & 1 ) ) { \n cmv_decode_inter ( s , buf + 2 , buf_end ) ; \n s -> frame . key_frame = 0 ; \n s -> frame . pict_type = AV_PICTURE_TYPE_P ; \n } else { \n s -> frame . key_frame = 1 ; \n s -> frame . pict_type = AV_PICTURE_TYPE_I ; \n cmv_decode_intra ( s , buf + 2 , buf_end ) ; \n } \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 22694}
{"project": "FFmpeg", "commit_id": "aa06658248a49f6ebf381894b9426cdfb377cd32", "target": 1, "func": "static int dvvideo_close ( AVCodecContext * c ) \n { \n DVVideoContext * s = c -> priv_data ; \n av_free ( s -> dv_anchor ) ; \n return 0 ; \n }", "idx": 22704}
{"project": "FFmpeg", "commit_id": "4391805916a1557278351f25428d0145b1073520", "target": 1, "func": "rgb16_32ToUV_half_c_template ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src , int width , \n enum PixelFormat origin , \n int shr , int shg , int shb , int shp , \n int maskr , int maskg , int maskb , \n int rsh , int gsh , int bsh , int S )  \n { \n const int ru = RU << rsh , gu = GU << gsh , bu = BU << bsh , \n rv = RV << rsh , gv = GV << gsh , bv = BV << bsh , \n rnd = 257 << S , maskgx = ~ ( maskr | maskb ) ; \n int i ; \n maskr |= maskr << 1 ; maskb |= maskb << 1 ; maskg |= maskg << 1 ; \n for ( i = 0 ; i < width ; i ++ ) { \n int px0 = input_pixel ( 2 * i + 0 ) >> shp ; \n int px1 = input_pixel ( 2 * i + 1 ) >> shp ; \n int b , r , g = ( px0 & maskgx ) + ( px1 & maskgx ) ; \n int rb = px0 + px1 - g ; \n b = ( rb & maskb ) >> shb ; \n if ( shp || origin == PIX_FMT_BGR565LE || origin == PIX_FMT_BGR565BE || \n origin == PIX_FMT_RGB565LE || origin == PIX_FMT_RGB565BE ) { \n g >>= shg ; \n } else { \n g = ( g & maskg ) >> shg ; \n } \n r = ( rb & maskr ) >> shr ; \n dstU [ i ] = ( ru * r + gu * g + bu * b + rnd ) >> ( S + 1 ) ; \n dstV [ i ] = ( rv * r + gv * g + bv * b + rnd ) >> ( S + 1 ) ; \n } \n }", "idx": 22708}
{"project": "FFmpeg", "commit_id": "c94f9e854228e0ea00e1de8769d8d3f7cab84a55", "target": 1, "func": "int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) \n { \n void * * ptrptr = ptr ; \n * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; \n if ( ! * ptrptr && ! ( nmemb && size ) ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 22715}
{"project": "FFmpeg", "commit_id": "f1c21a200bcbc9bbd54fc336016ac16c2e015012", "target": 1, "func": "static void read_table ( AVFormatContext * avctx , AVStream * st , \n int ( * parse ) ( AVFormatContext * avctx , AVStream * st , \n const char * name , int size ) ) \n { \n int count , i ; \n AVIOContext * pb = avctx -> pb ; \n avio_skip ( pb , 4 ) ; \n count = avio_rb32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n for ( i = 0 ; i < count ; i ++ ) { \n char name [ 17 ] ; \n int size ; \n avio_read ( pb , name , 16 ) ; \n name [ sizeof ( name ) - 1 ] = 0 ; \n size = avio_rb32 ( pb ) ; \n if ( parse ( avctx , st , name , size ) < 0 ) { \n avpriv_request_sample ( avctx , \" \" , name ) ; \n avio_skip ( pb , size ) ; \n } \n } \n }", "idx": 22720}
{"project": "FFmpeg", "commit_id": "ae100046ca32b0b83031a60d0c3cdfc5ceb9f874", "target": 0, "func": "static int avi_extract_stream_metadata ( AVFormatContext * s , AVStream * st ) \n { \n GetByteContext gb ; \n uint8_t * data = st -> codecpar -> extradata ; \n int data_size = st -> codecpar -> extradata_size ; \n int tag , offset ; \n if ( ! data || data_size < 8 ) { \n return AVERROR_INVALIDDATA ; \n } \n bytestream2_init ( & gb , data , data_size ) ; \n tag = bytestream2_get_le32 ( & gb ) ; \n switch ( tag ) { \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n bytestream2_skip ( & gb , 4 ) ; \n offset = bytestream2_tell ( & gb ) ; \n bytestream2_init ( & gb , data + offset , data_size - offset ) ; \n return avpriv_exif_decode_ifd ( s , & gb , 1 , 0 , & st -> metadata ) ; \n break ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n avpriv_request_sample ( s , \" \" , tag ) ; \n break ; \n case MKTAG ( ' ' , ' ' , ' ' , ' ' ) : \n avpriv_request_sample ( s , \" \" , tag ) ; \n break ; \n default : \n break ; \n } \n return 0 ; \n }", "idx": 22722}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgecv ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h , int intra ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 || ! intra ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 22733}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int cmp_color ( const void * a , const void * b ) \n { \n const struct range_box * box1 = a ; \n const struct range_box * box2 = b ; \n return box1 -> color - box2 -> color ; \n }", "idx": 22744}
{"project": "FFmpeg", "commit_id": "dbbb9262ca0fd09f2582b11157a74c88ab7e1db5", "target": 0, "func": "static void reconstruct_stereo_16 ( int32_t * buffer [ MAX_CHANNELS ] , \n int16_t * buffer_out , \n int numchannels , int numsamples , \n uint8_t interlacing_shift , \n uint8_t interlacing_leftweight ) \n { \n int i ; \n if ( numsamples <= 0 ) \n return ; \n if ( interlacing_leftweight ) { \n for ( i = 0 ; i < numsamples ; i ++ ) { \n int32_t a , b ; \n a = buffer [ 0 ] [ i ] ; \n b = buffer [ 1 ] [ i ] ; \n a -= ( b * interlacing_leftweight ) >> interlacing_shift ; \n b += a ; \n buffer_out [ i * numchannels ] = b ; \n buffer_out [ i * numchannels + 1 ] = a ; \n } \n return ; \n } \n for ( i = 0 ; i < numsamples ; i ++ ) { \n int16_t left , right ; \n left = buffer [ 0 ] [ i ] ; \n right = buffer [ 1 ] [ i ] ; \n buffer_out [ i * numchannels ] = left ; \n buffer_out [ i * numchannels + 1 ] = right ; \n } \n }", "idx": 22747}
{"project": "FFmpeg", "commit_id": "e54061ae6a5e22bad5c66ef4411acc8f778a9f90", "target": 0, "func": "av_cold void ff_vp9_init_static ( AVCodec * codec ) \n { \n if ( vpx_codec_version_major ( ) < 1 \n || ( vpx_codec_version_major ( ) == 1 && vpx_codec_version_minor ( ) < 3 ) ) \n codec -> capabilities |= AV_CODEC_CAP_EXPERIMENTAL ; \n codec -> pix_fmts = vp9_pix_fmts_def ; \n #if CONFIG_LIBVPX_VP9_ENCODER  \n  \n  if ( vpx_codec_version_major ( ) > 1 \n || ( vpx_codec_version_major ( ) == 1 && vpx_codec_version_minor ( ) >= 4 ) ) { \n #ifdef VPX_CODEC_CAP_HIGHBITDEPTH \n vpx_codec_caps_t codec_caps = vpx_codec_get_caps ( vpx_codec_vp9_cx ( ) ) ; \n if ( codec_caps & VPX_CODEC_CAP_HIGHBITDEPTH ) \n codec -> pix_fmts = vp9_pix_fmts_highbd ; \n else \n #endif \n codec -> pix_fmts = vp9_pix_fmts_highcol ; \n } \n #endif \n }", "idx": 22748}
{"project": "FFmpeg", "commit_id": "54d7fcc1207ed37356f06e3a31a4e6bdaa096958", "target": 0, "func": "static int init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n GraphContext * gctx = ctx -> priv ; \n if ( ! args ) \n return 0 ; \n if ( ! ( gctx -> link_filter = avfilter_open ( & vf_graph_dummy , NULL ) ) ) \n return -1 ; \n if ( avfilter_init_filter ( gctx -> link_filter , NULL , ctx ) ) \n goto fail ; \n return graph_load_chain_from_string ( ctx , args , NULL , NULL ) ; \n fail : \n avfilter_destroy ( gctx -> link_filter ) ; \n return -1 ; \n }", "idx": 22773}
{"project": "FFmpeg", "commit_id": "3825b5268844694ff50a0e0bfde64df43a862fae", "target": 0, "func": "static void return_frame ( AVFilterContext * ctx , int is_second ) \n { \n YADIFContext * yadif = ctx -> priv ; \n AVFilterLink * link = ctx -> outputs [ 0 ] ; \n int tff ; \n if ( yadif -> parity == -1 ) { \n tff = yadif -> cur -> video -> interlaced ? \n yadif -> cur -> video -> top_field_first : 1 ; \n } else { \n tff = yadif -> parity ^ 1 ; \n } \n if ( is_second ) { \n yadif -> out = ff_get_video_buffer ( link , AV_PERM_WRITE | AV_PERM_PRESERVE | \n AV_PERM_REUSE , link -> w , link -> h ) ; \n avfilter_copy_buffer_ref_props ( yadif -> out , yadif -> cur ) ; \n yadif -> out -> video -> interlaced = 0 ; \n } \n if ( ! yadif -> csp ) \n yadif -> csp = & av_pix_fmt_descriptors [ link -> format ] ; \n if ( yadif -> csp -> comp [ 0 ] . depth_minus1 / 8 == 1 ) \n yadif -> filter_line = filter_line_c_16bit ; \n filter ( ctx , yadif -> out , tff ^ ! is_second , tff ) ; \n if ( is_second ) { \n int64_t cur_pts = yadif -> cur -> pts ; \n int64_t next_pts = yadif -> next -> pts ; \n if ( next_pts != AV_NOPTS_VALUE && cur_pts != AV_NOPTS_VALUE ) { \n yadif -> out -> pts = cur_pts + next_pts ; \n } else { \n yadif -> out -> pts = AV_NOPTS_VALUE ; \n } \n ff_start_frame ( ctx -> outputs [ 0 ] , yadif -> out ) ; \n } \n ff_draw_slice ( ctx -> outputs [ 0 ] , 0 , link -> h , 1 ) ; \n ff_end_frame ( ctx -> outputs [ 0 ] ) ; \n yadif -> frame_pending = ( yadif -> mode & 1 ) && ! is_second ; \n }", "idx": 22795}
{"project": "FFmpeg", "commit_id": "e29d2d9c92e19b0caf05a2064d132ccdecdfc3d5", "target": 0, "func": "static int seg_check_bitstream ( struct AVFormatContext * s , const AVPacket * pkt ) \n { \n SegmentContext * seg = s -> priv_data ; \n AVFormatContext * oc = seg -> avf ; \n if ( oc -> oformat -> check_bitstream ) { \n int ret = oc -> oformat -> check_bitstream ( oc , pkt ) ; \n if ( ret == 1 ) { \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n AVStream * ost = oc -> streams [ pkt -> stream_index ] ; \n st -> internal -> bsfcs = ost -> internal -> bsfcs ; \n st -> internal -> nb_bsfcs = ost -> internal -> nb_bsfcs ; \n ost -> internal -> bsfcs = NULL ; \n ost -> internal -> nb_bsfcs = 0 ; \n } \n return ret ; \n } \n return 1 ; \n }", "idx": 22797}
{"project": "FFmpeg", "commit_id": "82613564cfae459796642b22fc0163927d7f49e0", "target": 0, "func": "static int gen_check_bw ( URLContext * s , RTMPContext * rt ) \n { \n RTMPPacket pkt ; \n uint8_t * p ; \n int ret ; \n if ( ( ret = ff_rtmp_packet_create ( & pkt , RTMP_SYSTEM_CHANNEL , RTMP_PT_INVOKE , \n 0 , 21 ) ) < 0 ) \n return ret ; \n p = pkt . data ; \n ff_amf_write_string ( & p , \" \" ) ; \n ff_amf_write_number ( & p , ++ rt -> nb_invokes ) ; \n ff_amf_write_null ( & p ) ; \n ret = ff_rtmp_packet_write ( rt -> stream , & pkt , rt -> chunk_size , \n rt -> prev_pkt [ 1 ] ) ; \n ff_rtmp_packet_destroy ( & pkt ) ; \n return ret ; \n }", "idx": 22798}
{"project": "FFmpeg", "commit_id": "c71999ef97b7cc8b1cb6eaf39e72e9ecbf825d9e", "target": 1, "func": "static int dfa_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVIOContext * pb = s -> pb ; \n uint32_t frame_size ; \n int ret , first = 1 ; \n if ( avio_feof ( pb ) ) \n return AVERROR_EOF ; \n if ( av_get_packet ( pb , pkt , 12 ) != 12 ) \n return AVERROR ( EIO ) ; \n while ( ! avio_feof ( pb ) ) { \n if ( ! first ) { \n ret = av_append_packet ( pb , pkt , 12 ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n } else \n first = 0 ; \n frame_size = AV_RL32 ( pkt -> data + pkt -> size - 8 ) ; \n if ( frame_size > INT_MAX - 4 ) { \n av_log ( s , AV_LOG_ERROR , \" \" PRIu32 \" \\n \" , frame_size ) ; \n return AVERROR ( EIO ) ; \n } \n if ( AV_RL32 ( pkt -> data + pkt -> size - 12 ) == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n if ( frame_size ) { \n av_log ( s , AV_LOG_WARNING , \n \" \" PRIu32 \" \\n \" , \n frame_size ) ; \n avio_skip ( pb , frame_size ) ; \n } \n return 0 ; \n } \n ret = av_append_packet ( pb , pkt , frame_size ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 22806}
{"project": "FFmpeg", "commit_id": "27dbc47c05e07486feba1ab829db584da2159648", "target": 1, "func": "static int nut_read_close ( AVFormatContext * s ) \n { \n NUTContext * nut = s -> priv_data ; \n av_freep ( & nut -> time_base ) ; \n av_freep ( & nut -> stream ) ; \n return 0 ; \n }", "idx": 22807}
{"project": "FFmpeg", "commit_id": "896873b5648c1c6d379c35832e99d966fa56f87f", "target": 1, "func": "static int64_t pva_read_timestamp ( struct AVFormatContext * s , int stream_index , \n int64_t * pos , int64_t pos_limit ) { \n ByteIOContext * pb = s -> pb ; \n PVAContext * pvactx = s -> priv_data ; \n int length , streamid ; \n int64_t res ; \n pos_limit = FFMIN ( * pos + PVA_MAX_PAYLOAD_LENGTH * 8 , ( uint64_t ) * pos + pos_limit ) ; \n while ( * pos < pos_limit ) { \n res = AV_NOPTS_VALUE ; \n url_fseek ( pb , * pos , SEEK_SET ) ; \n pvactx -> continue_pes = 0 ; \n if ( read_part_of_packet ( s , & res , & length , & streamid , 0 ) ) { \n ( * pos ) ++ ; \n continue ; \n } \n if ( streamid - 1 != stream_index || res == AV_NOPTS_VALUE ) { \n * pos = url_ftell ( pb ) + length ; \n continue ; \n } \n break ; \n } \n pvactx -> continue_pes = 0 ; \n return res ; \n }", "idx": 22808}
{"project": "FFmpeg", "commit_id": "383a04a127734d25c1ef7839c489bba297855801", "target": 1, "func": "int ff_write_chained ( AVFormatContext * dst , int dst_stream , AVPacket * pkt , \n AVFormatContext * src ) \n { \n AVPacket local_pkt ; \n local_pkt = * pkt ; \n local_pkt . stream_index = dst_stream ; \n if ( pkt -> pts != AV_NOPTS_VALUE ) \n local_pkt . pts = av_rescale_q ( pkt -> pts , \n src -> streams [ pkt -> stream_index ] -> time_base , \n dst -> streams [ dst_stream ] -> time_base ) ; \n if ( pkt -> dts != AV_NOPTS_VALUE ) \n local_pkt . dts = av_rescale_q ( pkt -> dts , \n src -> streams [ pkt -> stream_index ] -> time_base , \n dst -> streams [ dst_stream ] -> time_base ) ; \n if ( pkt -> duration ) \n local_pkt . duration = av_rescale_q ( pkt -> duration , \n src -> streams [ pkt -> stream_index ] -> time_base , \n dst -> streams [ dst_stream ] -> time_base ) ; \n return av_write_frame ( dst , & local_pkt ) ; \n }", "idx": 22819}
{"project": "FFmpeg", "commit_id": "205c31b301864e675d051b07b19b6c457cf2ab24", "target": 0, "func": "static int parse_section_header ( GetByteContext * gbc , int * section_size , \n enum HapSectionType * section_type ) \n { \n if ( bytestream2_get_bytes_left ( gbc ) < 4 ) \n return AVERROR_INVALIDDATA ; \n * section_size = bytestream2_get_le24 ( gbc ) ; \n * section_type = bytestream2_get_byte ( gbc ) ; \n if ( * section_size == 0 ) { \n if ( bytestream2_get_bytes_left ( gbc ) < 4 ) \n return AVERROR_INVALIDDATA ; \n * section_size = bytestream2_get_le32 ( gbc ) ; \n } \n if ( * section_size > bytestream2_get_bytes_left ( gbc ) ) \n return AVERROR_INVALIDDATA ; \n else \n return 0 ; \n }", "idx": 22821}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_4w_msa ( src + stride - 2 , \n src - ( stride * 2 ) , stride , dst , stride , 4 ) ; \n }", "idx": 22827}
{"project": "FFmpeg", "commit_id": "f5475e1b38a37c6da2e26097242cf82a2b1a9ee9", "target": 1, "func": "vorbis_header ( AVFormatContext * s , int idx )  \n { \n ogg_t * ogg = s -> priv_data ; \n ogg_stream_t * os = ogg -> streams + idx ; \n AVStream * st = s -> streams [ idx ] ; \n oggvorbis_private_t * priv ; \n if ( os -> seq > 2 ) \n return 0 ; \n if ( os -> seq == 0 ) { \n os -> private = av_mallocz ( sizeof ( oggvorbis_private_t ) ) ; \n if ( ! os -> private ) \n return 0 ; \n } \n priv = os -> private ; \n priv -> len [ os -> seq ] = os -> psize ; \n priv -> packet [ os -> seq ] = av_mallocz ( os -> psize ) ; \n memcpy ( priv -> packet [ os -> seq ] , os -> buf + os -> pstart , os -> psize ) ; \n if ( os -> buf [ os -> pstart ] == 1 ) { \n uint8_t * p = os -> buf + os -> pstart + 11 ; \n st -> codec -> channels = * p ++ ; \n st -> codec -> sample_rate = AV_RL32 ( p ) ; \n p += 8 ; \n st -> codec -> bit_rate = AV_RL32 ( p ) ; \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n st -> codec -> codec_id = CODEC_ID_VORBIS ; \n st -> time_base . num = 1 ; \n st -> time_base . den = st -> codec -> sample_rate ; \n } else if ( os -> buf [ os -> pstart ] == 3 ) { \n vorbis_comment ( s , os -> buf + os -> pstart + 7 , os -> psize - 8 ) ; \n } else { \n st -> codec -> extradata_size = \n fixup_vorbis_headers ( s , priv , & st -> codec -> extradata ) ; \n } \n return os -> seq < 3 ; \n }", "idx": 22835}
{"project": "FFmpeg", "commit_id": "984d58a3440d513f66344b5332f6b589c0a6bbc6", "target": 1, "func": "static struct URLProtocol * url_find_protocol ( const char * filename ) \n { \n URLProtocol * up = NULL ; \n char proto_str [ 128 ] , proto_nested [ 128 ] , * ptr ; \n size_t proto_len = strspn ( filename , URL_SCHEME_CHARS ) ; \n if ( filename [ proto_len ] != ' ' && \n ( filename [ proto_len ] != ' ' || ! strchr ( filename + proto_len + 1 , ' ' ) ) || \n is_dos_path ( filename ) ) \n strcpy ( proto_str , \" \" ) ; \n else \n av_strlcpy ( proto_str , filename , \n FFMIN ( proto_len + 1 , sizeof ( proto_str ) ) ) ; \n if ( ( ptr = strchr ( proto_str , ' ' ) ) ) \n * ptr = ' \\0 ' ; \n av_strlcpy ( proto_nested , proto_str , sizeof ( proto_nested ) ) ; \n if ( ( ptr = strchr ( proto_nested , ' ' ) ) ) \n * ptr = ' \\0 ' ; \n while ( up = ffurl_protocol_next ( up ) ) { \n if ( ! strcmp ( proto_str , up -> name ) ) \n break ; \n if ( up -> flags & URL_PROTOCOL_FLAG_NESTED_SCHEME && \n ! strcmp ( proto_nested , up -> name ) ) \n break ; \n } \n return up ; \n }", "idx": 22840}
{"project": "FFmpeg", "commit_id": "2dd18d4435c27a469b89e1d6b061eb9b4661687d", "target": 0, "func": "rdt_parse_sdp_line ( AVFormatContext * s , int st_index , \n PayloadContext * rdt , const char * line )  \n { \n AVStream * stream = s -> streams [ st_index ] ; \n const char * p = line ; \n if ( av_strstart ( p , \" \" , & p ) ) { \n rdt -> mlti_data = rdt_parse_b64buf ( & rdt -> mlti_data_size , p ) ; \n } else if ( av_strstart ( p , \" \" , & p ) ) \n stream -> first_dts = atoi ( p ) ; \n else if ( av_strstart ( p , \" \" , & p ) ) { \n int n , first = -1 ; \n for ( n = 0 ; n < s -> nb_streams ; n ++ ) \n if ( s -> streams [ n ] -> id == stream -> id ) { \n int count = s -> streams [ n ] -> index + 1 ; \n if ( first == -1 ) first = n ; \n if ( rdt -> nb_rmst < count ) { \n RMStream * * rmst = av_realloc ( rdt -> rmst , count * sizeof ( * rmst ) ) ; \n if ( ! rmst ) \n return AVERROR ( ENOMEM ) ; \n memset ( rmst + rdt -> nb_rmst , 0 , \n ( count - rdt -> nb_rmst ) * sizeof ( * rmst ) ) ; \n rdt -> rmst = rmst ; \n rdt -> nb_rmst = count ; \n } \n rdt -> rmst [ s -> streams [ n ] -> index ] = ff_rm_alloc_rmstream ( ) ; \n rdt_load_mdpr ( rdt , s -> streams [ n ] , ( n - first ) * 2 ) ; \n if ( s -> streams [ n ] -> codec -> codec_id == CODEC_ID_AAC ) \n s -> streams [ n ] -> codec -> frame_size = 1 ; \n } \n } \n return 0 ; \n }", "idx": 22883}
{"project": "FFmpeg", "commit_id": "838f461b0716393a1b5c70efd03de1e8bc197380", "target": 1, "func": "static int add_metadata_from_side_data ( AVCodecContext * avctx , AVFrame * frame ) \n { \n int size , ret = 0 ; \n const uint8_t * side_metadata ; \n const uint8_t * end ; \n side_metadata = av_packet_get_side_data ( avctx -> pkt , \n AV_PKT_DATA_STRINGS_METADATA , & size ) ; \n if ( ! side_metadata ) \n goto end ; \n end = side_metadata + size ; \n while ( side_metadata < end ) { \n const uint8_t * key = side_metadata ; \n const uint8_t * val = side_metadata + strlen ( key ) + 1 ; \n int ret = av_dict_set ( avpriv_frame_get_metadatap ( frame ) , key , val , 0 ) ; \n if ( ret < 0 ) \n break ; \n side_metadata = val + strlen ( val ) + 1 ; \n } \n end : \n return ret ; \n }", "idx": 22891}
{"project": "FFmpeg", "commit_id": "f79364b2c30aaaec9f0b1500a74da5a859c2ff37", "target": 0, "func": "static void float_to_int16_stride_altivec ( int16_t * dst , const float * src , \n long len , int stride ) \n { \n int i , j ; \n vector signed  short d , s ; \n for ( i = 0 ; i < len - 7 ; i += 8 ) { \n d = float_to_int16_one_altivec ( src + i ) ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n s = vec_splat ( d , j ) ; \n vec_ste ( s , 0 , dst ) ; \n dst += stride ; \n } \n } \n }", "idx": 22900}
{"project": "FFmpeg", "commit_id": "aeaf268e52fc11c1f64914a319e0edddf1346d6a", "target": 0, "func": "static void vp3_idct_dc_add_c ( uint8_t * dest \n , int line_size , \n const DCTELEM * block \n ) { \n int i , dc = ( block [ 0 ] + 15 ) >> 5 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = av_clip_uint8 ( dest [ 0 ] + dc ) ; \n dest [ 1 ] = av_clip_uint8 ( dest [ 1 ] + dc ) ; \n dest [ 2 ] = av_clip_uint8 ( dest [ 2 ] + dc ) ; \n dest [ 3 ] = av_clip_uint8 ( dest [ 3 ] + dc ) ; \n dest [ 4 ] = av_clip_uint8 ( dest [ 4 ] + dc ) ; \n dest [ 5 ] = av_clip_uint8 ( dest [ 5 ] + dc ) ; \n dest [ 6 ] = av_clip_uint8 ( dest [ 6 ] + dc ) ; \n dest [ 7 ] = av_clip_uint8 ( dest [ 7 ] + dc ) ; \n dest += line_size ; \n } \n }", "idx": 22903}
{"project": "FFmpeg", "commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "target": 1, "func": "static av_cold int libopenjpeg_encode_close ( AVCodecContext * avctx ) \n { \n LibOpenJPEGContext * ctx = avctx -> priv_data ; \n opj_cio_close ( ctx -> stream ) ; \n ctx -> stream = NULL ; \n opj_destroy_compress ( ctx -> compress ) ; \n ctx -> compress = NULL ; \n opj_image_destroy ( ctx -> image ) ; \n ctx -> image = NULL ; \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 22905}
{"project": "FFmpeg", "commit_id": "224bb46fb857dab589597bdab302ba8ba012008c", "target": 1, "func": "FFAMediaFormat * ff_AMediaFormat_new ( void ) \n { \n JNIEnv * env = NULL ; \n FFAMediaFormat * format = NULL ; \n format = av_mallocz ( sizeof ( FFAMediaFormat ) ) ; \n if ( ! format ) { \n return NULL ; \n } \n format -> class = & amediaformat_class ; \n env = ff_jni_get_env ( format ) ; \n if ( ! env ) { \n av_freep ( & format ) ; \n return NULL ; \n } \n if ( ff_jni_init_jfields ( env , & format -> jfields , jni_amediaformat_mapping , 1 , format ) < 0 ) { \n goto fail ; \n } \n format -> object = ( * env ) -> NewObject ( env , format -> jfields . mediaformat_class , format -> jfields . init_id ) ; \n if ( ! format -> object ) { \n goto fail ; \n } \n format -> object = ( * env ) -> NewGlobalRef ( env , format -> object ) ; \n if ( ! format -> object ) { \n goto fail ; \n } \n return format ; \n fail : \n ff_jni_reset_jfields ( env , & format -> jfields , jni_amediaformat_mapping , 1 , format ) ; \n av_freep ( & format ) ; \n return NULL ; \n }", "idx": 22907}
{"project": "FFmpeg", "commit_id": "4cc3467e7abfea7e8d03b6af511f7719038a5a98", "target": 1, "func": "static int64_t ogg_read_timestamp ( AVFormatContext * s , int stream_index , \n int64_t * pos_arg , int64_t pos_limit ) \n { \n struct ogg * ogg = s -> priv_data ; \n struct ogg_stream * os = ogg -> streams + stream_index ; \n AVIOContext * bc = s -> pb ; \n int64_t pts = AV_NOPTS_VALUE ; \n int i ; \n avio_seek ( bc , * pos_arg , SEEK_SET ) ; \n ogg_reset ( ogg ) ; \n while ( avio_tell ( bc ) < pos_limit && ! ogg_packet ( s , & i , NULL , NULL , pos_arg ) ) { \n if ( i == stream_index ) { \n pts = ogg_calc_pts ( s , i , NULL ) ; \n if ( os -> keyframe_seek && ! ( os -> pflags & AV_PKT_FLAG_KEY ) ) \n pts = AV_NOPTS_VALUE ; \n } \n if ( pts != AV_NOPTS_VALUE ) \n break ; \n } \n ogg_reset ( ogg ) ; \n return pts ; \n }", "idx": 22915}
{"project": "FFmpeg", "commit_id": "8dca0877e3e1457e9ec79ffa1ead1135aabb791c", "target": 0, "func": "static int mpegts_write_section1 ( MpegTSSection * s , int tid , int id , \n int version , int sec_num , int last_sec_num , \n uint8_t * buf , int len ) \n { \n uint8_t section [ 1024 ] , * q ; \n unsigned int tot_len ; \n unsigned int flags = tid == SDT_TID ? 0xf000 : 0xb000 ; \n tot_len = 3 + 5 + len + 4 ; \n if ( tot_len > 1024 ) \n return -1 ; \n q = section ; \n * q ++ = tid ; \n put16 ( & q , flags | ( len + 5 + 4 ) ) ; \n put16 ( & q , id ) ; \n * q ++ = 0xc1 | ( version << 1 ) ; \n * q ++ = sec_num ; \n * q ++ = last_sec_num ; \n memcpy ( q , buf , len ) ; \n mpegts_write_section ( s , section , tot_len ) ; \n return 0 ; \n }", "idx": 22921}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int compare_doubles ( const double * a , const double * b , int len , \n double max_diff ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) { \n if ( fabs ( a [ i ] - b [ i ] ) > max_diff ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , \n i , a [ i ] , b [ i ] , a [ i ] - b [ i ] ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 22922}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int _decode_exponents ( int expstr , int ngrps , uint8_t absexp , uint8_t * gexps , uint8_t * dexps ) \n { \n int exps ; \n int i = 0 ; \n while ( ngrps -- ) { \n exps = gexps [ i ++ ] ; \n absexp += exp_1 [ exps ] ; \n assert ( absexp <= 24 ) ; \n switch ( expstr ) { \n case AC3_EXPSTR_D45 : \n * ( dexps ++ ) = absexp ; \n * ( dexps ++ ) = absexp ; \n case AC3_EXPSTR_D25 : \n * ( dexps ++ ) = absexp ; \n case AC3_EXPSTR_D15 : \n * ( dexps ++ ) = absexp ; \n } \n absexp += exp_2 [ exps ] ; \n assert ( absexp <= 24 ) ; \n switch ( expstr ) { \n case AC3_EXPSTR_D45 : \n * ( dexps ++ ) = absexp ; \n * ( dexps ++ ) = absexp ; \n case AC3_EXPSTR_D25 : \n * ( dexps ++ ) = absexp ; \n case AC3_EXPSTR_D15 : \n * ( dexps ++ ) = absexp ; \n } \n absexp += exp_3 [ exps ] ; \n assert ( absexp <= 24 ) ; \n switch ( expstr ) { \n case AC3_EXPSTR_D45 : \n * ( dexps ++ ) = absexp ; \n * ( dexps ++ ) = absexp ; \n case AC3_EXPSTR_D25 : \n * ( dexps ++ ) = absexp ; \n case AC3_EXPSTR_D15 : \n * ( dexps ++ ) = absexp ; \n } \n } \n return 0 ; \n }", "idx": 22925}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_vertical ) ( uint8_t * _src , int _stride ) { \n int i ; \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n const pixel4 a = ( ( pixel4 * ) ( src - stride ) ) [ 0 ] ; \n const pixel4 b = ( ( pixel4 * ) ( src - stride ) ) [ 1 ] ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = a ; \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = b ; \n } \n }", "idx": 22932}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void checkasm_check_blockdsp ( void ) \n { \n LOCAL_ALIGNED_16 ( uint16_t , buf0 ,  [ 6 * 8 * 8 ] ) ; \n LOCAL_ALIGNED_16 ( uint16_t , buf1 ,  [ 6 * 8 * 8 ] ) ; \n AVCodecContext avctx = { 0 } ; \n BlockDSPContext h ; \n ff_blockdsp_init ( & h , & avctx ) ; \n check_clear ( clear_block , 8 * 8 ) ; \n check_clear ( clear_blocks , 8 * 8 * 6 ) ; \n report ( \" \" ) ; \n }", "idx": 22939}
{"project": "FFmpeg", "commit_id": "cd523888f304d297bb7dec5d358d0ee92576cc44", "target": 0, "func": "void ff_acelp_weighted_filter ( \n int16_t * out , \n const int16_t * in , \n const int16_t * weight_pow , \n int filter_length ) \n { \n int n ; \n for ( n = 0 ; n < filter_length ; n ++ ) \n out [ n ] = ( in [ n ] * weight_pow [ n ] + 0x4000 ) >> 15 ; \n }", "idx": 22946}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_c ( DCTELEM * block \n ) { \n idct ( NULL , 0 , block , 0 ) ; \n }", "idx": 22947}
{"project": "FFmpeg", "commit_id": "591944cd0c4f10ddf0eaee9298553633e12a26d0", "target": 0, "func": "static int seq_fill_buffer ( SeqDemuxContext * seq , ByteIOContext * pb , int buffer_num , unsigned int data_offs , int data_size ) \n { \n TiertexSeqFrameBuffer * seq_buffer ; \n if ( buffer_num >= SEQ_NUM_FRAME_BUFFERS ) \n return AVERROR_INVALIDDATA ; \n seq_buffer = & seq -> frame_buffers [ buffer_num ] ; \n if ( seq_buffer -> fill_size + data_size > seq_buffer -> data_size ) \n return AVERROR_INVALIDDATA ; \n url_fseek ( pb , seq -> current_frame_offs + data_offs , SEEK_SET ) ; \n if ( get_buffer ( pb , seq_buffer -> data + seq_buffer -> fill_size , data_size ) != data_size ) \n return AVERROR ( EIO ) ; \n seq_buffer -> fill_size += data_size ; \n return 0 ; \n }", "idx": 22948}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten  void h264_loop_filter_luma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int8_t * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( tc0 [ i ] < 0 ) { \n pix += 4 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 4 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int p2 = pix [ -3 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n const int q2 = pix [ 2 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n int tc = tc0 [ i ] ; \n int i_delta ; \n if ( FFABS ( p2 - p0 ) < beta ) { \n if ( tc0 [ i ] ) \n pix [ -2 * xstride ] = p1 + av_clip ( ( ( p2 + ( ( p0 + q0 + 1 ) >> 1 ) ) >> 1 ) - p1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n if ( FFABS ( q2 - q0 ) < beta ) { \n if ( tc0 [ i ] ) \n pix [ xstride ] = q1 + av_clip ( ( ( q2 + ( ( p0 + q0 + 1 ) >> 1 ) ) >> 1 ) - q1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n i_delta = av_clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = av_clip_uint8 ( p0 + i_delta ) ; \n pix [ 0 ] = av_clip_uint8 ( q0 - i_delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 22950}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int io_open_default ( AVFormatContext * s , AVIOContext * * pb , \n const char * url , int flags , AVDictionary * * options ) \n { \n return avio_open2 ( pb , url , flags , & s -> interrupt_callback , options ) ; \n }", "idx": 22951}
{"project": "FFmpeg", "commit_id": "d0393d79bc3d61c9f2ff832c0e273b7774ff0269", "target": 1, "func": "static int read_huffman_tables ( HYuvContext * s , const uint8_t * src , int length ) \n { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , src , length * 8 ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( read_len_table ( s -> len [ i ] , & gb ) < 0 ) \n return -1 ; \n if ( ff_huffyuv_generate_bits_table ( s -> bits [ i ] , s -> len [ i ] ) < 0 ) \n return -1 ; \n ff_free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , \n s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return ( get_bits_count ( & gb ) + 7 ) / 8 ; \n }", "idx": 22952}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int X264_close ( AVCodecContext * avctx ) \n { \n X264Context * x4 = avctx -> priv_data ; \n av_freep ( & avctx -> extradata ) ; \n av_freep ( & x4 -> sei ) ; \n if ( x4 -> enc ) { \n x264_encoder_close ( x4 -> enc ) ; \n x4 -> enc = NULL ; \n } \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 22962}
{"project": "FFmpeg", "commit_id": "db5dc02bd7d31243d2c4f84294907d657ab3d070", "target": 1, "func": "static int get_audio_frame_size ( AVCodecContext * enc , int size ) \n { \n int frame_size ; \n if ( enc -> codec_id == CODEC_ID_VORBIS ) \n return -1 ; \n if ( enc -> frame_size <= 1 ) { \n int bits_per_sample = av_get_bits_per_sample ( enc -> codec_id ) ; \n if ( bits_per_sample ) { \n if ( enc -> channels == 0 ) \n return -1 ; \n frame_size = ( size << 3 ) / ( bits_per_sample * enc -> channels ) ; \n } else { \n if ( enc -> bit_rate == 0 ) \n return -1 ; \n frame_size = ( size * 8 * enc -> sample_rate ) / enc -> bit_rate ; \n } \n } else { \n frame_size = enc -> frame_size ; \n } \n return frame_size ; \n }", "idx": 22971}
{"project": "FFmpeg", "commit_id": "61cd19b8bc32185c8caf64d89d1b0909877a0707", "target": 1, "func": "static av_always_inline void paint_raw ( uint8_t * dst , int w , int h , \n const uint8_t * src , int bpp , \n int be , int stride ) \n { \n int i , j , p ; \n for ( j = 0 ; j < h ; j ++ ) { \n for ( i = 0 ; i < w ; i ++ ) { \n p = vmnc_get_pixel ( src , bpp , be ) ; \n src += bpp ; \n switch ( bpp ) { \n case 1 : \n dst [ i ] = p ; \n break ; \n case 2 : \n ( ( uint16_t * ) dst ) [ i ] = p ; \n break ; \n case 4 : \n ( ( uint32_t * ) dst ) [ i ] = p ; \n break ; \n } \n } \n dst += stride ; \n } \n }", "idx": 22977}
{"project": "FFmpeg", "commit_id": "9543cd593ed8249e9885598fc53de163c9d4e2d3", "target": 1, "func": "static void show_format ( WriterContext * w , AVFormatContext * fmt_ctx ) \n { \n char val_str [ 128 ] ; \n int64_t size = fmt_ctx -> pb ? avio_size ( fmt_ctx -> pb ) : -1 ; \n print_section_header ( \" \" ) ; \n print_str ( \" \" , fmt_ctx -> filename ) ; \n print_int ( \" \" , fmt_ctx -> nb_streams ) ; \n print_str ( \" \" , fmt_ctx -> iformat -> name ) ; \n print_str ( \" \" , fmt_ctx -> iformat -> long_name ) ; \n print_time ( \" \" , fmt_ctx -> start_time , & AV_TIME_BASE_Q ) ; \n print_time ( \" \" , fmt_ctx -> duration , & AV_TIME_BASE_Q ) ; \n if ( size >= 0 ) print_val ( \" \" , size , unit_byte_str ) ; \n else print_str_opt ( \" \" , \" \" ) ; \n if ( fmt_ctx -> bit_rate > 0 ) print_val ( \" \" , fmt_ctx -> bit_rate , unit_bit_per_second_str ) ; \n else print_str_opt ( \" \" , \" \" ) ; \n show_tags ( fmt_ctx -> metadata ) ; \n print_section_footer ( \" \" ) ; \n fflush ( stdout ) ; \n }", "idx": 22982}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static SchroFrame * libschroedinger_frame_from_data ( AVCodecContext * avctx , \n const AVFrame * frame ) \n { \n SchroEncoderParams * p_schro_params = avctx -> priv_data ; \n SchroFrame * in_frame = ff_create_schro_frame ( avctx , \n p_schro_params -> frame_format ) ; \n if ( in_frame ) { \n if ( av_frame_copy ( in_frame -> priv , frame ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return NULL ; \n } \n } \n return in_frame ; \n }", "idx": 22983}
{"project": "FFmpeg", "commit_id": "8e2555d3b1855374707a4d53bf93d3e07d61e05c", "target": 0, "func": "static av_cold int g722_encode_close ( AVCodecContext * avctx ) \n { \n G722Context * c = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n av_freep ( & c -> paths [ i ] ) ; \n av_freep ( & c -> node_buf [ i ] ) ; \n av_freep ( & c -> nodep_buf [ i ] ) ; \n } \n return 0 ; \n }", "idx": 22991}
{"project": "FFmpeg", "commit_id": "f807d6d2009b9f2e70d9a204a0e8b6140a87ec85", "target": 0, "func": "void ff_check_pixfmt_descriptors ( void ) { \n int i , j ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( av_pix_fmt_descriptors ) ; i ++ ) { \n const AVPixFmtDescriptor * d = & av_pix_fmt_descriptors [ i ] ; \n if ( ! d -> name && ! d -> nb_components && ! d -> log2_chroma_w && ! d -> log2_chroma_h && ! d -> flags ) \n continue ; \n av_assert0 ( d -> log2_chroma_w <= 3 ) ; \n av_assert0 ( d -> log2_chroma_h <= 3 ) ; \n av_assert0 ( d -> nb_components <= 4 ) ; \n av_assert0 ( d -> name && d -> name [ 0 ] ) ; \n av_assert0 ( ( d -> nb_components == 4 || d -> nb_components == 2 ) == ! ! ( d -> flags & PIX_FMT_ALPHA ) ) ; \n av_assert2 ( av_get_pix_fmt ( d -> name ) == i ) ; \n for ( j = 0 ; j < FF_ARRAY_ELEMS ( d -> comp ) ; j ++ ) { \n const AVComponentDescriptor * c = & d -> comp [ j ] ; \n if ( j >= d -> nb_components ) \n av_assert0 ( ! c -> plane && ! c -> step_minus1 && ! c -> offset_plus1 && ! c -> shift && ! c -> depth_minus1 ) ; \n } \n } \n }", "idx": 22999}
{"project": "FFmpeg", "commit_id": "a2f55f22b342202e6925561b9ee0b7ec76e8bcd0", "target": 0, "func": "static void mxf_write_generic_desc ( ByteIOContext * pb , const MXFDescriptorWriteTableEntry * desc_tbl , AVStream * st ) \n { \n const MXFCodecUL * codec_ul ; \n put_buffer ( pb , desc_tbl -> key , 16 ) ; \n klv_encode_ber_length ( pb , 108 ) ; \n mxf_write_local_tag ( pb , 16 , 0x3C0A ) ; \n mxf_write_uuid ( pb , SubDescriptor , st -> index ) ; \n mxf_write_local_tag ( pb , 4 , 0x3006 ) ; \n put_be32 ( pb , st -> index ) ; \n mxf_write_local_tag ( pb , 8 , 0x3001 ) ; \n put_be32 ( pb , st -> time_base . den ) ; \n put_be32 ( pb , st -> time_base . num ) ; \n codec_ul = mxf_get_essence_container_ul ( st -> codec -> codec_id ) ; \n mxf_write_local_tag ( pb , 16 , 0x3004 ) ; \n put_buffer ( pb , codec_ul -> uid , 16 ) ; \n }", "idx": 23010}
{"project": "FFmpeg", "commit_id": "2131e8590c447575a1c23bbc9f7e0bf9592d8997", "target": 0, "func": "static void init_demo ( const char * filename ) \n { \n int i , j ; \n int h ; \n int radian ; \n char line [ 3 * W ] ; \n FILE * fichier ; \n fichier = fopen ( filename , \" \" ) ; \n if ( ! fichier ) { \n perror ( filename ) ; \n exit ( 1 ) ; \n } \n fread ( line , 1 , 15 , fichier ) ; \n for ( i = 0 ; i < H ; i ++ ) { \n fread ( line , 1 , 3 * W , fichier ) ; \n for ( j = 0 ; j < W ; j ++ ) { \n tab_r [ W * i + j ] = line [ 3 * j ] ; \n tab_g [ W * i + j ] = line [ 3 * j + 1 ] ; \n tab_b [ W * i + j ] = line [ 3 * j + 2 ] ; \n } \n } \n fclose ( fichier ) ; \n for ( i = 0 ; i < 360 ; i ++ ) { \n radian = 2 * i * MY_PI / 360 ; \n h = 2 * FIXP + int_sin ( radian ) ; \n h_cos [ i ] = h * int_sin ( radian + MY_PI / 2 ) / 2 / FIXP ; \n h_sin [ i ] = h * int_sin ( radian ) / 2 / FIXP ; \n } \n }", "idx": 23018}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static int qsv_get_buffer ( AVCodecContext * s , AVFrame * frame , int flags ) \n { \n InputStream * ist = s -> opaque ; \n QSVContext * qsv = ist -> hwaccel_ctx ; \n int i ; \n for ( i = 0 ; i < qsv -> nb_surfaces ; i ++ ) { \n if ( qsv -> surface_used [ i ] ) \n continue ; \n frame -> buf [ 0 ] = av_buffer_create ( ( uint8_t * ) qsv -> surface_ptrs [ i ] , sizeof ( * qsv -> surface_ptrs [ i ] ) , \n buffer_release , & qsv -> surface_used [ i ] , 0 ) ; \n if ( ! frame -> buf [ 0 ] ) \n return AVERROR ( ENOMEM ) ; \n frame -> data [ 3 ] = ( uint8_t * ) qsv -> surface_ptrs [ i ] ; \n qsv -> surface_used [ i ] = 1 ; \n return 0 ; \n } \n return AVERROR ( ENOMEM ) ; \n }", "idx": 23020}
{"project": "FFmpeg", "commit_id": "bd6fa80d56fcda385da1c8f21eb83282a7930899", "target": 0, "func": "static int hap_encode ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * frame , int * got_packet ) \n { \n HapContext * ctx = avctx -> priv_data ; \n int header_length = hap_header_length ( ctx ) ; \n int final_data_size , ret ; \n int pktsize = FFMAX ( ctx -> tex_size , ctx -> max_snappy * ctx -> chunk_count ) + header_length ; \n ret = ff_alloc_packet2 ( avctx , pkt , pktsize , header_length ) ; \n if ( ret < 0 ) \n return ret ; \n ret = compress_texture ( avctx , ctx -> tex_buf , ctx -> tex_size , frame ) ; \n if ( ret < 0 ) \n return ret ; \n final_data_size = hap_compress_frame ( avctx , pkt -> data + header_length ) ; \n if ( final_data_size < 0 ) \n return final_data_size ; \n hap_write_frame_header ( ctx , pkt -> data , final_data_size + header_length ) ; \n av_shrink_packet ( pkt , final_data_size + header_length ) ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n * got_packet = 1 ; \n return 0 ; \n }", "idx": 23024}
{"project": "FFmpeg", "commit_id": "6eda91ad54fd3214610edb1e4a5adb58806c243e", "target": 0, "func": "static void add_pid_to_pmt ( MpegTSContext * ts , unsigned int programid , unsigned int pid ) \n { \n int i ; \n struct Program * p = NULL ; \n for ( i = 0 ; i < ts -> nb_prg ; i ++ ) { \n if ( ts -> prg [ i ] . id == programid ) { \n p = & ts -> prg [ i ] ; \n break ; \n } \n } \n if ( ! p ) \n return ; \n if ( p -> nb_pids >= MAX_PIDS_PER_PROGRAM ) \n return ; \n p -> pids [ p -> nb_pids ++ ] = pid ; \n }", "idx": 23025}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "void ff_put_h264_qpel8_mc32_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_8w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 8 , 1 ) ; \n }", "idx": 23028}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x4 ( IpvideoContext * s ) \n { \n int x , y ; \n unsigned char B , BL , BH ; \n CHECK_STREAM_PTR ( 1 ) ; \n B = * s -> stream_ptr ++ ; \n BL = B & 0x0F ; \n BH = ( B >> 4 ) & 0x0F ; \n x = -8 + BL ; \n y = -8 + BH ; \n debug_interplay ( \" \\n \" , B , x , y ) ; \n return copy_from ( s , & s -> last_frame , x , y ) ; \n }", "idx": 23035}
{"project": "FFmpeg", "commit_id": "73029abddc14c8a376ff81968fe9b1e171e4e9eb", "target": 0, "func": "static int rtcp_parse_packet ( RTPDemuxContext * s , const unsigned char * buf , \n int len ) \n { \n int payload_len ; \n while ( len >= 4 ) { \n payload_len = FFMIN ( len , ( AV_RB16 ( buf + 2 ) + 1 ) * 4 ) ; \n switch ( buf [ 1 ] ) { \n case RTCP_SR : \n if ( payload_len < 20 ) { \n av_log ( NULL , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n s -> last_rtcp_reception_time = av_gettime_relative ( ) ; \n s -> last_rtcp_ntp_time = AV_RB64 ( buf + 8 ) ; \n s -> last_rtcp_timestamp = AV_RB32 ( buf + 16 ) ; \n if ( s -> first_rtcp_ntp_time == AV_NOPTS_VALUE ) { \n s -> first_rtcp_ntp_time = s -> last_rtcp_ntp_time ; \n if ( ! s -> base_timestamp ) \n s -> base_timestamp = s -> last_rtcp_timestamp ; \n s -> rtcp_ts_offset = s -> last_rtcp_timestamp - s -> base_timestamp ; \n } \n break ; \n case RTCP_BYE : \n return - RTCP_BYE ; \n } \n buf += payload_len ; \n len -= payload_len ; \n } \n return -1 ; \n }", "idx": 23037}
{"project": "FFmpeg", "commit_id": "8e944891ce95ec8cf9f492d41cb9dac869449210", "target": 0, "func": "AVBufferRef * av_buffer_alloc ( int size ) \n { \n AVBufferRef * ret = NULL ; \n uint8_t * data = NULL ; \n data = av_malloc ( size ) ; \n if ( ! data ) \n return NULL ; \n if ( CONFIG_MEMORY_POISONING ) \n memset ( data , 0x2a , size ) ; \n ret = av_buffer_create ( data , size , av_buffer_default_free , NULL , 0 ) ; \n if ( ! ret ) \n av_freep ( & data ) ; \n return ret ; \n }", "idx": 23039}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static unsigned tget ( const uint8_t * * p , int type , int le ) \n { \n switch ( type ) { \n case TIFF_BYTE : return * ( * p ) ++ ; \n case TIFF_SHORT : return tget_short ( p , le ) ; \n case TIFF_LONG : return tget_long ( p , le ) ; \n default : return UINT_MAX ; \n } \n }", "idx": 23060}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int roq_decode_init ( AVCodecContext * avctx ) \n { \n RoqContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n s -> last_frame = & s -> frames [ 0 ] ; \n s -> current_frame = & s -> frames [ 1 ] ; \n avctx -> pix_fmt = PIX_FMT_YUV444P ; \n dsputil_init ( & s -> dsp , avctx ) ; \n return 0 ; \n }", "idx": 23080}
{"project": "FFmpeg", "commit_id": "5b6d5596807e546d87f0afd1fb760b0f887b5c97", "target": 0, "func": "static void opt_format ( const char * arg ) \n { \n if ( ! strcmp ( arg , \" \" ) ) { \n opt_image_format ( arg ) ; \n arg = \" \" ; \n } \n file_iformat = av_find_input_format ( arg ) ; \n file_oformat = guess_format ( arg , NULL , NULL ) ; \n if ( ! file_iformat && ! file_oformat ) { \n fprintf ( stderr , \" \\n \" , arg ) ; \n exit ( 1 ) ; \n } \n }", "idx": 23091}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void init_vlc_rl ( RLTable * rl ) \n { \n int i , q ; \n init_vlc ( & rl -> vlc , 9 , rl -> n + 1 , \n & rl -> table_vlc [ 0 ] [ 1 ] , 4 , 2 , \n & rl -> table_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; \n for ( q = 0 ; q < 32 ; q ++ ) { \n int qmul = q * 2 ; \n int qadd = ( q - 1 ) | 1 ; \n if ( q == 0 ) { \n qmul = 1 ; \n qadd = 0 ; \n } \n rl -> rl_vlc [ q ] = av_malloc ( rl -> vlc . table_size * sizeof ( RL_VLC_ELEM ) ) ; \n for ( i = 0 ; i < rl -> vlc . table_size ; i ++ ) { \n int code = rl -> vlc . table [ i ] [ 0 ] ; \n int len = rl -> vlc . table [ i ] [ 1 ] ; \n int level , run ; \n if ( len == 0 ) { \n run = 66 ; \n level = MAX_LEVEL ; \n } else if ( len < 0 ) { \n run = 0 ; \n level = code ; \n } else { \n if ( code == rl -> n ) { \n run = 66 ; \n level = 0 ; \n } else { \n run = rl -> table_run [ code ] + 1 ; \n level = rl -> table_level [ code ] * qmul + qadd ; \n if ( code >= rl -> last ) run += 192 ; \n } \n } \n rl -> rl_vlc [ q ] [ i ] . len = len ; \n rl -> rl_vlc [ q ] [ i ] . level = level ; \n rl -> rl_vlc [ q ] [ i ] . run = run ; \n } \n } \n }", "idx": 23095}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_material_package ( MXFPackage * package , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x4403 : \n package -> tracks_count = get_be32 ( pb ) ; \n if ( package -> tracks_count >= UINT_MAX / sizeof ( UID ) ) \n return -1 ; \n package -> tracks_refs = av_malloc ( package -> tracks_count * sizeof ( UID ) ) ; \n if ( ! package -> tracks_refs ) \n return -1 ; \n url_fskip ( pb , 4 ) ; \n get_buffer ( pb , ( uint8_t * ) package -> tracks_refs , package -> tracks_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 23098}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "func": "void ff_avg_h264_qpel4_mc00_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avg_width4_msa ( src , stride , dst , stride , 4 ) ; \n }", "idx": 23111}
{"project": "FFmpeg", "commit_id": "60819e694ee5733741da91ebc237b20621de5bc3", "target": 1, "func": "static av_cold int decode_close ( AVCodecContext * avctx ) \n { \n IVI5DecContext * ctx = avctx -> priv_data ; \n ff_ivi_free_buffers ( & ctx -> planes [ 0 ] ) ; \n if ( ctx -> frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & ctx -> frame ) ; \n return 0 ; \n }", "idx": 23127}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int idcin_probe ( AVProbeData * p ) \n { \n unsigned int number ; \n if ( p -> buf_size < 20 ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 0 ] ) ; \n if ( ( number == 0 ) || ( number > 1024 ) ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 4 ] ) ; \n if ( ( number == 0 ) || ( number > 1024 ) ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 8 ] ) ; \n if ( ( number != 0 ) && ( ( number < 8000 ) | ( number > 48000 ) ) ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 12 ] ) ; \n if ( number > 2 ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 16 ] ) ; \n if ( number > 2 ) \n return 0 ; \n return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 23147}
{"project": "FFmpeg", "commit_id": "4b54c6d08437e5e3dd9359f29b247be58fef965f", "target": 0, "func": "static int read_key ( void ) \n { \n #if defined ( HAVE_CONIO_H )  \n  \n  if ( kbhit ( ) ) \n return ( getch ( ) ) ; \n #elif defined ( HAVE_TERMIOS_H )  \n  \n  int n = 1 ; \n unsigned char ch ; \n #ifndef CONFIG_BEOS_NETSERVER \n struct timeval tv ; \n fd_set rfds ; \n FD_ZERO ( & rfds ) ; \n FD_SET ( 0 , & rfds ) ; \n tv . tv_sec = 0 ; \n tv . tv_usec = 0 ; \n n = select ( 1 , & rfds , NULL , NULL , & tv ) ; \n #endif \n if ( n > 0 ) { \n n = read ( 0 , & ch , 1 ) ; \n if ( n == 1 ) \n return ch ; \n return n ; \n } \n #endif \n return -1 ; \n }", "idx": 23157}
{"project": "FFmpeg", "commit_id": "afebf470ca73c17cc8393bfd7eeebfdf6809c2b8", "target": 0, "func": "static void test_separators ( const AVDictionary * m , const char pair , const char val ) \n { \n AVDictionary * dict = NULL ; \n char pairs [ ] = { pair , ' \\0 ' } ; \n char vals [ ] = { val , ' \\0 ' } ; \n char * buffer = NULL ; \n av_dict_copy ( & dict , m , 0 ) ; \n print_dict ( dict ) ; \n av_dict_get_string ( dict , & buffer , val , pair ) ; \n printf ( \" \\n \" , buffer ) ; \n av_dict_free ( & dict ) ; \n av_dict_parse_string ( & dict , buffer , vals , pairs , 0 ) ; \n av_freep ( & buffer ) ; \n print_dict ( dict ) ; \n av_dict_free ( & dict ) ; \n }", "idx": 23183}
{"project": "FFmpeg", "commit_id": "b0c7f5a9d82feb7f4c4cdf77f1537193670ab58b", "target": 0, "func": "static int ogg_write_packet ( AVFormatContext * avfcontext , \n int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n OggContext * context = avfcontext -> priv_data ; \n AVCodecContext * avctx = & avfcontext -> streams [ stream_index ] -> codec ; \n ogg_packet * op = & context -> op ; \n ogg_page og ; \n pts = av_rescale ( pts , avctx -> sample_rate , AV_TIME_BASE ) ; \n if ( ! size ) { \n return 0 ; \n } \n if ( ! context -> header_handled ) { \n while ( ogg_stream_flush ( & context -> os , & og ) ) { \n put_buffer ( & avfcontext -> pb , og . header , og . header_len ) ; \n put_buffer ( & avfcontext -> pb , og . body , og . body_len ) ; \n put_flush_packet ( & avfcontext -> pb ) ; \n } \n context -> header_handled = 1 ; \n } \n op -> packet = ( uint8_t * ) buf ; \n op -> bytes = size ; \n op -> b_o_s = op -> packetno == 0 ; \n op -> granulepos = pts ; \n ogg_stream_packetin ( & context -> os , op ) ; \n while ( ogg_stream_pageout ( & context -> os , & og ) ) { \n put_buffer ( & avfcontext -> pb , og . header , og . header_len ) ; \n put_buffer ( & avfcontext -> pb , og . body , og . body_len ) ; \n put_flush_packet ( & avfcontext -> pb ) ; \n } \n op -> packetno ++ ; \n return 0 ; \n }", "idx": 23188}
{"project": "FFmpeg", "commit_id": "14f063d294a18a31928d2167a66b1087910e14c8", "target": 1, "func": "void * av_malloc ( size_t size ) \n { \n void * ptr = NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  long diff ; \n #endif \n if ( size > ( INT_MAX - 32 ) ) \n return NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  ptr = malloc ( size + 32 ) ; \n if ( ! ptr ) \n return ptr ; \n diff = ( ( - ( long ) ptr - 1 ) & 31 ) + 1 ; \n ptr = ( char * ) ptr + diff ; \n ( ( char * ) ptr ) [ -1 ] = diff ; \n #elif HAVE_POSIX_MEMALIGN  \n  \n  if ( posix_memalign ( & ptr , 32 , size ) ) \n ptr = NULL ; \n #elif HAVE_MEMALIGN  \n  \n  ptr = memalign ( 32 , size ) ; \n #else \n ptr = malloc ( size ) ; \n #endif \n return ptr ; \n }", "idx": 23196}
{"project": "FFmpeg", "commit_id": "949d2176ef0a37c6ecbb65be0f1199536a2d9278", "target": 1, "func": "static void decor_c ( int32_t * dst , const int32_t * src , int coeff , ptrdiff_t len ) \n { \n int i ; \n for ( i = 0 ; i < len ; i ++ ) \n dst [ i ] += ( int ) ( src [ i ] * ( SUINT ) coeff + ( 1 << 2 ) ) >> 3 ; \n }", "idx": 23197}
{"project": "FFmpeg", "commit_id": "7f5e75eea94020aaddeda1960186ceee73ca1c36", "target": 0, "func": "static av_cold int pulse_write_header ( AVFormatContext * h ) \n { \n PulseData * s = h -> priv_data ; \n AVStream * st = NULL ; \n int ret ; \n unsigned int i ; \n pa_sample_spec ss ; \n pa_buffer_attr attr = { -1 , -1 , -1 , -1 , -1 } ; \n const char * stream_name = s -> stream_name ; \n for ( i = 0 ; i < h -> nb_streams ; i ++ ) { \n if ( h -> streams [ i ] -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n st = h -> streams [ i ] ; \n s -> stream_index = i ; \n break ; \n } \n } \n if ( ! st ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ! stream_name ) { \n if ( h -> filename [ 0 ] ) \n stream_name = h -> filename ; \n else \n stream_name = \" \" ; \n } \n ss . format = codec_id_to_pulse_format ( st -> codec -> codec_id ) ; \n ss . rate = st -> codec -> sample_rate ; \n ss . channels = st -> codec -> channels ; \n s -> pa = pa_simple_new ( s -> server , \n s -> name , \n PA_STREAM_PLAYBACK , \n s -> device , \n stream_name , \n & ss , \n NULL , \n & attr , \n & ret ) ; \n if ( ! s -> pa ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , pa_strerror ( ret ) ) ; \n return AVERROR ( EIO ) ; \n } \n avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ; \n return 0 ; \n }", "idx": 23208}
{"project": "FFmpeg", "commit_id": "241f8465d07ecc0696bcda994a1f44d836b8809c", "target": 1, "func": "int av_asrc_buffer_add_buffer ( AVFilterContext * ctx , \n uint8_t * buf , int buf_size , int sample_rate , \n int sample_fmt , int64_t channel_layout , int planar , \n int64_t pts , int av_unused flags ) \n { \n uint8_t * data [ 8 ] ; \n int linesize [ 8 ] ; \n int nb_channels = av_get_channel_layout_nb_channels ( channel_layout ) , \n nb_samples = buf_size / nb_channels / av_get_bytes_per_sample ( sample_fmt ) ; \n av_samples_fill_arrays ( data , linesize , \n buf , nb_channels , nb_samples , \n sample_fmt , 16 ) ; \n return av_asrc_buffer_add_samples ( ctx , \n data , linesize , nb_samples , \n sample_rate , \n sample_fmt , channel_layout , planar , \n pts , flags ) ; \n }", "idx": 23211}
{"project": "FFmpeg", "commit_id": "00cbe9e4053fd562b6f21e76aca6636ff926b637", "target": 1, "func": "static int vmdaudio_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n VmdAudioContext * s = avctx -> priv_data ; \n int block_type , silent_chunks ; \n unsigned char * output_samples = ( unsigned char * ) data ; \n if ( buf_size < 16 ) { \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n * data_size = 0 ; \n return buf_size ; \n } \n block_type = buf [ 6 ] ; \n if ( block_type < BLOCK_TYPE_AUDIO || block_type > BLOCK_TYPE_SILENCE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , block_type ) ; \n return AVERROR ( EINVAL ) ; \n } \n buf += 16 ; \n buf_size -= 16 ; \n silent_chunks = 0 ; \n if ( block_type == BLOCK_TYPE_INITIAL ) { \n uint32_t flags = AV_RB32 ( buf ) ; \n silent_chunks = av_popcount ( flags ) ; \n buf += 4 ; \n buf_size -= 4 ; \n } else if ( block_type == BLOCK_TYPE_SILENCE ) { \n silent_chunks = 1 ; \n buf_size = 0 ; \n } \n if ( * data_size < ( avctx -> block_align * silent_chunks + buf_size ) * s -> out_bps ) \n return -1 ; \n * data_size = vmdaudio_loadsound ( s , output_samples , buf , silent_chunks , buf_size ) ; \n return avpkt -> size ; \n }", "idx": 23212}
{"project": "FFmpeg", "commit_id": "f1caaa1c61310beba705957e6366f0392a0b005b", "target": 0, "func": "static av_cold int dnxhd_init_rc ( DNXHDEncContext * ctx ) \n { \n FF_ALLOCZ_OR_GOTO ( ctx -> m . avctx , ctx -> mb_rc , 8160 * ctx -> m . avctx -> qmax * sizeof ( RCEntry ) , fail ) ; \n if ( ctx -> m . avctx -> mb_decision != FF_MB_DECISION_RD ) \n FF_ALLOCZ_OR_GOTO ( ctx -> m . avctx , ctx -> mb_cmp , ctx -> m . mb_num * sizeof ( RCCMPEntry ) , fail ) ; \n ctx -> frame_bits = ( ctx -> cid_table -> coding_unit_size - 640 - 4 - ctx -> min_padding ) * 8 ; \n ctx -> qscale = 1 ; \n ctx -> lambda = 2 << LAMBDA_FRAC_BITS ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 23218}
{"project": "FFmpeg", "commit_id": "3438d82d4b3bd987304975961e2a42e82767107d", "target": 0, "func": "static int opt_default ( const char * opt , const char * arg ) { \n int type ; \n const AVOption * o = NULL ; \n int opt_types [ ] = { AV_OPT_FLAG_VIDEO_PARAM , AV_OPT_FLAG_AUDIO_PARAM , 0 , AV_OPT_FLAG_SUBTITLE_PARAM , 0 } ; \n for ( type = 0 ; type < CODEC_TYPE_NB ; type ++ ) { \n const AVOption * o2 = av_find_opt ( avctx_opts [ 0 ] , opt , NULL , opt_types [ type ] , opt_types [ type ] ) ; \n if ( o2 ) \n o = av_set_string ( avctx_opts [ type ] , opt , arg ) ; \n } \n if ( ! o ) \n o = av_set_string ( avformat_opts , opt , arg ) ; \n if ( ! o ) \n o = av_set_string ( sws_opts , opt , arg ) ; \n if ( ! o ) { \n if ( opt [ 0 ] == ' ' ) \n o = av_set_string ( avctx_opts [ CODEC_TYPE_AUDIO ] , opt + 1 , arg ) ; \n else if ( opt [ 0 ] == ' ' ) \n o = av_set_string ( avctx_opts [ CODEC_TYPE_VIDEO ] , opt + 1 , arg ) ; \n else if ( opt [ 0 ] == ' ' ) \n o = av_set_string ( avctx_opts [ CODEC_TYPE_SUBTITLE ] , opt + 1 , arg ) ; \n } \n if ( ! o ) \n return -1 ; \n opt_names = av_realloc ( opt_names , sizeof ( void * ) * ( opt_name_count + 1 ) ) ; \n opt_names [ opt_name_count ++ ] = o -> name ; \n #ifdef CONFIG_FFM_MUXER \n if ( avctx_opts [ 0 ] -> flags & CODEC_FLAG_BITEXACT ) \n ffm_nopts = 1 ; \n #endif \n if ( avctx_opts [ 0 ] -> debug ) \n av_log_set_level ( AV_LOG_DEBUG ) ; \n return 0 ; \n }", "idx": 23239}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_left_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n const int dc = ( src [ -1 + 0 * stride ] + src [ -1 + 1 * stride ] + src [ -1 + 2 * stride ] + src [ -1 + 3 * stride ] + 2 ) >> 2 ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( dc ) ; \n }", "idx": 23254}
{"project": "FFmpeg", "commit_id": "5183fac92fc5c574a053dd06b84e735a1ec1cfa6", "target": 1, "func": "static void decode_nal_sei_decoded_picture_hash ( HEVCContext * s ) \n { \n int cIdx , i ; \n uint8_t hash_type ; \n GetBitContext * gb = & s -> HEVClc -> gb ; \n hash_type = get_bits ( gb , 8 ) ; \n for ( cIdx = 0 ; cIdx < 3 \n ; cIdx ++ ) { \n if ( hash_type == 0 ) { \n s -> is_md5 = 1 ; \n for ( i = 0 ; i < 16 ; i ++ ) \n s -> md5 [ cIdx ] [ i ] = get_bits ( gb , 8 ) ; \n } else if ( hash_type == 1 ) { \n skip_bits ( gb , 16 ) ; \n } else if ( hash_type == 2 ) { \n skip_bits ( gb , 32 ) ; \n } \n } \n }", "idx": 23255}
{"project": "FFmpeg", "commit_id": "801dbf0269b1bb5bc70c550e971491e0aea9eb70", "target": 0, "func": "static av_cold void dcadec_flush ( AVCodecContext * avctx ) \n { \n DCAContext * s = avctx -> priv_data ; \n ff_dca_core_flush ( & s -> core ) ; \n ff_dca_xll_flush ( & s -> xll ) ; \n ff_dca_lbr_flush ( & s -> lbr ) ; \n s -> core_residual_valid = 0 ; \n }", "idx": 23257}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int check ( AVIOContext * pb , int64_t pos , int64_t * out_pos ) \n { \n MPADecodeHeader mh = { 0 } ; \n int i ; \n uint32_t header ; \n int64_t off = 0 ; \n for ( i = 0 ; i < SEEK_PACKETS ; i ++ ) { \n off = avio_seek ( pb , pos + mh . frame_size , SEEK_SET ) ; \n if ( off < 0 ) \n break ; \n header = avio_rb32 ( pb ) ; \n if ( ff_mpa_check_header ( header ) < 0 || \n avpriv_mpegaudio_decode_header ( & mh , header ) ) \n break ; \n out_pos [ i ] = off ; \n } \n return i ; \n }", "idx": 23261}
{"project": "FFmpeg", "commit_id": "fd2982a0a01942091b2f08e17486ff4562f675a6", "target": 0, "func": "int av_read_play ( AVFormatContext * s ) \n { \n if ( s -> iformat -> read_play ) \n return s -> iformat -> read_play ( s ) ; \n if ( s -> pb && s -> pb -> read_pause ) \n return av_url_read_fpause ( s -> pb , 0 ) ; \n return AVERROR ( ENOSYS ) ; \n }", "idx": 23262}
{"project": "FFmpeg", "commit_id": "ec2694d25905c217e5815947cda896aa25398388", "target": 0, "func": "static av_cold int g722_decode_init ( AVCodecContext * avctx ) \n { \n G722Context * c = avctx -> priv_data ; \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n c -> band [ 0 ] . scale_factor = 8 ; \n c -> band [ 1 ] . scale_factor = 2 ; \n c -> prev_samples_pos = 22 ; \n avcodec_get_frame_defaults ( & c -> frame ) ; \n avctx -> coded_frame = & c -> frame ; \n return 0 ; \n }", "idx": 23267}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static void buffer_release ( void * opaque , uint8_t * data ) \n { \n * ( uint8_t * ) opaque = 0 ; \n }", "idx": 23269}
{"project": "FFmpeg", "commit_id": "63b737d4f9c118853a4f8d9af641335629bdf3ab", "target": 0, "func": "static void float_to_int16_3dnow ( int16_t * dst , const float * src , int len ) { \n int i ; \n for ( i = 0 ; i < len ; i += 4 ) { \n asm volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( dst [ i ] ) \n : \" \" ( src [ i ] ) , \" \" ( src [ i + 2 ] ) \n ) ; \n } \n asm volatile ( \" \" ) ; \n }", "idx": 23270}
{"project": "FFmpeg", "commit_id": "1ec83d9a9e472f485897ac92bad9631d551a8c5b", "target": 0, "func": "static int add_shorts_metadata ( const uint8_t * * buf , int count , const char * name , \n const char * sep , TiffContext * s ) \n { \n char * ap ; \n int i ; \n int * sp = av_malloc ( count * sizeof ( int ) ) ; \n if ( ! sp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n sp [ i ] = tget_short ( buf , s -> le ) ; \n ap = shorts2str ( sp , count , sep ) ; \n av_freep ( & sp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( & s -> picture . metadata , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 23271}
{"project": "FFmpeg", "commit_id": "cec939597722663f322941b4c12e00a583e63504", "target": 1, "func": "static inline void ff_h264_biweight_WxH_mmx2 ( uint8_t * dst , uint8_t * src , int stride , int log2_denom , int weightd , int weights , int offsetd , int offsets , int w , int h ) \n { \n int x , y ; \n int offset = ( ( offsets + offsetd + 1 ) | 1 ) << log2_denom ; \n asm volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( weightd ) , \" \" ( weights ) , \" \" ( offset ) , \" \" ( log2_denom + 1 ) \n ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x += 4 ) { \n asm volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + m \" \n : \" m \" \n ) ; \n } \n src += stride ; \n dst += stride ; \n } \n }", "idx": 23283}
{"project": "FFmpeg", "commit_id": "41ee459e88093a0b7ae13b8539ed9ccd0ebd0f0b", "target": 1, "func": "static int dpx_probe ( AVProbeData * p ) \n { \n const uint8_t * b = p -> buf ; \n if ( AV_RN32 ( b ) == AV_RN32 ( \" \" ) || AV_RN32 ( b ) == AV_RN32 ( \" \" ) ) \n return AVPROBE_SCORE_EXTENSION + 1 ; \n return 0 ; \n }", "idx": 23284}
{"project": "FFmpeg", "commit_id": "b69c2e0e6dab87bb90fece1d0de47c28394aa8e6", "target": 1, "func": "static int yop_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n YopDecContext * yop = s -> priv_data ; \n int64_t frame_pos , pos_min , pos_max ; \n int frame_count ; \n av_free_packet ( & yop -> video_packet ) ; \n if ( ! stream_index ) \n return -1 ; \n pos_min = s -> data_offset ; \n pos_max = avio_size ( s -> pb ) - yop -> frame_size ; \n frame_count = ( pos_max - pos_min ) / yop -> frame_size ; \n timestamp = FFMAX ( 0 , FFMIN ( frame_count , timestamp ) ) ; \n frame_pos = timestamp * yop -> frame_size + pos_min ; \n yop -> odd_frame = timestamp & 1 ; \n avio_seek ( s -> pb , frame_pos , SEEK_SET ) ; \n return 0 ; \n }", "idx": 23285}
{"project": "FFmpeg", "commit_id": "180a0b1bcb522dab0ad828d8efb9673a6531d534", "target": 1, "func": "static void decode_nal_sei_frame_packing_arrangement ( HEVCContext * s ) \n { \n GetBitContext * gb = & s -> HEVClc -> gb ; \n int cancel , type , quincunx , content ; \n get_ue_golomb ( gb ) ; \n cancel = get_bits1 ( gb ) ; \n if ( cancel == 0 ) { \n type = get_bits ( gb , 7 ) ; \n quincunx = get_bits1 ( gb ) ; \n content = get_bits ( gb , 6 ) ; \n skip_bits ( gb , 6 ) ; \n if ( quincunx == 0 && type != 5 ) \n skip_bits ( gb , 16 ) ; \n skip_bits ( gb , 8 ) ; \n skip_bits1 ( gb ) ; \n } \n skip_bits1 ( gb ) ; \n s -> sei_frame_packing_present = ( cancel == 0 ) ; \n s -> frame_packing_arrangement_type = type ; \n s -> content_interpretation_type = content ; \n s -> quincunx_subsampling = quincunx ; \n }", "idx": 23295}
{"project": "FFmpeg", "commit_id": "e977ca2645cc6b23589ddf97ab08861064ba8792", "target": 1, "func": "void avfilter_free ( AVFilterContext * filter ) \n { \n int i ; \n AVFilterLink * link ; \n if ( filter -> filter -> uninit ) \n filter -> filter -> uninit ( filter ) ; \n for ( i = 0 ; i < filter -> input_count ; i ++ ) { \n if ( ( link = filter -> inputs [ i ] ) ) { \n if ( link -> src ) \n link -> src -> outputs [ link -> srcpad - link -> src -> output_pads ] = NULL ; \n avfilter_formats_unref ( & link -> in_formats ) ; \n avfilter_formats_unref ( & link -> out_formats ) ; \n } \n av_freep ( & link ) ; \n } \n for ( i = 0 ; i < filter -> output_count ; i ++ ) { \n if ( ( link = filter -> outputs [ i ] ) ) { \n if ( link -> dst ) \n link -> dst -> inputs [ link -> dstpad - link -> dst -> input_pads ] = NULL ; \n avfilter_formats_unref ( & link -> in_formats ) ; \n avfilter_formats_unref ( & link -> out_formats ) ; \n } \n av_freep ( & link ) ; \n } \n av_freep ( & filter -> name ) ; \n av_freep ( & filter -> input_pads ) ; \n av_freep ( & filter -> output_pads ) ; \n av_freep ( & filter -> inputs ) ; \n av_freep ( & filter -> outputs ) ; \n av_freep ( & filter -> priv ) ; \n av_free ( filter ) ; \n }", "idx": 23302}
{"project": "FFmpeg", "commit_id": "078d43e23a7a3d64aafee8a58b380d3e139b3020", "target": 1, "func": "static int mpegts_handle_packet ( AVFormatContext * ctx , PayloadContext * data , \n AVStream * st , AVPacket * pkt , uint32_t * timestamp , \n const uint8_t * buf , int len , uint16_t seq , \n int flags ) \n { \n int ret ; \n * timestamp = RTP_NOTS_VALUE ; \n if ( ! data -> ts ) \n return AVERROR ( EINVAL ) ; \n if ( ! buf ) { \n if ( data -> read_buf_index >= data -> read_buf_size ) \n return AVERROR ( EAGAIN ) ; \n ret = ff_mpegts_parse_packet ( data -> ts , pkt , data -> buf + data -> read_buf_index , \n data -> read_buf_size - data -> read_buf_index ) ; \n if ( ret < 0 ) \n return AVERROR ( EAGAIN ) ; \n data -> read_buf_index += ret ; \n if ( data -> read_buf_index < data -> read_buf_size ) \n return 1 ; \n else \n return 0 ; \n } \n ret = ff_mpegts_parse_packet ( data -> ts , pkt , buf , len ) ; \n if ( ret < 0 ) \n return AVERROR ( EAGAIN ) ; \n if ( ret < len ) { \n data -> read_buf_size = FFMIN ( len - ret , sizeof ( data -> buf ) ) ; \n memcpy ( data -> buf , buf + ret , data -> read_buf_size ) ; \n data -> read_buf_index = 0 ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 23305}
{"project": "FFmpeg", "commit_id": "169c1cfa928040b83f2ac8386333ec5e5cff3df7", "target": 1, "func": "static int pvf_read_header ( AVFormatContext * s ) \n { \n char buffer [ 32 ] ; \n AVStream * st ; \n int bps , channels , sample_rate ; \n avio_skip ( s -> pb , 5 ) ; \n ff_get_line ( s -> pb , buffer , sizeof ( buffer ) ) ; \n if ( sscanf ( buffer , \" \" , \n & channels , \n & sample_rate , \n & bps ) != 3 ) \n return AVERROR_INVALIDDATA ; \n if ( channels <= 0 || bps <= 0 || sample_rate <= 0 ) \n return AVERROR_INVALIDDATA ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codecpar -> channels = channels ; \n st -> codecpar -> sample_rate = sample_rate ; \n st -> codecpar -> codec_id = ff_get_pcm_codec_id ( bps , 0 , 1 , 0xFFFF ) ; \n st -> codecpar -> bits_per_coded_sample = bps ; \n st -> codecpar -> block_align = bps * st -> codecpar -> channels / 8 ; \n avpriv_set_pts_info ( st , 64 , 1 , st -> codecpar -> sample_rate ) ; \n return 0 ; \n }", "idx": 23313}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yuv2yuv1 ) ( int16_t * lumSrc , int16_t * chrSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , int dstW , int chrDstW ) \n { \n #ifdef HAVE_MMX \n if ( uDest != NULL ) \n { \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n } \n asm volatile ( \n YSCALEYUV2YV121 \n :: \" r \" \" r \" \n \" g \" \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = lumSrc [ i ] >> 7 ; \n if ( val & 256 ) { \n if ( val < 0 ) val = 0 ; \n else val = 255 ; \n } \n dest [ i ] = val ; \n } \n if ( uDest != NULL ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = chrSrc [ i ] >> 7 ; \n int v = chrSrc [ i + 2048 ] >> 7 ; \n if ( ( u | v ) & 256 ) { \n if ( u < 0 ) u = 0 ; \n else if ( u > 255 ) u = 255 ; \n if ( v < 0 ) v = 0 ; \n else if ( v > 255 ) v = 255 ; \n } \n uDest [ i ] = u ; \n vDest [ i ] = v ; \n } \n #endif \n }", "idx": 23321}
{"project": "FFmpeg", "commit_id": "138902dfb60fbb87fb65a8c4800f8ac661394b72", "target": 1, "func": "static int read_dialogue ( ASSContext * ass , AVBPrint * dst , const uint8_t * p , \n int64_t * start , int * duration ) \n { \n int pos ; \n int64_t end ; \n int hh1 , mm1 , ss1 , ms1 ; \n int hh2 , mm2 , ss2 , ms2 ; \n if ( sscanf ( p , \" \" , \n & hh1 , & mm1 , & ss1 , & ms1 , \n & hh2 , & mm2 , & ss2 , & ms2 , & pos ) >= 8 ) { \n const int layer = atoi ( p + 10 ) ; \n end = ( hh2 * 3600LL + mm2 * 60LL + ss2 ) * 100LL + ms2 ; \n * start = ( hh1 * 3600LL + mm1 * 60LL + ss1 ) * 100LL + ms1 ; \n * duration = end - * start ; \n av_bprint_clear ( dst ) ; \n av_bprintf ( dst , \" \" , ass -> readorder ++ , layer , p + pos ) ; \n while ( dst -> len > 0 && \n dst -> str [ dst -> len - 1 ] == ' \\r ' || \n dst -> str [ dst -> len - 1 ] == ' \\n ' ) \n dst -> str [ -- dst -> len ] = 0 ; \n return 0 ; \n } \n return -1 ; \n }", "idx": 23322}
{"project": "FFmpeg", "commit_id": "932e6a5a4c78250e3cab4f65215214fb0dbf51f7", "target": 1, "func": "static void quantize_bands ( int ( * out ) [ 2 ] , const float * in , const float * scaled , \n int size , float Q34 , int is_signed , int maxval ) \n { \n int i ; \n double qc ; \n for ( i = 0 ; i < size ; i ++ ) { \n qc = scaled [ i ] * Q34 ; \n out [ i ] [ 0 ] = ( int ) FFMIN ( ( int ) qc , maxval ) ; \n out [ i ] [ 1 ] = ( int ) FFMIN ( ( int ) ( qc + 0.4054 ) , maxval ) ; \n if ( is_signed && in [ i ] < 0.0f ) { \n out [ i ] [ 0 ] = - out [ i ] [ 0 ] ; \n out [ i ] [ 1 ] = - out [ i ] [ 1 ] ; \n } \n } \n }", "idx": 23324}
{"project": "FFmpeg", "commit_id": "df3b17eba47e635a694acb18b74e389194355f45", "target": 1, "func": "av_cold int vaapi_device_init ( const char * device ) \n { \n int err ; \n err = av_hwdevice_ctx_create ( & hw_device_ctx , AV_HWDEVICE_TYPE_VAAPI , \n device , NULL , 0 ) ; \n if ( err < 0 ) { \n av_log ( & vaapi_log , AV_LOG_ERROR , \" \\n \" ) ; \n return err ; \n } \n return 0 ; \n }", "idx": 23325}
{"project": "FFmpeg", "commit_id": "907783f221ad9594a528681e30777705f11bf0b5", "target": 0, "func": "static void rtsp_parse_rtp_info ( RTSPState * rt , const char * p ) \n { \n int read = 0 ; \n char key [ 20 ] , value [ 1024 ] , url [ 1024 ] = \" \" ; \n uint32_t seq = 0 , rtptime = 0 ; \n for ( ; ; ) { \n p += strspn ( p , SPACE_CHARS ) ; \n if ( ! * p ) \n break ; \n get_word_sep ( key , sizeof ( key ) , \" \" , & p ) ; \n if ( * p != ' ' ) \n break ; \n p ++ ; \n get_word_sep ( value , sizeof ( value ) , \" \" , & p ) ; \n read ++ ; \n if ( ! strcmp ( key , \" \" ) ) \n av_strlcpy ( url , value , sizeof ( url ) ) ; \n else if ( ! strcmp ( key , \" \" ) ) \n seq = strtol ( value , NULL , 10 ) ; \n else if ( ! strcmp ( key , \" \" ) ) \n rtptime = strtol ( value , NULL , 10 ) ; \n if ( * p == ' ' ) { \n handle_rtp_info ( rt , url , seq , rtptime ) ; \n url [ 0 ] = ' \\0 ' ; \n seq = rtptime = 0 ; \n read = 0 ; \n } \n if ( * p ) \n p ++ ; \n } \n if ( read > 0 ) \n handle_rtp_info ( rt , url , seq , rtptime ) ; \n }", "idx": 23329}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_right ( const char * arg ) \n { \n frame_padright = atoi ( arg ) ; \n if ( frame_padright < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n }", "idx": 23331}
{"project": "FFmpeg", "commit_id": "69e456d7fbc5fff88acf747d135bf15c8e511c59", "target": 0, "func": "static int iszero ( const int16_t * c , int sz ) \n { \n int n ; \n for ( n = 0 ; n < sz ; n += 4 ) \n if ( AV_RN32A ( & c [ n ] ) ) \n return 0 ; \n return 1 ; \n }", "idx": 23333}
{"project": "FFmpeg", "commit_id": "121d3875b692c83866928e271c4b6d20d680d1a6", "target": 0, "func": "void avpriv_set_pts_info ( AVStream * s , int pts_wrap_bits , \n unsigned int pts_num , unsigned int pts_den ) \n { \n AVRational new_tb ; \n if ( av_reduce ( & new_tb . num , & new_tb . den , pts_num , pts_den , INT_MAX ) ) { \n if ( new_tb . num != pts_num ) \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , s -> index , pts_num / new_tb . num ) ; \n } else \n av_log ( NULL , AV_LOG_WARNING , \" \\n \" , s -> index ) ; \n if ( new_tb . num <= 0 || new_tb . den <= 0 ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , s -> index ) ; \n return ; \n } \n s -> time_base = new_tb ; \n s -> pts_wrap_bits = pts_wrap_bits ; \n }", "idx": 23334}
{"project": "FFmpeg", "commit_id": "5484170ac729d739b2747979408f47bd9aa31c7c", "target": 1, "func": "static int finish_frame ( AVCodecContext * avctx , AVFrame * pict ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n MpegEncContext * s = & r -> s ; \n int got_picture = 0 ; \n ff_er_frame_end ( s ) ; \n ff_MPV_frame_end ( s ) ; \n if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) \n ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ) ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { \n * pict = s -> current_picture_ptr -> f ; \n got_picture = 1 ; \n } else if ( s -> last_picture_ptr != NULL ) { \n * pict = s -> last_picture_ptr -> f ; \n got_picture = 1 ; \n } \n if ( got_picture ) \n ff_print_debug_info ( s , pict ) ; \n return got_picture ; \n }", "idx": 23343}
{"project": "FFmpeg", "commit_id": "6029b8a6bbc8bbf7799108582e71078ec0bde1cf", "target": 0, "func": "static int s337m_probe ( AVProbeData * p ) \n { \n uint64_t state = 0 ; \n int markers [ 3 ] = { 0 } ; \n int i , sum , max , data_type , data_size , offset ; \n uint8_t * buf ; \n for ( buf = p -> buf ; buf < p -> buf + p -> buf_size ; buf ++ ) { \n state = ( state << 8 ) | * buf ; \n if ( ! IS_LE_MARKER ( state ) ) \n continue ; \n if ( IS_16LE_MARKER ( state ) ) { \n data_type = AV_RL16 ( buf + 1 ) ; \n data_size = AV_RL16 ( buf + 3 ) ; \n buf += 4 ; \n } else { \n data_type = AV_RL24 ( buf + 1 ) ; \n data_size = AV_RL24 ( buf + 4 ) ; \n buf += 6 ; \n } \n if ( s337m_get_offset_and_codec ( NULL , state , data_type , data_size , & offset , NULL ) ) \n continue ; \n i = IS_16LE_MARKER ( state ) ? 0 : IS_20LE_MARKER ( state ) ? 1 : 2 ; \n markers [ i ] ++ ; \n buf += offset ; \n state = 0 ; \n } \n sum = max = 0 ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( markers ) ; i ++ ) { \n sum += markers [ i ] ; \n if ( markers [ max ] < markers [ i ] ) \n max = i ; \n } \n if ( markers [ max ] > 3 && markers [ max ] * 4 > sum * 3 ) \n return AVPROBE_SCORE_EXTENSION + 1 ; \n return 0 ; \n }", "idx": 23345}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yuv2nv12X ) ( SwsContext * c , const int16_t * lumFilter , const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , enum PixelFormat dstFormat ) \n { \n yuv2nv12XinC ( lumFilter , lumSrc , lumFilterSize , \n chrFilter , chrSrc , chrFilterSize , \n dest , uDest , dstW , chrDstW , dstFormat ) ; \n }", "idx": 23346}
{"project": "FFmpeg", "commit_id": "0d65e0f8cb0f924be95650f50f3d05d0b223aceb", "target": 1, "func": "int get_filtered_video_frame ( AVFilterContext * ctx , AVFrame * frame , \n AVFilterBufferRef * * picref_ptr , AVRational * tb ) \n { \n int ret ; \n AVFilterBufferRef * picref ; \n if ( ( ret = avfilter_request_frame ( ctx -> inputs [ 0 ] ) ) < 0 ) \n return ret ; \n if ( ! ( picref = ctx -> inputs [ 0 ] -> cur_buf ) ) \n return AVERROR ( ENOENT ) ; \n * picref_ptr = picref ; \n ctx -> inputs [ 0 ] -> cur_buf = NULL ; \n * tb = ctx -> inputs [ 0 ] -> time_base ; \n memcpy ( frame -> data , picref -> data , sizeof ( frame -> data ) ) ; \n memcpy ( frame -> linesize , picref -> linesize , sizeof ( frame -> linesize ) ) ; \n frame -> pkt_pos = picref -> pos ; \n frame -> interlaced_frame = picref -> video -> interlaced ; \n frame -> top_field_first = picref -> video -> top_field_first ; \n frame -> key_frame = picref -> video -> key_frame ; \n frame -> pict_type = picref -> video -> pict_type ; \n frame -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio ; \n return 1 ; \n }", "idx": 23348}
{"project": "FFmpeg", "commit_id": "3d9cb583c8f005a260d255853ef5f1c21e8599a0", "target": 1, "func": "static int hq_decode_block ( HQContext * c , GetBitContext * gb , int16_t block [ 64 ] , \n int qsel , int is_chroma , int is_hqa ) \n { \n const int32_t * q ; \n int val , pos = 1 ; \n memset ( block , 0 , 64 * sizeof ( * block ) ) ; \n if ( ! is_hqa ) { \n block [ 0 ] = get_sbits ( gb , 9 ) * 64 ; \n q = ff_hq_quants [ qsel ] [ is_chroma ] [ get_bits ( gb , 2 ) ] ; \n } else { \n q = ff_hq_quants [ qsel ] [ is_chroma ] [ get_bits ( gb , 2 ) ] ; \n block [ 0 ] = get_sbits ( gb , 9 ) * 64 ; \n } \n for ( ; ; ) { \n val = get_vlc2 ( gb , c -> hq_ac_vlc . table , 9 , 2 ) ; \n if ( val < 0 ) \n return AVERROR_INVALIDDATA ; \n pos += ff_hq_ac_skips [ val ] ; \n if ( pos >= 64 ) \n break ; \n block [ ff_zigzag_direct [ pos ] ] = ( ff_hq_ac_syms [ val ] * q [ pos ] ) >> 12 ; \n pos ++ ; \n } \n return 0 ; \n }", "idx": 23350}
{"project": "FFmpeg", "commit_id": "fc3a03fcf9cd7eafe7342e2508e6128888efa0bb", "target": 1, "func": "AVFrame * ff_framequeue_take ( FFFrameQueue * fq ) \n { \n FFFrameBucket * b ; \n check_consistency ( fq ) ; \n av_assert1 ( fq -> queued ) ; \n b = bucket ( fq , 0 ) ; \n fq -> queued -- ; \n fq -> tail ++ ; \n fq -> tail &= fq -> allocated - 1 ; \n fq -> total_frames_tail ++ ; \n fq -> total_samples_tail += b -> frame -> nb_samples ; \n check_consistency ( fq ) ; \n return b -> frame ; \n }", "idx": 23357}
{"project": "FFmpeg", "commit_id": "fb9187129c3d07ac6d0f7deaa27f1248394d8f91", "target": 0, "func": "void av_log_format_line ( void * ptr , int level , const char * fmt , va_list vl , \n char * line , int line_size , int * print_prefix ) \n { \n AVBPrint part [ 4 ] ; \n format_line ( ptr , level , fmt , vl , part , print_prefix , NULL ) ; \n snprintf ( line , line_size , \" \" , part [ 0 ] . str , part [ 1 ] . str , part [ 2 ] . str , part [ 3 ] . str ) ; \n av_bprint_finalize ( part + 3 , NULL ) ; \n }", "idx": 23372}
{"project": "FFmpeg", "commit_id": "dce25564cc554cc85c8c28928b1b8d3f965c1b16", "target": 1, "func": "int ff_mov_lang_to_iso639 ( int code , char * to ) \n { \n int i ; \n if ( code > 138 ) { \n for ( i = 2 ; i >= 0 ; i -- ) { \n to [ i ] = 0x60 + ( code & 0x1f ) ; \n code >>= 5 ; \n } \n return 1 ; \n } \n if ( code >= FF_ARRAY_ELEMS ( mov_mdhd_language_map ) ) \n return 0 ; \n if ( ! mov_mdhd_language_map [ code ] ) \n return 0 ; \n strncpy ( to , mov_mdhd_language_map [ code ] , 4 ) ; \n return 1 ; \n }", "idx": 23391}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_vp3dsp_init_x86 ( VP3DSPContext * c , int flags ) \n { \n #if HAVE_YASM  \n  \n  int cpuflags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( HAVE_MMX && cpuflags & AV_CPU_FLAG_MMX ) { \n c -> idct_put = ff_vp3_idct_put_mmx ; \n c -> idct_add = ff_vp3_idct_add_mmx ; \n c -> idct_perm = FF_PARTTRANS_IDCT_PERM ; \n } \n #endif \n if ( HAVE_MMXEXT && cpuflags & AV_CPU_FLAG_MMXEXT ) { \n c -> idct_dc_add = ff_vp3_idct_dc_add_mmx2 ; \n if ( ! ( flags & CODEC_FLAG_BITEXACT ) ) { \n c -> v_loop_filter = ff_vp3_v_loop_filter_mmx2 ; \n c -> h_loop_filter = ff_vp3_h_loop_filter_mmx2 ; \n } \n } \n if ( cpuflags & AV_CPU_FLAG_SSE2 ) { \n c -> idct_put = ff_vp3_idct_put_sse2 ; \n c -> idct_add = ff_vp3_idct_add_sse2 ; \n c -> idct_perm = FF_TRANSPOSE_IDCT_PERM ; \n } \n #endif \n }", "idx": 23395}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int decode_hrd ( VC9Context * v , GetBitContext * gb ) \n { \n int i , num ; \n num = get_bits ( gb , 5 ) ; \n if ( v -> hrd_rate || num != v -> hrd_num_leaky_buckets ) \n { \n av_freep ( & v -> hrd_rate ) ; \n } \n if ( ! v -> hrd_rate ) v -> hrd_rate = av_malloc ( num ) ; \n if ( ! v -> hrd_rate ) return -1 ; \n if ( v -> hrd_buffer || num != v -> hrd_num_leaky_buckets ) \n { \n av_freep ( & v -> hrd_buffer ) ; \n } \n if ( ! v -> hrd_buffer ) v -> hrd_buffer = av_malloc ( num ) ; \n if ( ! v -> hrd_buffer ) return -1 ; \n v -> hrd_num_leaky_buckets = num ; \n v -> bit_rate_exponent = get_bits ( gb , 4 ) ; \n v -> buffer_size_exponent = get_bits ( gb , 4 ) ; \n for ( i = 0 ; i < num ; i ++ ) \n { \n v -> hrd_rate [ i ] = get_bits ( gb , 16 ) ; \n if ( i && v -> hrd_rate [ i - 1 ] >= v -> hrd_rate [ i ] ) \n { \n av_log ( v , AV_LOG_ERROR , \" \" \n \" \\n \" , v -> hrd_rate [ i - 1 ] , v -> hrd_rate [ i ] ) ; \n return -1 ; \n } \n v -> hrd_buffer [ i ] = get_bits ( gb , 16 ) ; \n if ( i && v -> hrd_buffer [ i - 1 ] < v -> hrd_buffer [ i ] ) \n { \n av_log ( v , AV_LOG_ERROR , \" \" \n \" \\n \" , v -> hrd_buffer [ i - 1 ] , v -> hrd_buffer [ i ] ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 23406}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_encode_close ( AVCodecContext * avccontext ) \n { \n OggVorbisContext * context = avccontext -> priv_data ; \n vorbis_analysis_wrote ( & context -> vd , 0 ) ; \n vorbis_block_clear ( & context -> vb ) ; \n vorbis_dsp_clear ( & context -> vd ) ; \n vorbis_info_clear ( & context -> vi ) ; \n av_freep ( & avccontext -> coded_frame ) ; \n av_freep ( & avccontext -> extradata ) ; \n return 0 ; \n }", "idx": 23424}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static void generate_coupling_coordinates ( AC3DecodeContext * ctx ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n uint8_t exp , mstrcplco ; \n int16_t mant ; \n uint32_t cplbndstrc = ( 1 << ab -> ncplsubnd ) >> 1 ; \n int ch , bnd , sbnd ; \n float cplco ; \n if ( ab -> cplcoe ) \n for ( ch = 0 ; ch < ctx -> bsi . nfchans ; ch ++ ) \n if ( ab -> cplcoe & ( 1 << ch ) ) { \n mstrcplco = 3 * ab -> mstrcplco [ ch ] ; \n sbnd = ab -> cplbegf ; \n for ( bnd = 0 ; bnd < ab -> ncplbnd ; bnd ++ ) { \n exp = ab -> cplcoexp [ ch ] [ bnd ] ; \n if ( exp == 15 ) \n mant = ab -> cplcomant [ ch ] [ bnd ] <<= 14 ; \n else \n mant = ( ab -> cplcomant [ ch ] [ bnd ] | 0x10 ) << 13 ; \n cplco = to_float ( exp + mstrcplco , mant ) ; \n if ( ctx -> bsi . acmod == 0x02 && ( ab -> flags & AC3_AB_PHSFLGINU ) && ch == 1 \n && ( ab -> phsflg & ( 1 << bnd ) ) ) \n cplco = - cplco ; \n ab -> cplco [ ch ] [ sbnd ++ ] = cplco ; \n while ( cplbndstrc & ab -> cplbndstrc ) { \n cplbndstrc >>= 1 ; \n ab -> cplco [ ch ] [ sbnd ++ ] = cplco ; \n } \n cplbndstrc >>= 1 ; \n } \n } \n }", "idx": 23442}
{"project": "FFmpeg", "commit_id": "e2193b53eab9f207544a75ebaf51871b7a1a7931", "target": 0, "func": "static int update_streams_from_subdemuxer ( AVFormatContext * s , struct playlist * pls ) \n { \n while ( pls -> n_main_streams < pls -> ctx -> nb_streams ) { \n int ist_idx = pls -> n_main_streams ; \n AVStream * st = avformat_new_stream ( s , NULL ) ; \n AVStream * ist = pls -> ctx -> streams [ ist_idx ] ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n st -> id = pls -> index ; \n set_stream_info_from_input_stream ( st , pls , ist ) ; \n dynarray_add ( & pls -> main_streams , & pls -> n_main_streams , st ) ; \n add_stream_to_programs ( s , pls , st ) ; \n } \n return 0 ; \n }", "idx": 23448}
{"project": "FFmpeg", "commit_id": "3f50965b28d0c4ef10dde0bf2f7a9f78fa36b378", "target": 0, "func": "static inline void h264_loop_filter_luma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int8_t * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n if ( tc0 [ i ] < 0 ) { \n pix += 4 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 4 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int p2 = pix [ -3 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n const int q2 = pix [ 2 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n int tc = tc0 [ i ] ; \n int i_delta ; \n if ( FFABS ( p2 - p0 ) < beta ) { \n if ( tc0 [ i ] ) \n pix [ -2 * xstride ] = p1 + av_clip ( ( ( p2 + ( ( p0 + q0 + 1 ) >> 1 ) ) >> 1 ) - p1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n if ( FFABS ( q2 - q0 ) < beta ) { \n if ( tc0 [ i ] ) \n pix [ xstride ] = q1 + av_clip ( ( ( q2 + ( ( p0 + q0 + 1 ) >> 1 ) ) >> 1 ) - q1 , - tc0 [ i ] , tc0 [ i ] ) ; \n tc ++ ; \n } \n i_delta = av_clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = av_clip_uint8 ( p0 + i_delta ) ; \n pix [ 0 ] = av_clip_uint8 ( q0 - i_delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 23459}
{"project": "FFmpeg", "commit_id": "42fb414804419c3fc269c73ad049f218f8813ed0", "target": 0, "func": "static int mov_write_udta_tag ( ByteIOContext * pb , MOVContext * mov , \n AVFormatContext * s ) \n { \n offset_t pos = url_ftell ( pb ) ; \n int i ; \n put_be32 ( pb , 0 ) ; \n put_tag ( pb , \" \" ) ; \n mov_write_meta_tag ( pb , mov , s ) ; \n if ( mov -> mode == MODE_MOV ) { \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) { \n if ( mov -> tracks [ i ] . entry <= 0 ) continue ; \n if ( mov -> tracks [ i ] . enc -> codec_id == CODEC_ID_AAC || \n mov -> tracks [ i ] . enc -> codec_id == CODEC_ID_MPEG4 ) { \n mov_write_string_tag ( pb , \" \\251 \" , \" \" , 0 ) ; \n break ; \n } \n } \n mov_write_string_tag ( pb , \" \\251 \" , s -> title , 0 ) ; \n mov_write_string_tag ( pb , \" \\251 \" , s -> author , 0 ) ; \n mov_write_string_tag ( pb , \" \\251 \" , s -> album , 0 ) ; \n mov_write_day_tag ( pb , s -> year , 0 ) ; \n if ( mov -> tracks [ 0 ] . enc && ! ( mov -> tracks [ 0 ] . enc -> flags & CODEC_FLAG_BITEXACT ) ) \n mov_write_string_tag ( pb , \" \\251 \" , LIBAVFORMAT_IDENT , 0 ) ; \n mov_write_string_tag ( pb , \" \\251 \" , s -> comment , 0 ) ; \n mov_write_string_tag ( pb , \" \\251 \" , s -> genre , 0 ) ; \n } \n return updateSize ( pb , pos ) ; \n }", "idx": 23464}
{"project": "FFmpeg", "commit_id": "7248797c03e8fcddc1f1ab5887d1e53cc691a2c2", "target": 0, "func": "static void selfTest ( uint8_t * ref [ 4 ] , int refStride [ 4 ] , int w , int h ) \n { \n const int flags [ ] = { SWS_FAST_BILINEAR , \n SWS_BILINEAR , SWS_BICUBIC , \n SWS_X , SWS_POINT , SWS_AREA , 0 } ; \n const int srcW = w ; \n const int srcH = h ; \n const int dstW [ ] = { srcW - srcW / 3 , srcW , srcW + srcW / 3 , 0 } ; \n const int dstH [ ] = { srcH - srcH / 3 , srcH , srcH + srcH / 3 , 0 } ; \n enum PixelFormat srcFormat , dstFormat ; \n for ( srcFormat = 0 ; srcFormat < PIX_FMT_NB ; srcFormat ++ ) { \n for ( dstFormat = 0 ; dstFormat < PIX_FMT_NB ; dstFormat ++ ) { \n int i , j , k ; \n int res = 0 ; \n printf ( \" \\n \" , \n sws_format_name ( srcFormat ) , \n sws_format_name ( dstFormat ) ) ; \n fflush ( stdout ) ; \n for ( i = 0 ; dstW [ i ] && ! res ; i ++ ) \n for ( j = 0 ; dstH [ j ] && ! res ; j ++ ) \n for ( k = 0 ; flags [ k ] && ! res ; k ++ ) \n res = doTest ( ref , refStride , w , h , srcFormat , dstFormat , \n srcW , srcH , dstW [ i ] , dstH [ j ] , flags [ k ] ) ; \n } \n } \n }", "idx": 23466}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_biwgt_4width_msa ( uint8_t * src , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride , \n int32_t height , \n int32_t log2_denom , \n int32_t src_weight , \n int32_t dst_weight , \n int32_t offset_in ) \n { \n if ( 2 == height ) { \n avc_biwgt_4x2_msa ( src , src_stride , dst , dst_stride , \n log2_denom , src_weight , dst_weight , \n offset_in ) ; \n } else { \n avc_biwgt_4x4multiple_msa ( src , src_stride , dst , dst_stride , \n height , log2_denom , src_weight , \n dst_weight , offset_in ) ; \n } \n }", "idx": 23467}
{"project": "FFmpeg", "commit_id": "44e2105189ac66637f34c764febc349238250b1d", "target": 1, "func": "static void decode_pitch_lag_high ( int * lag_int , int * lag_frac , int pitch_index , \n uint8_t * base_lag_int , int subframe ) \n { \n if ( subframe == 0 || subframe == 2 ) { \n if ( pitch_index < 376 ) { \n * lag_int = ( pitch_index + 137 ) >> 2 ; \n * lag_frac = pitch_index - ( * lag_int << 2 ) + 136 ; \n } else if ( pitch_index < 440 ) { \n * lag_int = ( pitch_index + 257 - 376 ) >> 1 ; \n * lag_frac = ( pitch_index - ( * lag_int << 1 ) + 256 - 376 ) << 1 ; \n } else { \n * lag_int = pitch_index - 280 ; \n * lag_frac = 0 ; \n } \n * base_lag_int = av_clip ( * lag_int - 8 - ( * lag_frac < 0 ) , \n AMRWB_P_DELAY_MIN , AMRWB_P_DELAY_MAX - 15 ) ; \n } else { \n * lag_int = ( pitch_index + 1 ) >> 2 ; \n * lag_frac = pitch_index - ( * lag_int << 2 ) ; \n * lag_int += * base_lag_int ; \n } \n }", "idx": 23477}
{"project": "FFmpeg", "commit_id": "6d695d7acc4cb1da84eb73710e05a4c090e5ab31", "target": 1, "func": "static int amv_encode_picture ( AVCodecContext * avctx , AVPacket * pkt , \n const AVFrame * pic_arg , int * got_packet ) \n { \n MpegEncContext * s = avctx -> priv_data ; \n AVFrame * pic ; \n int i , ret ; \n int chroma_h_shift , chroma_v_shift ; \n av_pix_fmt_get_chroma_sub_sample ( avctx -> pix_fmt , & chroma_h_shift , & chroma_v_shift ) ; \n if ( s -> avctx -> flags & CODEC_FLAG_EMU_EDGE ) \n return AVERROR ( EINVAL ) ; \n if ( avctx -> height & 15 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n pic = av_frame_clone ( pic_arg ) ; \n if ( ! pic ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int vsample = i ? 2 >> chroma_v_shift : 2 ; \n pic -> data [ i ] += ( pic -> linesize [ i ] * ( vsample * ( 8 * s -> mb_height - ( ( s -> height / V_MAX ) & 7 ) ) - 1 ) ) ; \n pic -> linesize [ i ] *= -1 ; \n } \n ret = ff_MPV_encode_picture ( avctx , pkt , pic , got_packet ) ; \n av_frame_free ( & pic ) ; \n return ret ; \n }", "idx": 23482}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline void halfpel_motion_search4 ( MpegEncContext * s , \n int * mx_ptr , int * my_ptr , int dmin , \n int xmin , int ymin , int xmax , int ymax , \n int pred_x , int pred_y , int block_x , int block_y , \n uint8_t * ref_picture ) \n { \n UINT16 * mv_penalty = s -> mv_penalty [ s -> f_code ] + MAX_MV ; \n const int quant = s -> qscale ; \n int pen_x , pen_y ; \n int mx , my , mx1 , my1 , d , xx , yy , dminh ; \n UINT8 * pix , * ptr ; \n xx = 8 * block_x ; \n yy = 8 * block_y ; \n pix = s -> new_picture [ 0 ] + ( yy * s -> linesize ) + xx ; \n mx = * mx_ptr ; \n my = * my_ptr ; \n ptr = ref_picture + ( ( yy + my ) * s -> linesize ) + xx + mx ; \n dminh = dmin ; \n if ( mx > xmin && mx < xmax && \n my > ymin && my < ymax ) { \n mx = mx1 = 2 * mx ; \n my = my1 = 2 * my ; \n if ( dmin < Z_THRESHOLD && mx == 0 && my == 0 ) { \n * mx_ptr = 0 ; \n * my_ptr = 0 ; \n return ; \n } \n pen_x = pred_x + mx ; \n pen_y = pred_y + my ; \n ptr -= s -> linesize ; \n CHECK_HALF_MV4 ( xy2 , -1 , -1 )  \n CHECK_HALF_MV4 ( y2 , 0 , -1 )  \n CHECK_HALF_MV4 ( xy2 , +1 , -1 )  \n ptr += s -> linesize ; \n CHECK_HALF_MV4 ( x2 , -1 , 0 )  \n CHECK_HALF_MV4 ( x2 , +1 , 0 )  \n CHECK_HALF_MV4 ( xy2 , -1 , +1 )  \n CHECK_HALF_MV4 ( y2 , 0 , +1 )  \n CHECK_HALF_MV4 ( xy2 , +1 , +1 )  \n } else { \n mx *= 2 ; \n my *= 2 ; \n } \n * mx_ptr = mx ; \n * my_ptr = my ; \n }", "idx": 23487}
{"project": "FFmpeg", "commit_id": "1303d62d8416fa315a0cc7bbbe35cfdab787ea92", "target": 0, "func": "static int mpegts_raw_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int ret , i ; \n int64_t pcr_h , next_pcr_h , pos ; \n int pcr_l , next_pcr_l ; \n uint8_t pcr_buf [ 12 ] ; \n if ( av_new_packet ( pkt , TS_PACKET_SIZE ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n pkt -> pos = url_ftell ( s -> pb ) ; \n ret = read_packet ( s -> pb , pkt -> data , ts -> raw_packet_size ) ; \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return ret ; \n } \n if ( ts -> mpeg2ts_compute_pcr ) { \n if ( parse_pcr ( & pcr_h , & pcr_l , pkt -> data ) == 0 ) { \n pos = url_ftell ( s -> pb ) ; \n for ( i = 0 ; i < MAX_PACKET_READAHEAD ; i ++ ) { \n url_fseek ( s -> pb , pos + i * ts -> raw_packet_size , SEEK_SET ) ; \n get_buffer ( s -> pb , pcr_buf , 12 ) ; \n if ( parse_pcr ( & next_pcr_h , & next_pcr_l , pcr_buf ) == 0 ) { \n ts -> pcr_incr = ( ( next_pcr_h - pcr_h ) * 300 + ( next_pcr_l - pcr_l ) ) / \n ( i + 1 ) ; \n break ; \n } \n } \n url_fseek ( s -> pb , pos , SEEK_SET ) ; \n ts -> cur_pcr = pcr_h * 300 + pcr_l ; \n } \n pkt -> pts = ts -> cur_pcr ; \n pkt -> duration = ts -> pcr_incr ; \n ts -> cur_pcr += ts -> pcr_incr ; \n } \n pkt -> stream_index = 0 ; \n return 0 ; \n }", "idx": 23499}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int avio_open2 ( AVIOContext * * s , const char * filename , int flags , \n const AVIOInterruptCB * int_cb , AVDictionary * * options ) \n { \n URLContext * h ; \n int err ; \n err = ffurl_open ( & h , filename , flags , int_cb , options ) ; \n if ( err < 0 ) \n return err ; \n err = ffio_fdopen ( s , h ) ; \n if ( err < 0 ) { \n ffurl_close ( h ) ; \n return err ; \n } \n return 0 ; \n }", "idx": 23506}
{"project": "FFmpeg", "commit_id": "0ccabeeaef77e240f2a44f78271a8914a23e239b", "target": 0, "func": "static AVFilterBufferRef * get_video_buffer ( AVFilterLink * link , int perms , \n int w , int h ) \n { \n FlipContext * flip = link -> dst -> priv ; \n int i ; \n AVFilterBufferRef * picref = avfilter_get_video_buffer ( link -> dst -> outputs [ 0 ] , \n perms , w , h ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n int vsub = i == 1 || i == 2 ? flip -> vsub : 0 ; \n if ( picref -> data [ i ] ) { \n picref -> data [ i ] += ( ( h >> vsub ) - 1 ) * picref -> linesize [ i ] ; \n picref -> linesize [ i ] = - picref -> linesize [ i ] ; \n } \n } \n return picref ; \n }", "idx": 23515}
{"project": "FFmpeg", "commit_id": "ff35c7cdfac3a4affa9e98a806281da99f66787f", "target": 0, "func": "static int ftp_retrieve ( FTPContext * s ) \n { \n char command [ CONTROL_BUFFER_SIZE ] ; \n const int retr_codes [ ] = { 150 , 550 , 0 } ; \n snprintf ( command , sizeof ( command ) , \" \\r \\n \" , s -> path ) ; \n if ( ftp_send_command ( s , command , retr_codes , NULL ) != 150 ) \n return AVERROR ( EIO ) ; \n s -> state = DOWNLOADING ; \n return 0 ; \n }", "idx": 23558}
{"project": "FFmpeg", "commit_id": "57877f2b449f265ae1dd070b46aaadff4f0b3e34", "target": 0, "func": "static inline int sub_left_prediction ( HYuvContext * s , uint8_t * dst , \n const uint8_t * src , int w , int left ) \n { \n int i ; \n if ( s -> bps <= 8 ) { \n if ( w < 32 ) { \n for ( i = 0 ; i < w ; i ++ ) { \n const int temp = src [ i ] ; \n dst [ i ] = temp - left ; \n left = temp ; \n } \n return left ; \n } else { \n for ( i = 0 ; i < 32 ; i ++ ) { \n const int temp = src [ i ] ; \n dst [ i ] = temp - left ; \n left = temp ; \n } \n s -> llvidencdsp . diff_bytes ( dst + 32 , src + 32 , src + 31 , w - 32 ) ; \n return src [ w - 1 ] ; \n } \n } else { \n const uint16_t * src16 = ( const uint16_t * ) src ; \n uint16_t * dst16 = ( uint16_t * ) dst ; \n if ( w < 32 ) { \n for ( i = 0 ; i < w ; i ++ ) { \n const int temp = src16 [ i ] ; \n dst16 [ i ] = temp - left ; \n left = temp ; \n } \n return left ; \n } else { \n for ( i = 0 ; i < 16 ; i ++ ) { \n const int temp = src16 [ i ] ; \n dst16 [ i ] = temp - left ; \n left = temp ; \n } \n s -> hencdsp . diff_int16 ( dst16 + 16 , src16 + 16 , src16 + 15 , s -> n - 1 , w - 16 ) ; \n return src16 [ w - 1 ] ; \n } \n } \n }", "idx": 23562}
{"project": "FFmpeg", "commit_id": "0c5f839693da2276c2da23400f67a67be4ea0af1", "target": 1, "func": "int ffurl_register_protocol ( URLProtocol * protocol , int size ) \n { \n URLProtocol * * p ; \n if ( size < sizeof ( URLProtocol ) ) { \n URLProtocol * temp = av_mallocz ( sizeof ( URLProtocol ) ) ; \n memcpy ( temp , protocol , size ) ; \n protocol = temp ; \n } \n p = & first_protocol ; \n while ( * p != NULL ) \n p = & ( * p ) -> next ; \n * p = protocol ; \n protocol -> next = NULL ; \n return 0 ; \n }", "idx": 23566}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv34_idct_add_c ( uint8_t * dst , int stride , DCTELEM * block ) { \n int temp [ 16 ] ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i ; \n rv34_row_transform ( temp , block ) ; \n memset ( block , 0 , 16 * sizeof ( DCTELEM ) ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = 13 * ( temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ) + 0x200 ; \n const int z1 = 13 * ( temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ) + 0x200 ; \n const int z2 = 7 * temp [ 4 * 1 + i ] - 17 * temp [ 4 * 3 + i ] ; \n const int z3 = 17 * temp [ 4 * 1 + i ] + 7 * temp [ 4 * 3 + i ] ; \n dst [ 0 ] = cm [ dst [ 0 ] + ( ( z0 + z3 ) >> 10 ) ] ; \n dst [ 1 ] = cm [ dst [ 1 ] + ( ( z1 + z2 ) >> 10 ) ] ; \n dst [ 2 ] = cm [ dst [ 2 ] + ( ( z1 - z2 ) >> 10 ) ] ; \n dst [ 3 ] = cm [ dst [ 3 ] + ( ( z0 - z3 ) >> 10 ) ] ; \n dst += stride ; \n } \n }", "idx": 23568}
{"project": "FFmpeg", "commit_id": "67e285ceca1cb602a5ab87010b30d904527924fe", "target": 1, "func": "int av_reallocp ( void * ptr , size_t size ) \n { \n void * * ptrptr = ptr ; \n void * ret ; \n ret = av_realloc ( * ptrptr , size ) ; \n if ( ! ret ) { \n return AVERROR ( ENOMEM ) ; \n * ptrptr = ret ;", "idx": 23570}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int avi_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 32 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 8 ] == ' ' && p -> buf [ 9 ] == ' ' && \n p -> buf [ 10 ] == ' ' && ( p -> buf [ 11 ] == ' ' || p -> buf [ 11 ] == 0x19 ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 23572}
{"project": "FFmpeg", "commit_id": "9f0a705d46547ca0c3edab21f24cdb0fb3237185", "target": 0, "func": "static int decode_user_data ( MpegEncContext * s , GetBitContext * gb ) { \n char buf [ 256 ] ; \n int i ; \n int e ; \n int ver = 0 , build = 0 , ver2 = 0 , ver3 = 0 ; \n char last ; \n for ( i = 0 ; i < 255 && get_bits_count ( gb ) < gb -> size_in_bits ; i ++ ) { \n if ( show_bits ( gb , 23 ) == 0 ) break ; \n buf [ i ] = get_bits ( gb , 8 ) ; \n } \n buf [ i ] = 0 ; \n e = sscanf ( buf , \" \" , & ver , & build , & last ) ; \n if ( e < 2 ) \n e = sscanf ( buf , \" \" , & ver , & build , & last ) ; \n if ( e >= 2 ) { \n s -> divx_version = ver ; \n s -> divx_build = build ; \n s -> divx_packed = e == 3 && last == ' ' ; \n if ( s -> divx_packed ) \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n } \n e = sscanf ( buf , \" \" , & build ) + 3 ; \n if ( e != 4 ) \n e = sscanf ( buf , \" \" , & ver , & ver2 , & ver3 , & build ) ; \n if ( e != 4 ) { \n e = sscanf ( buf , \" \" , & ver , & ver2 , & ver3 ) + 1 ; \n if ( e > 1 ) \n build = ( ver << 16 ) + ( ver2 << 8 ) + ver3 ; \n } \n if ( e != 4 ) { \n if ( strcmp ( buf , \" \" ) == 0 ) { \n s -> lavc_build = 4600 ; \n } \n } \n if ( e == 4 ) { \n s -> lavc_build = build ; \n } \n e = sscanf ( buf , \" \" , & build ) ; \n if ( e == 1 ) { \n s -> xvid_build = build ; \n } \n return 0 ; \n }", "idx": 23573}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc02_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_8w_msa ( src - ( stride * 2 ) , stride , dst , stride , 8 ) ; \n }", "idx": 23577}
{"project": "FFmpeg", "commit_id": "f5a9c35f886508b851011b7dd4ec18cc67b57d37", "target": 0, "func": "static int read_pakt_chunk ( AVFormatContext * s , int64_t size ) \n { \n AVIOContext * pb = s -> pb ; \n AVStream * st = s -> streams [ 0 ] ; \n CaffContext * caf = s -> priv_data ; \n int64_t pos = 0 , ccount ; \n int num_packets , i ; \n ccount = avio_tell ( pb ) ; \n num_packets = avio_rb64 ( pb ) ; \n if ( num_packets < 0 || INT32_MAX / sizeof ( AVIndexEntry ) < num_packets ) \n return AVERROR_INVALIDDATA ; \n st -> nb_frames = avio_rb64 ( pb ) ; \n st -> nb_frames += avio_rb32 ( pb ) ; \n st -> nb_frames += avio_rb32 ( pb ) ; \n st -> duration = 0 ; \n for ( i = 0 ; i < num_packets ; i ++ ) { \n av_add_index_entry ( s -> streams [ 0 ] , pos , st -> duration , 0 , 0 , AVINDEX_KEYFRAME ) ; \n pos += caf -> bytes_per_packet ? caf -> bytes_per_packet : ff_mp4_read_descr_len ( pb ) ; \n st -> duration += caf -> frames_per_packet ? caf -> frames_per_packet : ff_mp4_read_descr_len ( pb ) ; \n } \n if ( avio_tell ( pb ) - ccount != size ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n caf -> num_bytes = pos ; \n return 0 ; \n }", "idx": 23578}
{"project": "FFmpeg", "commit_id": "7b5ff7d57355dc608f0fd86e3ab32a2fda65e752", "target": 1, "func": "static void vp8_decode_mb_row_no_filter ( AVCodecContext * avctx , void * tdata , \n int jobnr , int threadnr ) \n { \n decode_mb_row_no_filter ( avctx , tdata , jobnr , threadnr , 0 ) ; \n }", "idx": 23579}
{"project": "FFmpeg", "commit_id": "b9029997d4694b6533556480fe0ab1f3f9779a56", "target": 0, "func": "static int roq_decode_end ( AVCodecContext * avctx ) \n { \n RoqContext * s = avctx -> priv_data ; \n avctx -> release_buffer ( avctx , & s -> last_frame ) ; \n return 0 ; \n }", "idx": 23584}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_dc_4blk_8x8_msa ( uint8_t * src , int32_t stride ) \n { \n uint8_t lp_cnt ; \n uint32_t src0 , src1 , src3 , src2 = 0 ; \n uint32_t out0 , out1 , out2 , out3 ; \n v16u8 src_top ; \n v8u16 add ; \n v4u32 sum ; \n src_top = LD_UB ( src - stride ) ; \n add = __msa_hadd_u_h ( ( v16u8 ) src_top , ( v16u8 ) src_top ) ; \n sum = __msa_hadd_u_w ( add , add ) ; \n src0 = __msa_copy_u_w ( ( v4i32 ) sum , 0 ) ; \n src1 = __msa_copy_u_w ( ( v4i32 ) sum , 1 ) ; \n for ( lp_cnt = 0 ; lp_cnt < 4 ; lp_cnt ++ ) { \n src0 += src [ lp_cnt * stride - 1 ] ; \n src2 += src [ ( 4 + lp_cnt ) * stride - 1 ] ; \n } \n src0 = ( src0 + 4 ) >> 3 ; \n src3 = ( src1 + src2 + 4 ) >> 3 ; \n src1 = ( src1 + 2 ) >> 2 ; \n src2 = ( src2 + 2 ) >> 2 ; \n out0 = src0 * 0x01010101 ; \n out1 = src1 * 0x01010101 ; \n out2 = src2 * 0x01010101 ; \n out3 = src3 * 0x01010101 ; \n for ( lp_cnt = 4 ; lp_cnt -- ; ) { \n SW ( out0 , src ) ; \n SW ( out1 , ( src + 4 ) ) ; \n SW ( out2 , ( src + 4 * stride ) ) ; \n SW ( out3 , ( src + 4 * stride + 4 ) ) ; \n src += stride ; \n } \n }", "idx": 23631}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_128_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( 1 << ( BIT_DEPTH - 1 ) ) ; \n }", "idx": 23640}
{"project": "FFmpeg", "commit_id": "46e407554968e7258c874f4caf517172ffa285cf", "target": 1, "func": "int ff_dirac_golomb_read_16bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int16_t * dst = ( int16_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res ) ; \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n } \n for ( i = 0 ; i < LUT_BITS ; i ++ ) \n dst [ c_idx + i ] = l -> ready [ i ] ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 23644}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_add_pixels_clamped_c ( const DCTELEM * block , uint8_t * restrict pixels , \n int line_size ) \n { \n int i ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n pixels [ 0 ] = cm [ pixels [ 0 ] + block [ 0 ] ] ; \n pixels [ 1 ] = cm [ pixels [ 1 ] + block [ 1 ] ] ; \n pixels [ 2 ] = cm [ pixels [ 2 ] + block [ 2 ] ] ; \n pixels [ 3 ] = cm [ pixels [ 3 ] + block [ 3 ] ] ; \n pixels [ 4 ] = cm [ pixels [ 4 ] + block [ 4 ] ] ; \n pixels [ 5 ] = cm [ pixels [ 5 ] + block [ 5 ] ] ; \n pixels [ 6 ] = cm [ pixels [ 6 ] + block [ 6 ] ] ; \n pixels [ 7 ] = cm [ pixels [ 7 ] + block [ 7 ] ] ; \n pixels += line_size ; \n block += 8 ; \n } \n }", "idx": 23647}
{"project": "FFmpeg", "commit_id": "a38469e1da7b4829a2fba4279d8420a33f96832e", "target": 0, "func": "void show_help ( void ) \n { \n const OptionDef * po ; \n int i , expert ; \n printf ( \" \" FFMPEG_VERSION \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( i == 1 ) \n printf ( \" \\n \\n \" ) ; \n for ( po = options ; po -> name != NULL ; po ++ ) { \n char buf [ 64 ] ; \n expert = ( po -> flags & OPT_EXPERT ) != 0 ; \n if ( expert == i ) { \n strcpy ( buf , po -> name ) ; \n if ( po -> flags & HAS_ARG ) { \n strcat ( buf , \" \" ) ; \n strcat ( buf , po -> argname ) ; \n } \n printf ( \" \\n \" , buf , po -> help ) ; \n } \n } \n } \n exit ( 1 ) ; \n }", "idx": 23651}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_shutdown ( URLContext * h , int flags ) \n { \n FTPContext * s = h -> priv_data ; \n av_dlog ( h , \" \\n \" ) ; \n if ( s -> conn_data ) \n return ffurl_shutdown ( s -> conn_data , flags ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 23652}
{"project": "FFmpeg", "commit_id": "341f01290c2353669ed2263f56e1a9f4c67cc597", "target": 1, "func": "static int huff_build12 ( VLC * vlc , uint8_t * len ) \n { \n HuffEntry he [ 4096 ] ; \n uint32_t codes [ 4096 ] ; \n uint8_t bits [ 4096 ] ; \n uint16_t syms [ 4096 ] ; \n uint32_t code ; \n int i ; \n for ( i = 0 ; i < 4096 ; i ++ ) { \n he [ i ] . sym = 4095 - i ; \n he [ i ] . len = len [ i ] ; \n if ( len [ i ] == 0 ) \n return AVERROR_INVALIDDATA ; \n } \n AV_QSORT ( he , 4096 , HuffEntry , huff_cmp_len12 ) ; \n code = 1 ; \n for ( i = 4095 ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n ff_free_vlc ( vlc ) ; \n return ff_init_vlc_sparse ( vlc , FFMIN ( he [ 4095 ] . len , 14 ) , 4096 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 23664}
{"project": "FFmpeg", "commit_id": "6d702dc072ffc255cd0f709132e55661698313e7", "target": 0, "func": "static int encode_slice ( AVCodecContext * avctx , const AVFrame * pic , \n PutBitContext * pb , \n int sizes [ 4 ] , int x , int y , int quant , \n int mbs_per_slice ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n int i , xp , yp ; \n int total_size = 0 ; \n const uint16_t * src ; \n int slice_width_factor = av_log2 ( mbs_per_slice ) ; \n int num_cblocks , pwidth ; \n int plane_factor , is_chroma ; \n for ( i = 0 ; i < ctx -> num_planes ; i ++ ) { \n is_chroma = ( i == 1 || i == 2 ) ; \n plane_factor = slice_width_factor + 2 ; \n if ( is_chroma ) \n plane_factor += ctx -> chroma_factor - 3 ; \n if ( ! is_chroma || ctx -> chroma_factor == CFACTOR_Y444 ) { \n xp = x << 4 ; \n yp = y << 4 ; \n num_cblocks = 4 ; \n pwidth = avctx -> width ; \n } else { \n xp = x << 3 ; \n yp = y << 4 ; \n num_cblocks = 2 ; \n pwidth = avctx -> width >> 1 ; \n } \n src = ( const uint16_t * ) ( pic -> data [ i ] + yp * pic -> linesize [ i ] ) + xp ; \n get_slice_data ( ctx , src , pic -> linesize [ i ] , xp , yp , \n pwidth , avctx -> height , ctx -> blocks [ 0 ] , \n mbs_per_slice , num_cblocks ) ; \n sizes [ i ] = encode_slice_plane ( ctx , pb , src , pic -> linesize [ i ] , \n mbs_per_slice , ctx -> blocks [ 0 ] , \n num_cblocks , plane_factor , \n ctx -> quants [ quant ] ) ; \n total_size += sizes [ i ] ; \n } \n return total_size ; \n }", "idx": 23679}
{"project": "FFmpeg", "commit_id": "29fb49194bedc74ac9be0b49b6b42dcfeb6222d9", "target": 0, "func": "int av_get_cpu_flags ( void ) \n { \n if ( checked ) \n return flags ; \n if ( ARCH_AARCH64 ) \n flags = ff_get_cpu_flags_aarch64 ( ) ; \n if ( ARCH_ARM ) \n flags = ff_get_cpu_flags_arm ( ) ; \n if ( ARCH_PPC ) \n flags = ff_get_cpu_flags_ppc ( ) ; \n if ( ARCH_X86 ) \n flags = ff_get_cpu_flags_x86 ( ) ; \n checked = 1 ; \n return flags ; \n }", "idx": 23693}
{"project": "FFmpeg", "commit_id": "f738140807f504c9af7850042067777832f05e88", "target": 1, "func": "static int decode_pic_timing ( HEVCSEIContext * s , GetBitContext * gb , const HEVCParamSets * ps , \n void * logctx ) \n { \n HEVCSEIPictureTiming * h = & s -> picture_timing ; \n HEVCSPS * sps ; \n if ( ! ps -> sps_list [ s -> active_seq_parameter_set_id ] ) \n return ( AVERROR ( ENOMEM ) ) ; \n sps = ( HEVCSPS * ) ps -> sps_list [ s -> active_seq_parameter_set_id ] -> data ; \n if ( sps -> vui . frame_field_info_present_flag ) { \n int pic_struct = get_bits ( gb , 4 ) ; \n h -> picture_struct = AV_PICTURE_STRUCTURE_UNKNOWN ; \n if ( pic_struct == 2 ) { \n av_log ( logctx , AV_LOG_DEBUG , \" \\n \" ) ; \n h -> picture_struct = AV_PICTURE_STRUCTURE_BOTTOM_FIELD ; \n } else if ( pic_struct == 1 ) { \n av_log ( logctx , AV_LOG_DEBUG , \" \\n \" ) ; \n h -> picture_struct = AV_PICTURE_STRUCTURE_TOP_FIELD ; \n } \n get_bits ( gb , 2 ) ; \n get_bits ( gb , 1 ) ; \n } \n return 1 ; \n }", "idx": 23713}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static inline int decode_cabac_mb_transform_size ( H264Context * h ) { \n return get_cabac ( & h -> cabac , & h -> cabac_state [ 399 + h -> neighbor_transform_size ] ) ; \n }", "idx": 23718}
{"project": "FFmpeg", "commit_id": "386d60f9783ac094dae6c3c9210e0469f98c9147", "target": 1, "func": "static av_always_inline int lcg_random ( int previous_val ) \n { \n return previous_val * 1664525 + 1013904223 ; \n }", "idx": 23722}
{"project": "FFmpeg", "commit_id": "ebba2b3e2a551ce638d17332761431ba748f178f", "target": 0, "func": "static int tcp_wait_fd ( int fd , int write ) \n { \n int ev = write ? POLLOUT : POLLIN ; \n struct pollfd p = { . fd = fd , . events = ev , . revents = 0 } ; \n int ret ; \n ret = poll ( & p , 1 , 100 ) ; \n return ret < 0 ? ff_neterrno ( ) : p . revents & ev ? 0 : AVERROR ( EAGAIN ) ; \n }", "idx": 23732}
{"project": "FFmpeg", "commit_id": "77015443a84bb5dbed38eafc2ea26a2bf2641ed6", "target": 0, "func": "static int file_check ( URLContext * h , int mask ) \n { \n #if HAVE_ACCESS && defined ( R_OK )  \n  \n  int ret = 0 ; \n if ( access ( h -> filename , F_OK ) < 0 ) \n return AVERROR ( errno ) ; \n if ( mask & AVIO_FLAG_READ ) \n if ( access ( h -> filename , R_OK ) >= 0 ) \n ret |= AVIO_FLAG_READ ; \n if ( mask & AVIO_FLAG_WRITE ) \n if ( access ( h -> filename , W_OK ) >= 0 ) \n ret |= AVIO_FLAG_WRITE ; \n #else \n struct stat st ; \n int ret = stat ( h -> filename , & st ) ; \n if ( ret < 0 ) \n return AVERROR ( errno ) ; \n ret |= st . st_mode & S_IRUSR ? mask & AVIO_FLAG_READ : 0 ; \n ret |= st . st_mode & S_IWUSR ? mask & AVIO_FLAG_WRITE : 0 ; \n #endif \n return ret ; \n }", "idx": 23734}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( extract_even ) ( const uint8_t * src , uint8_t * dst , x86_reg count ) \n { \n dst += count ; \n src += 2 * count ; \n count = - count ; \n #if COMPILE_TEMPLATE_MMX  \n  \n  if ( count <= -16 ) { \n count += 15 ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + r \" \n : \" r \" \" r \" \n ) ; \n count -= 15 ; \n } \n #endif \n while ( count < 0 ) { \n dst [ count ] = src [ 2 * count ] ; \n count ++ ; \n } \n }", "idx": 23759}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_horiz_16x16_msa ( uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride ) \n { \n uint32_t row ; \n uint8_t inp0 , inp1 , inp2 , inp3 ; \n v16u8 src0 , src1 , src2 , src3 ; \n for ( row = 4 ; row -- ; ) { \n inp0 = src [ 0 ] ; \n src += src_stride ; \n inp1 = src [ 0 ] ; \n src += src_stride ; \n inp2 = src [ 0 ] ; \n src += src_stride ; \n inp3 = src [ 0 ] ; \n src += src_stride ; \n src0 = ( v16u8 ) __msa_fill_b ( inp0 ) ; \n src1 = ( v16u8 ) __msa_fill_b ( inp1 ) ; \n src2 = ( v16u8 ) __msa_fill_b ( inp2 ) ; \n src3 = ( v16u8 ) __msa_fill_b ( inp3 ) ; \n ST_UB4 ( src0 , src1 , src2 , src3 , dst , dst_stride ) ; \n dst += ( 4 * dst_stride ) ; \n } \n }", "idx": 23760}
{"project": "FFmpeg", "commit_id": "d94c577d3c61e428cfcbcd3dc3a80bd848077eae", "target": 0, "func": "int read_file ( const char * filename , char * * bufptr , size_t * size ) \n { \n FILE * f = fopen ( filename , \" \" ) ; \n if ( ! f ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , filename , strerror ( errno ) ) ; \n return AVERROR ( errno ) ; \n } \n fseek ( f , 0 , SEEK_END ) ; \n * size = ftell ( f ) ; \n fseek ( f , 0 , SEEK_SET ) ; \n * bufptr = av_malloc ( * size + 1 ) ; \n if ( ! * bufptr ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n fclose ( f ) ; \n return AVERROR ( ENOMEM ) ; \n } \n fread ( * bufptr , 1 , * size , f ) ; \n ( * bufptr ) [ * size ++ ] = ' \\0 ' ; \n fclose ( f ) ; \n return 0 ; \n }", "idx": 23764}
{"project": "FFmpeg", "commit_id": "6179dc8aa7e5fc5358b9614306f93f1adadf22a4", "target": 1, "func": "static inline int get_amv ( Mpeg4DecContext * ctx , int n ) \n { \n MpegEncContext * s = & ctx -> m ; \n int x , y , mb_v , sum , dx , dy , shift ; \n int len = 1 << ( s -> f_code + 4 ) ; \n const int a = s -> sprite_warping_accuracy ; \n if ( s -> workaround_bugs & FF_BUG_AMV ) \n len >>= s -> quarter_sample ; \n if ( s -> real_sprite_warping_points == 1 ) { \n if ( ctx -> divx_version == 500 && ctx -> divx_build == 413 ) \n sum = s -> sprite_offset [ 0 ] [ n ] / ( 1 << ( a - s -> quarter_sample ) ) ; \n else \n sum = RSHIFT ( s -> sprite_offset [ 0 ] [ n ] << s -> quarter_sample , a ) ; \n } else { \n dx = s -> sprite_delta [ n ] [ 0 ] ; \n dy = s -> sprite_delta [ n ] [ 1 ] ; \n shift = ctx -> sprite_shift [ 0 ] ; \n if ( n ) \n dy -= 1 << ( shift + a + 1 ) ; \n else \n dx -= 1 << ( shift + a + 1 ) ; \n mb_v = s -> sprite_offset [ 0 ] [ n ] + dx * s -> mb_x * 16 + dy * s -> mb_y * 16 ; \n sum = 0 ; \n for ( y = 0 ; y < 16 ; y ++ ) { \n int v ; \n v = mb_v + dy * y ; \n for ( x = 0 ; x < 16 ; x ++ ) { \n sum += v >> shift ; \n v += dx ; \n } \n } \n sum = RSHIFT ( sum , a + 8 - s -> quarter_sample ) ; \n } \n if ( sum < - len ) \n sum = - len ; \n else if ( sum >= len ) \n sum = len - 1 ; \n return sum ; \n }", "idx": 23767}
{"project": "FFmpeg", "commit_id": "be8d812c9635f31f69c30dff9ebf565a07a7dab7", "target": 1, "func": "static void ready_codebook ( vorbis_enc_codebook * cb ) \n { \n int i ; \n ff_vorbis_len2vlc ( cb -> lens , cb -> codewords , cb -> nentries ) ; \n if ( ! cb -> lookup ) { \n cb -> pow2 = cb -> dimentions = NULL ; \n } else { \n int vals = cb_lookup_vals ( cb -> lookup , cb -> ndimentions , cb -> nentries ) ; \n cb -> dimentions = av_malloc ( sizeof ( float ) * cb -> nentries * cb -> ndimentions ) ; \n cb -> pow2 = av_mallocz ( sizeof ( float ) * cb -> nentries ) ; \n for ( i = 0 ; i < cb -> nentries ; i ++ ) { \n float last = 0 ; \n int j ; \n int div = 1 ; \n for ( j = 0 ; j < cb -> ndimentions ; j ++ ) { \n int off ; \n if ( cb -> lookup == 1 ) \n off = ( i / div ) % vals ; \n else \n off = i * cb -> ndimentions + j ; \n cb -> dimentions [ i * cb -> ndimentions + j ] = last + cb -> min + cb -> quantlist [ off ] * cb -> delta ; \n if ( cb -> seq_p ) \n last = cb -> dimentions [ i * cb -> ndimentions + j ] ; \n cb -> pow2 [ i ] += cb -> dimentions [ i * cb -> ndimentions + j ] * cb -> dimentions [ i * cb -> ndimentions + j ] ; \n div *= vals ; \n } \n cb -> pow2 [ i ] /= 2. ; \n } \n } \n }", "idx": 23775}
{"project": "FFmpeg", "commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "target": 1, "func": "static void flush_buffered ( AVFormatContext * s1 , int last ) \n { \n RTPMuxContext * s = s1 -> priv_data ; \n if ( s -> buf_ptr != s -> buf ) { \n if ( s -> buffered_nals == 1 ) \n ff_rtp_send_data ( s1 , s -> buf + 4 , s -> buf_ptr - s -> buf - 4 , last ) ; \n else \n ff_rtp_send_data ( s1 , s -> buf , s -> buf_ptr - s -> buf , last ) ; \n } \n s -> buf_ptr = s -> buf ; \n s -> buffered_nals = 0 ; \n }", "idx": 23783}
{"project": "FFmpeg", "commit_id": "67020711b7d45afa073ef671f755765035a64373", "target": 1, "func": "static int vp8_lossy_decode_frame ( AVCodecContext * avctx , AVFrame * p , \n int * got_frame , uint8_t * data_start , \n unsigned int data_size ) \n { \n WebPContext * s = avctx -> priv_data ; \n AVPacket pkt ; \n int ret ; \n if ( ! s -> initialized ) { \n ff_vp8_decode_init ( avctx ) ; \n s -> initialized = 1 ; \n } \n avctx -> pix_fmt = s -> has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P ; \n s -> lossless = 0 ; \n if ( data_size > INT_MAX ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n av_init_packet ( & pkt ) ; \n pkt . data = data_start ; \n pkt . size = data_size ; \n ret = ff_vp8_decode_frame ( avctx , p , got_frame , & pkt ) ; \n if ( ret < 0 ) \n return ret ; \n update_canvas_size ( avctx , avctx -> width , avctx -> height ) ; \n if ( s -> has_alpha ) { \n ret = vp8_lossy_decode_alpha ( avctx , p , s -> alpha_data , \n s -> alpha_data_size ) ; \n if ( ret < 0 ) \n return ret ; \n } \n return ret ; \n }", "idx": 23784}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static int v4l2_send_frame ( AVCodecContext * avctx , const AVFrame * frame ) \n { \n V4L2m2mContext * s = avctx -> priv_data ; \n V4L2Context * const output = & s -> output ; \n return ff_v4l2_context_enqueue_frame ( output , frame ) ; \n }", "idx": 23791}
{"project": "FFmpeg", "commit_id": "9ac831c2c02e6e1c9c322b8bb77881c1dbac6f08", "target": 0, "func": "static int update_dimensions ( VP8Context * s , int width , int height ) \n { \n int i ; \n if ( avcodec_check_dimensions ( s -> avctx , width , height ) ) \n return AVERROR_INVALIDDATA ; \n vp8_decode_flush ( s -> avctx ) ; \n avcodec_set_dimensions ( s -> avctx , width , height ) ; \n s -> mb_width = ( s -> avctx -> coded_width + 15 ) / 16 ; \n s -> mb_height = ( s -> avctx -> coded_height + 15 ) / 16 ; \n s -> mb_stride = s -> mb_width + 1 ; \n s -> b4_stride = 4 * s -> mb_stride ; \n s -> macroblocks_base = av_mallocz ( s -> mb_stride * ( s -> mb_height + 1 ) * sizeof ( * s -> macroblocks ) ) ; \n s -> intra4x4_pred_mode_base = av_mallocz ( s -> b4_stride * ( 4 * s -> mb_height + 1 ) ) ; \n s -> top_nnz = av_mallocz ( s -> mb_width * sizeof ( * s -> top_nnz ) ) ; \n if ( ! s -> macroblocks_base || ! s -> intra4x4_pred_mode_base || ! s -> top_nnz ) \n return AVERROR ( ENOMEM ) ; \n s -> macroblocks = s -> macroblocks_base + 1 + s -> mb_stride ; \n s -> intra4x4_pred_mode = s -> intra4x4_pred_mode_base + 4 + s -> b4_stride ; \n memset ( s -> intra4x4_pred_mode_base , DC_PRED , s -> b4_stride ) ; \n for ( i = 0 ; i < 4 * s -> mb_height ; i ++ ) \n s -> intra4x4_pred_mode [ i * s -> b4_stride - 1 ] = DC_PRED ; \n return 0 ; \n }", "idx": 23796}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static int alloc_audio_output_buf ( AVCodecContext * dec , AVCodecContext * enc , \n int nb_samples , int * buf_linesize ) \n { \n int64_t audio_buf_samples ; \n int audio_buf_size ; \n audio_buf_samples = ( ( int64_t ) nb_samples * enc -> sample_rate + dec -> sample_rate ) / \n dec -> sample_rate ; \n audio_buf_samples = 4 * audio_buf_samples + 10000 ; \n audio_buf_samples = FFMAX ( audio_buf_samples , enc -> frame_size ) ; \n if ( audio_buf_samples > INT_MAX ) \n return AVERROR ( EINVAL ) ; \n audio_buf_size = av_samples_get_buffer_size ( buf_linesize , enc -> channels , \n audio_buf_samples , \n enc -> sample_fmt , 0 ) ; \n if ( audio_buf_size < 0 ) \n return audio_buf_size ; \n av_fast_malloc ( & audio_buf , & allocated_audio_buf_size , audio_buf_size ) ; \n if ( ! audio_buf ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 23799}
{"project": "FFmpeg", "commit_id": "3d828c9fd51aa8c348ff11241e212e5834b4f806", "target": 0, "func": "size_t av_cpu_max_align ( void ) \n { \n int flags = av_get_cpu_flags ( ) ; \n if ( flags & AV_CPU_FLAG_AVX ) \n return 32 ; \n if ( flags & ( AV_CPU_FLAG_ALTIVEC | AV_CPU_FLAG_SSE | AV_CPU_FLAG_NEON ) ) \n return 16 ; \n return 8 ; \n }", "idx": 23821}
{"project": "FFmpeg", "commit_id": "ed16c2dbf47cdd7c48825b4da6e7036698e5dde1", "target": 0, "func": "static void h261_loop_filter_c ( uint8_t * src , int stride ) { \n int x , y , xy , yz ; \n int temp [ 64 ] ; \n for ( x = 0 ; x < 8 ; x ++ ) { \n temp [ x ] = 4 * src [ x ] ; \n temp [ x + 7 * 8 ] = 4 * src [ x + 7 * stride ] ; \n } \n for ( y = 1 ; y < 7 ; y ++ ) { \n for ( x = 0 ; x < 8 ; x ++ ) { \n xy = y * stride + x ; \n yz = y * 8 + x ; \n temp [ yz ] = src [ xy - stride ] + 2 * src [ xy ] + src [ xy + stride ] ; \n } \n } \n for ( y = 0 ; y < 8 ; y ++ ) { \n src [ y * stride ] = ( temp [ y * 8 ] + 2 ) >> 2 ; \n src [ 7 + y * stride ] = ( temp [ 7 + y * 8 ] + 2 ) >> 2 ; \n for ( x = 1 ; x < 7 ; x ++ ) { \n xy = y * stride + x ; \n yz = y * 8 + x ; \n src [ xy ] = ( temp [ yz - 1 ] + 2 * temp [ yz ] + temp [ yz + 1 ] + 8 ) >> 4 ; \n } \n } \n }", "idx": 23832}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int av_lockmgr_register ( int ( * cb ) ( void * * mutex , enum AVLockOp op ) ) \n { \n if ( lockmgr_cb ) { \n lockmgr_cb ( & codec_mutex , AV_LOCK_DESTROY ) ; \n lockmgr_cb ( & avformat_mutex , AV_LOCK_DESTROY ) ; \n lockmgr_cb = NULL ; \n codec_mutex = NULL ; \n avformat_mutex = NULL ; \n } \n if ( cb ) { \n void * new_codec_mutex = NULL ; \n void * new_avformat_mutex = NULL ; \n int err ; \n if ( err = cb ( & new_codec_mutex , AV_LOCK_CREATE ) ) { \n return err > 0 ? AVERROR_UNKNOWN : err ; \n } \n if ( err = cb ( & new_avformat_mutex , AV_LOCK_CREATE ) ) { \n cb ( & new_codec_mutex , AV_LOCK_DESTROY ) ; \n return err > 0 ? AVERROR_UNKNOWN : err ; \n } \n lockmgr_cb = cb ; \n codec_mutex = new_codec_mutex ; \n avformat_mutex = new_avformat_mutex ; \n } \n return 0 ; \n }", "idx": 23843}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int gxf_probe ( AVProbeData * p ) { \n static const uint8_t startcode [ ] = { 0 , 0 , 0 , 0 , 1 , 0xbc } ; \n static const uint8_t endcode [ ] = { 0 , 0 , 0 , 0 , 0xe1 , 0xe2 } ; \n if ( p -> buf_size < 16 ) \n return 0 ; \n if ( ! memcmp ( p -> buf , startcode , sizeof ( startcode ) ) && \n ! memcmp ( & p -> buf [ 16 - sizeof ( endcode ) ] , endcode , sizeof ( endcode ) ) ) \n return AVPROBE_SCORE_MAX ; \n return 0 ; \n }", "idx": 23865}
{"project": "FFmpeg", "commit_id": "eb3f81e4ef73bb8d7e2c75ff0e8cb43de1c7dac5", "target": 0, "func": "static int targa_decode_rle ( AVCodecContext * avctx , TargaContext * s , const uint8_t * src , int src_size , uint8_t * dst , int w , int h , int stride , int bpp ) \n { \n int i , x , y ; \n int depth = ( bpp + 1 ) >> 3 ; \n int type , count ; \n int diff ; \n const uint8_t * src_end = src + src_size ; \n diff = stride - w * depth ; \n x = y = 0 ; \n while ( y < h ) { \n CHECK_BUFFER_SIZE ( src , src_end , 1 , \" \" ) ; \n type = * src ++ ; \n count = ( type & 0x7F ) + 1 ; \n type &= 0x80 ; \n if ( ( x + count > w ) && ( x + count + 1 > ( h - y ) * w ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , x , y , count ) ; \n return -1 ; \n } \n if ( type ) { \n CHECK_BUFFER_SIZE ( src , src_end , depth , \" \" ) ; \n } else { \n CHECK_BUFFER_SIZE ( src , src_end , count * depth , \" \" ) ; \n } \n for ( i = 0 ; i < count ; i ++ ) { \n switch ( depth ) { \n case 1 : \n * dst = * src ; \n break ; \n case 2 : \n AV_WN16A ( dst , AV_RN16A ( src ) ) ; \n break ; \n case 3 : \n dst [ 0 ] = src [ 0 ] ; \n dst [ 1 ] = src [ 1 ] ; \n dst [ 2 ] = src [ 2 ] ; \n break ; \n case 4 : \n AV_WN32A ( dst , AV_RN32A ( src ) ) ; \n break ; \n } \n dst += depth ; \n if ( ! type ) \n src += depth ; \n x ++ ; \n if ( x == w ) { \n x = 0 ; \n y ++ ; \n dst += diff ; \n } \n } \n if ( type ) \n src += depth ; \n } \n return src_size ; \n }", "idx": 23873}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static void mkv_write_simpletag ( AVIOContext * pb , AVDictionaryEntry * t ) \n { \n uint8_t * key = av_strdup ( t -> key ) ; \n uint8_t * p = key ; \n const uint8_t * lang = NULL ; \n ebml_master tag ; \n if ( ( p = strrchr ( p , ' ' ) ) && \n ( lang = av_convert_lang_to ( p + 1 , AV_LANG_ISO639_2_BIBL ) ) ) \n * p = 0 ; \n p = key ; \n while ( * p ) { \n if ( * p == ' ' ) \n * p = ' ' ; \n else if ( * p >= ' ' && * p <= ' ' ) \n * p -= ' ' - ' ' ; \n p ++ ; \n } \n tag = start_ebml_master ( pb , MATROSKA_ID_SIMPLETAG , 0 ) ; \n put_ebml_string ( pb , MATROSKA_ID_TAGNAME , key ) ; \n if ( lang ) \n put_ebml_string ( pb , MATROSKA_ID_TAGLANG , lang ) ; \n put_ebml_string ( pb , MATROSKA_ID_TAGSTRING , t -> value ) ; \n end_ebml_master ( pb , tag ) ; \n av_freep ( & key ) ; \n }", "idx": 23879}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static inline int decode_hrd_parameters ( H264Context * h , SPS * sps ) \n { \n int cpb_count , i ; \n cpb_count = get_ue_golomb_31 ( & h -> gb ) + 1 ; \n if ( cpb_count > 32U ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \" \\n \" , cpb_count ) ; \n return AVERROR_INVALIDDATA ; \n } \n get_bits ( & h -> gb , 4 ) ; \n get_bits ( & h -> gb , 4 ) ; \n for ( i = 0 ; i < cpb_count ; i ++ ) { \n get_ue_golomb_long ( & h -> gb ) ; \n get_ue_golomb_long ( & h -> gb ) ; \n get_bits1 ( & h -> gb ) ; \n } \n sps -> initial_cpb_removal_delay_length = get_bits ( & h -> gb , 5 ) + 1 ; \n sps -> cpb_removal_delay_length = get_bits ( & h -> gb , 5 ) + 1 ; \n sps -> dpb_output_delay_length = get_bits ( & h -> gb , 5 ) + 1 ; \n sps -> time_offset_length = get_bits ( & h -> gb , 5 ) ; \n sps -> cpb_cnt = cpb_count ; \n return 0 ; \n }", "idx": 23880}
{"project": "FFmpeg", "commit_id": "69dde1ad36b7d95b8b9268f414aa6c076212ed41", "target": 0, "func": "int mov_write_ftyp_tag ( ByteIOContext * pb , AVFormatContext * s ) \n { \n put_be32 ( pb , 0x14 ) ; \n put_tag ( pb , \" \" ) ; \n if ( ! strcmp ( \" \" , s -> oformat -> name ) ) \n put_tag ( pb , \" \" ) ; \n else \n put_tag ( pb , \" \" ) ; \n put_be32 ( pb , 0x200 ) ; \n if ( ! strcmp ( \" \" , s -> oformat -> name ) ) \n put_tag ( pb , \" \" ) ; \n else \n put_tag ( pb , \" \" ) ; \n return 0x14 ; \n }", "idx": 23883}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_rgb ( GetBitContext * gb , AVFrame * frame , \n int line , int left , uint8_t lru [ 3 ] [ 8 ] ) \n { \n int x , y ; \n int width = frame -> width ; \n int stride = frame -> linesize [ 0 ] ; \n uint8_t * dst = frame -> data [ 0 ] + stride * line ; \n for ( y = 0 ; y < left && get_bits_left ( gb ) > 16 ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n dst [ x * 3 + 0 ] = decode_sym ( gb , lru [ 0 ] ) ; \n dst [ x * 3 + 1 ] = decode_sym ( gb , lru [ 1 ] ) ; \n dst [ x * 3 + 2 ] = decode_sym ( gb , lru [ 2 ] ) ; \n } \n dst += stride ; \n } \n return y ; \n }", "idx": 23898}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "av_cold int ff_nvenc_encode_close ( AVCodecContext * avctx ) \n { \n NVENCContext * ctx = avctx -> priv_data ; \n NV_ENCODE_API_FUNCTION_LIST * nv = & ctx -> nvel . nvenc_funcs ; \n int i ; \n av_frame_free ( & avctx -> coded_frame ) ; \n if ( ctx -> in ) { \n for ( i = 0 ; i < ctx -> nb_surfaces ; ++ i ) { \n nv -> nvEncDestroyInputBuffer ( ctx -> nvenc_ctx , ctx -> in [ i ] . in ) ; \n nv -> nvEncDestroyBitstreamBuffer ( ctx -> nvenc_ctx , ctx -> out [ i ] . out ) ; \n } \n } \n av_freep ( & ctx -> in ) ; \n av_freep ( & ctx -> out ) ; \n if ( ctx -> nvenc_ctx ) \n nv -> nvEncDestroyEncoder ( ctx -> nvenc_ctx ) ; \n if ( ctx -> cu_context ) \n ctx -> nvel . cu_ctx_destroy ( ctx -> cu_context ) ; \n if ( ctx -> nvel . nvenc ) \n dlclose ( ctx -> nvel . nvenc ) ; \n if ( ctx -> nvel . cuda ) \n dlclose ( ctx -> nvel . cuda ) ; \n return 0 ; \n }", "idx": 23908}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static QDM2SubPNode * qdm2_search_subpacket_type_in_list ( QDM2SubPNode * list , \n int type ) \n { \n while ( list != NULL && list -> packet != NULL ) { \n if ( list -> packet -> type == type ) \n return list ; \n list = list -> next ; \n } \n return NULL ; \n }", "idx": 23909}
{"project": "FFmpeg", "commit_id": "78a5fc4579deb63e1e6b93cd4d6e2ec2dceff931", "target": 1, "func": "static enum AVPixelFormat get_format ( HEVCContext * s , const HEVCSPS * sps ) \n { \n #define HWACCEL_MAX  (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL)  \n  \n  enum AVPixelFormat pix_fmts [ HWACCEL_MAX + 2 ] , * fmt = pix_fmts ; \n switch ( sps -> pix_fmt ) { \n case AV_PIX_FMT_YUV420P : \n case AV_PIX_FMT_YUVJ420P : \n #if CONFIG_HEVC_DXVA2_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_DXVA2_VLD ; \n #endif \n #if CONFIG_HEVC_D3D11VA_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_D3D11VA_VLD ; \n #endif \n #if CONFIG_HEVC_VAAPI_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VAAPI ; \n #endif \n #if CONFIG_HEVC_VDPAU_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VDPAU ; \n #endif \n break ; \n case AV_PIX_FMT_YUV420P10 : \n #if CONFIG_HEVC_DXVA2_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_DXVA2_VLD ; \n #endif \n #if CONFIG_HEVC_D3D11VA_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_D3D11VA_VLD ; \n #endif \n #if CONFIG_HEVC_VAAPI_HWACCEL  \n  \n  * fmt ++ = AV_PIX_FMT_VAAPI ; \n #endif \n break ; \n } \n * fmt ++ = sps -> pix_fmt ; \n * fmt = AV_PIX_FMT_NONE ; \n return ff_get_format ( s -> avctx , pix_fmts ) ; \n }", "idx": 23915}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pnm_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n return 0 ; \n }", "idx": 23920}
{"project": "FFmpeg", "commit_id": "3f4fccf4d6d2a9a6db46bfca0e6fb648d8e3708b", "target": 0, "func": "static int read_table ( AVFormatContext * avctx , AVStream * st , \n int ( * parse ) ( AVFormatContext * avctx , AVStream * st , \n const char * name , int size ) ) \n { \n int count , i ; \n AVIOContext * pb = avctx -> pb ; \n avio_skip ( pb , 4 ) ; \n count = avio_rb32 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n for ( i = 0 ; i < count ; i ++ ) { \n char name [ 17 ] ; \n int size ; \n avio_read ( pb , name , 16 ) ; \n name [ sizeof ( name ) - 1 ] = 0 ; \n size = avio_rb32 ( pb ) ; \n if ( size < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , size ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( parse ( avctx , st , name , size ) < 0 ) { \n avpriv_request_sample ( avctx , \" \" , name ) ; \n avio_skip ( pb , size ) ; \n } \n } \n return 0 ; \n }", "idx": 23940}
{"project": "FFmpeg", "commit_id": "79c4a338e4b2bf0bc6f81c9f455994f673a92f78", "target": 0, "func": "static int xmv_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n XMVDemuxContext * xmv = s -> priv_data ; \n int result ; \n if ( xmv -> video . current_frame == xmv -> video . frame_count ) { \n result = xmv_fetch_new_packet ( s ) ; \n if ( result ) \n return result ; \n } \n if ( xmv -> current_stream == 0 ) { \n result = xmv_fetch_video_packet ( s , pkt ) ; \n } else { \n result = xmv_fetch_audio_packet ( s , pkt , xmv -> current_stream - 1 ) ; \n } \n if ( result ) \n return result ; \n if ( ++ xmv -> current_stream >= xmv -> stream_count ) { \n xmv -> current_stream = 0 ; \n xmv -> video . current_frame += 1 ; \n } \n return 0 ; \n }", "idx": 23952}
{"project": "FFmpeg", "commit_id": "61cd19b8bc32185c8caf64d89d1b0909877a0707", "target": 1, "func": "static av_always_inline int vmnc_get_pixel ( const uint8_t * buf , int bpp , int be ) \n { \n switch ( bpp * 2 + be ) { \n case 2 : \n case 3 : \n return * buf ; \n case 4 : \n return AV_RL16 ( buf ) ; \n case 5 : \n return AV_RB16 ( buf ) ; \n case 8 : \n return AV_RL32 ( buf ) ; \n case 9 : \n return AV_RB32 ( buf ) ; \n default : \n return 0 ; \n } \n }", "idx": 23971}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int get_moov_size ( AVFormatContext * s ) \n { \n int ret ; \n AVIOContext * moov_buf ; \n MOVMuxContext * mov = s -> priv_data ; \n if ( ( ret = ffio_open_null_buf ( & moov_buf ) ) < 0 ) \n return ret ; \n mov_write_moov_tag ( moov_buf , mov , s ) ; \n return ffio_close_null_buf ( moov_buf ) ; \n }", "idx": 23974}
{"project": "FFmpeg", "commit_id": "d44e0d8b930732a4a247b4884d75cf62b4ad3664", "target": 1, "func": "static int recover ( WtvContext * wtv , uint64_t broken_pos ) \n { \n AVIOContext * pb = wtv -> pb ; \n int i ; \n for ( i = 0 ; i < wtv -> nb_index_entries ; i ++ ) { \n if ( wtv -> index_entries [ i ] . pos > broken_pos ) { \n int ret = avio_seek ( pb , wtv -> index_entries [ i ] . pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n wtv -> pts = wtv -> index_entries [ i ] . timestamp ; \n return 0 ; \n } \n } \n return AVERROR ( EIO ) ; \n }", "idx": 23976}
{"project": "FFmpeg", "commit_id": "d43696309a64a19e2e738f9e7aa94f6c96409aee", "target": 1, "func": "static const uint8_t * decode_nal ( H264Context * h , const uint8_t * src , int * dst_length , int * consumed , int length ) { \n int i , si , di ; \n uint8_t * dst ; \n int bufidx ; \n h -> nal_ref_idc = src [ 0 ] >> 5 ; \n h -> nal_unit_type = src [ 0 ] & 0x1F ; \n src ++ ; length -- ; \n #if 0  \n  \n  for ( i = 0 ; i < length ; i ++ ) \n printf ( \" \" , src [ i ] ) ; \n #endif \n for ( i = 0 ; i + 1 < length ; i += 2 ) { \n if ( src [ i ] ) continue ; \n if ( i > 0 && src [ i - 1 ] == 0 ) i -- ; \n if ( i + 2 < length && src [ i + 1 ] == 0 && src [ i + 2 ] <= 3 ) { \n if ( src [ i + 2 ] != 3 ) { \n length = i ; \n } \n break ; \n } \n } \n if ( i >= length - 1 ) { \n * dst_length = length ; \n * consumed = length + 1 ; \n return src ; \n } \n bufidx = h -> nal_unit_type == NAL_DPC ? 1 : 0 ; \n h -> rbsp_buffer [ bufidx ] = av_fast_realloc ( h -> rbsp_buffer [ bufidx ] , & h -> rbsp_buffer_size [ bufidx ] , length ) ; \n dst = h -> rbsp_buffer [ bufidx ] ; \n if ( dst == NULL ) { \n return NULL ; \n } \n si = di = 0 ; \n while ( si < length ) { \n if ( si + 2 < length && src [ si ] == 0 && src [ si + 1 ] == 0 && src [ si + 2 ] <= 3 ) { \n if ( src [ si + 2 ] == 3 ) { \n dst [ di ++ ] = 0 ; \n dst [ di ++ ] = 0 ; \n si += 3 ; \n continue ; \n } else \n break ; \n } \n dst [ di ++ ] = src [ si ++ ] ; \n } \n * dst_length = di ; \n * consumed = si + 1 ; \n return dst ; \n }", "idx": 23979}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_wgt_4width_msa ( uint8_t * data , \n int32_t stride , \n int32_t height , \n int32_t log2_denom , \n int32_t src_weight , \n int32_t offset_in ) \n { \n if ( 2 == height ) { \n avc_wgt_4x2_msa ( data , stride , log2_denom , src_weight , offset_in ) ; \n } else { \n avc_wgt_4x4multiple_msa ( data , stride , height , log2_denom , \n src_weight , offset_in ) ; \n } \n }", "idx": 23990}
{"project": "FFmpeg", "commit_id": "d3e5fbb1406995e07fccbff3ca8c1e24f57a1f7b", "target": 0, "func": "static void do_apply_filter ( APEContext * ctx , int version , APEFilter * f , \n int32_t * data , int count , int order , int fracbits ) \n { \n int res ; \n int absres ; \n while ( count -- ) { \n res = ctx -> adsp . scalarproduct_and_madd_int16 ( f -> coeffs , \n f -> delay - order , \n f -> adaptcoeffs - order , \n order , APESIGN ( * data ) ) ; \n res = ( res + ( 1 << ( fracbits - 1 ) ) ) >> fracbits ; \n res += * data ; \n * data ++ = res ; \n * f -> delay ++ = av_clip_int16 ( res ) ; \n if ( version < 3980 ) { \n f -> adaptcoeffs [ 0 ] = ( res == 0 ) ? 0 : ( ( res >> 28 ) & 8 ) - 4 ; \n f -> adaptcoeffs [ -4 ] >>= 1 ; \n f -> adaptcoeffs [ -8 ] >>= 1 ; \n } else { \n absres = FFABS ( res ) ; \n if ( absres ) \n * f -> adaptcoeffs = ( ( res & ( -1 << 31 ) ) ^ ( -1 << 30 ) ) >> \n ( 25 + ( absres <= f -> avg * 3 ) + ( absres <= f -> avg * 4 / 3 ) ) ; \n else \n * f -> adaptcoeffs = 0 ; \n f -> avg += ( absres - f -> avg ) / 16 ; \n f -> adaptcoeffs [ -1 ] >>= 1 ; \n f -> adaptcoeffs [ -2 ] >>= 1 ; \n f -> adaptcoeffs [ -8 ] >>= 1 ; \n } \n f -> adaptcoeffs ++ ; \n if ( f -> delay == f -> historybuffer + HISTORY_SIZE + ( order * 2 ) ) { \n memmove ( f -> historybuffer , f -> delay - ( order * 2 ) , \n ( order * 2 ) * sizeof ( * f -> historybuffer ) ) ; \n f -> delay = f -> historybuffer + order * 2 ; \n f -> adaptcoeffs = f -> historybuffer + order ; \n } \n } \n }", "idx": 23991}
{"project": "FFmpeg", "commit_id": "12c3e120fe8f8d6881001eade390d8a5c185783d", "target": 1, "func": "static int h263p_decode_umotion ( MpegEncContext * s , int pred ) \n { \n int code = 0 , sign ; \n if ( get_bits1 ( & s -> gb ) ) \n return pred ; \n code = 2 + get_bits1 ( & s -> gb ) ; \n while ( get_bits1 ( & s -> gb ) ) \n { \n code <<= 1 ; \n code += get_bits1 ( & s -> gb ) ; \n if ( code >= 32768 ) { \n avpriv_request_sample ( s -> avctx , \" \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n sign = code & 1 ; \n code >>= 1 ; \n code = ( sign ) ? ( pred - code ) : ( pred + code ) ; \n ff_tlog ( s -> avctx , \" \\n \" , code ) ; \n return code ; \n }", "idx": 23993}
{"project": "FFmpeg", "commit_id": "68aefbe81cb3b9dd002108782bb8d798e1c12806", "target": 1, "func": "static void stream_pause ( VideoState * is ) \n { \n is -> paused = ! is -> paused ; \n if ( ! is -> paused ) { \n if ( is -> read_pause_return != AVERROR ( ENOSYS ) ) { \n is -> video_current_pts = get_video_clock ( is ) ; \n } \n is -> frame_timer += ( av_gettime ( ) - is -> video_current_pts_time ) / 1000000.0 ; \n is -> video_current_pts_time = av_gettime ( ) ; \n } \n }", "idx": 23994}
{"project": "FFmpeg", "commit_id": "8eeacf31c5ea37baf6b222dc38d20cf4fd33c455", "target": 0, "func": "static void FUNC ( hevc_loop_filter_chroma ) ( uint8_t * _pix , ptrdiff_t _xstride , \n ptrdiff_t _ystride , int * _tc , \n uint8_t * _no_p , uint8_t * _no_q ) \n { \n int d , j , no_p , no_q ; \n pixel * pix = ( pixel * ) _pix ; \n ptrdiff_t xstride = _xstride / sizeof ( pixel ) ; \n ptrdiff_t ystride = _ystride / sizeof ( pixel ) ; \n for ( j = 0 ; j < 2 ; j ++ ) { \n const int tc = _tc [ j ] << ( BIT_DEPTH - 8 ) ; \n if ( tc <= 0 ) { \n pix += 4 * ystride ; \n continue ; \n } \n no_p = _no_p [ j ] ; \n no_q = _no_q [ j ] ; \n for ( d = 0 ; d < 4 ; d ++ ) { \n int delta0 ; \n const int p1 = P1 ; \n const int p0 = P0 ; \n const int q0 = Q0 ; \n const int q1 = Q1 ; \n delta0 = av_clip ( ( ( ( q0 - p0 ) << 2 ) + p1 - q1 + 4 ) >> 3 , - tc , tc ) ; \n if ( ! no_p ) \n P0 = av_clip_pixel ( p0 + delta0 ) ; \n if ( ! no_q ) \n Q0 = av_clip_pixel ( q0 - delta0 ) ; \n pix += ystride ; \n } \n } \n }", "idx": 23998}
{"project": "FFmpeg", "commit_id": "f1783c05f1398b7a08f16f6aafbcf38a5323e770", "target": 0, "func": "static int hevc_decode_frame ( AVCodecContext * avctx , void * data , int * got_output , \n AVPacket * avpkt ) \n { \n int ret ; \n HEVCContext * s = avctx -> priv_data ; \n if ( ! avpkt -> size ) { \n ret = ff_hevc_output_frame ( s , data , 1 ) ; \n if ( ret < 0 ) \n return ret ; \n * got_output = ret ; \n return 0 ; \n } \n s -> ref = NULL ; \n ret = decode_nal_units ( s , avpkt -> data , avpkt -> size ) ; \n if ( ret < 0 ) \n return ret ; \n if ( avctx -> err_recognition & AV_EF_CRCCHECK && s -> is_decoded && \n avctx -> err_recognition & AV_EF_EXPLODE && \n s -> is_md5 ) { \n ret = verify_md5 ( s , s -> ref -> frame ) ; \n if ( ret < 0 ) { \n ff_hevc_unref_frame ( s , s -> ref , ~ 0 ) ; \n return ret ; \n } \n } \n s -> is_md5 = 0 ; \n if ( s -> is_decoded ) { \n av_log ( avctx , AV_LOG_DEBUG , \" \\n \" , s -> poc ) ; \n s -> is_decoded = 0 ; \n } \n if ( s -> output_frame -> buf [ 0 ] ) { \n av_frame_move_ref ( data , s -> output_frame ) ; \n * got_output = 1 ; \n } \n return avpkt -> size ; \n }", "idx": 24000}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "static inline int hpel_motion_lowres ( MpegEncContext * s , \n uint8_t * dest , uint8_t * src , \n int field_based , int field_select , \n int src_x , int src_y , \n int width , int height , int stride , \n int h_edge_pos , int v_edge_pos , \n int w , int h , h264_chroma_mc_func * pix_op , \n int motion_x , int motion_y ) \n { \n const int lowres = s -> avctx -> lowres ; \n const int op_index = FFMIN ( lowres , 3 ) ; \n const int s_mask = ( 2 << lowres ) - 1 ; \n int emu = 0 ; \n int sx , sy ; \n if ( s -> quarter_sample ) { \n motion_x /= 2 ; \n motion_y /= 2 ; \n } \n sx = motion_x & s_mask ; \n sy = motion_y & s_mask ; \n src_x += motion_x >> lowres + 1 ; \n src_y += motion_y >> lowres + 1 ; \n src += src_y * stride + src_x ; \n if ( ( unsigned ) src_x > FFMAX ( h_edge_pos - ( ! ! sx ) - w , 0 ) || \n ( unsigned ) src_y > FFMAX ( ( v_edge_pos >> field_based ) - ( ! ! sy ) - h , 0 ) ) { \n s -> vdsp . emulated_edge_mc ( s -> edge_emu_buffer , src , s -> linesize , w + 1 , \n ( h + 1 ) << field_based , src_x , \n src_y << field_based , \n h_edge_pos , \n v_edge_pos ) ; \n src = s -> edge_emu_buffer ; \n emu = 1 ; \n } \n sx = ( sx << 2 ) >> lowres ; \n sy = ( sy << 2 ) >> lowres ; \n if ( field_select ) \n src += s -> linesize ; \n pix_op [ op_index ] ( dest , src , stride , h , sx , sy ) ; \n return emu ; \n }", "idx": 24008}
{"project": "FFmpeg", "commit_id": "2f7a12fab5a2ea17bd78b155e9af965669fb9b52", "target": 1, "func": "av_cold void ff_mlz_init_dict ( void * context , MLZ * mlz ) { \n mlz -> dict = av_malloc_array ( TABLE_SIZE , sizeof ( * mlz -> dict ) ) ; \n mlz -> flush_code = FLUSH_CODE ; \n mlz -> current_dic_index_max = DIC_INDEX_INIT ; \n mlz -> dic_code_bit = CODE_BIT_INIT ; \n mlz -> bump_code = ( DIC_INDEX_INIT - 1 ) ; \n mlz -> next_code = FIRST_CODE ; \n mlz -> freeze_flag = 0 ; \n mlz -> context = context ; \n }", "idx": 24011}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static int decode_slice_chroma ( AVCodecContext * avctx , SliceContext * slice , \n uint16_t * dst , int dst_stride , \n const uint8_t * buf , unsigned buf_size , \n const int16_t * qmat , int log2_blocks_per_mb ) \n { \n ProresContext * ctx = avctx -> priv_data ; \n LOCAL_ALIGNED_16 ( int16_t , blocks ,  [ 8 * 4 * 64 ] ) ; \n int16_t * block ; \n GetBitContext gb ; \n int i , j , blocks_per_slice = slice -> mb_count << log2_blocks_per_mb ; \n int ret ; \n for ( i = 0 ; i < blocks_per_slice ; i ++ ) \n ctx -> bdsp . clear_block ( blocks + ( i << 6 ) ) ; \n init_get_bits ( & gb , buf , buf_size << 3 ) ; \n decode_dc_coeffs ( & gb , blocks , blocks_per_slice ) ; \n if ( ( ret = decode_ac_coeffs ( avctx , & gb , blocks , blocks_per_slice ) ) < 0 ) \n return ret ; \n block = blocks ; \n for ( i = 0 ; i < slice -> mb_count ; i ++ ) { \n for ( j = 0 ; j < log2_blocks_per_mb ; j ++ ) { \n ctx -> prodsp . idct_put ( dst , dst_stride , block + ( 0 << 6 ) , qmat ) ; \n ctx -> prodsp . idct_put ( dst + 4 * dst_stride , dst_stride , block + ( 1 << 6 ) , qmat ) ; \n block += 2 * 64 ; \n dst += 8 ; \n } \n } \n return 0 ; \n }", "idx": 24012}
{"project": "FFmpeg", "commit_id": "7684a36113fa12c88ba80b5498f05849a6b58632", "target": 0, "func": "static int mxf_write_footer ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n mxf -> duration = mxf -> last_indexed_edit_unit + mxf -> edit_units_count ; \n mxf_write_klv_fill ( s ) ; \n mxf -> footer_partition_offset = avio_tell ( pb ) ; \n if ( mxf -> edit_unit_byte_count ) { \n mxf_write_partition ( s , 0 , 0 , footer_partition_key , 0 ) ; \n } else { \n mxf_write_partition ( s , 0 , 2 , footer_partition_key , 0 ) ; \n mxf_write_klv_fill ( s ) ; \n mxf_write_index_table_segment ( s ) ; \n } \n mxf_write_klv_fill ( s ) ; \n mxf_write_random_index_pack ( s ) ; \n if ( s -> pb -> seekable ) { \n avio_seek ( pb , 0 , SEEK_SET ) ; \n if ( mxf -> edit_unit_byte_count ) { \n mxf_write_partition ( s , 1 , 2 , header_closed_partition_key , 1 ) ; \n mxf_write_klv_fill ( s ) ; \n mxf_write_index_table_segment ( s ) ; \n } else { \n mxf_write_partition ( s , 0 , 0 , header_closed_partition_key , 1 ) ; \n } \n } \n ff_audio_interleave_close ( s ) ; \n av_freep ( & mxf -> index_entries ) ; \n av_freep ( & mxf -> body_partition_offset ) ; \n av_freep ( & mxf -> timecode_track -> priv_data ) ; \n av_freep ( & mxf -> timecode_track ) ; \n mxf_free ( s ) ; \n return 0 ; \n }", "idx": 24014}
{"project": "FFmpeg", "commit_id": "7495c3066d7b67bbc74b1d5565684ff48e430099", "target": 0, "func": "static int64_t getutime ( void ) \n { \n #ifdef HAVE_GETRUSAGE \n struct rusage rusage ; \n getrusage ( RUSAGE_SELF , & rusage ) ; \n return ( rusage . ru_utime . tv_sec * 1000000LL ) + rusage . ru_utime . tv_usec ; \n #elif defined ( __MINGW32__ )  \n  \n  return av_gettime ( ) ; \n #endif \n }", "idx": 24020}
{"project": "FFmpeg", "commit_id": "d164ad3298c155330e303bea907920643b5d74a3", "target": 1, "func": "static int ivi_init_tiles ( IVIBandDesc * band , IVITile * ref_tile , \n int p , int b , int t_height , int t_width ) \n { \n int x , y ; \n IVITile * tile = band -> tiles ; \n for ( y = 0 ; y < band -> height ; y += t_height ) { \n for ( x = 0 ; x < band -> width ; x += t_width ) { \n tile -> xpos = x ; \n tile -> ypos = y ; \n tile -> mb_size = band -> mb_size ; \n tile -> width = FFMIN ( band -> width - x , t_width ) ; \n tile -> height = FFMIN ( band -> height - y , t_height ) ; \n tile -> is_empty = tile -> data_size = 0 ; \n tile -> num_MBs = IVI_MBs_PER_TILE ( tile -> width , tile -> height , \n band -> mb_size ) ; \n av_freep ( & tile -> mbs ) ; \n tile -> mbs = av_malloc ( tile -> num_MBs * sizeof ( IVIMbInfo ) ) ; \n if ( ! tile -> mbs ) \n return AVERROR ( ENOMEM ) ; \n tile -> ref_mbs = 0 ; \n if ( p || b ) { \n if ( tile -> num_MBs != ref_tile -> num_MBs ) { \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n tile -> ref_mbs = ref_tile -> mbs ; \n ref_tile ++ ; \n } \n tile ++ ; \n } \n } \n return 0 ; \n }", "idx": 24027}
{"project": "FFmpeg", "commit_id": "a0e7079a207fc38cb3754cf11a29863c81f633e4", "target": 1, "func": "static av_cold int common_end ( AVCodecContext * avctx ) { \n FFV1Context * s = avctx -> priv_data ; \n int i , j ; \n for ( j = 0 ; j < s -> slice_count ; j ++ ) { \n FFV1Context * fs = s -> slice_context [ j ] ; \n for ( i = 0 ; i < s -> plane_count ; i ++ ) { \n PlaneContext * p = & fs -> plane [ i ] ; \n av_freep ( & p -> state ) ; \n av_freep ( & p -> vlc_state ) ; \n av_freep ( & fs -> sample_buffer ) ; \n av_freep ( & avctx -> stats_out ) ; \n for ( j = 0 ; j < s -> quant_table_count ; j ++ ) { \n av_freep ( & s -> initial_states [ j ] ) ; \n FFV1Context * sf = s -> slice_context [ i ] ; \n av_freep ( & sf -> rc_stat2 [ j ] ) ; \n av_freep ( & s -> rc_stat2 [ j ] ) ; \n return 0 ;", "idx": 24028}
{"project": "FFmpeg", "commit_id": "be630b1e08ebe8f766b1798accd6b8e5e096f5aa", "target": 1, "func": "unsigned ff_dxva2_get_surface_index ( const AVCodecContext * avctx , \n const AVDXVAContext * ctx , \n const AVFrame * frame ) \n { \n void * surface = ff_dxva2_get_surface ( frame ) ; \n unsigned i ; \n for ( i = 0 ; i < DXVA_CONTEXT_COUNT ( avctx , ctx ) ; i ++ ) \n if ( DXVA_CONTEXT_SURFACE ( avctx , ctx , i ) == surface ) \n return i ; \n assert ( 0 ) ; \n return 0 ; \n }", "idx": 24029}
{"project": "FFmpeg", "commit_id": "d0a503c97cc59b17e77585a726448dfa46245f4d", "target": 0, "func": "static int ast_read_header ( AVFormatContext * s ) \n { \n int codec ; \n AVStream * st ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n avio_skip ( s -> pb , 8 ) ; \n codec = avio_rb16 ( s -> pb ) ; \n switch ( codec ) { \n case 1 : \n st -> codec -> codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR ; \n break ; \n default : \n av_log ( s , AV_LOG_ERROR , \" \\n \" , codec ) ; \n } \n avio_skip ( s -> pb , 2 ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codec -> channels = avio_rb16 ( s -> pb ) ; \n if ( ! st -> codec -> channels ) \n return AVERROR_INVALIDDATA ; \n if ( st -> codec -> channels == 2 ) \n st -> codec -> channel_layout = AV_CH_LAYOUT_STEREO ; \n else if ( st -> codec -> channels == 4 ) \n st -> codec -> channel_layout = AV_CH_LAYOUT_4POINT0 ; \n avio_skip ( s -> pb , 2 ) ; \n st -> codec -> sample_rate = avio_rb32 ( s -> pb ) ; \n if ( st -> codec -> sample_rate <= 0 ) \n return AVERROR_INVALIDDATA ; \n st -> start_time = 0 ; \n st -> duration = avio_rb32 ( s -> pb ) ; \n avio_skip ( s -> pb , 40 ) ; \n avpriv_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 24055}
{"project": "FFmpeg", "commit_id": "e48ded8551172b58a78f30303a81dfce125344e0", "target": 0, "func": "static av_cold int vsink_init ( AVFilterContext * ctx , void * opaque ) \n { \n BufferSinkContext * buf = ctx -> priv ; \n AVBufferSinkParams * params = opaque ; \n if ( params && params -> pixel_fmts ) { \n const int * pixel_fmts = params -> pixel_fmts ; \n buf -> pixel_fmts = ff_copy_int_list ( pixel_fmts ) ; \n if ( ! buf -> pixel_fmts ) \n return AVERROR ( ENOMEM ) ; \n } \n return common_init ( ctx ) ; \n }", "idx": 24056}
{"project": "FFmpeg", "commit_id": "c595139f1fdb5ce5ee128c317ed9e4e836282436", "target": 1, "func": "int ff_dirac_golomb_read_32bit ( DiracGolombLUT * lut_ctx , const uint8_t * buf , \n int bytes , uint8_t * _dst , int coeffs ) \n { \n int i , b , c_idx = 0 ; \n int32_t * dst = ( int32_t * ) _dst ; \n DiracGolombLUT * future [ 4 ] , * l = & lut_ctx [ 2 * LUT_SIZE + buf [ 0 ] ] ; \n INIT_RESIDUE ( res ) ; \n for ( b = 1 ; b <= bytes ; b ++ ) { \n future [ 0 ] = & lut_ctx [ buf [ b ] ] ; \n future [ 1 ] = future [ 0 ] + 1 * LUT_SIZE ; \n future [ 2 ] = future [ 0 ] + 2 * LUT_SIZE ; \n future [ 3 ] = future [ 0 ] + 3 * LUT_SIZE ; \n if ( ( c_idx + 1 ) > coeffs ) \n return c_idx ; \n if ( res_bits && l -> sign ) { \n int32_t coeff = 1 ; \n APPEND_RESIDUE ( res , l -> preamble ) ; \n for ( i = 0 ; i < ( res_bits >> 1 ) - 1 ; i ++ ) { \n coeff <<= 1 ; \n coeff |= ( res >> ( RSIZE_BITS - 2 * i - 2 ) ) & 1 ; \n } \n dst [ c_idx ++ ] = l -> sign * ( coeff - 1 ) ; \n } \n memcpy ( & dst [ c_idx ] , l -> ready , LUT_BITS * sizeof ( int32_t ) ) ; \n c_idx += l -> ready_num ; \n APPEND_RESIDUE ( res , l -> leftover ) ; \n l = future [ l -> need_s ? 3 : ! res_bits ? 2 : res_bits & 1 ] ; \n } \n return c_idx ; \n }", "idx": 24061}
{"project": "FFmpeg", "commit_id": "50c21814b9de5635cf01e2d1ea091a9a272a4d67", "target": 1, "func": "static void clone_tables ( H264Context * dst , H264Context * src ) { \n dst -> intra4x4_pred_mode = src -> intra4x4_pred_mode ; \n dst -> non_zero_count = src -> non_zero_count ; \n dst -> slice_table = src -> slice_table ; \n dst -> cbp_table = src -> cbp_table ; \n dst -> mb2b_xy = src -> mb2b_xy ; \n dst -> mb2b8_xy = src -> mb2b8_xy ; \n dst -> chroma_pred_mode_table = src -> chroma_pred_mode_table ; \n dst -> mvd_table [ 0 ] = src -> mvd_table [ 0 ] ; \n dst -> mvd_table [ 1 ] = src -> mvd_table [ 1 ] ; \n dst -> direct_table = src -> direct_table ; \n if ( ! dst -> dequant4_coeff [ 0 ] ) \n init_dequant_tables ( dst ) ; \n dst -> s . obmc_scratchpad = NULL ; \n ff_h264_pred_init ( & dst -> hpc , src -> s . codec_id ) ; \n dst -> dequant_coeff_pps = -1 ; \n }", "idx": 24067}
{"project": "FFmpeg", "commit_id": "3b7ebeb4d52a25c7e1038ae90c6c19b0d6f11877", "target": 0, "func": "void ff_h264_write_back_intra_pred_mode ( H264Context * h ) { \n int8_t * mode = h -> intra4x4_pred_mode + h -> mb2br_xy [ h -> mb_xy ] ; \n AV_COPY32 ( mode , h -> intra4x4_pred_mode_cache + 4 + 8 * 4 ) ; \n mode [ 4 ] = h -> intra4x4_pred_mode_cache [ 7 + 8 * 3 ] ; \n mode [ 5 ] = h -> intra4x4_pred_mode_cache [ 7 + 8 * 2 ] ; \n mode [ 6 ] = h -> intra4x4_pred_mode_cache [ 7 + 8 * 1 ] ; \n }", "idx": 24074}
{"project": "FFmpeg", "commit_id": "93ef29b6f47eda7d73eb9e71628f1f1abb64266d", "target": 1, "func": "static int noise ( AVBitStreamFilterContext * bsfc , AVCodecContext * avctx , const char * args , \n uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size , int keyframe ) { \n unsigned int * state = bsfc -> priv_data ; \n int amount = args ? atoi ( args ) : ( * state % 10001 + 1 ) ; \n int i ; \n * poutbuf = av_malloc ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n memcpy ( * poutbuf , buf , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n for ( i = 0 ; i < buf_size ; i ++ ) { \n ( * state ) += ( * poutbuf ) [ i ] + 1 ; \n if ( * state % amount == 0 ) \n ( * poutbuf ) [ i ] = * state ; \n } \n return 1 ; \n }", "idx": 24076}
{"project": "FFmpeg", "commit_id": "e29153f414f5b2d10e0386abf7921aed4a4fa454", "target": 1, "func": "static av_cold int avui_encode_init ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( avctx -> width != 720 || avctx -> height != 486 && avctx -> height != 576 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( ! avctx -> coded_frame ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! ( avctx -> extradata = av_mallocz ( 24 + FF_INPUT_BUFFER_PADDING_SIZE ) ) ) \n return AVERROR ( ENOMEM ) ; \n avctx -> extradata_size = 24 ; \n memcpy ( avctx -> extradata , \" \\0 \\0 \\0 \\x18 \" \" \" , 16 ) ; \n if ( avctx -> field_order > AV_FIELD_PROGRESSIVE ) { \n avctx -> extradata [ 19 ] = 2 ; \n } else { \n avctx -> extradata [ 19 ] = 1 ; \n } \n return 0 ; \n }", "idx": 24079}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n MPADecodeContext * s = avctx -> priv_data ; \n uint32_t header ; \n int ret ; \n if ( buf_size < HEADER_SIZE ) \n return AVERROR_INVALIDDATA ; \n header = AV_RB32 ( buf ) ; \n if ( ff_mpa_check_header ( header ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( avpriv_mpegaudio_decode_header ( ( MPADecodeHeader * ) s , header ) == 1 ) { \n s -> frame_size = -1 ; \n return AVERROR_INVALIDDATA ; \n } \n avctx -> channels = s -> nb_channels ; \n avctx -> channel_layout = s -> nb_channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO ; \n if ( ! avctx -> bit_rate ) \n avctx -> bit_rate = s -> bit_rate ; \n s -> frame = data ; \n ret = mp_decode_frame ( s , NULL , buf , buf_size ) ; \n if ( ret >= 0 ) { \n s -> frame -> nb_samples = avctx -> frame_size ; \n * got_frame_ptr = 1 ; \n avctx -> sample_rate = s -> sample_rate ; \n } else { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n * got_frame_ptr = 0 ; \n if ( buf_size == avpkt -> size || ret != AVERROR_INVALIDDATA ) \n return ret ; \n } \n s -> frame_size = 0 ; \n return buf_size ; \n }", "idx": 24081}
{"project": "FFmpeg", "commit_id": "284b432662b6e137148ff9d13ef2b554cb14b4ae", "target": 0, "func": "static int fits_write_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n write_image_header ( s ) ; \n avio_write ( s -> pb , pkt -> data , pkt -> size ) ; \n return 0 ; \n }", "idx": 24093}
{"project": "FFmpeg", "commit_id": "eabbc64728c2fdb74f565aededec2ab023d20699", "target": 0, "func": "static int mkv_write_tag_targets ( AVFormatContext * s , \n unsigned int elementid , unsigned int uid , \n ebml_master * tags , ebml_master * tag ) \n { \n AVIOContext * pb ; \n MatroskaMuxContext * mkv = s -> priv_data ; \n ebml_master targets ; \n int ret ; \n if ( ! tags -> pos ) { \n ret = mkv_add_seekhead_entry ( mkv -> main_seekhead , MATROSKA_ID_TAGS , avio_tell ( s -> pb ) ) ; \n if ( ret < 0 ) return ret ; \n start_ebml_master_crc32 ( s -> pb , & mkv -> tags_bc , tags , MATROSKA_ID_TAGS , 0 ) ; \n } \n pb = mkv -> tags_bc ; \n * tag = start_ebml_master ( pb , MATROSKA_ID_TAG , 0 ) ; \n targets = start_ebml_master ( pb , MATROSKA_ID_TAGTARGETS , 0 ) ; \n if ( elementid ) \n put_ebml_uint ( pb , elementid , uid ) ; \n end_ebml_master ( pb , targets ) ; \n return 0 ; \n }", "idx": 24104}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int ogg_read_header ( AVFormatContext * avfcontext , AVFormatParameters * ap ) \n { \n OggContext * context = avfcontext -> priv_data ; \n ogg_packet op ; \n char * buf ; \n ogg_page og ; \n AVStream * ast ; \n AVCodecContext * codec ; \n uint8_t * p ; \n int i ; \n ogg_sync_init ( & context -> oy ) ; \n buf = ogg_sync_buffer ( & context -> oy , DECODER_BUFFER_SIZE ) ; \n if ( get_buffer ( & avfcontext -> pb , buf , DECODER_BUFFER_SIZE ) <= 0 ) \n return AVERROR_IO ; \n ogg_sync_wrote ( & context -> oy , DECODER_BUFFER_SIZE ) ; \n ogg_sync_pageout ( & context -> oy , & og ) ; \n ogg_stream_init ( & context -> os , ogg_page_serialno ( & og ) ) ; \n ogg_stream_pagein ( & context -> os , & og ) ; \n ast = av_new_stream ( avfcontext , 0 ) ; \n if ( ! ast ) \n return AVERROR_NOMEM ; \n av_set_pts_info ( ast , 60 , 1 , AV_TIME_BASE ) ; \n codec = & ast -> codec ; \n codec -> codec_type = CODEC_TYPE_AUDIO ; \n codec -> codec_id = CODEC_ID_VORBIS ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n if ( next_packet ( avfcontext , & op ) ) { \n } \n codec -> extradata_size += 2 + op . bytes ; \n codec -> extradata = av_realloc ( codec -> extradata , codec -> extradata_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n p = codec -> extradata + codec -> extradata_size - 2 - op . bytes ; \n * ( p ++ ) = op . bytes >> 8 ; \n * ( p ++ ) = op . bytes & 0xFF ; \n memcpy ( p , op . packet , op . bytes ) ; \n } \n return 0 ; \n }", "idx": 24112}
{"project": "FFmpeg", "commit_id": "b0b2faa70995caf710bf49c7c6eb6dc502a67672", "target": 1, "func": "static void rtsp_cmd_teardown ( HTTPContext * c , const char * url , RTSPHeader * h ) \n { \n HTTPContext * rtp_c ; \n rtp_c = find_rtp_session_with_url ( url , h -> session_id ) ; \n if ( ! rtp_c ) { \n rtsp_reply_error ( c , RTSP_STATUS_SESSION ) ; \n return ; \n } \n close_connection ( rtp_c ) ; \n rtsp_reply_header ( c , RTSP_STATUS_OK ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" , rtp_c -> session_id ) ; \n url_fprintf ( c -> pb , \" \\r \\n \" ) ; \n }", "idx": 24116}
{"project": "FFmpeg", "commit_id": "933aa91e31d5cbf9dbc0cf416a988e6011bc4a40", "target": 1, "func": "void ff_hevc_cabac_init ( HEVCContext * s , int ctb_addr_ts ) \n { \n if ( ctb_addr_ts == s -> ps . pps -> ctb_addr_rs_to_ts [ s -> sh . slice_ctb_addr_rs ] ) { \n cabac_init_decoder ( s ) ; \n if ( s -> sh . dependent_slice_segment_flag == 0 || \n ( s -> ps . pps -> tiles_enabled_flag && \n s -> ps . pps -> tile_id [ ctb_addr_ts ] != s -> ps . pps -> tile_id [ ctb_addr_ts - 1 ] ) ) \n cabac_init_state ( s ) ; \n if ( ! s -> sh . first_slice_in_pic_flag && \n s -> ps . pps -> entropy_coding_sync_enabled_flag ) { \n if ( ctb_addr_ts % s -> ps . sps -> ctb_width == 0 ) { \n if ( s -> ps . sps -> ctb_width == 1 ) \n cabac_init_state ( s ) ; \n else if ( s -> sh . dependent_slice_segment_flag == 1 ) \n load_states ( s ) ; \n } \n } \n } else { \n if ( s -> ps . pps -> tiles_enabled_flag && \n s -> ps . pps -> tile_id [ ctb_addr_ts ] != s -> ps . pps -> tile_id [ ctb_addr_ts - 1 ] ) { \n if ( s -> threads_number == 1 ) \n cabac_reinit ( s -> HEVClc ) ; \n else \n cabac_init_decoder ( s ) ; \n cabac_init_state ( s ) ; \n } \n if ( s -> ps . pps -> entropy_coding_sync_enabled_flag ) { \n if ( ctb_addr_ts % s -> ps . sps -> ctb_width == 0 ) { \n get_cabac_terminate ( & s -> HEVClc -> cc ) ; \n if ( s -> threads_number == 1 ) \n cabac_reinit ( s -> HEVClc ) ; \n else \n cabac_init_decoder ( s ) ; \n if ( s -> ps . sps -> ctb_width == 1 ) \n cabac_init_state ( s ) ; \n else \n load_states ( s ) ; \n } \n } \n } \n }", "idx": 24125}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME ( yuv2rgb565_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n x86_reg uv_off = c -> uv_off << 1 ; \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \"  \n YSCALEYUV2RGB ( % % REGBP , % 5 , % 6 ) \n \" \\n \\t \"  \n #ifdef DITHER1XBPP \n \" \" BLUE_DITHER \" \\n \\t \" \n \" \" GREEN_DITHER \" \\n \\t \" \n \" \" RED_DITHER \" \\n \\t \" \n #endif \n WRITERGB16 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) , \" \" ( uv_off ) \n ) ; \n }", "idx": 24130}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC ( ff_simple_idct_put ) ( uint8_t * dest_ , int line_size , DCTELEM * block ) \n { \n pixel * dest = ( pixel * ) dest_ ; \n int i ; \n line_size /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 8 ; i ++ ) \n FUNC ( idctRowCondDC ) ( block + i * 8 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) \n FUNC ( idctSparseColPut ) ( dest + i , line_size , block + i ) ; \n }", "idx": 24134}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_glbl ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return -1 ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size ; \n get_buffer ( pb , st -> codec -> extradata , atom . size ) ; \n return 0 ; \n }", "idx": 24145}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static uint64_t find_any_startcode ( ByteIOContext * bc , int64_t pos ) { \n uint64_t state = 0 ; \n if ( pos >= 0 ) \n url_fseek ( bc , pos , SEEK_SET ) ; \n while ( bytes_left ( bc ) ) { \n state = ( state << 8 ) | get_byte ( bc ) ; \n if ( ( state >> 56 ) != ' ' ) \n continue ; \n switch ( state ) { \n case MAIN_STARTCODE : \n case STREAM_STARTCODE : \n case KEYFRAME_STARTCODE : \n case INFO_STARTCODE : \n case INDEX_STARTCODE : \n return state ; \n } \n } \n return 0 ; \n }", "idx": 24146}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void ape_unpack_stereo ( APEContext * ctx , int count ) \n { \n int32_t left , right ; \n int32_t * decoded0 = ctx -> decoded [ 0 ] ; \n int32_t * decoded1 = ctx -> decoded [ 1 ] ; \n if ( ctx -> frameflags & APE_FRAMECODE_STEREO_SILENCE ) { \n av_log ( ctx -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return ; \n } \n entropy_decode ( ctx , count , 1 ) ; \n ape_apply_filters ( ctx , decoded0 , decoded1 , count ) ; \n predictor_decode_stereo ( ctx , count ) ; \n while ( count -- ) { \n left = * decoded1 - ( * decoded0 / 2 ) ; \n right = left + * decoded0 ; \n * ( decoded0 ++ ) = left ; \n * ( decoded1 ++ ) = right ; \n } \n }", "idx": 24147}
{"project": "FFmpeg", "commit_id": "0dcfccaa691bf533b0f144b6d98b49eb59f1f3ab", "target": 1, "func": "static int au_write_header ( AVFormatContext * s ) \n { \n AVIOContext * pb = s -> pb ; \n AVCodecContext * enc = s -> streams [ 0 ] -> codec ; \n if ( ! enc -> codec_tag ) \n return AVERROR ( EINVAL ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n avio_wb32 ( pb , AU_HEADER_SIZE ) ; \n avio_wb32 ( pb , AU_UNKNOWN_SIZE ) ; \n avio_wb32 ( pb , enc -> codec_tag ) ; \n avio_wb32 ( pb , enc -> sample_rate ) ; \n avio_wb32 ( pb , enc -> channels ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_flush ( pb ) ; \n return 0 ; \n }", "idx": 24175}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int h264_find_frame_end ( H264ParseContext * p , const uint8_t * buf , \n int buf_size ) \n { \n int i ; \n uint32_t state ; \n ParseContext * pc = & p -> pc ; \n state = pc -> state ; \n if ( state > 13 ) \n state = 7 ; \n for ( i = 0 ; i < buf_size ; i ++ ) { \n if ( state == 7 ) { \n i += p -> h264dsp . startcode_find_candidate ( buf + i , buf_size - i ) ; \n if ( i < buf_size ) \n state = 2 ; \n } else if ( state <= 2 ) { \n if ( buf [ i ] == 1 ) \n state ^= 5 ; \n else if ( buf [ i ] ) \n state = 7 ; \n else \n state >>= 1 ; \n } else if ( state <= 5 ) { \n int nalu_type = buf [ i ] & 0x1F ; \n if ( nalu_type == NAL_SEI || nalu_type == NAL_SPS || \n nalu_type == NAL_PPS || nalu_type == NAL_AUD ) { \n if ( pc -> frame_start_found ) { \n i ++ ; \n goto found ; \n } \n } else if ( nalu_type == NAL_SLICE || nalu_type == NAL_DPA || \n nalu_type == NAL_IDR_SLICE ) { \n if ( pc -> frame_start_found ) { \n state += 8 ; \n continue ; \n } else \n pc -> frame_start_found = 1 ; \n } \n state = 7 ; \n } else { \n if ( buf [ i ] & 0x80 ) \n goto found ; \n state = 7 ; \n } \n } \n pc -> state = state ; \n return END_NOT_FOUND ; \n found : \n pc -> state = 7 ; \n pc -> frame_start_found = 0 ; \n return i - ( state & 5 ) ; \n }", "idx": 24193}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int flic_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n FlicDemuxContext * flic = ( FlicDemuxContext * ) s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n int packet_read = 0 ; \n unsigned int size ; \n int magic ; \n int ret = 0 ; \n unsigned char preamble [ FLIC_PREAMBLE_SIZE ] ; \n while ( ! packet_read ) { \n if ( ( ret = get_buffer ( pb , preamble , FLIC_PREAMBLE_SIZE ) ) != \n FLIC_PREAMBLE_SIZE ) { \n ret = AVERROR_IO ; \n break ; \n } \n size = LE_32 ( & preamble [ 0 ] ) ; \n magic = LE_16 ( & preamble [ 4 ] ) ; \n if ( ( magic == FLIC_CHUNK_MAGIC_1 ) || ( magic == FLIC_CHUNK_MAGIC_2 ) ) { \n if ( av_new_packet ( pkt , size ) ) { \n ret = AVERROR_IO ; \n break ; \n } \n pkt -> stream_index = flic -> video_stream_index ; \n pkt -> pts = flic -> pts ; \n memcpy ( pkt -> data , preamble , FLIC_PREAMBLE_SIZE ) ; \n ret = get_buffer ( pb , pkt -> data + FLIC_PREAMBLE_SIZE , \n size - FLIC_PREAMBLE_SIZE ) ; \n if ( ret != size - FLIC_PREAMBLE_SIZE ) { \n av_free_packet ( pkt ) ; \n ret = AVERROR_IO ; \n } \n flic -> pts += flic -> frame_pts_inc ; \n packet_read = 1 ; \n } else { \n url_fseek ( pb , size - 6 , SEEK_CUR ) ; \n } \n } \n return ret ; \n }", "idx": 24223}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int get_ref_idx ( AVFrame * frame ) \n { \n FrameDecodeData * fdd ; \n NVDECFrame * cf ; \n if ( ! frame || ! frame -> private_ref ) \n return -1 ; \n fdd = ( FrameDecodeData * ) frame -> private_ref -> data ; \n cf = ( NVDECFrame * ) fdd -> hwaccel_priv ; \n return cf -> idx ; \n }", "idx": 24225}
{"project": "FFmpeg", "commit_id": "a26e1d4c1f7c93d24250dd9c0786241f92fcdea4", "target": 0, "func": "static int put_packetheader ( NUTContext * nut , ByteIOContext * bc , int max_size , int calculate_checksum ) \n { \n put_flush_packet ( bc ) ; \n nut -> packet_start [ 2 ] = url_ftell ( bc ) - 8 ; \n nut -> written_packet_size = max_size ; \n if ( calculate_checksum ) \n init_checksum ( bc , update_adler32 , 0 ) ; \n put_v ( bc , nut -> written_packet_size ) ; \n return 0 ; \n }", "idx": 24228}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int avpriv_unlock_avformat ( void ) \n { \n if ( lockmgr_cb ) { \n if ( ( * lockmgr_cb ) ( & avformat_mutex , AV_LOCK_RELEASE ) ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 24232}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int build_vlc ( VLC * vlc , const uint8_t * bits_table , const uint8_t * val_table , \n int nb_codes ) \n { \n uint8_t huff_size [ 256 ] ; \n uint16_t huff_code [ 256 ] ; \n memset ( huff_size , 0 , sizeof ( huff_size ) ) ; \n build_huffman_codes ( huff_size , huff_code , bits_table , val_table ) ; \n return init_vlc ( vlc , 9 , nb_codes , huff_size , 1 , 1 , huff_code , 2 , 2 ) ; \n }", "idx": 24239}
{"project": "FFmpeg", "commit_id": "f0da370a523d76fb5f48e58537f26a9d949e9c05", "target": 1, "func": "static void display_picref ( AVFilterBufferRef * picref , AVRational time_base ) \n { \n int x , y ; \n uint8_t * p0 , * p ; \n int64_t delay ; \n if ( picref -> pts != AV_NOPTS_VALUE ) { \n if ( last_pts != AV_NOPTS_VALUE ) { \n delay = av_rescale_q ( picref -> pts - last_pts , \n time_base , AV_TIME_BASE_Q ) ; \n if ( delay > 0 && delay < 1000000 ) \n usleep ( delay ) ; \n } \n last_pts = picref -> pts ; \n } \n p0 = picref -> data [ 0 ] ; \n puts ( \" \\033 \" ) ; \n for ( y = 0 ; y < picref -> video -> h ; y ++ ) { \n p = p0 ; \n for ( x = 0 ; x < picref -> video -> w ; x ++ ) \n putchar ( \" \" [ * ( p ++ ) / 52 ] ) ; \n putchar ( ' \\n ' ) ; \n p0 += picref -> linesize [ 0 ] ; \n } \n fflush ( stdout ) ; \n }", "idx": 24242}
{"project": "FFmpeg", "commit_id": "61af627d56c785650ac3d235f6356ee3bc5676ee", "target": 0, "func": "static int create_filter ( AVFilterContext * * filt_ctx , AVFilterGraph * ctx , int index , \n const char * filt_name , const char * args , void * log_ctx ) \n { \n AVFilter * filt ; \n char inst_name [ 30 ] ; \n char tmp_args [ 256 ] ; \n int ret ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , filt_name , index ) ; \n filt = avfilter_get_by_name ( filt_name ) ; \n if ( ! filt ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name ) ; \n return AVERROR ( EINVAL ) ; \n } \n * filt_ctx = avfilter_graph_alloc_filter ( ctx , filt , inst_name ) ; \n if ( ! * filt_ctx ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( ! strcmp ( filt_name , \" \" ) && args && ! strstr ( args , \" \" ) && \n ctx -> scale_sws_opts ) { \n snprintf ( tmp_args , sizeof ( tmp_args ) , \" \" , \n args , ctx -> scale_sws_opts ) ; \n args = tmp_args ; \n } \n ret = avfilter_init_str ( * filt_ctx , args ) ; \n if ( ret < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" , filt_name ) ; \n if ( args ) \n av_log ( log_ctx , AV_LOG_ERROR , \" \" , args ) ; \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 24248}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_xvmc_init_block ( MpegEncContext * s ) \n { \n struct xvmc_pix_fmt * render = ( struct xvmc_pix_fmt * ) s -> current_picture . f -> data [ 2 ] ; \n assert ( render && render -> xvmc_id == AV_XVMC_ID ) ; \n s -> block = ( int16_t ( * ) [ 64 ] ) ( render -> data_blocks + render -> next_free_data_block_num * 64 ) ; \n }", "idx": 24250}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline void set_p_mv_tables ( MpegEncContext * s , int mx , int my ) \n { \n const int xy = s -> mb_x + 1 + ( s -> mb_y + 1 ) * ( s -> mb_width + 2 ) ; \n s -> p_mv_table [ xy ] [ 0 ] = mx ; \n s -> p_mv_table [ xy ] [ 1 ] = my ; \n if ( ! ( s -> flags & CODEC_FLAG_4MV ) ) { \n int mot_xy = s -> block_index [ 0 ] ; \n s -> motion_val [ mot_xy ] [ 0 ] = mx ; \n s -> motion_val [ mot_xy ] [ 1 ] = my ; \n s -> motion_val [ mot_xy + 1 ] [ 0 ] = mx ; \n s -> motion_val [ mot_xy + 1 ] [ 1 ] = my ; \n mot_xy += s -> block_wrap [ 0 ] ; \n s -> motion_val [ mot_xy ] [ 0 ] = mx ; \n s -> motion_val [ mot_xy ] [ 1 ] = my ; \n s -> motion_val [ mot_xy + 1 ] [ 0 ] = mx ; \n s -> motion_val [ mot_xy + 1 ] [ 1 ] = my ; \n } \n }", "idx": 24252}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int hds_flush ( AVFormatContext * s , OutputStream * os , int final , \n int64_t end_ts ) \n { \n HDSContext * c = s -> priv_data ; \n int i , ret = 0 ; \n char target_filename [ 1024 ] ; \n int index = s -> streams [ os -> first_stream ] -> id ; \n if ( ! os -> packets_written ) \n return 0 ; \n avio_flush ( os -> ctx -> pb ) ; \n os -> packets_written = 0 ; \n close_file ( os ) ; \n snprintf ( target_filename , sizeof ( target_filename ) , \n \" \" , s -> filename , index , os -> fragment_index ) ; \n ret = ff_rename ( os -> temp_filename , target_filename ) ; \n if ( ret < 0 ) \n return ret ; \n add_fragment ( os , target_filename , os -> frag_start_ts , end_ts - os -> frag_start_ts ) ; \n if ( ! final ) { \n ret = init_file ( s , os , end_ts ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( c -> window_size || ( final && c -> remove_at_exit ) ) { \n int remove = os -> nb_fragments - c -> window_size - c -> extra_window_size ; \n if ( final && c -> remove_at_exit ) \n remove = os -> nb_fragments ; \n if ( remove > 0 ) { \n for ( i = 0 ; i < remove ; i ++ ) { \n unlink ( os -> fragments [ i ] -> file ) ; \n av_free ( os -> fragments [ i ] ) ; \n } \n os -> nb_fragments -= remove ; \n memmove ( os -> fragments , os -> fragments + remove , \n os -> nb_fragments * sizeof ( * os -> fragments ) ) ; \n } \n } \n if ( ret >= 0 ) \n ret = write_abst ( s , os , final ) ; \n return ret ; \n }", "idx": 24253}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yuy2ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm2 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( long ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i ] ; \n #endif \n }", "idx": 24256}
{"project": "FFmpeg", "commit_id": "a1684cf82d1aa35de0ae97724477501f92395c2b", "target": 1, "func": "av_cold void ff_msmpeg4_encode_init ( MpegEncContext * s ) \n { \n static int init_done = 0 ; \n int i ; \n common_init ( s ) ; \n if ( s -> msmpeg4_version >= 4 ) { \n s -> min_qcoeff = -255 ; \n s -> max_qcoeff = 255 ; \n } \n if ( ! init_done ) { \n init_done = 1 ; \n init_mv_table ( & mv_tables [ 0 ] ) ; \n init_mv_table ( & mv_tables [ 1 ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) \n init_rl ( & rl_table [ i ] , static_rl_table_store [ i ] ) ; \n for ( i = 0 ; i < NB_RL_TABLES ; i ++ ) { \n int level ; \n for ( level = 0 ; level <= MAX_LEVEL ; level ++ ) { \n int run ; \n for ( run = 0 ; run <= MAX_RUN ; run ++ ) { \n int last ; \n for ( last = 0 ; last < 2 ; last ++ ) { \n rl_length [ i ] [ level ] [ run ] [ last ] = get_size_of_code ( s , & rl_table [ i ] , last , run , level , 0 ) ; \n } \n } \n } \n } \n } \n }", "idx": 24258}
{"project": "FFmpeg", "commit_id": "5f928c5201c077b9765610bc5304235c3f1d9bd6", "target": 1, "func": "av_cold void ff_init_range_decoder ( RangeCoder * c , const uint8_t * buf , \n int buf_size ) \n { \n ff_init_range_encoder ( c , ( uint8_t * ) buf , buf_size ) ; \n c -> low = AV_RB16 ( c -> bytestream ) ; \n c -> bytestream += 2 ; ", "idx": 24259}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int open_in ( HLSContext * c , AVIOContext * * in , const char * url ) \n { \n AVDictionary * tmp = NULL ; \n int ret ; \n av_dict_copy ( & tmp , c -> avio_opts , 0 ) ; \n ret = avio_open2 ( in , url , AVIO_FLAG_READ , c -> interrupt_callback , & tmp ) ; \n av_dict_free ( & tmp ) ; \n return ret ; \n }", "idx": 24266}
{"project": "FFmpeg", "commit_id": "af165acefacd89196c003c24802fa3c494d54d3a", "target": 0, "func": "static int mov_write_trak_tag ( AVIOContext * pb , MOVMuxContext * mov , \n MOVTrack * track , AVStream * st ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n mov_write_tkhd_tag ( pb , track , st ) ; \n if ( supports_edts ( mov ) ) \n mov_write_edts_tag ( pb , track ) ; \n if ( track -> tref_tag ) \n mov_write_tref_tag ( pb , track ) ; \n mov_write_mdia_tag ( pb , track ) ; \n if ( track -> mode == MODE_PSP ) \n mov_write_uuid_tag_psp ( pb , track ) ; \n if ( track -> tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n mov_write_udta_sdp ( pb , track ) ; \n if ( track -> mode == MODE_MOV ) { \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) { \n double sample_aspect_ratio = av_q2d ( st -> sample_aspect_ratio ) ; \n if ( st -> sample_aspect_ratio . num && 1.0 != sample_aspect_ratio ) { \n mov_write_tapt_tag ( pb , track ) ; \n } \n } \n if ( is_clcp_track ( track ) ) { \n mov_write_tapt_tag ( pb , track ) ; \n } \n } \n return update_size ( pb , pos ) ; \n }", "idx": 24267}
{"project": "FFmpeg", "commit_id": "499c2d41d75fdadbf65daa9eaf743f61632f14f8", "target": 0, "func": "static int mpeg4_decode_gop_header ( MpegEncContext * s , GetBitContext * gb ) { \n int hours , minutes , seconds ; \n if ( ! show_bits ( gb , 18 ) ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return -1 ; \n } \n hours = get_bits ( gb , 5 ) ; \n minutes = get_bits ( gb , 6 ) ; \n skip_bits1 ( gb ) ; \n seconds = get_bits ( gb , 6 ) ; \n s -> time_base = seconds + 60 * ( minutes + 60 * hours ) ; \n skip_bits1 ( gb ) ; \n skip_bits1 ( gb ) ; \n return 0 ; \n }", "idx": 24270}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_vlcs ( ASV1Context * a ) { \n static int done = 0 ; \n if ( ! done ) { \n done = 1 ; \n init_vlc ( & ccp_vlc , VLC_BITS , 17 , \n & ccp_tab [ 0 ] [ 1 ] , 2 , 1 , \n & ccp_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & dc_ccp_vlc , VLC_BITS , 8 , \n & dc_ccp_tab [ 0 ] [ 1 ] , 2 , 1 , \n & dc_ccp_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & ac_ccp_vlc , VLC_BITS , 16 , \n & ac_ccp_tab [ 0 ] [ 1 ] , 2 , 1 , \n & ac_ccp_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & level_vlc , VLC_BITS , 7 , \n & level_tab [ 0 ] [ 1 ] , 2 , 1 , \n & level_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & asv2_level_vlc , ASV2_LEVEL_VLC_BITS , 63 , \n & asv2_level_tab [ 0 ] [ 1 ] , 2 , 1 , \n & asv2_level_tab [ 0 ] [ 0 ] , 2 , 1 ) ; \n } \n }", "idx": 24271}
{"project": "FFmpeg", "commit_id": "1ca87d600bc069fe4cf497c410b4f794e88a122d", "target": 1, "func": "static int applehttp_close ( URLContext * h ) \n { \n AppleHTTPContext * s = h -> priv_data ; \n free_segment_list ( s ) ; \n free_variant_list ( s ) ; \n ffurl_close ( s -> seg_hd ) ; \n av_free ( s ) ; \n return 0 ; \n }", "idx": 24272}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_v_loop_filter_luma_intra_c ( uint8_t * pix , int stride , int alpha , int beta ) \n { \n h264_loop_filter_luma_intra_c ( pix , stride , 1 , alpha , beta ) ; \n }", "idx": 24277}
{"project": "FFmpeg", "commit_id": "3faa303a47e0c3b59a53988e0f76018930c6cb1a", "target": 0, "func": "static inline void decode_subblock3 ( DCTELEM * dst , int code , const int is_block2 , GetBitContext * gb , VLC * vlc , \n int q_dc , int q_ac1 , int q_ac2 ) \n { \n int coeffs [ 4 ] ; \n coeffs [ 0 ] = modulo_three_table [ code ] [ 0 ] ; \n coeffs [ 1 ] = modulo_three_table [ code ] [ 1 ] ; \n coeffs [ 2 ] = modulo_three_table [ code ] [ 2 ] ; \n coeffs [ 3 ] = modulo_three_table [ code ] [ 3 ] ; \n decode_coeff ( dst , coeffs [ 0 ] , 3 , gb , vlc , q_dc ) ; \n if ( is_block2 ) { \n decode_coeff ( dst + 8 , coeffs [ 1 ] , 2 , gb , vlc , q_ac1 ) ; \n decode_coeff ( dst + 1 , coeffs [ 2 ] , 2 , gb , vlc , q_ac1 ) ; \n } else { \n decode_coeff ( dst + 1 , coeffs [ 1 ] , 2 , gb , vlc , q_ac1 ) ; \n decode_coeff ( dst + 8 , coeffs [ 2 ] , 2 , gb , vlc , q_ac1 ) ; \n } \n decode_coeff ( dst + 9 , coeffs [ 3 ] , 2 , gb , vlc , q_ac2 ) ; \n }", "idx": 24284}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int mm_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < MM_PREAMBLE_SIZE ) \n return 0 ; \n if ( AV_RL16 ( & p -> buf [ 0 ] ) != MM_TYPE_HEADER ) \n return 0 ; \n if ( AV_RL32 ( & p -> buf [ 2 ] ) != MM_HEADER_LEN_V && AV_RL32 ( & p -> buf [ 2 ] ) != MM_HEADER_LEN_AV ) \n return 0 ; \n return AVPROBE_SCORE_MAX / 2 ; \n }", "idx": 24286}
{"project": "FFmpeg", "commit_id": "403ee835e7913eb9536b22c2b22edfdd700166a9", "target": 0, "func": "static int tcp_write_packet ( AVFormatContext * s , RTSPStream * rtsp_st ) \n { \n RTSPState * rt = s -> priv_data ; \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n uint8_t * buf , * ptr ; \n int size ; \n uint8_t * interleave_header , * interleaved_packet ; \n size = avio_close_dyn_buf ( rtpctx -> pb , & buf ) ; \n ptr = buf ; \n while ( size > 4 ) { \n uint32_t packet_len = AV_RB32 ( ptr ) ; \n int id ; \n interleaved_packet = interleave_header = ptr ; \n ptr += 4 ; \n size -= 4 ; \n if ( packet_len > size || packet_len < 2 ) \n break ; \n if ( ptr [ 1 ] >= RTCP_SR && ptr [ 1 ] <= RTCP_APP ) \n id = rtsp_st -> interleaved_max ; \n else \n id = rtsp_st -> interleaved_min ; \n interleave_header [ 0 ] = ' ' ; \n interleave_header [ 1 ] = id ; \n AV_WB16 ( interleave_header + 2 , packet_len ) ; \n url_write ( rt -> rtsp_hd_out , interleaved_packet , 4 + packet_len ) ; \n ptr += packet_len ; \n size -= packet_len ; \n } \n av_free ( buf ) ; \n url_open_dyn_packet_buf ( & rtpctx -> pb , RTSP_TCP_MAX_PACKET_SIZE ) ; \n return 0 ; \n }", "idx": 24287}
{"project": "FFmpeg", "commit_id": "1509c018bd5b054a2354e20021ccbac9c934d213", "target": 1, "func": "static int get_packet_size ( const uint8_t * buf , int size ) \n { \n int score , fec_score , dvhs_score ; \n if ( size < ( TS_FEC_PACKET_SIZE * 5 + 1 ) ) \n return AVERROR_INVALIDDATA ; \n score = analyze ( buf , size , TS_PACKET_SIZE , NULL ) ; \n dvhs_score = analyze ( buf , size , TS_DVHS_PACKET_SIZE , NULL ) ; \n fec_score = analyze ( buf , size , TS_FEC_PACKET_SIZE , NULL ) ; \n av_dlog ( NULL , \" \\n \" , \n score , dvhs_score , fec_score ) ; \n if ( score > fec_score && score > dvhs_score ) \n return TS_PACKET_SIZE ; \n else if ( dvhs_score > score && dvhs_score > fec_score ) \n return TS_DVHS_PACKET_SIZE ; \n else if ( score < fec_score && dvhs_score < fec_score ) \n return TS_FEC_PACKET_SIZE ; \n else \n return AVERROR_INVALIDDATA ; \n }", "idx": 24295}
{"project": "FFmpeg", "commit_id": "faaec4676cb4c7a2303d50df66c6290bc96a7657", "target": 1, "func": "static void matroska_execute_seekhead ( MatroskaDemuxContext * matroska ) \n { \n EbmlList * seekhead_list = & matroska -> seekhead ; \n MatroskaSeekhead * seekhead = seekhead_list -> elem ; \n int64_t before_pos = avio_tell ( matroska -> ctx -> pb ) ; \n int i ; \n if ( ! matroska -> ctx -> pb -> seekable || \n ( matroska -> ctx -> flags & AVFMT_FLAG_IGNIDX ) ) \n return ; \n for ( i = 0 ; i < seekhead_list -> nb_elem ; i ++ ) { \n if ( seekhead [ i ] . pos <= before_pos ) \n continue ; \n if ( seekhead [ i ] . id == MATROSKA_ID_CUES ) { \n matroska -> cues_parsing_deferred = 1 ; \n continue ; \n } \n if ( matroska_parse_seekhead_entry ( matroska , i ) < 0 ) \n break ; \n } \n }", "idx": 24296}
{"project": "FFmpeg", "commit_id": "61cd19b8bc32185c8caf64d89d1b0909877a0707", "target": 1, "func": "static void load_cursor ( VmncContext * c , const uint8_t * src ) \n { \n int i , j , p ; \n const int bpp = c -> bpp2 ; \n uint8_t * dst8 = c -> curbits ; \n uint16_t * dst16 = ( uint16_t * ) c -> curbits ; \n uint32_t * dst32 = ( uint32_t * ) c -> curbits ; \n for ( j = 0 ; j < c -> cur_h ; j ++ ) { \n for ( i = 0 ; i < c -> cur_w ; i ++ ) { \n p = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; \n src += bpp ; \n if ( bpp == 1 ) \n * dst8 ++ = p ; \n if ( bpp == 2 ) \n * dst16 ++ = p ; \n if ( bpp == 4 ) \n * dst32 ++ = p ; \n } \n } \n dst8 = c -> curmask ; \n dst16 = ( uint16_t * ) c -> curmask ; \n dst32 = ( uint32_t * ) c -> curmask ; \n for ( j = 0 ; j < c -> cur_h ; j ++ ) { \n for ( i = 0 ; i < c -> cur_w ; i ++ ) { \n p = vmnc_get_pixel ( src , bpp , c -> bigendian ) ; \n src += bpp ; \n if ( bpp == 1 ) \n * dst8 ++ = p ; \n if ( bpp == 2 ) \n * dst16 ++ = p ; \n if ( bpp == 4 ) \n * dst32 ++ = p ; \n } \n } \n }", "idx": 24299}
{"project": "FFmpeg", "commit_id": "570745cc5114ea13d0054f73776533f5e6e538f8", "target": 0, "func": "AVChapter * ff_new_chapter ( AVFormatContext * s , int id , AVRational time_base , int64_t start , int64_t end , const char * title ) \n { \n AVChapter * chapter = NULL ; \n int i ; \n for ( i = 0 ; i < s -> nb_chapters ; i ++ ) \n if ( s -> chapters [ i ] -> id == id ) \n chapter = s -> chapters [ i ] ; \n if ( ! chapter ) { \n chapter = av_mallocz ( sizeof ( AVChapter ) ) ; \n if ( ! chapter ) \n return NULL ; \n dynarray_add ( & s -> chapters , & s -> nb_chapters , chapter ) ; \n } \n if ( chapter -> title ) \n av_free ( chapter -> title ) ; \n chapter -> title = av_strdup ( title ) ; \n chapter -> id = id ; \n chapter -> time_base = time_base ; \n chapter -> start = start ; \n chapter -> end = end ; \n return chapter ; \n }", "idx": 24316}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "void show_banner ( void ) \n { \n fprintf ( stderr , \" \" FFMPEG_VERSION \" \\n \" , \n program_name , program_birth_year , this_year ) ; \n fprintf ( stderr , \" \\n \" , \n __DATE__ , __TIME__ , CC_TYPE , CC_VERSION ) ; \n fprintf ( stderr , \" \" FFMPEG_CONFIGURATION \" \\n \" ) ; \n print_all_libs_info ( stderr , INDENT | SHOW_CONFIG ) ; \n print_all_libs_info ( stderr , INDENT | SHOW_VERSION ) ; \n }", "idx": 24341}
{"project": "FFmpeg", "commit_id": "d1923d15a3544cbb94563a59e7169291db76b312", "target": 1, "func": "static int idcin_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n IdcinDemuxContext * idcin = s -> priv_data ; \n if ( idcin -> first_pkt_pos > 0 ) { \n int ret = avio_seek ( s -> pb , idcin -> first_pkt_pos , SEEK_SET ) ; \n if ( ret < 0 ) \n return ret ; \n ff_update_cur_dts ( s , s -> streams [ idcin -> video_stream_index ] , 0 ) ; \n idcin -> next_chunk_is_video = 1 ; \n idcin -> current_audio_chunk = 0 ; \n return 0 ; \n } \n return -1 ; \n }", "idx": 24358}
{"project": "FFmpeg", "commit_id": "1189af429211ac650aac730368a6cf5b23756605", "target": 1, "func": "static int output_frame ( H264Context * h , AVFrame * dst , H264Picture * srcp ) \n { \n AVFrame * src = srcp -> f ; \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( src -> format ) ; \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n av_dict_set ( & dst -> metadata , \" \" , ff_h264_sei_stereo_mode ( h ) , 0 ) ; \n if ( srcp -> sei_recovery_frame_cnt == 0 ) \n dst -> key_frame = 1 ; \n if ( ! srcp -> crop ) \n return 0 ; \n for ( i = 0 ; i < desc -> nb_components ; i ++ ) { \n int hshift = ( i > 0 ) ? desc -> log2_chroma_w : 0 ; \n int vshift = ( i > 0 ) ? desc -> log2_chroma_h : 0 ; \n int off = ( ( srcp -> crop_left >> hshift ) << h -> pixel_shift ) + \n ( srcp -> crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 24360}
{"project": "FFmpeg", "commit_id": "ae2d41ec875965ce4ab9fdd88a5e8ba57cada67a", "target": 0, "func": "void ff_init_elbg ( int * points , int dim , int numpoints , int * codebook , \n int numCB , int max_steps , int * closest_cb , \n AVLFG * rand_state ) \n { \n int i , k ; \n if ( numpoints > 24 * numCB ) { \n int * temp_points = av_malloc ( dim * ( numpoints / 8 ) * sizeof ( int ) ) ; \n for ( i = 0 ; i < numpoints / 8 ; i ++ ) { \n k = ( i * BIG_PRIME ) % numpoints ; \n memcpy ( temp_points + i * dim , points + k * dim , dim * sizeof ( int ) ) ; \n } \n ff_init_elbg ( temp_points , dim , numpoints / 8 , codebook , numCB , 2 * max_steps , closest_cb , rand_state ) ; \n ff_do_elbg ( temp_points , dim , numpoints / 8 , codebook , numCB , 2 * max_steps , closest_cb , rand_state ) ; \n av_free ( temp_points ) ; \n } else \n for ( i = 0 ; i < numCB ; i ++ ) \n memcpy ( codebook + i * dim , points + ( ( i * BIG_PRIME ) % numpoints ) * dim , \n dim * sizeof ( int ) ) ; \n }", "idx": 24369}
{"project": "FFmpeg", "commit_id": "7fb758cd8ed08e4a37f10e25003953d13c68b8cd", "target": 0, "func": "av_cold void ff_lpc_init_x86 ( LPCContext * c ) \n { \n #if HAVE_SSE2_INLINE  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( INLINE_SSE2 ( cpu_flags ) && ( cpu_flags & AV_CPU_FLAG_SSE2SLOW ) ) { \n c -> lpc_apply_welch_window = lpc_apply_welch_window_sse2 ; \n c -> lpc_compute_autocorr = lpc_compute_autocorr_sse2 ; \n } \n #endif \n }", "idx": 24370}
{"project": "FFmpeg", "commit_id": "4d09bc98974d4602d71e71520535457a53d44222", "target": 0, "func": "int ff_pcm_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size ; \n size = RAW_SAMPLES * s -> streams [ 0 ] -> codec -> block_align ; \n if ( size <= 0 ) \n return AVERROR ( EINVAL ) ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n pkt -> flags &= ~ AV_PKT_FLAG_CORRUPT ; \n pkt -> stream_index = 0 ; \n if ( ret < 0 ) \n return ret ; \n return ret ; \n }", "idx": 24372}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static int decode_cabac_mb_skip ( H264Context * h , int mb_x , int mb_y ) { \n MpegEncContext * const s = & h -> s ; \n int mba_xy , mbb_xy ; \n int ctx = 0 ; \n if ( FRAME_MBAFF ) { \n int mb_xy = mb_x + ( mb_y & ~ 1 ) * s -> mb_stride ; \n mba_xy = mb_xy - 1 ; \n if ( ( mb_y & 1 ) \n && h -> slice_table [ mba_xy ] == h -> slice_num \n && MB_FIELD == ! ! IS_INTERLACED ( s -> current_picture . mb_type [ mba_xy ] ) ) \n mba_xy += s -> mb_stride ; \n if ( MB_FIELD ) { \n mbb_xy = mb_xy - s -> mb_stride ; \n if ( ! ( mb_y & 1 ) \n && h -> slice_table [ mbb_xy ] == h -> slice_num \n && IS_INTERLACED ( s -> current_picture . mb_type [ mbb_xy ] ) ) \n mbb_xy -= s -> mb_stride ; \n } else \n mbb_xy = mb_x + ( mb_y - 1 ) * s -> mb_stride ; \n } else { \n int mb_xy = mb_x + mb_y * s -> mb_stride ; \n mba_xy = mb_xy - 1 ; \n mbb_xy = mb_xy - s -> mb_stride ; \n } \n if ( h -> slice_table [ mba_xy ] == h -> slice_num && ! IS_SKIP ( s -> current_picture . mb_type [ mba_xy ] ) ) \n ctx ++ ; \n if ( h -> slice_table [ mbb_xy ] == h -> slice_num && ! IS_SKIP ( s -> current_picture . mb_type [ mbb_xy ] ) ) \n ctx ++ ; \n if ( h -> slice_type == B_TYPE ) \n ctx += 13 ; \n return get_cabac ( & h -> cabac , & h -> cabac_state [ 11 + ctx ] ) ; \n }", "idx": 24373}
{"project": "FFmpeg", "commit_id": "ec23a47286a9be0ca67b78f4d8b9d87220c18286", "target": 0, "func": "static int handle_packets ( AVFormatContext * s , int nb_packets ) \n { \n MpegTSContext * ts = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n uint8_t packet [ TS_FEC_PACKET_SIZE ] ; \n int packet_num , len ; \n ts -> stop_parse = 0 ; \n packet_num = 0 ; \n for ( ; ; ) { \n if ( ts -> stop_parse ) \n break ; \n packet_num ++ ; \n if ( nb_packets != 0 && packet_num >= nb_packets ) \n break ; \n len = get_buffer ( pb , packet , ts -> raw_packet_size ) ; \n if ( len != ts -> raw_packet_size ) \n return AVERROR_IO ; \n if ( packet [ 0 ] != 0x47 ) \n return AVERROR_INVALIDDATA ; \n handle_packet ( s , packet ) ; \n } \n return 0 ; \n }", "idx": 24374}
{"project": "FFmpeg", "commit_id": "b315a3cf42a15358ab38279723f3c93406a66f6a", "target": 1, "func": "static SoftFloat sbr_sum_square_c ( int ( * x ) [ 2 ] , int n ) \n { \n SoftFloat ret ; \n uint64_t accu = 0 , round ; \n int i , nz ; \n unsigned u ; \n for ( i = 0 ; i < n ; i += 2 ) { \n av_assert2 ( FFABS ( x [ i + 0 ] [ 0 ] ) >> 29 == 0 ) ; \n accu += ( int64_t ) x [ i + 0 ] [ 0 ] * x [ i + 0 ] [ 0 ] ; \n av_assert2 ( FFABS ( x [ i + 0 ] [ 1 ] ) >> 29 == 0 ) ; \n accu += ( int64_t ) x [ i + 0 ] [ 1 ] * x [ i + 0 ] [ 1 ] ; \n av_assert2 ( FFABS ( x [ i + 1 ] [ 0 ] ) >> 29 == 0 ) ; \n accu += ( int64_t ) x [ i + 1 ] [ 0 ] * x [ i + 1 ] [ 0 ] ; \n av_assert2 ( FFABS ( x [ i + 1 ] [ 1 ] ) >> 29 == 0 ) ; \n accu += ( int64_t ) x [ i + 1 ] [ 1 ] * x [ i + 1 ] [ 1 ] ; \n } \n u = accu >> 32 ; \n if ( u == 0 ) { \n nz = 1 ; \n } else { \n nz = -1 ; \n while ( u < 0x80000000U ) { \n u <<= 1 ; \n nz ++ ; \n } \n nz = 32 - nz ; \n } \n round = 1ULL << ( nz - 1 ) ; \n u = ( ( accu + round ) >> nz ) ; \n u >>= 1 ; \n ret = av_int2sf ( u , 15 - nz ) ; \n return ret ; \n }", "idx": 24380}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static uint64_t getSSD ( uint8_t * src1 , uint8_t * src2 , int stride1 , int stride2 , int w , int h ) { \n int x , y ; \n uint64_t ssd = 0 ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n int d = src1 [ x + y * stride1 ] - src2 [ x + y * stride2 ] ; \n ssd += d * d ; \n } \n } \n return ssd ; \n }", "idx": 24391}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int standard_decode_i_mbs ( VC9Context * v ) \n { \n int x , y , ac_pred , cbpcy ; \n if ( v -> pq < 5 ) v -> ttmb_vlc = & vc9_ttmb_vlc [ 0 ] ; \n else if ( v -> pq < 13 ) v -> ttmb_vlc = & vc9_ttmb_vlc [ 1 ] ; \n else v -> ttmb_vlc = & vc9_ttmb_vlc [ 2 ] ; \n for ( y = 0 ; y < v -> height_mb ; y ++ ) \n { \n for ( x = 0 ; x < v -> width_mb ; x ++ ) \n { \n cbpcy = get_vlc2 ( & v -> gb , vc9_cbpcy_i_vlc . table , \n VC9_CBPCY_I_VLC_BITS , 2 ) ; \n ac_pred = get_bits ( & v -> gb , 1 ) ; \n } \n } \n return 0 ; \n }", "idx": 24395}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_dc_add_mmx2 ( uint8_t * dst , int16_t * block , int stride ) \n { \n int dc = ( block [ 0 ] + 32 ) >> 6 ; \n int y ; \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( dc ) \n ) ; \n for ( y = 2 ; y -- ; dst += 4 * stride ) { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n : \" + m \" \n \" + m \" \n \" + m \" \n \" + m \" \n ) ; \n } \n }", "idx": 24396}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void rv34_idct_add_c ( uint8_t * dst , ptrdiff_t stride , DCTELEM * block ) { \n int temp [ 16 ] ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i ; \n rv34_row_transform ( temp , block ) ; \n memset ( block , 0 , 16 * sizeof ( DCTELEM ) ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = 13 * ( temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ) + 0x200 ; \n const int z1 = 13 * ( temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ) + 0x200 ; \n const int z2 = 7 * temp [ 4 * 1 + i ] - 17 * temp [ 4 * 3 + i ] ; \n const int z3 = 17 * temp [ 4 * 1 + i ] + 7 * temp [ 4 * 3 + i ] ; \n dst [ 0 ] = cm [ dst [ 0 ] + ( ( z0 + z3 ) >> 10 ) ] ; \n dst [ 1 ] = cm [ dst [ 1 ] + ( ( z1 + z2 ) >> 10 ) ] ; \n dst [ 2 ] = cm [ dst [ 2 ] + ( ( z1 - z2 ) >> 10 ) ] ; \n dst [ 3 ] = cm [ dst [ 3 ] + ( ( z0 - z3 ) >> 10 ) ] ; \n dst += stride ; \n } \n }", "idx": 24413}
{"project": "FFmpeg", "commit_id": "835d9f299cf6b3704989a7b3eccfa1c2ec6866d9", "target": 1, "func": "av_cold void ff_cavsdsp_init_x86 ( CAVSDSPContext * c , AVCodecContext * avctx ) \n { \n av_unused int cpu_flags = av_get_cpu_flags ( ) ; \n cavsdsp_init_mmx ( c , avctx ) ; \n #if HAVE_AMD3DNOW_INLINE  \n  \n  if ( INLINE_AMD3DNOW ( cpu_flags ) ) \n cavsdsp_init_3dnow ( c , avctx ) ; \n #endif \n #if HAVE_MMXEXT_INLINE  \n  \n  if ( INLINE_MMXEXT ( cpu_flags ) ) { \n DSPFUNC ( put , 0 , 16 , mmxext ) ; \n DSPFUNC ( put , 1 , 8 , mmxext ) ; \n DSPFUNC ( avg , 0 , 16 , mmxext ) ; \n DSPFUNC ( avg , 1 , 8 , mmxext ) ; \n } \n #endif \n #if HAVE_MMX_EXTERNAL  \n  \n  if ( EXTERNAL_MMXEXT ( cpu_flags ) ) { \n c -> avg_cavs_qpel_pixels_tab [ 0 ] [ 0 ] = avg_cavs_qpel16_mc00_mmxext ; \n c -> avg_cavs_qpel_pixels_tab [ 1 ] [ 0 ] = avg_cavs_qpel8_mc00_mmxext ; \n } \n #endif \n #if HAVE_SSE2_EXTERNAL  \n  \n  if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n c -> put_cavs_qpel_pixels_tab [ 0 ] [ 0 ] = put_cavs_qpel16_mc00_sse2 ; \n c -> avg_cavs_qpel_pixels_tab [ 0 ] [ 0 ] = avg_cavs_qpel16_mc00_sse2 ; \n } \n #endif \n }", "idx": 24416}
{"project": "FFmpeg", "commit_id": "b16830840eb9bdec88fce2aebb38a582e093ab6b", "target": 0, "func": "static int add_string_metadata ( int count , const char * name , \n TiffContext * s ) \n { \n char * value ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count ) \n return AVERROR_INVALIDDATA ; \n value = av_malloc ( count + 1 ) ; \n if ( ! value ) \n return AVERROR ( ENOMEM ) ; \n bytestream2_get_bufferu ( & s -> gb , value , count ) ; \n value [ count ] = 0 ; \n av_dict_set ( & s -> picture . metadata , name , value , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 24427}
{"project": "FFmpeg", "commit_id": "1eaae7abb8f208fefb4e8b9e983e61b2499206a3", "target": 0, "func": "static av_cold int wmv2_decode_init ( AVCodecContext * avctx ) \n { \n Wmv2Context * const w = avctx -> priv_data ; \n int ret ; \n if ( ( ret = ff_msmpeg4_decode_init ( avctx ) ) < 0 ) \n return ret ; \n ff_wmv2_common_init ( w ) ; \n return ff_intrax8_common_init ( & w -> x8 , & w -> s . idsp , & w -> s ) ; \n }", "idx": 24432}
{"project": "FFmpeg", "commit_id": "c8dcff0cdb17d0aa03ac729eba12d1a20f1f59c8", "target": 0, "func": "static int h264_init_context ( AVCodecContext * avctx , H264Context * h ) \n { \n int i ; \n h -> avctx = avctx ; \n h -> picture_structure = PICT_FRAME ; \n h -> slice_context_count = 1 ; \n h -> workaround_bugs = avctx -> workaround_bugs ; \n h -> flags = avctx -> flags ; \n h -> prev_poc_msb = 1 << 16 ; \n h -> x264_build = -1 ; \n h -> recovery_frame = -1 ; \n h -> frame_recovered = 0 ; \n h -> next_outputed_poc = INT_MIN ; \n for ( i = 0 ; i < MAX_DELAYED_PIC_COUNT ; i ++ ) \n h -> last_pocs [ i ] = INT_MIN ; \n ff_h264_reset_sei ( h ) ; \n avctx -> chroma_sample_location = AVCHROMA_LOC_LEFT ; \n h -> nb_slice_ctx = ( avctx -> active_thread_type & FF_THREAD_SLICE ) ? H264_MAX_THREADS : 1 ; \n h -> slice_ctx = av_mallocz_array ( h -> nb_slice_ctx , sizeof ( * h -> slice_ctx ) ) ; \n if ( ! h -> slice_ctx ) { \n h -> nb_slice_ctx = 0 ; \n return AVERROR ( ENOMEM ) ; \n } \n for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) { \n h -> DPB [ i ] . f = av_frame_alloc ( ) ; \n if ( ! h -> DPB [ i ] . f ) \n return AVERROR ( ENOMEM ) ; \n } \n h -> cur_pic . f = av_frame_alloc ( ) ; \n if ( ! h -> cur_pic . f ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < h -> nb_slice_ctx ; i ++ ) \n h -> slice_ctx [ i ] . h264 = h ; \n return 0 ; \n }", "idx": 24435}
{"project": "FFmpeg", "commit_id": "7f4ec4364bc4a73036660c1c6a3c4801db524e9e", "target": 0, "func": "int ff_replaygain_export_raw ( AVStream * st , int32_t tg , uint32_t tp , \n int32_t ag , uint32_t ap ) \n { \n AVReplayGain * replaygain ; \n if ( tg == INT32_MIN && ag == INT32_MIN ) \n return 0 ; \n replaygain = ( AVReplayGain * ) ff_stream_new_side_data ( st , AV_PKT_DATA_REPLAYGAIN , \n sizeof ( * replaygain ) ) ; \n if ( ! replaygain ) \n return AVERROR ( ENOMEM ) ; \n replaygain -> track_gain = tg ; \n replaygain -> track_peak = tp ; \n replaygain -> album_gain = ag ; \n replaygain -> album_peak = ap ; \n return 0 ; \n }", "idx": 24454}
{"project": "FFmpeg", "commit_id": "0382c94f13b4b20456b7259e90b170dc020419b8", "target": 1, "func": "static int check_tag ( AVIOContext * s , int offset , unsigned int len ) \n { \n char tag [ 4 ] ; \n if ( len > 4 || \n avio_seek ( s , offset , SEEK_SET ) < 0 || \n avio_read ( s , tag , len ) < len ) \n return -1 ; \n else if ( ! AV_RB32 ( tag ) || is_tag ( tag , len ) ) \n return 1 ; \n return 0 ; \n }", "idx": 24460}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int rm_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 32 ) \n return 0 ; \n if ( ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' && \n p -> buf [ 4 ] == 0 && p -> buf [ 5 ] == 0 ) || \n ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == 0xfd ) ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 24464}
{"project": "FFmpeg", "commit_id": "69c1fe7c9c9bc85eebfc02c6a19caf7e88cd74ff", "target": 0, "func": "static int ass_get_duration ( const uint8_t * p ) \n { \n int sh , sm , ss , sc , eh , em , es , ec ; \n uint64_t start , end ; \n if ( sscanf ( p , \" \" , \n & sh , & sm , & ss , & sc , & eh , & em , & es , & ec ) != 8 ) \n return 0 ; \n start = 3600000 * sh + 60000 * sm + 1000 * ss + 10 * sc ; \n end = 3600000 * eh + 60000 * em + 1000 * es + 10 * ec ; \n return end - start ; \n }", "idx": 24468}
{"project": "FFmpeg", "commit_id": "07728a111583be6865b7ce2adea705af9d207588", "target": 1, "func": "static int decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n BinkAudioContext * s = avctx -> priv_data ; \n AVFrame * frame = data ; \n GetBitContext * gb = & s -> gb ; \n int ret , consumed = 0 ; \n if ( ! get_bits_left ( gb ) ) { \n uint8_t * buf ; \n if ( ! avpkt -> size ) { \n * got_frame_ptr = 0 ; \n return 0 ; \n } \n if ( avpkt -> size < 4 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n buf = av_realloc ( s -> packet_buffer , avpkt -> size + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n s -> packet_buffer = buf ; \n memcpy ( s -> packet_buffer , avpkt -> data , avpkt -> size ) ; \n if ( ( ret = init_get_bits8 ( gb , s -> packet_buffer , avpkt -> size ) ) < 0 ) \n return ret ; \n consumed = avpkt -> size ; \n skip_bits_long ( gb , 32 ) ; \n } \n frame -> nb_samples = s -> frame_len ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n return ret ; \n if ( decode_block ( s , ( float * * ) frame -> extended_data , \n avctx -> codec -> id == AV_CODEC_ID_BINKAUDIO_DCT ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n get_bits_align32 ( gb ) ; \n frame -> nb_samples = s -> block_size / avctx -> channels ; \n * got_frame_ptr = 1 ; \n return consumed ; \n }", "idx": 24475}
{"project": "FFmpeg", "commit_id": "5806e8cd1f60c67d936fa44dd4421428489503f5", "target": 0, "func": "static int decode_cabac_intra_mb_type ( H264Context * h , int ctx_base , int intra_slice ) { \n uint8_t * state = & h -> cabac_state [ ctx_base ] ; \n int mb_type ; \n if ( intra_slice ) { \n MpegEncContext * const s = & h -> s ; \n const int mba_xy = h -> left_mb_xy [ 0 ] ; \n const int mbb_xy = h -> top_mb_xy ; \n int ctx = 0 ; \n if ( h -> slice_table [ mba_xy ] == h -> slice_num && ! IS_INTRA4x4 ( s -> current_picture . mb_type [ mba_xy ] ) ) \n ctx ++ ; \n if ( h -> slice_table [ mbb_xy ] == h -> slice_num && ! IS_INTRA4x4 ( s -> current_picture . mb_type [ mbb_xy ] ) ) \n ctx ++ ; \n if ( get_cabac_noinline ( & h -> cabac , & state [ ctx ] ) == 0 ) \n return 0 ; \n state += 2 ; \n } else { \n if ( get_cabac_noinline ( & h -> cabac , state ) == 0 ) \n return 0 ; \n } \n if ( get_cabac_terminate ( & h -> cabac ) ) \n return 25 ; \n mb_type = 1 ; \n mb_type += 12 * get_cabac_noinline ( & h -> cabac , & state [ 1 ] ) ; \n if ( get_cabac_noinline ( & h -> cabac , & state [ 2 ] ) ) \n mb_type += 4 + 4 * get_cabac_noinline ( & h -> cabac , & state [ 2 + intra_slice ] ) ; \n mb_type += 2 * get_cabac_noinline ( & h -> cabac , & state [ 3 + intra_slice ] ) ; \n mb_type += 1 * get_cabac_noinline ( & h -> cabac , & state [ 3 + 2 * intra_slice ] ) ; \n return mb_type ; \n }", "idx": 24476}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel8_mc12_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_and_aver_dst_8w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 8 , 0 ) ; \n }", "idx": 24479}
{"project": "FFmpeg", "commit_id": "f6e1c96730ebbcebbd0341329d51d3d3a36b4fa1", "target": 1, "func": "static int ffm_is_avail_data ( AVFormatContext * s , int size ) \n { \n FFMContext * ffm = s -> priv_data ; \n int64_t pos , avail_size ; \n int len ; \n len = ffm -> packet_end - ffm -> packet_ptr ; \n if ( size <= len ) \n return 1 ; \n pos = avio_tell ( s -> pb ) ; \n if ( ! ffm -> write_index ) { \n if ( pos == ffm -> file_size ) \n return AVERROR_EOF ; \n avail_size = ffm -> file_size - pos ; \n } else { \n if ( pos == ffm -> write_index ) { \n if ( ffm -> server_attached ) \n return AVERROR ( EAGAIN ) ; \n else \n return AVERROR_INVALIDDATA ; \n } else if ( pos < ffm -> write_index ) { \n avail_size = ffm -> write_index - pos ; \n } else { \n avail_size = ( ffm -> file_size - pos ) + ( ffm -> write_index - FFM_PACKET_SIZE ) ; \n } \n } \n avail_size = ( avail_size / ffm -> packet_size ) * ( ffm -> packet_size - FFM_HEADER_SIZE ) + len ; \n if ( size <= avail_size ) \n return 1 ; \n else if ( ffm -> server_attached ) \n return AVERROR ( EAGAIN ) ; \n else \n return AVERROR_INVALIDDATA ; \n }", "idx": 24491}
{"project": "FFmpeg", "commit_id": "67afcefb35932b420998f6f3fda46c7c85848a3f", "target": 0, "func": "static int vda_h264_start_frame ( AVCodecContext * avctx , \n av_unused const uint8_t * buffer , \n av_unused uint32_t size ) \n { \n VDAContext * vda = avctx -> internal -> hwaccel_priv_data ; \n struct vda_context * vda_ctx = avctx -> hwaccel_context ; \n if ( ! vda_ctx -> decoder ) \n return -1 ; \n vda -> bitstream_size = 0 ; \n return 0 ; \n }", "idx": 24519}
{"project": "FFmpeg", "commit_id": "7ac2f7e413051aa6ff735a8b9c47ca06dc4607d9", "target": 0, "func": "static void colored_fputs ( int level , int tint , const char * str ) \n { \n if ( ! * str ) \n return ; \n if ( use_color < 0 ) \n check_color_terminal ( ) ; \n #if defined ( _WIN32 ) && ! defined ( __MINGW32CE__ ) && HAVE_SETCONSOLETEXTATTRIBUTE  \n  \n  if ( use_color && level != AV_LOG_INFO / 8 ) \n SetConsoleTextAttribute ( con , background | color [ level ] ) ; \n fputs ( str , stderr ) ; \n if ( use_color && level != AV_LOG_INFO / 8 ) \n SetConsoleTextAttribute ( con , attr_orig ) ; \n #else \n if ( use_color == 1 && level != AV_LOG_INFO / 8 ) { \n fprintf ( stderr , \n \" \\033 \\033 \" , \n ( color [ level ] >> 4 ) & 15 , \n color [ level ] & 15 , \n str ) ; \n } else if ( tint && use_color == 256 ) { \n fprintf ( stderr , \n \" \\033 \\033 \\033 \" , \n ( color [ level ] >> 16 ) & 0xff , \n tint , \n str ) ; \n } else if ( use_color == 256 && level != AV_LOG_INFO / 8 ) { \n fprintf ( stderr , \n \" \\033 \\033 \\033 \" , \n ( color [ level ] >> 16 ) & 0xff , \n ( color [ level ] >> 8 ) & 0xff , \n str ) ; \n } else \n fputs ( str , stderr ) ; \n #endif \n }", "idx": 24520}
{"project": "FFmpeg", "commit_id": "da7baaaae79b4d7d715d35ea6bcfbdd149edc177", "target": 0, "func": "static int aasc_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n AascContext * s = avctx -> priv_data ; \n int compr , i , stride , ret ; \n s -> frame . reference = 1 ; \n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; \n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n compr = AV_RL32 ( buf ) ; \n buf += 4 ; \n buf_size -= 4 ; \n switch ( compr ) { \n case 0 : \n stride = ( avctx -> width * 3 + 3 ) & ~ 3 ; \n for ( i = avctx -> height - 1 ; i >= 0 ; i -- ) { \n memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , buf , avctx -> width * 3 ) ; \n buf += stride ; \n } \n break ; \n case 1 : \n bytestream2_init ( & s -> gb , buf - 4 , buf_size + 4 ) ; \n ff_msrle_decode ( avctx , ( AVPicture * ) & s -> frame , 8 , & s -> gb ) ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , compr ) ; \n return AVERROR_INVALIDDATA ; \n } \n * got_frame = 1 ; \n * ( AVFrame * ) data = s -> frame ; \n return buf_size ; \n }", "idx": 24521}
{"project": "FFmpeg", "commit_id": "cd7a2e1502f174c725c0de82711d2c7649057574", "target": 1, "func": "static int asf_read_simple_index ( AVFormatContext * s , const GUIDParseTable * g ) \n { \n ASFContext * asf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n AVStream * st = NULL ; \n uint64_t interval ; \n uint32_t pkt_num , nb_entries ; \n int32_t prev_pkt_num = -1 ; \n int i , ret ; \n uint64_t size = avio_rl64 ( pb ) ; \n for ( i = 0 ; i < asf -> nb_streams ; i ++ ) { \n if ( ( asf -> asf_st [ i ] -> type == AVMEDIA_TYPE_VIDEO ) && ! asf -> asf_st [ i ] -> indexed ) { \n asf -> asf_st [ i ] -> indexed = 1 ; \n st = s -> streams [ asf -> asf_st [ i ] -> index ] ; \n break ; \n } \n } \n if ( ! st ) { \n avio_skip ( pb , size - 24 ) ; \n return 0 ; \n } \n avio_skip ( pb , 16 ) ; \n interval = avio_rl64 ( pb ) ; \n avio_skip ( pb , 4 ) ; \n nb_entries = avio_rl32 ( pb ) ; \n for ( i = 0 ; i < nb_entries ; i ++ ) { \n pkt_num = avio_rl32 ( pb ) ; \n ret = avio_skip ( pb , 2 ) ; \n if ( ret < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n if ( prev_pkt_num != pkt_num ) { \n av_add_index_entry ( st , asf -> first_packet_offset + asf -> packet_size * \n pkt_num , av_rescale ( interval , i , 10000 ) , \n asf -> packet_size , 0 , AVINDEX_KEYFRAME ) ; \n prev_pkt_num = pkt_num ; \n } \n } \n asf -> is_simple_index = 1 ; \n align_position ( pb , asf -> offset , size ) ; \n return 0 ; \n }", "idx": 24529}
{"project": "FFmpeg", "commit_id": "f19af812a32c1398d48c3550d11dbc6aafbb2bfc", "target": 1, "func": "static uint32_t read_long ( const unsigned char * p ) \n { \n return ( p [ 0 ] << 24 ) | ( p [ 1 ] << 16 ) | ( p [ 2 ] << 8 ) | p [ 3 ] ; \n }", "idx": 24531}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( rgb15to16 ) ( const uint8_t * src , uint8_t * dst , unsigned src_size ) \n { \n register const uint8_t * s = src ; \n register uint8_t * d = dst ; \n register const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n #ifdef HAVE_MMX \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \n __asm __volatile ( \" \" :: \" \" ( mask15s ) ) ; \n mm_end = end - 15 ; \n while ( s < mm_end ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" \" ( * d ) \n : \" \" ( * s ) \n ) ; \n d += 16 ; \n s += 16 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #endif \n mm_end = end - 3 ; \n while ( s < mm_end ) \n { \n register unsigned x = * ( ( uint32_t * ) s ) ; \n * ( ( uint32_t * ) d ) = ( x & 0x7FFF7FFF ) + ( x & 0x7FE07FE0 ) ; \n d += 4 ; \n s += 4 ; \n } \n if ( s < end ) \n { \n register unsigned short x = * ( ( uint16_t * ) s ) ; \n * ( ( uint16_t * ) d ) = ( x & 0x7FFF ) + ( x & 0x7FE0 ) ; \n } \n }", "idx": 24538}
{"project": "FFmpeg", "commit_id": "ac9d159015a88aa2721b271875d18482f713f354", "target": 1, "func": "static void unpack_alpha ( GetBitContext * gb , uint16_t * dst , int num_coeffs , \n const int num_bits ) \n { \n const int mask = ( 1 << num_bits ) - 1 ; \n int i , idx , val , alpha_val ; \n idx = 0 ; \n alpha_val = mask ; \n do { \n do { \n if ( get_bits1 ( gb ) ) \n val = get_bits ( gb , num_bits ) ; \n else { \n int sign ; \n val = get_bits ( gb , num_bits == 16 ? 7 : 4 ) ; \n sign = val & 1 ; \n val = ( val + 2 ) >> 1 ; \n if ( sign ) \n val = - val ; \n } \n alpha_val = ( alpha_val + val ) & mask ; \n if ( num_bits == 16 ) \n dst [ idx ++ ] = alpha_val >> 6 ; \n else \n dst [ idx ++ ] = ( alpha_val << 2 ) | ( alpha_val >> 6 ) ; \n if ( idx == num_coeffs - 1 ) \n break ; \n } while ( get_bits1 ( gb ) ) ; \n val = get_bits ( gb , 4 ) ; \n if ( ! val ) \n val = get_bits ( gb , 11 ) ; \n if ( idx + val > num_coeffs ) \n val = num_coeffs - idx ; \n if ( num_bits == 16 ) \n for ( i = 0 ; i < val ; i ++ ) \n dst [ idx ++ ] = alpha_val >> 6 ; \n else \n for ( i = 0 ; i < val ; i ++ ) \n dst [ idx ++ ] = ( alpha_val << 2 ) | ( alpha_val >> 6 ) ; \n } while ( idx < num_coeffs ) ; \n }", "idx": 24550}
{"project": "FFmpeg", "commit_id": "66dd21d50be14a355e296b769d9d99090c0207f7", "target": 1, "func": "int attribute_align_arg avcodec_send_packet ( AVCodecContext * avctx , const AVPacket * avpkt ) \n { \n int ret ; \n if ( ! avcodec_is_open ( avctx ) || ! av_codec_is_decoder ( avctx -> codec ) ) \n return AVERROR ( EINVAL ) ; \n if ( avctx -> internal -> draining ) \n return AVERROR_EOF ; \n if ( ! avpkt || ! avpkt -> size ) { \n avctx -> internal -> draining = 1 ; \n avpkt = NULL ; \n if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) ) \n return 0 ; \n } \n if ( avctx -> codec -> send_packet ) { \n if ( avpkt ) { \n ret = apply_param_change ( avctx , ( AVPacket * ) avpkt ) ; \n if ( ret < 0 ) \n return ret ; \n } \n return avctx -> codec -> send_packet ( avctx , avpkt ) ; \n } \n if ( avctx -> internal -> buffer_pkt -> size || avctx -> internal -> buffer_frame -> buf [ 0 ] ) \n return AVERROR ( EAGAIN ) ; \n return do_decode ( avctx , ( AVPacket * ) avpkt ) ; \n }", "idx": 24556}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_tm_pred8x8_mode ( int mode , int mb_x , int mb_y ) \n { \n if ( ! mb_x ) \n return mb_y ? VERT_PRED8x8 : DC_129_PRED8x8 ; \n else \n return mb_y ? mode : HOR_PRED8x8 ; \n }", "idx": 24561}
{"project": "FFmpeg", "commit_id": "584c2f1db82fbb8024ba2b6b4c48397efedcc125", "target": 1, "func": "double parse_number_or_die ( const char * context , const char * numstr , int type , double min , double max ) \n { \n char * tail ; \n const char * error ; \n double d = av_strtod ( numstr , & tail ) ; \n if ( * tail ) \n error = \" \\n \" ; \n else if ( d < min || d > max ) \n error = \" \\n \" ; \n else if ( type == OPT_INT64 && ( int64_t ) d != d ) \n error = \" \\n \" ; \n else \n return d ; \n fprintf ( stderr , error , context , numstr , min , max ) ; \n exit ( 1 ) ; \n }", "idx": 24563}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void libschroedinger_decode_frame_free ( void * frame ) \n { \n schro_frame_unref ( frame ) ; \n }", "idx": 24566}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int get_transform_coeffs ( AC3DecodeContext * ctx ) \n { \n int i ; \n ac3_audio_block * ab = & ctx -> audio_block ; \n float * samples = ctx -> samples ; \n int got_cplchan = 0 ; \n int dithflag = 0 ; \n samples += ( ctx -> bsi . flags & AC3_BSI_LFEON ) ? 256 : 0 ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) { \n if ( ( ab -> flags & AC3_AB_CPLINU ) && ( ab -> chincpl & ( 1 << i ) ) ) \n dithflag = 0 ; \n else \n dithflag = ab -> dithflag & ( 1 << i ) ; \n if ( _get_transform_coeffs ( ab -> dexps [ i ] , ab -> bap [ i ] , ab -> chcoeffs [ i ] , samples + ( i * 256 ) , \n 0 , ab -> endmant [ i ] , dithflag , & ctx -> gb , & ctx -> state ) ) \n return -1 ; \n if ( ( ab -> flags & AC3_AB_CPLINU ) && ( ab -> chincpl & ( 1 << i ) ) && ! got_cplchan ) { \n if ( _get_transform_coeffs ( ab -> dcplexps , ab -> cplbap , 1.0f , ab -> cplcoeffs , \n ab -> cplstrtmant , ab -> cplendmant , 0 , & ctx -> gb , & ctx -> state ) ) \n return -1 ; \n got_cplchan = 1 ; \n } \n } \n if ( ctx -> bsi . flags & AC3_BSI_LFEON ) \n if ( _get_transform_coeffs ( ab -> lfeexps , ab -> lfebap , 1.0f , samples - 256 , 0 , 7 , 0 , & ctx -> gb , & ctx -> state ) ) \n return -1 ; \n if ( ab -> flags & AC3_AB_CPLINU ) \n if ( uncouple_channels ( ctx ) ) \n return -1 ; \n return 0 ; \n }", "idx": 24571}
{"project": "FFmpeg", "commit_id": "f5fbbbc022f723d3ccf99afd5d658a977b51c08a", "target": 0, "func": "static int mxf_add_metadata_set ( MXFContext * mxf , void * metadata_set ) \n { \n int err ; \n if ( mxf -> metadata_sets_count + 1 >= UINT_MAX / sizeof ( * mxf -> metadata_sets ) ) \n return AVERROR ( ENOMEM ) ; \n if ( ( err = av_reallocp_array ( & mxf -> metadata_sets , mxf -> metadata_sets_count + 1 , \n sizeof ( * mxf -> metadata_sets ) ) ) < 0 ) { \n mxf -> metadata_sets_count = 0 ; \n return err ; \n } \n mxf -> metadata_sets [ mxf -> metadata_sets_count ] = metadata_set ; \n mxf -> metadata_sets_count ++ ; \n return 0 ; \n }", "idx": 24572}
{"project": "FFmpeg", "commit_id": "778111592bf5f38630858ee6dfcfd097cd6c6da9", "target": 0, "func": "static int dvvideo_encode_frame ( AVCodecContext * c , AVPacket * pkt , \n const AVFrame * frame , int * got_packet ) \n { \n DVVideoContext * s = c -> priv_data ; \n int ret ; \n s -> sys = avpriv_dv_codec_profile ( c ) ; \n if ( ! s -> sys || ff_dv_init_dynamic_tables ( s -> sys ) ) \n return -1 ; \n if ( ( ret = ff_alloc_packet ( pkt , s -> sys -> frame_size ) ) < 0 ) { \n av_log ( c , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n c -> pix_fmt = s -> sys -> pix_fmt ; \n s -> frame = frame ; \n c -> coded_frame -> key_frame = 1 ; \n c -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n s -> buf = pkt -> data ; \n c -> execute ( c , dv_encode_video_segment , s -> sys -> work_chunks , NULL , \n dv_work_pool_size ( s -> sys ) , sizeof ( DVwork_chunk ) ) ; \n emms_c ( ) ; \n dv_format_frame ( s , pkt -> data ) ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n * got_packet = 1 ; \n return 0 ; \n }", "idx": 24573}
{"project": "FFmpeg", "commit_id": "7f938dd32bed373560e06a6f884f5d73415ed788", "target": 1, "func": "static void av_update_stream_timings ( AVFormatContext * ic ) \n { \n int64_t start_time , start_time1 , end_time , end_time1 ; \n int64_t duration , duration1 ; \n int i ; \n AVStream * st ; \n start_time = INT64_MAX ; \n end_time = INT64_MIN ; \n duration = INT64_MIN ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n if ( st -> start_time != AV_NOPTS_VALUE ) { \n start_time1 = av_rescale_q ( st -> start_time , st -> time_base , AV_TIME_BASE_Q ) ; \n if ( start_time1 < start_time ) \n start_time = start_time1 ; \n if ( st -> duration != AV_NOPTS_VALUE ) { \n end_time1 = start_time1 \n + av_rescale_q ( st -> duration , st -> time_base , AV_TIME_BASE_Q ) ; \n if ( end_time1 > end_time ) \n end_time = end_time1 ; \n } \n } \n if ( st -> duration != AV_NOPTS_VALUE ) { \n duration1 = av_rescale_q ( st -> duration , st -> time_base , AV_TIME_BASE_Q ) ; \n if ( duration1 > duration ) \n duration = duration1 ; \n } \n } \n if ( start_time != INT64_MAX ) { \n ic -> start_time = start_time ; \n if ( end_time != INT64_MIN ) { \n if ( end_time - start_time > duration ) \n duration = end_time - start_time ; \n } \n } \n if ( duration != INT64_MIN ) { \n ic -> duration = duration ; \n if ( ic -> file_size > 0 ) { \n ic -> bit_rate = ( double ) ic -> file_size * 8.0 * AV_TIME_BASE / \n ( double ) ic -> duration ; \n } \n } \n }", "idx": 24581}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "av_cold int ff_intrax8_common_init ( AVCodecContext * avctx , \n IntraX8Context * w , IDCTDSPContext * idsp , \n int16_t ( * block ) [ 64 ] , \n int block_last_index [ 12 ] , \n int mb_width , int mb_height ) \n { \n int ret = x8_vlc_init ( ) ; \n if ( ret < 0 ) \n return ret ; \n w -> avctx = avctx ; \n w -> idsp = * idsp ; \n w -> mb_width = mb_width ; \n w -> mb_height = mb_height ; \n w -> block = block ; \n w -> block_last_index = block_last_index ; \n w -> prediction_table = av_mallocz ( w -> mb_width * 2 * 2 ) ; \n if ( ! w -> prediction_table ) \n return AVERROR ( ENOMEM ) ; \n ff_init_scantable ( w -> idsp . idct_permutation , & w -> scantable [ 0 ] , \n ff_wmv1_scantable [ 0 ] ) ; \n ff_init_scantable ( w -> idsp . idct_permutation , & w -> scantable [ 1 ] , \n ff_wmv1_scantable [ 2 ] ) ; \n ff_init_scantable ( w -> idsp . idct_permutation , & w -> scantable [ 2 ] , \n ff_wmv1_scantable [ 3 ] ) ; \n ff_intrax8dsp_init ( & w -> dsp ) ; \n ff_blockdsp_init ( & w -> bdsp , avctx ) ; \n return 0 ; \n }", "idx": 24598}
{"project": "FFmpeg", "commit_id": "e3a1eb9edf65edda301f3a727f11e0224b9f5ae2", "target": 1, "func": "static int parse_channel_name ( char * * arg , int * rchannel , int * rnamed ) \n { \n char buf [ 8 ] ; \n int len , i , channel_id = 0 ; \n int64_t layout , layout0 ; \n if ( sscanf ( * arg , \" \" , buf , & len ) ) { \n layout0 = layout = av_get_channel_layout ( buf ) ; \n for ( i = 32 ; i > 0 ; i >>= 1 ) { \n if ( layout >= ( int64_t ) 1 << i ) { \n channel_id += i ; \n layout >>= i ; \n } \n } \n if ( channel_id >= MAX_CHANNELS || layout0 != ( int64_t ) 1 << channel_id ) \n return AVERROR ( EINVAL ) ; \n * rchannel = channel_id ; \n * rnamed = 1 ; \n * arg += len ; \n return 0 ; \n } \n if ( sscanf ( * arg , \" \" , & channel_id , & len ) && \n channel_id >= 0 && channel_id < MAX_CHANNELS ) { \n * rchannel = channel_id ; \n * rnamed = 0 ; \n * arg += len ; \n return 0 ; \n } \n return AVERROR ( EINVAL ) ; \n }", "idx": 24609}
{"project": "FFmpeg", "commit_id": "f5e646a00ac21e500dae4bcceded790a0fbc5246", "target": 1, "func": "static void get_attachment ( AVFormatContext * s , AVIOContext * pb , int length ) \n { \n char mime [ 1024 ] ; \n char description [ 1024 ] ; \n unsigned int filesize ; \n AVStream * st ; \n int64_t pos = avio_tell ( pb ) ; \n avio_get_str16le ( pb , INT_MAX , mime , sizeof ( mime ) ) ; \n if ( strcmp ( mime , \" \" ) ) \n goto done ; \n avio_r8 ( pb ) ; \n avio_get_str16le ( pb , INT_MAX , description , sizeof ( description ) ) ; \n filesize = avio_rl32 ( pb ) ; \n if ( ! filesize ) \n goto done ; \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n goto done ; \n av_dict_set ( & st -> metadata , \" \" , description , 0 ) ; \n st -> codec -> codec_id = AV_CODEC_ID_MJPEG ; \n st -> codec -> codec_type = AVMEDIA_TYPE_ATTACHMENT ; \n st -> codec -> extradata = av_mallocz ( filesize ) ; \n if ( ! st -> codec -> extradata ) \n goto done ; \n st -> codec -> extradata_size = filesize ; \n avio_read ( pb , st -> codec -> extradata , filesize ) ; \n done : \n avio_seek ( pb , pos + length , SEEK_SET ) ; \n }", "idx": 24616}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int parse_filename ( char * filename , char * * representation_id , \n char * * initialization_pattern , char * * media_pattern ) { \n char * underscore_pos = NULL ; \n char * period_pos = NULL ; \n char * temp_pos = NULL ; \n char * filename_str = av_strdup ( filename ) ; \n if ( ! filename_str ) return AVERROR ( ENOMEM ) ; \n temp_pos = av_stristr ( filename_str , \" \" ) ; \n while ( temp_pos ) { \n underscore_pos = temp_pos + 1 ; \n temp_pos = av_stristr ( temp_pos + 1 , \" \" ) ; \n } \n if ( ! underscore_pos ) return -1 ; \n period_pos = av_stristr ( underscore_pos , \" \" ) ; \n if ( ! period_pos ) return -1 ; \n * ( underscore_pos - 1 ) = 0 ; \n if ( representation_id ) { \n * representation_id = av_malloc ( period_pos - underscore_pos + 1 ) ; \n if ( ! ( * representation_id ) ) return AVERROR ( ENOMEM ) ; \n av_strlcpy ( * representation_id , underscore_pos , period_pos - underscore_pos + 1 ) ; \n } \n if ( initialization_pattern ) { \n * initialization_pattern = av_asprintf ( \" \" , \n filename_str ) ; \n if ( ! ( * initialization_pattern ) ) return AVERROR ( ENOMEM ) ; \n } \n if ( media_pattern ) { \n * media_pattern = av_asprintf ( \" \" , \n filename_str ) ; \n if ( ! ( * media_pattern ) ) return AVERROR ( ENOMEM ) ; \n } \n av_free ( filename_str ) ; \n return 0 ; \n }", "idx": 24617}
{"project": "FFmpeg", "commit_id": "de052ea454e06f2c1aab4e06cca0012cf80f2630", "target": 1, "func": "static void celt_denormalize ( CeltFrame * f , CeltBlock * block , float * data ) \n { \n int i , j ; \n for ( i = f -> start_band ; i < f -> end_band ; i ++ ) { \n float * dst = data + ( ff_celt_freq_bands [ i ] << f -> size ) ; \n float norm = exp2f ( block -> energy [ i ] + ff_celt_mean_energy [ i ] ) ; \n for ( j = 0 ; j < ff_celt_freq_range [ i ] << f -> size ; j ++ ) \n dst [ j ] *= norm ; \n } \n }", "idx": 24622}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_8w_msa ( src + stride - 2 , \n src - ( stride * 2 ) , stride , dst , stride , 8 ) ; \n }", "idx": 24628}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "static void xvid_idct_add ( uint8_t * dest , ptrdiff_t line_size , int16_t * block ) \n { \n ff_xvid_idct ( block ) ; \n ff_add_pixels_clamped ( block , dest , line_size ) ; \n }", "idx": 24633}
{"project": "FFmpeg", "commit_id": "18d1d5886bb78e4d0e11a2a0193fda765e05805d", "target": 1, "func": "static int rv30_decode_mb_info ( RV34DecContext * r ) \n { \n static const int rv30_p_types [ 6 ] = { RV34_MB_SKIP , RV34_MB_P_16x16 , RV34_MB_P_8x8 , -1 , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 } ; \n static const int rv30_b_types [ 6 ] = { RV34_MB_SKIP , RV34_MB_B_DIRECT , RV34_MB_B_FORWARD , RV34_MB_B_BACKWARD , RV34_MB_TYPE_INTRA , RV34_MB_TYPE_INTRA16x16 } ; \n MpegEncContext * s = & r -> s ; \n GetBitContext * gb = & s -> gb ; \n int code = svq3_get_ue_golomb ( gb ) ; \n if ( code > 11 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( code > 5 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n code -= 6 ; \n } \n if ( s -> pict_type != AV_PICTURE_TYPE_B ) \n return rv30_p_types [ code ] ; \n else \n return rv30_b_types [ code ] ; \n }", "idx": 24636}
{"project": "FFmpeg", "commit_id": "0424e052f83adc422d8a746e3cdc5ab6bc28679e", "target": 1, "func": "void ff_release_unused_pictures ( MpegEncContext * s , int remove_current ) \n { \n int i ; \n for ( i = 0 ; i < s -> picture_count ; i ++ ) { \n if ( s -> picture [ i ] . data [ 0 ] && ! s -> picture [ i ] . reference \n && s -> picture [ i ] . owner2 == s \n && ( remove_current || & s -> picture [ i ] != s -> current_picture_ptr ) \n ) { \n free_frame_buffer ( s , & s -> picture [ i ] ) ; \n } \n } \n }", "idx": 24641}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static int mov_read_stsc ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = ( MOVStreamContext * ) st -> priv_data ; \n int entries , i ; \n print_atom ( \" \" , atom ) ; \n get_byte ( pb ) ; \n get_byte ( pb ) ; get_byte ( pb ) ; get_byte ( pb ) ; \n entries = get_be32 ( pb ) ; \n #ifdef DEBUG \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n #endif \n sc -> sample_to_chunk_sz = entries ; \n sc -> sample_to_chunk = ( MOV_sample_to_chunk_tbl * ) av_malloc ( entries * sizeof ( MOV_sample_to_chunk_tbl ) ) ; \n if ( ! sc -> sample_to_chunk ) \n return -1 ; \n for ( i = 0 ; i < entries ; i ++ ) { \n sc -> sample_to_chunk [ i ] . first = get_be32 ( pb ) ; \n sc -> sample_to_chunk [ i ] . count = get_be32 ( pb ) ; \n sc -> sample_to_chunk [ i ] . id = get_be32 ( pb ) ; \n #ifdef DEBUG \n #endif \n } \n return 0 ; \n }", "idx": 24646}
{"project": "FFmpeg", "commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "target": 1, "func": "static int blend_frames ( AVFilterContext * ctx , int interpolate ) \n { \n FrameRateContext * s = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n double interpolate_scene_score = 0 ; \n if ( ( s -> flags & FRAMERATE_FLAG_SCD ) ) { \n if ( s -> score >= 0.0 ) \n interpolate_scene_score = s -> score ; \n else \n interpolate_scene_score = s -> score = get_scene_score ( ctx , s -> f0 , s -> f1 ) ; \n ff_dlog ( ctx , \" \\n \" , interpolate_scene_score ) ; \n } \n if ( interpolate_scene_score < s -> scene_score ) { \n ThreadData td ; \n td . copy_src1 = s -> f0 ; \n td . copy_src2 = s -> f1 ; \n td . src2_factor = interpolate ; \n td . src1_factor = s -> max - td . src2_factor ; \n s -> work = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; \n if ( ! s -> work ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( s -> work , s -> f0 ) ; \n ff_dlog ( ctx , \" \\n \" ) ; \n ctx -> internal -> execute ( ctx , filter_slice , & td , NULL , FFMIN ( outlink -> h , ff_filter_get_nb_threads ( ctx ) ) ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 24653}
{"project": "FFmpeg", "commit_id": "7a7ca3cc2f43e7a7b61fdad8200b365ff0977bd2", "target": 1, "func": "static void draw_bar ( TestSourceContext * test , const uint8_t color [ 4 ] , \n unsigned x , unsigned y , unsigned w , unsigned h , \n AVFrame * frame ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n uint8_t * p , * p0 ; \n int plane ; \n x = FFMIN ( x , test -> w - 1 ) ; \n y = FFMIN ( y , test -> h - 1 ) ; \n w = FFMIN ( w , test -> w - x ) ; \n h = FFMIN ( h , test -> h - y ) ; \n av_assert0 ( x + w <= test -> w ) ; \n av_assert0 ( y + h <= test -> h ) ; \n for ( plane = 0 ; frame -> data [ plane ] ; plane ++ ) { \n const int c = color [ plane ] ; \n const int linesize = frame -> linesize [ plane ] ; \n int i , px , py , pw , ph ; \n if ( plane == 1 || plane == 2 ) { \n px = x >> desc -> log2_chroma_w ; \n pw = w >> desc -> log2_chroma_w ; \n py = y >> desc -> log2_chroma_h ; \n ph = h >> desc -> log2_chroma_h ; \n } else { \n px = x ; \n pw = w ; \n py = y ; \n ph = h ; \n } \n p0 = p = frame -> data [ plane ] + py * linesize + px ; \n memset ( p , c , pw ) ; \n p += linesize ; \n for ( i = 1 ; i < ph ; i ++ , p += linesize ) \n memcpy ( p , p0 , pw ) ; \n } \n }", "idx": 24664}
{"project": "FFmpeg", "commit_id": "05e161952954acf247e0fd1fdef00559675c4d4d", "target": 1, "func": "static inline int64_t gb_get_v ( GetBitContext * gb ) \n { \n int64_t v = 0 ; \n int bits = 0 ; \n while ( get_bits1 ( gb ) && bits < 64 - 7 ) { \n v <<= 7 ; \n v |= get_bits ( gb , 7 ) ; \n bits += 7 ; \n } \n v <<= 7 ; \n v |= get_bits ( gb , 7 ) ; \n return v ; \n }", "idx": 24666}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ff_copy_whitelists ( AVFormatContext * dst , AVFormatContext * src ) \n { \n av_assert0 ( ! dst -> codec_whitelist && ! dst -> format_whitelist ) ; \n dst -> codec_whitelist = av_strdup ( src -> codec_whitelist ) ; \n dst -> format_whitelist = av_strdup ( src -> format_whitelist ) ; \n if ( ( src -> codec_whitelist && ! dst -> codec_whitelist ) \n || ( src -> format_whitelist && ! dst -> format_whitelist ) ) { \n av_log ( dst , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 24670}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "static void init_dequant4_coeff_table ( H264Context * h ) { \n int i , j , q , x ; \n const int transpose = ( h -> h264dsp . h264_idct_add != ff_h264_idct_add_c ) ; \n for ( i = 0 ; i < 6 ; i ++ ) { \n h -> dequant4_coeff [ i ] = h -> dequant4_buffer [ i ] ; \n for ( j = 0 ; j < i ; j ++ ) { \n if ( ! memcmp ( h -> pps . scaling_matrix4 [ j ] , h -> pps . scaling_matrix4 [ i ] , 16 * sizeof ( uint8_t ) ) ) { \n h -> dequant4_coeff [ i ] = h -> dequant4_buffer [ j ] ; \n break ; \n } \n } \n if ( j < i ) \n continue ; \n for ( q = 0 ; q < 52 ; q ++ ) { \n int shift = div6 [ q ] + 2 ; \n int idx = rem6 [ q ] ; \n for ( x = 0 ; x < 16 ; x ++ ) \n h -> dequant4_coeff [ i ] [ q ] [ transpose ? ( x >> 2 ) | ( ( x << 2 ) & 0xF ) : x ] = \n ( ( uint32_t ) dequant4_coeff_init [ idx ] [ ( x & 1 ) + ( ( x >> 2 ) & 1 ) ] * \n h -> pps . scaling_matrix4 [ i ] [ x ] ) << shift ; \n } \n } \n }", "idx": 24671}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pcx_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 24701}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static void fill_double_array ( AVLFG * lfg , double * a , int len ) \n { \n int i ; \n double bmg [ 2 ] , stddev = 10.0 , mean = 0.0 ; \n for ( i = 0 ; i < len ; i += 2 ) { \n av_bmg_get ( lfg , bmg ) ; \n a [ i ] = bmg [ 0 ] * stddev + mean ; \n a [ i + 1 ] = bmg [ 1 ] * stddev + mean ; \n } \n }", "idx": 24702}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel4_mc12_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_and_aver_dst_4w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 4 , 0 ) ; \n }", "idx": 24707}
{"project": "FFmpeg", "commit_id": "8b97ae64841ed29db9c77db322890656cdc0d354", "target": 0, "func": "static int has_duration ( AVFormatContext * ic ) \n { \n int i ; \n AVStream * st ; \n for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { \n st = ic -> streams [ i ] ; \n if ( st -> duration != AV_NOPTS_VALUE ) \n return 1 ; \n } \n if ( ic -> duration ) \n return 1 ; \n return 0 ; \n }", "idx": 24710}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "void write_video_frame ( AVFormatContext * oc , AVStream * st ) \n { \n int x , y , i , out_size ; \n AVCodecContext * c ; \n c = & st -> codec ; \n i = frame_count ++ ; \n for ( y = 0 ; y < c -> height ; y ++ ) { \n for ( x = 0 ; x < c -> width ; x ++ ) { \n picture -> data [ 0 ] [ y * picture -> linesize [ 0 ] + x ] = x + y + i * 3 ; \n } \n } \n for ( y = 0 ; y < c -> height / 2 ; y ++ ) { \n for ( x = 0 ; x < c -> width / 2 ; x ++ ) { \n picture -> data [ 1 ] [ y * picture -> linesize [ 1 ] + x ] = 128 + y + i * 2 ; \n picture -> data [ 2 ] [ y * picture -> linesize [ 2 ] + x ] = 64 + x + i * 5 ; \n } \n } \n out_size = avcodec_encode_video ( c , video_outbuf , video_outbuf_size , picture ) ; \n if ( av_write_frame ( oc , st -> index , video_outbuf , out_size ) != 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 24735}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "static int inline get_mb_score ( MpegEncContext * s , int mx , int my , int src_index , \n int ref_index ) \n { \n MotionEstContext * const c = & s -> me ; \n const int size = 0 ; \n const int h = 16 ; \n const int penalty_factor = c -> mb_penalty_factor ; \n const int flags = c -> mb_flags ; \n const int qpel = flags & FLAG_QPEL ; \n const int mask = 1 + 2 * qpel ; \n me_cmp_func cmp_sub , chroma_cmp_sub ; \n int d ; \n LOAD_COMMON \n cmp_sub = s -> dsp . mb_cmp [ size ] ; \n chroma_cmp_sub = s -> dsp . mb_cmp [ size + 1 ] ; \n assert ( ! c -> skip ) ; \n assert ( c -> avctx -> me_sub_cmp != c -> avctx -> mb_cmp ) ; \n d = cmp ( s , mx >> ( qpel + 1 ) , my >> ( qpel + 1 ) , mx & mask , my & mask , size , h , ref_index , src_index , cmp_sub , chroma_cmp_sub , flags ) ; \n if ( mx || my || size > 0 ) \n d += ( mv_penalty [ mx - pred_x ] + mv_penalty [ my - pred_y ] ) * penalty_factor ; \n return d ; \n }", "idx": 24745}
{"project": "FFmpeg", "commit_id": "4cb6964244fd6c099383d8b7e99731e72cc844b9", "target": 0, "func": "av_cold void ff_dcadsp_init ( DCADSPContext * s ) \n { \n s -> lfe_fir [ 0 ] = dca_lfe_fir0_c ; \n s -> lfe_fir [ 1 ] = dca_lfe_fir1_c ; \n s -> qmf_32_subbands = dca_qmf_32_subbands ; \n s -> int8x8_fmul_int32 = int8x8_fmul_int32_c ; \n if ( ARCH_ARM ) ff_dcadsp_init_arm ( s ) ; \n if ( ARCH_X86 ) ff_dcadsp_init_x86 ( s ) ; \n }", "idx": 24746}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2mono_1_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * ubuf0 , const uint16_t * ubuf1 , \n const uint16_t * vbuf0 , const uint16_t * vbuf1 , \n const uint16_t * abuf0 , uint8_t * dest , int dstW , \n int uvalpha , enum PixelFormat dstFormat , \n int flags , int y , enum PixelFormat target )  \n { \n const uint8_t * const d128 = dither_8x8_220 [ y & 7 ] ; \n uint8_t * g = c -> table_gU [ 128 ] + c -> table_gV [ 128 ] ; \n int i ; \n for ( i = 0 ; i < dstW - 7 ; i += 8 ) { \n int acc = g [ ( buf0 [ i ] >> 7 ) + d128 [ 0 ] ] ; \n acc += acc + g [ ( buf0 [ i + 1 ] >> 7 ) + d128 [ 1 ] ] ; \n acc += acc + g [ ( buf0 [ i + 2 ] >> 7 ) + d128 [ 2 ] ] ; \n acc += acc + g [ ( buf0 [ i + 3 ] >> 7 ) + d128 [ 3 ] ] ; \n acc += acc + g [ ( buf0 [ i + 4 ] >> 7 ) + d128 [ 4 ] ] ; \n acc += acc + g [ ( buf0 [ i + 5 ] >> 7 ) + d128 [ 5 ] ] ; \n acc += acc + g [ ( buf0 [ i + 6 ] >> 7 ) + d128 [ 6 ] ] ; \n acc += acc + g [ ( buf0 [ i + 7 ] >> 7 ) + d128 [ 7 ] ] ; \n output_pixel ( * dest ++ , acc ) ; \n } \n }", "idx": 24760}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static int decode_cabac_mb_dqp ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int mbn_xy ; \n int ctx = 0 ; \n int val = 0 ; \n if ( s -> mb_x > 0 ) \n mbn_xy = s -> mb_x + s -> mb_y * s -> mb_stride - 1 ; \n else \n mbn_xy = s -> mb_width - 1 + ( s -> mb_y - 1 ) * s -> mb_stride ; \n if ( h -> last_qscale_diff != 0 ) \n ctx ++ ; \n while ( get_cabac ( & h -> cabac , & h -> cabac_state [ 60 + ctx ] ) ) { \n if ( ctx < 2 ) \n ctx = 2 ; \n else \n ctx = 3 ; \n val ++ ; \n if ( val > 102 ) \n return INT_MIN ; \n } \n if ( val & 0x01 ) \n return ( val + 1 ) / 2 ; \n else \n return - ( val + 1 ) / 2 ; \n }", "idx": 24762}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static uint8_t get_sot ( Jpeg2000DecoderContext * s , int n ) \n { \n Jpeg2000TilePart * tp ; \n uint16_t Isot ; \n uint32_t Psot ; \n uint8_t TPsot ; \n if ( s -> buf_end - s -> buf < 4 ) \n return AVERROR ( EINVAL ) ; \n Isot = bytestream_get_be16 ( & s -> buf ) ; \n if ( Isot ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return -1 ; \n } \n Psot = bytestream_get_be32 ( & s -> buf ) ; \n TPsot = bytestream_get_byte ( & s -> buf ) ; \n bytestream_get_byte ( & s -> buf ) ; \n tp = s -> tile [ s -> curtileno ] . tile_part + TPsot ; \n tp -> tile_index = Isot ; \n tp -> tp_len = Psot ; \n tp -> tp_idx = TPsot ; \n if ( JPEG2000_SOD == bytestream_get_be16 ( & s -> buf ) ) \n tp -> tp_start_bstrm = s -> buf ; \n else { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n tp -> tp_end_bstrm = s -> buf + ( tp -> tp_len - n - 4 ) ; \n s -> buf = tp -> tp_end_bstrm ; \n return 0 ; \n }", "idx": 24769}
{"project": "FFmpeg", "commit_id": "ddbb7c9be2f8a006325ec64cd5b90e1ade5bc476", "target": 1, "func": "static int xa_probe ( AVProbeData * p ) \n { \n switch ( AV_RL32 ( p -> buf ) ) { \n case XA00_TAG : \n case XAI0_TAG : \n case XAJ0_TAG : \n return AVPROBE_SCORE_MAX ; \n } \n return 0 ; \n }", "idx": 24770}
{"project": "FFmpeg", "commit_id": "3ed65d98c616d52e2544c8b81aa3997f28bb88f5", "target": 1, "func": "void av_vlog ( void * avcl , int level , const char * fmt , va_list vl ) \n { \n if ( av_log_callback ) \n av_log_callback ( avcl , level , fmt , vl ) ; \n }", "idx": 24773}
{"project": "FFmpeg", "commit_id": "e9ba3098319f78c91470c05da988d865491852c5", "target": 0, "func": "static int read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n ASSContext * ass = s -> priv_data ; \n uint8_t * p , * end ; \n if ( ass -> event_index >= ass -> event_count ) \n return AVERROR ( EIO ) ; \n p = ass -> event [ ass -> event_index ] ; \n end = strchr ( p , ' \\n ' ) ; \n av_new_packet ( pkt , end ? end - p + 1 : strlen ( p ) ) ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> pos = p - ass -> event_buffer + s -> streams [ 0 ] -> codec -> extradata_size ; \n pkt -> pts = pkt -> dts = get_pts ( p ) ; \n memcpy ( pkt -> data , p , pkt -> size ) ; \n ass -> event_index ++ ; \n return 0 ; \n }", "idx": 24775}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xwd_encode_close ( AVCodecContext * avctx ) \n { \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 24776}
{"project": "FFmpeg", "commit_id": "79db7ac6ef235a06c3049d7792eda39da28ee3fd", "target": 1, "func": "static int context_init ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n CHECKED_ALLOCZ ( h -> top_borders [ 0 ] , h -> s . mb_width * ( 16 + 8 + 8 ) * sizeof ( uint8_t ) )  \n CHECKED_ALLOCZ ( h -> top_borders [ 1 ] , h -> s . mb_width * ( 16 + 8 + 8 ) * sizeof ( uint8_t ) )  \n CHECKED_ALLOCZ ( s -> allocated_edge_emu_buffer , \n ( s -> width + 64 ) * 2 * 21 * 2 ) ; \n s -> edge_emu_buffer = s -> allocated_edge_emu_buffer + ( s -> width + 64 ) * 2 * 21 ; \n return 0 ; \n fail : \n return -1 ; \n }", "idx": 24782}
{"project": "FFmpeg", "commit_id": "2d0b4bc4cf92dd961dbafbff3f1f4a9e08a9565b", "target": 0, "func": "static int check_slice_end ( RV34DecContext * r , MpegEncContext * s ) \n { \n int bits ; \n if ( s -> mb_y >= s -> mb_height ) \n return 1 ; \n if ( ! s -> mb_num_left ) \n return 1 ; \n if ( r -> s . mb_skip_run > 1 ) \n return 0 ; \n bits = get_bits_left ( & s -> gb ) ; \n if ( bits < 0 || ( bits < 8 && ! show_bits ( & s -> gb , bits ) ) ) \n return 1 ; \n return 0 ; \n }", "idx": 24784}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel4_mc32_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_and_aver_dst_4w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 4 , 1 ) ; \n }", "idx": 24786}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_programs ( WriterContext * w , AVFormatContext * fmt_ctx ) \n { \n int i ; \n writer_print_section_header ( w , SECTION_ID_PROGRAMS ) ; \n for ( i = 0 ; i < fmt_ctx -> nb_programs ; i ++ ) { \n AVProgram * program = fmt_ctx -> programs [ i ] ; \n if ( ! program ) \n continue ; \n show_program ( w , fmt_ctx , program ) ; \n } \n writer_print_section_footer ( w ) ; \n }", "idx": 24788}
{"project": "FFmpeg", "commit_id": "66f26b3e8ec075298e7ba329a55893d085bafe96", "target": 0, "func": "static int put_flac_codecpriv ( AVFormatContext * s , \n AVIOContext * pb , AVCodecContext * codec ) \n { \n int write_comment = ( codec -> channel_layout && \n ! ( codec -> channel_layout & ~ 0x3ffffULL ) && \n ! ff_flac_is_native_layout ( codec -> channel_layout ) ) ; \n int ret = ff_flac_write_header ( pb , codec -> extradata , codec -> extradata_size , \n ! write_comment ) ; \n if ( ret < 0 ) \n return ret ; \n if ( write_comment ) { \n const char * vendor = ( s -> flags & AVFMT_FLAG_BITEXACT ) ? \n \" \" : LIBAVFORMAT_IDENT ; \n AVDictionary * dict = NULL ; \n uint8_t buf [ 32 ] , * data , * p ; \n int len ; \n snprintf ( buf , sizeof ( buf ) , \" \" PRIx64 , codec -> channel_layout ) ; \n av_dict_set ( & dict , \" \" , buf , 0 ) ; \n len = ff_vorbiscomment_length ( dict , vendor ) ; \n data = av_malloc ( len + 4 ) ; \n if ( ! data ) { \n av_dict_free ( & dict ) ; \n return AVERROR ( ENOMEM ) ; \n } \n data [ 0 ] = 0x84 ; \n AV_WB24 ( data + 1 , len ) ; \n p = data + 4 ; \n ff_vorbiscomment_write ( & p , & dict , vendor ) ; \n avio_write ( pb , data , len + 4 ) ; \n av_freep ( & data ) ; \n av_dict_free ( & dict ) ; \n } \n return 0 ; \n }", "idx": 24789}
{"project": "FFmpeg", "commit_id": "1662bd350a470f1cbd5c2cc9a0e1bfaa8543033f", "target": 1, "func": "static int64_t wrap_timestamp ( AVStream * st , int64_t timestamp ) \n { \n if ( st -> pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st -> pts_wrap_bits < 64 && \n st -> pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE ) { \n if ( st -> pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET && \n timestamp < st -> pts_wrap_reference ) \n return timestamp + ( 1LL << st -> pts_wrap_bits ) ; \n else if ( st -> pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET && \n timestamp >= st -> pts_wrap_reference ) \n return timestamp - ( 1LL << st -> pts_wrap_bits ) ; \n } \n return timestamp ; \n }", "idx": 24793}
{"project": "FFmpeg", "commit_id": "8813d55fa5978660d9f4e7dbe1f50da9922be08d", "target": 0, "func": "static void * alloc_buffer ( FFVAContext * vactx , int type , unsigned int size , uint32_t * buf_id ) \n { \n void * data = NULL ; \n * buf_id = 0 ; \n if ( vaCreateBuffer ( vactx -> display , vactx -> context_id , \n type , size , 1 , NULL , buf_id ) == VA_STATUS_SUCCESS ) \n vaMapBuffer ( vactx -> display , * buf_id , & data ) ; \n return data ; \n }", "idx": 24805}
{"project": "FFmpeg", "commit_id": "8f0bd1d9bad5b8aa42b5b4cec103cc4afed5eab6", "target": 0, "func": "void ff_http_auth_handle_header ( HTTPAuthState * state , const char * key , \n const char * value ) \n { \n if ( ! strcmp ( key , \" \" ) || ! strcmp ( key , \" \" ) ) { \n const char * p ; \n if ( av_stristart ( value , \" \" , & p ) && \n state -> auth_type <= HTTP_AUTH_BASIC ) { \n state -> auth_type = HTTP_AUTH_BASIC ; \n state -> realm [ 0 ] = 0 ; \n state -> stale = 0 ; \n ff_parse_key_value ( p , ( ff_parse_key_val_cb ) handle_basic_params , \n state ) ; \n } else if ( av_stristart ( value , \" \" , & p ) && \n state -> auth_type <= HTTP_AUTH_DIGEST ) { \n state -> auth_type = HTTP_AUTH_DIGEST ; \n memset ( & state -> digest_params , 0 , sizeof ( DigestParams ) ) ; \n state -> realm [ 0 ] = 0 ; \n state -> stale = 0 ; \n ff_parse_key_value ( p , ( ff_parse_key_val_cb ) handle_digest_params , \n state ) ; \n choose_qop ( state -> digest_params . qop , \n sizeof ( state -> digest_params . qop ) ) ; \n if ( ! av_strcasecmp ( state -> digest_params . stale , \" \" ) ) \n state -> stale = 1 ; \n } \n } else if ( ! strcmp ( key , \" \" ) ) { \n ff_parse_key_value ( value , ( ff_parse_key_val_cb ) handle_digest_update , \n state ) ; \n } \n }", "idx": 24807}
{"project": "FFmpeg", "commit_id": "343e2833994655c252d5236a3394bf6db7a4d8b1", "target": 0, "func": "void ff_thread_report_progress ( ThreadFrame * f , int n , int field ) \n { \n PerThreadContext * p ; \n atomic_int * progress = f -> progress ? ( atomic_int * ) f -> progress -> data : NULL ; \n if ( ! progress || \n atomic_load_explicit ( & progress [ field ] , memory_order_acquire ) >= n ) \n return ; \n p = f -> owner -> internal -> thread_ctx ; \n if ( f -> owner -> debug & FF_DEBUG_THREADS ) \n av_log ( f -> owner , AV_LOG_DEBUG , \" \\n \" , progress , n , field ) ; \n pthread_mutex_lock ( & p -> progress_mutex ) ; \n atomic_store ( & progress [ field ] , n ) ; \n pthread_cond_broadcast ( & p -> progress_cond ) ; \n pthread_mutex_unlock ( & p -> progress_mutex ) ; \n }", "idx": 24808}
{"project": "FFmpeg", "commit_id": "3896cd11a107f241f06b06a336322aef2f372fdd", "target": 1, "func": "static void mxf_write_system_item ( AVFormatContext * s ) \n { \n MXFContext * mxf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n unsigned frame ; \n uint32_t time_code ; \n frame = mxf -> last_indexed_edit_unit + mxf -> edit_units_count ; \n avio_write ( pb , system_metadata_pack_key , 16 ) ; \n klv_encode_ber4_length ( pb , 57 ) ; \n avio_w8 ( pb , 0x5c ) ; \n avio_w8 ( pb , 0x04 ) ; \n avio_w8 ( pb , 0x00 ) ; \n avio_wb16 ( pb , 0x00 ) ; \n avio_wb16 ( pb , mxf -> tc . start + frame ) ; \n if ( mxf -> essence_container_count > 1 ) \n avio_write ( pb , multiple_desc_ul , 16 ) ; \n else { \n MXFStreamContext * sc = s -> streams [ 0 ] -> priv_data ; \n avio_write ( pb , mxf_essence_container_uls [ sc -> index ] . container_ul , 16 ) ; \n } \n avio_w8 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_w8 ( pb , 0x81 ) ; \n time_code = av_timecode_get_smpte_from_framenum ( & mxf -> tc , frame ) ; \n avio_wb32 ( pb , time_code ) ; \n avio_wb32 ( pb , 0 ) ; \n avio_wb64 ( pb , 0 ) ; \n avio_write ( pb , system_metadata_package_set_key , 16 ) ; \n klv_encode_ber4_length ( pb , 35 ) ; \n avio_w8 ( pb , 0x83 ) ; \n avio_wb16 ( pb , 0x20 ) ; \n mxf_write_umid ( s , 1 ) ; \n }", "idx": 24809}
{"project": "FFmpeg", "commit_id": "17ae608127324cabd083202a32a8dc210d30c3a1", "target": 1, "func": "static av_cold int aac_encode_end ( AVCodecContext * avctx ) \n { \n AACEncContext * s = avctx -> priv_data ; \n ff_mdct_end ( & s -> mdct1024 ) ; \n ff_mdct_end ( & s -> mdct128 ) ; \n ff_psy_end ( & s -> psy ) ; \n ff_psy_preprocess_end ( s -> psypp ) ; \n av_freep ( & s -> samples ) ; \n av_freep ( & s -> cpe ) ; \n return 0 ; \n }", "idx": 24814}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int rice_count_exact ( int32_t * res , int n , int k ) \n { \n int i ; \n int count = 0 ; \n for ( i = 0 ; i < n ; i ++ ) { \n int32_t v = -2 * res [ i ] - 1 ; \n v ^= v >> 31 ; \n count += ( v >> k ) + 1 + k ; \n } \n return count ; \n }", "idx": 24816}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "static inline int mix_core ( uint32_t multbl [ ] [ 256 ] , int a , int b , int c , int d ) { \n #if CONFIG_SMALL  \n  \n  #define ROT ( x , s )  ((x<<s)|(x>>(32-s)))  \n  \n  return multbl [ 0 ] [ a ] ^ ROT ( multbl [ 0 ] [ b ] , 8 ) ^ ROT ( multbl [ 0 ] [ c ] , 16 ) ^ ROT ( multbl [ 0 ] [ d ] , 24 ) ; \n #else \n return multbl [ 0 ] [ a ] ^ multbl [ 1 ] [ b ] ^ multbl [ 2 ] [ c ] ^ multbl [ 3 ] [ d ] ; \n #endif \n }", "idx": 24819}
{"project": "FFmpeg", "commit_id": "bad446e251405dc250c3cbee199072e083a1e4b9", "target": 1, "func": "void ff_generate_sliding_window_mmcos ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n h -> mmco_index = 0 ; \n if ( h -> short_ref_count && h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE && ! s -> first_field && s -> current_picture_ptr -> f . reference ) ) { \n h -> mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n h -> mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n h -> mmco_index = 1 ; \n if ( FIELD_PICTURE ) { \n h -> mmco [ 0 ] . short_pic_num *= 2 ; \n h -> mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n h -> mmco [ 1 ] . short_pic_num = h -> mmco [ 0 ] . short_pic_num + 1 ; \n h -> mmco_index = 2 ; \n } \n } \n }", "idx": 24820}
{"project": "FFmpeg", "commit_id": "b737a2c52857b214be246ff615c6293730033cfa", "target": 1, "func": "static int mpc8_probe ( AVProbeData * p ) \n { \n const uint8_t * bs = p -> buf + 4 ; \n const uint8_t * bs_end = bs + p -> buf_size ; \n int64_t size ; \n if ( p -> buf_size < 16 ) \n return 0 ; \n if ( AV_RL32 ( p -> buf ) != TAG_MPCK ) \n return 0 ; \n while ( bs < bs_end + 3 ) { \n int header_found = ( bs [ 0 ] == ' ' && bs [ 1 ] == ' ' ) ; \n if ( bs [ 0 ] < ' ' || bs [ 0 ] > ' ' || bs [ 1 ] < ' ' || bs [ 1 ] > ' ' ) \n return 0 ; \n bs += 2 ; \n size = bs_get_v ( & bs ) ; \n if ( size < 2 ) \n return 0 ; \n if ( bs + size - 2 >= bs_end ) \n return AVPROBE_SCORE_EXTENSION - 1 ; \n if ( header_found ) { \n if ( size < 11 || size > 28 ) \n return 0 ; \n if ( ! AV_RL32 ( bs ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n } else { \n bs += size - 2 ; \n } \n } \n return 0 ; \n }", "idx": 24823}
{"project": "FFmpeg", "commit_id": "002a7414b5852418f9a66245fc414c0416c4b4c1", "target": 0, "func": "static int decode_block ( MJpegDecodeContext * s , DCTELEM * block , \n int component , int dc_index , int ac_index , int16_t * quant_matrix ) \n { \n int code , i , j , level , val ; \n VLC * ac_vlc ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xffff ) { \n dprintf ( \" \\n \" ) ; \n return -1 ; \n } \n val = val * quant_matrix [ 0 ] + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n ac_vlc = & s -> vlcs [ 1 ] [ ac_index ] ; \n i = 0 ; \n { OPEN_READER ( re , & s -> gb )  \n for ( ; ; ) { \n UPDATE_CACHE ( re , & s -> gb ) ; \n GET_VLC ( code , re , & s -> gb , s -> vlcs [ 1 ] [ ac_index ] . table , 9 , 2 )  \n if ( code == 0x10 ) \n break ; \n if ( code == 0x100 ) { \n i += 16 ; \n } else { \n i += ( ( unsigned ) code ) >> 4 ; \n code &= 0xf ; \n if ( code > MIN_CACHE_BITS - 16 ) { \n UPDATE_CACHE ( re , & s -> gb )  \n } \n { \n int cache = GET_CACHE ( re , gb ) ; \n int sign = ( ~ cache ) >> 31 ; \n level = ( NEG_USR32 ( sign ^ cache , code ) ^ sign ) - sign ; \n } \n LAST_SKIP_BITS ( re , & s -> gb , code )  \n if ( i >= 63 ) { \n if ( i == 63 ) { \n j = s -> scantable . permutated [ 63 ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n break ; \n } \n dprintf ( \" \\n \" , i ) ; \n return -1 ; \n } \n j = s -> scantable . permutated [ i ] ; \n block [ j ] = level * quant_matrix [ j ] ; \n } \n } \n CLOSE_READER ( re , & s -> gb )  } \n return 0 ; \n }", "idx": 24826}
{"project": "FFmpeg", "commit_id": "e9b8523d52ca84d5012168db24fec2d50e73cf22", "target": 1, "func": "static int parse_fade ( struct sbg_parser * p , struct sbg_fade * fr ) \n { \n struct sbg_fade f ; \n if ( lex_char ( p , ' ' ) ) \n f . in = SBG_FADE_SILENCE ; \n else if ( lex_char ( p , ' ' ) ) \n f . in = SBG_FADE_SAME ; \n else if ( lex_char ( p , ' ' ) ) \n f . in = SBG_FADE_ADAPT ; \n else \n return 0 ; \n if ( lex_char ( p , ' ' ) ) \n f . out = SBG_FADE_SILENCE ; \n else if ( lex_char ( p , ' ' ) ) \n f . out = SBG_FADE_SAME ; \n else if ( lex_char ( p , ' ' ) ) \n f . out = SBG_FADE_ADAPT ; \n else \n return AVERROR_INVALIDDATA ; \n * fr = f ; \n return 1 ; \n }", "idx": 24832}
{"project": "FFmpeg", "commit_id": "eb5b0422b595d488f5c2f2a37a62cd46dfbb6aa7", "target": 0, "func": "static inline int clamp ( int value , int min , int max ) \n { \n if ( value < min ) \n return min ; \n else if ( value > max ) \n return max ; \n else \n return value ; \n }", "idx": 24839}
{"project": "FFmpeg", "commit_id": "3df18b3ed1177037892ce5b3db113d52dcdcdbf3", "target": 0, "func": "av_cold int ff_rv34_decode_init ( AVCodecContext * avctx ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n MpegEncContext * s = & r -> s ; \n MPV_decode_defaults ( s ) ; \n s -> avctx = avctx ; \n s -> out_format = FMT_H263 ; \n s -> codec_id = avctx -> codec_id ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n r -> s . avctx = avctx ; \n avctx -> flags |= CODEC_FLAG_EMU_EDGE ; \n r -> s . flags |= CODEC_FLAG_EMU_EDGE ; \n avctx -> pix_fmt = PIX_FMT_YUV420P ; \n avctx -> has_b_frames = 1 ; \n s -> low_delay = 0 ; \n if ( MPV_common_init ( s ) < 0 ) \n return -1 ; \n ff_h264_pred_init ( & r -> h , CODEC_ID_RV40 ) ; \n r -> intra_types_hist = av_malloc ( s -> b4_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ; \n r -> intra_types = r -> intra_types_hist + s -> b4_stride * 4 ; \n r -> mb_type = av_mallocz ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> mb_type ) ) ; \n r -> cbp_luma = av_malloc ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> cbp_luma ) ) ; \n r -> cbp_chroma = av_malloc ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> cbp_chroma ) ) ; \n r -> deblock_coefs = av_malloc ( r -> s . mb_stride * r -> s . mb_height * sizeof ( * r -> deblock_coefs ) ) ; \n if ( ! intra_vlcs [ 0 ] . cbppattern [ 0 ] . bits ) \n rv34_init_tables ( ) ; \n return 0 ; \n }", "idx": 24860}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_2r_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += output [ 3 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 4 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 24861}
{"project": "FFmpeg", "commit_id": "d8013f38ab73b15c5041f2489fc0b8bb45512e24", "target": 0, "func": "static int segment_start ( AVFormatContext * s ) \n { \n SegmentContext * seg = s -> priv_data ; \n AVFormatContext * oc = seg -> avf ; \n int err = 0 ; \n if ( seg -> wrap ) \n seg -> number %= seg -> wrap ; \n if ( av_get_frame_filename ( oc -> filename , sizeof ( oc -> filename ) , \n s -> filename , seg -> number ++ ) < 0 ) \n return AVERROR ( EINVAL ) ; \n if ( ( err = avio_open2 ( & oc -> pb , oc -> filename , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ) < 0 ) \n return err ; \n if ( ! oc -> priv_data && oc -> oformat -> priv_data_size > 0 ) { \n oc -> priv_data = av_mallocz ( oc -> oformat -> priv_data_size ) ; \n if ( ! oc -> priv_data ) { \n avio_close ( oc -> pb ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( oc -> oformat -> priv_class ) { \n * ( const AVClass * * ) oc -> priv_data = oc -> oformat -> priv_class ; \n av_opt_set_defaults ( oc -> priv_data ) ; \n } \n } \n if ( ( err = oc -> oformat -> write_header ( oc ) ) < 0 ) { \n goto fail ; \n } \n return 0 ; \n fail : \n av_log ( oc , AV_LOG_ERROR , \" \\n \" , \n oc -> filename ) ; \n avio_close ( oc -> pb ) ; \n av_freep ( & oc -> priv_data ) ; \n return err ; \n }", "idx": 24869}
{"project": "FFmpeg", "commit_id": "345cfd04d093d9fdec81ea3531e73b1f5c1b6a6c", "target": 1, "func": "void avcodec_free_context ( AVCodecContext * * pavctx ) \n { \n AVCodecContext * avctx = * pavctx ; \n if ( ! avctx ) \n return ; \n avcodec_close ( avctx ) ; \n av_freep ( & avctx -> extradata ) ; \n av_freep ( & avctx -> subtitle_header ) ; \n av_freep ( pavctx ) ; \n }", "idx": 24890}
{"project": "FFmpeg", "commit_id": "2d0bcfb412a618e8130fbfea15df76eb0f7dac45", "target": 1, "func": "void ff_mpeg_flush ( AVCodecContext * avctx ) { \n int i ; \n MpegEncContext * s = avctx -> priv_data ; \n if ( s == NULL || s -> picture == NULL ) \n return ; \n for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { \n if ( s -> picture [ i ] . data [ 0 ] && ( s -> picture [ i ] . type == FF_BUFFER_TYPE_INTERNAL \n || s -> picture [ i ] . type == FF_BUFFER_TYPE_USER ) ) \n avctx -> release_buffer ( avctx , ( AVFrame * ) & s -> picture [ i ] ) ; \n } \n s -> current_picture_ptr = s -> last_picture_ptr = s -> next_picture_ptr = NULL ; \n s -> mb_x = s -> mb_y = 0 ; \n s -> parse_context . state = -1 ; \n s -> parse_context . frame_start_found = 0 ; \n s -> parse_context . overread = 0 ; \n s -> parse_context . overread_index = 0 ; \n s -> parse_context . index = 0 ; \n s -> parse_context . last_index = 0 ; \n s -> bitstream_buffer_size = 0 ; \n }", "idx": 24891}
{"project": "FFmpeg", "commit_id": "224944895efe6ac23e3b8f9d35abfee9f5c6c440", "target": 0, "func": "static int get_packet_payload_size ( AVFormatContext * ctx , int stream_index , \n int64_t pts , int64_t dts ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n int buf_index ; \n StreamInfo * stream ; \n stream = ctx -> streams [ stream_index ] -> priv_data ; \n buf_index = 0 ; \n if ( ( ( s -> packet_number % s -> pack_header_freq ) == 0 ) ) { \n if ( s -> is_mpeg2 ) \n buf_index += 14 ; \n else \n buf_index += 12 ; \n if ( s -> is_vcd ) { \n if ( stream -> packet_number == 0 ) \n buf_index += 15 ; \n } else { \n if ( ( s -> packet_number % s -> system_header_freq ) == 0 ) \n buf_index += s -> system_header_size ; \n } \n } \n if ( s -> is_vcd && stream -> packet_number == 0 ) \n buf_index += s -> packet_size - buf_index ; \n else { \n buf_index += 6 ; \n if ( s -> is_mpeg2 ) \n buf_index += 3 ; \n if ( pts != AV_NOPTS_VALUE ) { \n if ( dts != pts ) \n buf_index += 5 + 5 ; \n else \n buf_index += 5 ; \n } else { \n if ( ! s -> is_mpeg2 ) \n buf_index ++ ; \n } \n if ( stream -> id < 0xc0 ) { \n buf_index += 4 ; \n if ( stream -> id >= 0xa0 ) { \n int n ; \n buf_index += 3 ; \n n = ( s -> packet_size - buf_index ) % stream -> lpcm_align ; \n if ( n ) \n buf_index += ( stream -> lpcm_align - n ) ; \n } \n } \n if ( s -> is_vcd && stream -> id == AUDIO_ID ) \n buf_index += 20 ; \n } \n return s -> packet_size - buf_index ; \n }", "idx": 24901}
{"project": "FFmpeg", "commit_id": "c7dd3e7e43555b2922481a9242a306c5b138d69c", "target": 0, "func": "static int opt_input_ts_scale ( const char * opt , const char * arg ) \n { \n unsigned int stream ; \n double scale ; \n char * p ; \n stream = strtol ( arg , & p , 0 ) ; \n if ( * p ) \n p ++ ; \n scale = strtod ( p , & p ) ; \n if ( stream >= MAX_STREAMS ) \n ffmpeg_exit ( 1 ) ; \n ts_scale = grow_array ( ts_scale , sizeof ( * ts_scale ) , & nb_ts_scale , stream + 1 ) ; \n ts_scale [ stream ] = scale ; \n return 0 ; \n }", "idx": 24911}
{"project": "FFmpeg", "commit_id": "5245c04da332ab9585133ad55f8ec7a06d43b0b0", "target": 0, "func": "static av_always_inline int normal_limit ( uint8_t * p , int stride , int E , int I ) \n { \n LOAD_PIXELS \n return  simple_limit ( p , stride , 2 * E + I ) \n && FFABS ( p3 - p2 ) <= I && FFABS ( p2 - p1 ) <= I && FFABS ( p1 - p0 ) <= I \n && FFABS ( q3 - q2 ) <= I && FFABS ( q2 - q1 ) <= I && FFABS ( q1 - q0 ) <= I ; \n }", "idx": 24912}
{"project": "FFmpeg", "commit_id": "8003816e1619e77d8de051883264aa090e0d78cc", "target": 0, "func": "static int mov_open_dref ( AVIOContext * * pb , const char * src , MOVDref * ref , \n AVIOInterruptCB * int_cb , int use_absolute_path , AVFormatContext * fc ) \n { \n if ( ref -> nlvl_to > 0 && ref -> nlvl_from > 0 ) { \n char filename [ 1024 ] ; \n const char * src_path ; \n int i , l ; \n src_path = strrchr ( src , ' ' ) ; \n if ( src_path ) \n src_path ++ ; \n else \n src_path = src ; \n for ( i = 0 , l = strlen ( ref -> path ) - 1 ; l >= 0 ; l -- ) \n if ( ref -> path [ l ] == ' ' ) { \n if ( i == ref -> nlvl_to - 1 ) \n break ; \n else \n i ++ ; \n } \n if ( i == ref -> nlvl_to - 1 && src_path - src < sizeof ( filename ) ) { \n memcpy ( filename , src , src_path - src ) ; \n filename [ src_path - src ] = 0 ; \n for ( i = 1 ; i < ref -> nlvl_from ; i ++ ) \n av_strlcat ( filename , \" \" , sizeof ( filename ) ) ; \n av_strlcat ( filename , ref -> path + l + 1 , sizeof ( filename ) ) ; \n if ( ! avio_open2 ( pb , filename , AVIO_FLAG_READ , int_cb , NULL ) ) \n return 0 ; \n } \n } else if ( use_absolute_path ) { \n av_log ( fc , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n if ( ! avio_open2 ( pb , ref -> path , AVIO_FLAG_READ , int_cb , NULL ) ) \n return 0 ; \n } \n return AVERROR ( ENOENT ) ; \n }", "idx": 24913}
{"project": "FFmpeg", "commit_id": "f61bece684d9685b07895508e6c1c733b5564ccf", "target": 0, "func": "int sws_setColorspaceDetails ( struct SwsContext * c , const int inv_table [ 4 ] , \n int srcRange , const int table [ 4 ] , int dstRange , \n int brightness , int contrast , int saturation ) \n { \n const AVPixFmtDescriptor * desc_dst = av_pix_fmt_desc_get ( c -> dstFormat ) ; \n const AVPixFmtDescriptor * desc_src = av_pix_fmt_desc_get ( c -> srcFormat ) ; \n memcpy ( c -> srcColorspaceTable , inv_table , sizeof ( int ) * 4 ) ; \n memcpy ( c -> dstColorspaceTable , table , sizeof ( int ) * 4 ) ; \n c -> brightness = brightness ; \n c -> contrast = contrast ; \n c -> saturation = saturation ; \n c -> srcRange = srcRange ; \n c -> dstRange = dstRange ; \n if ( isYUV ( c -> dstFormat ) || isGray ( c -> dstFormat ) ) \n return -1 ; \n c -> dstFormatBpp = av_get_bits_per_pixel ( desc_dst ) ; \n c -> srcFormatBpp = av_get_bits_per_pixel ( desc_src ) ; \n ff_yuv2rgb_c_init_tables ( c , inv_table , srcRange , brightness , \n contrast , saturation ) ; \n if ( HAVE_ALTIVEC && av_get_cpu_flags ( ) & AV_CPU_FLAG_ALTIVEC ) \n ff_yuv2rgb_init_tables_altivec ( c , inv_table , brightness , \n contrast , saturation ) ; \n return 0 ; \n }", "idx": 24915}
{"project": "FFmpeg", "commit_id": "27216bf314c62125c408be1a5a79e5c9dba88e76", "target": 1, "func": "static int submit_stats ( AVCodecContext * avctx ) \n { \n #ifdef TH_ENCCTL_2PASS_IN \n TheoraContext * h = avctx -> priv_data ; \n int bytes ; \n if ( ! avctx -> stats_in ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n h -> stats_size = strlen ( avctx -> stats_in ) * 3 / 4 ; \n h -> stats = av_malloc ( h -> stats_size ) ; \n h -> stats_size = av_base64_decode ( h -> stats , avctx -> stats_in , h -> stats_size ) ; \n while ( h -> stats_size - h -> stats_offset > 0 ) { \n bytes = th_encode_ctl ( h -> t_state , TH_ENCCTL_2PASS_IN , \n h -> stats + h -> stats_offset , \n h -> stats_size - h -> stats_offset ) ; \n if ( bytes < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_EXTERNAL ; \n if ( ! bytes ) \n return 0 ; \n h -> stats_offset += bytes ; \n return 0 ; \n #else  \n  \n  av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSUP ) ; \n #endif  \n ", "idx": 24919}
{"project": "FFmpeg", "commit_id": "40fa6a2fa2c255293a780a194eecae5df52644a1", "target": 1, "func": "static int decode_dc_progressive ( MJpegDecodeContext * s , int16_t * block , \n int component , int dc_index , \n uint16_t * quant_matrix , int Al ) \n { \n int val ; \n s -> bdsp . clear_block ( block ) ; \n val = mjpeg_decode_dc ( s , dc_index ) ; \n if ( val == 0xfffff ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n val = ( val * ( quant_matrix [ 0 ] << Al ) ) + s -> last_dc [ component ] ; \n s -> last_dc [ component ] = val ; \n block [ 0 ] = val ; \n return 0 ; \n }", "idx": 24945}
{"project": "FFmpeg", "commit_id": "8824b7370a9fb72f9c699c3751a5ceb56e0cc41d", "target": 1, "func": "static void vp7_idct_add_c ( uint8_t * dst , int16_t block [ 16 ] , ptrdiff_t stride ) \n { \n int i , a1 , b1 , c1 , d1 ; \n int16_t tmp [ 16 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n a1 = ( block [ i * 4 + 0 ] + block [ i * 4 + 2 ] ) * 23170 ; \n b1 = ( block [ i * 4 + 0 ] - block [ i * 4 + 2 ] ) * 23170 ; \n c1 = block [ i * 4 + 1 ] * 12540 - block [ i * 4 + 3 ] * 30274 ; \n d1 = block [ i * 4 + 1 ] * 30274 + block [ i * 4 + 3 ] * 12540 ; \n AV_ZERO64 ( block + i * 4 ) ; \n tmp [ i * 4 + 0 ] = ( a1 + d1 ) >> 14 ; \n tmp [ i * 4 + 3 ] = ( a1 - d1 ) >> 14 ; \n tmp [ i * 4 + 1 ] = ( b1 + c1 ) >> 14 ; \n tmp [ i * 4 + 2 ] = ( b1 - c1 ) >> 14 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n a1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ; \n b1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ; \n c1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ; \n d1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ; \n dst [ 0 * stride + i ] = av_clip_uint8 ( dst [ 0 * stride + i ] + \n ( ( a1 + d1 + 0x20000 ) >> 18 ) ) ; \n dst [ 3 * stride + i ] = av_clip_uint8 ( dst [ 3 * stride + i ] + \n ( ( a1 - d1 + 0x20000 ) >> 18 ) ) ; \n dst [ 1 * stride + i ] = av_clip_uint8 ( dst [ 1 * stride + i ] + \n ( ( b1 + c1 + 0x20000 ) >> 18 ) ) ; \n dst [ 2 * stride + i ] = av_clip_uint8 ( dst [ 2 * stride + i ] + \n ( ( b1 - c1 + 0x20000 ) >> 18 ) ) ; \n } \n }", "idx": 24949}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , \n int chrFilterSize , const int16_t * * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , long dstW , long chrDstW ) \n { \n if ( uDest ) { \n YSCALEYUV2YV12X ( CHR_MMX_FILTER_OFFSET , uDest , chrDstW , 0 )  \n YSCALEYUV2YV12X ( CHR_MMX_FILTER_OFFSET , vDest , chrDstW + c -> uv_off , c -> uv_off )  \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) { \n YSCALEYUV2YV12X ( ALP_MMX_FILTER_OFFSET , aDest , dstW , 0 )  \n } \n YSCALEYUV2YV12X ( LUM_MMX_FILTER_OFFSET , dest , dstW , 0 )  \n }", "idx": 24952}
{"project": "FFmpeg", "commit_id": "7a2efd2e447d5e7c7c0af61417a838b042fb7d0a", "target": 0, "func": "int av_cold ff_mlp_init_crc2D ( AVCodecParserContext * s ) \n { \n if ( ! crc_init_2D ) { \n av_crc_init ( crc_2D , 0 , 16 , 0x002D , sizeof ( crc_2D ) ) ; \n crc_init_2D = 1 ; \n } \n return 0 ; \n }", "idx": 24957}
{"project": "FFmpeg", "commit_id": "5a31f2318b8fed1f4711cb86eab6d9b679946878", "target": 1, "func": "static AVStream * add_av_stream1 ( FFServerStream * stream , \n AVCodecContext * codec , int copy ) \n { \n AVStream * fst ; \n if ( stream -> nb_streams >= FF_ARRAY_ELEMS ( stream -> streams ) ) \n return NULL ; \n fst = av_mallocz ( sizeof ( AVStream ) ) ; \n if ( ! fst ) \n return NULL ; \n if ( copy ) { \n fst -> codec = avcodec_alloc_context3 ( codec -> codec ) ; \n if ( ! fst -> codec ) { \n av_free ( fst ) ; \n return NULL ; \n } \n avcodec_copy_context ( fst -> codec , codec ) ; \n } else \n fst -> codec = codec ; \n fst -> priv_data = av_mallocz ( sizeof ( FeedData ) ) ; \n fst -> index = stream -> nb_streams ; \n avpriv_set_pts_info ( fst , 33 , 1 , 90000 ) ; \n fst -> sample_aspect_ratio = codec -> sample_aspect_ratio ; \n stream -> streams [ stream -> nb_streams ++ ] = fst ; \n return fst ; \n }", "idx": 24961}
{"project": "FFmpeg", "commit_id": "fc78b0cb7e115ae494861c37a9928cff74df8db9", "target": 1, "func": "static void finalize_packet ( RTPDemuxContext * s , AVPacket * pkt , uint32_t timestamp ) \n { \n if ( s -> last_rtcp_ntp_time != AV_NOPTS_VALUE ) { \n int64_t addend ; \n int delta_timestamp ; \n delta_timestamp = timestamp - s -> last_rtcp_timestamp ; \n addend = av_rescale ( s -> last_rtcp_ntp_time - s -> first_rtcp_ntp_time , s -> st -> time_base . den , ( uint64_t ) s -> st -> time_base . num << 32 ) ; \n pkt -> pts = addend + delta_timestamp ; \n } \n }", "idx": 24975}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_v_loop_filter_chroma_intra_c ( uint8_t * pix , int stride , int alpha , int beta ) \n { \n h264_loop_filter_chroma_intra_c ( pix , stride , 1 , alpha , beta ) ; \n }", "idx": 24977}
{"project": "FFmpeg", "commit_id": "e71ca21f308432cac3deaabe522ac1b856471162", "target": 1, "func": "static av_always_inline int small_diamond_search ( MpegEncContext * s , int * best , int dmin , \n int src_index , int ref_index , int const penalty_factor , \n int size , int h , int flags ) \n { \n MotionEstContext * const c = & s -> me ; \n me_cmp_func cmpf , chroma_cmpf ; \n int next_dir = -1 ; \n LOAD_COMMON \n LOAD_COMMON2  \n unsigned map_generation = c -> map_generation ; \n cmpf = s -> mecc . me_cmp [ size ] ; \n chroma_cmpf = s -> mecc . me_cmp [ size + 1 ] ; \n { \n const unsigned key = ( best [ 1 ] << ME_MAP_MV_BITS ) + best [ 0 ] + map_generation ; \n const int index = ( ( best [ 1 ] << ME_MAP_SHIFT ) + best [ 0 ] ) & ( ME_MAP_SIZE - 1 ) ; \n if ( map [ index ] != key ) { \n score_map [ index ] = cmp ( s , best [ 0 ] , best [ 1 ] , 0 , 0 , size , h , ref_index , src_index , cmpf , chroma_cmpf , flags ) ; \n map [ index ] = key ; \n } \n } \n for ( ; ; ) { \n int d ; \n const int dir = next_dir ; \n const int x = best [ 0 ] ; \n const int y = best [ 1 ] ; \n next_dir = -1 ; \n if ( dir != 2 && x > xmin ) CHECK_MV_DIR ( x - 1 , y , 0 )  \n if ( dir != 3 && y > ymin ) CHECK_MV_DIR ( x , y - 1 , 1 )  \n if ( dir != 0 && x < xmax ) CHECK_MV_DIR ( x + 1 , y , 2 )  \n if ( dir != 1 && y < ymax ) CHECK_MV_DIR ( x , y + 1 , 3 )  \n if ( next_dir == -1 ) { \n return dmin ; \n } \n } \n }", "idx": 24981}
{"project": "FFmpeg", "commit_id": "0886267e3cc4ce12bcd48b712d8affa8c953bc38", "target": 1, "func": "static void opt_frame_aspect_ratio ( const char * arg ) \n { \n int x = 0 , y = 0 ; \n double ar = 0 ; \n const char * p ; \n char * end ; \n p = strchr ( arg , ' ' ) ; \n if ( p ) { \n x = strtol ( arg , & end , 10 ) ; \n if ( end == p ) \n y = strtol ( end + 1 , & end , 10 ) ; \n if ( x > 0 && y > 0 ) \n ar = ( double ) x / ( double ) y ; \n } else \n ar = strtod ( arg , NULL ) ; \n if ( ! ar ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n frame_aspect_ratio = ar ; \n x = vfilters ? strlen ( vfilters ) : 0 ; \n vfilters = av_realloc ( vfilters , x + 100 ) ; \n snprintf ( vfilters + x , x + 100 , \" \\n \" , x ? ' ' : ' ' , ar ) ; \n }", "idx": 24984}
{"project": "FFmpeg", "commit_id": "b51469a0c54b30079eecc4891cc050778f343683", "target": 0, "func": "static int tcp_write ( URLContext * h , uint8_t * buf , int size ) \n { \n TCPContext * s = h -> priv_data ; \n int ret , size1 , fd_max ; \n fd_set wfds ; \n struct timeval tv ; \n size1 = size ; \n while ( size > 0 ) { \n if ( url_interrupt_cb ( ) ) \n return - EINTR ; \n fd_max = s -> fd ; \n FD_ZERO ( & wfds ) ; \n FD_SET ( s -> fd , & wfds ) ; \n tv . tv_sec = 0 ; \n tv . tv_usec = 100 * 1000 ; \n select ( fd_max + 1 , NULL , & wfds , NULL , & tv ) ; \n #ifdef __BEOS__ \n ret = send ( s -> fd , buf , size , 0 ) ; \n #else \n ret = write ( s -> fd , buf , size ) ; \n #endif \n if ( ret < 0 ) { \n if ( errno != EINTR && errno != EAGAIN ) { \n #ifdef __BEOS__ \n return errno ; \n #else \n return - errno ; \n #endif \n } \n continue ; \n } \n size -= ret ; \n buf += ret ; \n } \n return size1 - size ; \n }", "idx": 24986}
{"project": "FFmpeg", "commit_id": "17ba719d9ba30c970f65747f42d5fbb1e447ca28", "target": 1, "func": "static av_cold int mm_decode_init ( AVCodecContext * avctx ) \n { \n MmContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n s -> frame = av_frame_alloc ( ) ; \n if ( ! s -> frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; ", "idx": 24988}
{"project": "FFmpeg", "commit_id": "3d2515a8f3ba35f10a69d077936770955b5394da", "target": 0, "func": "static int split_init ( AVFilterContext * ctx , const char * args , void * opaque ) \n { \n int i , nb_outputs = 2 ; \n if ( args ) { \n nb_outputs = strtol ( args , NULL , 0 ) ; \n if ( nb_outputs <= 0 ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n nb_outputs ) ; \n return AVERROR ( EINVAL ) ; \n } \n } \n for ( i = 0 ; i < nb_outputs ; i ++ ) { \n char name [ 32 ] ; \n AVFilterPad pad = { 0 } ; \n snprintf ( name , sizeof ( name ) , \" \" , i ) ; \n pad . type = ! strcmp ( ctx -> name , \" \" ) ? AVMEDIA_TYPE_VIDEO : AVMEDIA_TYPE_AUDIO ; \n pad . name = av_strdup ( name ) ; \n avfilter_insert_outpad ( ctx , i , & pad ) ; \n } \n return 0 ; \n }", "idx": 25000}
{"project": "FFmpeg", "commit_id": "8aeb33225aed5a0da03f9145a09ca1bbd6ac6532", "target": 0, "func": "static void draw_slice ( AVFilterLink * link , int y , int h ) \n { \n ScaleContext * scale = link -> dst -> priv ; \n int out_h ; \n AVFilterPicRef * cur_pic = link -> cur_pic ; \n uint8_t * data [ 4 ] ; \n if ( ! scale -> slice_dir ) { \n if ( y != 0 && y + h != link -> h ) { \n av_log ( scale , AV_LOG_ERROR , \" \\n \" ) ; \n return ; \n } \n scale -> slice_dir = y ? -1 : 1 ; \n scale -> slice_y = y ? link -> dst -> outputs [ 0 ] -> h : y ; \n } \n data [ 0 ] = cur_pic -> data [ 0 ] + y * cur_pic -> linesize [ 0 ] ; \n data [ 1 ] = scale -> input_is_pal ? \n cur_pic -> data [ 1 ] : \n cur_pic -> data [ 1 ] + ( y >> scale -> vsub ) * cur_pic -> linesize [ 1 ] ; \n data [ 2 ] = cur_pic -> data [ 2 ] + ( y >> scale -> vsub ) * cur_pic -> linesize [ 2 ] ; \n data [ 3 ] = cur_pic -> data [ 3 ] + y * cur_pic -> linesize [ 3 ] ; \n out_h = sws_scale ( scale -> sws , data , cur_pic -> linesize , y , h , \n link -> dst -> outputs [ 0 ] -> outpic -> data , \n link -> dst -> outputs [ 0 ] -> outpic -> linesize ) ; \n if ( scale -> slice_dir == -1 ) \n scale -> slice_y -= out_h ; \n avfilter_draw_slice ( link -> dst -> outputs [ 0 ] , scale -> slice_y , out_h ) ; \n if ( scale -> slice_dir == 1 ) \n scale -> slice_y += out_h ; \n }", "idx": 25029}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2yuvXinC ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , int dstW , int chrDstW ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( uDest ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ i ] = av_clip_uint8 ( u >> 19 ) ; \n vDest [ i ] = av_clip_uint8 ( v >> 19 ) ; \n } \n }", "idx": 25038}
{"project": "FFmpeg", "commit_id": "b69b43e2c471c4febbffaf313875396256b6a51e", "target": 1, "func": "static void check_decode_result ( int * got_output , int ret ) \n { \n if ( * got_output || ret < 0 ) \n decode_error_stat [ ret < 0 ] ++ ; \n if ( ret < 0 && exit_on_error ) \n exit_program ( 1 ) ; \n }", "idx": 25040}
{"project": "FFmpeg", "commit_id": "2e59ffbb7964214e192a9f77c4445ff29c6510d7", "target": 1, "func": "static int mace_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n AVFrame * frame = data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n int16_t * * samples ; \n MACEContext * ctx = avctx -> priv_data ; \n int i , j , k , l , ret ; \n int is_mace3 = ( avctx -> codec_id == AV_CODEC_ID_MACE3 ) ; \n frame -> nb_samples = 3 * ( buf_size << ( 1 - is_mace3 ) ) / avctx -> channels ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n return ret ; \n samples = ( int16_t * * ) frame -> extended_data ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) { \n int16_t * output = samples [ i ] ; \n for ( j = 0 ; j < buf_size / ( avctx -> channels << is_mace3 ) ; j ++ ) \n for ( k = 0 ; k < ( 1 << is_mace3 ) ; k ++ ) { \n uint8_t pkt = buf [ ( i << is_mace3 ) + \n ( j * avctx -> channels << is_mace3 ) + k ] ; \n uint8_t val [ 2 ] [ 3 ] = { { pkt >> 5 , ( pkt >> 3 ) & 3 , pkt & 7 } , \n { pkt & 7 , ( pkt >> 3 ) & 3 , pkt >> 5 } } ; \n for ( l = 0 ; l < 3 ; l ++ ) { \n if ( is_mace3 ) \n chomp3 ( & ctx -> chd [ i ] , output , val [ 1 ] [ l ] , l ) ; \n else \n chomp6 ( & ctx -> chd [ i ] , output , val [ 0 ] [ l ] , l ) ; \n output += 1 << ( 1 - is_mace3 ) ; \n * got_frame_ptr = 1 ; \n return buf_size ;", "idx": 25043}
{"project": "FFmpeg", "commit_id": "be524ffc16bf14cab0ad112b0dcb48d09a2a40ff", "target": 1, "func": "static av_cold int rv30_decode_init ( AVCodecContext * avctx ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n int ret ; \n r -> rv30 = 1 ; \n if ( ( ret = ff_rv34_decode_init ( avctx ) ) < 0 ) \n return ret ; \n if ( avctx -> extradata_size < 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n r -> max_rpr = avctx -> extradata [ 1 ] & 7 ; \n r -> parse_slice_header = rv30_parse_slice_header ; \n r -> decode_intra_types = rv30_decode_intra_types ; \n r -> decode_mb_info = rv30_decode_mb_info ; \n r -> loop_filter = rv30_loop_filter ; \n r -> luma_dc_quant_i = rv30_luma_dc_quant ; \n r -> luma_dc_quant_p = rv30_luma_dc_quant ; \n return 0 ;", "idx": 25044}
{"project": "FFmpeg", "commit_id": "f66f3819b96847cd28589b718dbcd03b782e7a5c", "target": 1, "func": "static int vid_probe ( AVProbeData * p ) \n { \n if ( AV_RL32 ( p -> buf ) != MKTAG ( ' ' , ' ' , ' ' , 0 ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 25053}
{"project": "FFmpeg", "commit_id": "6138ed777db101c26d19b96e6a27b8499ab9f4e7", "target": 1, "func": "static int decode_residual_block ( AVSContext * h , GetBitContext * gb , \n const dec_2dvlc_t * r , int esc_golomb_order , \n int qp , uint8_t * dst , int stride ) { \n int i , level_code , esc_code , level , run , mask ; \n DCTELEM level_buf [ 64 ] ; \n uint8_t run_buf [ 64 ] ; \n DCTELEM * block = h -> block ; \n for ( i = 0 ; i < 65 ; i ++ ) { \n level_code = get_ue_code ( gb , r -> golomb_order ) ; \n if ( level_code >= ESCAPE_CODE ) { \n run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 ; \n esc_code = get_ue_code ( gb , esc_golomb_order ) ; \n level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ) ; \n while ( level > r -> inc_limit ) \n r ++ ; \n mask = - ( level_code & 1 ) ; \n level = ( level ^ mask ) - mask ; \n } else { \n level = r -> rltab [ level_code ] [ 0 ] ; \n if ( ! level ) \n break ; \n run = r -> rltab [ level_code ] [ 1 ] ; \n r += r -> rltab [ level_code ] [ 2 ] ; \n } \n level_buf [ i ] = level ; \n run_buf [ i ] = run ; \n } \n if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , \n ff_cavs_dequant_shift [ qp ] , i ) ) \n return -1 ; \n h -> s . dsp . cavs_idct8_add ( dst , block , stride ) ; \n return 0 ; \n }", "idx": 25064}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int swf_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 16 ) \n return 0 ; \n if ( ( p -> buf [ 0 ] == ' ' || p -> buf [ 0 ] == ' ' ) && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 25069}
{"project": "FFmpeg", "commit_id": "4240e6a92117811509be3e5f360a44dde8618040", "target": 0, "func": "static int16_t * precalc_coefs ( double dist25 , int depth ) \n { \n int i ; \n double gamma , simil , C ; \n int16_t * ct = av_malloc ( ( 512 << LUT_BITS ) * sizeof ( int16_t ) ) ; \n if ( ! ct ) \n return NULL ; \n gamma = log ( 0.25 ) / log ( 1.0 - FFMIN ( dist25 , 252.0 ) / 255.0 - 0.00001 ) ; \n for ( i = -255 << LUT_BITS ; i <= 255 << LUT_BITS ; i ++ ) { \n double f = ( ( i << ( 9 - LUT_BITS ) ) + ( 1 << ( 8 - LUT_BITS ) ) - 1 ) / 512.0 ; \n simil = 1.0 - FFABS ( f ) / 255.0 ; \n C = pow ( simil , gamma ) * 256.0 * f ; \n ct [ ( 256 << LUT_BITS ) + i ] = lrint ( C ) ; \n } \n ct [ 0 ] = ! ! dist25 ; \n return ct ; \n }", "idx": 25070}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_value ( AVFormatContext * s , uint8_t * name , uint16_t name_len , \n uint16_t val_len , int type , AVDictionary * * met ) \n { \n int ret ; \n uint8_t * value ; \n uint16_t buflen = 2 * val_len + 1 ; \n AVIOContext * pb = s -> pb ; \n value = av_malloc ( buflen ) ; \n if ( ! value ) \n return AVERROR ( ENOMEM ) ; \n if ( type == ASF_UNICODE ) { \n if ( ( ret = get_asf_string ( pb , val_len , value , buflen ) ) < 0 ) \n goto failed ; \n if ( av_dict_set ( met , name , value , 0 ) < 0 ) \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n } else { \n char buf [ 256 ] ; \n if ( val_len > sizeof ( buf ) ) { \n ret = AVERROR_INVALIDDATA ; \n goto failed ; \n } \n if ( ( ret = avio_read ( pb , value , val_len ) ) < 0 ) \n goto failed ; \n if ( ret < 2 * val_len ) \n value [ ret ] = ' \\0 ' ; \n else \n value [ 2 * val_len - 1 ] = ' \\0 ' ; \n snprintf ( buf , sizeof ( buf ) , \" \" , value ) ; \n if ( av_dict_set ( met , name , buf , 0 ) < 0 ) \n av_log ( s , AV_LOG_WARNING , \" \\n \" ) ; \n } \n av_freep ( & value ) ; \n return 0 ; \n failed : \n av_freep ( & value ) ; \n return ret ; \n }", "idx": 25073}
{"project": "FFmpeg", "commit_id": "c4c0245686bc2fcc545644101c7b328fed71f268", "target": 1, "func": "static int estimate_sid_gain ( G723_1_Context * p ) \n { \n int i , shift , seg , seg2 , t , val , val_add , x , y ; \n shift = 16 - p -> cur_gain * 2 ; \n if ( shift > 0 ) \n t = p -> sid_gain << shift ; \n else \n t = p -> sid_gain >> - shift ; \n x = av_clipl_int32 ( t * ( int64_t ) cng_filt [ 0 ] >> 16 ) ; \n if ( x >= cng_bseg [ 2 ] ) \n return 0x3F ; \n if ( x >= cng_bseg [ 1 ] ) { \n shift = 4 ; \n seg = 3 ; \n } else { \n shift = 3 ; \n seg = ( x >= cng_bseg [ 0 ] ) ; \n } \n seg2 = FFMIN ( seg , 3 ) ; \n val = 1 << shift ; \n val_add = val >> 1 ; \n for ( i = 0 ; i < shift ; i ++ ) { \n t = seg * 32 + ( val << seg2 ) ; \n t *= t ; \n if ( x >= t ) \n val += val_add ; \n else \n val -= val_add ; \n val_add >>= 1 ; \n } \n t = seg * 32 + ( val << seg2 ) ; \n y = t * t - x ; \n if ( y <= 0 ) { \n t = seg * 32 + ( val + 1 << seg2 ) ; \n t = t * t - x ; \n val = ( seg2 - 1 << 4 ) + val ; \n if ( t >= y ) \n val ++ ; \n } else { \n t = seg * 32 + ( val - 1 << seg2 ) ; \n t = t * t - x ; \n val = ( seg2 - 1 << 4 ) + val ; \n if ( t >= y ) \n val -- ; \n } \n return val ; \n }", "idx": 25084}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int au_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n int ret ; \n ret = av_get_packet ( s -> pb , pkt , BLOCK_SIZE * \n s -> streams [ 0 ] -> codec -> channels * \n av_get_bits_per_sample ( s -> streams [ 0 ] -> codec -> codec_id ) >> 3 ) ; \n if ( ret < 0 ) \n return ret ; \n pkt -> stream_index = 0 ; \n pkt -> size = ret ; \n return 0 ; \n }", "idx": 25087}
{"project": "FFmpeg", "commit_id": "a606f27f4c610708fa96e35eed7b7537d3d8f712", "target": 0, "func": "int avio_read_partial ( AVIOContext * s , unsigned char * buf , int size ) \n { \n int len ; \n if ( size < 0 ) \n return -1 ; \n if ( s -> read_packet && s -> write_flag ) { \n len = s -> read_packet ( s -> opaque , buf , size ) ; \n if ( len > 0 ) \n s -> pos += len ; \n return len ; \n } \n len = s -> buf_end - s -> buf_ptr ; \n if ( len == 0 ) { \n s -> buf_end = s -> buf_ptr = s -> buffer ; \n fill_buffer ( s ) ; \n len = s -> buf_end - s -> buf_ptr ; \n } \n if ( len > size ) \n len = size ; \n memcpy ( buf , s -> buf_ptr , len ) ; \n s -> buf_ptr += len ; \n if ( ! len ) { \n if ( s -> error ) return s -> error ; \n if ( avio_feof ( s ) ) return AVERROR_EOF ; \n } \n return len ; \n }", "idx": 25096}
{"project": "FFmpeg", "commit_id": "5b0fc078191138795e817244555741356f9d12e9", "target": 1, "func": "static av_cold int vp9_decode_free ( AVCodecContext * ctx ) \n { \n VP9Context * s = ctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( s -> frames [ i ] . tf . f -> data [ 0 ] ) \n vp9_unref_frame ( ctx , & s -> frames [ i ] ) ; \n av_frame_free ( & s -> frames [ i ] . tf . f ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n if ( s -> refs [ i ] . f -> data [ 0 ] ) \n ff_thread_release_buffer ( ctx , & s -> refs [ i ] ) ; \n av_frame_free ( & s -> refs [ i ] . f ) ; \n if ( s -> next_refs [ i ] . f -> data [ 0 ] ) \n ff_thread_release_buffer ( ctx , & s -> next_refs [ i ] ) ; \n av_frame_free ( & s -> next_refs [ i ] . f ) ; \n } \n av_freep ( & s -> above_partition_ctx ) ; \n av_freep ( & s -> c_b ) ; \n s -> c_b_size = 0 ; \n av_freep ( & s -> b_base ) ; \n av_freep ( & s -> block_base ) ; \n return 0 ; \n }", "idx": 25124}
{"project": "FFmpeg", "commit_id": "bc574408dc011943b82de012451f95266bed9989", "target": 1, "func": "int url_open ( URLContext * * puc , const char * filename , int flags ) \n { \n URLProtocol * up ; \n const char * p ; \n char proto_str [ 128 ] , * q ; \n p = filename ; \n q = proto_str ; \n while ( * p != ' \\0 ' && * p != ' ' ) { \n if ( ! isalpha ( * p ) ) \n goto file_proto ; \n if ( ( q - proto_str ) < sizeof ( proto_str ) - 1 ) \n * q ++ = * p ; \n p ++ ; \n } \n if ( * p == ' \\0 ' || ( q - proto_str ) <= 1 ) { \n file_proto : \n strcpy ( proto_str , \" \" ) ; \n } else { \n * q = ' \\0 ' ; \n } \n up = first_protocol ; \n while ( up != NULL ) { \n if ( ! strcmp ( proto_str , up -> name ) ) \n return url_open_protocol ( puc , up , filename , flags ) ; \n up = up -> next ; \n } \n * puc = NULL ; \n return AVERROR ( ENOENT ) ; \n }", "idx": 25141}
{"project": "FFmpeg", "commit_id": "f15e6b869fc1ff3ffef1b1ac7b394e2155b5fafe", "target": 1, "func": "struct SwsContext * sws_getContext ( int srcW , int srcH , int srcFormat , \n int dstW , int dstH , int dstFormat , \n int flags , SwsFilter * srcFilter , \n SwsFilter * dstFilter , double * param ) \n { \n struct SwsContext * ctx ; \n ctx = av_malloc ( sizeof ( struct SwsContext ) ) ; \n if ( ctx ) \n ctx -> av_class = av_mallocz ( sizeof ( AVClass ) ) ; \n if ( ! ctx || ! ctx -> av_class ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return NULL ; \n } \n if ( ( srcH != dstH ) || ( srcW != dstW ) ) { \n if ( ( srcFormat != PIX_FMT_YUV420P ) || ( dstFormat != PIX_FMT_YUV420P ) ) { \n av_log ( NULL , AV_LOG_INFO , \" \\n \" ) ; \n } \n ctx -> resampling_ctx = img_resample_init ( dstW , dstH , srcW , srcH ) ; \n } else { \n ctx -> resampling_ctx = av_malloc ( sizeof ( ImgReSampleContext ) ) ; \n ctx -> resampling_ctx -> iheight = srcH ; \n ctx -> resampling_ctx -> iwidth = srcW ; \n ctx -> resampling_ctx -> oheight = dstH ; \n ctx -> resampling_ctx -> owidth = dstW ; \n } \n ctx -> src_pix_fmt = srcFormat ; \n ctx -> dst_pix_fmt = dstFormat ; \n return ctx ; \n }", "idx": 25143}
{"project": "FFmpeg", "commit_id": "3aac5fcfa9d3748659d78ab2a66d0ccce22cfd4f", "target": 1, "func": "void av_opt_freep_ranges ( AVOptionRanges * * rangesp ) \n { \n int i ; \n AVOptionRanges * ranges = * rangesp ; \n if ( ! ranges ) \n return ; \n for ( i = 0 ; i < ranges -> nb_ranges * ranges -> nb_components ; i ++ ) { \n AVOptionRange * range = ranges -> range [ i ] ; \n av_freep ( & range -> str ) ; \n av_freep ( & ranges -> range [ i ] ) ; \n } \n av_freep ( & ranges -> range ) ; \n av_freep ( rangesp ) ; \n }", "idx": 25145}
{"project": "FFmpeg", "commit_id": "a4696aa2fe88c21927835e59d543eb2efbfabaef", "target": 1, "func": "static void rtcp_send_sr ( AVFormatContext * s1 , int64_t ntp_time ) \n { \n RTPDemuxContext * s = s1 -> priv_data ; \n uint32_t rtp_ts ; \n #if defined ( DEBUG )  \n  \n  printf ( \" \" PRIx64 \" \\n \" , s -> payload_type , ntp_time , s -> timestamp ) ; \n #endif \n if ( s -> first_rtcp_ntp_time == AV_NOPTS_VALUE ) s -> first_rtcp_ntp_time = ntp_time ; \n s -> last_rtcp_ntp_time = ntp_time ; \n rtp_ts = av_rescale_q ( ntp_time - s -> first_rtcp_ntp_time , AV_TIME_BASE_Q , \n s1 -> streams [ 0 ] -> time_base ) + s -> base_timestamp ; \n put_byte ( s1 -> pb , ( RTP_VERSION << 6 ) ) ; \n put_byte ( s1 -> pb , 200 ) ; \n put_be16 ( s1 -> pb , 6 ) ; \n put_be32 ( s1 -> pb , s -> ssrc ) ; \n put_be32 ( s1 -> pb , ntp_time / 1000000 ) ; \n put_be32 ( s1 -> pb , ( ( ntp_time % 1000000 ) << 32 ) / 1000000 ) ; \n put_be32 ( s1 -> pb , rtp_ts ) ; \n put_be32 ( s1 -> pb , s -> packet_count ) ; \n put_be32 ( s1 -> pb , s -> octet_count ) ; \n put_flush_packet ( s1 -> pb ) ; \n }", "idx": 25156}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_2r_to_dolby ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] -= samples [ i + 512 ] ; \n samples [ i + 256 ] += samples [ i + 768 ] ; \n samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 25175}
{"project": "FFmpeg", "commit_id": "f4aa8085f23c3abff3114d7bf638698d42110526", "target": 1, "func": "av_cold void ff_psy_end ( FFPsyContext * ctx ) \n { \n if ( ctx -> model -> end ) \n ctx -> model -> end ( ctx ) ; \n av_freep ( & ctx -> bands ) ; \n av_freep ( & ctx -> num_bands ) ; \n av_freep ( & ctx -> group ) ; \n av_freep ( & ctx -> ch ) ; \n }", "idx": 25180}
{"project": "FFmpeg", "commit_id": "ce1ebb31a9a0e556a89cd7681082af19fbc1cced", "target": 0, "func": "static unsigned tget_short ( GetByteContext * gb , int le ) \n { \n unsigned v = le ? bytestream2_get_le16u ( gb ) : bytestream2_get_be16u ( gb ) ; \n return v ; \n }", "idx": 25208}
{"project": "FFmpeg", "commit_id": "073811cdd29e365498b3455ee4e0eda4b957a957", "target": 0, "func": "static int decode_syncpoint ( NUTContext * nut , int64_t * ts , int64_t * back_ptr ) { \n AVFormatContext * s = nut -> avf ; \n ByteIOContext * bc = & s -> pb ; \n int64_t end , tmp ; \n AVRational time_base ; \n nut -> last_syncpoint_pos = url_ftell ( bc ) - 8 ; \n end = get_packetheader ( nut , bc , 1 ) ; \n end += url_ftell ( bc ) ; \n tmp = get_v ( bc ) ; \n * back_ptr = nut -> last_syncpoint_pos - 16 * get_v ( bc ) ; \n if ( * back_ptr < 0 ) \n return -1 ; \n ff_nut_reset_ts ( nut , nut -> time_base [ tmp % nut -> time_base_count ] , tmp ) ; \n if ( skip_reserved ( bc , end ) || get_checksum ( bc ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n * ts = tmp / s -> nb_streams * av_q2d ( nut -> time_base [ tmp % s -> nb_streams ] ) * AV_TIME_BASE ; \n add_sp ( nut , nut -> last_syncpoint_pos , * back_ptr , * ts ) ; \n return 0 ; \n }", "idx": 25227}
{"project": "FFmpeg", "commit_id": "6950cca97fed890ec56259a2f868f37b65513d92", "target": 0, "func": "int av_image_fill_linesizes ( int linesizes [ 4 ] , enum PixelFormat pix_fmt , int width ) \n { \n int i ; \n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ; \n int max_step [ 4 ] ; \n int max_step_comp [ 4 ] ; \n memset ( linesizes , 0 , 4 * sizeof ( linesizes [ 0 ] ) ) ; \n if ( desc -> flags & PIX_FMT_HWACCEL ) \n return AVERROR ( EINVAL ) ; \n if ( desc -> flags & PIX_FMT_BITSTREAM ) { \n linesizes [ 0 ] = ( width * ( desc -> comp [ 0 ] . step_minus1 + 1 ) + 7 ) >> 3 ; \n return 0 ; \n } \n av_image_fill_max_pixsteps ( max_step , max_step_comp , desc ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n int s = ( max_step_comp [ i ] == 1 || max_step_comp [ i ] == 2 ) ? desc -> log2_chroma_w : 0 ; \n linesizes [ i ] = max_step [ i ] * ( ( ( width + ( 1 << s ) - 1 ) ) >> s ) ; \n } \n return 0 ; \n }", "idx": 25228}
{"project": "FFmpeg", "commit_id": "6369ba3c9cc74becfaad2a8882dff3dd3e7ae3c0", "target": 0, "func": "av_cold void ff_vorbisdsp_init_x86 ( VorbisDSPContext * dsp ) \n { \n #if HAVE_YASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n #if ARCH_X86_32  \n  \n  if ( cpu_flags & AV_CPU_FLAG_3DNOW ) \n dsp -> vorbis_inverse_coupling = ff_vorbis_inverse_coupling_3dnow ; \n #endif \n if ( cpu_flags & AV_CPU_FLAG_SSE ) \n dsp -> vorbis_inverse_coupling = ff_vorbis_inverse_coupling_sse ; \n #endif \n }", "idx": 25239}
{"project": "FFmpeg", "commit_id": "398f015f077c6a2406deffd9e37ff34b9c7bb3bc", "target": 0, "func": "static void output_packet ( AVFormatContext * s , AVPacket * pkt , OutputStream * ost ) \n { \n int ret = 0 ; \n if ( ost -> nb_bitstream_filters ) { \n int idx ; \n ret = av_bsf_send_packet ( ost -> bsf_ctx [ 0 ] , pkt ) ; \n if ( ret < 0 ) \n goto finish ; \n idx = 1 ; \n while ( idx ) { \n ret = av_bsf_receive_packet ( ost -> bsf_ctx [ idx - 1 ] , pkt ) ; \n if ( ret == AVERROR ( EAGAIN ) ) { \n ret = 0 ; \n idx -- ; \n continue ; \n } else if ( ret < 0 ) \n goto finish ; \n if ( idx < ost -> nb_bitstream_filters ) { \n ret = av_bsf_send_packet ( ost -> bsf_ctx [ idx ] , pkt ) ; \n if ( ret < 0 ) \n goto finish ; \n idx ++ ; \n } else \n write_packet ( s , pkt , ost ) ; \n } \n } else \n write_packet ( s , pkt , ost ) ; \n finish : \n if ( ret < 0 && ret != AVERROR_EOF ) { \n av_log ( NULL , AV_LOG_FATAL , \" \" \n \" \\n \" , ost -> file_index , ost -> index ) ; \n exit_program ( 1 ) ; \n } \n }", "idx": 25240}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int read_huffman_tables ( HYuvContext * s , uint8_t * src , int length ) { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , src , length ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n read_len_table ( s -> len [ i ] , & gb ) ; \n if ( generate_bits_table ( s -> bits [ i ] , s -> len [ i ] ) < 0 ) { \n return -1 ; \n } \n #if 0  \n  \n  for ( j = 0 ; j < 256 ; j ++ ) { \n printf ( \" \\n \" , s -> bits [ i ] [ j ] , s -> len [ i ] [ j ] , j ) ; \n } \n #endif \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 ) ; \n } \n return 0 ; \n }", "idx": 25243}
{"project": "FFmpeg", "commit_id": "7cdea450c67d24a3503a0eb64f491f58e474973f", "target": 1, "func": "static int rate_control ( AVCodecContext * avctx , void * arg ) \n { \n SliceArgs * slice_dat = arg ; \n VC2EncContext * s = slice_dat -> ctx ; \n const int sx = slice_dat -> x ; \n const int sy = slice_dat -> y ; \n int quant_buf [ 2 ] , bits_buf [ 2 ] , quant = s -> q_start , range = s -> q_start / 3 ; \n const int64_t top = slice_dat -> bits_ceil ; \n const double percent = s -> tolerance ; \n const double bottom = top - top * ( percent / 100.0f ) ; \n int bits = count_hq_slice ( s , sx , sy , quant ) ; \n range -= range & 1 ; \n while ( ( bits > top ) || ( bits < bottom ) ) { \n range *= bits > top ? +1 : -1 ; \n quant = av_clip ( quant + range , 0 , s -> q_ceil ) ; \n bits = count_hq_slice ( s , sx , sy , quant ) ; \n range = av_clip ( range / 2 , 1 , s -> q_ceil ) ; \n if ( quant_buf [ 1 ] == quant ) { \n quant = bits_buf [ 0 ] < bits ? quant_buf [ 0 ] : quant ; \n bits = bits_buf [ 0 ] < bits ? bits_buf [ 0 ] : bits ; \n break ; \n } \n quant_buf [ 1 ] = quant_buf [ 0 ] ; \n quant_buf [ 0 ] = quant ; \n bits_buf [ 1 ] = bits_buf [ 0 ] ; \n bits_buf [ 0 ] = bits ; \n } \n slice_dat -> quant_idx = av_clip ( quant , 0 , s -> q_ceil ) ; \n slice_dat -> bytes = FFALIGN ( ( bits >> 3 ) , s -> size_scaler ) + 4 + s -> prefix_bytes ; \n return 0 ; \n }", "idx": 25255}
{"project": "FFmpeg", "commit_id": "acf23d9451e9ea014a4eddf2abdb476c4f33edc4", "target": 0, "func": "static int genh_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n AVCodecContext * codec = s -> streams [ 0 ] -> codec ; \n GENHDemuxContext * c = s -> priv_data ; \n int ret ; \n if ( c -> dsp_int_type == 1 && codec -> codec_id == AV_CODEC_ID_ADPCM_THP && \n codec -> channels > 1 ) { \n int i , ch ; \n if ( avio_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n av_new_packet ( pkt , 8 * codec -> channels ) ; \n for ( i = 0 ; i < 8 / c -> interleave_size ; i ++ ) { \n for ( ch = 0 ; ch < codec -> channels ; ch ++ ) { \n pkt -> data [ ch * 8 + i * c -> interleave_size + 0 ] = avio_r8 ( s -> pb ) ; \n pkt -> data [ ch * 8 + i * c -> interleave_size + 1 ] = avio_r8 ( s -> pb ) ; \n } \n } \n ret = 0 ; \n } else { \n ret = av_get_packet ( s -> pb , pkt , codec -> block_align ? codec -> block_align : 1024 * codec -> channels ) ; \n } \n pkt -> stream_index = 0 ; \n return ret ; \n }", "idx": 25267}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel8_mc32_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_and_aver_dst_8w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 8 , 1 ) ; \n }", "idx": 25293}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_2r_to_dolby ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] -= output [ 3 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 4 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 25297}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "int ff_qsv_enc_close ( AVCodecContext * avctx , QSVEncContext * q ) \n { \n QSVFrame * cur ; \n MFXVideoENCODE_Close ( q -> session ) ; \n if ( q -> internal_session ) \n MFXClose ( q -> internal_session ) ; \n q -> session = NULL ; \n q -> internal_session = NULL ; \n cur = q -> work_frames ; \n while ( cur ) { \n q -> work_frames = cur -> next ; \n av_frame_free ( & cur -> frame ) ; \n av_freep ( & cur ) ; \n cur = q -> work_frames ; \n } \n while ( q -> async_fifo && av_fifo_size ( q -> async_fifo ) ) { \n AVPacket pkt ; \n mfxSyncPoint sync ; \n mfxBitstream * bs ; \n av_fifo_generic_read ( q -> async_fifo , & pkt , sizeof ( pkt ) , NULL ) ; \n av_fifo_generic_read ( q -> async_fifo , & sync , sizeof ( sync ) , NULL ) ; \n av_fifo_generic_read ( q -> async_fifo , & bs , sizeof ( bs ) , NULL ) ; \n av_freep ( & bs ) ; \n av_packet_unref ( & pkt ) ; \n } \n av_fifo_free ( q -> async_fifo ) ; \n q -> async_fifo = NULL ; \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 25298}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int raw_encode_init ( AVCodecContext * avctx ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; \n avctx -> coded_frame = av_frame_alloc ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> pict_type = AV_PICTURE_TYPE_I ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> bits_per_coded_sample = av_get_bits_per_pixel ( desc ) ; \n if ( ! avctx -> codec_tag ) \n avctx -> codec_tag = avcodec_pix_fmt_to_codec_tag ( avctx -> pix_fmt ) ; \n return 0 ; \n }", "idx": 25299}
{"project": "FFmpeg", "commit_id": "091bc6ca8c643bfece2c70ff2404c7b31574e1f1", "target": 0, "func": "static void mm_decode_intra ( MmContext * s , int half_horiz , int half_vert , const uint8_t * buf , int buf_size ) \n { \n int i , x , y ; \n i = 0 ; x = 0 ; y = 0 ; \n while ( i < buf_size ) { \n int run_length , color ; \n if ( buf [ i ] & 0x80 ) { \n run_length = 1 ; \n color = buf [ i ] ; \n i ++ ; \n } else { \n run_length = ( buf [ i ] & 0x7f ) + 2 ; \n color = buf [ i + 1 ] ; \n i += 2 ; \n } \n if ( half_horiz ) \n run_length *= 2 ; \n if ( color ) { \n memset ( s -> frame . data [ 0 ] + y * s -> frame . linesize [ 0 ] + x , color , run_length ) ; \n if ( half_vert ) \n memset ( s -> frame . data [ 0 ] + ( y + 1 ) * s -> frame . linesize [ 0 ] + x , color , run_length ) ; \n } \n x += run_length ; \n if ( x >= s -> avctx -> width ) { \n x = 0 ; \n y += half_vert ? 2 : 1 ; \n } \n } \n }", "idx": 25303}
{"project": "FFmpeg", "commit_id": "0247bdee2581a6857a24c5ff297f01d3a3112b11", "target": 1, "func": "void av_log_default_callback ( void * ptr , int level , const char * fmt , va_list vl ) \n { \n static int print_prefix = 1 ; \n static int count ; \n static char line [ 1024 ] , prev [ 1024 ] ; \n static int is_atty ; \n AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; \n if ( level > av_log_level ) \n return ; \n line [ 0 ] = 0 ; \n #undef  fprintf  \n  \n  if ( print_prefix && avc ) { \n if ( avc -> parent_log_context_offset ) { \n AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; \n if ( parent && * parent ) { \n snprintf ( line , sizeof ( line ) , \" \" , ( * parent ) -> item_name ( parent ) , parent ) ; \n } \n } \n snprintf ( line + strlen ( line ) , sizeof ( line ) - strlen ( line ) , \" \" , avc -> item_name ( ptr ) , ptr ) ; \n } \n vsnprintf ( line + strlen ( line ) , sizeof ( line ) - strlen ( line ) , fmt , vl ) ; \n print_prefix = line [ strlen ( line ) - 1 ] == ' \\n ' ; \n #if HAVE_ISATTY  \n  \n  if ( ! is_atty ) is_atty = isatty ( 2 ) ? 1 : -1 ; \n #endif \n if ( print_prefix && ( flags & AV_LOG_SKIP_REPEATED ) && ! strcmp ( line , prev ) ) { \n count ++ ; \n if ( is_atty == 1 ) \n fprintf ( stderr , \" \\r \" , count ) ; \n return ; \n } \n if ( count > 0 ) { \n fprintf ( stderr , \" \\n \" , count ) ; \n count = 0 ; \n } \n colored_fputs ( av_clip ( level >> 3 , 0 , 6 ) , line ) ; \n strcpy ( prev , line ) ; \n }", "idx": 25305}
{"project": "FFmpeg", "commit_id": "ed16c2dbf47cdd7c48825b4da6e7036698e5dde1", "target": 0, "func": "void ff_h261_loop_filter ( MpegEncContext * s ) { \n H261Context * h = ( H261Context * ) s ; \n const int linesize = s -> linesize ; \n const int uvlinesize = s -> uvlinesize ; \n uint8_t * dest_y = s -> dest [ 0 ] ; \n uint8_t * dest_cb = s -> dest [ 1 ] ; \n uint8_t * dest_cr = s -> dest [ 2 ] ; \n if ( ! ( IS_FIL ( h -> mtype ) ) ) \n return ; \n s -> dsp . h261_loop_filter ( dest_y , linesize ) ; \n s -> dsp . h261_loop_filter ( dest_y + 8 , linesize ) ; \n s -> dsp . h261_loop_filter ( dest_y + 8 * linesize , linesize ) ; \n s -> dsp . h261_loop_filter ( dest_y + 8 * linesize + 8 , linesize ) ; \n s -> dsp . h261_loop_filter ( dest_cb , uvlinesize ) ; \n s -> dsp . h261_loop_filter ( dest_cr , uvlinesize ) ; \n }", "idx": 25311}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "int udp_set_remote_url ( URLContext * h , const char * uri ) \n { \n UDPContext * s = h -> priv_data ; \n char hostname [ 256 ] ; \n int port ; \n url_split ( NULL , 0 , hostname , sizeof ( hostname ) , & port , NULL , 0 , uri ) ; \n if ( resolve_host ( & s -> dest_addr . sin_addr , hostname ) < 0 ) \n return AVERROR_IO ; \n s -> dest_addr . sin_family = AF_INET ; \n s -> dest_addr . sin_port = htons ( port ) ; \n return 0 ; \n }", "idx": 25322}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_cdt16_entry ( int p1 , int p2 , int16_t * cdt ) \n { \n int r , b , lo ; \n b = cdt [ p2 ] ; \n r = cdt [ p1 ] << 11 ; \n lo = b + r ; \n return ( lo + ( lo << 16 ) ) << 1 ; \n }", "idx": 25335}
{"project": "FFmpeg", "commit_id": "0041cdba98d5b636a8d912352dd3d8ca72bba4ce", "target": 0, "func": "int av_seek_frame ( AVFormatContext * s , int stream_index , int64_t timestamp , int flags ) \n { \n int ret ; \n AVStream * st ; \n ff_read_frame_flush ( s ) ; \n if ( flags & AVSEEK_FLAG_BYTE ) \n return seek_frame_byte ( s , stream_index , timestamp , flags ) ; \n if ( stream_index < 0 ) { \n stream_index = av_find_default_stream_index ( s ) ; \n if ( stream_index < 0 ) \n return -1 ; \n st = s -> streams [ stream_index ] ; \n timestamp = av_rescale ( timestamp , st -> time_base . den , AV_TIME_BASE * ( int64_t ) st -> time_base . num ) ; \n } \n if ( s -> iformat -> read_seek ) \n ret = s -> iformat -> read_seek ( s , stream_index , timestamp , flags ) ; \n else \n ret = -1 ; \n if ( ret >= 0 ) { \n return 0 ; \n } \n if ( s -> iformat -> read_timestamp && ! ( s -> iformat -> flags & AVFMT_NOBINSEARCH ) ) \n return av_seek_frame_binary ( s , stream_index , timestamp , flags ) ; \n else if ( ! ( s -> iformat -> flags & AVFMT_NOGENSEARCH ) ) \n return seek_frame_generic ( s , stream_index , timestamp , flags ) ; \n else \n return -1 ; \n }", "idx": 25345}
{"project": "FFmpeg", "commit_id": "a181981eb49fc20d1a701fcfebda5cec70def295", "target": 0, "func": "int av_metadata_set ( AVMetadata * * pm , const char * key , const char * value ) \n { \n AVMetadata * m = * pm ; \n AVMetadataTag * tag = av_metadata_get ( m , key , NULL , AV_METADATA_MATCH_CASE ) ; \n if ( ! m ) \n m = * pm = av_mallocz ( sizeof ( * m ) ) ; \n if ( tag ) { \n av_free ( tag -> value ) ; \n av_free ( tag -> key ) ; \n * tag = m -> elems [ -- m -> count ] ; \n } else { \n AVMetadataTag * tmp = av_realloc ( m -> elems , ( m -> count + 1 ) * sizeof ( * m -> elems ) ) ; \n if ( tmp ) { \n m -> elems = tmp ; \n } else \n return AVERROR ( ENOMEM ) ; \n } \n if ( value ) { \n m -> elems [ m -> count ] . key = av_strdup ( key ) ; \n m -> elems [ m -> count ] . value = av_strdup ( value ) ; \n m -> count ++ ; \n } \n if ( ! m -> count ) { \n av_free ( m -> elems ) ; \n av_freep ( pm ) ; \n } \n return 0 ; \n }", "idx": 25349}
{"project": "FFmpeg", "commit_id": "bf8bcd3b2b51c4d3f0a157e80a8c96c8542217b0", "target": 0, "func": "static int read_packet ( AVFormatContext * ctx , AVPacket * pkt ) \n { \n al_data * ad = ctx -> priv_data ; \n int error = 0 ; \n const char * error_msg ; \n ALCint nb_samples ; \n alcGetIntegerv ( ad -> device , ALC_CAPTURE_SAMPLES , ( ALCsizei ) sizeof ( ALCint ) , & nb_samples ) ; \n if ( error = al_get_error ( ad -> device , & error_msg ) ) goto fail ; \n av_new_packet ( pkt , nb_samples * ad -> sample_step ) ; \n pkt -> pts = av_gettime ( ) ; \n alcCaptureSamples ( ad -> device , pkt -> data , nb_samples ) ; \n if ( error = al_get_error ( ad -> device , & error_msg ) ) goto fail ; \n return pkt -> size ; \n fail : \n if ( pkt -> data ) \n av_destruct_packet ( pkt ) ; \n if ( error_msg ) \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , error_msg ) ; \n return error ; \n }", "idx": 25371}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void palette8tobgr15 ( const uint8_t * src , uint8_t * dst , unsigned num_pixels , const uint8_t * palette ) \n { \n unsigned i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = bswap_16 ( ( ( uint16_t * ) palette ) [ src [ i ] ] ) ; \n }", "idx": 25376}
{"project": "FFmpeg", "commit_id": "76d8c77430e9e0110623705bfb54d922cc2ac3ea", "target": 1, "func": "static int decode_interrupt_cb ( void * ctx ) \n { \n return received_nb_signals > transcode_init_done ; \n }", "idx": 25377}
{"project": "FFmpeg", "commit_id": "0834f2056c7f1a0c09129802a003465e0ebcc9b8", "target": 1, "func": "static int mxf_read_content_storage ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) \n { \n MXFContext * mxf = arg ; \n switch ( tag ) { \n case 0x1901 : \n mxf -> packages_count = avio_rb32 ( pb ) ; \n mxf -> packages_refs = av_calloc ( mxf -> packages_count , sizeof ( UID ) ) ; \n if ( ! mxf -> packages_refs ) \n return AVERROR ( ENOMEM ) ; \n avio_skip ( pb , 4 ) ; \n avio_read ( pb , ( uint8_t * ) mxf -> packages_refs , mxf -> packages_count * sizeof ( UID ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 25378}
{"project": "FFmpeg", "commit_id": "a779602584b43578e8baa69b367ba7d64e973dd0", "target": 1, "func": "static int decode_mb ( MadContext * s , AVFrame * frame , int inter ) \n { \n int mv_map = 0 ; \n int mv_x , mv_y ; \n int j ; \n if ( inter ) { \n int v = decode210 ( & s -> gb ) ; \n if ( v < 2 ) { \n mv_map = v ? get_bits ( & s -> gb , 6 ) : 63 ; \n mv_x = decode_motion ( & s -> gb ) ; \n mv_y = decode_motion ( & s -> gb ) ; \n } \n } \n for ( j = 0 ; j < 6 ; j ++ ) { \n if ( mv_map & ( 1 << j ) ) { \n int add = 2 * decode_motion ( & s -> gb ) ; \n if ( s -> last_frame -> data [ 0 ] ) \n comp_block ( s , frame , s -> mb_x , s -> mb_y , j , mv_x , mv_y , add ) ; \n } else { \n s -> dsp . clear_block ( s -> block ) ; \n if ( decode_block_intra ( s , s -> block ) < 0 ) \n return -1 ; \n idct_put ( s , frame , s -> block , s -> mb_x , s -> mb_y , j ) ; \n } \n } \n return 0 ; \n }", "idx": 25381}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "int ff_vaapi_mpeg_end_frame ( AVCodecContext * avctx ) \n { \n struct vaapi_context * const vactx = avctx -> hwaccel_context ; \n MpegEncContext * s = avctx -> priv_data ; \n int ret ; \n ret = ff_vaapi_commit_slices ( vactx ) ; \n if ( ret < 0 ) \n goto finish ; \n ret = ff_vaapi_render_picture ( vactx , \n ff_vaapi_get_surface_id ( & s -> current_picture_ptr -> f ) ) ; \n if ( ret < 0 ) \n goto finish ; \n ff_mpeg_draw_horiz_band ( s , 0 , s -> avctx -> height ) ; \n finish : \n ff_vaapi_common_end_frame ( avctx ) ; \n return ret ; \n }", "idx": 25406}
{"project": "FFmpeg", "commit_id": "c763f86728f1ae8c64794dc1a2451777539e382d", "target": 1, "func": "static void decode_band_structure ( GetBitContext * gbc , int blk , int eac3 , \n int ecpl , int start_subband , int end_subband , \n const uint8_t * default_band_struct , \n uint8_t * band_struct , int * num_subbands , \n int * num_bands , int * band_sizes ) \n { \n int subbnd , bnd , n_subbands , n_bands , bnd_sz [ 22 ] ; \n n_subbands = end_subband - start_subband ; \n if ( ! eac3 || get_bits1 ( gbc ) ) { \n for ( subbnd = 0 ; subbnd < n_subbands - 1 ; subbnd ++ ) { \n band_struct [ subbnd ] = get_bits1 ( gbc ) ; \n } \n } else if ( ! blk ) { \n memcpy ( band_struct , \n & default_band_struct [ start_subband + 1 ] , \n n_subbands - 1 ) ; \n } \n band_struct [ n_subbands - 1 ] = 0 ; \n if ( num_bands || band_sizes ) { \n n_bands = n_subbands ; \n bnd_sz [ 0 ] = ecpl ? 6 : 12 ; \n for ( bnd = 0 , subbnd = 1 ; subbnd < n_subbands ; subbnd ++ ) { \n int subbnd_size = ( ecpl && subbnd < 4 ) ? 6 : 12 ; \n if ( band_struct [ subbnd - 1 ] ) { \n n_bands -- ; \n bnd_sz [ bnd ] += subbnd_size ; \n } else { \n bnd_sz [ ++ bnd ] = subbnd_size ; \n } \n } \n } \n if ( num_subbands ) \n * num_subbands = n_subbands ; \n if ( num_bands ) \n * num_bands = n_bands ; \n if ( band_sizes ) \n memcpy ( band_sizes , bnd_sz , sizeof ( int ) * n_bands ) ; \n }", "idx": 25412}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static void init_coef_vlc ( VLC * vlc , \n uint16_t * * prun_table , uint16_t * * plevel_table , \n const CoefVLCTable * vlc_table ) \n { \n int n = vlc_table -> n ; \n const uint8_t * table_bits = vlc_table -> huffbits ; \n const uint32_t * table_codes = vlc_table -> huffcodes ; \n const uint16_t * levels_table = vlc_table -> levels ; \n uint16_t * run_table , * level_table ; \n const uint16_t * p ; \n int i , l , j , level ; \n init_vlc ( vlc , 9 , n , table_bits , 1 , 1 , table_codes , 4 , 4 ) ; \n run_table = av_malloc ( n * sizeof ( uint16_t ) ) ; \n level_table = av_malloc ( n * sizeof ( uint16_t ) ) ; \n p = levels_table ; \n i = 2 ; \n level = 1 ; \n while ( i < n ) { \n l = * p ++ ; \n for ( j = 0 ; j < l ; j ++ ) { \n run_table [ i ] = j ; \n level_table [ i ] = level ; \n i ++ ; \n } \n level ++ ; \n } \n * prun_table = run_table ; \n * plevel_table = level_table ; \n }", "idx": 25415}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_midh_qrt_and_aver_dst_16w_msa ( const uint8_t * src , \n int32_t src_stride , \n uint8_t * dst , \n int32_t dst_stride , \n int32_t height , \n uint8_t horiz_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 4 ; multiple8_cnt -- ; ) { \n avc_luma_midh_qrt_and_aver_dst_4w_msa ( src , src_stride , dst , dst_stride , \n height , horiz_offset ) ; \n src += 4 ; \n dst += 4 ; \n } \n }", "idx": 25417}
{"project": "FFmpeg", "commit_id": "dfea94ce994a916eb7c1a278a09748fd3928c00d", "target": 1, "func": "static av_cold int fieldmatch_init ( AVFilterContext * ctx ) \n { \n const FieldMatchContext * fm = ctx -> priv ; \n AVFilterPad pad = { \n . name = av_strdup ( \" \" ) , \n . type = AVMEDIA_TYPE_VIDEO , \n . filter_frame = filter_frame , \n . config_props = config_input , \n } ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_inpad ( ctx , INPUT_MAIN , & pad ) ; \n if ( fm -> ppsrc ) { \n pad . name = av_strdup ( \" \" ) ; \n pad . config_props = NULL ; \n if ( ! pad . name ) \n return AVERROR ( ENOMEM ) ; \n ff_insert_inpad ( ctx , INPUT_CLEANSRC , & pad ) ; \n } \n if ( ( fm -> blockx & ( fm -> blockx - 1 ) ) || \n ( fm -> blocky & ( fm -> blocky - 1 ) ) ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( fm -> combpel > fm -> blockx * fm -> blocky ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 25422}
{"project": "FFmpeg", "commit_id": "6bd665b7c5798803366b877903fa3bce7f129d05", "target": 0, "func": "void avpriv_tak_parse_streaminfo ( GetBitContext * gb , TAKStreamInfo * s ) \n { \n uint64_t channel_mask = 0 ; \n int frame_type , i ; \n s -> codec = get_bits ( gb , TAK_ENCODER_CODEC_BITS ) ; \n skip_bits ( gb , TAK_ENCODER_PROFILE_BITS ) ; \n frame_type = get_bits ( gb , TAK_SIZE_FRAME_DURATION_BITS ) ; \n s -> samples = get_bits64 ( gb , TAK_SIZE_SAMPLES_NUM_BITS ) ; \n s -> data_type = get_bits ( gb , TAK_FORMAT_DATA_TYPE_BITS ) ; \n s -> sample_rate = get_bits ( gb , TAK_FORMAT_SAMPLE_RATE_BITS ) + \n TAK_SAMPLE_RATE_MIN ; \n s -> bps = get_bits ( gb , TAK_FORMAT_BPS_BITS ) + \n TAK_BPS_MIN ; \n s -> channels = get_bits ( gb , TAK_FORMAT_CHANNEL_BITS ) + \n TAK_CHANNELS_MIN ; \n if ( get_bits1 ( gb ) ) { \n skip_bits ( gb , TAK_FORMAT_VALID_BITS ) ; \n if ( get_bits1 ( gb ) ) { \n for ( i = 0 ; i < s -> channels ; i ++ ) { \n int value = get_bits ( gb , TAK_FORMAT_CH_LAYOUT_BITS ) ; \n if ( value < FF_ARRAY_ELEMS ( tak_channel_layouts ) ) \n channel_mask |= tak_channel_layouts [ value ] ; \n } \n } \n } \n s -> ch_layout = channel_mask ; \n s -> frame_samples = tak_get_nb_samples ( s -> sample_rate , frame_type ) ; \n }", "idx": 25425}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "int show_formats ( void * optctx , const char * opt , const char * arg ) \n { \n AVInputFormat * ifmt = NULL ; \n AVOutputFormat * ofmt = NULL ; \n const char * last_name ; \n printf ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n last_name = \" \" ; \n for ( ; ; ) { \n int decode = 0 ; \n int encode = 0 ; \n const char * name = NULL ; \n const char * long_name = NULL ; \n while ( ( ofmt = av_oformat_next ( ofmt ) ) ) { \n if ( ( name == NULL || strcmp ( ofmt -> name , name ) < 0 ) && \n strcmp ( ofmt -> name , last_name ) > 0 ) { \n name = ofmt -> name ; \n long_name = ofmt -> long_name ; \n encode = 1 ; \n } \n } \n while ( ( ifmt = av_iformat_next ( ifmt ) ) ) { \n if ( ( name == NULL || strcmp ( ifmt -> name , name ) < 0 ) && \n strcmp ( ifmt -> name , last_name ) > 0 ) { \n name = ifmt -> name ; \n long_name = ifmt -> long_name ; \n encode = 0 ; \n } \n if ( name && strcmp ( ifmt -> name , name ) == 0 ) \n decode = 1 ; \n } \n if ( name == NULL ) \n break ; \n last_name = name ; \n printf ( \" \\n \" , \n decode ? \" \" : \" \" , \n encode ? \" \" : \" \" , \n name , \n long_name ? long_name : \" \" ) ; \n } \n return 0 ; \n }", "idx": 25426}
{"project": "FFmpeg", "commit_id": "be394968c81019887ef996a78a526bdd85d1e216", "target": 0, "func": "static void SET_TYPE ( resample_nearest ) ( void * dst0 , int dst_index , const void * src0 , int index ) \n { \n FELEM * dst = dst0 ; \n const FELEM * src = src0 ; \n dst [ dst_index ] = src [ index ] ; \n }", "idx": 25427}
{"project": "FFmpeg", "commit_id": "57f94f54c449b1d34b0d6ccf82dfdcdc1ce7cd14", "target": 0, "func": "static void rtsp_send_cmd ( AVFormatContext * s , \n const char * cmd , RTSPMessageHeader * reply , \n unsigned char * * content_ptr ) \n { \n RTSPState * rt = s -> priv_data ; \n char buf [ 4096 ] , buf1 [ 1024 ] ; \n rt -> seq ++ ; \n av_strlcpy ( buf , cmd , sizeof ( buf ) ) ; \n snprintf ( buf1 , sizeof ( buf1 ) , \" \\r \\n \" , rt -> seq ) ; \n av_strlcat ( buf , buf1 , sizeof ( buf ) ) ; \n if ( rt -> session_id [ 0 ] != ' \\0 ' && ! strstr ( cmd , \" \\n \" ) ) { \n snprintf ( buf1 , sizeof ( buf1 ) , \" \\r \\n \" , rt -> session_id ) ; \n av_strlcat ( buf , buf1 , sizeof ( buf ) ) ; \n } \n av_strlcat ( buf , \" \\r \\n \" , sizeof ( buf ) ) ; \n #ifdef DEBUG \n printf ( \" \\n \\n \" , buf ) ; \n #endif \n url_write ( rt -> rtsp_hd , buf , strlen ( buf ) ) ; \n rtsp_read_reply ( rt , reply , content_ptr ) ; \n }", "idx": 25429}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int x8_setup_spatial_predictor ( IntraX8Context * const w , const int chroma ) { \n MpegEncContext * const s = w -> s ; \n int range ; \n int sum ; \n int quant ; \n w -> dsp . setup_spatial_compensation ( s -> dest [ chroma ] , s -> edge_emu_buffer , \n s -> current_picture . f . linesize [ chroma > 0 ] , \n & range , & sum , w -> edges ) ; \n if ( chroma ) { \n w -> orient = w -> chroma_orient ; \n quant = w -> quant_dc_chroma ; \n } else { \n quant = w -> quant ; \n } \n w -> flat_dc = 0 ; \n if ( range < quant || range < 3 ) { \n w -> orient = 0 ; \n if ( range < 3 ) { \n w -> flat_dc = 1 ; \n sum += 9 ; \n w -> predicted_dc = ( sum * 6899 ) >> 17 ; \n } \n } \n if ( chroma ) \n return 0 ; \n assert ( w -> orient < 3 ) ; \n if ( range < 2 * w -> quant ) { \n if ( ( w -> edges & 3 ) == 0 ) { \n if ( w -> orient == 1 ) w -> orient = 11 ; \n if ( w -> orient == 2 ) w -> orient = 10 ; \n } else { \n w -> orient = 0 ; \n } \n w -> raw_orient = 0 ; \n } else { \n static const uint8_t prediction_table [ 3 ] [ 12 ] = { \n { 0 , 8 , 4 , 10 , 11 , 2 , 6 , 9 , 1 , 3 , 5 , 7 } , \n { 4 , 0 , 8 , 11 , 10 , 3 , 5 , 2 , 6 , 9 , 1 , 7 } , \n { 8 , 0 , 4 , 10 , 11 , 1 , 7 , 2 , 6 , 9 , 3 , 5 } \n } ; \n w -> raw_orient = x8_get_orient_vlc ( w ) ; \n if ( w -> raw_orient < 0 ) return -1 ; \n assert ( w -> raw_orient < 12 ) ; \n assert ( w -> orient < 3 ) ; \n w -> orient = prediction_table [ w -> orient ] [ w -> raw_orient ] ; \n } \n return 0 ; \n }", "idx": 25433}
{"project": "FFmpeg", "commit_id": "445a02b1ec5ea94d28ea2503a3ae0272fcff0e12", "target": 1, "func": "static int rtp_asf_fix_header ( uint8_t * buf , int len ) \n { \n uint8_t * p = buf , * end = buf + len ; \n if ( len < sizeof ( ff_asf_guid ) * 2 + 22 || \n memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { \n return -1 ; \n } \n p += sizeof ( ff_asf_guid ) + 14 ; \n do { \n uint64_t chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; \n if ( memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { \n if ( chunksize > end - p ) \n return -1 ; \n p += chunksize ; \n continue ; \n } \n p += 6 * 8 + 3 * 4 + sizeof ( ff_asf_guid ) * 2 ; \n if ( p + 8 <= end && AV_RL32 ( p ) == AV_RL32 ( p + 4 ) ) { \n AV_WL32 ( p , 0 ) ; \n return 0 ; \n } \n break ; \n } while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) ; \n return -1 ; \n }", "idx": 25436}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( uyvyToY ) ( uint8_t * dst , uint8_t * src , long width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i + 1 ] ; \n #endif \n }", "idx": 25439}
{"project": "FFmpeg", "commit_id": "bb23bf8fd7fb4771b0f08a4ee1ba8fe6ca16d14f", "target": 1, "func": "int avfilter_process_command ( AVFilterContext * filter , const char * cmd , const char * arg , char * res , int res_len , int flags ) \n { \n if ( ! strcmp ( cmd , \" \" ) ) { \n av_strlcatf ( res , res_len , \" \\n \" , filter -> filter -> name , filter -> name ) ; \n return 0 ; \n } else if ( ! strcmp ( cmd , \" \" ) ) { \n return set_enable_expr ( filter , arg ) ; \n } else if ( filter -> filter -> process_command ) { \n return filter -> filter -> process_command ( filter , cmd , arg , res , res_len , flags ) ; \n return AVERROR ( ENOSYS ) ;", "idx": 25443}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel8_mc03_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_8w_msa ( src - ( stride * 2 ) , stride , dst , stride , 8 , 1 ) ; \n }", "idx": 25445}
{"project": "FFmpeg", "commit_id": "e56d1a120324fa49a5367cbf22098c5c7eb23f91", "target": 0, "func": "static av_cold int audio_write_header ( AVFormatContext * s1 ) \n { \n AlsaData * s = s1 -> priv_data ; \n AVStream * st ; \n unsigned int sample_rate ; \n enum AVCodecID codec_id ; \n int res ; \n st = s1 -> streams [ 0 ] ; \n sample_rate = st -> codec -> sample_rate ; \n codec_id = st -> codec -> codec_id ; \n res = ff_alsa_open ( s1 , SND_PCM_STREAM_PLAYBACK , & sample_rate , \n st -> codec -> channels , & codec_id ) ; \n if ( sample_rate != st -> codec -> sample_rate ) { \n av_log ( s1 , AV_LOG_ERROR , \n \" \\n \" , \n st -> codec -> sample_rate , sample_rate ) ; \n goto fail ; \n } \n avpriv_set_pts_info ( st , 64 , 1 , sample_rate ) ; \n return res ; \n fail : \n snd_pcm_close ( s -> h ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 25446}
{"project": "FFmpeg", "commit_id": "019247bdc326a90bf20d3ce5d2413cc642e8bb08", "target": 0, "func": "static int mov_read_stss ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned int i , entries ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n av_dlog ( c -> fc , \" \\n \" , entries ) ; \n if ( ! entries ) \n { \n sc -> keyframe_absent = 1 ; \n if ( ! st -> need_parsing ) \n st -> need_parsing = AVSTREAM_PARSE_HEADERS ; \n return 0 ; \n } \n if ( entries >= UINT_MAX / sizeof ( int ) ) \n return AVERROR_INVALIDDATA ; \n sc -> keyframes = av_malloc ( entries * sizeof ( int ) ) ; \n if ( ! sc -> keyframes ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < entries && ! pb -> eof_reached ; i ++ ) { \n sc -> keyframes [ i ] = avio_rb32 ( pb ) ; \n } \n sc -> keyframe_count = i ; \n if ( pb -> eof_reached ) \n return AVERROR_EOF ; \n return 0 ; \n }", "idx": 25449}
{"project": "FFmpeg", "commit_id": "741aca793623afeff1d18816f416cc65104b7ef9", "target": 0, "func": "void swr_compensate ( struct SwrContext * s , int sample_delta , int compensation_distance ) { \n ResampleContext * c = s -> resample ; \n c -> compensation_distance = compensation_distance ; \n c -> dst_incr = c -> ideal_dst_incr - c -> ideal_dst_incr * ( int64_t ) sample_delta / compensation_distance ; \n }", "idx": 25450}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "int opt_loglevel ( void * optctx , const char * opt , const char * arg ) \n { \n const struct { const char * name ; int level ; } log_levels [ ] = { \n { \" \" , AV_LOG_QUIET } , \n { \" \" , AV_LOG_PANIC } , \n { \" \" , AV_LOG_FATAL } , \n { \" \" , AV_LOG_ERROR } , \n { \" \" , AV_LOG_WARNING } , \n { \" \" , AV_LOG_INFO } , \n { \" \" , AV_LOG_VERBOSE } , \n { \" \" , AV_LOG_DEBUG } , \n } ; \n char * tail ; \n int level ; \n int i ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) { \n if ( ! strcmp ( log_levels [ i ] . name , arg ) ) { \n av_log_set_level ( log_levels [ i ] . level ) ; \n return 0 ; \n } \n } \n level = strtol ( arg , & tail , 10 ) ; \n if ( * tail ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\\" \\\" \" \n \" \\n \" , arg ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) \n av_log ( NULL , AV_LOG_FATAL , \" \\\" \\\" \\n \" , log_levels [ i ] . name ) ; \n exit ( 1 ) ; \n } \n av_log_set_level ( level ) ; \n return 0 ; \n }", "idx": 25461}
{"project": "FFmpeg", "commit_id": "f98dbc7311a30a30802c71571ff5e3d049ea7556", "target": 0, "func": "const AVOption * av_opt_next ( void * obj , const AVOption * last ) \n { \n AVClass * class = * ( AVClass * * ) obj ; \n if ( ! last && class -> option && class -> option [ 0 ] . name ) \n return class -> option ; \n if ( last && last [ 1 ] . name ) \n return ++ last ; \n return NULL ; \n }", "idx": 25463}
{"project": "FFmpeg", "commit_id": "0acf7e268b2f873379cd854b4d5aaba6f9c1f0b5", "target": 0, "func": "int avfilter_graph_create_filter ( AVFilterContext * * filt_ctx , AVFilter * filt , \n const char * name , const char * args , void * opaque , \n AVFilterGraph * graph_ctx ) \n { \n int ret ; \n * filt_ctx = avfilter_graph_alloc_filter ( graph_ctx , filt , name ) ; \n if ( ! * filt_ctx ) \n return AVERROR ( ENOMEM ) ; \n ret = avfilter_init_filter ( * filt_ctx , args , opaque ) ; \n if ( ret < 0 ) \n goto fail ; \n return 0 ; \n fail : \n if ( * filt_ctx ) \n avfilter_free ( * filt_ctx ) ; \n * filt_ctx = NULL ; \n return ret ; \n }", "idx": 25464}
{"project": "FFmpeg", "commit_id": "0d05406482950b7c129eccfefe0daa3d6d47e292", "target": 1, "func": "static void blur ( CoverContext * cover , AVFrame * in , int offx , int offy ) \n { \n int x , y , p ; \n for ( p = 0 ; p < 3 ; p ++ ) { \n int ox = offx >> ! ! p ; \n int oy = offy >> ! ! p ; \n int stride = in -> linesize [ p ] ; \n uint8_t * data = in -> data [ p ] + ox + oy * stride ; \n int w = FF_CEIL_RSHIFT ( cover -> width , ! ! p ) ; \n int h = FF_CEIL_RSHIFT ( cover -> height , ! ! p ) ; \n int iw = FF_CEIL_RSHIFT ( in -> width , ! ! p ) ; \n int ih = FF_CEIL_RSHIFT ( in -> height , ! ! p ) ; \n for ( y = 0 ; y < h ; y ++ ) { \n for ( x = 0 ; x < w ; x ++ ) { \n int c = 0 ; \n int s = 0 ; \n if ( ox ) { \n int scale = 65536 / ( x + 1 ) ; \n s += data [ -1 + y * stride ] * scale ; \n c += scale ; \n } \n if ( oy ) { \n int scale = 65536 / ( y + 1 ) ; \n s += data [ x - stride ] * scale ; \n c += scale ; \n } \n if ( ox + w < iw ) { \n int scale = 65536 / ( w - x ) ; \n s += data [ w + y * stride ] * scale ; \n c += scale ; \n } \n if ( oy + h < ih ) { \n int scale = 65536 / ( h - y ) ; \n s += data [ x + h * stride ] * scale ; \n c += scale ; \n } \n data [ x + y * stride ] = ( s + ( c >> 1 ) ) / c ; \n } \n } \n } \n }", "idx": 25473}
{"project": "FFmpeg", "commit_id": "59f809e9922ad2a8ed5373189e0e2aec0d4dffd7", "target": 1, "func": "static int parse_bsfs ( void * log_ctx , const char * bsfs_spec , \n AVBitStreamFilterContext * * bsfs ) \n { \n char * bsf_name , * buf , * saveptr ; \n int ret = 0 ; \n if ( ! ( buf = av_strdup ( bsfs_spec ) ) ) \n return AVERROR ( ENOMEM ) ; \n while ( bsf_name = av_strtok ( buf , \" \" , & saveptr ) ) { \n AVBitStreamFilterContext * bsf = av_bitstream_filter_init ( bsf_name ) ; \n if ( ! bsf ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" , \n bsf_name ) ; \n ret = AVERROR_UNKNOWN ; \n goto end ; \n } \n * bsfs = bsf ; \n bsfs = & bsf -> next ; \n buf = NULL ; \n } \n end : \n av_free ( buf ) ; \n return ret ; \n }", "idx": 25475}
{"project": "FFmpeg", "commit_id": "b18a0cc781b791912549504ca8a257f35a151c5e", "target": 1, "func": "void ff_ivi_output_plane ( IVIPlaneDesc * plane , uint8_t * dst , int dst_pitch ) \n { \n int x , y ; \n const int16_t * src = plane -> bands [ 0 ] . buf ; \n uint32_t pitch = plane -> bands [ 0 ] . pitch ; \n for ( y = 0 ; y < plane -> height ; y ++ ) { \n for ( x = 0 ; x < plane -> width ; x ++ ) \n dst [ x ] = av_clip_uint8 ( src [ x ] + 128 ) ; \n src += pitch ; \n dst += dst_pitch ; \n } \n }", "idx": 25476}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "int avpicture_layout ( const AVPicture * src , int pix_fmt , int width , int height , \n unsigned char * dest , int dest_size ) \n { \n PixFmtInfo * pf = & pix_fmt_info [ pix_fmt ] ; \n int i , j , w , h , data_planes ; \n const unsigned char * s ; \n int size = avpicture_get_size ( pix_fmt , width , height ) ; \n if ( size > dest_size ) \n return -1 ; \n if ( pf -> pixel_type == FF_PIXEL_PACKED || pf -> pixel_type == FF_PIXEL_PALETTE ) { \n if ( pix_fmt == PIX_FMT_YUV422 || \n pix_fmt == PIX_FMT_UYVY422 || \n pix_fmt == PIX_FMT_RGB565 || \n pix_fmt == PIX_FMT_RGB555 ) \n w = width * 2 ; \n else if ( pix_fmt == PIX_FMT_UYVY411 ) \n w = width + width / 2 ; \n else if ( pix_fmt == PIX_FMT_PAL8 ) \n w = width ; \n else \n w = width * ( pf -> depth * pf -> nb_channels / 8 ) ; \n data_planes = 1 ; \n h = height ; \n } else { \n data_planes = pf -> nb_channels ; \n w = ( width * pf -> depth + 7 ) / 8 ; \n h = height ; \n } \n for ( i = 0 ; i < data_planes ; i ++ ) { \n if ( i == 1 ) { \n w = width >> pf -> x_chroma_shift ; \n h = height >> pf -> y_chroma_shift ; \n } \n s = src -> data [ i ] ; \n for ( j = 0 ; j < h ; j ++ ) { \n memcpy ( dest , s , w ) ; \n dest += w ; \n s += src -> linesize [ i ] ; \n } \n } \n if ( pf -> pixel_type == FF_PIXEL_PALETTE ) \n memcpy ( ( unsigned char * ) ( ( ( size_t ) dest + 3 ) & ~ 3 ) , src -> data [ 1 ] , 256 * 4 ) ; \n return size ; \n }", "idx": 25493}
{"project": "FFmpeg", "commit_id": "98e42a249e7891d295228ff19892450ba1f09092", "target": 1, "func": "enum AVCodecID av_guess_codec ( AVOutputFormat * fmt , const char * short_name , \n const char * filename , const char * mime_type , \n enum AVMediaType type ) \n { \n if ( av_match_name ( \" \" , fmt -> name ) || av_match_name ( \" \" , fmt -> name ) ) { \n fmt = av_guess_format ( NULL , filename , NULL ) ; \n } \n if ( type == AVMEDIA_TYPE_VIDEO ) { \n enum AVCodecID codec_id = AV_CODEC_ID_NONE ; \n #if CONFIG_IMAGE2_MUXER  \n  \n  if ( ! strcmp ( fmt -> name , \" \" ) || ! strcmp ( fmt -> name , \" \" ) ) { \n codec_id = ff_guess_image2_codec ( filename ) ; \n } \n #endif \n if ( codec_id == AV_CODEC_ID_NONE ) \n codec_id = fmt -> video_codec ; \n return codec_id ; \n } else if ( type == AVMEDIA_TYPE_AUDIO ) \n return fmt -> audio_codec ; \n else if ( type == AVMEDIA_TYPE_SUBTITLE ) \n return fmt -> subtitle_codec ; \n else \n return AV_CODEC_ID_NONE ; \n }", "idx": 25499}
{"project": "FFmpeg", "commit_id": "e9f4001a30c563a840614048629055769f6f7020", "target": 1, "func": "static int wav_parse_fmt_tag ( AVFormatContext * s , int64_t size , AVStream * * st ) \n { \n AVIOContext * pb = s -> pb ; \n int ret ; \n * st = av_new_stream ( s , 0 ) ; \n if ( ! * st ) \n return AVERROR ( ENOMEM ) ; \n ff_get_wav_header ( pb , ( * st ) -> codec , size ) ; \n if ( ret < 0 ) \n return ret ; \n ( * st ) -> need_parsing = AVSTREAM_PARSE_FULL ; \n av_set_pts_info ( * st , 64 , 1 , ( * st ) -> codec -> sample_rate ) ; \n return 0 ; \n }", "idx": 25502}
{"project": "FFmpeg", "commit_id": "ccb8f674995ded871ac725833b5efefce0ad63de", "target": 1, "func": "static int chunk_mux_init ( AVFormatContext * s ) \n { \n WebMChunkContext * wc = s -> priv_data ; \n AVFormatContext * oc ; \n int ret ; \n ret = avformat_alloc_output_context2 ( & wc -> avf , wc -> oformat , NULL , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n oc = wc -> avf ; \n oc -> interrupt_callback = s -> interrupt_callback ; \n oc -> max_delay = s -> max_delay ; \n av_dict_copy ( & oc -> metadata , s -> metadata , 0 ) ; \n oc -> priv_data = av_mallocz ( oc -> oformat -> priv_data_size ) ; \n if ( ! oc -> priv_data ) { \n avio_close ( oc -> pb ) ; \n return AVERROR ( ENOMEM ) ; \n } \n * ( const AVClass * * ) oc -> priv_data = oc -> oformat -> priv_class ; \n av_opt_set_defaults ( oc -> priv_data ) ; \n av_opt_set_int ( oc -> priv_data , \" \" , 1 , 0 ) ; \n av_opt_set_int ( oc -> priv_data , \" \" , wc -> chunk_duration , 0 ) ; \n av_opt_set_int ( oc -> priv_data , \" \" , 1 , 0 ) ; \n oc -> streams = s -> streams ; \n oc -> nb_streams = s -> nb_streams ; \n return 0 ; \n }", "idx": 25504}
{"project": "FFmpeg", "commit_id": "6c9c8b06b32013c58101f27991eae251bf4eb485", "target": 0, "func": "static int interp ( RA144Context * ractx , int16_t * out , int block_num , \n int copyold , int energy ) \n { \n int work [ 10 ] ; \n int a = block_num + 1 ; \n int b = NBLOCKS - a ; \n int x ; \n for ( x = 0 ; x < 30 ; x ++ ) \n out [ x ] = ( a * ractx -> lpc_coef [ 0 ] [ x ] + b * ractx -> lpc_coef [ 1 ] [ x ] ) >> 2 ; \n if ( eval_refl ( work , out , ractx ) ) { \n int_to_int16 ( out , ractx -> lpc_coef [ copyold ] ) ; \n return rescale_rms ( ractx -> lpc_refl_rms [ copyold ] , energy ) ; \n } else { \n return rescale_rms ( rms ( work ) , energy ) ; \n } \n }", "idx": 25513}
{"project": "FFmpeg", "commit_id": "3b64e3ea45c580c5e158c086f2eb7c65635fc33b", "target": 0, "func": "int ff_framesync_request_frame ( FFFrameSync * fs , AVFilterLink * outlink ) \n { \n AVFilterContext * ctx = outlink -> src ; \n int input , ret ; \n if ( ( ret = ff_framesync_process_frame ( fs , 0 ) ) < 0 ) \n return ret ; \n if ( ret > 0 ) \n return 0 ; \n if ( fs -> eof ) \n return AVERROR_EOF ; \n input = fs -> in_request ; \n ret = ff_request_frame ( ctx -> inputs [ input ] ) ; \n if ( ret == AVERROR_EOF ) { \n if ( ( ret = ff_framesync_add_frame ( fs , input , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = ff_framesync_process_frame ( fs , 0 ) ) < 0 ) \n return ret ; \n ret = 0 ; \n } \n return ret ; \n }", "idx": 25524}
{"project": "FFmpeg", "commit_id": "84a6bc23570c17ce91071e41431103f709c0d595", "target": 0, "func": "static Jpeg2000TgtNode * ff_jpeg2000_tag_tree_init ( int w , int h ) \n { \n int pw = w , ph = h ; \n Jpeg2000TgtNode * res , * t , * t2 ; \n int32_t tt_size ; \n tt_size = tag_tree_size ( w , h ) ; \n if ( tt_size == -1 ) \n return NULL ; \n t = res = av_mallocz_array ( tt_size , sizeof ( * t ) ) ; \n if ( ! res ) \n return NULL ; \n while ( w > 1 || h > 1 ) { \n int i , j ; \n pw = w ; \n ph = h ; \n w = ( w + 1 ) >> 1 ; \n h = ( h + 1 ) >> 1 ; \n t2 = t + pw * ph ; \n for ( i = 0 ; i < ph ; i ++ ) \n for ( j = 0 ; j < pw ; j ++ ) \n t [ i * pw + j ] . parent = & t2 [ ( i >> 1 ) * w + ( j >> 1 ) ] ; \n t = t2 ; \n } \n t [ 0 ] . parent = NULL ; \n return res ; \n }", "idx": 25527}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void put_pixels16_altivec ( uint8_t * block , const uint8_t * pixels , int line_size , int h ) \n { \n POWERPC_TBL_DECLARE ( altivec_put_pixels16_num , 1 ) ; \n #ifdef ALTIVEC_USE_REFERENCE_C_CODE \n int i ; \n POWERPC_TBL_START_COUNT ( altivec_put_pixels16_num , 1 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n * ( ( uint32_t * ) ( block ) ) = ( ( ( const struct unaligned_32 * ) ( pixels ) ) -> l ) ; \n * ( ( uint32_t * ) ( block + 4 ) ) = ( ( ( const struct unaligned_32 * ) ( pixels + 4 ) ) -> l ) ; \n * ( ( uint32_t * ) ( block + 8 ) ) = ( ( ( const struct unaligned_32 * ) ( pixels + 8 ) ) -> l ) ; \n * ( ( uint32_t * ) ( block + 12 ) ) = ( ( ( const struct unaligned_32 * ) ( pixels + 12 ) ) -> l ) ; \n pixels += line_size ; \n block += line_size ; \n } \n POWERPC_TBL_STOP_COUNT ( altivec_put_pixels16_num , 1 ) ; \n #else \n register vector unsigned  char pixelsv1 , pixelsv2 ; \n register vector unsigned  char perm = vec_lvsl ( 0 , pixels ) ; \n int i ; \n POWERPC_TBL_START_COUNT ( altivec_put_pixels16_num , 1 ) ; \n for ( i = 0 ; i < h ; i ++ ) { \n pixelsv1 = vec_ld ( 0 , ( unsigned char * ) pixels ) ; \n pixelsv2 = vec_ld ( 16 , ( unsigned char * ) pixels ) ; \n vec_st ( vec_perm ( pixelsv1 , pixelsv2 , perm ) , \n 0 , ( unsigned char * ) block ) ; \n pixels += line_size ; \n block += line_size ; \n } \n POWERPC_TBL_STOP_COUNT ( altivec_put_pixels16_num , 1 ) ; \n #endif \n }", "idx": 25534}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "static int av_thread_message_queue_recv_locked ( AVThreadMessageQueue * mq , \n void * msg , \n unsigned flags ) \n { \n while ( ! mq -> err_recv && av_fifo_size ( mq -> fifo ) < mq -> elsize ) { \n if ( ( flags & AV_THREAD_MESSAGE_NONBLOCK ) ) \n return AVERROR ( EAGAIN ) ; \n pthread_cond_wait ( & mq -> cond , & mq -> lock ) ; \n } \n if ( av_fifo_size ( mq -> fifo ) < mq -> elsize ) \n return mq -> err_recv ; \n av_fifo_generic_read ( mq -> fifo , msg , mq -> elsize , NULL ) ; \n pthread_cond_signal ( & mq -> cond ) ; \n return 0 ; \n }", "idx": 25554}
{"project": "FFmpeg", "commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "target": 1, "func": "void av_thread_message_flush ( AVThreadMessageQueue * mq ) \n { \n #if HAVE_THREADS  \n  \n  int used , off ; \n void * free_func = mq -> free_func ; \n pthread_mutex_lock ( & mq -> lock ) ; \n used = av_fifo_size ( mq -> fifo ) ; \n if ( free_func ) \n for ( off = 0 ; off < used ; off += mq -> elsize ) \n av_fifo_generic_peek_at ( mq -> fifo , mq , off , mq -> elsize , free_func_wrap ) ; \n av_fifo_drain ( mq -> fifo , used ) ; \n pthread_cond_broadcast ( & mq -> cond ) ; \n pthread_mutex_unlock ( & mq -> lock ) ; \n #endif \n }", "idx": 25563}
{"project": "FFmpeg", "commit_id": "4e59c8ecf1433b85b539c5e89bb68cfe8b839866", "target": 1, "func": "int av_open_input_stream ( AVFormatContext * * ic_ptr , \n AVIOContext * pb , const char * filename , \n AVInputFormat * fmt , AVFormatParameters * ap ) \n { \n int err ; \n AVDictionary * opts ; \n AVFormatContext * ic ; \n AVFormatParameters default_ap ; \n if ( ! ap ) { \n ap = & default_ap ; \n memset ( ap , 0 , sizeof ( default_ap ) ) ; \n } \n opts = convert_format_parameters ( ap ) ; \n if ( ! ap -> prealloced_context ) \n ic = avformat_alloc_context ( ) ; \n else \n ic = * ic_ptr ; \n if ( ! ic ) { \n err = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( pb && fmt && fmt -> flags & AVFMT_NOFILE ) \n av_log ( ic , AV_LOG_WARNING , \" \" \n \" \\n \" ) ; \n else \n ic -> pb = pb ; \n err = avformat_open_input ( & ic , filename , fmt , & opts ) ; \n ic -> pb = ic -> pb ? ic -> pb : pb ; \n * ic_ptr = ic ; \n fail : \n av_dict_free ( & opts ) ; \n return err ; \n }", "idx": 25564}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int libgsm_encode_init ( AVCodecContext * avctx ) { \n if ( avctx -> channels > 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> channels ) ; \n return -1 ; \n if ( avctx -> sample_rate != 8000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> sample_rate ) ; \n if ( avctx -> strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) \n return -1 ; \n if ( avctx -> bit_rate != 13000 \n && \n avctx -> bit_rate != 13200 \n && \n avctx -> bit_rate != 0 \n ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n avctx -> bit_rate ) ; \n if ( avctx -> strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) \n return -1 ; \n avctx -> priv_data = gsm_create ( ) ; \n switch ( avctx -> codec_id ) { \n case CODEC_ID_GSM : \n avctx -> frame_size = GSM_FRAME_SIZE ; \n avctx -> block_align = GSM_BLOCK_SIZE ; \n break ; \n case CODEC_ID_GSM_MS : { \n int one = 1 ; \n gsm_option ( avctx -> priv_data , GSM_OPT_WAV49 , & one ) ; \n avctx -> frame_size = 2 * GSM_FRAME_SIZE ; \n avctx -> block_align = GSM_MS_BLOCK_SIZE ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n return 0 ;", "idx": 25589}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel8_mc01_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_vt_qrt_8w_msa ( src - ( stride * 2 ) , stride , dst , stride , 8 , 0 ) ; \n }", "idx": 25594}
{"project": "FFmpeg", "commit_id": "5029a406334ad0eaf92130e23d596e405a8a5aa0", "target": 1, "func": "static void free_picture ( MpegEncContext * s , Picture * pic ) { \n int i ; \n if ( pic -> data [ 0 ] && pic -> type != FF_BUFFER_TYPE_SHARED ) { \n free_frame_buffer ( s , pic ) ; \n } \n av_freep ( & pic -> mb_var ) ; \n av_freep ( & pic -> mc_mb_var ) ; \n av_freep ( & pic -> mb_mean ) ; \n av_freep ( & pic -> mbskip_table ) ; \n av_freep ( & pic -> qscale_table ) ; \n av_freep ( & pic -> mb_type_base ) ; \n av_freep ( & pic -> dct_coeff ) ; \n av_freep ( & pic -> pan_scan ) ; \n pic -> mb_type = NULL ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n av_freep ( & pic -> motion_val_base [ i ] ) ; \n av_freep ( & pic -> ref_index [ i ] ) ; \n } \n if ( pic -> type == FF_BUFFER_TYPE_SHARED ) { \n for ( i = 0 ; i < 4 ; i ++ ) { \n pic -> base [ i ] = \n pic -> data [ i ] = NULL ; \n } \n pic -> type = 0 ; \n } \n }", "idx": 25598}
{"project": "FFmpeg", "commit_id": "4533d2d67f28860304cdaa8aa0b3db85f368810e", "target": 1, "func": "static int mov_read_close ( AVFormatContext * s ) \n { \n int i ; \n MOVContext * mov = s -> priv_data ; \n for ( i = 0 ; i < mov -> total_streams ; i ++ ) \n mov_free_stream_context ( mov -> streams [ i ] ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) \n av_free ( s -> streams [ i ] ) ; \n return 0 ; \n }", "idx": 25601}
{"project": "FFmpeg", "commit_id": "bd8d28e2d2713f0368ee6b7dbb5ec251cbc162ac", "target": 0, "func": "static av_cold int hnm_decode_init ( AVCodecContext * avctx ) \n { \n Hnm4VideoContext * hnm = avctx -> priv_data ; \n if ( avctx -> extradata_size < 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n hnm -> version = avctx -> extradata [ 0 ] ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n hnm -> width = avctx -> width ; \n hnm -> height = avctx -> height ; \n hnm -> buffer1 = av_mallocz ( avctx -> width * avctx -> height ) ; \n hnm -> buffer2 = av_mallocz ( avctx -> width * avctx -> height ) ; \n hnm -> processed = av_mallocz ( avctx -> width * avctx -> height ) ; \n if ( ! hnm -> buffer1 || ! hnm -> buffer2 || ! hnm -> processed ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n av_freep ( & hnm -> buffer1 ) ; \n av_freep ( & hnm -> buffer2 ) ; \n av_freep ( & hnm -> processed ) ; \n return AVERROR ( ENOMEM ) ; \n } \n hnm -> current = hnm -> buffer1 ; \n hnm -> previous = hnm -> buffer2 ; \n return 0 ; \n }", "idx": 25605}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int16_t logadd ( int16_t a , int16_t b ) \n { \n int16_t c = a - b ; \n uint8_t address = FFMIN ( ( ABS ( c ) >> 1 ) , 255 ) ; \n return ( ( c >= 0 ) ? ( a + latab [ address ] ) : ( b + latab [ address ] ) ) ; \n }", "idx": 25613}
{"project": "FFmpeg", "commit_id": "a557ae8d52ce1cfaf3be5cdb13728b7b2b9512b9", "target": 1, "func": "static int get_scale_factor ( H264SliceContext * sl , \n int poc , int poc1 , int i ) \n { \n int poc0 = sl -> ref_list [ 0 ] [ i ] . poc ; \n int td = av_clip_int8 ( poc1 - poc0 ) ; \n if ( td == 0 || sl -> ref_list [ 0 ] [ i ] . parent -> long_ref ) { \n return 256 ; \n } else { \n int tb = av_clip_int8 ( poc - poc0 ) ; \n int tx = ( 16384 + ( FFABS ( td ) >> 1 ) ) / td ; \n return av_clip_intp2 ( ( tb * tx + 32 ) >> 6 , 10 ) ; \n } \n }", "idx": 25616}
{"project": "FFmpeg", "commit_id": "76d81909ae65f5a771e3a58d6a5d6bb58bfed995", "target": 0, "func": "static int X264_frame ( AVCodecContext * ctx , uint8_t * buf , \n int bufsize , void * data ) \n { \n X264Context * x4 = ctx -> priv_data ; \n AVFrame * frame = data ; \n x264_nal_t * nal ; \n int nnal , i ; \n x264_picture_t pic_out ; \n x4 -> pic . img . i_csp = X264_CSP_I420 ; \n x4 -> pic . img . i_plane = 3 ; \n if ( frame ) { \n for ( i = 0 ; i < 3 ; i ++ ) { \n x4 -> pic . img . plane [ i ] = frame -> data [ i ] ; \n x4 -> pic . img . i_stride [ i ] = frame -> linesize [ i ] ; \n } \n x4 -> pic . i_pts = frame -> pts ; \n x4 -> pic . i_type = X264_TYPE_AUTO ; \n } \n if ( x264_encoder_encode ( x4 -> enc , & nal , & nnal , frame ? & x4 -> pic : NULL , & pic_out ) < 0 ) \n return -1 ; \n bufsize = encode_nals ( ctx , buf , bufsize , nal , nnal , 0 ) ; \n if ( bufsize < 0 ) \n return -1 ; \n x4 -> out_pic . pts = pic_out . i_pts ; \n switch ( pic_out . i_type ) { \n case X264_TYPE_IDR : \n case X264_TYPE_I : \n x4 -> out_pic . pict_type = FF_I_TYPE ; \n break ; \n case X264_TYPE_P : \n x4 -> out_pic . pict_type = FF_P_TYPE ; \n break ; \n case X264_TYPE_B : \n case X264_TYPE_BREF : \n x4 -> out_pic . pict_type = FF_B_TYPE ; \n break ; \n } \n x4 -> out_pic . key_frame = pic_out . i_type == X264_TYPE_IDR ; \n x4 -> out_pic . quality = ( pic_out . i_qpplus1 - 1 ) * FF_QP2LAMBDA ; \n return bufsize ; \n }", "idx": 25629}
{"project": "FFmpeg", "commit_id": "602dd8f6c4d4f7e1b5f48cc580fd9b694d41d602", "target": 0, "func": "static void fill_buffer ( ByteIOContext * s ) \n { \n int len ; \n if ( s -> eof_reached ) \n return ; \n if ( s -> update_checksum ) { \n if ( s -> buf_end > s -> checksum_ptr ) \n s -> checksum = s -> update_checksum ( s -> checksum , s -> checksum_ptr , s -> buf_end - s -> checksum_ptr ) ; \n s -> checksum_ptr = s -> buffer ; \n } \n len = s -> read_packet ( s -> opaque , s -> buffer , s -> buffer_size ) ; \n if ( len <= 0 ) { \n s -> eof_reached = 1 ; \n if ( len < 0 ) \n s -> error = len ; \n } else { \n s -> pos += len ; \n s -> buf_ptr = s -> buffer ; \n s -> buf_end = s -> buffer + len ; \n } \n }", "idx": 25638}
{"project": "FFmpeg", "commit_id": "754ebd1a5b68dd63ccceb50a8a852fe8d0c94354", "target": 0, "func": "static int adx_encode_frame ( AVCodecContext * avctx , uint8_t * frame , \n int buf_size , void * data ) \n { \n ADXContext * c = avctx -> priv_data ; \n const int16_t * samples = data ; \n uint8_t * dst = frame ; \n int ch ; \n if ( ! c -> header_parsed ) { \n int hdrsize = adx_encode_header ( avctx , dst , buf_size ) ; \n dst += hdrsize ; \n c -> header_parsed = 1 ; \n } \n for ( ch = 0 ; ch < avctx -> channels ; ch ++ ) { \n adx_encode ( c , dst , samples + ch , & c -> prev [ ch ] , avctx -> channels ) ; \n dst += BLOCK_SIZE ; \n } \n return dst - frame ; \n }", "idx": 25639}
{"project": "FFmpeg", "commit_id": "c31a5b23b4cd566724743685e5ea158b0c818647", "target": 0, "func": "static int opt_streamid ( const char * opt , const char * arg ) \n { \n int idx ; \n char * p ; \n char idx_str [ 16 ] ; \n av_strlcpy ( idx_str , arg , sizeof ( idx_str ) ) ; \n p = strchr ( idx_str , ' ' ) ; \n if ( ! p ) { \n fprintf ( stderr , \n \" \\n \" , \n arg , opt ) ; \n ffmpeg_exit ( 1 ) ; \n } \n * p ++ = ' \\0 ' ; \n idx = parse_number_or_die ( opt , idx_str , OPT_INT , 0 , INT_MAX ) ; \n streamid_map = grow_array ( streamid_map , sizeof ( * streamid_map ) , & nb_streamid_map , idx + 1 ) ; \n streamid_map [ idx ] = parse_number_or_die ( opt , p , OPT_INT , 0 , INT_MAX ) ; \n return 0 ; \n }", "idx": 25642}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_16w_msa ( const uint8_t * src , int32_t src_stride , \n uint8_t * dst , int32_t dst_stride , \n int32_t height , uint8_t vert_offset ) \n { \n uint32_t multiple8_cnt ; \n for ( multiple8_cnt = 2 ; multiple8_cnt -- ; ) { \n avc_luma_midv_qrt_8w_msa ( src , src_stride , dst , dst_stride , height , \n vert_offset ) ; \n src += 8 ; \n dst += 8 ; \n } \n }", "idx": 25643}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_audio4 ( AVCodecContext * avctx , \n AVFrame * frame , \n int * got_frame_ptr , \n AVPacket * avpkt ) \n { \n int planar , channels ; \n int ret = 0 ; \n * got_frame_ptr = 0 ; \n avctx -> pkt = avpkt ; \n if ( ! avpkt -> data && avpkt -> size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n apply_param_change ( avctx , avpkt ) ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || avpkt -> size ) { \n ret = avctx -> codec -> decode ( avctx , frame , got_frame_ptr , avpkt ) ; \n if ( ret >= 0 && * got_frame_ptr ) { \n avctx -> frame_number ++ ; \n frame -> pkt_dts = avpkt -> dts ; \n if ( frame -> format == AV_SAMPLE_FMT_NONE ) \n frame -> format = avctx -> sample_fmt ; \n } \n } \n planar = av_sample_fmt_is_planar ( frame -> format ) ; \n channels = av_get_channel_layout_nb_channels ( frame -> channel_layout ) ; \n if ( ! ( planar && channels > AV_NUM_DATA_POINTERS ) ) \n frame -> extended_data = frame -> data ; \n return ret ; \n }", "idx": 25649}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "decode_lpc ( WmallDecodeCtx * s )  \n { \n int ch , i , cbits ; \n s -> lpc_order = get_bits ( & s -> gb , 5 ) + 1 ; \n s -> lpc_scaling = get_bits ( & s -> gb , 4 ) ; \n s -> lpc_intbits = get_bits ( & s -> gb , 3 ) + 1 ; \n cbits = s -> lpc_scaling + s -> lpc_intbits ; \n for ( ch = 0 ; ch < s -> num_channels ; ch ++ ) { \n for ( i = 0 ; i < s -> lpc_order ; i ++ ) { \n s -> lpc_coefs [ ch ] [ i ] = get_sbits ( & s -> gb , cbits ) ; \n } \n } \n }", "idx": 25658}
{"project": "FFmpeg", "commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "target": 1, "func": "static double get_scene_score ( AVFilterContext * ctx , AVFrame * crnt , AVFrame * next ) \n { \n FrameRateContext * s = ctx -> priv ; \n double ret = 0 ; \n ff_dlog ( ctx , \" \\n \" ) ; \n if ( crnt -> height == next -> height && \n crnt -> width == next -> width ) { \n int64_t sad ; \n double mafd , diff ; \n ff_dlog ( ctx , \" \\n \" ) ; \n if ( s -> bitdepth == 8 ) \n sad = scene_sad8 ( s , crnt -> data [ 0 ] , crnt -> linesize [ 0 ] , next -> data [ 0 ] , next -> linesize [ 0 ] , crnt -> height ) ; \n else \n sad = scene_sad16 ( s , ( const uint16_t * ) crnt -> data [ 0 ] , crnt -> linesize [ 0 ] >> 1 , ( const uint16_t * ) next -> data [ 0 ] , next -> linesize [ 0 ] >> 1 , crnt -> height ) ; \n mafd = ( double ) sad * 100.0 / ( crnt -> height * crnt -> width ) / ( 1 << s -> bitdepth ) ; \n diff = fabs ( mafd - s -> prev_mafd ) ; \n ret = av_clipf ( FFMIN ( mafd , diff ) , 0 , 100.0 ) ; \n s -> prev_mafd = mafd ; \n } \n ff_dlog ( ctx , \" \\n \" , ret ) ; \n return ret ; \n }", "idx": 25659}
{"project": "FFmpeg", "commit_id": "d68542f019c89e7938297a18da282e3a892718aa", "target": 0, "func": "static int decode_group3_1d_line ( AVCodecContext * avctx , GetBitContext * gb , \n int pix_left , int * runs ) \n { \n int mode = 0 , run = 0 ; \n unsigned int t ; \n for ( ; ; ) { \n t = get_vlc2 ( gb , ccitt_vlc [ mode ] . table , 9 , 2 ) ; \n run += t ; \n if ( t < 64 ) { \n pix_left -= run ; \n * runs ++ = run ; \n if ( pix_left <= 0 ) { \n if ( ! pix_left ) \n break ; \n runs [ -1 ] = 0 ; \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n run = 0 ; \n mode = ! mode ; \n } else if ( ( int ) t == -1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n } \n * runs ++ = 0 ; \n return 0 ; \n }", "idx": 25664}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_qcx ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q ) \n { \n int i , x ; \n if ( s -> buf_end - s -> buf < 1 ) \n return AVERROR ( EINVAL ) ; \n x = bytestream_get_byte ( & s -> buf ) ; \n q -> nguardbits = x >> 5 ; \n q -> quantsty = x & 0x1f ; \n if ( q -> quantsty == JPEG2000_QSTY_NONE ) { \n n -= 3 ; \n if ( s -> buf_end - s -> buf < n || 32 * 3 < n ) \n return AVERROR ( EINVAL ) ; \n for ( i = 0 ; i < n ; i ++ ) \n q -> expn [ i ] = bytestream_get_byte ( & s -> buf ) >> 3 ; \n } else if ( q -> quantsty == JPEG2000_QSTY_SI ) { \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR ( EINVAL ) ; \n x = bytestream_get_be16 ( & s -> buf ) ; \n q -> expn [ 0 ] = x >> 11 ; \n q -> mant [ 0 ] = x & 0x7ff ; \n for ( i = 1 ; i < 32 * 3 ; i ++ ) { \n int curexpn = FFMAX ( 0 , q -> expn [ 0 ] - ( i - 1 ) / 3 ) ; \n q -> expn [ i ] = curexpn ; \n q -> mant [ i ] = q -> mant [ 0 ] ; \n } \n } else { \n n = ( n - 3 ) >> 1 ; \n if ( s -> buf_end - s -> buf < 2 * n || 32 * 3 < n ) \n return AVERROR ( EINVAL ) ; \n for ( i = 0 ; i < n ; i ++ ) { \n x = bytestream_get_be16 ( & s -> buf ) ; \n q -> expn [ i ] = x >> 11 ; \n q -> mant [ i ] = x & 0x7ff ; \n } \n } \n return 0 ; \n }", "idx": 25665}
{"project": "FFmpeg", "commit_id": "be8d812c9635f31f69c30dff9ebf565a07a7dab7", "target": 1, "func": "static void ready_residue ( vorbis_enc_residue * rc , vorbis_enc_context * venc ) \n { \n int i ; \n assert ( rc -> type == 2 ) ; \n rc -> maxes = av_mallocz ( sizeof ( float [ 2 ] ) * rc -> classifications ) ; \n for ( i = 0 ; i < rc -> classifications ; i ++ ) { \n int j ; \n vorbis_enc_codebook * cb ; \n for ( j = 0 ; j < 8 ; j ++ ) \n if ( rc -> books [ i ] [ j ] != -1 ) \n break ; \n if ( j == 8 ) \n continue ; \n cb = & venc -> codebooks [ rc -> books [ i ] [ j ] ] ; \n assert ( cb -> ndimentions >= 2 ) ; \n assert ( cb -> lookup ) ; \n for ( j = 0 ; j < cb -> nentries ; j ++ ) { \n float a ; \n if ( ! cb -> lens [ j ] ) \n continue ; \n a = fabs ( cb -> dimentions [ j * cb -> ndimentions ] ) ; \n if ( a > rc -> maxes [ i ] [ 0 ] ) \n rc -> maxes [ i ] [ 0 ] = a ; \n a = fabs ( cb -> dimentions [ j * cb -> ndimentions + 1 ] ) ; \n if ( a > rc -> maxes [ i ] [ 1 ] ) \n rc -> maxes [ i ] [ 1 ] = a ; \n } \n } \n for ( i = 0 ; i < rc -> classifications ; i ++ ) { \n rc -> maxes [ i ] [ 0 ] += 0.8 ; \n rc -> maxes [ i ] [ 1 ] += 0.8 ; \n } \n }", "idx": 25667}
{"project": "FFmpeg", "commit_id": "7dabc78ce13e3baa37292f42df2364b4ccd2aa78", "target": 0, "func": "AVRational av_d2q ( double d , int max ) \n { \n AVRational a ; \n int exponent ; \n int64_t den ; \n if ( isnan ( d ) ) \n return ( AVRational ) { 0 , 0 } ; \n if ( fabs ( d ) > INT_MAX + 3LL ) \n return ( AVRational ) { d < 0 ? -1 : 1 , 0 } ; \n frexp ( d , & exponent ) ; \n exponent = FFMAX ( exponent - 1 , 0 ) ; \n den = 1LL << ( 61 - exponent ) ; \n av_reduce ( & a . num , & a . den , floor ( d * den + 0.5 ) , den , max ) ; \n if ( ( ! a . num || ! a . den ) && d && max > 0 && max < INT_MAX ) \n av_reduce ( & a . num , & a . den , floor ( d * den + 0.5 ) , den , INT_MAX ) ; \n return a ; \n }", "idx": 25677}
{"project": "FFmpeg", "commit_id": "ce1ebb31a9a0e556a89cd7681082af19fbc1cced", "target": 0, "func": "static unsigned tget ( GetByteContext * gb , int type , int le ) \n { \n switch ( type ) { \n case TIFF_BYTE : return bytestream2_get_byteu ( gb ) ; \n case TIFF_SHORT : return tget_short ( gb , le ) ; \n case TIFF_LONG : return tget_long ( gb , le ) ; \n default : return UINT_MAX ; \n } \n }", "idx": 25678}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( palToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width , uint32_t * pal ) \n { \n int i ; \n assert ( src1 == src2 ) ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int p = pal [ src1 [ i ] ] ; \n dstU [ i ] = p >> 8 ; \n dstV [ i ] = p >> 16 ; \n } \n }", "idx": 25684}
{"project": "FFmpeg", "commit_id": "7782cb207a09f4acf0b2a935ca81076b117660a2", "target": 1, "func": "static void targa_decode_rle ( AVCodecContext * avctx , TargaContext * s , const uint8_t * src , uint8_t * dst , int w , int h , int stride , int bpp ) \n { \n int i , x , y ; \n int depth = ( bpp + 1 ) >> 3 ; \n int type , count ; \n int diff ; \n diff = stride - w * depth ; \n x = y = 0 ; \n while ( y < h ) { \n type = * src ++ ; \n count = ( type & 0x7F ) + 1 ; \n type &= 0x80 ; \n if ( ( x + count > w ) && ( x + count + 1 > ( h - y ) * w ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , x , y , count ) ; \n return ; \n } \n for ( i = 0 ; i < count ; i ++ ) { \n switch ( depth ) { \n case 1 : \n * dst = * src ; \n break ; \n case 2 : \n * ( ( uint16_t * ) dst ) = AV_RL16 ( src ) ; \n break ; \n case 3 : \n dst [ 0 ] = src [ 0 ] ; \n dst [ 1 ] = src [ 1 ] ; \n dst [ 2 ] = src [ 2 ] ; \n break ; \n case 4 : \n * ( ( uint32_t * ) dst ) = AV_RL32 ( src ) ; \n break ; \n } \n dst += depth ; \n if ( ! type ) \n src += depth ; \n x ++ ; \n if ( x == w ) { \n x = 0 ; \n y ++ ; \n dst += diff ; \n } \n } \n if ( type ) \n src += depth ; \n } \n }", "idx": 25689}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "func": "static int mov_read_stts ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n int64_t duration = 0 ; \n int64_t total_sample_count = 0 ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n dprintf ( c -> fc , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stts_data ) ) \n return -1 ; \n sc -> stts_data = av_malloc ( entries * sizeof ( * sc -> stts_data ) ) ; \n if ( ! sc -> stts_data ) \n return AVERROR ( ENOMEM ) ; \n sc -> stts_count = entries ; \n for ( i = 0 ; i < entries ; i ++ ) { \n int sample_duration ; \n int sample_count ; \n sample_count = get_be32 ( pb ) ; \n sample_duration = get_be32 ( pb ) ; \n sc -> stts_data [ i ] . count = sample_count ; \n sc -> stts_data [ i ] . duration = sample_duration ; \n dprintf ( c -> fc , \" \\n \" , sample_count , sample_duration ) ; \n duration += ( int64_t ) sample_duration * sample_count ; \n total_sample_count += sample_count ; \n } \n st -> nb_frames = total_sample_count ; \n if ( duration ) \n st -> duration = duration ; \n return 0 ; \n }", "idx": 25703}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int decode_i_picture_secondary_header ( VC9Context * v ) \n { \n int status ; \n #if HAS_ADVANCED_PROFILE  \n  \n  if ( v -> profile > PROFILE_MAIN ) \n { \n v -> s . ac_pred = get_bits ( & v -> s . gb , 1 ) ; \n if ( v -> postprocflag ) v -> postproc = get_bits ( & v -> s . gb , 1 ) ; \n if ( v -> overlap && v -> pq < 9 ) \n { \n v -> condover = get_bits ( & v -> s . gb , 1 ) ; \n if ( v -> condover ) \n { \n v -> condover = 2 + get_bits ( & v -> s . gb , 1 ) ; \n if ( v -> condover == 3 ) \n { \n status = bitplane_decoding ( & v -> over_flags_plane , v ) ; \n if ( status < 0 ) return -1 ; \n #  if TRACE  \n  \n  av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , status >> 1 , status & 1 ) ; \n #  endif \n } \n } \n } \n } \n #endif \n return 0 ; \n }", "idx": 25718}
{"project": "FFmpeg", "commit_id": "4ed899f2c5848b75b61d13ad42942ecc2a4386f9", "target": 1, "func": "static AVStream * get_subtitle_pkt ( AVFormatContext * s , AVStream * next_st , \n AVPacket * pkt ) \n { \n AVIStream * ast , * next_ast = next_st -> priv_data ; \n int64_t ts , next_ts , ts_min = INT64_MAX ; \n AVStream * st , * sub_st = NULL ; \n int i ; \n next_ts = av_rescale_q ( next_ast -> frame_offset , next_st -> time_base , \n AV_TIME_BASE_Q ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n st = s -> streams [ i ] ; \n ast = st -> priv_data ; \n if ( st -> discard < AVDISCARD_ALL && ast -> sub_pkt . data ) { \n ts = av_rescale_q ( ast -> sub_pkt . dts , st -> time_base , AV_TIME_BASE_Q ) ; \n if ( ts <= next_ts && ts < ts_min ) { \n ts_min = ts ; \n sub_st = st ; \n } \n } \n } \n if ( sub_st ) { \n ast = sub_st -> priv_data ; \n * pkt = ast -> sub_pkt ; \n pkt -> stream_index = sub_st -> index ; \n if ( av_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) < 0 ) \n ast -> sub_pkt . data = NULL ; \n } \n return sub_st ; \n }", "idx": 25720}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb15ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int d = ( ( uint16_t * ) src ) [ i ] ; \n int r = d & 0x1F ; \n int g = ( d >> 5 ) & 0x1F ; \n int b = ( d >> 10 ) & 0x1F ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b ) >> ( RGB2YUV_SHIFT - 3 ) ) + 16 ; \n } \n }", "idx": 25727}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( uyvytoyuv420 ) ( uint8_t * ydst , uint8_t * udst , uint8_t * vdst , const uint8_t * src , \n long width , long height , \n long lumStride , long chromStride , long srcStride ) \n { \n long y ; \n const long chromWidth = - ( ( - width ) >> 1 ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n RENAME ( extract_even ) ( src + 1 , ydst , width ) ; \n if ( y & 1 ) { \n RENAME ( extract_even2avg ) ( src - srcStride , src , udst , vdst , chromWidth ) ; \n udst += chromStride ; \n vdst += chromStride ; \n } \n src += srcStride ; \n ydst += lumStride ; \n } \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ ( \n EMMS \" \\n \\t \" \n SFENCE \" \\n \\t \" \n :: : \" \" \n ) ; \n #endif \n }", "idx": 25730}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_close ( AVFormatContext * s ) \n { \n LibQuviContext * qc = s -> priv_data ; \n if ( qc -> fmtctx ) \n avformat_close_input ( & qc -> fmtctx ) ; \n return 0 ; \n }", "idx": 25739}
{"project": "FFmpeg", "commit_id": "ea4f8aabab2a5a7ebd232b45557c11c4c59c332b", "target": 1, "func": "static int prepare_sdp_description ( FFStream * stream , uint8_t * * pbuffer , \n struct in_addr my_ip ) \n { \n AVFormatContext * avc ; \n AVStream avs [ MAX_STREAMS ] ; \n int i ; \n avc = avformat_alloc_context ( ) ; \n if ( avc == NULL ) { \n return -1 ; \n } \n av_metadata_set2 ( & avc -> metadata , \" \" , \n stream -> title [ 0 ] ? stream -> title : \" \" , 0 ) ; \n avc -> nb_streams = stream -> nb_streams ; \n if ( stream -> is_multicast ) { \n snprintf ( avc -> filename , 1024 , \" \n inet_ntoa ( stream -> multicast_ip ) , \n stream -> multicast_port , stream -> multicast_ttl ) ; \n } else { \n snprintf ( avc -> filename , 1024 , \" \n } \n for ( i = 0 ; i < stream -> nb_streams ; i ++ ) { \n avc -> streams [ i ] = & avs [ i ] ; \n avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec ; \n } \n * pbuffer = av_mallocz ( 2048 ) ; \n avf_sdp_create ( & avc , 1 , * pbuffer , 2048 ) ; \n av_free ( avc ) ; \n return strlen ( * pbuffer ) ; \n }", "idx": 25742}
{"project": "FFmpeg", "commit_id": "a67304d05f11b2377bf157a356d7ebb00f3e06dd", "target": 0, "func": "void av_md5_update ( AVMD5 * ctx , const uint8_t * src , int len ) \n { \n const uint8_t * end ; \n int j ; \n j = ctx -> len & 63 ; \n ctx -> len += len ; \n if ( j ) { \n int cnt = FFMIN ( len , 64 - j ) ; \n memcpy ( ctx -> block + j , src , cnt ) ; \n src += cnt ; \n len -= cnt ; \n if ( j + cnt < 64 ) \n return ; \n body ( ctx -> ABCD , ( uint32_t * ) ctx -> block ) ; \n } \n end = src + ( len & ~ 63 ) ; \n if ( HAVE_BIGENDIAN || ( ! HAVE_FAST_UNALIGNED && ( ( intptr_t ) src & 3 ) ) ) { \n while ( src < end ) { \n memcpy ( ctx -> block , src , 64 ) ; \n body ( ctx -> ABCD , ( uint32_t * ) ctx -> block ) ; \n src += 64 ; \n } \n } else { \n while ( src < end ) { \n body ( ctx -> ABCD , ( uint32_t * ) src ) ; \n src += 64 ; \n } \n } \n len &= 63 ; \n if ( len > 0 ) \n memcpy ( ctx -> block , src , len ) ; \n }", "idx": 25759}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_decode_init ( AVCodecContext * avctx ) \n { \n XanContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n if ( ( avctx -> codec -> id == CODEC_ID_XAN_WC3 ) && \n ( s -> avctx -> palctrl == NULL ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n avctx -> has_b_frames = 0 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n y_r_table [ i ] = Y_R * i ; \n y_g_table [ i ] = Y_G * i ; \n y_b_table [ i ] = Y_B * i ; \n u_r_table [ i ] = U_R * i ; \n u_g_table [ i ] = U_G * i ; \n u_b_table [ i ] = U_B * i ; \n v_r_table [ i ] = V_R * i ; \n v_g_table [ i ] = V_G * i ; \n v_b_table [ i ] = V_B * i ; \n } \n if ( avcodec_check_dimensions ( avctx , avctx -> width , avctx -> height ) ) \n return -1 ; \n s -> buffer1 = av_malloc ( avctx -> width * avctx -> height ) ; \n s -> buffer2 = av_malloc ( avctx -> width * avctx -> height ) ; \n if ( ! s -> buffer1 || ! s -> buffer2 ) \n return -1 ; \n return 0 ; \n }", "idx": 25770}
{"project": "FFmpeg", "commit_id": "d5028f61e44b7607b6a547f218f7d85217490a5b", "target": 1, "func": "static av_always_inline int mvd_decode ( HEVCContext * s ) \n { \n int ret = 2 ; \n int k = 1 ; \n while ( k < CABAC_MAX_BIN && get_cabac_bypass ( & s -> HEVClc -> cc ) ) { \n ret += 1 << k ; \n k ++ ; \n } \n if ( k == CABAC_MAX_BIN ) \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , k ) ; \n while ( k -- ) \n ret += get_cabac_bypass ( & s -> HEVClc -> cc ) << k ; \n return get_cabac_bypass_sign ( & s -> HEVClc -> cc , - ret ) ; \n }", "idx": 25788}
{"project": "FFmpeg", "commit_id": "efd6b80b402a54923f007378a7dc5397676a8f3a", "target": 1, "func": "int ff_raw_read_partial_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n int ret , size ; \n size = RAW_PACKET_SIZE ; \n if ( av_new_packet ( pkt , size ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n pkt -> pos = avio_tell ( s -> pb ) ; \n pkt -> stream_index = 0 ; \n ret = ffio_read_partial ( s -> pb , pkt -> data , size ) ; \n if ( ret < 0 ) { \n av_free_packet ( pkt ) ; \n return ret ; \n } \n pkt -> size = ret ; \n return ret ; \n }", "idx": 25793}
{"project": "FFmpeg", "commit_id": "ea1e630c47e70672a7933c048090601ce09c8195", "target": 1, "func": "static int rv34_decoder_alloc ( RV34DecContext * r ) \n { \n r -> intra_types_stride = r -> s . mb_width * 4 + 4 ; \n r -> cbp_chroma = av_malloc ( r -> s . mb_stride * r -> s . mb_height * \n sizeof ( * r -> cbp_chroma ) ) ; \n r -> cbp_luma = av_malloc ( r -> s . mb_stride * r -> s . mb_height * \n sizeof ( * r -> cbp_luma ) ) ; \n r -> deblock_coefs = av_malloc ( r -> s . mb_stride * r -> s . mb_height * \n sizeof ( * r -> deblock_coefs ) ) ; \n r -> intra_types_hist = av_malloc ( r -> intra_types_stride * 4 * 2 * \n sizeof ( * r -> intra_types_hist ) ) ; \n r -> mb_type = av_mallocz ( r -> s . mb_stride * r -> s . mb_height * \n sizeof ( * r -> mb_type ) ) ; \n if ( ! ( r -> cbp_chroma && r -> cbp_luma && r -> deblock_coefs && \n r -> intra_types_hist && r -> mb_type ) ) { \n rv34_decoder_free ( r ) ; \n return AVERROR ( ENOMEM ) ; \n } \n r -> intra_types = r -> intra_types_hist + r -> intra_types_stride * 4 ; \n return 0 ; \n }", "idx": 25798}
{"project": "FFmpeg", "commit_id": "f23dc1e1f9ee3a00db951d3dec7d5bfb0e04dae8", "target": 1, "func": "static void decode_band_structure ( GetBitContext * gbc , int blk , int eac3 , \n int ecpl , int start_subband , int end_subband , \n const uint8_t * default_band_struct , \n uint8_t * band_struct , int * num_subbands , \n int * num_bands , uint8_t * band_sizes ) \n { \n int subbnd , bnd , n_subbands , n_bands ; \n uint8_t bnd_sz [ 22 ] ; \n n_subbands = end_subband - start_subband ; \n if ( ! eac3 || get_bits1 ( gbc ) ) { \n for ( subbnd = 0 ; subbnd < n_subbands - 1 ; subbnd ++ ) { \n band_struct [ subbnd ] = get_bits1 ( gbc ) ; \n } \n } else if ( ! blk ) { \n memcpy ( band_struct , \n & default_band_struct [ start_subband + 1 ] , \n n_subbands - 1 ) ; \n } \n band_struct [ n_subbands - 1 ] = 0 ; \n if ( num_bands || band_sizes ) { \n n_bands = n_subbands ; \n bnd_sz [ 0 ] = ecpl ? 6 : 12 ; \n for ( bnd = 0 , subbnd = 1 ; subbnd < n_subbands ; subbnd ++ ) { \n int subbnd_size = ( ecpl && subbnd < 4 ) ? 6 : 12 ; \n if ( band_struct [ subbnd - 1 ] ) { \n n_bands -- ; \n bnd_sz [ bnd ] += subbnd_size ; \n } else { \n bnd_sz [ ++ bnd ] = subbnd_size ; \n } \n } \n } \n if ( num_subbands ) \n * num_subbands = n_subbands ; \n if ( num_bands ) \n * num_bands = n_bands ; \n if ( band_sizes ) \n memcpy ( band_sizes , bnd_sz , n_bands ) ; \n }", "idx": 25801}
{"project": "FFmpeg", "commit_id": "247e658784ead984f96021acb9c95052ba599f26", "target": 0, "func": "static int ftp_get_line ( FTPContext * s , char * line , int line_size ) \n { \n int ch ; \n char * q = line ; \n int ori_block_flag = s -> conn_control_block_flag ; \n for ( ; ; ) { \n ch = ftp_getc ( s ) ; \n if ( ch < 0 ) { \n s -> conn_control_block_flag = ori_block_flag ; \n return ch ; \n } \n if ( ch == ' \\n ' ) { \n if ( q > line && q [ -1 ] == ' \\r ' ) \n q -- ; \n * q = ' \\0 ' ; \n s -> conn_control_block_flag = ori_block_flag ; \n return 0 ; \n } else { \n s -> conn_control_block_flag = 0 ; \n if ( ( q - line ) < line_size - 1 ) \n * q ++ = ch ; \n } \n } \n }", "idx": 25818}
{"project": "FFmpeg", "commit_id": "df640dbbc949d0f4deefaf43e86b8bd50ae997cc", "target": 1, "func": "static void wmv2_idct_row ( short * b ) \n { \n int s1 , s2 ; \n int a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ; \n a1 = W1 * b [ 1 ] + W7 * b [ 7 ] ; \n a7 = W7 * b [ 1 ] - W1 * b [ 7 ] ; \n a5 = W5 * b [ 5 ] + W3 * b [ 3 ] ; \n a3 = W3 * b [ 5 ] - W5 * b [ 3 ] ; \n a2 = W2 * b [ 2 ] + W6 * b [ 6 ] ; \n a6 = W6 * b [ 2 ] - W2 * b [ 6 ] ; \n a0 = W0 * b [ 0 ] + W0 * b [ 4 ] ; \n a4 = W0 * b [ 0 ] - W0 * b [ 4 ] ; \n s1 = ( 181 * ( a1 - a5 + a7 - a3 ) + 128 ) >> 8 ; \n s2 = ( 181 * ( a1 - a5 - a7 + a3 ) + 128 ) >> 8 ; \n b [ 0 ] = ( a0 + a2 + a1 + a5 + ( 1 << 7 ) ) >> 8 ; \n b [ 1 ] = ( a4 + a6 + s1 + ( 1 << 7 ) ) >> 8 ; \n b [ 2 ] = ( a4 - a6 + s2 + ( 1 << 7 ) ) >> 8 ; \n b [ 3 ] = ( a0 - a2 + a7 + a3 + ( 1 << 7 ) ) >> 8 ; \n b [ 4 ] = ( a0 - a2 - a7 - a3 + ( 1 << 7 ) ) >> 8 ; \n b [ 5 ] = ( a4 - a6 - s2 + ( 1 << 7 ) ) >> 8 ; \n b [ 6 ] = ( a4 + a6 - s1 + ( 1 << 7 ) ) >> 8 ; \n b [ 7 ] = ( a0 + a2 - a1 - a5 + ( 1 << 7 ) ) >> 8 ; \n }", "idx": 25829}
{"project": "FFmpeg", "commit_id": "1509d739a036b9838e12f28dac9f09ac37bc3928", "target": 1, "func": "static void d3d11va_frames_uninit ( AVHWFramesContext * ctx ) \n { \n AVD3D11VAFramesContext * frames_hwctx = ctx -> hwctx ; \n D3D11VAFramesContext * s = ctx -> internal -> priv ; \n if ( frames_hwctx -> texture ) \n ID3D11Texture2D_Release ( frames_hwctx -> texture ) ; \n if ( s -> staging_texture ) \n ID3D11Texture2D_Release ( s -> staging_texture ) ; \n }", "idx": 25833}
{"project": "FFmpeg", "commit_id": "b5ef6f8eb452c37b19d973d61548725d7b91113e", "target": 1, "func": "static void choose_pixel_fmt ( AVStream * st , AVCodec * codec ) \n { \n if ( codec && codec -> pix_fmts ) { \n const enum PixelFormat * p = codec -> pix_fmts ; \n if ( st -> codec -> strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL ) { \n if ( st -> codec -> codec_id == CODEC_ID_MJPEG ) { \n p = ( const enum PixelFormat [ ] ) { PIX_FMT_YUVJ420P , PIX_FMT_YUVJ422P , PIX_FMT_YUV420P , PIX_FMT_YUV422P , PIX_FMT_NONE } ; \n } else if ( st -> codec -> codec_id == CODEC_ID_LJPEG ) { \n p = ( const enum PixelFormat [ ] ) { PIX_FMT_YUVJ420P , PIX_FMT_YUVJ422P , PIX_FMT_YUVJ444P , PIX_FMT_YUV420P , PIX_FMT_YUV422P , PIX_FMT_YUV444P , PIX_FMT_BGRA , PIX_FMT_NONE } ; \n } \n } \n for ( ; * p != -1 ; p ++ ) { \n if ( * p == st -> codec -> pix_fmt ) \n break ; \n } \n if ( * p == -1 ) { \n av_log ( NULL , AV_LOG_WARNING , \n \" \\n \" , \n av_pix_fmt_descriptors [ st -> codec -> pix_fmt ] . name , \n codec -> name , \n av_pix_fmt_descriptors [ codec -> pix_fmts [ 0 ] ] . name ) ; \n st -> codec -> pix_fmt = codec -> pix_fmts [ 0 ] ; \n } \n } \n }", "idx": 25851}
{"project": "FFmpeg", "commit_id": "0a41faa9a77dc83d8d933e99f1ba902ecd146e79", "target": 1, "func": "av_cold int vp56_free ( AVCodecContext * avctx ) \n { \n VP56Context * s = avctx -> priv_data ; \n int pt ; \n av_freep ( & s -> qscale_table ) ; \n av_freep ( & s -> above_blocks ) ; \n av_freep ( & s -> macroblocks ) ; \n av_freep ( & s -> edge_emu_buffer_alloc ) ; \n if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] ) \n avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ) ; \n if ( s -> framep [ VP56_FRAME_GOLDEN2 ] -> data [ 0 ] ) \n avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN2 ] ) ; \n if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] ) \n avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ) ; \n return 0 ; ", "idx": 25855}
{"project": "FFmpeg", "commit_id": "b5995856a4236c27f231210bb08d70688e045192", "target": 1, "func": "static void decode_block_params ( DiracContext * s , DiracArith arith [ 8 ] , DiracBlock * block , \n int stride , int x , int y ) \n { \n int i ; \n block -> ref = pred_block_mode ( block , stride , x , y , DIRAC_REF_MASK_REF1 ) ; \n block -> ref ^= dirac_get_arith_bit ( arith , CTX_PMODE_REF1 ) ; \n if ( s -> num_refs == 2 ) { \n block -> ref |= pred_block_mode ( block , stride , x , y , DIRAC_REF_MASK_REF2 ) ; \n block -> ref ^= dirac_get_arith_bit ( arith , CTX_PMODE_REF2 ) << 1 ; \n } \n if ( ! block -> ref ) { \n pred_block_dc ( block , stride , x , y ) ; \n for ( i = 0 ; i < 3 ; i ++ ) \n block -> u . dc [ i ] += dirac_get_arith_int ( arith + 1 + i , CTX_DC_F1 , CTX_DC_DATA ) ; \n return ; \n } \n if ( s -> globalmc_flag ) { \n block -> ref |= pred_block_mode ( block , stride , x , y , DIRAC_REF_MASK_GLOBAL ) ; \n block -> ref ^= dirac_get_arith_bit ( arith , CTX_GLOBAL_BLOCK ) << 2 ; \n } \n for ( i = 0 ; i < s -> num_refs ; i ++ ) \n if ( block -> ref & ( i + 1 ) ) { \n if ( block -> ref & DIRAC_REF_MASK_GLOBAL ) { \n global_mv ( s , block , x , y , i ) ; \n } else { \n pred_mv ( block , stride , x , y , i ) ; \n block -> u . mv [ i ] [ 0 ] += dirac_get_arith_int ( arith + 4 + 2 * i , CTX_MV_F1 , CTX_MV_DATA ) ; \n block -> u . mv [ i ] [ 1 ] += dirac_get_arith_int ( arith + 5 + 2 * i , CTX_MV_F1 , CTX_MV_DATA ) ; \n } \n } \n }", "idx": 25857}
{"project": "FFmpeg", "commit_id": "ccce2248bf56692fc7bd436ca2c9acca772d486a", "target": 1, "func": "static void vp7_luma_dc_wht_c ( int16_t block [ 4 ] [ 4 ] [ 16 ] , int16_t dc [ 16 ] ) \n { \n int i , a1 , b1 , c1 , d1 ; \n int16_t tmp [ 16 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n a1 = ( dc [ i * 4 + 0 ] + dc [ i * 4 + 2 ] ) * 23170 ; \n b1 = ( dc [ i * 4 + 0 ] - dc [ i * 4 + 2 ] ) * 23170 ; \n c1 = dc [ i * 4 + 1 ] * 12540 - dc [ i * 4 + 3 ] * 30274 ; \n d1 = dc [ i * 4 + 1 ] * 30274 + dc [ i * 4 + 3 ] * 12540 ; \n tmp [ i * 4 + 0 ] = ( a1 + d1 ) >> 14 ; \n tmp [ i * 4 + 3 ] = ( a1 - d1 ) >> 14 ; \n tmp [ i * 4 + 1 ] = ( b1 + c1 ) >> 14 ; \n tmp [ i * 4 + 2 ] = ( b1 - c1 ) >> 14 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n a1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ; \n b1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ; \n c1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ; \n d1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ; \n AV_ZERO64 ( dc + i * 4 ) ; \n block [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) >> 18 ; \n block [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) >> 18 ; \n block [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) >> 18 ; \n block [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) >> 18 ; \n } \n }", "idx": 25873}
{"project": "FFmpeg", "commit_id": "fd2982a0a01942091b2f08e17486ff4562f675a6", "target": 0, "func": "int av_read_pause ( AVFormatContext * s ) \n { \n if ( s -> iformat -> read_pause ) \n return s -> iformat -> read_pause ( s ) ; \n if ( s -> pb && s -> pb -> read_pause ) \n return av_url_read_fpause ( s -> pb , 1 ) ; \n return AVERROR ( ENOSYS ) ; \n }", "idx": 25877}
{"project": "FFmpeg", "commit_id": "d5128fce38646d3f64c55feda42084888ba0e87e", "target": 1, "func": "static void decode_array_0000 ( APEContext * ctx , GetBitContext * gb , \n int32_t * out , APERice * rice , int blockstodecode ) \n { \n int i ; \n int ksummax , ksummin ; \n rice -> ksum = 0 ; \n for ( i = 0 ; i < 5 ; i ++ ) { \n out [ i ] = get_rice_ook ( & ctx -> gb , 10 ) ; \n rice -> ksum += out [ i ] ; \n } \n rice -> k = av_log2 ( rice -> ksum / 10 ) + 1 ; \n for ( ; i < 64 ; i ++ ) { \n out [ i ] = get_rice_ook ( & ctx -> gb , rice -> k ) ; \n rice -> ksum += out [ i ] ; \n rice -> k = av_log2 ( rice -> ksum / ( ( i + 1 ) * 2 ) ) + 1 ; \n } \n ksummax = 1 << rice -> k + 7 ; \n ksummin = rice -> k ? ( 1 << rice -> k + 6 ) : 0 ; \n for ( ; i < blockstodecode ; i ++ ) { \n out [ i ] = get_rice_ook ( & ctx -> gb , rice -> k ) ; \n rice -> ksum += out [ i ] - out [ i - 64 ] ; \n while ( rice -> ksum < ksummin ) { \n rice -> k -- ; \n ksummin = rice -> k ? ksummin >> 1 : 0 ; \n ksummax >>= 1 ; \n } \n while ( rice -> ksum >= ksummax ) { \n rice -> k ++ ; \n if ( rice -> k > 24 ) \n ksummax <<= 1 ; \n ksummin = ksummin ? ksummin << 1 : 128 ; \n } \n } \n for ( i = 0 ; i < blockstodecode ; i ++ ) { \n if ( out [ i ] & 1 ) \n out [ i ] = ( out [ i ] >> 1 ) + 1 ; \n else \n out [ i ] = - ( out [ i ] >> 1 ) ; \n } \n }", "idx": 25883}
{"project": "FFmpeg", "commit_id": "aac8b76983e340bc744d3542d676f72efa3b474f", "target": 0, "func": "static void filter_mb_edgeh ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 4 ] , int qp ) { \n int i , d ; \n const int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = ( alpha_table + 52 ) [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n const int pix_next = stride ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) \n tc [ i ] = bS [ i ] ? ( tc0_table + 52 ) [ index_a ] [ bS [ i ] - 1 ] : -1 ; \n h -> s . dsp . h264_v_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_v_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 25884}
{"project": "FFmpeg", "commit_id": "53ea595eec984e3109310e8bb7ff4b5786d91057", "target": 1, "func": "static int mov_seek_stream ( AVFormatContext * s , AVStream * st , int64_t timestamp , int flags ) \n { \n MOVStreamContext * sc = st -> priv_data ; \n int sample , time_sample ; \n int i ; \n sample = av_index_search_timestamp ( st , timestamp , flags ) ; \n av_log ( s , AV_LOG_TRACE , \" \" PRId64 \" \\n \" , st -> index , timestamp , sample ) ; \n if ( sample < 0 && st -> nb_index_entries && timestamp < st -> index_entries [ 0 ] . timestamp ) \n sample = 0 ; \n if ( sample < 0 ) \n return AVERROR_INVALIDDATA ; \n sc -> current_sample = sample ; \n av_log ( s , AV_LOG_TRACE , \" \\n \" , st -> index , sc -> current_sample ) ; \n if ( sc -> ctts_data ) { \n time_sample = 0 ; \n for ( i = 0 ; i < sc -> ctts_count ; i ++ ) { \n int next = time_sample + sc -> ctts_data [ i ] . count ; \n if ( next > sc -> current_sample ) { \n sc -> ctts_index = i ; \n sc -> ctts_sample = sc -> current_sample - time_sample ; \n break ; \n } \n time_sample = next ; \n } \n } \n time_sample = 0 ; \n for ( i = 0 ; i < sc -> stsc_count ; i ++ ) { \n int next = time_sample + mov_get_stsc_samples ( sc , i ) ; \n if ( next > sc -> current_sample ) { \n sc -> stsc_index = i ; \n sc -> stsc_sample = sc -> current_sample - time_sample ; \n break ; \n } \n time_sample = next ; \n } \n return sample ; \n }", "idx": 25887}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int advanced_decode_i_mbs ( VC9Context * v ) \n { \n MpegEncContext * s = & v -> s ; \n GetBitContext * gb = & v -> s . gb ; \n int mqdiff , mquant , current_mb = 0 , over_flags_mb = 0 ; \n for ( s -> mb_y = 0 ; s -> mb_y < s -> mb_height ; s -> mb_y ++ ) \n { \n for ( s -> mb_x = 0 ; s -> mb_x < s -> mb_width ; s -> mb_x ++ ) \n { \n if ( v -> ac_pred_plane . is_raw ) \n s -> ac_pred = get_bits ( gb , 1 ) ; \n else \n s -> ac_pred = v -> ac_pred_plane . data [ current_mb ] ; \n if ( v -> condover == 3 && v -> over_flags_plane . is_raw ) \n over_flags_mb = get_bits ( gb , 1 ) ; \n GET_MQUANT ( ) ; \n } \n current_mb ++ ; \n } \n return 0 ; \n }", "idx": 25888}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "static void start_frame ( AVFilterLink * inlink , AVFilterBufferRef * picref ) \n { \n PixdescTestContext * priv = inlink -> dst -> priv ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * outpicref ; \n int i ; \n outlink -> out_buf = avfilter_get_video_buffer ( outlink , AV_PERM_WRITE , \n outlink -> w , outlink -> h ) ; \n outpicref = outlink -> out_buf ; \n avfilter_copy_buffer_ref_props ( outpicref , picref ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n int h = outlink -> h ; \n h = i == 1 || i == 2 ? h >> priv -> pix_desc -> log2_chroma_h : h ; \n if ( outpicref -> data [ i ] ) { \n uint8_t * data = outpicref -> data [ i ] + \n ( outpicref -> linesize [ i ] > 0 ? 0 : outpicref -> linesize [ i ] * ( h - 1 ) ) ; \n memset ( data , 0 , FFABS ( outpicref -> linesize [ i ] ) * h ) ; \n } \n } \n if ( priv -> pix_desc -> flags & PIX_FMT_PAL ) \n memcpy ( outpicref -> data [ 1 ] , outpicref -> data [ 1 ] , 256 * 4 ) ; \n avfilter_start_frame ( outlink , avfilter_ref_buffer ( outpicref , ~ 0 ) ) ; \n }", "idx": 25894}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int mov_read_aclr ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n int ret = 0 ; \n int length = 0 ; \n uint64_t original_size ; \n if ( c -> fc -> nb_streams >= 1 ) { \n AVCodecContext * codec = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] -> codec ; \n if ( codec -> codec_id == AV_CODEC_ID_H264 ) \n return 0 ; \n if ( atom . size == 16 ) { \n original_size = codec -> extradata_size ; \n ret = mov_realloc_extradata ( codec , atom ) ; \n if ( ! ret ) { \n length = mov_read_atom_into_extradata ( c , pb , atom , codec , codec -> extradata + original_size ) ; \n if ( length == atom . size ) { \n const uint8_t range_value = codec -> extradata [ original_size + 19 ] ; \n switch ( range_value ) { \n case 1 : \n codec -> color_range = AVCOL_RANGE_MPEG ; \n break ; \n case 2 : \n codec -> color_range = AVCOL_RANGE_JPEG ; \n break ; \n default : \n av_log ( c , AV_LOG_WARNING , \" \\n \" , range_value ) ; \n break ; \n } \n av_dlog ( c , \" \\n \" , codec -> color_range ) ; \n } else { \n av_log ( c , AV_LOG_ERROR , \" \\n \" ) ; \n } \n } else { \n av_log ( c , AV_LOG_ERROR , \" \\n \" ) ; \n } \n } else { \n av_log ( c , AV_LOG_WARNING , \" \" PRId64 \" \\n \" , atom . size ) ; \n } \n } \n return ret ; \n }", "idx": 25897}
{"project": "FFmpeg", "commit_id": "e9266a2be04ea505285e32e411ef6120e9cbeba4", "target": 0, "func": "static av_always_inline void filter_level_for_mb ( VP8Context * s , VP8Macroblock * mb , VP8FilterStrength * f ) \n { \n int interior_limit , filter_level ; \n if ( s -> segmentation . enabled ) { \n filter_level = s -> segmentation . filter_level [ s -> segment ] ; \n if ( ! s -> segmentation . absolute_vals ) \n filter_level += s -> filter . level ; \n } else \n filter_level = s -> filter . level ; \n if ( s -> lf_delta . enabled ) { \n filter_level += s -> lf_delta . ref [ mb -> ref_frame ] ; \n filter_level += s -> lf_delta . mode [ mb -> mode ] ; \n } \n #define POW2CLIP ( x , max )  (((x) & ~max) ? (-(x))>>31 & max : (x));  \n  \n  filter_level = POW2CLIP ( filter_level , 63 ) ; \n interior_limit = filter_level ; \n if ( s -> filter . sharpness ) { \n interior_limit >>= s -> filter . sharpness > 4 ? 2 : 1 ; \n interior_limit = FFMIN ( interior_limit , 9 - s -> filter . sharpness ) ; \n } \n interior_limit = FFMAX ( interior_limit , 1 ) ; \n f -> filter_level = filter_level ; \n f -> inner_limit = interior_limit ; \n f -> inner_filter = ! mb -> skip || mb -> mode == MODE_I4x4 || mb -> mode == VP8_MVMODE_SPLIT ; \n }", "idx": 25898}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr16 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x3E0 ) >> 5 ; \n b = ( rgb & 0x7C00 ) >> 10 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x3F ) << 5 ) | ( ( r & 0x1F ) << 11 ) ; \n } \n }", "idx": 25899}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_index_table_segment ( MXFIndexTableSegment * segment , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x3F05 : dprintf ( NULL , \" \\n \" , get_be32 ( pb ) ) ; break ; \n case 0x3F06 : dprintf ( NULL , \" \\n \" , get_be32 ( pb ) ) ; break ; \n case 0x3F07 : dprintf ( NULL , \" \\n \" , get_be32 ( pb ) ) ; break ; \n case 0x3F0B : dprintf ( NULL , \" \\n \" , get_be32 ( pb ) , get_be32 ( pb ) ) ; break ; \n case 0x3F0C : dprintf ( NULL , \" \\n \" , get_be64 ( pb ) ) ; break ; \n case 0x3F0D : dprintf ( NULL , \" \\n \" , get_be64 ( pb ) ) ; break ; \n } \n return 0 ; \n }", "idx": 25901}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void yuv2nv12X_c ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , int chrFilterSize , \n const int16_t * * alpSrc , uint8_t * dest , uint8_t * uDest , \n uint8_t * vDest , uint8_t * aDest , \n int dstW , int chrDstW ) \n { \n enum PixelFormat dstFormat = c -> dstFormat ; \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( ! uDest ) \n return ; \n if ( dstFormat == PIX_FMT_NV12 ) \n for ( i = 0 ; i < chrDstW ; i ++ ) { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) { \n u += chrUSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrVSrc [ j ] [ i ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( u >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( v >> 19 ) ; \n } \n else \n for ( i = 0 ; i < chrDstW ; i ++ ) { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) { \n u += chrUSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrVSrc [ j ] [ i ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( v >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( u >> 19 ) ; \n } \n }", "idx": 25905}
{"project": "FFmpeg", "commit_id": "0e15b7b0dde44130069739bfb98c29e74c72be86", "target": 0, "func": "static void gxf_write_padding ( ByteIOContext * pb , offset_t to_pad ) \n { \n while ( to_pad -- ) { \n put_byte ( pb , 0 ) ; \n } \n }", "idx": 25914}
{"project": "FFmpeg", "commit_id": "3941df546276b190cc9362fd093e6721e8e52f50", "target": 0, "func": "static int aea_read_header ( AVFormatContext * s ) \n { \n AVStream * st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n avio_skip ( s -> pb , 264 ) ; \n st -> codec -> channels = avio_r8 ( s -> pb ) ; \n avio_skip ( s -> pb , 1783 ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codec -> codec_id = AV_CODEC_ID_ATRAC1 ; \n st -> codec -> sample_rate = 44100 ; \n st -> codec -> bit_rate = 292000 ; \n if ( st -> codec -> channels != 1 && st -> codec -> channels != 2 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , st -> codec -> channels ) ; \n return -1 ; \n } \n st -> codec -> channel_layout = ( st -> codec -> channels == 1 ) ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO ; \n st -> codec -> block_align = AT1_SU_SIZE * st -> codec -> channels ; \n return 0 ; \n }", "idx": 25915}
{"project": "FFmpeg", "commit_id": "a66099192159d02b1a1c1820ddb24c7cea271a44", "target": 0, "func": "static int64_t mpegts_get_dts ( AVFormatContext * s , int stream_index , \n int64_t * ppos , int64_t pos_limit ) \n { \n MpegTSContext * ts = s -> priv_data ; \n int64_t pos ; \n int pos47 = ts -> pos47_full % ts -> raw_packet_size ; \n pos = ( ( * ppos + ts -> raw_packet_size - 1 - pos47 ) / ts -> raw_packet_size ) * ts -> raw_packet_size + pos47 ; \n ff_read_frame_flush ( s ) ; \n if ( avio_seek ( s -> pb , pos , SEEK_SET ) < 0 ) \n return AV_NOPTS_VALUE ; \n while ( pos < pos_limit ) { \n int ret ; \n AVPacket pkt ; \n av_init_packet ( & pkt ) ; \n ret = av_read_frame ( s , & pkt ) ; \n if ( ret < 0 ) \n return AV_NOPTS_VALUE ; \n av_free_packet ( & pkt ) ; \n if ( pkt . dts != AV_NOPTS_VALUE && pkt . pos >= 0 ) { \n ff_reduce_index ( s , pkt . stream_index ) ; \n av_add_index_entry ( s -> streams [ pkt . stream_index ] , pkt . pos , pkt . dts , 0 , 0 , AVINDEX_KEYFRAME \n ) ; \n if ( pkt . stream_index == stream_index ) { \n * ppos = pkt . pos ; \n return pkt . dts ; \n } \n } \n pos = pkt . pos ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 25941}
{"project": "FFmpeg", "commit_id": "dd1e6b2a139a9eea61aefe24fc3295499e70d04b", "target": 0, "func": "static int http_open ( URLContext * h , const char * uri , int flags ) \n { \n HTTPContext * s = h -> priv_data ; \n h -> is_streamed = 1 ; \n s -> filesize = -1 ; \n av_strlcpy ( s -> location , uri , sizeof ( s -> location ) ) ; \n if ( s -> headers ) { \n int len = strlen ( s -> headers ) ; \n if ( len < 2 || strcmp ( \" \\r \\n \" , s -> headers + len - 2 ) ) \n av_log ( h , AV_LOG_WARNING , \" \\n \" ) ; \n } \n return http_open_cnx ( h ) ; \n }", "idx": 25945}
{"project": "FFmpeg", "commit_id": "3ee8ca9b0894df3aaf5086c643283cb58ef9763d", "target": 0, "func": "void ff_ass_init ( AVSubtitle * sub ) \n { \n memset ( sub , 0 , sizeof ( * sub ) ) ; \n }", "idx": 25966}
{"project": "FFmpeg", "commit_id": "f4bd9fe326ad1315a74206939ae56df93b940a09", "target": 1, "func": "int ff_generate_sliding_window_mmcos ( H264Context * h , int first_slice ) \n { \n MMCO mmco_temp [ MAX_MMCO_COUNT ] , * mmco = first_slice ? h -> mmco : mmco_temp ; \n int mmco_index = 0 , i ; \n assert ( h -> long_ref_count + h -> short_ref_count <= h -> sps . ref_frame_count ) ; \n if ( h -> short_ref_count && \n h -> long_ref_count + h -> short_ref_count == h -> sps . ref_frame_count && \n ! ( FIELD_PICTURE ( h ) && ! h -> first_field && h -> cur_pic_ptr -> reference ) ) { \n mmco [ 0 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 0 ] . short_pic_num = h -> short_ref [ h -> short_ref_count - 1 ] -> frame_num ; \n mmco_index = 1 ; \n if ( FIELD_PICTURE ( h ) ) { \n mmco [ 0 ] . short_pic_num *= 2 ; \n mmco [ 1 ] . opcode = MMCO_SHORT2UNUSED ; \n mmco [ 1 ] . short_pic_num = mmco [ 0 ] . short_pic_num + 1 ; \n mmco_index = 2 ; \n } \n } \n if ( first_slice ) { \n h -> mmco_index = mmco_index ; \n } else if ( ! first_slice && mmco_index >= 0 && \n ( mmco_index != h -> mmco_index || \n ( i = check_opcodes ( h -> mmco , mmco_temp , mmco_index ) ) ) ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n mmco_index , h -> mmco_index , i ) ; \n return AVERROR_INVALIDDATA ; \n } \n return 0 ; \n }", "idx": 25981}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static inline void idct4col_add ( uint8_t * dest , int line_size , const DCTELEM * col ) \n { \n int c0 , c1 , c2 , c3 , a0 , a1 , a2 , a3 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a0 = col [ 8 * 0 ] ; \n a1 = col [ 8 * 1 ] ; \n a2 = col [ 8 * 2 ] ; \n a3 = col [ 8 * 3 ] ; \n c0 = ( a0 + a2 ) * C3 + ( 1 << ( C_SHIFT - 1 ) ) ; \n c2 = ( a0 - a2 ) * C3 + ( 1 << ( C_SHIFT - 1 ) ) ; \n c1 = a1 * C1 + a3 * C2 ; \n c3 = a1 * C2 - a3 * C1 ; \n dest [ 0 ] = cm [ dest [ 0 ] + ( ( c0 + c1 ) >> C_SHIFT ) ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ dest [ 0 ] + ( ( c2 + c3 ) >> C_SHIFT ) ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ dest [ 0 ] + ( ( c2 - c3 ) >> C_SHIFT ) ] ; \n dest += line_size ; \n dest [ 0 ] = cm [ dest [ 0 ] + ( ( c0 - c1 ) >> C_SHIFT ) ] ; \n }", "idx": 25988}
{"project": "FFmpeg", "commit_id": "c89e428ed8c2c31396af2d18cab4342b7d82958f", "target": 0, "func": "void ff_slice_buffer_init ( slice_buffer * buf , int line_count , \n int max_allocated_lines , int line_width , \n IDWTELEM * base_buffer ) \n { \n int i ; \n buf -> base_buffer = base_buffer ; \n buf -> line_count = line_count ; \n buf -> line_width = line_width ; \n buf -> data_count = max_allocated_lines ; \n buf -> line = av_mallocz ( sizeof ( IDWTELEM * ) * line_count ) ; \n buf -> data_stack = av_malloc ( sizeof ( IDWTELEM * ) * max_allocated_lines ) ; \n for ( i = 0 ; i < max_allocated_lines ; i ++ ) \n buf -> data_stack [ i ] = av_malloc ( sizeof ( IDWTELEM ) * line_width ) ; \n buf -> data_stack_top = max_allocated_lines - 1 ; \n }", "idx": 25998}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_get_file_handle ( URLContext * h ) \n { \n if ( ! h -> prot -> url_get_file_handle ) \n return -1 ; \n return h -> prot -> url_get_file_handle ( h ) ; \n }", "idx": 26009}
{"project": "FFmpeg", "commit_id": "2e988fd689642899927707a084bf40dc1326dc90", "target": 0, "func": "static void ttafilter_init ( TTAContext * s , TTAFilter * c , int32_t shift ) { \n memset ( c , 0 , sizeof ( TTAFilter ) ) ; \n if ( s -> pass ) { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) \n c -> qm [ i ] = sign_extend ( s -> crc_pass [ i ] , 8 ) ; \n } \n c -> shift = shift ; \n c -> round = shift_1 [ shift - 1 ] ; \n }", "idx": 26023}
{"project": "FFmpeg", "commit_id": "ab2940691ba76e1a9b0ce608db0dfc45021d741e", "target": 0, "func": "int avio_get_str ( AVIOContext * s , int maxlen , char * buf , int buflen ) \n { \n int i ; \n buflen = FFMIN ( buflen - 1 , maxlen ) ; \n for ( i = 0 ; i < buflen ; i ++ ) \n if ( ! ( buf [ i ] = avio_r8 ( s ) ) ) \n return i + 1 ; \n if ( buflen ) \n buf [ i ] = 0 ; \n for ( ; i < maxlen ; i ++ ) \n if ( ! avio_r8 ( s ) ) \n return i + 1 ; \n return maxlen ; \n }", "idx": 26032}
{"project": "FFmpeg", "commit_id": "05b7a635dc1e5266fb367ce8b0019a0830317879", "target": 1, "func": "static void sample_queue_push ( HintSampleQueue * queue , uint8_t * data , int size , \n int sample ) \n { \n if ( size <= 14 ) \n return ; \n if ( ! queue -> samples || queue -> len >= queue -> size ) { \n HintSample * samples ; \n samples = av_realloc ( queue -> samples , sizeof ( HintSample ) * ( queue -> size + 10 ) ) ; \n if ( ! samples ) \n return ; \n queue -> size += 10 ; \n queue -> samples = samples ; \n } \n queue -> samples [ queue -> len ] . data = data ; \n queue -> samples [ queue -> len ] . size = size ; \n queue -> samples [ queue -> len ] . sample_number = sample ; \n queue -> samples [ queue -> len ] . offset = 0 ; \n queue -> samples [ queue -> len ] . own_data = 0 ; \n queue -> len ++ ; \n }", "idx": 26036}
{"project": "FFmpeg", "commit_id": "42d73f7f6bea0ee0f64a3ad4882860ce5b923a11", "target": 1, "func": "static int parse_vtrk ( AVFormatContext * s , \n FourxmDemuxContext * fourxm , uint8_t * buf , int size ) \n { \n AVStream * st ; \n if ( size != vtrk_SIZE ) { \n return AVERROR_INVALIDDATA ; \n } \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n avpriv_set_pts_info ( st , 60 , 1 , fourxm -> fps ) ; \n fourxm -> video_stream_index = st -> index ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = AV_CODEC_ID_4XM ; \n st -> codec -> extradata_size = 4 ; \n st -> codec -> extradata = av_malloc ( 4 ) ; \n AV_WL32 ( st -> codec -> extradata , AV_RL32 ( buf + 16 ) ) ; \n st -> codec -> width = AV_RL32 ( buf + 36 ) ; \n st -> codec -> height = AV_RL32 ( buf + 40 ) ; \n return 0 ; \n }", "idx": 26043}
{"project": "FFmpeg", "commit_id": "e494f44c051d7dccc038a603ab22532b87dd1705", "target": 0, "func": "static int can_safely_read ( GetBitContext * gb , uint64_t bits ) { \n return get_bits_left ( gb ) >= bits ; \n }", "idx": 26054}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int tta_probe ( AVProbeData * p ) \n { \n const uint8_t * d = p -> buf ; \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( d [ 0 ] == ' ' && d [ 1 ] == ' ' && d [ 2 ] == ' ' && d [ 3 ] == ' ' ) \n return 80 ; \n return 0 ; \n }", "idx": 26055}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "static void list_formats ( AVFormatContext * ctx , int type ) \n { \n const struct video_data * s = ctx -> priv_data ; \n struct v4l2_fmtdesc vfd = { . type = V4L2_BUF_TYPE_VIDEO_CAPTURE } ; \n while ( ! v4l2_ioctl ( s -> fd , VIDIOC_ENUM_FMT , & vfd ) ) { \n enum AVCodecID codec_id = avpriv_fmt_v4l2codec ( vfd . pixelformat ) ; \n enum AVPixelFormat pix_fmt = avpriv_fmt_v4l2ff ( vfd . pixelformat , codec_id ) ; \n vfd . index ++ ; \n if ( ! ( vfd . flags & V4L2_FMT_FLAG_COMPRESSED ) && \n type & V4L_RAWFORMATS ) { \n const char * fmt_name = av_get_pix_fmt_name ( pix_fmt ) ; \n av_log ( ctx , AV_LOG_INFO , \" \" , \n fmt_name ? fmt_name : \" \" , \n vfd . description ) ; \n } else if ( vfd . flags & V4L2_FMT_FLAG_COMPRESSED && \n type & V4L_COMPFORMATS ) { \n AVCodec * codec = avcodec_find_decoder ( codec_id ) ; \n av_log ( ctx , AV_LOG_INFO , \" \" , \n codec ? codec -> name : \" \" , \n vfd . description ) ; \n } else { \n continue ; \n } \n #ifdef V4L2_FMT_FLAG_EMULATED \n if ( vfd . flags & V4L2_FMT_FLAG_EMULATED ) \n av_log ( ctx , AV_LOG_INFO , \" \" ) ; \n #endif \n #if HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE  \n  \n  list_framesizes ( ctx , vfd . pixelformat ) ; \n #endif \n av_log ( ctx , AV_LOG_INFO , \" \\n \" ) ; \n } \n }", "idx": 26060}
{"project": "FFmpeg", "commit_id": "7056f13a89da1d1f4afd5c6342e7ca6824777125", "target": 0, "func": "static int cinepak_decode_strip ( CinepakContext * s , \n cvid_strip * strip , const uint8_t * data , int size ) \n { \n const uint8_t * eod = ( data + size ) ; \n int chunk_id , chunk_size ; \n if ( strip -> x1 >= s -> width || strip -> x2 > s -> width || \n strip -> y1 >= s -> height || strip -> y2 > s -> height || \n strip -> x1 >= strip -> x2 || strip -> y1 >= strip -> y2 ) \n return -1 ; \n while ( ( data + 4 ) <= eod ) { \n chunk_id = data [ 0 ] ; \n chunk_size = AV_RB24 ( & data [ 1 ] ) - 4 ; \n if ( chunk_size < 0 ) \n return -1 ; \n data += 4 ; \n chunk_size = ( ( data + chunk_size ) > eod ) ? ( eod - data ) : chunk_size ; \n switch ( chunk_id ) { \n case 0x20 : \n case 0x21 : \n case 0x24 : \n case 0x25 : \n cinepak_decode_codebook ( strip -> v4_codebook , chunk_id , \n chunk_size , data ) ; \n break ; \n case 0x22 : \n case 0x23 : \n case 0x26 : \n case 0x27 : \n cinepak_decode_codebook ( strip -> v1_codebook , chunk_id , \n chunk_size , data ) ; \n break ; \n case 0x30 : \n case 0x31 : \n case 0x32 : \n return cinepak_decode_vectors ( s , strip , chunk_id , \n chunk_size , data ) ; \n } \n data += chunk_size ; \n } \n return -1 ; \n }", "idx": 26071}
{"project": "FFmpeg", "commit_id": "f67a0d115254461649470452058fa3c28c0df294", "target": 0, "func": "static int read_old_huffman_tables ( HYuvContext * s ) \n { \n GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , classic_shift_luma , \n classic_shift_luma_table_size * 8 ) ; \n if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 ) \n return -1 ; \n init_get_bits ( & gb , classic_shift_chroma , \n classic_shift_chroma_table_size * 8 ) ; \n if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 ) \n return -1 ; \n for ( i = 0 ; i < 256 ; i ++ ) s -> bits [ 0 ] [ i ] = classic_add_luma [ i ] ; \n for ( i = 0 ; i < 256 ; i ++ ) s -> bits [ 1 ] [ i ] = classic_add_chroma [ i ] ; \n if ( s -> bitstream_bpp >= 24 ) { \n memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ) ; \n memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ) ; \n } \n memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ) ; \n memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n ff_free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , \n s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return 0 ; \n }", "idx": 26077}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int ff_unlock_avcodec ( const AVCodec * codec ) \n { \n if ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || ! codec -> init ) \n return 0 ; \n av_assert0 ( ff_avcodec_locked ) ; \n ff_avcodec_locked = 0 ; \n atomic_fetch_add ( & entangled_thread_counter , -1 ) ; \n if ( lockmgr_cb ) { \n if ( ( * lockmgr_cb ) ( & codec_mutex , AV_LOCK_RELEASE ) ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 26081}
{"project": "FFmpeg", "commit_id": "cf2b7c01f81c1fb3283a1390c0ca9a2f81f4f4a8", "target": 1, "func": "static inline void copy ( LZOContext * c , int cnt ) \n { \n register const uint8_t * src = c -> in ; \n register uint8_t * dst = c -> out ; \n if ( cnt > c -> in_end - src ) { \n cnt = FFMAX ( c -> in_end - src , 0 ) ; \n c -> error |= AV_LZO_INPUT_DEPLETED ; \n } \n if ( cnt > c -> out_end - dst ) { \n cnt = FFMAX ( c -> out_end - dst , 0 ) ; \n c -> error |= AV_LZO_OUTPUT_FULL ; \n } \n #if defined ( INBUF_PADDED ) && defined ( OUTBUF_PADDED )  \n  \n  AV_COPY32U ( dst , src ) ; \n src += 4 ; \n dst += 4 ; \n cnt -= 4 ; \n if ( cnt > 0 )  \n #endif \n memcpy ( dst , src , cnt ) ; \n c -> in = src + cnt ; \n c -> out = dst + cnt ; \n }", "idx": 26082}
{"project": "FFmpeg", "commit_id": "763e714442e07f6430b003c8a9f4b62deaa7b3a5", "target": 0, "func": "static int aiff_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n AIFFInputContext * aiff = s -> priv_data ; \n int64_t max_size ; \n int res , size ; \n max_size = aiff -> data_end - avio_tell ( s -> pb ) ; \n if ( max_size <= 0 ) \n return AVERROR_EOF ; \n if ( st -> codec -> block_align >= 17 ) \n size = st -> codec -> block_align ; \n else \n size = ( MAX_SIZE / st -> codec -> block_align ) * st -> codec -> block_align ; \n size = FFMIN ( max_size , size ) ; \n res = av_get_packet ( s -> pb , pkt , size ) ; \n if ( res < 0 ) \n return res ; \n if ( size >= st -> codec -> block_align ) \n pkt -> flags &= ~ AV_PKT_FLAG_CORRUPT ; \n pkt -> stream_index = 0 ; \n pkt -> duration = ( res / st -> codec -> block_align ) * aiff -> block_duration ; \n return 0 ; \n }", "idx": 26085}
{"project": "FFmpeg", "commit_id": "8a048fe6f8bf41de93c091a7a9b3132bedc1b41c", "target": 1, "func": "static int get_riff ( AVFormatContext * s , AVIOContext * pb ) \n { \n AVIContext * avi = s -> priv_data ; \n char header [ 8 ] ; \n int i ; \n avio_read ( pb , header , 4 ) ; \n avi -> riff_end = avio_rl32 ( pb ) ; \n avi -> riff_end += avio_tell ( pb ) ; \n avio_read ( pb , header + 4 , 4 ) ; \n for ( i = 0 ; avi_headers [ i ] [ 0 ] ; i ++ ) \n if ( ! memcmp ( header , avi_headers [ i ] , 8 ) ) \n break ; \n if ( ! avi_headers [ i ] [ 0 ] ) \n return AVERROR_INVALIDDATA ; \n if ( header [ 7 ] == 0x19 ) \n av_log ( s , AV_LOG_INFO , \n \" \\n \" ) ; \n return 0 ; \n }", "idx": 26086}
{"project": "FFmpeg", "commit_id": "955db411929a9876d3cd016fbbb9c49b6362feba", "target": 1, "func": "static int decode_segment ( TAKDecContext * s , int8_t mode , int32_t * decoded , int len ) \n { \n struct CParam code ; \n GetBitContext * gb = & s -> gb ; \n int i ; \n if ( ! mode ) { \n memset ( decoded , 0 , len * sizeof ( * decoded ) ) ; \n return 0 ; \n } \n if ( mode > FF_ARRAY_ELEMS ( xcodes ) ) \n return AVERROR_INVALIDDATA ; \n code = xcodes [ mode - 1 ] ; \n for ( i = 0 ; i < len ; i ++ ) { \n int x = get_bits_long ( gb , code . init ) ; \n if ( x >= code . escape && get_bits1 ( gb ) ) { \n x |= 1 << code . init ; \n if ( x >= code . aescape ) { \n int scale = get_unary ( gb , 1 , 9 ) ; \n if ( scale == 9 ) { \n int scale_bits = get_bits ( gb , 3 ) ; \n if ( scale_bits > 0 ) { \n if ( scale_bits == 7 ) { \n scale_bits += get_bits ( gb , 5 ) ; \n if ( scale_bits > 29 ) \n return AVERROR_INVALIDDATA ; \n } \n scale = get_bits_long ( gb , scale_bits ) + 1 ; \n x += code . scale * scale ; \n } \n x += code . bias ; \n } else \n x += code . scale * scale - code . escape ; \n } else \n x -= code . escape ; \n } \n decoded [ i ] = ( x >> 1 ) ^ - ( x & 1 ) ; \n } \n return 0 ; \n }", "idx": 26088}
{"project": "FFmpeg", "commit_id": "5cb57a16ede71d913384a0b3036a2c6df5da5e43", "target": 1, "func": "int avpriv_dv_produce_packet ( DVDemuxContext * c , AVPacket * pkt , \n uint8_t * buf , int buf_size , int64_t pos ) \n { \n int size , i ; \n uint8_t * ppcm [ 4 ] = { 0 } ; \n if ( buf_size < DV_PROFILE_BYTES || \n ! ( c -> sys = avpriv_dv_frame_profile ( c -> sys , buf , buf_size ) ) || \n buf_size < c -> sys -> frame_size ) { \n return -1 ; \n } \n size = dv_extract_audio_info ( c , buf ) ; \n for ( i = 0 ; i < c -> ach ; i ++ ) { \n c -> audio_pkt [ i ] . pos = pos ; \n c -> audio_pkt [ i ] . size = size ; \n c -> audio_pkt [ i ] . pts = c -> abytes * 30000 * 8 / c -> ast [ i ] -> codec -> bit_rate ; \n ppcm [ i ] = c -> audio_buf [ i ] ; \n } \n dv_extract_audio ( buf , ppcm , c -> sys ) ; \n if ( c -> sys -> height == 720 ) { \n if ( buf [ 1 ] & 0x0C ) { \n c -> audio_pkt [ 2 ] . size = c -> audio_pkt [ 3 ] . size = 0 ; \n } else { \n c -> audio_pkt [ 0 ] . size = c -> audio_pkt [ 1 ] . size = 0 ; \n c -> abytes += size ; \n } \n } else { \n c -> abytes += size ; \n } \n size = dv_extract_video_info ( c , buf ) ; \n av_init_packet ( pkt ) ; \n pkt -> data = buf ; \n pkt -> pos = pos ; \n pkt -> size = size ; \n pkt -> flags |= AV_PKT_FLAG_KEY ; \n pkt -> stream_index = c -> vst -> id ; \n pkt -> pts = c -> frames ; \n c -> frames ++ ; \n return size ; \n }", "idx": 26093}
{"project": "FFmpeg", "commit_id": "0afdedcafb4d524abfe2c958f17aafe4f1ab8d9a", "target": 0, "func": "int ff_rle_encode ( uint8_t * outbuf , int out_size , const uint8_t * ptr , int bpp , int w , \n int add_rep , int xor_rep , int add_raw , int xor_raw ) \n { \n int count , x ; \n uint8_t * out = outbuf ; \n for ( x = 0 ; x < w ; x += count ) { \n if ( ( count = count_pixels ( ptr , w - x , bpp , 1 ) ) > 1 ) { \n if ( out + bpp + 1 > outbuf + out_size ) return -1 ; \n * out ++ = ( count ^ xor_rep ) + add_rep ; \n memcpy ( out , ptr , bpp ) ; \n out += bpp ; \n } else { \n count = count_pixels ( ptr , w - x , bpp , 0 ) ; \n * out ++ = ( count ^ xor_raw ) + add_raw ; \n if ( out + bpp * count > outbuf + out_size ) return -1 ; \n memcpy ( out , ptr , bpp * count ) ; \n out += bpp * count ; \n } \n ptr += count * bpp ; \n } \n return out - outbuf ; \n }", "idx": 26097}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "static void vp8_decode_mv_mb_modes ( AVCodecContext * avctx , VP8Frame * curframe , \n VP8Frame * prev_frame ) \n { \n VP8Context * s = avctx -> priv_data ; \n int mb_x , mb_y ; \n s -> mv_min . y = - MARGIN ; \n s -> mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; \n for ( mb_y = 0 ; mb_y < s -> mb_height ; mb_y ++ ) { \n VP8Macroblock * mb = s -> macroblocks_base + \n ( ( s -> mb_width + 1 ) * ( mb_y + 1 ) + 1 ) ; \n int mb_xy = mb_y * s -> mb_width ; \n AV_WN32A ( s -> intra4x4_pred_mode_left , DC_PRED * 0x01010101 ) ; \n s -> mv_min . x = - MARGIN ; \n s -> mv_max . x = ( ( s -> mb_width - 1 ) << 6 ) + MARGIN ; \n for ( mb_x = 0 ; mb_x < s -> mb_width ; mb_x ++ , mb_xy ++ , mb ++ ) { \n if ( mb_y == 0 ) \n AV_WN32A ( ( mb - s -> mb_width - 1 ) -> intra4x4_pred_mode_top , \n DC_PRED * 0x01010101 ) ; \n decode_mb_mode ( s , mb , mb_x , mb_y , curframe -> seg_map -> data + mb_xy , \n prev_frame && prev_frame -> seg_map ? \n prev_frame -> seg_map -> data + mb_xy : NULL , 1 ) ; \n s -> mv_min . x -= 64 ; \n s -> mv_max . x -= 64 ; \n } \n s -> mv_min . y -= 64 ; \n s -> mv_max . y -= 64 ; \n } \n }", "idx": 26101}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_4x4_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n register int t1 , t2 , t3 , t4 ; \n DCTELEM * src , * dst ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n src = block ; \n dst = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t1 = 17 * ( src [ 0 ] + src [ 2 ] ) + 4 ; \n t2 = 17 * ( src [ 0 ] - src [ 2 ] ) + 4 ; \n t3 = 22 * src [ 1 ] + 10 * src [ 3 ] ; \n t4 = 22 * src [ 3 ] - 10 * src [ 1 ] ; \n dst [ 0 ] = ( t1 + t3 ) >> 3 ; \n dst [ 1 ] = ( t2 - t4 ) >> 3 ; \n dst [ 2 ] = ( t2 + t4 ) >> 3 ; \n dst [ 3 ] = ( t1 - t3 ) >> 3 ; \n src += 8 ; \n dst += 8 ; \n } \n src = block ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n t1 = 17 * ( src [ 0 ] + src [ 16 ] ) + 64 ; \n t2 = 17 * ( src [ 0 ] - src [ 16 ] ) + 64 ; \n t3 = 22 * src [ 8 ] + 10 * src [ 24 ] ; \n t4 = 22 * src [ 24 ] - 10 * src [ 8 ] ; \n dest [ 0 * linesize ] = cm [ dest [ 0 * linesize ] + ( ( t1 + t3 ) >> 7 ) ] ; \n dest [ 1 * linesize ] = cm [ dest [ 1 * linesize ] + ( ( t2 - t4 ) >> 7 ) ] ; \n dest [ 2 * linesize ] = cm [ dest [ 2 * linesize ] + ( ( t2 + t4 ) >> 7 ) ] ; \n dest [ 3 * linesize ] = cm [ dest [ 3 * linesize ] + ( ( t1 - t3 ) >> 7 ) ] ; \n src ++ ; \n dest ++ ; \n } \n }", "idx": 26106}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_dct_init_mmx ( DCTContext * s ) \n { \n #if HAVE_YASM  \n  \n  int has_vectors = av_get_cpu_flags ( ) ; \n if ( has_vectors & AV_CPU_FLAG_SSE && HAVE_SSE ) \n s -> dct32 = ff_dct32_float_sse ; \n if ( has_vectors & AV_CPU_FLAG_SSE2 && HAVE_SSE ) \n s -> dct32 = ff_dct32_float_sse2 ; \n if ( has_vectors & AV_CPU_FLAG_AVX && HAVE_AVX ) \n s -> dct32 = ff_dct32_float_avx ; \n #endif \n }", "idx": 26111}
{"project": "FFmpeg", "commit_id": "4a0f6651434c6f213d830140f575b4ec7858519f", "target": 0, "func": "int ff_reget_buffer ( AVCodecContext * avctx , AVFrame * frame ) \n { \n AVFrame * tmp ; \n int ret ; \n av_assert0 ( avctx -> codec_type == AVMEDIA_TYPE_VIDEO ) ; \n if ( ! frame -> data [ 0 ] ) \n return ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ; \n if ( av_frame_is_writable ( frame ) ) { \n frame -> pkt_pts = avctx -> internal -> pkt ? avctx -> internal -> pkt -> pts : AV_NOPTS_VALUE ; \n frame -> reordered_opaque = avctx -> reordered_opaque ; \n return 0 ; \n } \n tmp = av_frame_alloc ( ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n av_frame_move_ref ( tmp , frame ) ; \n ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ; \n if ( ret < 0 ) { \n av_frame_free ( & tmp ) ; \n return ret ; \n } \n av_frame_copy ( frame , tmp ) ; \n av_frame_free ( & tmp ) ; \n return 0 ; \n }", "idx": 26112}
{"project": "FFmpeg", "commit_id": "224bb46fb857dab589597bdab302ba8ba012008c", "target": 1, "func": "uint8_t * ff_AMediaCodec_getOutputBuffer ( FFAMediaCodec * codec , size_t idx , size_t * out_size ) \n { \n uint8_t * ret = NULL ; \n JNIEnv * env = NULL ; \n jobject buffer = NULL ; \n JNI_GET_ENV_OR_RETURN ( env , codec , NULL ) ; \n if ( codec -> has_get_i_o_buffer ) { \n buffer = ( * env ) -> CallObjectMethod ( env , codec -> object , codec -> jfields . get_output_buffer_id , idx ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n } else { \n if ( ! codec -> output_buffers ) { \n codec -> output_buffers = ( * env ) -> CallObjectMethod ( env , codec -> object , codec -> jfields . get_output_buffers_id ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n codec -> output_buffers = ( * env ) -> NewGlobalRef ( env , codec -> output_buffers ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n } \n buffer = ( * env ) -> GetObjectArrayElement ( env , codec -> output_buffers , idx ) ; \n if ( ff_jni_exception_check ( env , 1 , codec ) < 0 ) { \n goto fail ; \n } \n } \n ret = ( * env ) -> GetDirectBufferAddress ( env , buffer ) ; \n * out_size = ( * env ) -> GetDirectBufferCapacity ( env , buffer ) ; \n fail : \n if ( buffer ) { \n ( * env ) -> DeleteLocalRef ( env , buffer ) ; \n } \n return ret ; \n }", "idx": 26135}
{"project": "FFmpeg", "commit_id": "dfbb5de172b3a0373cbead8a966c41f5ba1ae08b", "target": 1, "func": "static int try_decode_video_frame ( AVCodecContext * codec_ctx , AVPacket * pkt , int decode ) \n { \n int ret = 0 ; \n int got_frame = 0 ; \n AVFrame * frame = NULL ; \n int skip_frame = codec_ctx -> skip_frame ; \n if ( ! avcodec_is_open ( codec_ctx ) ) { \n const AVCodec * codec = avcodec_find_decoder ( codec_ctx -> codec_id ) ; \n ret = avcodec_open2 ( codec_ctx , codec , NULL ) ; \n if ( ret < 0 ) { \n av_log ( codec_ctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto end ; \n } \n } \n frame = av_frame_alloc ( ) ; \n if ( ! frame ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n goto end ; \n } \n if ( ! decode && codec_ctx -> codec -> caps_internal & FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM ) { \n codec_ctx -> skip_frame = AVDISCARD_ALL ; \n } \n do { \n ret = avcodec_decode_video2 ( codec_ctx , frame , & got_frame , pkt ) ; \n av_assert0 ( decode || ( ! decode && ! got_frame ) ) ; \n if ( ret < 0 ) \n break ; \n pkt -> data += ret ; \n pkt -> size -= ret ; \n if ( got_frame ) { \n break ; \n } \n } while ( pkt -> size > 0 ) ; \n end : \n codec_ctx -> skip_frame = skip_frame ; \n av_frame_free ( & frame ) ; \n return ret ; \n }", "idx": 26138}
{"project": "FFmpeg", "commit_id": "7faa40af982960608b117e20fec999b48011e5e0", "target": 1, "func": "static int adx_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n ADXDemuxerContext * c = s -> priv_data ; \n AVCodecContext * avctx = s -> streams [ 0 ] -> codec ; \n int ret , size ; \n size = BLOCK_SIZE * avctx -> channels ; \n pkt -> pos = avio_tell ( s -> pb ) ; \n pkt -> stream_index = 0 ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n if ( ret != size ) { \n av_free_packet ( pkt ) ; \n return ret < 0 ? ret : AVERROR ( EIO ) ; \n if ( AV_RB16 ( pkt -> data ) & 0x8000 ) { \n av_free_packet ( pkt ) ; \n return AVERROR_EOF ; \n pkt -> size = size ; \n pkt -> duration = 1 ; \n pkt -> pts = ( pkt -> pos - c -> header_size ) / size ; \n return 0 ;", "idx": 26143}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int put_flac_codecpriv ( AVFormatContext * s , ByteIOContext * pb , AVCodecContext * codec ) \n { \n if ( codec -> extradata_size < FLAC_STREAMINFO_SIZE ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } else if ( codec -> extradata_size == FLAC_STREAMINFO_SIZE ) { \n put_buffer ( pb , \" \" , 4 ) ; \n put_byte ( pb , 0x80 ) ; \n put_be24 ( pb , FLAC_STREAMINFO_SIZE ) ; \n } else if ( memcmp ( \" \" , codec -> extradata , 4 ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n put_buffer ( pb , codec -> extradata , codec -> extradata_size ) ; \n return 0 ; \n }", "idx": 26165}
{"project": "FFmpeg", "commit_id": "ddebfb15dc8ee01f7f8ff4e15e80b9843e550f00", "target": 0, "func": "int avcodec_open ( AVCodecContext * avctx , AVCodec * codec ) \n { \n int ret ; \n if ( avctx -> codec ) \n return -1 ; \n avctx -> codec = codec ; \n avctx -> codec_id = codec -> id ; \n avctx -> frame_number = 0 ; \n if ( codec -> priv_data_size > 0 ) { \n avctx -> priv_data = av_mallocz ( codec -> priv_data_size ) ; \n if ( ! avctx -> priv_data ) \n return - ENOMEM ; \n } else { \n avctx -> priv_data = NULL ; \n } \n if ( avctx -> coded_width && avctx -> coded_height ) \n avcodec_set_dimensions ( avctx , avctx -> coded_width , avctx -> coded_height ) ; \n else if ( avctx -> width && avctx -> height ) \n avcodec_set_dimensions ( avctx , avctx -> width , avctx -> height ) ; \n if ( ( avctx -> coded_width || avctx -> coded_height ) && avcodec_check_dimensions ( avctx , avctx -> coded_width , avctx -> coded_height ) ) { \n av_freep ( & avctx -> priv_data ) ; \n return -1 ; \n } \n ret = avctx -> codec -> init ( avctx ) ; \n if ( ret < 0 ) { \n av_freep ( & avctx -> priv_data ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 26168}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yv12touyvy ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartouyvy ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 26169}
{"project": "FFmpeg", "commit_id": "5a8fec1b33f2c9da89fe565516fff24b09988dc9", "target": 1, "func": "static void imdct12 ( INTFLOAT * out , INTFLOAT * in ) \n { \n INTFLOAT in0 , in1 , in2 , in3 , in4 , in5 , t1 , t2 ; \n in0 = in [ 0 * 3 ] ; \n in1 = in [ 1 * 3 ] + in [ 0 * 3 ] ; \n in2 = in [ 2 * 3 ] + in [ 1 * 3 ] ; \n in3 = in [ 3 * 3 ] + in [ 2 * 3 ] ; \n in4 = in [ 4 * 3 ] + in [ 3 * 3 ] ; \n in5 = in [ 5 * 3 ] + in [ 4 * 3 ] ; \n in5 += in3 ; \n in3 += in1 ; \n in2 = MULH3 ( in2 , C3 , 2 ) ; \n in3 = MULH3 ( in3 , C3 , 4 ) ; \n t1 = in0 - in4 ; \n t2 = MULH3 ( in1 - in5 , C4 , 2 ) ; \n out [ 7 ] = \n out [ 10 ] = t1 + t2 ; \n out [ 1 ] = \n out [ 4 ] = t1 - t2 ; \n in0 += SHR ( in4 , 1 ) ; \n in4 = in0 + in2 ; \n in5 += 2 * in1 ; \n in1 = MULH3 ( in5 + in3 , C5 , 1 ) ; \n out [ 8 ] = \n out [ 9 ] = in4 + in1 ; \n out [ 2 ] = \n out [ 3 ] = in4 - in1 ; \n in0 -= in2 ; \n in5 = MULH3 ( in5 - in3 , C6 , 2 ) ; \n out [ 0 ] = \n out [ 5 ] = in0 - in5 ; \n out [ 6 ] = \n out [ 11 ] = in0 + in5 ; \n }", "idx": 26172}
{"project": "FFmpeg", "commit_id": "dcd3418a35aab7ef283b68ed9997ce4ac204094e", "target": 0, "func": "static int get_cv_color_primaries ( AVCodecContext * avctx , \n CFStringRef * primaries ) \n { \n enum AVColorPrimaries pri = avctx -> color_primaries ; \n switch ( pri ) { \n case AVCOL_PRI_UNSPECIFIED : \n * primaries = NULL ; \n break ; \n case AVCOL_PRI_BT709 : \n * primaries = kCVImageBufferColorPrimaries_ITU_R_709_2 ; \n break ; \n case AVCOL_PRI_BT2020 : \n * primaries = kCVImageBufferColorPrimaries_ITU_R_2020 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , av_color_primaries_name ( pri ) ) ; \n * primaries = NULL ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 26179}
{"project": "FFmpeg", "commit_id": "acc163c6ab52d2235767852262c64c7f6b273d1c", "target": 0, "func": "static void FUNC ( flac_decorrelate_indep_c ) ( uint8_t * * out , int32_t * * in , \n int channels , int len , int shift ) \n { \n sample * samples = ( sample * ) OUT ( out ) ; \n int i , j ; \n for ( j = 0 ; j < len ; j ++ ) \n for ( i = 0 ; i < channels ; i ++ ) \n S ( samples , i , j ) = in [ i ] [ j ] << shift ; \n }", "idx": 26182}
{"project": "FFmpeg", "commit_id": "aac8b76983e340bc744d3542d676f72efa3b474f", "target": 0, "func": "static void filter_mb_edgev ( H264Context * h , uint8_t * pix , int stride , int16_t bS [ 4 ] , int qp ) { \n int i , d ; \n const int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = ( alpha_table + 52 ) [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n for ( i = 0 ; i < 4 ; i ++ ) \n tc [ i ] = bS [ i ] ? ( tc0_table + 52 ) [ index_a ] [ bS [ i ] - 1 ] : -1 ; \n h -> s . dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 26190}
{"project": "FFmpeg", "commit_id": "e55ed689a264c78f332745598ea8c58a3422ee13", "target": 0, "func": "static void selfTest ( uint8_t * src [ 4 ] , int stride [ 4 ] , int w , int h ) { \n enum PixelFormat srcFormat , dstFormat ; \n int srcW , srcH , dstW , dstH ; \n int flags ; \n for ( srcFormat = 0 ; srcFormat < PIX_FMT_NB ; srcFormat ++ ) { \n for ( dstFormat = 0 ; dstFormat < PIX_FMT_NB ; dstFormat ++ ) { \n printf ( \" \\n \" , \n sws_format_name ( srcFormat ) , \n sws_format_name ( dstFormat ) ) ; \n fflush ( stdout ) ; \n srcW = w ; \n srcH = h ; \n for ( dstW = w - w / 3 ; dstW <= 4 * w / 3 ; dstW += w / 3 ) { \n for ( dstH = h - h / 3 ; dstH <= 4 * h / 3 ; dstH += h / 3 ) { \n for ( flags = 1 ; flags < 33 ; flags *= 2 ) { \n int res ; \n res = doTest ( src , stride , w , h , srcFormat , dstFormat , \n srcW , srcH , dstW , dstH , flags ) ; \n if ( res < 0 ) { \n dstW = 4 * w / 3 ; \n dstH = 4 * h / 3 ; \n flags = 33 ; \n } \n } \n } \n } \n } \n } \n }", "idx": 26201}
{"project": "FFmpeg", "commit_id": "ff17c76e92cd9a9072a8771cad73c96cd620040b", "target": 1, "func": "static int add_crc_to_array ( uint32_t crc , int64_t pts ) \n { \n if ( size_of_array <= number_of_elements ) { \n if ( size_of_array == 0 ) \n size_of_array = 10 ; \n size_of_array *= 2 ; \n crc_array = av_realloc ( crc_array , size_of_array * sizeof ( uint32_t ) ) ; \n pts_array = av_realloc ( pts_array , size_of_array * sizeof ( int64_t ) ) ; \n if ( ( crc_array == NULL ) || ( pts_array == NULL ) ) { \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n } \n } \n crc_array [ number_of_elements ] = crc ; \n pts_array [ number_of_elements ] = pts ; \n number_of_elements ++ ; \n return 0 ; \n }", "idx": 26212}
{"project": "FFmpeg", "commit_id": "5b4da8a38a5ed211df9504c85ce401c30af86b97", "target": 0, "func": "static av_cold void init_mv_penalty_and_fcode ( MpegEncContext * s ) \n { \n int f_code ; \n int mv ; \n for ( f_code = 1 ; f_code <= MAX_FCODE ; f_code ++ ) { \n for ( mv = - MAX_MV ; mv <= MAX_MV ; mv ++ ) { \n int len ; \n if ( mv == 0 ) len = ff_mvtab [ 0 ] [ 1 ] ; \n else { \n int val , bit_size , code ; \n bit_size = f_code - 1 ; \n val = mv ; \n if ( val < 0 ) \n val = - val ; \n val -- ; \n code = ( val >> bit_size ) + 1 ; \n if ( code < 33 ) { \n len = ff_mvtab [ code ] [ 1 ] + 1 + bit_size ; \n } else { \n len = ff_mvtab [ 32 ] [ 1 ] + av_log2 ( code >> 5 ) + 2 + bit_size ; \n } \n } \n mv_penalty [ f_code ] [ mv + MAX_MV ] = len ; \n } \n } \n for ( f_code = MAX_FCODE ; f_code > 0 ; f_code -- ) { \n for ( mv = - ( 16 << f_code ) ; mv < ( 16 << f_code ) ; mv ++ ) { \n fcode_tab [ mv + MAX_MV ] = f_code ; \n } \n } \n for ( mv = 0 ; mv < MAX_MV * 2 + 1 ; mv ++ ) { \n umv_fcode_tab [ mv ] = 1 ; \n } \n }", "idx": 26214}
{"project": "FFmpeg", "commit_id": "ddf1b4a2f8a680126eb611428e4f47e6e5b8c6c0", "target": 0, "func": "static av_always_inline int setup_classifs ( vorbis_context * vc , \n vorbis_residue * vr , \n uint8_t * do_not_decode , \n unsigned ch_used , \n int partition_count ) \n { \n int p , j , i ; \n unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; \n unsigned inverse_class = ff_inverse [ vr -> classifications ] ; \n unsigned temp , temp2 ; \n for ( p = 0 , j = 0 ; j < ch_used ; ++ j ) { \n if ( ! do_not_decode [ j ] ) { \n temp = get_vlc2 ( & vc -> gb , vc -> codebooks [ vr -> classbook ] . vlc . table , \n vc -> codebooks [ vr -> classbook ] . nb_bits , 3 ) ; \n av_dlog ( NULL , \" \\n \" , temp ) ; \n assert ( vr -> classifications > 1 && temp <= 65536 ) ; \n for ( i = 0 ; i < c_p_c ; ++ i ) { \n temp2 = ( ( ( uint64_t ) temp ) * inverse_class ) >> 32 ; \n if ( partition_count + c_p_c - 1 - i < vr -> ptns_to_read ) \n vr -> classifs [ p + partition_count + c_p_c - 1 - i ] = \n temp - temp2 * vr -> classifications ; \n temp = temp2 ; \n } \n } \n p += vr -> ptns_to_read ; \n } \n return 0 ; \n }", "idx": 26215}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static uint32_t adler32 ( uint32_t adler , const uint8_t * buf , unsigned int len ) \n { \n unsigned long s1 = adler & 0xffff ; \n unsigned long s2 = ( adler >> 16 ) & 0xffff ; \n int k ; \n if ( buf == NULL ) return 1L ; \n while ( len > 0 ) { \n k = len < NMAX ? len : NMAX ; \n len -= k ; \n while ( k >= 16 ) { \n DO16 ( buf ) ; \n k -= 16 ; \n } \n if ( k != 0 ) do { \n DO1 ( buf ) ; \n } while ( -- k ) ; \n s1 %= BASE ; \n s2 %= BASE ; \n } \n return ( s2 << 16 ) | s1 ; \n }", "idx": 26219}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_close ( AVFormatContext * s1 ) \n { \n GifState * s = s1 -> priv_data ; \n av_free ( s -> image_buf ) ; \n return 0 ; \n }", "idx": 26236}
{"project": "FFmpeg", "commit_id": "aff01de6415f1ba022f1a58e354ad6e4d0796e97", "target": 0, "func": "static int link_filter_inouts ( AVFilterContext * filt_ctx , \n AVFilterInOut * * curr_inputs , \n AVFilterInOut * * open_inputs , void * log_ctx ) \n { \n int pad , ret ; \n for ( pad = 0 ; pad < filt_ctx -> input_count ; pad ++ ) { \n AVFilterInOut * p = * curr_inputs ; \n if ( p ) \n * curr_inputs = ( * curr_inputs ) -> next ; \n else if ( ! ( p = av_mallocz ( sizeof ( * p ) ) ) ) \n return AVERROR ( ENOMEM ) ; \n if ( p -> filter_ctx ) { \n if ( ( ret = link_filter ( p -> filter_ctx , p -> pad_idx , filt_ctx , pad , log_ctx ) ) < 0 ) \n return ret ; \n av_free ( p -> name ) ; \n av_free ( p ) ; \n } else { \n p -> filter_ctx = filt_ctx ; \n p -> pad_idx = pad ; \n append_inout ( open_inputs , & p ) ; \n } \n } \n if ( * curr_inputs ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\\" \\\" \\n \" , \n filt_ctx -> filter -> name ) ; \n return AVERROR ( EINVAL ) ; \n } \n pad = filt_ctx -> output_count ; \n while ( pad -- ) { \n AVFilterInOut * currlinkn = av_mallocz ( sizeof ( AVFilterInOut ) ) ; \n if ( ! currlinkn ) \n return AVERROR ( ENOMEM ) ; \n currlinkn -> filter_ctx = filt_ctx ; \n currlinkn -> pad_idx = pad ; \n insert_inout ( curr_inputs , currlinkn ) ; \n } \n return 0 ; \n }", "idx": 26262}
{"project": "FFmpeg", "commit_id": "6260ab60a80fd8baebf79f9ce9299b0db72333b5", "target": 0, "func": "static void blend_image_rgba ( AVFilterContext * ctx , AVFrame * dst , const AVFrame * src , int x , int y ) \n { \n blend_image_packed_rgb ( ctx , dst , src , 1 , x , y , 0 ) ; \n }", "idx": 26273}
{"project": "FFmpeg", "commit_id": "9bcbb250e23959075765edd3cb4c1fcb46736d7d", "target": 0, "func": "static inline void RENAME ( yuv2yuv1 ) ( SwsContext * c , const int16_t * lumSrc , \n const int16_t * chrUSrc , const int16_t * chrVSrc , \n const int16_t * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n int p = 4 ; \n const uint8_t * src [ 4 ] = { alpSrc + dstW , lumSrc + dstW , chrUSrc + chrDstW , chrVSrc + chrDstW } ; \n uint8_t * dst [ 4 ] = { aDest , dest , uDest , vDest } ; \n x86_reg counter [ 4 ] = { dstW , dstW , chrDstW , chrDstW } ; \n while ( p -- ) { \n if ( dst [ p ] ) { \n __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n MOVNTQ ( % % mm0 , ( % 1 , % % REGa ) ) \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n :: \" \" ( src [ p ] ) , \" \" ( dst [ p ] + counter [ p ] ) , \n \" \" ( - counter [ p ] ) \n : \" % \" \n ) ; \n } \n } \n }", "idx": 26280}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( rgb15to16 ) ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n register const uint8_t * s = src ; \n register uint8_t * d = dst ; \n register const uint8_t * end ; \n const uint8_t * mm_end ; \n end = s + src_size ; \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \n __asm__ volatile ( \" \" :: \" \" ( mask15s ) ) ; \n mm_end = end - 15 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * d ) \n : \" m \" ( * s ) \n ) ; \n d += 16 ; \n s += 16 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n #endif \n mm_end = end - 3 ; \n while ( s < mm_end ) { \n register unsigned x = * ( ( const uint32_t * ) s ) ; \n * ( ( uint32_t * ) d ) = ( x & 0x7FFF7FFF ) + ( x & 0x7FE07FE0 ) ; \n d += 4 ; \n s += 4 ; \n } \n if ( s < end ) { \n register unsigned short x = * ( ( const uint16_t * ) s ) ; \n * ( ( uint16_t * ) d ) = ( x & 0x7FFF ) + ( x & 0x7FE0 ) ; \n } \n }", "idx": 26281}
{"project": "FFmpeg", "commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "target": 1, "func": "static void dnxhd_decode_dct_block_8 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n dnxhd_decode_dct_block ( ctx , row , n , 4 , 32 , 6 ) ; \n }", "idx": 26302}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "static void http_write_packet ( void * opaque , \n unsigned char * buf , int size ) \n { \n HTTPContext * c = opaque ; \n if ( c -> buffer_ptr == c -> buffer_end || ! c -> buffer_ptr ) \n c -> buffer_ptr = c -> buffer_end = c -> buffer ; \n if ( c -> buffer_end - c -> buffer + size > IOBUFFER_MAX_SIZE ) \n abort ( ) ; \n memcpy ( c -> buffer_end , buf , size ) ; \n c -> buffer_end += size ; \n }", "idx": 26307}
{"project": "FFmpeg", "commit_id": "131644677970a3c4a0096270ea2a5b5d437c2e63", "target": 1, "func": "static int http_read_stream ( URLContext * h , uint8_t * buf , int size ) \n { \n HTTPContext * s = h -> priv_data ; \n int err , new_location ; \n if ( ! s -> hd ) \n return AVERROR_EOF ; \n if ( s -> end_chunked_post && ! s -> end_header ) { \n err = http_read_header ( h , & new_location ) ; \n if ( err < 0 ) \n return err ; \n } \n if ( s -> chunksize >= 0 ) { \n if ( ! s -> chunksize ) { \n char line [ 32 ] ; \n for ( ; ; ) { \n do { \n if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) \n return err ; \n } while ( ! * line ) ; \n s -> chunksize = strtoll ( line , NULL , 16 ) ; \n av_log ( NULL , AV_LOG_TRACE , \" \" PRId64 \" \\n \" , \n s -> chunksize ) ; \n if ( ! s -> chunksize ) \n return 0 ; \n break ; \n } \n } \n size = FFMIN ( size , s -> chunksize ) ; \n } \n #if CONFIG_ZLIB  \n  \n  if ( s -> compressed ) \n return http_buf_read_compressed ( h , buf , size ) ; \n #endif \n return http_buf_read ( h , buf , size ) ; \n }", "idx": 26309}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_2r_to_stereo ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 512 ] ; \n samples [ i + 256 ] = samples [ i + 768 ] ; \n samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 26312}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "func": "static int video_read_header ( AVFormatContext * s , \n AVFormatParameters * ap ) \n { \n AVStream * st ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR_NOMEM ; \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n st -> codec -> codec_id = s -> iformat -> value ; \n st -> need_parsing = 1 ; \n if ( ap && ap -> time_base . num ) { \n av_set_pts_info ( st , 64 , ap -> time_base . num , ap -> time_base . den ) ; \n } else if ( st -> codec -> codec_id == CODEC_ID_MJPEG || \n st -> codec -> codec_id == CODEC_ID_MPEG4 || \n st -> codec -> codec_id == CODEC_ID_H264 ) { \n av_set_pts_info ( st , 64 , 1 , 25 ) ; \n } \n return 0 ; \n }", "idx": 26313}
{"project": "FFmpeg", "commit_id": "c39059bea3adebcd888571d1181db215eee54495", "target": 0, "func": "void ff_h264_direct_dist_scale_factor ( H264Context * const h ) \n { \n const int poc = h -> cur_pic_ptr -> field_poc [ h -> picture_structure == PICT_BOTTOM_FIELD ] ; \n const int poc1 = h -> ref_list [ 1 ] [ 0 ] . poc ; \n int i , field ; \n if ( FRAME_MBAFF ( h ) ) \n for ( field = 0 ; field < 2 ; field ++ ) { \n const int poc = h -> cur_pic_ptr -> field_poc [ field ] ; \n const int poc1 = h -> ref_list [ 1 ] [ 0 ] . field_poc [ field ] ; \n for ( i = 0 ; i < 2 * h -> ref_count [ 0 ] ; i ++ ) \n h -> dist_scale_factor_field [ field ] [ i ^ field ] = \n get_scale_factor ( h , poc , poc1 , i + 16 ) ; \n } \n for ( i = 0 ; i < h -> ref_count [ 0 ] ; i ++ ) \n h -> dist_scale_factor [ i ] = get_scale_factor ( h , poc , poc1 , i ) ; \n }", "idx": 26322}
{"project": "FFmpeg", "commit_id": "ce41c51b0c71c87f623914ba0786aef325d818fe", "target": 1, "func": "AVFormatContext * ff_rtp_chain_mux_open ( AVFormatContext * s , AVStream * st , \n URLContext * handle , int packet_size ) \n { \n AVFormatContext * rtpctx ; \n int ret ; \n AVOutputFormat * rtp_format = av_guess_format ( \" \" , NULL , NULL ) ; \n if ( ! rtp_format ) \n return NULL ; \n rtpctx = avformat_alloc_context ( ) ; \n if ( ! rtpctx ) \n return NULL ; \n rtpctx -> oformat = rtp_format ; \n if ( ! av_new_stream ( rtpctx , 0 ) ) { \n av_free ( rtpctx ) ; \n return NULL ; \n } \n rtpctx -> max_delay = s -> max_delay ; \n rtpctx -> streams [ 0 ] -> sample_aspect_ratio = st -> sample_aspect_ratio ; \n rtpctx -> start_time_realtime = s -> start_time_realtime ; \n av_free ( rtpctx -> streams [ 0 ] -> codec ) ; \n rtpctx -> streams [ 0 ] -> codec = st -> codec ; \n if ( handle ) { \n url_fdopen ( & rtpctx -> pb , handle ) ; \n } else \n url_open_dyn_packet_buf ( & rtpctx -> pb , packet_size ) ; \n ret = av_write_header ( rtpctx ) ; \n if ( ret ) { \n if ( handle ) { \n url_fclose ( rtpctx -> pb ) ; \n } else { \n uint8_t * ptr ; \n url_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } \n av_free ( rtpctx -> streams [ 0 ] ) ; \n av_free ( rtpctx ) ; \n return NULL ; \n } \n st -> time_base = rtpctx -> streams [ 0 ] -> time_base ; \n return rtpctx ; \n }", "idx": 26327}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "static int vc1test_write_header ( AVFormatContext * s ) \n { \n AVCodecContext * avc = s -> streams [ 0 ] -> codec ; \n AVIOContext * pb = s -> pb ; \n if ( avc -> codec_id != CODEC_ID_WMV3 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avio_wl24 ( pb , 0 ) ; \n avio_w8 ( pb , 0xC5 ) ; \n avio_wl32 ( pb , 4 ) ; \n avio_write ( pb , avc -> extradata , 4 ) ; \n avio_wl32 ( pb , avc -> height ) ; \n avio_wl32 ( pb , avc -> width ) ; \n avio_wl32 ( pb , 0xC ) ; \n avio_wl24 ( pb , 0 ) ; \n avio_w8 ( pb , 0x80 ) ; \n avio_wl32 ( pb , 0 ) ; \n if ( s -> streams [ 0 ] -> r_frame_rate . den && s -> streams [ 0 ] -> r_frame_rate . num == 1 ) \n avio_wl32 ( pb , s -> streams [ 0 ] -> r_frame_rate . den ) ; \n else \n avio_wl32 ( pb , 0xFFFFFFFF ) ; \n avpriv_set_pts_info ( s -> streams [ 0 ] , 32 , 1 , 1000 ) ; \n return 0 ; \n }", "idx": 26332}
{"project": "FFmpeg", "commit_id": "c0b91348fe4aec7d2245d95ccabb460a6971e361", "target": 1, "func": "static int caca_write_trailer ( AVFormatContext * s ) \n { \n CACAContext * c = s -> priv_data ; \n av_freep ( & c -> window_title ) ; \n caca_free_dither ( c -> dither ) ; \n caca_free_display ( c -> display ) ; \n caca_free_canvas ( c -> canvas ) ; \n return 0 ; \n }", "idx": 26334}
{"project": "FFmpeg", "commit_id": "915bbac6815eddd911fb5cb8a23517b3cac3a84b", "target": 1, "func": "void mpeg1_init_vlc ( MpegEncContext * s ) \n { \n static int done = 0 ; \n if ( ! done ) { \n init_vlc ( & dc_lum_vlc , 9 , 12 , \n vlc_dc_lum_bits , 1 , 1 , \n vlc_dc_lum_code , 2 , 2 ) ; \n init_vlc ( & dc_chroma_vlc , 9 , 12 , \n vlc_dc_chroma_bits , 1 , 1 , \n vlc_dc_chroma_code , 2 , 2 ) ; \n init_vlc ( & mv_vlc , 9 , 17 , \n & mbMotionVectorTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbMotionVectorTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mbincr_vlc , 9 , 35 , \n & mbAddrIncrTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbAddrIncrTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_pat_vlc , 9 , 63 , \n & mbPatTable [ 0 ] [ 1 ] , 2 , 1 , \n & mbPatTable [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_ptype_vlc , 6 , 32 , \n & table_mb_ptype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_ptype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & mb_btype_vlc , 6 , 32 , \n & table_mb_btype [ 0 ] [ 1 ] , 2 , 1 , \n & table_mb_btype [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_rl ( & rl_mpeg1 ) ; \n init_rl ( & rl_mpeg2 ) ; \n init_vlc ( & rl_mpeg1 . vlc , 9 , rl_mpeg1 . n + 2 , \n & rl_mpeg1 . table_vlc [ 0 ] [ 1 ] , 4 , 2 , \n & rl_mpeg1 . table_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; \n init_vlc ( & rl_mpeg2 . vlc , 9 , rl_mpeg2 . n + 2 , \n & rl_mpeg2 . table_vlc [ 0 ] [ 1 ] , 4 , 2 , \n & rl_mpeg2 . table_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; \n } \n }", "idx": 26337}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int smc_decode_init ( AVCodecContext * avctx ) \n { \n SmcContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 26342}
{"project": "FFmpeg", "commit_id": "a4d3cf10b2ece441ae25849a66b1c11d838f9381", "target": 0, "func": "static void decode_lowdelay ( DiracContext * s ) \n { \n AVCodecContext * avctx = s -> avctx ; \n int slice_x , slice_y , bytes , bufsize ; \n const uint8_t * buf ; \n struct lowdelay_slice * slices ; \n int slice_num = 0 ; \n slices = av_mallocz_array ( s -> lowdelay . num_x , s -> lowdelay . num_y * sizeof ( struct lowdelay_slice ) ) ; \n align_get_bits ( & s -> gb ) ; \n buf = s -> gb . buffer + get_bits_count ( & s -> gb ) / 8 ; \n bufsize = get_bits_left ( & s -> gb ) ; \n for ( slice_y = 0 ; bufsize > 0 && slice_y < s -> lowdelay . num_y ; slice_y ++ ) \n for ( slice_x = 0 ; bufsize > 0 && slice_x < s -> lowdelay . num_x ; slice_x ++ ) { \n bytes = ( slice_num + 1 ) * s -> lowdelay . bytes . num / s -> lowdelay . bytes . den \n - slice_num * s -> lowdelay . bytes . num / s -> lowdelay . bytes . den ; \n slices [ slice_num ] . bytes = bytes ; \n slices [ slice_num ] . slice_x = slice_x ; \n slices [ slice_num ] . slice_y = slice_y ; \n init_get_bits ( & slices [ slice_num ] . gb , buf , bufsize ) ; \n slice_num ++ ; \n buf += bytes ; \n bufsize -= bytes * 8 ; \n } \n avctx -> execute ( avctx , decode_lowdelay_slice , slices , NULL , slice_num , \n sizeof ( struct lowdelay_slice ) ) ; \n intra_dc_prediction ( & s -> plane [ 0 ] . band [ 0 ] [ 0 ] ) ; \n intra_dc_prediction ( & s -> plane [ 1 ] . band [ 0 ] [ 0 ] ) ; \n intra_dc_prediction ( & s -> plane [ 2 ] . band [ 0 ] [ 0 ] ) ; \n av_free ( slices ) ; \n }", "idx": 26344}
{"project": "FFmpeg", "commit_id": "b7e7ee6231bc1f3608ed4005c3e7550ec4815296", "target": 1, "func": "static void copy_video_props ( AVFilterBufferRefVideoProps * dst , AVFilterBufferRefVideoProps * src ) { \n * dst = * src ; \n if ( src -> qp_table ) { \n int qsize = src -> qp_table_size ; \n dst -> qp_table = av_malloc ( qsize ) ; \n memcpy ( dst -> qp_table , src -> qp_table , qsize ) ; \n } \n }", "idx": 26345}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "void * av_fast_realloc ( void * ptr , unsigned int * size , unsigned int min_size ) \n { \n if ( min_size < * size ) \n return ptr ; \n * size = 17 * min_size / 16 + 32 ; \n return av_realloc ( ptr , * size ) ; \n }", "idx": 26353}
{"project": "FFmpeg", "commit_id": "2b1a4c5b3411c3030a5bdbd70d80bc606be570f7", "target": 1, "func": "static int amovie_request_frame ( AVFilterLink * outlink ) \n { \n MovieContext * movie = outlink -> src -> priv ; \n int ret ; \n if ( movie -> is_done ) \n return AVERROR_EOF ; \n if ( ( ret = amovie_get_samples ( outlink ) ) < 0 ) \n return ret ; \n avfilter_filter_samples ( outlink , avfilter_ref_buffer ( movie -> samplesref , ~ 0 ) ) ; \n avfilter_unref_buffer ( movie -> samplesref ) ; \n movie -> samplesref = NULL ; \n return 0 ; \n }", "idx": 26382}
{"project": "FFmpeg", "commit_id": "7a8cbb39f6154fb091597d28deba8d3bec38df64", "target": 0, "func": "static av_cold int Faac_encode_close ( AVCodecContext * avctx ) \n { \n FaacAudioContext * s = avctx -> priv_data ; \n av_freep ( & avctx -> coded_frame ) ; \n av_freep ( & avctx -> extradata ) ; \n faacEncClose ( s -> faac_handle ) ; \n return 0 ; \n }", "idx": 26412}
{"project": "FFmpeg", "commit_id": "f3202871598f59b570b31b01cfeb64b8fedbd700", "target": 1, "func": "AVD3D11VAContext * av_d3d11va_alloc_context ( void ) \n { \n AVD3D11VAContext * res = av_mallocz ( sizeof ( AVD3D11VAContext ) ) ; \n res -> context_mutex = INVALID_HANDLE_VALUE ; \n return res ; \n }", "idx": 26417}
{"project": "FFmpeg", "commit_id": "7dafb3a25a580a5f8f1a5083835c67be9ed17043", "target": 1, "func": "static int cudaupload_query_formats ( AVFilterContext * ctx ) \n { \n int ret ; \n static const enum AVPixelFormat input_pix_fmts [ ] = { \n AV_PIX_FMT_NV12 , AV_PIX_FMT_YUV420P , AV_PIX_FMT_YUV444P , \n AV_PIX_FMT_NONE , \n } ; \n static const enum AVPixelFormat output_pix_fmts [ ] = { \n AV_PIX_FMT_CUDA , AV_PIX_FMT_NONE , \n } ; \n AVFilterFormats * in_fmts = ff_make_format_list ( input_pix_fmts ) ; \n AVFilterFormats * out_fmts = ff_make_format_list ( output_pix_fmts ) ; \n ret = ff_formats_ref ( in_fmts , & ctx -> inputs [ 0 ] -> out_formats ) ; \n if ( ret < 0 ) \n return ret ; \n ret = ff_formats_ref ( out_fmts , & ctx -> outputs [ 0 ] -> in_formats ) ; \n if ( ret < 0 ) \n return ret ; \n return 0 ; \n }", "idx": 26419}
{"project": "FFmpeg", "commit_id": "20a93ea8d489304d5c522283d79ea5f9c8fdc804", "target": 0, "func": "static void check_mct ( uint8_t * ref0 , uint8_t * ref1 , uint8_t * ref2 , \n uint8_t * new0 , uint8_t * new1 , uint8_t * new2 ) { \n declare_func ( void , void * src0 , void * src1 , void * src2 , int csize ) ; \n randomize_buffers ( ) ; \n call_ref ( ref0 , ref1 , ref2 , BUF_SIZE / sizeof ( int32_t ) ) ; \n call_new ( new0 , new1 , new2 , BUF_SIZE / sizeof ( int32_t ) ) ; \n if ( memcmp ( ref0 , new0 , BUF_SIZE ) || memcmp ( ref1 , new1 , BUF_SIZE ) || \n memcmp ( ref2 , new2 , BUF_SIZE ) ) \n fail ( ) ; \n bench_new ( new0 , new1 , new2 , BUF_SIZE / sizeof ( int32_t ) ) ; \n }", "idx": 26424}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC ( ff_h264_add_pixels4 ) ( uint8_t * _dst , int16_t * _src , int stride ) \n { \n int i ; \n pixel * dst = ( pixel * ) _dst ; \n dctcoef * src = ( dctcoef * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dst [ 0 ] += src [ 0 ] ; \n dst [ 1 ] += src [ 1 ] ; \n dst [ 2 ] += src [ 2 ] ; \n dst [ 3 ] += src [ 3 ] ; \n dst += stride ; \n src += 4 ; \n } \n memset ( _src , 0 , sizeof ( dctcoef ) * 16 ) ; \n }", "idx": 26427}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_2r_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 512 ] + samples [ i + 768 ] ) ; \n samples [ i + 256 ] = samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 26429}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_dolby ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] - samples [ i + 768 ] ) ; \n samples [ i + 256 ] += ( samples [ i + 512 ] + samples [ i + 768 ] ) ; \n samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 26431}
{"project": "FFmpeg", "commit_id": "a11c16a0b0cadf3a14fa5e7329c2a144a2165bc6", "target": 1, "func": "void compute_images_mse ( PSNRContext * s , \n const uint8_t * main_data [ 4 ] , const int main_linesizes [ 4 ] , \n const uint8_t * ref_data [ 4 ] , const int ref_linesizes [ 4 ] , \n int w , int h , double mse [ 4 ] ) \n { \n int i , c , j ; \n for ( c = 0 ; c < s -> nb_components ; c ++ ) { \n const int outw = s -> planewidth [ c ] ; \n const int outh = s -> planeheight [ c ] ; \n const uint8_t * main_line = main_data [ c ] ; \n const uint8_t * ref_line = ref_data [ c ] ; \n const int ref_linesize = ref_linesizes [ c ] ; \n const int main_linesize = main_linesizes [ c ] ; \n int m = 0 ; \n for ( i = 0 ; i < outh ; i ++ ) { \n for ( j = 0 ; j < outw ; j ++ ) \n m += pow2 ( main_line [ j ] - ref_line [ j ] ) ; \n ref_line += ref_linesize ; \n main_line += main_linesize ; \n } \n mse [ c ] = m / ( double ) ( outw * outh ) ; \n } \n }", "idx": 26433}
{"project": "FFmpeg", "commit_id": "7f4ec4364bc4a73036660c1c6a3c4801db524e9e", "target": 0, "func": "static int mov_read_dac3 ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n enum AVAudioServiceType * ast ; \n int ac3info , acmod , lfeon , bsmod ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n ast = ( enum AVAudioServiceType * ) ff_stream_new_side_data ( st , AV_PKT_DATA_AUDIO_SERVICE_TYPE , \n sizeof ( * ast ) ) ; \n if ( ! ast ) \n return AVERROR ( ENOMEM ) ; \n ac3info = avio_rb24 ( pb ) ; \n bsmod = ( ac3info >> 14 ) & 0x7 ; \n acmod = ( ac3info >> 11 ) & 0x7 ; \n lfeon = ( ac3info >> 10 ) & 0x1 ; \n st -> codec -> channels = ( ( int [ ] ) { 2 , 1 , 2 , 3 , 3 , 4 , 4 , 5 } ) [ acmod ] + lfeon ; \n st -> codec -> channel_layout = avpriv_ac3_channel_layout_tab [ acmod ] ; \n if ( lfeon ) \n st -> codec -> channel_layout |= AV_CH_LOW_FREQUENCY ; \n * ast = bsmod ; \n if ( st -> codec -> channels > 1 && bsmod == 0x7 ) \n * ast = AV_AUDIO_SERVICE_TYPE_KARAOKE ; \n st -> codec -> audio_service_type = * ast ; \n return 0 ; \n }", "idx": 26441}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int mpsub_probe ( AVProbeData * p ) \n { \n const char * ptr = p -> buf ; \n const char * ptr_end = p -> buf + p -> buf_size ; \n while ( ptr < ptr_end ) { \n if ( ! memcmp ( ptr , \" \" , 11 ) ) \n return AVPROBE_SCORE_EXTENSION ; \n if ( ! memcmp ( ptr , \" \" , 7 ) ) \n return AVPROBE_SCORE_EXTENSION / 3 ; \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n } \n return 0 ; \n }", "idx": 26446}
{"project": "FFmpeg", "commit_id": "3518c5a96b0417f6e66bd0c8c64bd2b32d936064", "target": 1, "func": "void MPV_common_init_altivec ( MpegEncContext * s ) \n { \n if ( s -> avctx -> lowres == 0 ) \n { \n if ( ( s -> avctx -> idct_algo == FF_IDCT_AUTO ) || \n ( s -> avctx -> idct_algo == FF_IDCT_ALTIVEC ) ) \n { \n s -> dsp . idct_put = idct_put_altivec ; \n s -> dsp . idct_add = idct_add_altivec ; \n s -> dsp . idct_permutation_type = FF_TRANSPOSE_IDCT_PERM ; \n } \n } \n if ( ( ( ( long ) ( s -> q_intra_matrix ) & 0x0f ) != 0 ) || \n ( ( ( long ) ( s -> q_inter_matrix ) & 0x0f ) != 0 ) ) \n { \n av_log ( s -> avctx , AV_LOG_INFO , \" \" \n \" \\n \" ) ; \n return ; \n } \n if ( ( ( long ) ( s -> intra_scantable . inverse ) & 0x0f ) != 0 ) \n { \n av_log ( s -> avctx , AV_LOG_INFO , \" \" \n \" \\n \" ) ; \n return ; \n } \n if ( ( s -> avctx -> dct_algo == FF_DCT_AUTO ) || \n ( s -> avctx -> dct_algo == FF_DCT_ALTIVEC ) ) \n { \n #if 0  \n  \n  s -> dct_quantize = dct_quantize_altivec ; \n #endif \n s -> dct_unquantize_h263_intra = dct_unquantize_h263_altivec ; \n s -> dct_unquantize_h263_inter = dct_unquantize_h263_altivec ; \n } \n }", "idx": 26447}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_auth ( FTPContext * s ) \n { \n const char * user = NULL , * pass = NULL ; \n char * end = NULL , buf [ CONTROL_BUFFER_SIZE ] , credencials [ CREDENTIALS_BUFFER_SIZE ] ; \n int err ; \n const int user_codes [ ] = { 331 , 230 , 0 } ; \n const int pass_codes [ ] = { 230 , 0 } ; \n av_strlcpy ( credencials , s -> credencials , sizeof ( credencials ) ) ; \n user = av_strtok ( credencials , \" \" , & end ) ; \n pass = av_strtok ( end , \" \" , & end ) ; \n if ( ! user ) { \n user = \" \" ; \n pass = s -> anonymous_password ? s -> anonymous_password : \" \" ; \n } \n snprintf ( buf , sizeof ( buf ) , \" \\r \\n \" , user ) ; \n err = ftp_send_command ( s , buf , user_codes , NULL ) ; \n if ( err == 331 ) { \n if ( pass ) { \n snprintf ( buf , sizeof ( buf ) , \" \\r \\n \" , pass ) ; \n err = ftp_send_command ( s , buf , pass_codes , NULL ) ; \n } else \n return AVERROR ( EACCES ) ; \n } \n if ( ! err ) \n return AVERROR ( EACCES ) ; \n return 0 ; \n }", "idx": 26470}
{"project": "FFmpeg", "commit_id": "fddc5b9bea39968ed1f45c667869428865de7626", "target": 0, "func": "int ff_celp_lp_synthesis_filter ( int16_t * out , const int16_t * filter_coeffs , \n const int16_t * in , int buffer_length , \n int filter_length , int stop_on_overflow , \n int shift , int rounder ) \n { \n int i , n ; \n for ( n = 0 ; n < buffer_length ; n ++ ) { \n int sum = rounder ; \n for ( i = 1 ; i <= filter_length ; i ++ ) \n sum -= filter_coeffs [ i - 1 ] * out [ n - i ] ; \n sum = ( ( sum >> 12 ) + in [ n ] ) >> shift ; \n if ( sum + 0x8000 > 0xFFFFU ) { \n if ( stop_on_overflow ) \n return 1 ; \n sum = ( sum >> 31 ) ^ 32767 ; \n } \n out [ n ] = sum ; \n } \n return 0 ; \n }", "idx": 26473}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode ( GetByteContext * gb , RangeCoder * rc , unsigned cumFreq , unsigned freq , unsigned total_freq ) \n { \n rc -> code -= cumFreq * rc -> range ; \n rc -> range *= freq ; \n while ( rc -> range < TOP && bytestream2_get_bytes_left ( gb ) > 0 ) { \n unsigned byte = bytestream2_get_byte ( gb ) ; \n rc -> code = ( rc -> code << 8 ) | byte ; \n rc -> range <<= 8 ; \n } \n }", "idx": 26477}
{"project": "FFmpeg", "commit_id": "98422c44cf86de6da8f73a7bd80284ed165c5a98", "target": 1, "func": "vorbis_comment ( AVFormatContext * as , uint8_t * buf , int size )  \n { \n const uint8_t * p = buf ; \n const uint8_t * end = buf + size ; \n unsigned s , n , j ; \n if ( size < 8 ) \n return -1 ; \n s = bytestream_get_le32 ( & p ) ; \n if ( end - p < s ) \n return -1 ; \n p += s ; \n n = bytestream_get_le32 ( & p ) ; \n while ( p < end && n > 0 ) { \n const char * t , * v ; \n int tl , vl ; \n s = bytestream_get_le32 ( & p ) ; \n if ( end - p < s ) \n break ; \n t = p ; \n p += s ; \n n -- ; \n v = memchr ( t , ' ' , s ) ; \n if ( ! v ) \n continue ; \n tl = v - t ; \n vl = s - tl - 1 ; \n v ++ ; \n if ( tl && vl ) { \n char * tt , * ct ; \n tt = av_malloc ( tl + 1 ) ; \n ct = av_malloc ( vl + 1 ) ; \n if ( ! tt || ! ct ) { \n av_freep ( & tt ) ; \n av_freep ( & ct ) ; \n av_log ( as , AV_LOG_WARNING , \" \\n \" ) ; \n continue ; \n } \n for ( j = 0 ; j < tl ; j ++ ) \n tt [ j ] = toupper ( t [ j ] ) ; \n tt [ tl ] = 0 ; \n memcpy ( ct , v , vl ) ; \n ct [ vl ] = 0 ; \n av_metadata_set ( & as -> metadata , tt , ct ) ; \n av_freep ( & tt ) ; \n av_freep ( & ct ) ; \n } \n } \n if ( p != end ) \n av_log ( as , AV_LOG_INFO , \" \\n \" , end - p ) ; \n if ( n > 0 ) \n av_log ( as , AV_LOG_INFO , \n \" \\n \" , n ) ; \n return 0 ; \n }", "idx": 26505}
{"project": "FFmpeg", "commit_id": "5a571d324129ce367584ad9d92aae1d286f389a2", "target": 1, "func": "static PayloadContext * h264_new_context ( void ) \n { \n PayloadContext * data = \n av_mallocz ( sizeof ( PayloadContext ) + \n FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( data ) { \n data -> cookie = MAGIC_COOKIE ; \n } \n return data ; \n }", "idx": 26507}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16_sse2 ( uint8_t * dst , const int * block_offset , DCTELEM * block , int stride , const uint8_t nnzc [ 6 * 8 ] ) { \n int i ; \n for ( i = 0 ; i < 16 ; i += 2 ) \n if ( nnzc [ scan8 [ i + 0 ] ] | nnzc [ scan8 [ i + 1 ] ] ) \n ff_x264_add8x4_idct_sse2 ( dst + block_offset [ i ] , block + i * 16 , stride ) ; \n }", "idx": 26513}
{"project": "FFmpeg", "commit_id": "de6a1e32fd483db05d957268d5e45e2b1be9cab4", "target": 1, "func": "static int io_write_data_type ( void * opaque , uint8_t * buf , int size , \n enum AVIODataMarkerType type , int64_t time ) \n { \n char timebuf [ 30 ] , content [ 5 ] = { 0 } ; \n const char * str ; \n switch ( type ) { \n case AVIO_DATA_MARKER_HEADER : str = \" \" ; break ; \n case AVIO_DATA_MARKER_SYNC_POINT : str = \" \" ; break ; \n case AVIO_DATA_MARKER_BOUNDARY_POINT : str = \" \" ; break ; \n case AVIO_DATA_MARKER_UNKNOWN : str = \" \" ; break ; \n case AVIO_DATA_MARKER_TRAILER : str = \" \" ; break ; \n } \n if ( time == AV_NOPTS_VALUE ) \n snprintf ( timebuf , sizeof ( timebuf ) , \" \" ) ; \n else \n snprintf ( timebuf , sizeof ( timebuf ) , \" \" PRId64 , time ) ; \n if ( type != AVIO_DATA_MARKER_UNKNOWN && \n type != AVIO_DATA_MARKER_TRAILER && \n ( type != AVIO_DATA_MARKER_HEADER || out_size == 0 ) && \n size >= 8 ) \n memcpy ( content , & buf [ 4 ] , 4 ) ; \n else \n snprintf ( content , sizeof ( content ) , \" \" ) ; \n printf ( \" \\n \" , size , timebuf , str , content ) ; \n return io_write ( opaque , buf , size ) ; \n }", "idx": 26523}
{"project": "FFmpeg", "commit_id": "c7269e3a2697c189c907832b8a36341cbb40936c", "target": 1, "func": "static void release_buffer ( AVCodecContext * avctx , AVFrame * pic ) \n { \n int i ; \n CVPixelBufferRef cv_buffer = ( CVPixelBufferRef ) pic -> data [ 3 ] ; \n CVPixelBufferUnlockBaseAddress ( cv_buffer , 0 ) ; \n CVPixelBufferRelease ( cv_buffer ) ; \n for ( i = 0 ; i < 4 ; i ++ ) \n pic -> data [ i ] = NULL ; \n }", "idx": 26524}
{"project": "FFmpeg", "commit_id": "233f6f889ea310c2213f1f678b68e424791bf843", "target": 0, "func": "AVOption * av_set_string ( void * obj , const char * name , const char * val ) { \n AVOption * o = find_opt ( obj , name ) ; \n if ( ! o || ! val || o -> offset <= 0 ) \n return NULL ; \n if ( o -> type != FF_OPT_TYPE_STRING ) { \n double d = 0 , tmp_d ; \n for ( ; ; ) { \n int i ; \n char buf [ 256 ] , * tail ; \n for ( i = 0 ; i < sizeof ( buf ) - 1 && val [ i ] && val [ i ] != ' ' ; i ++ ) \n buf [ i ] = val [ i ] ; \n buf [ i ] = 0 ; \n val += i ; \n tmp_d = av_parse_num ( buf , & tail ) ; \n if ( tail > buf ) \n d += tmp_d ; \n else { \n AVOption * o_named = find_opt ( obj , buf ) ; \n if ( o_named && o_named -> type == FF_OPT_TYPE_CONST ) \n d += o_named -> default_val ; \n else if ( ! strcmp ( buf , \" \" ) ) d += o -> default_val ; \n else if ( ! strcmp ( buf , \" \" ) ) d += o -> max ; \n else if ( ! strcmp ( buf , \" \" ) ) d += o -> min ; \n else return NULL ; \n } \n if ( * val == ' ' ) val ++ ; \n if ( ! * val ) \n return av_set_number ( obj , name , d , 1 , 1 ) ; \n } \n return NULL ; \n } \n memcpy ( ( ( uint8_t * ) obj ) + o -> offset , val , sizeof ( val ) ) ; \n return o ; \n }", "idx": 26526}
{"project": "FFmpeg", "commit_id": "508a24f8dc63e74bd9917e6f0c4cdbb744741ef0", "target": 0, "func": "static av_cold int mpeg_mc_decode_init ( AVCodecContext * avctx ) { \n if ( avctx -> thread_count > 1 ) \n return -1 ; \n if ( ! ( avctx -> slice_flags & SLICE_FLAG_CODED_ORDER ) ) \n return -1 ; \n if ( ! ( avctx -> slice_flags & SLICE_FLAG_ALLOW_FIELD ) ) { \n av_dlog ( avctx , \" \\n \" ) ; \n } \n mpeg_decode_init ( avctx ) ; \n avctx -> pix_fmt = PIX_FMT_XVMC_MPEG2_IDCT ; \n avctx -> xvmc_acceleration = 2 ; \n return 0 ; \n }", "idx": 26555}
{"project": "FFmpeg", "commit_id": "50ce510ac4e3ed093c051738242a9a75aeeb36ce", "target": 0, "func": "static int thread_execute ( AVCodecContext * avctx , action_func * func , void * arg , int * ret , int job_count , int job_size ) \n { \n SliceThreadContext * c = avctx -> internal -> thread_ctx ; \n int dummy_ret ; \n if ( ! ( avctx -> active_thread_type & FF_THREAD_SLICE ) || avctx -> thread_count <= 1 ) \n return avcodec_default_execute ( avctx , func , arg , ret , job_count , job_size ) ; \n if ( job_count <= 0 ) \n return 0 ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n c -> current_job = avctx -> thread_count ; \n c -> job_count = job_count ; \n c -> job_size = job_size ; \n c -> args = arg ; \n c -> func = func ; \n if ( ret ) { \n c -> rets = ret ; \n c -> rets_count = job_count ; \n } else { \n c -> rets = & dummy_ret ; \n c -> rets_count = 1 ; \n } \n c -> current_execute ++ ; \n pthread_cond_broadcast ( & c -> current_job_cond ) ; \n thread_park_workers ( c , avctx -> thread_count ) ; \n return 0 ; \n }", "idx": 26579}
{"project": "FFmpeg", "commit_id": "e8a3498f2452ba2be605b1ffb5974143095aacf1", "target": 1, "func": "static void chs_assemble_msbs_lsbs ( DCAXllDecoder * s , DCAXllChSet * c , int band ) \n { \n DCAXllBand * b = & c -> bands [ band ] ; \n int n , ch , nsamples = s -> nframesamples ; \n for ( ch = 0 ; ch < c -> nchannels ; ch ++ ) { \n int shift = chs_get_lsb_width ( s , c , band , ch ) ; \n if ( shift ) { \n int32_t * msb = b -> msb_sample_buffer [ ch ] ; \n if ( b -> nscalablelsbs [ ch ] ) { \n int32_t * lsb = b -> lsb_sample_buffer [ ch ] ; \n int adj = b -> bit_width_adjust [ ch ] ; \n for ( n = 0 ; n < nsamples ; n ++ ) \n msb [ n ] = msb [ n ] * ( 1 << shift ) + ( lsb [ n ] << adj ) ; \n } else { \n for ( n = 0 ; n < nsamples ; n ++ ) \n msb [ n ] = msb [ n ] * ( 1 << shift ) ; \n } \n } \n } \n }", "idx": 26581}
{"project": "FFmpeg", "commit_id": "14e4e26559697cfdea584767be4e68474a0a9c7f", "target": 1, "func": "static int t27 ( InterplayACMContext * s , unsigned ind , unsigned col ) \n { \n GetBitContext * gb = & s -> gb ; \n unsigned i , b ; \n int n1 , n2 , n3 ; \n for ( i = 0 ; i < s -> rows ; i ++ ) { \n b = get_bits ( gb , 7 ) ; \n n1 = ( mul_3x5 [ b ] & 0x0F ) - 2 ; \n n2 = ( ( mul_3x5 [ b ] >> 4 ) & 0x0F ) - 2 ; \n n3 = ( ( mul_3x5 [ b ] >> 8 ) & 0x0F ) - 2 ; \n set_pos ( s , i ++ , col , n1 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i ++ , col , n2 ) ; \n if ( i >= s -> rows ) \n break ; \n set_pos ( s , i , col , n3 ) ; \n return 0 ;", "idx": 26585}
{"project": "FFmpeg", "commit_id": "d81be0a60a6dea2bc48ec29f9466eee63984ed34", "target": 1, "func": "static AVFrame * hwmap_get_buffer ( AVFilterLink * inlink , int w , int h ) \n { \n AVFilterContext * avctx = inlink -> dst ; \n AVFilterLink * outlink = avctx -> outputs [ 0 ] ; \n HWMapContext * ctx = avctx -> priv ; \n if ( ctx -> map_backwards ) { \n AVFrame * src , * dst ; \n int err ; \n src = ff_get_video_buffer ( outlink , w , h ) ; \n if ( ! src ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" ) ; \n return NULL ; \n } \n dst = av_frame_alloc ( ) ; \n if ( ! dst ) { \n av_frame_free ( & src ) ; \n return NULL ; \n } \n err = av_hwframe_map ( dst , src , ctx -> mode ) ; \n if ( err ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" , err ) ; \n av_frame_free ( & src ) ; \n av_frame_free ( & dst ) ; \n return NULL ; \n } \n av_frame_free ( & src ) ; \n return dst ; \n } else { \n return ff_default_get_video_buffer ( inlink , w , h ) ; \n } \n }", "idx": 26588}
{"project": "FFmpeg", "commit_id": "e1bd40fe6beb74a942b7b0cff2d077750a7e733e", "target": 0, "func": "PIX_SAD ( mmxext ) \n #endif \n av_cold  void ff_dsputil_init_pix_mmx ( DSPContext * c , AVCodecContext * avctx ) \n { \n #if HAVE_INLINE_ASM  \n  \n  int cpu_flags = av_get_cpu_flags ( ) ; \n if ( INLINE_MMX ( cpu_flags ) ) { \n c -> pix_abs [ 0 ] [ 0 ] = sad16_mmx ; \n c -> pix_abs [ 0 ] [ 1 ] = sad16_x2_mmx ; \n c -> pix_abs [ 0 ] [ 2 ] = sad16_y2_mmx ; \n c -> pix_abs [ 0 ] [ 3 ] = sad16_xy2_mmx ; \n c -> pix_abs [ 1 ] [ 0 ] = sad8_mmx ; \n c -> pix_abs [ 1 ] [ 1 ] = sad8_x2_mmx ; \n c -> pix_abs [ 1 ] [ 2 ] = sad8_y2_mmx ; \n c -> pix_abs [ 1 ] [ 3 ] = sad8_xy2_mmx ; \n c -> sad [ 0 ] = sad16_mmx ; \n c -> sad [ 1 ] = sad8_mmx ; \n } \n if ( INLINE_MMXEXT ( cpu_flags ) ) { \n c -> pix_abs [ 0 ] [ 0 ] = sad16_mmxext ; \n c -> pix_abs [ 1 ] [ 0 ] = sad8_mmxext ; \n c -> sad [ 0 ] = sad16_mmxext ; \n c -> sad [ 1 ] = sad8_mmxext ; \n if ( ! ( avctx -> flags & CODEC_FLAG_BITEXACT ) ) { \n c -> pix_abs [ 0 ] [ 1 ] = sad16_x2_mmxext ; \n c -> pix_abs [ 0 ] [ 2 ] = sad16_y2_mmxext ; \n c -> pix_abs [ 0 ] [ 3 ] = sad16_xy2_mmxext ; \n c -> pix_abs [ 1 ] [ 1 ] = sad8_x2_mmxext ; \n c -> pix_abs [ 1 ] [ 2 ] = sad8_y2_mmxext ; \n c -> pix_abs [ 1 ] [ 3 ] = sad8_xy2_mmxext ; \n } \n } \n if ( INLINE_SSE2 ( cpu_flags ) && ! ( cpu_flags & AV_CPU_FLAG_3DNOW ) && avctx -> codec_id != AV_CODEC_ID_SNOW ) { \n c -> sad [ 0 ] = sad16_sse2 ; \n } \n #endif \n }", "idx": 26591}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n uint8_t * buf , int buf_size ) \n { \n XanContext * s = avctx -> priv_data ; \n AVPaletteControl * palette_control = avctx -> palctrl ; \n int keyframe = 0 ; \n if ( palette_control -> palette_changed ) { \n xan_wc3_build_palette ( s , palette_control -> palette ) ; \n if ( s -> avctx -> pix_fmt != PIX_FMT_PAL8 ) \n palette_control -> palette_changed = 0 ; \n keyframe = 1 ; \n } \n if ( avctx -> get_buffer ( avctx , & s -> current_frame ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> current_frame . reference = 3 ; \n s -> buf = buf ; \n s -> size = buf_size ; \n if ( avctx -> codec -> id == CODEC_ID_XAN_WC3 ) \n xan_wc3_decode_frame ( s ) ; \n else if ( avctx -> codec -> id == CODEC_ID_XAN_WC4 ) \n xan_wc4_decode_frame ( s ) ; \n if ( s -> last_frame . data [ 0 ] ) \n avctx -> release_buffer ( avctx , & s -> last_frame ) ; \n s -> last_frame = s -> current_frame ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = s -> current_frame ; \n return buf_size ; \n }", "idx": 26602}
{"project": "FFmpeg", "commit_id": "ef4c71e8f83a46fb31a11f0a066efb90821c579f", "target": 0, "func": "static void init_filter_param ( AVFilterContext * ctx , FilterParam * fp , const char * effect_type , int width ) \n { \n int z ; \n const char * effect ; \n effect = fp -> amount == 0 ? \" \" : fp -> amount < 0 ? \" \" : \" \" ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , \n effect , effect_type , fp -> msize_x , fp -> msize_y , fp -> amount / 65535.0 ) ; \n for ( z = 0 ; z < 2 * fp -> steps_y ; z ++ ) \n fp -> sc [ z ] = av_malloc ( sizeof ( * ( fp -> sc [ z ] ) ) * ( width + 2 * fp -> steps_x ) ) ; \n }", "idx": 26611}
{"project": "FFmpeg", "commit_id": "9888ffb1ce5e0a17f711b01933d504c72ea29d3b", "target": 0, "func": "static int mov_read_stco ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned int i , entries ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n if ( ! entries ) \n return 0 ; \n if ( entries >= UINT_MAX / sizeof ( int64_t ) ) \n return AVERROR_INVALIDDATA ; \n sc -> chunk_offsets = av_malloc ( entries * sizeof ( int64_t ) ) ; \n if ( ! sc -> chunk_offsets ) \n return AVERROR ( ENOMEM ) ; \n sc -> chunk_count = entries ; \n if ( atom . type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n for ( i = 0 ; i < entries ; i ++ ) \n sc -> chunk_offsets [ i ] = avio_rb32 ( pb ) ; \n else if ( atom . type == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n for ( i = 0 ; i < entries ; i ++ ) \n sc -> chunk_offsets [ i ] = avio_rb64 ( pb ) ; \n else \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 26613}
{"project": "FFmpeg", "commit_id": "3faa303a47e0c3b59a53988e0f76018930c6cb1a", "target": 0, "func": "static inline void decode_subblock ( DCTELEM * dst , int code , const int is_block2 , GetBitContext * gb , VLC * vlc , int q ) \n { \n int coeffs [ 4 ] ; \n coeffs [ 0 ] = modulo_three_table [ code ] [ 0 ] ; \n coeffs [ 1 ] = modulo_three_table [ code ] [ 1 ] ; \n coeffs [ 2 ] = modulo_three_table [ code ] [ 2 ] ; \n coeffs [ 3 ] = modulo_three_table [ code ] [ 3 ] ; \n decode_coeff ( dst , coeffs [ 0 ] , 3 , gb , vlc , q ) ; \n if ( is_block2 ) { \n decode_coeff ( dst + 8 , coeffs [ 1 ] , 2 , gb , vlc , q ) ; \n decode_coeff ( dst + 1 , coeffs [ 2 ] , 2 , gb , vlc , q ) ; \n } else { \n decode_coeff ( dst + 1 , coeffs [ 1 ] , 2 , gb , vlc , q ) ; \n decode_coeff ( dst + 8 , coeffs [ 2 ] , 2 , gb , vlc , q ) ; \n } \n decode_coeff ( dst + 9 , coeffs [ 3 ] , 2 , gb , vlc , q ) ; \n }", "idx": 26615}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int process_metadata ( AVFormatContext * s , uint8_t * name , uint16_t name_len , \n uint16_t val_len , uint16_t type , AVDictionary * * met ) \n { \n int ret ; \n ff_asf_guid guid ; \n if ( val_len ) { \n switch ( type ) { \n case ASF_UNICODE : \n asf_read_value ( s , name , name_len , val_len , type , met ) ; \n break ; \n case ASF_BYTE_ARRAY : \n if ( ! strcmp ( name , \" \" ) ) \n asf_read_picture ( s , val_len ) ; \n else if ( ! strcmp ( name , \" \" ) ) \n get_id3_tag ( s , val_len ) ; \n else \n asf_read_value ( s , name , name_len , val_len , type , met ) ; \n break ; \n case ASF_GUID : \n ff_get_guid ( s -> pb , & guid ) ; \n break ; \n default : \n if ( ( ret = asf_read_generic_value ( s , name , name_len , type , met ) ) < 0 ) \n return ret ; \n break ; \n } \n } \n av_freep ( & name ) ; \n return 0 ; \n }", "idx": 26618}
{"project": "FFmpeg", "commit_id": "86736f59d6a527d8bc807d09b93f971c0fe0bb07", "target": 0, "func": "static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) \n { \n long i ; \n for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { \n long a = * ( long * ) ( src1 + i ) ; \n long b = * ( long * ) ( src2 + i ) ; \n * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; \n } \n for ( ; i < w ; i ++ ) \n dst [ i ] = src1 [ i ] + src2 [ i ] ; \n }", "idx": 26622}
{"project": "FFmpeg", "commit_id": "fed50c4304eecb352e29ce789cdb96ea84d6162f", "target": 1, "func": "void av_set_cpu_flags_mask ( int mask ) \n { \n cpu_flags = get_cpu_flags ( ) & mask ; \n }", "idx": 26626}
{"project": "FFmpeg", "commit_id": "c3671e1d5760d79c083e7565d951f4628c06cf41", "target": 1, "func": "void ff_riff_write_info_tag ( AVIOContext * pb , const char * tag , const char * str ) \n { \n int len = strlen ( str ) ; \n if ( len > 0 ) { \n len ++ ; \n ffio_wfourcc ( pb , tag ) ; \n avio_wl32 ( pb , len ) ; \n avio_put_str ( pb , str ) ; \n if ( len & 1 ) \n avio_w8 ( pb , 0 ) ; \n } \n }", "idx": 26636}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_mjpeg_init_internal ( AVCodecContext * avctx ) \n { \n static const VAConfigAttrib default_config_attributes [ ] = { \n { . type = VAConfigAttribRTFormat , \n . value = VA_RT_FORMAT_YUV420 } , \n { . type = VAConfigAttribEncPackedHeaders , \n . value = VA_ENC_PACKED_HEADER_SEQUENCE } , \n } ; \n VAAPIEncodeContext * ctx = avctx -> priv_data ; \n VAAPIEncodeMJPEGContext * priv = ctx -> priv_data ; \n int i ; \n ctx -> va_profile = VAProfileJPEGBaseline ; \n ctx -> va_entrypoint = VAEntrypointEncPicture ; \n ctx -> input_width = avctx -> width ; \n ctx -> input_height = avctx -> height ; \n ctx -> aligned_width = FFALIGN ( ctx -> input_width , 8 ) ; \n ctx -> aligned_height = FFALIGN ( ctx -> input_height , 8 ) ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( default_config_attributes ) ; i ++ ) { \n ctx -> config_attributes [ ctx -> nb_config_attributes ++ ] = \n default_config_attributes [ i ] ; \n } \n priv -> quality = avctx -> global_quality ; \n if ( priv -> quality < 1 || priv -> quality > 100 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \" \n \" \\n \" , priv -> quality ) ; \n return AVERROR ( EINVAL ) ; \n } \n vaapi_encode_mjpeg_init_tables ( avctx ) ; \n return 0 ; \n }", "idx": 26659}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int h261_probe ( AVProbeData * p ) \n { \n int code ; \n const uint8_t * d ; \n if ( p -> buf_size < 6 ) \n return 0 ; \n d = p -> buf ; \n code = ( d [ 0 ] << 12 ) | ( d [ 1 ] << 4 ) | ( d [ 2 ] >> 4 ) ; \n if ( code == 0x10 ) { \n return 50 ; \n } \n return 0 ; \n }", "idx": 26668}
{"project": "FFmpeg", "commit_id": "2007082d2db25f9305b8a345798b840ea7784fdb", "target": 0, "func": "static int mov_read_wfex ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n ff_get_wav_header ( pb , st -> codec , atom . size ) ; \n return 0 ; \n }", "idx": 26678}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static int add_doubles_metadata ( int count , \n const char * name , const char * sep , \n TiffContext * s ) \n { \n char * ap ; \n int i ; \n double * dp ; \n if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) ) \n return -1 ; \n dp = av_malloc ( count * sizeof ( double ) ) ; \n if ( ! dp ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < count ; i ++ ) \n dp [ i ] = tget_double ( & s -> gb , s -> le ) ; \n ap = doubles2str ( dp , count , sep ) ; \n av_freep ( & dp ) ; \n if ( ! ap ) \n return AVERROR ( ENOMEM ) ; \n av_dict_set ( & s -> picture . metadata , name , ap , AV_DICT_DONT_STRDUP_VAL ) ; \n return 0 ; \n }", "idx": 26704}
{"project": "FFmpeg", "commit_id": "9e1914dfbafb59b424a7c06cfdd324a85c33ef44", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFilterBufferRef * in ) \n { \n HQDN3DContext * hqdn3d = inlink -> dst -> priv ; \n AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; \n AVFilterBufferRef * out ; \n int direct , c ; \n if ( in -> perms & AV_PERM_WRITE ) { \n direct = 1 ; \n out = in ; \n } else { \n out = ff_get_video_buffer ( outlink , AV_PERM_WRITE , outlink -> w , outlink -> h ) ; \n if ( ! out ) { \n avfilter_unref_bufferp ( & in ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avfilter_copy_buffer_ref_props ( out , in ) ; \n out -> video -> w = outlink -> w ; \n out -> video -> h = outlink -> h ; \n } \n for ( c = 0 ; c < 3 ; c ++ ) { \n denoise ( hqdn3d , in -> data [ c ] , out -> data [ c ] , \n hqdn3d -> line , & hqdn3d -> frame_prev [ c ] , \n in -> video -> w >> ( ! ! c * hqdn3d -> hsub ) , \n in -> video -> h >> ( ! ! c * hqdn3d -> vsub ) , \n in -> linesize [ c ] , out -> linesize [ c ] , \n hqdn3d -> coefs [ c ? 2 : 0 ] , hqdn3d -> coefs [ c ? 3 : 1 ] ) ; \n } \n if ( ! direct ) \n avfilter_unref_bufferp ( & in ) ; \n return ff_filter_frame ( outlink , out ) ; \n }", "idx": 26716}
{"project": "FFmpeg", "commit_id": "28bf81c90d36a55cf76e2be913c5215ebebf61f2", "target": 1, "func": "void in_asm_used_var_warning_killer ( ) \n { \n volatile int i = yCoeff + vrCoeff + ubCoeff + vgCoeff + ugCoeff + bF8 + bFC + w400 + w80 + w10 + \n bm00001111 + bm00000111 + bm11111000 + b16Mask + g16Mask + r16Mask + b15Mask + g15Mask + r15Mask + temp0 + asm_yalpha1 + asm_uvalpha1 + \n M24A + M24B + M24C + w02 + funnyYCode [ 0 ] + funnyUVCode [ 0 ] + b5Dither + g5Dither + r5Dither + g6Dither + dither4 [ 0 ] + dither8 [ 0 ] ; \n if ( i ) i = 0 ; \n }", "idx": 26732}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_4x8_dc_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n int dc = block [ 0 ] ; \n const uint8_t * cm ; \n dc = ( 17 * dc + 4 ) >> 3 ; \n dc = ( 12 * dc + 64 ) >> 7 ; \n cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest += linesize ; \n } \n }", "idx": 26733}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int cmp ( const void * a , const void * b ) \n { \n const double va = * ( const double * ) a , vb = * ( const double * ) b ; \n return va < vb ? -1 : ( va > vb ? 1 : 0 ) ; \n }", "idx": 26741}
{"project": "FFmpeg", "commit_id": "e30004fa733ec64b6ff90678098c1f1132d4d603", "target": 1, "func": "static void read_len_table ( uint8_t * dst , GetBitContext * gb ) { \n int i , val , repeat ; \n for ( i = 0 ; i < 256 ; ) { \n repeat = get_bits ( gb , 3 ) ; \n val = get_bits ( gb , 5 ) ; \n if ( repeat == 0 ) \n repeat = get_bits ( gb , 8 ) ; \n while ( repeat -- ) \n dst [ i ++ ] = val ; \n } \n }", "idx": 26743}
{"project": "FFmpeg", "commit_id": "00ae5b401b24592a9f7019baada5b349152ee2fc", "target": 1, "func": "static int dca_parse ( AVCodecParserContext * s , AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n DCAParseContext * pc1 = s -> priv_data ; \n ParseContext * pc = & pc1 -> pc ; \n int next , duration , sample_rate ; \n if ( s -> flags & PARSER_FLAG_COMPLETE_FRAMES ) { \n next = buf_size ; \n } else { \n next = dca_find_frame_end ( pc1 , buf , buf_size ) ; \n if ( ff_combine_frame ( pc , next , & buf , & buf_size ) < 0 ) { \n * poutbuf = NULL ; \n * poutbuf_size = 0 ; \n return buf_size ; \n } \n } \n if ( ! dca_parse_params ( buf , buf_size , & duration , & sample_rate , & pc1 -> framesize ) ) { \n s -> duration = duration ; \n avctx -> sample_rate = sample_rate ; \n } else \n s -> duration = 0 ; \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n return next ; \n }", "idx": 26744}
{"project": "FFmpeg", "commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "target": 1, "func": "static void dnxhd_decode_dct_block_10 ( const DNXHDContext * ctx , \n RowContext * row , int n ) \n { \n dnxhd_decode_dct_block ( ctx , row , n , 6 , 8 , 4 ) ; \n }", "idx": 26755}
{"project": "FFmpeg", "commit_id": "58bba31e3f22bb07645a764602603364b1ec953d", "target": 0, "func": "static void opt_qsquish ( const char * arg ) \n { \n video_qsquish = atof ( arg ) ; \n if ( video_qsquish < 0.0 || \n video_qsquish > 99.0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n }", "idx": 26756}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_mdia_tag ( AVIOContext * pb , MOVMuxContext * mov , \n MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n mov_write_mdhd_tag ( pb , mov , track ) ; \n mov_write_hdlr_tag ( pb , track ) ; \n mov_write_minf_tag ( pb , track ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 26760}
{"project": "FFmpeg", "commit_id": "80c873a87ed07c6dd772dcf6befb4cf0fd98ef7b", "target": 1, "func": "int ff_h264_decode_sei ( H264Context * h ) { \n while ( get_bits_left ( & h -> gb ) > 16 ) { \n int size , type ; \n type = 0 ; \n do { \n if ( get_bits_left ( & h -> gb ) < 8 ) \n return AVERROR_INVALIDDATA ; \n type += show_bits ( & h -> gb , 8 ) ; \n } while ( get_bits ( & h -> gb , 8 ) == 255 ) ; \n size = 0 ; \n do { \n if ( get_bits_left ( & h -> gb ) < 8 ) \n return AVERROR_INVALIDDATA ; \n size += show_bits ( & h -> gb , 8 ) ; \n } while ( get_bits ( & h -> gb , 8 ) == 255 ) ; \n if ( h -> avctx -> debug & FF_DEBUG_STARTCODE ) \n av_log ( h -> avctx , AV_LOG_DEBUG , \" \\n \" , type , size ) ; \n switch ( type ) { \n case SEI_TYPE_PIC_TIMING : \n if ( decode_picture_timing ( h ) < 0 ) \n return -1 ; \n break ; \n case SEI_TYPE_USER_DATA_ITU_T_T35 : \n if ( decode_user_data_itu_t_t35 ( h , size ) < 0 ) \n return -1 ; \n break ; \n case SEI_TYPE_USER_DATA_UNREGISTERED : \n if ( decode_unregistered_user_data ( h , size ) < 0 ) \n return -1 ; \n break ; \n case SEI_TYPE_RECOVERY_POINT : \n if ( decode_recovery_point ( h ) < 0 ) \n return -1 ; \n break ; \n case SEI_BUFFERING_PERIOD : \n if ( decode_buffering_period ( h ) < 0 ) \n return -1 ; \n break ; \n case SEI_TYPE_FRAME_PACKING : \n if ( decode_frame_packing ( h , size ) < 0 ) \n return -1 ; \n default : \n skip_bits ( & h -> gb , 8 * size ) ; \n } \n align_get_bits ( & h -> gb ) ; \n } \n return 0 ; \n }", "idx": 26761}
{"project": "FFmpeg", "commit_id": "aae4f5108d04041bb264a9c547f05c4f0d18c9c7", "target": 1, "func": "static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) \n { \n MXFContext * mxf = arg ; \n int item_num = avio_rb32 ( pb ) ; \n int item_len = avio_rb32 ( pb ) ; \n if ( item_len != 18 ) { \n avpriv_request_sample ( pb , \" \" , item_len ) ; \n return AVERROR_PATCHWELCOME ; \n } \n if ( item_num > 65536 ) { \n av_log ( mxf -> fc , AV_LOG_ERROR , \" \\n \" , item_num ) ; \n return AVERROR_INVALIDDATA ; \n } \n mxf -> local_tags = av_calloc ( item_num , item_len ) ; \n if ( ! mxf -> local_tags ) \n return AVERROR ( ENOMEM ) ; \n mxf -> local_tags_count = item_num ; \n avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; \n return 0 ; \n }", "idx": 26764}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME ( yuv2bgr24_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n x86_reg uv_off = c -> uv_off << 1 ; \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \"  \n YSCALEYUV2RGB ( % % REGBP , % 5 , % 6 ) \n \" \\n \\t \"  \n WRITEBGR24 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) , \" \" ( uv_off ) \n ) ; \n }", "idx": 26766}
{"project": "FFmpeg", "commit_id": "7620d48f2eab67812d8c535d12a98eaa754a1177", "target": 1, "func": "int avformat_network_init ( void ) \n { \n #if CONFIG_NETWORK  \n  \n  int ret ; \n ff_network_inited_globally = 1 ; \n if ( ( ret = ff_network_init ( ) ) < 0 ) \n return ret ; \n ff_tls_init ( ) ; \n #endif \n return 0 ; \n }", "idx": 26768}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "func": "static mfxIMPL choose_implementation ( const InputStream * ist ) \n { \n static const struct { \n const char * name ; \n mfxIMPL impl ; \n } impl_map [ ] = { \n { \" \" , MFX_IMPL_AUTO } , \n { \" \" , MFX_IMPL_SOFTWARE } , \n { \" \" , MFX_IMPL_HARDWARE } , \n { \" \" , MFX_IMPL_AUTO_ANY } , \n { \" \" , MFX_IMPL_HARDWARE_ANY } , \n { \" \" , MFX_IMPL_HARDWARE2 } , \n { \" \" , MFX_IMPL_HARDWARE3 } , \n { \" \" , MFX_IMPL_HARDWARE4 } , \n } ; \n mfxIMPL impl = MFX_IMPL_AUTO_ANY ; \n int i ; \n if ( ist -> hwaccel_device ) { \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( impl_map ) ; i ++ ) \n if ( ! strcmp ( ist -> hwaccel_device , impl_map [ i ] . name ) ) { \n impl = impl_map [ i ] . impl ; \n break ; \n } \n if ( i == FF_ARRAY_ELEMS ( impl_map ) ) \n impl = strtol ( ist -> hwaccel_device , NULL , 0 ) ; \n } \n return impl ; \n }", "idx": 26785}
{"project": "FFmpeg", "commit_id": "6021615bbe393381f23b34a7cd0dcfd1a42687ba", "target": 0, "func": "static void hscroll ( AVCodecContext * avctx ) \n { \n AnsiContext * s = avctx -> priv_data ; \n int i ; \n if ( s -> y < avctx -> height - s -> font_height ) { \n s -> y += s -> font_height ; \n return ; \n } \n i = 0 ; \n for ( ; i < avctx -> height - s -> font_height ; i ++ ) \n memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , \n s -> frame -> data [ 0 ] + ( i + s -> font_height ) * s -> frame -> linesize [ 0 ] , \n avctx -> width ) ; \n for ( ; i < avctx -> height ; i ++ ) \n memset ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , \n DEFAULT_BG_COLOR , avctx -> width ) ; \n }", "idx": 26812}
{"project": "FFmpeg", "commit_id": "e2afcc33e0bcba92ab6c767f09f17a67911a4928", "target": 0, "func": "static int dxva_get_decoder_guid ( AVCodecContext * avctx , void * service , void * surface_format , \n unsigned guid_count , const GUID * guid_list , GUID * decoder_guid ) \n { \n FFDXVASharedContext * sctx = DXVA_SHARED_CONTEXT ( avctx ) ; \n unsigned i , j ; \n * decoder_guid = ff_GUID_NULL ; \n for ( i = 0 ; dxva_modes [ i ] . guid ; i ++ ) { \n const dxva_mode * mode = & dxva_modes [ i ] ; \n int validate ; \n if ( mode -> codec != avctx -> codec_id ) \n continue ; \n for ( j = 0 ; j < guid_count ; j ++ ) { \n if ( IsEqualGUID ( mode -> guid , & guid_list [ j ] ) ) \n break ; \n } \n if ( j == guid_count ) \n continue ; \n #if CONFIG_D3D11VA  \n  \n  if ( sctx -> pix_fmt == AV_PIX_FMT_D3D11 ) \n validate = d3d11va_validate_output ( service , * mode -> guid , surface_format ) ; \n #endif \n #if CONFIG_DXVA2  \n  \n  if ( sctx -> pix_fmt == AV_PIX_FMT_DXVA2_VLD ) \n validate = dxva2_validate_output ( service , * mode -> guid , surface_format ) ; \n #endif \n if ( validate ) { \n * decoder_guid = * mode -> guid ; \n break ; \n } \n } \n if ( IsEqualGUID ( decoder_guid , & ff_GUID_NULL ) ) { \n av_log ( avctx , AV_LOG_VERBOSE , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( IsEqualGUID ( decoder_guid , & ff_DXVADDI_Intel_ModeH264_E ) ) \n sctx -> workaround |= FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO ; \n return 0 ; \n }", "idx": 26820}
{"project": "FFmpeg", "commit_id": "892fc83e88a20f9543c6c5be3626712be7a2e6f2", "target": 0, "func": "static int vp3_decode_end ( AVCodecContext * avctx ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n av_free ( s -> all_fragments ) ; \n av_free ( s -> coded_fragment_list ) ; \n av_free ( s -> superblock_fragments ) ; \n av_free ( s -> superblock_macroblocks ) ; \n av_free ( s -> macroblock_fragments ) ; \n av_free ( s -> macroblock_coded ) ; \n avctx -> release_buffer ( avctx , & s -> golden_frame ) ; \n avctx -> release_buffer ( avctx , & s -> last_frame ) ; \n avctx -> release_buffer ( avctx , & s -> current_frame ) ; \n return 0 ; \n }", "idx": 26826}
{"project": "FFmpeg", "commit_id": "88d1e2b2b0a129365a62efd666db0394e8ffbe08", "target": 1, "func": "double av_int2dbl ( int64_t v ) { \n if ( v + v > 0xFFEULL << 52 ) \n return NAN ; \n return ldexp ( ( ( v & ( ( 1LL << 52 ) - 1 ) ) + ( 1LL << 52 ) ) * ( v >> 63 | 1 ) , ( v >> 52 & 0x7FF ) - 1075 ) ; \n }", "idx": 26837}
{"project": "FFmpeg", "commit_id": "fecb3e82a4ba09dc11a51ad0961ab491881a53a1", "target": 1, "func": "static inline int mxf_read_utf16_string ( AVIOContext * pb , int size , char * * str , int be ) \n { \n int ret ; \n size_t buf_size ; \n if ( size < 0 ) \n return AVERROR ( EINVAL ) ; \n buf_size = size + size / 2 + 1 ; \n * str = av_malloc ( buf_size ) ; \n if ( ! * str ) \n return AVERROR ( ENOMEM ) ; \n if ( be ) \n ret = avio_get_str16be ( pb , size , * str , buf_size ) ; \n else \n ret = avio_get_str16le ( pb , size , * str , buf_size ) ; \n if ( ret < 0 ) { \n av_freep ( str ) ; \n return ret ; \n } \n return ret ; \n }", "idx": 26838}
{"project": "FFmpeg", "commit_id": "6ba5cbc699e77cae66bb719354fa142114b64eab", "target": 0, "func": "void url_split ( char * proto , int proto_size , \n char * hostname , int hostname_size , \n int * port_ptr , \n char * path , int path_size , \n const char * url ) \n { \n const char * p ; \n char * q ; \n int port ; \n port = -1 ; \n p = url ; \n q = proto ; \n while ( * p != ' ' && * p != ' \\0 ' ) { \n if ( ( q - proto ) < proto_size - 1 ) \n * q ++ = * p ; \n p ++ ; \n } \n if ( proto_size > 0 ) \n * q = ' \\0 ' ; \n if ( * p == ' \\0 ' ) { \n if ( proto_size > 0 ) \n proto [ 0 ] = ' \\0 ' ; \n if ( hostname_size > 0 ) \n hostname [ 0 ] = ' \\0 ' ; \n p = url ; \n } else { \n p ++ ; \n if ( * p == ' ' ) \n p ++ ; \n if ( * p == ' ' ) \n p ++ ; \n q = hostname ; \n while ( * p != ' ' && * p != ' ' && * p != ' ' && * p != ' \\0 ' ) { \n if ( ( q - hostname ) < hostname_size - 1 ) \n * q ++ = * p ; \n p ++ ; \n } \n if ( hostname_size > 0 ) \n * q = ' \\0 ' ; \n if ( * p == ' ' ) { \n p ++ ; \n port = strtoul ( p , ( char * * ) & p , 10 ) ; \n } \n } \n if ( port_ptr ) \n * port_ptr = port ; \n pstrcpy ( path , path_size , p ) ; \n }", "idx": 26842}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static void rtsp_send_cmd_async ( AVFormatContext * s , \n const char * cmd , RTSPMessageHeader * reply , \n unsigned char * * content_ptr ) \n { \n RTSPState * rt = s -> priv_data ; \n char buf [ 4096 ] , buf1 [ 1024 ] ; \n rt -> seq ++ ; \n av_strlcpy ( buf , cmd , sizeof ( buf ) ) ; \n snprintf ( buf1 , sizeof ( buf1 ) , \" \\r \\n \" , rt -> seq ) ; \n av_strlcat ( buf , buf1 , sizeof ( buf ) ) ; \n if ( rt -> session_id [ 0 ] != ' \\0 ' && ! strstr ( cmd , \" \\n \" ) ) { \n snprintf ( buf1 , sizeof ( buf1 ) , \" \\r \\n \" , rt -> session_id ) ; \n av_strlcat ( buf , buf1 , sizeof ( buf ) ) ; \n } \n if ( rt -> auth_b64 ) \n av_strlcatf ( buf , sizeof ( buf ) , \n \" \\r \\n \" , \n rt -> auth_b64 ) ; \n av_strlcat ( buf , \" \\r \\n \" , sizeof ( buf ) ) ; \n dprintf ( s , \" \\n \\n \" , buf ) ; \n url_write ( rt -> rtsp_hd , buf , strlen ( buf ) ) ; \n rt -> last_cmd_time = av_gettime ( ) ; \n }", "idx": 26844}
{"project": "FFmpeg", "commit_id": "87ecefdab0097537c5c30014e57b19113ab05eee", "target": 1, "func": "static int get_high_utility_cell ( elbg_data * elbg ) \n { \n int i = 0 ; \n int r = av_lfg_get ( elbg -> rand_state ) % elbg -> utility_inc [ elbg -> numCB - 1 ] + 1 ; \n while ( elbg -> utility_inc [ i ] < r ) \n i ++ ; \n av_assert2 ( elbg -> cells [ i ] ) ; \n return i ; \n }", "idx": 26846}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void ff_jref_idct1_put ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n dest [ 0 ] = cm [ ( block [ 0 ] + 4 ) >> 3 ] ; \n }", "idx": 26849}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int v410_encode_close ( AVCodecContext * avctx ) \n { \n av_freep ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 26851}
{"project": "FFmpeg", "commit_id": "3f98848d6e04a11f28e776b665fb14e58d56e015", "target": 0, "func": "static int au_read_header ( AVFormatContext * s ) \n { \n int size ; \n unsigned int tag ; \n AVIOContext * pb = s -> pb ; \n unsigned int id , channels , rate ; \n enum AVCodecID codec ; \n AVStream * st ; \n tag = avio_rl32 ( pb ) ; \n if ( tag != MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) \n return -1 ; \n size = avio_rb32 ( pb ) ; \n avio_rb32 ( pb ) ; \n id = avio_rb32 ( pb ) ; \n rate = avio_rb32 ( pb ) ; \n channels = avio_rb32 ( pb ) ; \n codec = ff_codec_get_id ( codec_au_tags , id ) ; \n if ( ! av_get_bits_per_sample ( codec ) ) { \n av_log_ask_for_sample ( s , \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n if ( channels == 0 || channels > 64 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" , channels ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( size >= 24 ) { \n avio_skip ( pb , size - 24 ) ; \n } \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return -1 ; \n st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; \n st -> codec -> codec_tag = id ; \n st -> codec -> codec_id = codec ; \n st -> codec -> channels = channels ; \n st -> codec -> sample_rate = rate ; \n avpriv_set_pts_info ( st , 64 , 1 , rate ) ; \n return 0 ; \n }", "idx": 26853}
{"project": "FFmpeg", "commit_id": "258dfff8394d383beaa639d19912b3f068f67e16", "target": 1, "func": "void av_log_format_line ( void * ptr , int level , const char * fmt , va_list vl , \n char * line , int line_size , int * print_prefix ) \n { \n char part [ 3 ] [ 512 ] ; \n format_line ( ptr , level , fmt , vl , part , sizeof ( part [ 0 ] ) , print_prefix , NULL ) ; \n snprintf ( line , line_size , \" \" , part [ 0 ] , part [ 1 ] , part [ 2 ] ) ; \n }", "idx": 26867}
{"project": "FFmpeg", "commit_id": "89505f2c3f8ee1b0b68fc220a226c8bf3cef24cd", "target": 0, "func": "static int init_filter_param ( AVFilterContext * ctx , FilterParam * fp , const char * effect_type , int width ) \n { \n int z ; \n const char * effect = fp -> amount == 0 ? \" \" : fp -> amount < 0 ? \" \" : \" \" ; \n if ( ! ( fp -> msize_x & fp -> msize_y & 1 ) ) { \n av_log ( ctx , AV_LOG_ERROR , \n \" \\n \" , \n effect_type , fp -> msize_x , fp -> msize_y ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , \n effect , effect_type , fp -> msize_x , fp -> msize_y , fp -> amount / 65535.0 ) ; \n for ( z = 0 ; z < 2 * fp -> steps_y ; z ++ ) \n fp -> sc [ z ] = av_malloc ( sizeof ( * ( fp -> sc [ z ] ) ) * ( width + 2 * fp -> steps_x ) ) ; \n return 0 ; \n }", "idx": 26899}
{"project": "FFmpeg", "commit_id": "f8cab062caacba2982a0d0bccd504b11c073caf6", "target": 0, "func": "static int process_ea_header ( AVFormatContext * s ) { \n uint32_t blockid , size = 0 ; \n EaDemuxContext * ea = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n blockid = get_le32 ( pb ) ; \n if ( blockid == MVhd_TAG ) { \n size = get_le32 ( pb ) ; \n process_video_header_vp6 ( s ) ; \n url_fskip ( pb , size - 32 ) ; \n blockid = get_le32 ( pb ) ; \n } \n if ( blockid != SCHl_TAG ) \n return 0 ; \n size += get_le32 ( pb ) ; \n blockid = get_le32 ( pb ) ; \n if ( blockid == GSTR_TAG ) { \n url_fskip ( pb , 4 ) ; \n } else if ( blockid != PT00_TAG ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n process_audio_header_elements ( s ) ; \n url_fseek ( pb , size , SEEK_SET ) ; \n return 1 ; \n }", "idx": 26910}
{"project": "FFmpeg", "commit_id": "daece4c6745b42e8b1e171fb4bf485d5d64fc53f", "target": 0, "func": "static void check_external_clock_sync ( VideoState * is , double pts ) { \n if ( fabs ( get_external_clock ( is ) - pts ) > AV_NOSYNC_THRESHOLD ) { \n update_external_clock_pts ( is , pts ) ; \n } \n }", "idx": 26911}
{"project": "FFmpeg", "commit_id": "574929d8b6de32ae712fcca7ab09f01a3e4616be", "target": 1, "func": "int av_packet_add_side_data ( AVPacket * pkt , enum AVPacketSideDataType type , \n uint8_t * data , size_t size ) \n { \n int elems = pkt -> side_data_elems ; \n if ( ( unsigned ) elems + 1 > INT_MAX / sizeof ( * pkt -> side_data ) ) \n return AVERROR ( ERANGE ) ; \n pkt -> side_data = av_realloc ( pkt -> side_data , \n ( elems + 1 ) * sizeof ( * pkt -> side_data ) ) ; \n if ( ! pkt -> side_data ) \n return AVERROR ( ENOMEM ) ; \n pkt -> side_data [ elems ] . data = data ; \n pkt -> side_data [ elems ] . size = size ; \n pkt -> side_data [ elems ] . type = type ; \n pkt -> side_data_elems ++ ; \n return 0 ; \n }", "idx": 26917}
{"project": "FFmpeg", "commit_id": "22cc57da64bfd73f2206969486b0aa183ee76479", "target": 1, "func": "static void enqueue_packet ( RTPDemuxContext * s , uint8_t * buf , int len ) \n { \n uint16_t seq = AV_RB16 ( buf + 2 ) ; \n RTPPacket * * cur = & s -> queue , * packet ; \n while ( * cur ) { \n int16_t diff = seq - ( * cur ) -> seq ; \n if ( diff < 0 ) \n break ; \n cur = & ( * cur ) -> next ; \n } \n packet = av_mallocz ( sizeof ( * packet ) ) ; \n if ( ! packet ) \n return ; \n packet -> recvtime = av_gettime_relative ( ) ; \n packet -> seq = seq ; \n packet -> len = len ; \n packet -> buf = buf ; \n packet -> next = * cur ; \n * cur = packet ; \n s -> queue_len ++ ; \n }", "idx": 26926}
{"project": "FFmpeg", "commit_id": "802713c4e7b41bc2deed754d78649945c3442063", "target": 1, "func": "static av_cold int mss2_decode_init ( AVCodecContext * avctx ) \n { \n MSS2Context * const ctx = avctx -> priv_data ; \n MSS12Context * c = & ctx -> c ; \n int ret ; \n c -> avctx = avctx ; \n avctx -> coded_frame = & ctx -> pic ; \n if ( ret = ff_mss12_decode_init ( c , 1 , & ctx -> sc [ 0 ] , & ctx -> sc [ 1 ] ) ) \n return ret ; \n c -> pal_stride = c -> mask_stride ; \n c -> pal_pic = av_malloc ( c -> pal_stride * avctx -> height ) ; \n c -> last_pal_pic = av_malloc ( c -> pal_stride * avctx -> height ) ; \n if ( ! c -> pal_pic || ! c -> last_pal_pic ) { \n mss2_decode_end ( avctx ) ; \n return AVERROR ( ENOMEM ) ; \n } \n if ( ret = wmv9_init ( avctx ) ) { \n mss2_decode_end ( avctx ) ; \n return ret ; \n } \n ff_mss2dsp_init ( & ctx -> dsp ) ; \n avctx -> pix_fmt = c -> free_colours == 127 ? AV_PIX_FMT_RGB555 \n : AV_PIX_FMT_RGB24 ; \n return 0 ; \n }", "idx": 26928}
{"project": "FFmpeg", "commit_id": "25e3e53d4092e7b69a4d681824fa0f7b2731bb1e", "target": 1, "func": "static void build_file_streams ( void ) \n { \n FFStream * stream , * stream_next ; \n AVFormatContext * infile ; \n int i ; \n for ( stream = first_stream ; stream != NULL ; stream = stream_next ) { \n stream_next = stream -> next ; \n if ( stream -> stream_type == STREAM_TYPE_LIVE && \n ! stream -> feed ) { \n stream -> ap_in = av_mallocz ( sizeof ( AVFormatParameters ) ) ; \n if ( ! strcmp ( stream -> fmt -> name , \" \" ) ) { \n stream -> ap_in -> mpeg2ts_raw = 1 ; \n stream -> ap_in -> mpeg2ts_compute_pcr = 1 ; \n } \n if ( av_open_input_file ( & infile , stream -> feed_filename , \n stream -> ifmt , 0 , stream -> ap_in ) < 0 ) { \n http_log ( \" \" , stream -> feed_filename ) ; \n fail : \n remove_stream ( stream ) ; \n } else { \n if ( av_find_stream_info ( infile ) < 0 ) { \n http_log ( \" \" , \n stream -> feed_filename ) ; \n av_close_input_file ( infile ) ; \n goto fail ; \n } \n extract_mpeg4_header ( infile ) ; \n for ( i = 0 ; i < infile -> nb_streams ; i ++ ) \n add_av_stream1 ( stream , infile -> streams [ i ] -> codec ) ; \n av_close_input_file ( infile ) ; \n } \n } \n } \n }", "idx": 26929}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int png_write_row ( PNGContext * s , const uint8_t * data , int size ) \n { \n int ret ; \n s -> zstream . avail_in = size ; \n s -> zstream . next_in = ( uint8_t * ) data ; \n while ( s -> zstream . avail_in > 0 ) { \n ret = deflate ( & s -> zstream , Z_NO_FLUSH ) ; \n if ( ret != Z_OK ) \n return -1 ; \n if ( s -> zstream . avail_out == 0 ) { \n png_write_chunk ( & s -> bytestream , MKTAG ( ' ' , ' ' , ' ' , ' ' ) , s -> buf , IOBUF_SIZE ) ; \n s -> zstream . avail_out = IOBUF_SIZE ; \n s -> zstream . next_out = s -> buf ; \n } \n } \n return 0 ; \n }", "idx": 26981}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred4x4_127_dc ) ( uint8_t * _src , const uint8_t * topright , int _stride ) { \n pixel * src = ( pixel * ) _src ; \n int stride = _stride / sizeof ( pixel ) ; \n ( ( pixel4 * ) ( src + 0 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 1 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 2 * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + 3 * stride ) ) [ 0 ] = PIXEL_SPLAT_X4 ( ( 1 << ( BIT_DEPTH - 1 ) ) - 1 ) ; \n }", "idx": 26985}
{"project": "FFmpeg", "commit_id": "2bfa067d0b636e7b2004fb0ad5a53d0d48c6de32", "target": 1, "func": "av_cold int ff_vaapi_encode_close ( AVCodecContext * avctx ) \n { \n VAAPIEncodeContext * ctx = avctx -> priv_data ; \n VAAPIEncodePicture * pic , * next ; \n for ( pic = ctx -> pic_start ; pic ; pic = next ) { \n next = pic -> next ; \n vaapi_encode_free ( avctx , pic ) ; \n } \n if ( ctx -> va_context != VA_INVALID_ID ) \n vaDestroyContext ( ctx -> hwctx -> display , ctx -> va_context ) ; \n if ( ctx -> va_config != VA_INVALID_ID ) \n vaDestroyConfig ( ctx -> hwctx -> display , ctx -> va_config ) ; \n if ( ctx -> codec -> close ) \n ctx -> codec -> close ( avctx ) ; \n av_freep ( & ctx -> codec_sequence_params ) ; \n av_freep ( & ctx -> codec_picture_params ) ; \n av_buffer_unref ( & ctx -> recon_frames_ref ) ; \n av_buffer_unref ( & ctx -> input_frames_ref ) ; \n av_buffer_unref ( & ctx -> device_ref ) ; \n av_freep ( & ctx -> priv_data ) ; \n return 0 ; \n }", "idx": 26986}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int trim_filter_frame ( AVFilterLink * inlink , AVFrame * frame ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n TrimContext * s = ctx -> priv ; \n int drop ; \n if ( s -> eof ) { \n av_frame_free ( & frame ) ; \n return 0 ; \n } \n if ( s -> start_frame >= 0 || s -> start_pts != AV_NOPTS_VALUE ) { \n drop = 1 ; \n if ( s -> start_frame >= 0 && s -> nb_frames >= s -> start_frame ) \n drop = 0 ; \n if ( s -> start_pts != AV_NOPTS_VALUE && frame -> pts != AV_NOPTS_VALUE && \n frame -> pts >= s -> start_pts ) \n drop = 0 ; \n if ( drop ) \n goto drop ; \n } \n if ( s -> first_pts == AV_NOPTS_VALUE && frame -> pts != AV_NOPTS_VALUE ) \n s -> first_pts = frame -> pts ; \n if ( s -> end_frame != INT64_MAX || s -> end_pts != AV_NOPTS_VALUE || s -> duration_tb ) { \n drop = 1 ; \n if ( s -> end_frame != INT64_MAX && s -> nb_frames < s -> end_frame ) \n drop = 0 ; \n if ( s -> end_pts != AV_NOPTS_VALUE && frame -> pts != AV_NOPTS_VALUE && \n frame -> pts < s -> end_pts ) \n drop = 0 ; \n if ( s -> duration_tb && frame -> pts != AV_NOPTS_VALUE && \n frame -> pts - s -> first_pts < s -> duration_tb ) \n drop = 0 ; \n if ( drop ) { \n s -> eof = 1 ; \n goto drop ; \n } \n } \n s -> nb_frames ++ ; \n s -> got_output = 1 ; \n return ff_filter_frame ( ctx -> outputs [ 0 ] , frame ) ; \n drop : \n s -> nb_frames ++ ; \n av_frame_free ( & frame ) ; \n return 0 ; \n }", "idx": 26989}
{"project": "FFmpeg", "commit_id": "43abef9fde0cf87153cc9031cad61f75b02cfa01", "target": 0, "func": "static int read_line ( AVIOContext * pb , char * line , int bufsize ) \n { \n int i ; \n for ( i = 0 ; i < bufsize - 1 ; i ++ ) { \n int b = avio_r8 ( pb ) ; \n if ( b == 0 ) \n break ; \n if ( b == ' \\n ' ) { \n line [ i ] = ' \\0 ' ; \n return 0 ; \n } \n line [ i ] = b ; \n } \n line [ i ] = ' \\0 ' ; \n return -1 ; \n }", "idx": 26991}
{"project": "FFmpeg", "commit_id": "0a39c9ac0bfd7345fe676b4e2707d9cec3cbb553", "target": 0, "func": "av_cold void ff_hpeldsp_vp3_init_x86 ( HpelDSPContext * c , int cpu_flags , int flags ) \n { \n if ( EXTERNAL_AMD3DNOW ( cpu_flags ) ) { \n if ( flags & AV_CODEC_FLAG_BITEXACT ) { \n c -> put_no_rnd_pixels_tab [ 1 ] [ 1 ] = ff_put_no_rnd_pixels8_x2_exact_3dnow ; \n c -> put_no_rnd_pixels_tab [ 1 ] [ 2 ] = ff_put_no_rnd_pixels8_y2_exact_3dnow ; \n } \n } \n if ( EXTERNAL_MMXEXT ( cpu_flags ) ) { \n if ( flags & AV_CODEC_FLAG_BITEXACT ) { \n c -> put_no_rnd_pixels_tab [ 1 ] [ 1 ] = ff_put_no_rnd_pixels8_x2_exact_mmxext ; \n c -> put_no_rnd_pixels_tab [ 1 ] [ 2 ] = ff_put_no_rnd_pixels8_y2_exact_mmxext ; \n } \n } \n }", "idx": 27005}
{"project": "FFmpeg", "commit_id": "205046420d5a4d389adb705538df3d6158be1fdb", "target": 0, "func": "static int expand ( AVFilterContext * ctx , double * pz , int nb , double * coeffs ) \n { \n int i ; \n coeffs [ 0 ] = 1.0 ; \n coeffs [ 1 ] = 0.0 ; \n for ( i = 0 ; i < nb ; i ++ ) { \n coeffs [ 2 * ( i + 1 ) ] = 0.0 ; \n coeffs [ 2 * ( i + 1 ) + 1 ] = 0.0 ; \n } \n for ( i = 0 ; i < nb ; i ++ ) \n multiply ( pz [ 2 * i ] , pz [ 2 * i + 1 ] , nb , coeffs ) ; \n for ( i = 0 ; i < nb + 1 ; i ++ ) { \n if ( fabs ( coeffs [ 2 * i + 1 ] ) > DBL_EPSILON ) { \n av_log ( ctx , AV_LOG_ERROR , \" \\n \" , \n coeffs [ 2 * i + i ] , i ) ; \n return AVERROR ( EINVAL ) ; \n } \n } \n return 0 ; \n }", "idx": 27016}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int64_t ffm_seek1 ( AVFormatContext * s , int64_t pos1 ) \n { \n FFMContext * ffm = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int64_t pos ; \n pos = FFMIN ( pos1 , ffm -> file_size - FFM_PACKET_SIZE ) ; \n pos = FFMAX ( pos , FFM_PACKET_SIZE ) ; \n av_dlog ( s , \" \" PRIx64 \" \" PRIx64 \" \\n \" , pos1 , pos ) ; \n return avio_seek ( pb , pos , SEEK_SET ) ; \n }", "idx": 27018}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "func": "static int raw_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n AVStream * st ; \n int id ; \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR_NOMEM ; \n if ( ap ) { \n id = s -> iformat -> value ; \n if ( id == CODEC_ID_RAWVIDEO ) { \n st -> codec -> codec_type = CODEC_TYPE_VIDEO ; \n } else { \n st -> codec -> codec_type = CODEC_TYPE_AUDIO ; \n } \n st -> codec -> codec_id = id ; \n switch ( st -> codec -> codec_type ) { \n case CODEC_TYPE_AUDIO : \n st -> codec -> sample_rate = ap -> sample_rate ; \n st -> codec -> channels = ap -> channels ; \n av_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n break ; \n case CODEC_TYPE_VIDEO : \n av_set_pts_info ( st , 64 , ap -> time_base . num , ap -> time_base . den ) ; \n st -> codec -> width = ap -> width ; \n st -> codec -> height = ap -> height ; \n st -> codec -> pix_fmt = ap -> pix_fmt ; \n if ( st -> codec -> pix_fmt == PIX_FMT_NONE ) \n st -> codec -> pix_fmt = PIX_FMT_YUV420P ; \n break ; \n default : \n return -1 ; \n } \n } else { \n return -1 ; \n } \n return 0 ; \n }", "idx": 27019}
{"project": "FFmpeg", "commit_id": "a8a6da4a0e059b2aab66627a96b63c3632c477c2", "target": 1, "func": "static av_cold int twin_decode_close ( AVCodecContext * avctx ) \n { \n TwinContext * tctx = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n ff_mdct_end ( & tctx -> mdct_ctx [ i ] ) ; \n av_free ( tctx -> cos_tabs [ i ] ) ; \n } \n av_free ( tctx -> curr_frame ) ; \n av_free ( tctx -> spectrum ) ; \n av_free ( tctx -> prev_frame ) ; \n av_free ( tctx -> tmp_buf ) ; \n return 0 ; \n }", "idx": 27022}
{"project": "FFmpeg", "commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "target": 1, "func": "static int asf_read_seek ( AVFormatContext * s , int stream_index , \n int64_t pts , int flags ) \n { \n ASFContext * asf = s -> priv_data ; \n AVStream * st = s -> streams [ stream_index ] ; \n int64_t pos ; \n int index ; \n if ( s -> packet_size <= 0 ) \n return -1 ; \n if ( s -> pb ) { \n int ret = avio_seek_time ( s -> pb , stream_index , pts , flags ) ; \n if ( ret >= 0 ) \n asf_reset_header ( s ) ; \n if ( ret != AVERROR ( ENOSYS ) ) \n return ret ; \n } \n if ( ! asf -> index_read ) \n asf_build_simple_index ( s , stream_index ) ; \n if ( ( asf -> index_read && st -> index_entries ) ) { \n index = av_index_search_timestamp ( st , pts , flags ) ; \n if ( index >= 0 ) { \n pos = st -> index_entries [ index ] . pos ; \n av_log ( s , AV_LOG_DEBUG , \" \" PRId64 \" \\n \" , pos ) ; \n avio_seek ( s -> pb , pos , SEEK_SET ) ; \n asf_reset_header ( s ) ; \n return 0 ; \n } \n } \n if ( ff_seek_frame_binary ( s , stream_index , pts , flags ) < 0 ) \n return -1 ; \n asf_reset_header ( s ) ; \n return 0 ; \n }", "idx": 27028}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_mpeg_unref_picture ( MpegEncContext * s , Picture * pic ) \n { \n int off = offsetof ( Picture , mb_mean ) + sizeof ( pic -> mb_mean ) ; \n pic -> tf . f = & pic -> f ; \n if ( s -> codec_id != AV_CODEC_ID_WMV3IMAGE && \n s -> codec_id != AV_CODEC_ID_VC1IMAGE && \n s -> codec_id != AV_CODEC_ID_MSS2 ) \n ff_thread_release_buffer ( s -> avctx , & pic -> tf ) ; \n else \n av_frame_unref ( & pic -> f ) ; \n av_buffer_unref ( & pic -> hwaccel_priv_buf ) ; \n if ( pic -> needs_realloc ) \n ff_free_picture_tables ( pic ) ; \n memset ( ( uint8_t * ) pic + off , 0 , sizeof ( * pic ) - off ) ; \n }", "idx": 27029}
{"project": "FFmpeg", "commit_id": "de6c150444159a26fe2555089d384ddd2d6459aa", "target": 1, "func": "int64_t ff_lsb2full ( StreamContext * stream , int64_t lsb ) { \n int64_t mask = ( 1 << stream -> msb_pts_shift ) - 1 ; \n int64_t delta = stream -> last_pts - mask / 2 ; \n return ( ( lsb - delta ) & mask ) + delta ; \n }", "idx": 27033}
{"project": "FFmpeg", "commit_id": "324ff59444ff5470bb325ff1e2be7c4b054fc944", "target": 0, "func": "int ff_audio_rechunk_interleave ( AVFormatContext * s , AVPacket * out , AVPacket * pkt , int flush , \n int ( * get_packet ) ( AVFormatContext * , AVPacket * , AVPacket * , int ) , \n int ( * compare_ts ) ( AVFormatContext * , AVPacket * , AVPacket * ) ) \n { \n int i ; \n if ( pkt ) { \n AVStream * st = s -> streams [ pkt -> stream_index ] ; \n AudioInterleaveContext * aic = st -> priv_data ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n unsigned new_size = av_fifo_size ( aic -> fifo ) + pkt -> size ; \n if ( new_size > aic -> fifo_size ) { \n if ( av_fifo_realloc2 ( aic -> fifo , new_size ) < 0 ) \n return -1 ; \n aic -> fifo_size = new_size ; \n } \n av_fifo_generic_write ( aic -> fifo , pkt -> data , pkt -> size , NULL ) ; \n } else { \n pkt -> pts = pkt -> dts = aic -> dts ; \n aic -> dts += pkt -> duration ; \n ff_interleave_add_packet ( s , pkt , compare_ts ) ; \n } \n pkt = NULL ; \n } \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) { \n AVPacket new_pkt ; \n while ( interleave_new_audio_packet ( s , & new_pkt , i , flush ) ) \n ff_interleave_add_packet ( s , & new_pkt , compare_ts ) ; \n } \n } \n return get_packet ( s , out , NULL , flush ) ; \n }", "idx": 27041}
{"project": "FFmpeg", "commit_id": "d150a147dac67faeaf6b1f25a523ae330168ee1e", "target": 0, "func": "static av_cold int init_decoder ( AVCodecContext * avctx ) \n { \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n return 0 ; \n }", "idx": 27042}
{"project": "FFmpeg", "commit_id": "140f48b90fbe32a88423aad473bccc72c3bb450e", "target": 0, "func": "static int smc_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n SmcContext * s = avctx -> priv_data ; \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n int ret ; \n bytestream2_init ( & s -> gb , buf , buf_size ) ; \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) \n return ret ; \n if ( pal ) { \n s -> frame -> palette_has_changed = 1 ; \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n } \n smc_decode_stream ( s ) ; \n * got_frame = 1 ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n return buf_size ; \n }", "idx": 27051}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static void parse_palette_segment ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size ) \n { \n PGSSubContext * ctx = avctx -> priv_data ; \n const uint8_t * buf_end = buf + buf_size ; \n const uint8_t * cm = ff_crop_tab + MAX_NEG_CROP ; \n int color_id ; \n int y , cb , cr , alpha ; \n int r , g , b , r_add , g_add , b_add ; \n buf += 2 ; \n while ( buf < buf_end ) { \n color_id = bytestream_get_byte ( & buf ) ; \n y = bytestream_get_byte ( & buf ) ; \n cr = bytestream_get_byte ( & buf ) ; \n cb = bytestream_get_byte ( & buf ) ; \n alpha = bytestream_get_byte ( & buf ) ; \n YUV_TO_RGB1 ( cb , cr ) ; \n YUV_TO_RGB2 ( r , g , b , y ) ; \n av_dlog ( avctx , \" \\n \" , color_id , r , g , b , alpha ) ; \n ctx -> clut [ color_id ] = RGBA ( r , g , b , alpha ) ; \n } \n }", "idx": 27064}
{"project": "FFmpeg", "commit_id": "fc11927890f38445a950b453d24928525da0e61a", "target": 0, "func": "void * av_realloc ( void * ptr , size_t size ) \n { \n #if CONFIG_MEMALIGN_HACK  \n  \n  int diff ; \n #endif \n if ( size > ( MAX_MALLOC_SIZE - 16 ) ) \n return NULL ; \n #if CONFIG_MEMALIGN_HACK  \n  \n  \n  if ( ! ptr ) return av_malloc ( size ) ; \n diff = ( ( char * ) ptr ) [ -1 ] ; \n return ( char * ) realloc ( ( char * ) ptr - diff , size + diff ) + diff ; \n #else \n return realloc ( ptr , size + ! size ) ; \n #endif \n }", "idx": 27066}
{"project": "FFmpeg", "commit_id": "6184fa2067ccf88e68a7009442cf01440e59d99c", "target": 0, "func": "static av_cold int raw_close_decoder ( AVCodecContext * avctx ) \n { \n RawVideoContext * context = avctx -> priv_data ; \n av_freep ( & context -> buffer ) ; \n return 0 ; \n }", "idx": 27068}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb32tobgr24 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 2 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n #ifdef WORDS_BIGENDIAN \n dst [ 3 * i + 0 ] = src [ 4 * i + 1 ] ; \n dst [ 3 * i + 1 ] = src [ 4 * i + 2 ] ; \n dst [ 3 * i + 2 ] = src [ 4 * i + 3 ] ; \n #else \n dst [ 3 * i + 0 ] = src [ 4 * i + 2 ] ; \n dst [ 3 * i + 1 ] = src [ 4 * i + 1 ] ; \n dst [ 3 * i + 2 ] = src [ 4 * i + 0 ] ; \n #endif \n } \n }", "idx": 27076}
{"project": "FFmpeg", "commit_id": "7c2fa13df9a6130b3f258c7513933cbdca2fe23b", "target": 1, "func": "static int oma_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n OMAContext * oc = s -> priv_data ; \n AVStream * st = s -> streams [ 0 ] ; \n int packet_size = st -> codec -> block_align ; \n int byte_rate = st -> codec -> bit_rate >> 3 ; \n int64_t pos = avio_tell ( s -> pb ) ; \n int ret = av_get_packet ( s -> pb , pkt , packet_size ) ; \n if ( ret < packet_size ) \n pkt -> flags |= AV_PKT_FLAG_CORRUPT ; \n if ( ret < 0 ) \n return ret ; \n if ( ! ret ) \n return AVERROR_EOF ; \n pkt -> stream_index = 0 ; \n if ( pos > 0 ) { \n pkt -> pts = \n pkt -> dts = av_rescale ( pos , st -> time_base . den , \n byte_rate * ( int64_t ) st -> time_base . num ) ; \n } \n if ( oc -> encrypted ) { \n if ( ret == packet_size ) \n av_des_crypt ( & oc -> av_des , pkt -> data , pkt -> data , \n ( packet_size >> 3 ) , oc -> iv , 1 ) ; \n else \n memset ( oc -> iv , 0 , 8 ) ; \n } \n return ret ; \n }", "idx": 27117}
{"project": "FFmpeg", "commit_id": "08d0969c1402ccec4dce44bd430128fb59d7b790", "target": 0, "func": "void av_opt_set_defaults2 ( void * s , int mask , int flags ) \n { \n #endif  \n  \n  const AVOption * opt = NULL ; \n while ( ( opt = av_opt_next ( s , opt ) ) != NULL ) { \n #if FF_API_OLD_AVOPTIONS  \n  \n  if ( ( opt -> flags & mask ) != flags ) \n continue ; \n #endif \n switch ( opt -> type ) { \n case AV_OPT_TYPE_CONST : \n break ; \n case AV_OPT_TYPE_FLAGS : \n case AV_OPT_TYPE_INT : \n case AV_OPT_TYPE_INT64 : \n av_opt_set_int ( s , opt -> name , opt -> default_val . i64 , 0 ) ; \n break ; \n case AV_OPT_TYPE_DOUBLE : \n case AV_OPT_TYPE_FLOAT : { \n double val ; \n val = opt -> default_val . dbl ; \n av_opt_set_double ( s , opt -> name , val , 0 ) ; \n } \n break ; \n case AV_OPT_TYPE_RATIONAL : { \n AVRational val ; \n val = av_d2q ( opt -> default_val . dbl , INT_MAX ) ; \n av_opt_set_q ( s , opt -> name , val , 0 ) ; \n } \n break ; \n case AV_OPT_TYPE_STRING : \n case AV_OPT_TYPE_IMAGE_SIZE : \n case AV_OPT_TYPE_PIXEL_FMT : \n case AV_OPT_TYPE_SAMPLE_FMT : \n av_opt_set ( s , opt -> name , opt -> default_val . str , 0 ) ; \n break ; \n case AV_OPT_TYPE_BINARY : \n break ; \n default : \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , opt -> type , opt -> name ) ; \n } \n } \n }", "idx": 27118}
{"project": "FFmpeg", "commit_id": "65e33d8e23277bb96809842656482e0e3fe8746f", "target": 1, "func": "static int RENAME ( resample_common ) ( ResampleContext * c , \n void * dest , const void * source , \n int n , int update_ctx ) \n { \n DELEM * dst = dest ; \n const DELEM * src = source ; \n int dst_index ; \n int index = c -> index ; \n int frac = c -> frac ; \n int sample_index = 0 ; \n while ( index >= c -> phase_count ) { \n sample_index ++ ; \n index -= c -> phase_count ; \n } \n for ( dst_index = 0 ; dst_index < n ; dst_index ++ ) { \n FELEM * filter = ( ( FELEM * ) c -> filter_bank ) + c -> filter_alloc * index ; \n FELEM2 val = FOFFSET ; \n int i ; \n for ( i = 0 ; i < c -> filter_length ; i ++ ) { \n val += src [ sample_index + i ] * ( FELEM2 ) filter [ i ] ; \n } \n OUT ( dst [ dst_index ] , val ) ; \n frac += c -> dst_incr_mod ; \n index += c -> dst_incr_div ; \n if ( frac >= c -> src_incr ) { \n frac -= c -> src_incr ; \n index ++ ; \n } \n while ( index >= c -> phase_count ) { \n sample_index ++ ; \n index -= c -> phase_count ; \n } \n } \n if ( update_ctx ) { \n c -> frac = frac ; \n c -> index = index ; \n } \n return sample_index ; \n }", "idx": 27119}
{"project": "FFmpeg", "commit_id": "4c439f6e3999ae534991ecde943e45b00c80b8d2", "target": 1, "func": "static int idcin_probe ( AVProbeData * p ) \n { \n unsigned int number , sample_rate ; \n if ( p -> buf_size < 20 ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 0 ] ) ; \n if ( ( number == 0 ) || ( number > 1024 ) ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 4 ] ) ; \n if ( ( number == 0 ) || ( number > 1024 ) ) \n return 0 ; \n sample_rate = AV_RL32 ( & p -> buf [ 8 ] ) ; \n if ( sample_rate && ( sample_rate < 8000 || sample_rate > 48000 ) ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 12 ] ) ; \n if ( number > 2 || sample_rate && ! number ) \n return 0 ; \n number = AV_RL32 ( & p -> buf [ 16 ] ) ; \n if ( number > 2 || sample_rate && ! number ) \n return 0 ; \n return AVPROBE_SCORE_EXTENSION ; \n }", "idx": 27136}
{"project": "FFmpeg", "commit_id": "9f0eaf792a8560a089643489403e549c30fb3170", "target": 0, "func": "static inline int hpel_motion ( MpegEncContext * s , \n uint8_t * dest , uint8_t * src , \n int src_x , int src_y , \n op_pixels_func * pix_op , \n int motion_x , int motion_y ) \n { \n int dxy = 0 ; \n int emu = 0 ; \n src_x += motion_x >> 1 ; \n src_y += motion_y >> 1 ; \n src_x = av_clip ( src_x , -16 , s -> width ) ; \n if ( src_x != s -> width ) \n dxy |= motion_x & 1 ; \n src_y = av_clip ( src_y , -16 , s -> height ) ; \n if ( src_y != s -> height ) \n dxy |= ( motion_y & 1 ) << 1 ; \n src += src_y * s -> linesize + src_x ; \n if ( ( unsigned ) src_x > FFMAX ( s -> h_edge_pos - ( motion_x & 1 ) - 8 , 0 ) || \n ( unsigned ) src_y > FFMAX ( s -> v_edge_pos - ( motion_y & 1 ) - 8 , 0 ) ) { \n s -> vdsp . emulated_edge_mc ( s -> edge_emu_buffer , src , \n s -> linesize , s -> linesize , \n 9 , 9 , \n src_x , src_y , \n s -> h_edge_pos , s -> v_edge_pos ) ; \n src = s -> edge_emu_buffer ; \n emu = 1 ; \n } \n pix_op [ dxy ] ( dest , src , s -> linesize , 8 ) ; \n return emu ; \n }", "idx": 27138}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_dualmono_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += samples [ i + 256 ] ; \n samples [ i + 256 ] = 0 ; \n } \n }", "idx": 27139}
{"project": "FFmpeg", "commit_id": "6892d145a0c80249bd61ee7dd31ec851c5076bcd", "target": 1, "func": "static int film_read_close ( AVFormatContext * s ) \n { \n FilmDemuxContext * film = s -> priv_data ; \n av_free ( film -> sample_table ) ; \n av_free ( film -> stereo_buffer ) ; \n return 0 ; \n }", "idx": 27141}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static av_cold int libschroedinger_decode_init ( AVCodecContext * avctx ) \n { \n SchroDecoderParams * p_schro_params = avctx -> priv_data ; \n schro_init ( ) ; \n schro_debug_set_level ( avctx -> debug ) ; \n p_schro_params -> decoder = schro_decoder_new ( ) ; \n schro_decoder_set_skip_ratio ( p_schro_params -> decoder , 1 ) ; \n if ( ! p_schro_params -> decoder ) \n return -1 ; \n ff_schro_queue_init ( & p_schro_params -> dec_frame_queue ) ; \n return 0 ; \n }", "idx": 27143}
{"project": "FFmpeg", "commit_id": "7444cf9a9c0b8b2bba8198af2823521c654a48f4", "target": 1, "func": "static int imc_decode_frame ( AVCodecContext * avctx , void * data , \n int * got_frame_ptr , AVPacket * avpkt ) \n { \n AVFrame * frame = data ; \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n int ret , i ; \n IMCContext * q = avctx -> priv_data ; \n LOCAL_ALIGNED_16 ( uint16_t , buf16 ,  [ IMC_BLOCK_SIZE / 2 ] ) ; \n if ( buf_size < IMC_BLOCK_SIZE * avctx -> channels ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n frame -> nb_samples = COEFFS ; \n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < avctx -> channels ; i ++ ) { \n q -> out_samples = ( float * ) frame -> extended_data [ i ] ; \n q -> bdsp . bswap16_buf ( buf16 , ( const uint16_t * ) buf , IMC_BLOCK_SIZE / 2 ) ; \n init_get_bits ( & q -> gb , ( const uint8_t * ) buf16 , IMC_BLOCK_SIZE * 8 ) ; \n buf += IMC_BLOCK_SIZE ; \n if ( ( ret = imc_decode_block ( avctx , q , i ) ) < 0 ) \n return ret ; \n } \n if ( avctx -> channels == 2 ) { \n q -> fdsp . butterflies_float ( ( float * ) frame -> extended_data [ 0 ] , \n ( float * ) frame -> extended_data [ 1 ] , COEFFS ) ; \n } \n * got_frame_ptr = 1 ; \n return IMC_BLOCK_SIZE * avctx -> channels ; \n }", "idx": 27152}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "int init_vlc ( VLC * vlc , int nb_bits , int nb_codes , \n const void * bits , int bits_wrap , int bits_size , \n const void * codes , int codes_wrap , int codes_size ) \n { \n vlc -> bits = nb_bits ; \n vlc -> table = NULL ; \n vlc -> table_allocated = 0 ; \n vlc -> table_size = 0 ; \n #ifdef DEBUG_VLC \n printf ( \" \\n \" , nb_codes ) ; \n #endif \n if ( build_table ( vlc , nb_bits , nb_codes , \n bits , bits_wrap , bits_size , \n codes , codes_wrap , codes_size , \n 0 , 0 ) < 0 ) { \n av_free ( vlc -> table ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 27153}
{"project": "FFmpeg", "commit_id": "9d656110966fbdde0fd1d2e685f3ed3633ba3596", "target": 0, "func": "static int decode_subframe_fixed ( FLACContext * s , int channel , int pred_order ) \n { \n int i ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" , pred_order ) ; \n for ( i = 0 ; i < pred_order ; i ++ ) \n { \n s -> decoded [ channel ] [ i ] = get_sbits ( & s -> gb , s -> curr_bps ) ; \n } \n if ( decode_residuals ( s , channel , pred_order ) < 0 ) \n return -1 ; \n switch ( pred_order ) \n { \n case 0 : \n break ; \n case 1 : \n for ( i = pred_order ; i < s -> blocksize ; i ++ ) \n s -> decoded [ channel ] [ i ] += s -> decoded [ channel ] [ i - 1 ] ; \n break ; \n case 2 : \n for ( i = pred_order ; i < s -> blocksize ; i ++ ) \n s -> decoded [ channel ] [ i ] += 2 * s -> decoded [ channel ] [ i - 1 ] \n - s -> decoded [ channel ] [ i - 2 ] ; \n break ; \n case 3 : \n for ( i = pred_order ; i < s -> blocksize ; i ++ ) \n s -> decoded [ channel ] [ i ] += 3 * s -> decoded [ channel ] [ i - 1 ] \n - 3 * s -> decoded [ channel ] [ i - 2 ] \n + s -> decoded [ channel ] [ i - 3 ] ; \n break ; \n case 4 : \n for ( i = pred_order ; i < s -> blocksize ; i ++ ) \n s -> decoded [ channel ] [ i ] += 4 * s -> decoded [ channel ] [ i - 1 ] \n - 6 * s -> decoded [ channel ] [ i - 2 ] \n + 4 * s -> decoded [ channel ] [ i - 3 ] \n - s -> decoded [ channel ] [ i - 4 ] ; \n break ; \n default : \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , pred_order ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 27163}
{"project": "FFmpeg", "commit_id": "64b164f44abc232dbb125b36e2d00b54e1531ba7", "target": 1, "func": "static AVFilterContext * parse_filter ( const char * * buf , AVFilterGraph * graph , \n int index , AVClass * log_ctx ) \n { \n char * opts = NULL ; \n char * name = consume_string ( buf ) ; \n if ( * * buf == ' ' ) { \n ( * buf ) ++ ; \n opts = consume_string ( buf ) ; \n } \n return create_filter ( graph , index , name , opts , log_ctx ) ; \n }", "idx": 27173}
{"project": "FFmpeg", "commit_id": "dec2fa8cc7089605d1d934d65dd2709cfe8aece2", "target": 1, "func": "static AVCodec * AVCodecInitialize ( enum AVCodecID codec_id ) \n { \n AVCodec * res ; \n avcodec_register_all ( ) ; \n av_log_set_level ( AV_LOG_PANIC ) ; \n res = avcodec_find_decoder ( codec_id ) ; \n if ( ! res ) \n error ( \" \" ) ; \n return res ; \n }", "idx": 27174}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static void truncpasses ( Jpeg2000EncoderContext * s , Jpeg2000Tile * tile ) \n { \n int precno , compno , reslevelno , bandno , cblkno , lev ; \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n Jpeg2000Component * comp = tile -> comp + compno ; \n for ( reslevelno = 0 , lev = codsty -> nreslevels - 1 ; reslevelno < codsty -> nreslevels ; reslevelno ++ , lev -- ) { \n Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { \n int bandpos = bandno + ( reslevelno > 0 ) ; \n Jpeg2000Band * band = reslevel -> band + bandno ; \n Jpeg2000Prec * prec = band -> prec + precno ; \n for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_height * prec -> nb_codeblocks_width ; cblkno ++ ) { \n Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; \n cblk -> ninclpasses = getcut ( cblk , s -> lambda , \n ( int64_t ) dwt_norms [ codsty -> transform ] [ bandpos ] [ lev ] * ( int64_t ) band -> i_stepsize >> 16 ) ; \n } \n } \n } \n } \n } \n }", "idx": 27195}
{"project": "FFmpeg", "commit_id": "e56b0984103b981ec25fe8a22ef9c4905b9751dd", "target": 1, "func": "static int srt_write_packet ( AVFormatContext * avf , AVPacket * pkt ) \n { \n SRTContext * srt = avf -> priv_data ; \n int write_ts = avf -> streams [ 0 ] -> codec -> codec_id != AV_CODEC_ID_SRT ; \n srt -> index ++ ; \n if ( write_ts ) { \n int64_t s = pkt -> pts , e , d = pkt -> duration ; \n if ( d <= 0 ) \n d = pkt -> convergence_duration ; \n if ( s == AV_NOPTS_VALUE || d < 0 ) { \n av_log ( avf , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n e = s + d ; \n avio_printf ( avf -> pb , \" \\n \\n \" , \n srt -> index , \n ( int ) ( s / 3600000 ) , ( int ) ( s / 60000 ) % 60 , \n ( int ) ( s / 1000 ) % 60 , ( int ) ( s % 1000 ) , \n ( int ) ( e / 3600000 ) , ( int ) ( e / 60000 ) % 60 , \n ( int ) ( e / 1000 ) % 60 , ( int ) ( e % 1000 ) ) ; \n } \n avio_write ( avf -> pb , pkt -> data , pkt -> size ) ; \n if ( write_ts ) \n avio_write ( avf -> pb , \" \\n \\n \" , 2 ) ; \n avio_flush ( avf -> pb ) ; \n return 0 ; \n }", "idx": 27198}
{"project": "FFmpeg", "commit_id": "daa1ea049a9445b7bed03963cb789497065dd1eb", "target": 0, "func": "void ff_vp3_v_loop_filter_mmx ( uint8_t * src , int stride , int * bounding_values ) \n { \n __asm__ volatile ( \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n VP3_LOOP_FILTER ( % 4 ) \n \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( * ( uint64_t * ) ( src - 2 * stride ) ) , \n \" \" ( * ( uint64_t * ) ( src - 1 * stride ) ) , \n \" \" ( * ( uint64_t * ) ( src + 0 * stride ) ) , \n \" \" ( * ( uint64_t * ) ( src + 1 * stride ) ) \n : \" \" ( * ( uint64_t * ) ( bounding_values + 129 ) ) \n ) ; \n }", "idx": 27202}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_idct_add_altivec ( uint8_t * dst , int stride , DCTELEM block [ 64 ] ) \n { \n LOAD_ZERO ; \n vec_u8 t , vdst ; \n vec_s16 vdst_16 ; \n vec_u8 vdst_mask = vec_mergeh ( vec_splat_u8 ( -1 ) , vec_lvsl ( 0 , dst ) ) ; \n IDCT_START \n IDCT_1D ( NOP , NOP )  \n TRANSPOSE8 ( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 ) ; \n IDCT_1D ( ADD8 , SHIFT4 )  \n #define ADD ( a ) \\ \n  \n  vdst = vec_ld ( 0 , dst ) ; \n vdst_16 = ( vec_s16 ) vec_perm ( vdst , zero_u8v , vdst_mask ) ; \n vdst_16 = vec_adds ( a , vdst_16 ) ; \n t = vec_packsu ( vdst_16 , vdst_16 ) ; \n vec_ste ( ( vec_u32 ) t , 0 , ( unsigned int * ) dst ) ; \n vec_ste ( ( vec_u32 ) t , 4 , ( unsigned int * ) dst ) ; \n ADD ( b0 ) dst += stride ; \n ADD ( b1 ) dst += stride ; \n ADD ( b2 ) dst += stride ; \n ADD ( b3 ) dst += stride ; \n ADD ( b4 ) dst += stride ; \n ADD ( b5 ) dst += stride ; \n ADD ( b6 ) dst += stride ; \n ADD ( b7 )  \n }", "idx": 27208}
{"project": "FFmpeg", "commit_id": "c69461d73797e02e7a3ab4316050c241fa91f53f", "target": 1, "func": "static int asf_read_replicated_data ( AVFormatContext * s , ASFPacket * asf_pkt ) \n { \n ASFContext * asf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n int ret ; \n if ( ! asf_pkt -> data_size ) { \n asf_pkt -> data_size = asf_pkt -> size_left = avio_rl32 ( pb ) ; \n if ( asf_pkt -> data_size <= 0 ) \n return AVERROR_INVALIDDATA ; \n if ( ( ret = av_new_packet ( & asf_pkt -> avpkt , asf_pkt -> data_size ) ) < 0 ) \n return ret ; \n } else \n avio_skip ( pb , 4 ) ; \n asf_pkt -> dts = avio_rl32 ( pb ) ; \n if ( asf -> rep_data_len && ( asf -> rep_data_len >= 8 ) ) \n avio_skip ( pb , asf -> rep_data_len - 8 ) ; \n return 0 ; \n }", "idx": 27210}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static void encode_gray_bitstream ( HYuvContext * s , int count ) { \n int i ; \n count /= 2 ; \n if ( s -> flags & CODEC_FLAG_PASS1 ) { \n for ( i = 0 ; i < count ; i ++ ) { \n s -> stats [ 0 ] [ s -> temp [ 0 ] [ 2 * i ] ] ++ ; \n s -> stats [ 0 ] [ s -> temp [ 0 ] [ 2 * i + 1 ] ] ++ ; \n } \n } else if ( s -> context ) { \n for ( i = 0 ; i < count ; i ++ ) { \n s -> stats [ 0 ] [ s -> temp [ 0 ] [ 2 * i ] ] ++ ; \n put_bits ( & s -> pb , s -> len [ 0 ] [ s -> temp [ 0 ] [ 2 * i ] ] , s -> bits [ 0 ] [ s -> temp [ 0 ] [ 2 * i ] ] ) ; \n s -> stats [ 0 ] [ s -> temp [ 0 ] [ 2 * i + 1 ] ] ++ ; \n put_bits ( & s -> pb , s -> len [ 0 ] [ s -> temp [ 0 ] [ 2 * i + 1 ] ] , s -> bits [ 0 ] [ s -> temp [ 0 ] [ 2 * i + 1 ] ] ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n put_bits ( & s -> pb , s -> len [ 0 ] [ s -> temp [ 0 ] [ 2 * i ] ] , s -> bits [ 0 ] [ s -> temp [ 0 ] [ 2 * i ] ] ) ; \n put_bits ( & s -> pb , s -> len [ 0 ] [ s -> temp [ 0 ] [ 2 * i + 1 ] ] , s -> bits [ 0 ] [ s -> temp [ 0 ] [ 2 * i + 1 ] ] ) ; \n } \n } \n }", "idx": 27219}
{"project": "FFmpeg", "commit_id": "d256ed78ffe202a4dcc8d625becffc716bfa3977", "target": 1, "func": "static int parse_vtrk ( AVFormatContext * s , \n FourxmDemuxContext * fourxm , uint8_t * buf , int size , \n int left ) \n { \n AVStream * st ; \n if ( size != vtrk_SIZE || left < size + 8 ) { \n return AVERROR_INVALIDDATA ; \n } \n st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n avpriv_set_pts_info ( st , 60 , 1 , fourxm -> fps ) ; \n fourxm -> video_stream_index = st -> index ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = AV_CODEC_ID_4XM ; \n st -> codec -> extradata_size = 4 ; \n st -> codec -> extradata = av_malloc ( 4 ) ; \n AV_WL32 ( st -> codec -> extradata , AV_RL32 ( buf + 16 ) ) ; \n st -> codec -> width = AV_RL32 ( buf + 36 ) ; \n st -> codec -> height = AV_RL32 ( buf + 40 ) ; \n return 0 ; \n }", "idx": 27224}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_stereo ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n output [ 1 ] [ i ] += output [ 2 ] [ i ] ; \n output [ 2 ] [ i ] += output [ 3 ] [ i ] ; \n } \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n }", "idx": 27228}
{"project": "FFmpeg", "commit_id": "851ded8918c977d8160c6617b69604f758cabf50", "target": 0, "func": "static int decode_cabac_mb_cbp_chroma ( H264Context * h ) { \n int ctx ; \n int cbp_a , cbp_b ; \n cbp_a = ( h -> left_cbp >> 4 ) & 0x03 ; \n cbp_b = ( h -> top_cbp >> 4 ) & 0x03 ; \n ctx = 0 ; \n if ( cbp_a > 0 ) ctx ++ ; \n if ( cbp_b > 0 ) ctx += 2 ; \n if ( get_cabac ( & h -> cabac , & h -> cabac_state [ 77 + ctx ] ) == 0 ) \n return 0 ; \n ctx = 4 ; \n if ( cbp_a == 2 ) ctx ++ ; \n if ( cbp_b == 2 ) ctx += 2 ; \n return 1 + get_cabac ( & h -> cabac , & h -> cabac_state [ 77 + ctx ] ) ; \n }", "idx": 27229}
{"project": "FFmpeg", "commit_id": "cb65b32c97b06fc611b53c1ab77a2edbaadee84f", "target": 0, "func": "static int mp3_write_audio_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n MP3Context * mp3 = s -> priv_data ; \n if ( pkt && pkt -> data && pkt -> size >= 4 ) { \n MPADecodeHeader c ; \n int av_unused base ; \n avpriv_mpegaudio_decode_header ( & c , AV_RB32 ( pkt -> data ) ) ; \n if ( ! mp3 -> initial_bitrate ) \n mp3 -> initial_bitrate = c . bit_rate ; \n if ( ( c . bit_rate == 0 ) || ( mp3 -> initial_bitrate != c . bit_rate ) ) \n mp3 -> has_variable_bitrate = 1 ; \n #ifdef FILTER_VBR_HEADERS \n base = 4 + xing_offtbl [ c . lsf == 1 ] [ c . nb_channels == 1 ] ; \n if ( base + 4 <= pkt -> size ) { \n uint32_t v = AV_RB32 ( pkt -> data + base ) ; \n if ( MKBETAG ( ' ' , ' ' , ' ' , ' ' ) == v || MKBETAG ( ' ' , ' ' , ' ' , ' ' ) == v ) \n return 0 ; \n } \n base = 4 + 32 ; \n if ( base + 4 <= pkt -> size && MKBETAG ( ' ' , ' ' , ' ' , ' ' ) == AV_RB32 ( pkt -> data + base ) ) \n return 0 ; \n #endif \n if ( mp3 -> xing_offset ) \n mp3_xing_add_frame ( mp3 , pkt ) ; \n } \n return ff_raw_write_packet ( s , pkt ) ; \n }", "idx": 27230}
{"project": "FFmpeg", "commit_id": "c97f54020d5d55511e28622551f13233bd8ceb56", "target": 0, "func": "int has_altivec ( void ) \n { \n #ifdef __AMIGAOS4__ \n ULONG result = 0 ; \n extern struct ExecIFace * IExec ; \n IExec -> GetCPUInfoTags ( GCIT_VectorUnit , & result , TAG_DONE ) ; \n if ( result == VECTORTYPE_ALTIVEC ) return 1 ; \n return 0 ; \n #else \n #ifdef SYS_DARWIN \n int sels [ 2 ] = { CTL_HW , HW_VECTORUNIT } ; \n int has_vu = 0 ; \n size_t len = sizeof ( has_vu ) ; \n int err ; \n err = sysctl ( sels , 2 , & has_vu , & len , NULL , 0 ) ; \n if ( err == 0 ) return ( has_vu != 0 ) ; \n #else \n { \n signal ( SIGILL , sigill_handler ) ; \n if ( sigsetjmp ( jmpbuf , 1 ) ) { \n signal ( SIGILL , SIG_DFL ) ; \n } else { \n canjump = 1 ; \n asm volatile ( \" \\n \\t \" \n \" \" \n : \n : \" \" ( -1 ) ) ; \n signal ( SIGILL , SIG_DFL ) ; \n return 1 ; \n } \n } \n #endif \n return 0 ; \n #endif \n }", "idx": 27231}
{"project": "FFmpeg", "commit_id": "1cb0edb40b8e94e1a50ad40c40d43e34ed8435fe", "target": 1, "func": "static void mpeg_decode_picture_coding_extension ( MpegEncContext * s ) \n { \n s -> full_pel [ 0 ] = s -> full_pel [ 1 ] = 0 ; \n s -> mpeg_f_code [ 0 ] [ 0 ] = get_bits ( & s -> gb , 4 ) ; \n s -> mpeg_f_code [ 0 ] [ 1 ] = get_bits ( & s -> gb , 4 ) ; \n s -> mpeg_f_code [ 1 ] [ 0 ] = get_bits ( & s -> gb , 4 ) ; \n s -> mpeg_f_code [ 1 ] [ 1 ] = get_bits ( & s -> gb , 4 ) ; \n s -> intra_dc_precision = get_bits ( & s -> gb , 2 ) ; \n s -> picture_structure = get_bits ( & s -> gb , 2 ) ; \n s -> top_field_first = get_bits1 ( & s -> gb ) ; \n s -> frame_pred_frame_dct = get_bits1 ( & s -> gb ) ; \n s -> concealment_motion_vectors = get_bits1 ( & s -> gb ) ; \n s -> q_scale_type = get_bits1 ( & s -> gb ) ; \n s -> intra_vlc_format = get_bits1 ( & s -> gb ) ; \n s -> alternate_scan = get_bits1 ( & s -> gb ) ; \n s -> repeat_first_field = get_bits1 ( & s -> gb ) ; \n s -> chroma_420_type = get_bits1 ( & s -> gb ) ; \n s -> progressive_frame = get_bits1 ( & s -> gb ) ; \n dprintf ( \" \\n \" , s -> intra_dc_precision ) ; \n dprintf ( \" \\n \" , s -> picture_structure ) ; \n dprintf ( \" \\n \" , s -> concealment_motion_vectors ) ; \n dprintf ( \" \\n \" , s -> intra_vlc_format ) ; \n dprintf ( \" \\n \" , s -> alternate_scan ) ; \n dprintf ( \" \\n \" , s -> frame_pred_frame_dct ) ; \n }", "idx": 27234}
{"project": "FFmpeg", "commit_id": "3836af476534e6f84be7b3a19afce3530af50703", "target": 1, "func": "static int mpegvideo_probe ( AVProbeData * p ) \n { \n uint32_t code = -1 ; \n int pic = 0 , seq = 0 , slice = 0 , pspack = 0 , vpes = 0 , apes = 0 , res = 0 , sicle = 0 ; \n int i ; \n uint32_t last = 0 ; \n for ( i = 0 ; i < p -> buf_size ; i ++ ) { \n code = ( code << 8 ) + p -> buf [ i ] ; \n if ( ( code & 0xffffff00 ) == 0x100 ) { \n switch ( code ) { \n case SEQ_START_CODE : seq ++ ; break ; \n case PICTURE_START_CODE : pic ++ ; break ; \n case PACK_START_CODE : pspack ++ ; break ; \n case 0x1b6 : \n res ++ ; break ; \n } \n if ( code >= SLICE_START_CODE && code <= 0x1af ) { \n if ( last >= SLICE_START_CODE && last <= 0x1af ) { \n if ( code >= last ) slice ++ ; \n else sicle ++ ; \n } else { \n if ( code == SLICE_START_CODE ) slice ++ ; \n else sicle ++ ; \n } \n } \n if ( ( code & 0x1f0 ) == VIDEO_ID ) vpes ++ ; \n else if ( ( code & 0x1e0 ) == AUDIO_ID ) apes ++ ; \n last = code ; \n } \n } \n if ( seq && seq * 9 <= pic * 10 && pic * 9 <= slice * 10 && ! pspack && ! apes && ! res && slice > sicle ) { \n if ( vpes ) return AVPROBE_SCORE_EXTENSION / 4 ; \n else return pic > 1 ? AVPROBE_SCORE_EXTENSION + 1 : AVPROBE_SCORE_EXTENSION / 2 ; \n } \n return 0 ; \n }", "idx": 27236}
{"project": "FFmpeg", "commit_id": "59163139679b0aa2cb84cd6d7a3f696ed5a5813a", "target": 0, "func": "static int get_std_framerate ( int i ) { \n if ( i < 60 * 12 ) return i * 1001 ; \n else return ( ( const int [ ] ) { 24 , 30 , 60 , 12 , 15 , 48 } ) [ i - 60 * 12 ] * 1000 * 12 ; \n }", "idx": 27243}
{"project": "FFmpeg", "commit_id": "912ce9dd2080c5837285a471d750fa311e09b555", "target": 0, "func": "void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) \n { \n int reslevelno , bandno , precno ; \n for ( reslevelno = 0 ; \n comp -> reslevel && reslevelno < codsty -> nreslevels ; \n reslevelno ++ ) { \n Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; \n for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { \n Jpeg2000Band * band = reslevel -> band + bandno ; \n for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { \n Jpeg2000Prec * prec = band -> prec + precno ; \n av_freep ( & prec -> zerobits ) ; \n av_freep ( & prec -> cblkincl ) ; \n av_freep ( & prec -> cblk ) ; \n } \n av_freep ( & band -> prec ) ; \n } \n av_freep ( & reslevel -> band ) ; \n } \n ff_dwt_destroy ( & comp -> dwt ) ; \n av_freep ( & comp -> reslevel ) ; \n av_freep ( & comp -> i_data ) ; \n av_freep ( & comp -> f_data ) ; \n }", "idx": 27244}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int apc_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n if ( av_get_packet ( s -> pb , pkt , MAX_READ_SIZE ) <= 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = 0 ; \n return 0 ; \n }", "idx": 27260}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int sdp_parse ( AVFormatContext * s , const char * content ) \n { \n const char * p ; \n int letter ; \n char buf [ 16384 ] , * q ; \n SDPParseState sdp_parse_state , * s1 = & sdp_parse_state ; \n memset ( s1 , 0 , sizeof ( SDPParseState ) ) ; \n p = content ; \n for ( ; ; ) { \n skip_spaces ( & p ) ; \n letter = * p ; \n if ( letter == ' \\0 ' ) \n break ; \n p ++ ; \n if ( * p != ' ' ) \n goto next_line ; \n p ++ ; \n q = buf ; \n while ( * p != ' \\n ' && * p != ' \\r ' && * p != ' \\0 ' ) { \n if ( ( q - buf ) < sizeof ( buf ) - 1 ) \n * q ++ = * p ; \n p ++ ; \n } \n * q = ' \\0 ' ; \n sdp_parse_line ( s , s1 , letter , buf ) ; \n next_line : \n while ( * p != ' \\n ' && * p != ' \\0 ' ) \n p ++ ; \n if ( * p == ' \\n ' ) \n p ++ ; \n } \n return 0 ; \n }", "idx": 27282}
{"project": "FFmpeg", "commit_id": "aaa7d2fafcc375d8cdef25a289008821c9c2fbaa", "target": 1, "func": "static void flush_change ( H264Context * h ) \n { \n h -> outputed_poc = h -> next_outputed_poc = INT_MIN ; \n h -> prev_interlaced_frame = 1 ; \n idr ( h ) ; \n h -> prev_frame_num = -1 ; \n if ( h -> s . current_picture_ptr ) \n h -> s . current_picture_ptr -> f . reference = 0 ; \n h -> s . first_field = 0 ; \n memset ( h -> ref_list [ 0 ] , 0 , sizeof ( h -> ref_list [ 0 ] ) ) ; \n memset ( h -> ref_list [ 1 ] , 0 , sizeof ( h -> ref_list [ 1 ] ) ) ; \n memset ( h -> default_ref_list [ 0 ] , 0 , sizeof ( h -> default_ref_list [ 0 ] ) ) ; \n memset ( h -> default_ref_list [ 1 ] , 0 , sizeof ( h -> default_ref_list [ 1 ] ) ) ; \n ff_h264_reset_sei ( h ) ; \n h -> recovery_frame = -1 ; \n h -> sync = 0 ; \n h -> list_count = 0 ; \n h -> current_slice = 0 ; \n }", "idx": 27283}
{"project": "FFmpeg", "commit_id": "37f573543c4fd7f44339e04d8d15b95118493ddd", "target": 0, "func": "static int check_image_pointers ( uint8_t * data [ 4 ] , enum AVPixelFormat pix_fmt , \n const int linesizes [ 4 ] ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ; \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n int plane = desc -> comp [ i ] . plane ; \n if ( ! data [ plane ] || ! linesizes [ plane ] ) \n return 0 ; \n } \n return 1 ; \n }", "idx": 27298}
{"project": "FFmpeg", "commit_id": "84be80698227366d970e045001e4b59e4f99f0a1", "target": 0, "func": "static void pool_release_buffer ( void * opaque , uint8_t * data ) \n { \n BufferPoolEntry * buf = opaque ; \n AVBufferPool * pool = buf -> pool ; \n if ( CONFIG_MEMORY_POISONING ) \n memset ( buf -> data , 0x2a , pool -> size ) ; \n add_to_pool ( buf ) ; \n if ( ! avpriv_atomic_int_add_and_fetch ( & pool -> refcount , -1 ) ) \n buffer_pool_free ( pool ) ; \n }", "idx": 27306}
