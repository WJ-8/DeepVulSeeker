{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact ( FlacEncodeContext * s , FlacSubframe * sub , \n int pred_order ) \n { \n int p , porder , psize ; \n int i , part_end ; \n int count = 0 ; \n count += 8 ; \n if ( sub -> type == FLAC_SUBFRAME_CONSTANT ) { \n count += sub -> obits ; \n } else if ( sub -> type == FLAC_SUBFRAME_VERBATIM ) { \n count += s -> frame . blocksize * sub -> obits ; \n } else { \n count += pred_order * sub -> obits ; \n if ( sub -> type == FLAC_SUBFRAME_LPC ) \n count += 4 + 5 + pred_order * s -> options . lpc_coeff_precision ; \n count += 2 ; \n porder = sub -> rc . porder ; \n psize = s -> frame . blocksize >> porder ; \n count += 4 ; \n i = pred_order ; \n part_end = psize ; \n for ( p = 0 ; p < 1 << porder ; p ++ ) { \n int k = sub -> rc . params [ p ] ; \n count += 4 ; \n count += rice_count_exact ( & sub -> residual [ i ] , part_end - i , k ) ; \n i = part_end ; \n part_end = FFMIN ( s -> frame . blocksize , part_end + psize ) ; \n } \n } \n return count ; \n }", "idx": 35}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n int dc = block [ 0 ] ; \n const uint8_t * cm ; \n dc = ( 3 * dc + 1 ) >> 1 ; \n dc = ( 3 * dc + 16 ) >> 5 ; \n cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest [ 4 ] = cm [ dest [ 4 ] ] ; \n dest [ 5 ] = cm [ dest [ 5 ] ] ; \n dest [ 6 ] = cm [ dest [ 6 ] ] ; \n dest [ 7 ] = cm [ dest [ 7 ] ] ; \n dest += linesize ; \n } \n }", "idx": 121}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy ( AC3EncodeContext * s ) \n { \n int nb_coefs ; \n int blk , bnd , i ; \n AC3Block * block , * block0 ; \n s -> num_rematrixing_bands = 4 ; \n if ( s -> rematrixing & AC3_REMATRIXING_IS_STATIC ) \n return ; \n nb_coefs = FFMIN ( s -> nb_coefs [ 0 ] , s -> nb_coefs [ 1 ] ) ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n block = & s -> blocks [ blk ] ; \n block -> new_rematrixing_strategy = ! blk ; \n for ( bnd = 0 ; bnd < s -> num_rematrixing_bands ; bnd ++ ) { \n int start = ff_ac3_rematrix_band_tab [ bnd ] ; \n int end = FFMIN ( nb_coefs , ff_ac3_rematrix_band_tab [ bnd + 1 ] ) ; \n CoefSumType sum [ 4 ] = { 0 , } ; \n for ( i = start ; i < end ; i ++ ) { \n CoefType lt = block -> mdct_coef [ 0 ] [ i ] ; \n CoefType rt = block -> mdct_coef [ 1 ] [ i ] ; \n CoefType md = lt + rt ; \n CoefType sd = lt - rt ; \n sum [ 0 ] += lt * lt ; \n sum [ 1 ] += rt * rt ; \n sum [ 2 ] += md * md ; \n sum [ 3 ] += sd * sd ; \n } \n if ( FFMIN ( sum [ 2 ] , sum [ 3 ] ) < FFMIN ( sum [ 0 ] , sum [ 1 ] ) ) \n block -> rematrixing_flags [ bnd ] = 1 ; \n else \n block -> rematrixing_flags [ bnd ] = 0 ; \n if ( blk && \n block -> rematrixing_flags [ bnd ] != block0 -> rematrixing_flags [ bnd ] ) { \n block -> new_rematrixing_strategy = 1 ; \n } \n } \n block0 = block ; \n } \n }", "idx": 149}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table ( CLLCContext * ctx , GetBitContext * gb , VLC * vlc ) \n { \n uint8_t symbols [ 256 ] ; \n uint8_t bits [ 256 ] ; \n uint16_t codes [ 256 ] ; \n int num_lens , num_codes , num_codes_sum , prefix ; \n int i , j , count ; \n prefix = 0 ; \n count = 0 ; \n num_codes_sum = 0 ; \n num_lens = get_bits ( gb , 5 ) ; \n for ( i = 0 ; i < num_lens ; i ++ ) { \n num_codes = get_bits ( gb , 9 ) ; \n num_codes_sum += num_codes ; \n if ( num_codes_sum > 256 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \n \" \\n \" , num_codes_sum ) ; \n for ( j = 0 ; j < num_codes ; j ++ ) { \n symbols [ count ] = get_bits ( gb , 8 ) ; \n bits [ count ] = i + 1 ; \n codes [ count ] = prefix ++ ; \n count ++ ; \n if ( prefix > ( 65535 - 256 ) / 2 ) { \n prefix <<= 1 ; \n return ff_init_vlc_sparse ( vlc , VLC_BITS , count , bits , 1 , 1 , \n codes , 2 , 2 , symbols , 1 , 1 , 0 ) ;", "idx": 244}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context ( AVCodecContext * avctx ) \n { \n HEVCContext * s = avctx -> priv_data ; \n int i ; \n s -> avctx = avctx ; \n s -> HEVClc = av_mallocz ( sizeof ( HEVCLocalContext ) ) ; \n if ( ! s -> HEVClc ) \n goto fail ; \n s -> HEVClcList [ 0 ] = s -> HEVClc ; \n s -> sList [ 0 ] = s ; \n s -> cabac_state = av_malloc ( HEVC_CONTEXTS ) ; \n if ( ! s -> cabac_state ) \n goto fail ; \n s -> output_frame = av_frame_alloc ( ) ; \n if ( ! s -> output_frame ) \n goto fail ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( s -> DPB ) ; i ++ ) { \n s -> DPB [ i ] . frame = av_frame_alloc ( ) ; \n if ( ! s -> DPB [ i ] . frame ) \n goto fail ; \n s -> DPB [ i ] . tf . f = s -> DPB [ i ] . frame ; \n } \n s -> max_ra = INT_MAX ; \n s -> md5_ctx = av_md5_alloc ( ) ; \n if ( ! s -> md5_ctx ) \n goto fail ; \n ff_bswapdsp_init ( & s -> bdsp ) ; \n s -> context_initialized = 1 ; \n s -> eos = 0 ; \n return 0 ; \n fail : \n hevc_decode_free ( avctx ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 262}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk ( AVCodecContext * avctx , PNGDecContext * s , \n uint32_t length ) \n { \n int n , i , r , g , b ; \n if ( ( length % 3 ) != 0 || length > 256 * 3 ) \n return AVERROR_INVALIDDATA ; \n n = length / 3 ; \n for ( i = 0 ; i < n ; i ++ ) { \n r = bytestream2_get_byte ( & s -> gb ) ; \n g = bytestream2_get_byte ( & s -> gb ) ; \n b = bytestream2_get_byte ( & s -> gb ) ; \n s -> palette [ i ] = ( 0xFFU << 24 ) | ( r << 16 ) | ( g << 8 ) | b ; \n } \n for ( ; i < 256 ; i ++ ) \n s -> palette [ i ] = ( 0xFFU << 24 ) ; \n s -> state |= PNG_PLTE ; \n bytestream2_skip ( & s -> gb , 4 ) ; \n return 0 ; \n }", "idx": 265}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n if ( atom . size <= 40 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n if ( ( uint64_t ) atom . size > ( 1 << 30 ) ) \n return AVERROR_INVALIDDATA ; \n av_free ( st -> codec -> extradata ) ; \n st -> codec -> extradata = av_mallocz ( atom . size - 40 + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! st -> codec -> extradata ) \n return AVERROR ( ENOMEM ) ; \n st -> codec -> extradata_size = atom . size - 40 ; \n avio_skip ( pb , 40 ) ; \n avio_read ( pb , st -> codec -> extradata , atom . size - 40 ) ; \n return 0 ; \n }", "idx": 305}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2 ( AVCodecContext * avctx , AVFrame * picture , \n int * got_picture_ptr , \n AVPacket * avpkt ) \n { \n int ret ; \n * got_picture_ptr = 0 ; \n if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( avctx -> coded_width , avctx -> coded_height , 0 , avctx ) ) \n return -1 ; \n avctx -> pkt = avpkt ; \n apply_param_change ( avctx , avpkt ) ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || avpkt -> size || ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( HAVE_THREADS && avctx -> active_thread_type & FF_THREAD_FRAME ) \n ret = ff_thread_decode_frame ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n else { \n ret = avctx -> codec -> decode ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n picture -> pkt_dts = avpkt -> dts ; \n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio ; \n picture -> width = avctx -> width ; \n picture -> height = avctx -> height ; \n picture -> format = avctx -> pix_fmt ; \n } \n emms_c ( ) ; \n if ( * got_picture_ptr ) \n avctx -> frame_number ++ ; \n } else \n ret = 0 ; \n picture -> extended_data = picture -> data ; \n return ret ; \n }", "idx": 372}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open ( URLContext * h , const char * uri , int flags ) \n { \n const char * nested_url ; \n int ret ; \n CryptoContext * c = h -> priv_data ; \n if ( ! av_strstart ( uri , \" \" , & nested_url ) && \n ! av_strstart ( uri , \" \" , & nested_url ) ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" , uri ) ; \n ret = AVERROR ( EINVAL ) ; \n goto err ; \n } \n if ( c -> keylen < BLOCKSIZE || c -> ivlen < BLOCKSIZE ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n ret = AVERROR ( EINVAL ) ; \n goto err ; \n } \n if ( flags & AVIO_FLAG_WRITE ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n ret = AVERROR ( ENOSYS ) ; \n goto err ; \n } \n if ( ( ret = ffurl_open ( & c -> hd , nested_url , AVIO_FLAG_READ ) ) < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n goto err ; \n } \n c -> aes = av_mallocz ( av_aes_size ) ; \n if ( ! c -> aes ) { \n ret = AVERROR ( ENOMEM ) ; \n goto err ; \n } \n av_aes_init ( c -> aes , c -> key , 128 , 1 ) ; \n h -> is_streamed = 1 ; \n return 0 ; \n err : \n av_free ( c -> key ) ; \n av_free ( c -> iv ) ; \n return ret ; \n }", "idx": 436}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries ( AVCodecContext * avctx , int count ) \n { \n int i ; \n if ( avctx -> active_thread_type & FF_THREAD_SLICE ) { \n SliceThreadContext * p = avctx -> internal -> thread_ctx ; \n p -> thread_count = avctx -> thread_count ; \n p -> entries = av_mallocz_array ( count , sizeof ( int ) ) ; \n if ( ! p -> entries ) { \n return AVERROR ( ENOMEM ) ; \n } \n p -> entries_count = count ; \n p -> progress_mutex = av_malloc_array ( p -> thread_count , sizeof ( pthread_mutex_t ) ) ; \n p -> progress_cond = av_malloc_array ( p -> thread_count , sizeof ( pthread_cond_t ) ) ; \n for ( i = 0 ; i < p -> thread_count ; i ++ ) { \n pthread_mutex_init ( & p -> progress_mutex [ i ] , NULL ) ; \n pthread_cond_init ( & p -> progress_cond [ i ] , NULL ) ; \n } \n } \n return 0 ; \n }", "idx": 439}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12 ( AVCodecContext * avctx , const AVFrame * frame , opj_image_t * image ) \n { \n int compno ; \n int x , y ; \n int * image_line ; \n int frame_index ; \n const int numcomps = image -> numcomps ; \n uint16_t * frame_ptr = ( uint16_t * ) frame -> data [ 0 ] ; \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n if ( image -> comps [ compno ] . w > frame -> linesize [ 0 ] / numcomps ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return 0 ; \n } \n } \n for ( compno = 0 ; compno < numcomps ; ++ compno ) { \n for ( y = 0 ; y < avctx -> height ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n frame_index = y * ( frame -> linesize [ 0 ] / 2 ) + compno ; \n for ( x = 0 ; x < avctx -> width ; ++ x ) { \n image_line [ x ] = frame_ptr [ frame_index ] >> 4 ; \n frame_index += numcomps ; \n } \n for ( ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - 1 ] ; \n } \n } \n for ( ; y < image -> comps [ compno ] . h ; ++ y ) { \n image_line = image -> comps [ compno ] . data + y * image -> comps [ compno ] . w ; \n for ( x = 0 ; x < image -> comps [ compno ] . w ; ++ x ) { \n image_line [ x ] = image_line [ x - image -> comps [ compno ] . w ] ; \n } \n } \n } \n return 1 ; \n }", "idx": 657}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n dst [ 0 ] = palette [ src [ i ] * 4 + 0 ] ; \n dst [ 1 ] = palette [ src [ i ] * 4 + 1 ] ; \n dst [ 2 ] = palette [ src [ i ] * 4 + 2 ] ; \n dst += 3 ; \n } \n }", "idx": 674}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock ( DiracContext * s , SubBand * b , \n GetBitContext * gb , DiracArith * c , \n int left , int right , int top , int bottom , \n int blockcnt_one , int is_arith ) \n { \n int x , y , zero_block ; \n int qoffset , qfactor ; \n IDWTELEM * buf ; \n if ( ! blockcnt_one ) { \n if ( is_arith ) \n zero_block = dirac_get_arith_bit ( c , CTX_ZERO_BLOCK ) ; \n else \n zero_block = get_bits1 ( gb ) ; \n if ( zero_block ) \n return ; \n } \n if ( s -> codeblock_mode && ! ( s -> old_delta_quant && blockcnt_one ) ) { \n if ( is_arith ) \n b -> quant += dirac_get_arith_int ( c , CTX_DELTA_Q_F , CTX_DELTA_Q_DATA ) ; \n else \n b -> quant += dirac_get_se_golomb ( gb ) ; \n } \n b -> quant = FFMIN ( b -> quant , MAX_QUANT ) ; \n qfactor = qscale_tab [ b -> quant ] ; \n if ( ! s -> num_refs ) \n qoffset = qoffset_intra_tab [ b -> quant ] ; \n else \n qoffset = qoffset_inter_tab [ b -> quant ] ; \n buf = b -> ibuf + top * b -> stride ; \n for ( y = top ; y < bottom ; y ++ ) { \n for ( x = left ; x < right ; x ++ ) { \n if ( is_arith ) \n coeff_unpack_arith ( c , qfactor , qoffset , b , buf + x , x , y ) ; \n else \n buf [ x ] = coeff_unpack_golomb ( gb , qfactor , qoffset ) ; \n } \n buf += b -> stride ; \n } \n }", "idx": 677}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream ( AVFormatContext * s ) \n { \n BinDemuxContext * bin = s -> priv_data ; \n AVStream * st = avformat_new_stream ( s , NULL ) ; \n if ( ! st ) \n return NULL ; \n st -> codec -> codec_tag = 0 ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n if ( ! bin -> width ) { \n st -> codec -> width = ( 80 << 3 ) ; \n st -> codec -> height = ( 25 << 4 ) ; \n } \n avpriv_set_pts_info ( st , 60 , bin -> framerate . den , bin -> framerate . num ) ; \n bin -> chars_per_frame = FFMAX ( av_q2d ( st -> time_base ) * bin -> chars_per_frame , 1 ) ; \n return st ; \n }", "idx": 767}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples ( AVFilterLink * link , AVFilterBufferRef * samplesref ) \n { \n return 0 ; \n }", "idx": 1035}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum ( ByteIOContext * bc ) { \n unsigned long checksum = get_checksum ( bc ) ; \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , checksum , ( int ) get_be32 ( bc ) ) ; \n return 0 ; \n }", "idx": 1059}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt ( int argc , char * argv [ ] , char * opts ) \n { \n static int sp = 1 ; \n int c ; \n char * cp ; \n if ( sp == 1 ) \n if ( optind >= argc || \n argv [ optind ] [ 0 ] != ' ' || argv [ optind ] [ 1 ] == ' \\0 ' ) \n return EOF ; \n else if ( ! strcmp ( argv [ optind ] , \" \" ) ) { \n optind ++ ; \n return EOF ; \n } \n optopt = c = argv [ optind ] [ sp ] ; \n if ( c == ' ' || ( cp = strchr ( opts , c ) ) == NULL ) { \n fprintf ( stderr , \" \\n \" , c ) ; \n if ( argv [ optind ] [ ++ sp ] == ' \\0 ' ) { \n optind ++ ; \n sp = 1 ; \n } \n return ' ' ; \n } \n if ( * ++ cp == ' ' ) { \n if ( argv [ optind ] [ sp + 1 ] != ' \\0 ' ) \n optarg = & argv [ optind ++ ] [ sp + 1 ] ; \n else if ( ++ optind >= argc ) { \n fprintf ( stderr , \" \\n \" , c ) ; \n sp = 1 ; \n return ' ' ; \n } else \n optarg = argv [ optind ++ ] ; \n sp = 1 ; \n } else { \n if ( argv [ optind ] [ ++ sp ] == ' \\0 ' ) { \n sp = 1 ; \n optind ++ ; \n } \n optarg = NULL ; \n } \n return c ; \n }", "idx": 1145}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "func": "FFTContext * av_fft_init ( int nbits , int inverse ) \n { \n FFTContext * s = av_malloc ( sizeof ( * s ) ) ; \n if ( s && ff_fft_init ( s , nbits , inverse ) ) \n av_freep ( & s ) ; \n return s ; \n }", "idx": 1307}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_int ( int * p , int i0 , int i1 ) \n { \n int i ; \n if ( i1 <= i0 + 1 ) { \n if ( i0 == 1 ) \n p [ 1 ] = ( p [ 1 ] * I_LFTG_X + ( 1 << 15 ) ) >> 16 ; \n else \n p [ 0 ] = ( p [ 0 ] * I_LFTG_K + ( 1 << 15 ) ) >> 16 ; \n return ; \n } \n extend97_int ( p , i0 , i1 ) ; \n i0 ++ ; i1 ++ ; \n for ( i = i0 / 2 - 2 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i + 1 ] -= ( I_LFTG_ALPHA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 + 1 ; i ++ ) \n p [ 2 * i ] -= ( I_LFTG_BETA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = i0 / 2 - 1 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i + 1 ] += ( I_LFTG_GAMMA * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 << 15 ) ) >> 16 ; \n for ( i = i0 / 2 ; i < i1 / 2 ; i ++ ) \n p [ 2 * i ] += ( I_LFTG_DELTA * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 << 15 ) ) >> 16 ; \n }", "idx": 1338}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( rgb32ToY ) ( uint8_t * dst , uint8_t * src , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n int r = ( ( uint32_t * ) src ) [ i ] & 0xFF ; \n int g = ( ( ( uint32_t * ) src ) [ i ] >> 8 ) & 0xFF ; \n int b = ( ( ( uint32_t * ) src ) [ i ] >> 16 ) & 0xFF ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n }", "idx": 1341}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n IPMVEContext * ipmovie = ( IPMVEContext * ) s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n int ret ; \n ret = process_ipmovie_chunk ( ipmovie , pb , pkt ) ; \n if ( ret == CHUNK_BAD ) \n ret = AVERROR_INVALIDDATA ; \n else if ( ret == CHUNK_EOF ) \n ret = AVERROR_IO ; \n else if ( ret == CHUNK_NOMEM ) \n ret = AVERROR_NOMEM ; \n else \n ret = 0 ; \n return ret ; \n }", "idx": 1373}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4uv_c ( uint8_t * dst , int16_t block [ 4 ] [ 16 ] , ptrdiff_t stride ) \n { \n vp8_idct_dc_add_c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \n vp8_idct_dc_add_c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \n }", "idx": 1426}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static av_cold int png_dec_end ( AVCodecContext * avctx ) \n { \n PNGDecContext * s = avctx -> priv_data ; \n ff_thread_release_buffer ( avctx , & s -> previous_picture ) ; \n av_frame_free ( & s -> previous_picture . f ) ; \n ff_thread_release_buffer ( avctx , & s -> last_picture ) ; \n av_frame_free ( & s -> last_picture . f ) ; \n ff_thread_release_buffer ( avctx , & s -> picture ) ; \n av_frame_free ( & s -> picture . f ) ; \n av_freep ( & s -> buffer ) ; \n s -> buffer_size = 0 ; \n av_freep ( & s -> last_row ) ; \n s -> last_row_size = 0 ; \n av_freep ( & s -> tmp_row ) ; \n s -> tmp_row_size = 0 ; \n av_freep ( & s -> extra_data ) ; \n s -> extra_data_size = 0 ; \n return 0 ; \n }", "idx": 1439}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_file_size ( FTPContext * s ) \n { \n char command [ CONTROL_BUFFER_SIZE ] ; \n char * res = NULL ; \n const int size_codes [ ] = { 213 , 0 } ; \n snprintf ( command , sizeof ( command ) , \" \\r \\n \" , s -> path ) ; \n if ( ftp_send_command ( s , command , size_codes , & res ) ) { \n s -> filesize = strtoll ( & res [ 4 ] , NULL , 10 ) ; \n } else { \n s -> filesize = -1 ; \n av_free ( res ) ; \n return AVERROR ( EIO ) ; \n } \n av_free ( res ) ; \n return 0 ; \n }", "idx": 1525}
{"project": "FFmpeg", "commit_id": "bd255f9feb4deea4c990e582f0ba3b90d7b64b4c", "target": 0, "func": "int attribute_align_arg avcodec_decode_video2 ( AVCodecContext * avctx , AVFrame * picture , \n int * got_picture_ptr , \n AVPacket * avpkt ) \n { \n int ret ; \n * got_picture_ptr = 0 ; \n if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( avctx -> coded_width , avctx -> coded_height , 0 , avctx ) ) \n return -1 ; \n avctx -> pkt = avpkt ; \n apply_param_change ( avctx , avpkt ) ; \n avcodec_get_frame_defaults ( picture ) ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || avpkt -> size || ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) { \n if ( HAVE_THREADS && avctx -> active_thread_type & FF_THREAD_FRAME ) \n ret = ff_thread_decode_frame ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n else { \n ret = avctx -> codec -> decode ( avctx , picture , got_picture_ptr , \n avpkt ) ; \n picture -> pkt_dts = avpkt -> dts ; \n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio ; \n picture -> width = avctx -> width ; \n picture -> height = avctx -> height ; \n picture -> format = avctx -> pix_fmt ; \n } \n emms_c ( ) ; \n if ( * got_picture_ptr ) \n avctx -> frame_number ++ ; \n } else \n ret = 0 ; \n picture -> extended_data = picture -> data ; \n return ret ; \n }", "idx": 1657}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init ( AVCodecContext * avctx ) \n { \n ADPCMContext * c = avctx -> priv_data ; \n if ( avctx -> channels > 2U ) { \n return -1 ; \n } \n c -> channel = 0 ; \n c -> status [ 0 ] . predictor = c -> status [ 1 ] . predictor = 0 ; \n c -> status [ 0 ] . step_index = c -> status [ 1 ] . step_index = 0 ; \n c -> status [ 0 ] . step = c -> status [ 1 ] . step = 0 ; \n switch ( avctx -> codec -> id ) { \n case CODEC_ID_ADPCM_CT : \n c -> status [ 0 ] . step = c -> status [ 1 ] . step = 511 ; \n break ; \n case CODEC_ID_ADPCM_IMA_WS : \n if ( avctx -> extradata && avctx -> extradata_size == 2 * 4 ) { \n c -> status [ 0 ] . predictor = AV_RL32 ( avctx -> extradata ) ; \n c -> status [ 1 ] . predictor = AV_RL32 ( avctx -> extradata + 4 ) ; \n } \n break ; \n default : \n break ; \n } \n return 0 ; \n }", "idx": 1713}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_schro_queue_push_back ( FFSchroQueue * queue , void * p_data ) \n { \n FFSchroQueueElement * p_new = av_mallocz ( sizeof ( FFSchroQueueElement ) ) ; \n if ( ! p_new ) \n return -1 ; \n p_new -> data = p_data ; \n if ( ! queue -> p_head ) \n queue -> p_head = p_new ; \n else \n queue -> p_tail -> next = p_new ; \n queue -> p_tail = p_new ; \n ++ queue -> size ; \n return 0 ; \n }", "idx": 1791}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_block ( FICContext * ctx , GetBitContext * gb , \n uint8_t * dst , int stride , int16_t * block ) \n { \n int i , num_coeff ; \n if ( get_bits1 ( gb ) ) { \n ctx -> frame -> key_frame = 0 ; \n ctx -> frame -> pict_type = AV_PICTURE_TYPE_P ; \n return 0 ; \n } \n memset ( block , 0 , sizeof ( * block ) * 64 ) ; \n num_coeff = get_bits ( gb , 7 ) ; \n if ( num_coeff > 64 ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < num_coeff ; i ++ ) \n block [ ff_zigzag_direct [ i ] ] = get_se_golomb ( gb ) * \n ctx -> qmat [ ff_zigzag_direct [ i ] ] ; \n fic_idct_put ( dst , stride , block ) ; \n return 0 ; \n }", "idx": 2010}
{"project": "FFmpeg", "commit_id": "604c9b1196c70d79bbbc1f23e75f6a8253a74da3", "target": 1, "func": "void ff_rtsp_undo_setup ( AVFormatContext * s , int send_packets ) \n { \n RTSPState * rt = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < rt -> nb_rtsp_streams ; i ++ ) { \n RTSPStream * rtsp_st = rt -> rtsp_streams [ i ] ; \n if ( ! rtsp_st ) \n continue ; \n if ( rtsp_st -> transport_priv ) { \n if ( s -> oformat ) { \n AVFormatContext * rtpctx = rtsp_st -> transport_priv ; \n av_write_trailer ( rtpctx ) ; \n if ( rt -> lower_transport == RTSP_LOWER_TRANSPORT_TCP ) { \n uint8_t * ptr ; \n if ( CONFIG_RTSP_MUXER && rtpctx -> pb && send_packets ) \n ff_rtsp_tcp_write_packet ( s , rtsp_st ) ; \n avio_close_dyn_buf ( rtpctx -> pb , & ptr ) ; \n av_free ( ptr ) ; \n } else { \n avio_close ( rtpctx -> pb ) ; \n } \n avformat_free_context ( rtpctx ) ; \n } else if ( rt -> transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC ) \n ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; \n else if ( rt -> transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC ) \n ff_rtp_parse_close ( rtsp_st -> transport_priv ) ; \n } \n rtsp_st -> transport_priv = NULL ; \n if ( rtsp_st -> rtp_handle ) \n ffurl_close ( rtsp_st -> rtp_handle ) ; \n rtsp_st -> rtp_handle = NULL ; \n } \n }", "idx": 2027}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer ( AVFrame * frame , int align ) \n { \n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( frame -> format ) ; \n int ret , i ; \n if ( ! desc ) \n return AVERROR ( EINVAL ) ; \n if ( ( ret = av_image_check_size ( frame -> width , frame -> height , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ! frame -> linesize [ 0 ] ) { \n ret = av_image_fill_linesizes ( frame -> linesize , frame -> format , \n frame -> width ) ; \n if ( ret < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) \n frame -> linesize [ i ] = FFALIGN ( frame -> linesize [ i ] , align ) ; \n } \n for ( i = 0 ; i < 4 && frame -> linesize [ i ] ; i ++ ) { \n int h = FFALIGN ( frame -> height , 32 ) ; \n if ( i == 1 || i == 2 ) \n h = - ( ( - h ) >> desc -> log2_chroma_h ) ; \n frame -> buf [ i ] = av_buffer_alloc ( frame -> linesize [ i ] * h ) ; \n if ( ! frame -> buf [ i ] ) \n goto fail ; \n frame -> data [ i ] = frame -> buf [ i ] -> data ; \n } \n if ( desc -> flags & PIX_FMT_PAL || desc -> flags & PIX_FMT_PSEUDOPAL ) { \n av_buffer_unref ( & frame -> buf [ 1 ] ) ; \n frame -> buf [ 1 ] = av_buffer_alloc ( 1024 ) ; \n if ( ! frame -> buf [ 1 ] ) \n goto fail ; \n frame -> data [ 1 ] = frame -> buf [ 1 ] -> data ; \n } \n frame -> extended_data = frame -> data ; \n return 0 ; \n fail : \n av_frame_unref ( frame ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 2049}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts ( FFV1Context * f ) \n { \n int i ; \n f -> slice_count = f -> num_h_slices * f -> num_v_slices ; \n if ( f -> slice_count <= 0 ) { \n av_log ( f -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n for ( i = 0 ; i < f -> slice_count ; i ++ ) { \n FFV1Context * fs = av_mallocz ( sizeof ( * fs ) ) ; \n int sx = i % f -> num_h_slices ; \n int sy = i / f -> num_h_slices ; \n int sxs = f -> avctx -> width * sx / f -> num_h_slices ; \n int sxe = f -> avctx -> width * ( sx + 1 ) / f -> num_h_slices ; \n int sys = f -> avctx -> height * sy / f -> num_v_slices ; \n int sye = f -> avctx -> height * ( sy + 1 ) / f -> num_v_slices ; \n f -> slice_context [ i ] = fs ; \n memcpy ( fs , f , sizeof ( * fs ) ) ; \n memset ( fs -> rc_stat2 , 0 , sizeof ( fs -> rc_stat2 ) ) ; \n fs -> slice_width = sxe - sxs ; \n fs -> slice_height = sye - sys ; \n fs -> slice_x = sxs ; \n fs -> slice_y = sys ; \n fs -> sample_buffer = av_malloc ( 3 * MAX_PLANES * ( fs -> width + 6 ) * \n sizeof ( * fs -> sample_buffer ) ) ; \n if ( ! fs -> sample_buffer ) \n return AVERROR ( ENOMEM ) ; \n } \n return 0 ; \n }", "idx": 2083}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int * DEC_UQUAD ( int * dst , unsigned idx , unsigned sign ) \n { \n unsigned nz = idx >> 12 ; \n dst [ 0 ] = ( idx & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n sign <<= nz & 1 ; \n nz >>= 1 ; \n dst [ 1 ] = ( idx >> 2 & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n sign <<= nz & 1 ; \n nz >>= 1 ; \n dst [ 2 ] = ( idx >> 4 & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n sign <<= nz & 1 ; \n nz >>= 1 ; \n dst [ 3 ] = ( idx >> 6 & 3 ) * ( 1 + ( ( ( int ) sign >> 31 ) << 1 ) ) ; \n return dst + 4 ; \n }", "idx": 2142}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yuv422ptouyvy ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartouyvy ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 1 ) ; \n }", "idx": 2246}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_2_c_template ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target )  \n { \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n output_pixels ( i * 4 , Y1 , U , Y2 , V ) ; \n } \n }", "idx": 2298}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc ( uint8_t * buf , const uint8_t * src , \n int linesize , \n int block_w , int block_h , \n int src_x , int src_y , \n int w , int h , \n emu_edge_core_func * core_fn ) \n { \n int start_y , start_x , end_y , end_x , src_y_add = 0 ; \n if ( src_y >= h ) { \n src_y_add = h - 1 - src_y ; \n src_y = h - 1 ; \n } else if ( src_y <= - block_h ) { \n src_y_add = 1 - block_h - src_y ; \n src_y = 1 - block_h ; \n } \n if ( src_x >= w ) { \n src += w - 1 - src_x ; \n src_x = w - 1 ; \n } else if ( src_x <= - block_w ) { \n src += 1 - block_w - src_x ; \n src_x = 1 - block_w ; \n } \n start_y = FFMAX ( 0 , - src_y ) ; \n start_x = FFMAX ( 0 , - src_x ) ; \n end_y = FFMIN ( block_h , h - src_y ) ; \n end_x = FFMIN ( block_w , w - src_x ) ; \n av_assert2 ( start_x < end_x && block_w > 0 ) ; \n av_assert2 ( start_y < end_y && block_h > 0 ) ; \n src += ( src_y_add + start_y ) * linesize + start_x ; \n buf += start_x ; \n core_fn ( buf , src , linesize , start_y , end_y , \n block_h , start_x , end_x , block_w ) ; \n }", "idx": 2300}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles ( BinkContext * c ) \n { \n int bw , bh , blocks ; \n int i ; \n bw = ( c -> avctx -> width + 7 ) >> 3 ; \n bh = ( c -> avctx -> height + 7 ) >> 3 ; \n blocks = bw * bh ; \n for ( i = 0 ; i < BINKB_NB_SRC ; i ++ ) { \n c -> bundle [ i ] . data = av_malloc ( blocks * 64 ) ; \n if ( ! c -> bundle [ i ] . data ) \n return AVERROR ( ENOMEM ) ; \n c -> bundle [ i ] . data_end = c -> bundle [ i ] . data + blocks * 64 ; \n } \n return 0 ; \n }", "idx": 2325}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME ( yuv422ptoyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 1 ) ; \n }", "idx": 2348}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref ( HEVCContext * s , RefPicList * list , \n int poc , int ref_flag ) \n { \n HEVCFrame * ref = find_ref_idx ( s , poc ) ; \n if ( ref == s -> ref ) \n return AVERROR_INVALIDDATA ; \n if ( ! ref ) { \n ref = generate_missing_ref ( s , poc ) ; \n if ( ! ref ) \n return AVERROR ( ENOMEM ) ; \n } \n list -> list [ list -> nb_refs ] = ref -> poc ; \n list -> ref [ list -> nb_refs ] = ref ; \n list -> nb_refs ++ ; \n mark_ref ( ref , ref_flag ) ; \n return 0 ; \n }", "idx": 2400}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_4x4_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride ) ; \n }", "idx": 2429}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe ( AVProbeData * p ) \n { \n const uint8_t * d ; \n if ( p -> buf_size < 6 ) \n return 0 ; \n d = p -> buf ; \n if ( d [ 0 ] == ' ' && d [ 1 ] == ' ' && d [ 2 ] == ' ' && d [ 3 ] < 5 && d [ 5 ] == 0 ) { \n return AVPROBE_SCORE_MAX ; \n } \n return 0 ; \n }", "idx": 2466}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_coc ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c , \n uint8_t * properties ) \n { \n int compno ; \n if ( s -> buf_end - s -> buf < 2 ) \n return AVERROR ( EINVAL ) ; \n compno = bytestream_get_byte ( & s -> buf ) ; \n c += compno ; \n c -> csty = bytestream_get_byte ( & s -> buf ) ; \n get_cox ( s , c ) ; \n properties [ compno ] |= HAD_COC ; \n return 0 ; \n }", "idx": 2665}
{"project": "FFmpeg", "commit_id": "1169f0d0afc0454633cfcfad73643f0458521c67", "target": 0, "func": "void ff_dnxhdenc_init_x86 ( DNXHDEncContext * ctx ) \n { \n #if HAVE_INLINE_ASM  \n  \n  if ( av_get_cpu_flags ( ) & AV_CPU_FLAG_SSE2 ) { \n if ( ctx -> cid_table -> bit_depth == 8 ) \n ctx -> get_pixels_8x4_sym = get_pixels_8x4_sym_sse2 ; \n } \n #endif \n }", "idx": 2793}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc21_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_8w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 8 , 0 ) ; \n }", "idx": 3065}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget ( const uint8_t * * p , int type , int le ) \n { \n switch ( type ) { \n case TIFF_BYTE : \n return * ( * p ) ++ ; \n case TIFF_SHORT : \n return tget_short ( p , le ) ; \n case TIFF_LONG : \n return tget_long ( p , le ) ; \n default : \n return UINT_MAX ; \n } \n }", "idx": 3158}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice ( AVCodecContext * avctx , void * arg ) \n { \n int i , quant , level , orientation , quant_idx ; \n uint8_t quants [ MAX_DWT_LEVELS ] [ 4 ] ; \n DiracContext * s = avctx -> priv_data ; \n DiracSlice * slice = arg ; \n GetBitContext * gb = & slice -> gb ; \n skip_bits_long ( gb , 8 * s -> highquality . prefix_bytes ) ; \n quant_idx = get_bits ( gb , 8 ) ; \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { \n quant = FFMAX ( quant_idx - s -> lowdelay . quant [ level ] [ orientation ] , 0 ) ; \n quants [ level ] [ orientation ] = quant ; \n } \n } \n for ( i = 0 ; i < 3 ; i ++ ) { \n int64_t length = s -> highquality . size_scaler * get_bits ( gb , 8 ) ; \n int64_t bits_left = 8 * length ; \n int64_t bits_end = get_bits_count ( gb ) + bits_left ; \n if ( bits_end >= INT_MAX ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { \n for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { \n decode_subband ( s , gb , quants [ level ] [ orientation ] , slice -> slice_x , slice -> slice_y , bits_end , \n & s -> plane [ i ] . band [ level ] [ orientation ] , NULL ) ; \n } \n } \n skip_bits_long ( gb , bits_end - get_bits_count ( gb ) ) ; \n } \n return 0 ; \n }", "idx": 3160}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_wb_encode_init ( AVCodecContext * avctx ) \n { \n AMRWBContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 16000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> last_bitrate = avctx -> bit_rate ; \n avctx -> frame_size = 320 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n s -> state = E_IF_init ( ) ; \n return 0 ; \n }", "idx": 3161}
{"project": "FFmpeg", "commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "target": 1, "func": "void ff_fetch_timestamp ( AVCodecParserContext * s , int off , int remove ) \n { \n int i ; \n s -> dts = \n s -> pts = AV_NOPTS_VALUE ; \n s -> pos = -1 ; \n s -> offset = 0 ; \n for ( i = 0 ; i < AV_PARSER_PTS_NB ; i ++ ) { \n if ( s -> cur_offset + off >= s -> cur_frame_offset [ i ] && \n ( s -> frame_offset < s -> cur_frame_offset [ i ] || \n ( ! s -> frame_offset && ! s -> next_frame_offset ) ) && \n s -> cur_frame_end [ i ] ) { \n s -> dts = s -> cur_frame_dts [ i ] ; \n s -> pts = s -> cur_frame_pts [ i ] ; \n s -> pos = s -> cur_frame_pos [ i ] ; \n s -> offset = s -> next_frame_offset - s -> cur_frame_offset [ i ] ; \n if ( remove ) \n s -> cur_frame_offset [ i ] = INT64_MAX ; \n if ( s -> cur_offset + off < s -> cur_frame_end [ i ] ) \n break ; \n } \n } \n }", "idx": 3176}
{"project": "FFmpeg", "commit_id": "3d2c3ef4b46d96023d6f0d358e4d7d65568da67c", "target": 0, "func": "static int decode_cabac_mb_cbp_luma ( H264Context * h ) { \n int cbp_b , cbp_a , ctx , cbp = 0 ; \n cbp_a = h -> slice_table [ h -> left_mb_xy [ 0 ] ] == h -> slice_num ? h -> left_cbp : -1 ; \n cbp_b = h -> slice_table [ h -> top_mb_xy ] == h -> slice_num ? h -> top_cbp : -1 ; \n ctx = ! ( cbp_a & 0x02 ) + 2 * ! ( cbp_b & 0x04 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) ; \n ctx = ! ( cbp & 0x01 ) + 2 * ! ( cbp_b & 0x08 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) << 1 ; \n ctx = ! ( cbp_a & 0x08 ) + 2 * ! ( cbp & 0x01 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) << 2 ; \n ctx = ! ( cbp & 0x04 ) + 2 * ! ( cbp & 0x02 ) ; \n cbp |= get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 73 + ctx ] ) << 3 ; \n return cbp ; \n }", "idx": 3211}
{"project": "FFmpeg", "commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "target": 1, "func": "void ff_qsv_decode_reset ( AVCodecContext * avctx , QSVContext * q ) \n { \n QSVFrame * cur ; \n AVPacket pkt ; \n int ret = 0 ; \n mfxVideoParam param = { { 0 } } ; \n if ( q -> reinit_pending ) { \n close_decoder ( q ) ; \n } else if ( q -> engine_ready ) { \n ret = MFXVideoDECODE_GetVideoParam ( q -> session , & param ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ret ) ; \n } \n ret = MFXVideoDECODE_Reset ( q -> session , & param ) ; \n if ( ret < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ret ) ; \n } \n cur = q -> work_frames ; \n while ( cur ) { \n q -> work_frames = cur -> next ; \n av_frame_free ( & cur -> frame ) ; \n av_freep ( & cur ) ; \n cur = q -> work_frames ; \n } \n } \n av_fifo_reset ( q -> async_fifo ) ; \n while ( av_fifo_size ( q -> pkt_fifo ) ) { \n av_fifo_generic_read ( q -> pkt_fifo , & pkt , sizeof ( pkt ) , NULL ) ; \n av_packet_unref ( & pkt ) ; \n } \n av_fifo_reset ( q -> input_fifo ) ; \n }", "idx": 3227}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane ( uint8_t * main , int main_stride , \n uint8_t * ref , int ref_stride , \n int width , int height , void * temp ) \n { \n int z = 0 ; \n int x , y ; \n float ssim = 0.0 ; \n int ( * sum0 ) [ 4 ] = temp ; \n int ( * sum1 ) [ 4 ] = sum0 + ( width >> 2 ) + 3 ; \n width >>= 2 ; \n height >>= 2 ; \n for ( y = 1 ; y < height ; y ++ ) { \n for ( ; z <= y ; z ++ ) { \n FFSWAP ( void * , sum0 , sum1 ) ; \n for ( x = 0 ; x < width ; x += 2 ) \n ssim_4x4x2_core ( & main [ 4 * ( x + z * main_stride ) ] , main_stride , \n & ref [ 4 * ( x + z * ref_stride ) ] , ref_stride , \n & sum0 [ x ] ) ; \n } \n ssim += ssim_endn ( sum0 , sum1 , width - 1 ) ; \n } \n return ssim / ( ( height - 1 ) * ( width - 1 ) ) ; \n }", "idx": 3274}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To15_c ( SwsContext * c , int16_t * dst , int dstW , const uint8_t * src , \n const int16_t * filter , const int16_t * filterPos , \n int filterSize ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int j ; \n int srcPos = filterPos [ i ] ; \n int val = 0 ; \n for ( j = 0 ; j < filterSize ; j ++ ) { \n val += ( ( int ) src [ srcPos + j ] ) * filter [ filterSize * i + j ] ; \n } \n dst [ i ] = FFMIN ( val >> 7 , ( 1 << 15 ) - 1 ) ; \n } \n }", "idx": 3293}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgech ( uint8_t * pix , int stride , const int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const int qp_bd_offset = 6 * ( h -> sps . bit_depth_luma - 8 ) ; \n const unsigned int index_a = qp - qp_bd_offset + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp - qp_bd_offset + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_v_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_v_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 3330}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME ( rgb15to32 ) ( const uint8_t * src , uint8_t * dst , int src_size ) \n { \n const uint16_t * end ; \n const uint16_t * mm_end ; \n uint8_t * d = dst ; \n const uint16_t * s = ( const uint16_t * ) src ; \n end = s + src_size / 2 ; \n __asm__ volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n __asm__ volatile ( \" \\n \\t \" :: : \" \" ) ; \n mm_end = end - 3 ; \n while ( s < mm_end ) { \n __asm__ volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \"  \n PACK_RGB32 \n : \" \" ( * d ) \n : \" \" ( * s ) , \" \" ( mask15b ) , \" \" ( mask15g ) , \" \" ( mask15r ) \n : \" \" ) ; \n d += 16 ; \n s += 4 ; \n } \n __asm__ volatile ( SFENCE :: : \" memory \" ) ; \n __asm__ volatile ( EMMS :: : \" memory \" ) ; \n while ( s < end ) { \n register uint16_t bgr ; \n bgr = * s ++ ; \n * d ++ = ( bgr & 0x1F ) << 3 ; \n * d ++ = ( bgr & 0x3E0 ) >> 2 ; \n * d ++ = ( bgr & 0x7C00 ) >> 7 ; \n * d ++ = 255 ; \n } \n }", "idx": 3375}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hcscale ( SwsContext * c , int16_t * dst1 , int16_t * dst2 , int dstWidth , \n const uint8_t * src_in [ 4 ] , \n int srcW , int xInc , const int16_t * hChrFilter , \n const int16_t * hChrFilterPos , int hChrFilterSize , \n uint8_t * formatConvBuffer , uint32_t * pal ) \n { \n const uint8_t * src1 = src_in [ 1 ] , * src2 = src_in [ 2 ] ; \n if ( c -> chrToYV12 ) { \n uint8_t * buf2 = formatConvBuffer + FFALIGN ( srcW * FFALIGN ( c -> srcBpc , 8 ) >> 3 , 16 ) ; \n c -> chrToYV12 ( formatConvBuffer , buf2 , src1 , src2 , srcW , pal ) ; \n src1 = formatConvBuffer ; \n src2 = buf2 ; \n } else if ( c -> readChrPlanar ) { \n uint8_t * buf2 = formatConvBuffer + FFALIGN ( srcW * FFALIGN ( c -> srcBpc , 8 ) >> 3 , 16 ) ; \n c -> readChrPlanar ( formatConvBuffer , buf2 , src_in , srcW ) ; \n src1 = formatConvBuffer ; \n src2 = buf2 ; \n } \n if ( ! c -> hcscale_fast ) { \n c -> hcScale ( c , dst1 , dstWidth , src1 , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n c -> hcScale ( c , dst2 , dstWidth , src2 , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n } else { \n c -> hcscale_fast ( c , dst1 , dst2 , dstWidth , src1 , src2 , srcW , xInc ) ; \n } \n if ( c -> chrConvertRange ) \n c -> chrConvertRange ( dst1 , dst2 , dstWidth ) ; \n }", "idx": 3397}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n TMVContext * tmv = s -> priv_data ; \n int64_t pos ; \n if ( stream_index ) \n return -1 ; \n pos = timestamp * \n ( tmv -> audio_chunk_size + tmv -> video_chunk_size + tmv -> padding ) ; \n avio_seek ( s -> pb , pos + TMV_HEADER_SIZE , SEEK_SET ) ; \n tmv -> stream_index = 0 ; \n return 0 ; \n }", "idx": 3551}
{"project": "FFmpeg", "commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "target": 1, "func": "static int64_t read_ts ( char * * line , int * duration ) \n { \n int64_t start , end ; \n if ( sscanf ( * line , \" \" SCNd64 \" \" SCNd64 , & start , & end ) == 2 ) { \n * line += strcspn ( * line , \" \\\" \" ) + 1 ; \n * duration = end - start ; \n return start ; \n } \n return AV_NOPTS_VALUE ; \n }", "idx": 3596}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2nv12XinC ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , uint8_t * uDest , int dstW , int chrDstW , int dstFormat ) \n { \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) \n { \n int val = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < lumFilterSize ; j ++ ) \n val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; \n dest [ i ] = av_clip_uint8 ( val >> 19 ) ; \n } \n if ( ! uDest ) \n return ; \n if ( dstFormat == PIX_FMT_NV12 ) \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( u >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( v >> 19 ) ; \n } \n else \n for ( i = 0 ; i < chrDstW ; i ++ ) \n { \n int u = 1 << 18 ; \n int v = 1 << 18 ; \n int j ; \n for ( j = 0 ; j < chrFilterSize ; j ++ ) \n { \n u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; \n v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; \n } \n uDest [ 2 * i ] = av_clip_uint8 ( v >> 19 ) ; \n uDest [ 2 * i + 1 ] = av_clip_uint8 ( u >> 19 ) ; \n } \n }", "idx": 3621}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred ( Indeo3DecodeContext * s ) \n { \n int i , j ; \n s -> ModPred = av_malloc ( 8 * 128 ) ; \n for ( i = 0 ; i < 128 ; ++ i ) { \n s -> ModPred [ i + 0 * 128 ] = i > 126 ? 254 : 2 * ( i + 1 - ( ( i + 1 ) % 2 ) ) ; \n s -> ModPred [ i + 1 * 128 ] = i == 7 ? 20 : \n i == 119 || \n i == 120 ? 236 : 2 * ( i + 2 - ( ( i + 1 ) % 3 ) ) ; \n s -> ModPred [ i + 2 * 128 ] = i > 125 ? 248 : 2 * ( i + 2 - ( ( i + 2 ) % 4 ) ) ; \n s -> ModPred [ i + 3 * 128 ] = 2 * ( i + 1 - ( ( i - 3 ) % 5 ) ) ; \n s -> ModPred [ i + 4 * 128 ] = i == 8 ? 20 : 2 * ( i + 1 - ( ( i - 3 ) % 6 ) ) ; \n s -> ModPred [ i + 5 * 128 ] = 2 * ( i + 4 - ( ( i + 3 ) % 7 ) ) ; \n s -> ModPred [ i + 6 * 128 ] = i > 123 ? 240 : 2 * ( i + 4 - ( ( i + 4 ) % 8 ) ) ; \n s -> ModPred [ i + 7 * 128 ] = 2 * ( i + 5 - ( ( i + 4 ) % 9 ) ) ; \n } \n s -> corrector_type = av_malloc ( 24 * 256 ) ; \n for ( i = 0 ; i < 24 ; ++ i ) { \n for ( j = 0 ; j < 256 ; ++ j ) { \n s -> corrector_type [ i * 256 + j ] = j < corrector_type_0 [ i ] ? 1 : \n j < 248 || ( i == 16 && j == 248 ) ? 0 : \n corrector_type_2 [ j - 248 ] ; \n } \n } \n }", "idx": 3658}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter ( AVFilterContext * * filt_ctx , AVFilterGraph * ctx , int index , \n const char * filt_name , const char * args , AVClass * log_ctx ) \n { \n AVFilter * filt ; \n char inst_name [ 30 ] ; \n char tmp_args [ 256 ] ; \n int ret ; \n snprintf ( inst_name , sizeof ( inst_name ) , \" \" , index , filt_name ) ; \n filt = avfilter_get_by_name ( filt_name ) ; \n if ( ! filt ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name ) ; \n return AVERROR ( EINVAL ) ; \n } \n ret = avfilter_open ( filt_ctx , filt , inst_name ) ; \n if ( ! * filt_ctx ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name ) ; \n return ret ; \n } \n if ( ( ret = avfilter_graph_add_filter ( ctx , * filt_ctx ) ) < 0 ) { \n avfilter_free ( * filt_ctx ) ; \n return ret ; \n } \n if ( ! strcmp ( filt_name , \" \" ) && ! strstr ( args , \" \" ) ) { \n snprintf ( tmp_args , sizeof ( tmp_args ) , \" \" , \n args , ctx -> scale_sws_opts ) ; \n args = tmp_args ; \n } \n if ( ( ret = avfilter_init_filter ( * filt_ctx , args , NULL ) ) < 0 ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\n \" , filt_name , args ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 3721}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_mclms ( WmallDecodeCtx * s ) \n { \n s -> mclms_order = ( get_bits ( & s -> gb , 4 ) + 1 ) * 2 ; \n s -> mclms_scaling = get_bits ( & s -> gb , 4 ) ; \n if ( get_bits1 ( & s -> gb ) ) { \n int i ; \n int send_coef_bits ; \n int cbits = av_log2 ( s -> mclms_scaling + 1 ) ; \n assert ( cbits == my_log2 ( s -> mclms_scaling + 1 ) ) ; \n if ( 1 << cbits < s -> mclms_scaling + 1 ) \n cbits ++ ; \n send_coef_bits = ( cbits ? get_bits ( & s -> gb , cbits ) : 0 ) + 2 ; \n for ( i = 0 ; i < s -> mclms_order * s -> num_channels * s -> num_channels ; i ++ ) { \n s -> mclms_coeffs [ i ] = get_bits ( & s -> gb , send_coef_bits ) ; \n } \n for ( i = 0 ; i < s -> num_channels ; i ++ ) { \n int c ; \n for ( c = 0 ; c < i ; c ++ ) { \n s -> mclms_coeffs_cur [ i * s -> num_channels + c ] = get_bits ( & s -> gb , send_coef_bits ) ; \n } \n } \n } \n }", "idx": 3722}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode ( H264Context * h , int mode , int is_chroma ) \n { \n static const int8_t top [ 7 ] = { LEFT_DC_PRED8x8 , 1 , -1 , -1 } ; \n static const int8_t left [ 7 ] = { TOP_DC_PRED8x8 , -1 , 2 , -1 , DC_128_PRED8x8 } ; \n if ( mode > 6U ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n h -> mb_x , h -> mb_y ) ; \n return -1 ; \n } \n if ( ! ( h -> top_samples_available & 0x8000 ) ) { \n mode = top [ mode ] ; \n if ( mode < 0 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n h -> mb_x , h -> mb_y ) ; \n return -1 ; \n } \n } \n if ( ( h -> left_samples_available & 0x8080 ) != 0x8080 ) { \n mode = left [ mode ] ; \n if ( is_chroma && ( h -> left_samples_available & 0x8080 ) ) { \n mode = ALZHEIMER_DC_L0T_PRED8x8 + \n ( ! ( h -> left_samples_available & 0x8000 ) ) + \n 2 * ( mode == DC_128_PRED8x8 ) ; \n } \n if ( mode < 0 ) { \n av_log ( h -> avctx , AV_LOG_ERROR , \n \" \\n \" , \n h -> mb_x , h -> mb_y ) ; \n return -1 ; \n } \n } \n return mode ; \n }", "idx": 3748}
{"project": "FFmpeg", "commit_id": "4a023d5b53132ced3643d0e8397baa80cf75f656", "target": 0, "func": "static av_cold int check_format ( AVCodecContext * avctx ) \n { \n AVCodecParserContext * parser ; \n uint8_t * pout ; \n int psize ; \n int index ; \n H264Context * h ; \n int ret = -1 ; \n parser = av_parser_init ( avctx -> codec -> id ) ; \n if ( ! parser ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto final ; \n } \n parser -> flags = PARSER_FLAG_COMPLETE_FRAMES ; \n index = av_parser_parse2 ( parser , avctx , & pout , & psize , NULL , 0 , 0 , 0 , 0 ) ; \n if ( index < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto release_parser ; \n } \n h = parser -> priv_data ; \n switch ( h -> sps . bit_depth_luma ) { \n case 8 : \n if ( ! CHROMA444 ( h ) && ! CHROMA422 ( h ) ) { \n ret = 0 ; \n break ; \n } \n default : \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n release_parser : \n av_parser_close ( parser ) ; \n final : \n return ret ; \n }", "idx": 3832}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain ( const char * gain ) \n { \n char * fraction ; \n int scale = 10000 ; \n int32_t mb = 0 ; \n int sign = 1 ; \n int db ; \n if ( ! gain ) \n return INT32_MIN ; \n gain += strspn ( gain , \" \\t \" ) ; \n if ( * gain == ' ' ) \n sign = -1 ; \n db = strtol ( gain , & fraction , 0 ) ; \n if ( * fraction ++ == ' ' ) { \n while ( av_isdigit ( * fraction ) && scale ) { \n mb += scale * ( * fraction - ' ' ) ; \n scale /= 10 ; \n fraction ++ ; \n } \n } \n if ( abs ( db ) > ( INT32_MAX - mb ) / 100000 ) \n return INT32_MIN ; \n return db * 100000 + sign * mb ; \n }", "idx": 3984}
{"project": "FFmpeg", "commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "target": 1, "func": "static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , \n const uint8_t * src , const uint8_t * src_end , \n int width , int esc_count ) \n { \n int i = 0 ; \n int count ; \n uint8_t zero_run = 0 ; \n const uint8_t * src_start = src ; \n uint8_t mask1 = - ( esc_count < 2 ) ; \n uint8_t mask2 = - ( esc_count < 3 ) ; \n uint8_t * end = dst + ( width - 2 ) ; \n avpriv_request_sample ( l -> avctx , \" \" ) ; \n return AVERROR_PATCHWELCOME ; \n output_zeros : \n if ( l -> zeros_rem ) { \n count = FFMIN ( l -> zeros_rem , width - i ) ; \n if ( end - dst < count ) { \n av_log ( l -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n memset ( dst , 0 , count ) ; \n l -> zeros_rem -= count ; \n dst += count ; \n } \n while ( dst < end ) { \n i = 0 ; \n while ( ! zero_run && dst + i < end ) { \n i ++ ; \n if ( i + 2 >= src_end - src ) \n return AVERROR_INVALIDDATA ; \n zero_run = \n ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; \n } \n if ( zero_run ) { \n zero_run = 0 ; \n i += esc_count ; \n memcpy ( dst , src , i ) ; \n dst += i ; \n l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; \n src += i + 1 ; \n goto output_zeros ; \n } else { \n memcpy ( dst , src , i ) ; \n src += i ; \n dst += i ; \n } \n } \n return src - src_start ; \n }", "idx": 4009}
{"project": "FFmpeg", "commit_id": "86b0d9cd58137fc499f263267c3219ac6186b98e", "target": 0, "func": "static void av_always_inline filter_mb_edgecv ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = beta_table [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] + 1 ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] + 1 ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] + 1 ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] + 1 ; \n h -> h264dsp . h264_h_loop_filter_chroma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> h264dsp . h264_h_loop_filter_chroma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 4025}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86 ( PixblockDSPContext * c , \n AVCodecContext * avctx , \n unsigned high_bit_depth ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_MMX ( cpu_flags ) ) { \n if ( ! high_bit_depth ) \n c -> get_pixels = ff_get_pixels_mmx ; \n c -> diff_pixels = ff_diff_pixels_mmx ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n if ( ! high_bit_depth ) \n c -> get_pixels = ff_get_pixels_sse2 ; \n c -> diff_pixels = ff_diff_pixels_sse2 ; \n } \n }", "idx": 4091}
{"project": "FFmpeg", "commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "target": 1, "func": "static void pkt_dump_internal ( void * avcl , FILE * f , int level , const AVPacket * pkt , \n int dump_payload , AVRational time_base ) \n { \n HEXDUMP_PRINT ( \" \\n \" , pkt -> stream_index ) ; \n HEXDUMP_PRINT ( \" \\n \" , ( pkt -> flags & AV_PKT_FLAG_KEY ) != 0 ) ; \n HEXDUMP_PRINT ( \" \\n \" , pkt -> duration * av_q2d ( time_base ) ) ; \n HEXDUMP_PRINT ( \" \" ) ; \n if ( pkt -> dts == AV_NOPTS_VALUE ) \n HEXDUMP_PRINT ( \" \" ) ; \n else \n HEXDUMP_PRINT ( \" \" , pkt -> dts * av_q2d ( time_base ) ) ; \n HEXDUMP_PRINT ( \" \" ) ; \n if ( pkt -> pts == AV_NOPTS_VALUE ) \n HEXDUMP_PRINT ( \" \" ) ; \n else \n HEXDUMP_PRINT ( \" \" , pkt -> pts * av_q2d ( time_base ) ) ; \n HEXDUMP_PRINT ( \" \\n \" ) ; \n HEXDUMP_PRINT ( \" \\n \" , pkt -> size ) ; \n if ( dump_payload ) \n av_hex_dump ( f , pkt -> data , pkt -> size ) ; \n }", "idx": 4095}
{"project": "FFmpeg", "commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "target": 1, "func": "int av_packet_split_side_data ( AVPacket * pkt ) { \n if ( ! pkt -> side_data_elems && pkt -> size > 12 && AV_RB64 ( pkt -> data + pkt -> size - 8 ) == FF_MERGE_MARKER ) { \n int i ; \n unsigned int size ; \n uint8_t * p ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 1 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n if ( size > INT_MAX || p - pkt -> data < size ) \n return 0 ; \n if ( p [ 4 ] & 128 ) \n break ; \n p -= size + 5 ; \n } \n pkt -> side_data = av_malloc_array ( i , sizeof ( * pkt -> side_data ) ) ; \n if ( ! pkt -> side_data ) \n return AVERROR ( ENOMEM ) ; \n p = pkt -> data + pkt -> size - 8 - 5 ; \n for ( i = 0 ; ; i ++ ) { \n size = AV_RB32 ( p ) ; \n av_assert0 ( size <= INT_MAX && p - pkt -> data >= size ) ; \n pkt -> side_data [ i ] . data = av_mallocz ( size + AV_INPUT_BUFFER_PADDING_SIZE ) ; \n pkt -> side_data [ i ] . size = size ; \n pkt -> side_data [ i ] . type = p [ 4 ] & 127 ; \n if ( ! pkt -> side_data [ i ] . data ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( pkt -> side_data [ i ] . data , p - size , size ) ; \n pkt -> size -= size + 5 ; \n if ( p [ 4 ] & 128 ) \n break ; \n p -= size + 5 ; \n } \n pkt -> size -= 8 ; \n pkt -> side_data_elems = i + 1 ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 4159}
{"project": "FFmpeg", "commit_id": "43a4cb070bf7588c53fd192e8fbc71a52fa14a4c", "target": 0, "func": "static int alac_encode_frame ( AVCodecContext * avctx , uint8_t * frame , \n int buf_size , void * data ) \n { \n AlacEncodeContext * s = avctx -> priv_data ; \n PutBitContext * pb = & s -> pbctx ; \n int i , out_bytes , verbatim_flag = 0 ; \n if ( avctx -> frame_size > DEFAULT_FRAME_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( buf_size < 2 * s -> max_coded_frame_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n verbatim : \n init_put_bits ( pb , frame , buf_size ) ; \n if ( s -> compression_level == 0 || verbatim_flag ) { \n const int16_t * samples = data ; \n write_frame_header ( s , 1 ) ; \n for ( i = 0 ; i < avctx -> frame_size * avctx -> channels ; i ++ ) { \n put_sbits ( pb , 16 , * samples ++ ) ; \n } \n } else { \n init_sample_buffers ( s , data ) ; \n write_frame_header ( s , 0 ) ; \n write_compressed_frame ( s ) ; \n } \n put_bits ( pb , 3 , 7 ) ; \n flush_put_bits ( pb ) ; \n out_bytes = put_bits_count ( pb ) >> 3 ; \n if ( out_bytes > s -> max_coded_frame_size ) { \n if ( verbatim_flag || s -> compression_level == 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n verbatim_flag = 1 ; \n goto verbatim ; \n } \n return out_bytes ; \n }", "idx": 4344}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init ( AVCodecContext * avctx , AudioFrameQueue * afq ) \n { \n afq -> avctx = avctx ; \n afq -> next_pts = AV_NOPTS_VALUE ; \n afq -> remaining_delay = avctx -> delay ; \n afq -> remaining_samples = avctx -> delay ; \n afq -> frame_queue = NULL ; \n }", "idx": 4479}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int estimate_qp ( MpegEncContext * s , int dry_run ) { \n if ( s -> next_lambda ) { \n s -> current_picture_ptr -> f . quality = \n s -> current_picture . f . quality = s -> next_lambda ; \n if ( ! dry_run ) s -> next_lambda = 0 ; \n } else if ( ! s -> fixed_qscale ) { \n s -> current_picture_ptr -> f . quality = \n s -> current_picture . f . quality = ff_rate_estimate_qscale ( s , dry_run ) ; \n if ( s -> current_picture . f . quality < 0 ) \n return -1 ; \n } \n if ( s -> adaptive_quant ) { \n switch ( s -> codec_id ) { \n case AV_CODEC_ID_MPEG4 : \n if ( CONFIG_MPEG4_ENCODER ) \n ff_clean_mpeg4_qscales ( s ) ; \n break ; \n case AV_CODEC_ID_H263 : \n case AV_CODEC_ID_H263P : \n case AV_CODEC_ID_FLV1 : \n if ( CONFIG_H263_ENCODER ) \n ff_clean_h263_qscales ( s ) ; \n break ; \n default : \n ff_init_qscale_tab ( s ) ; \n } \n s -> lambda = s -> lambda_table [ 0 ] ; \n } else \n s -> lambda = s -> current_picture . f . quality ; \n update_qscale ( s ) ; \n return 0 ; \n }", "idx": 4539}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "enum CodecID av_codec_get_id ( const AVCodecTag * tags [ 4 ] , unsigned int tag ) \n { \n int i ; \n for ( i = 0 ; i < 4 && tags [ i ] ; i ++ ) { \n enum CodecID id = codec_get_id ( tags [ i ] , tag ) ; \n if ( id != CODEC_ID_NONE ) return id ; \n } \n return CODEC_ID_NONE ; \n }", "idx": 4610}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "void sws_rgb2rgb_init ( int flags ) \n { \n #if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX  \n  \n  if ( flags & SWS_CPU_CAPS_SSE2 ) \n rgb2rgb_init_SSE2 ( ) ; \n else if ( flags & SWS_CPU_CAPS_MMX2 ) \n rgb2rgb_init_MMX2 ( ) ; \n else if ( flags & SWS_CPU_CAPS_3DNOW ) \n rgb2rgb_init_3DNOW ( ) ; \n else if ( flags & SWS_CPU_CAPS_MMX ) \n rgb2rgb_init_MMX ( ) ; \n else \n #endif \n rgb2rgb_init_C ( ) ; \n }", "idx": 4698}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static double tget_double ( GetByteContext * gb , int le ) \n { \n av_alias64 i = { . u64 = le ? bytestream2_get_le64 ( gb ) : bytestream2_get_be64 ( gb ) } ; \n return i . f64 ; \n }", "idx": 4718}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate ( AVCodecContext * ctx ) \n { \n int64_t bit_rate ; \n int bits_per_sample ; \n switch ( ctx -> codec_type ) { \n case AVMEDIA_TYPE_VIDEO : \n case AVMEDIA_TYPE_DATA : \n case AVMEDIA_TYPE_SUBTITLE : \n case AVMEDIA_TYPE_ATTACHMENT : \n bit_rate = ctx -> bit_rate ; \n break ; \n case AVMEDIA_TYPE_AUDIO : \n bits_per_sample = av_get_bits_per_sample ( ctx -> codec_id ) ; \n bit_rate = bits_per_sample ? ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate ; \n break ; \n default : \n bit_rate = 0 ; \n break ; \n } \n return bit_rate ; \n }", "idx": 4761}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_vp3_idct_dc_add_c ( uint8_t * dest \n , int line_size , const DCTELEM * block \n ) { \n int i , dc = ( block [ 0 ] + 15 ) >> 5 ; \n const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest [ 4 ] = cm [ dest [ 4 ] ] ; \n dest [ 5 ] = cm [ dest [ 5 ] ] ; \n dest [ 6 ] = cm [ dest [ 6 ] ] ; \n dest [ 7 ] = cm [ dest [ 7 ] ] ; \n dest += line_size ; \n } \n }", "idx": 4766}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static inline int mirror ( int v , int m ) { \n if ( v < 0 ) return - v ; \n else if ( v > m ) return 2 * m - v ; \n else return v ; \n }", "idx": 4769}
{"project": "FFmpeg", "commit_id": "4189fe11ffcbdcd311eb9a3437586a94492c4cde", "target": 1, "func": "static int vobsub_read_seek ( AVFormatContext * s , int stream_index , \n int64_t min_ts , int64_t ts , int64_t max_ts , int flags ) \n { \n MpegDemuxContext * vobsub = s -> priv_data ; \n if ( stream_index == -1 && s -> nb_streams != 1 ) { \n int i , ret = 0 ; \n AVRational time_base = s -> streams [ 0 ] -> time_base ; \n ts = av_rescale_q ( ts , AV_TIME_BASE_Q , time_base ) ; \n min_ts = av_rescale_rnd ( min_ts , time_base . den , \n time_base . num * ( int64_t ) AV_TIME_BASE , \n AV_ROUND_UP | AV_ROUND_PASS_MINMAX ) ; \n max_ts = av_rescale_rnd ( max_ts , time_base . den , \n time_base . num * ( int64_t ) AV_TIME_BASE , \n AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX ) ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n int r = ff_subtitles_queue_seek ( & vobsub -> q [ i ] , s , stream_index , \n min_ts , ts , max_ts , flags ) ; \n if ( r < 0 ) \n ret = r ; \n } \n return ret ; \n } \n return ff_subtitles_queue_seek ( & vobsub -> q [ stream_index ] , s , stream_index , \n min_ts , ts , max_ts , flags ) ; \n }", "idx": 4798}
{"project": "FFmpeg", "commit_id": "11de006babf735aafa3462d43dd2c02bb6ac6e2f", "target": 0, "func": "static int v4l2_read_packet ( AVFormatContext * s1 , AVPacket * pkt ) \n { \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n struct  video_data * s = s1 -> priv_data ; \n AVFrame * frame = s1 -> streams [ 0 ] -> codec -> coded_frame ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n int res ; \n av_init_packet ( pkt ) ; \n if ( ( res = mmap_read_frame ( s1 , pkt ) ) < 0 ) { \n return res ; \n } \n #if FF_API_CODED_FRAME  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( frame && s -> interlaced ) { \n frame -> interlaced_frame = 1 ; \n frame -> top_field_first = s -> top_field_first ; \n } \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n return pkt -> size ; \n }", "idx": 4873}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags ( AVFormatContext * s , AVStream * st , int64_t base ) \n { \n uint32_t v , spf ; \n MPADecodeHeader c ; \n int vbrtag_size = 0 ; \n MP3DecContext * mp3 = s -> priv_data ; \n ffio_init_checksum ( s -> pb , ff_crcA001_update , 0 ) ; \n v = avio_rb32 ( s -> pb ) ; \n if ( ff_mpa_check_header ( v ) < 0 ) \n return -1 ; \n if ( avpriv_mpegaudio_decode_header ( & c , v ) == 0 ) \n vbrtag_size = c . frame_size ; \n if ( c . layer != 3 ) \n return -1 ; \n spf = c . lsf ? 576 : 1152 ; \n mp3 -> frames = 0 ; \n mp3 -> size = 0 ; \n mp3_parse_info_tag ( s , st , & c , spf ) ; \n mp3_parse_vbri_tag ( s , st , base ) ; \n if ( ! mp3 -> frames && ! mp3 -> size ) \n return -1 ; \n avio_seek ( s -> pb , base + vbrtag_size , SEEK_SET ) ; \n if ( mp3 -> frames ) \n st -> duration = av_rescale_q ( mp3 -> frames , ( AVRational ) { spf , c . sample_rate } , \n st -> time_base ) ; \n if ( mp3 -> size && mp3 -> frames && ! mp3 -> is_cbr ) \n st -> codec -> bit_rate = av_rescale ( mp3 -> size , 8 * c . sample_rate , mp3 -> frames * ( int64_t ) spf ) ; \n return 0 ; \n }", "idx": 4879}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s , AVFrame * frame ) \n { \n int y ; \n unsigned char P [ 2 ] ; \n for ( y = 0 ; y < 8 ; y ++ ) { \n if ( ! ( y & 3 ) ) { \n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ; \n memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ; \n memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ; \n s -> pixel_ptr += s -> stride ; \n return 0 ;", "idx": 4995}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_top_dc_rv40_c ( uint8_t * src , int stride ) { \n int i ; \n int dc0 ; \n dc0 = 0 ; \n for ( i = 0 ; i < 8 ; i ++ ) \n dc0 += src [ i - stride ] ; \n dc0 = 0x01010101 * ( ( dc0 + 4 ) >> 3 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n ( ( uint32_t * ) ( src + i * stride ) ) [ 0 ] = \n ( ( uint32_t * ) ( src + i * stride ) ) [ 1 ] = dc0 ; \n } \n }", "idx": 5071}
{"project": "FFmpeg", "commit_id": "63b1866ae1e19ff0d694746a84e2eac859cda462", "target": 0, "func": "static void ac3_extract_exponents_c ( uint8_t * exp , int32_t * coef , int nb_coefs ) \n { \n int i ; \n for ( i = 0 ; i < nb_coefs ; i ++ ) { \n int e ; \n int v = abs ( coef [ i ] ) ; \n if ( v == 0 ) \n e = 24 ; \n else { \n e = 23 - av_log2 ( v ) ; \n if ( e >= 24 ) { \n e = 24 ; \n coef [ i ] = 0 ; \n } \n av_assert2 ( e >= 0 ) ; \n } \n exp [ i ] = e ; \n } \n }", "idx": 5281}
{"project": "FFmpeg", "commit_id": "7cc8d616aab68ba5534e5a74214786ad08aac5ce", "target": 1, "func": "uint8_t ff_mlp_calculate_parity ( const uint8_t * buf , unsigned int buf_size ) \n { \n uint32_t scratch = 0 ; \n const uint8_t * buf_end = buf + buf_size ; \n for ( ; buf < buf_end - 3 ; buf += 4 ) \n scratch ^= * ( ( const uint32_t * ) buf ) ; \n scratch = xor_32_to_8 ( scratch ) ; \n for ( ; buf < buf_end ; buf ++ ) \n return scratch ; \n }", "idx": 5327}
{"project": "FFmpeg", "commit_id": "f354f30836a3148275ce60d19bbc581310249ad2", "target": 0, "func": "void ff_er_frame_start ( ERContext * s ) \n { \n if ( ! s -> avctx -> err_recognition ) \n return ; \n memset ( s -> error_status_table , ER_MB_ERROR | VP_START | ER_MB_END , \n s -> mb_stride * s -> mb_height * sizeof ( uint8_t ) ) ; \n s -> error_count = 3 * s -> mb_num ; \n s -> error_occurred = 0 ; \n }", "idx": 5353}
{"project": "FFmpeg", "commit_id": "fc5a905a6d0c76d9fb8d838ac83f6219a7a5e20f", "target": 0, "func": "static void start_children ( FFStream * feed ) \n { \n if ( no_launch ) \n return ; \n for ( ; feed ; feed = feed -> next ) { \n if ( feed -> child_argv && ! feed -> pid ) { \n feed -> pid_start = time ( 0 ) ; \n feed -> pid = fork ( ) ; \n if ( feed -> pid < 0 ) { \n http_log ( \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( ! feed -> pid ) { \n char pathname [ 1024 ] ; \n char * slash ; \n int i ; \n av_strlcpy ( pathname , my_program_name , sizeof ( pathname ) ) ; \n slash = strrchr ( pathname , ' ' ) ; \n if ( ! slash ) \n slash = pathname ; \n else \n slash ++ ; \n strcpy ( slash , \" \" ) ; \n http_log ( \" \" ) ; \n http_log ( \" \" , pathname ) ; \n for ( i = 1 ; feed -> child_argv [ i ] && feed -> child_argv [ i ] [ 0 ] ; i ++ ) \n http_log ( \" \" , feed -> child_argv [ i ] ) ; \n http_log ( \" \\n \" ) ; \n for ( i = 3 ; i < 256 ; i ++ ) \n close ( i ) ; \n if ( ! ffserver_debug ) { \n i = open ( \" \" , O_RDWR ) ; \n if ( i != -1 ) { \n dup2 ( i , 0 ) ; \n dup2 ( i , 1 ) ; \n dup2 ( i , 2 ) ; \n close ( i ) ; \n } \n } \n chdir ( my_program_dir ) ; \n signal ( SIGPIPE , SIG_DFL ) ; \n execvp ( pathname , feed -> child_argv ) ; \n _exit ( 1 ) ; \n } \n } \n } \n }", "idx": 5416}
{"project": "FFmpeg", "commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "target": 1, "func": "static int mov_seek_fragment ( AVFormatContext * s , AVStream * st , int64_t timestamp ) \n { \n MOVContext * mov = s -> priv_data ; \n int i , j ; \n if ( ! mov -> fragment_index_complete ) \n return 0 ; \n for ( i = 0 ; i < mov -> fragment_index_count ; i ++ ) { \n if ( mov -> fragment_index_data [ i ] -> track_id == st -> id ) { \n MOVFragmentIndex * index = index = mov -> fragment_index_data [ i ] ; \n for ( j = index -> item_count - 1 ; j >= 0 ; j -- ) { \n if ( index -> items [ j ] . time <= timestamp ) { \n if ( index -> items [ j ] . headers_read ) \n return 0 ; \n return mov_switch_root ( s , index -> items [ j ] . moof_offset ) ; \n } \n } \n } \n } \n return 0 ; \n }", "idx": 5429}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_track ( MXFTrack * track , ByteIOContext * pb , int tag ) \n { \n switch ( tag ) { \n case 0x4801 : \n track -> track_id = get_be32 ( pb ) ; \n break ; \n case 0x4804 : \n get_buffer ( pb , track -> track_number , 4 ) ; \n break ; \n case 0x4B01 : \n track -> edit_rate . den = get_be32 ( pb ) ; \n track -> edit_rate . num = get_be32 ( pb ) ; \n break ; \n case 0x4803 : \n get_buffer ( pb , track -> sequence_ref , 16 ) ; \n break ; \n } \n return 0 ; \n }", "idx": 5430}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0 ( GetByteContext * gb , RangeCoder * rc , unsigned cumFreq , unsigned freq , unsigned total_freq ) \n { \n int t = rc -> range * ( uint64_t ) cumFreq / total_freq ; \n rc -> code1 += t + 1 ; \n rc -> range = rc -> range * ( uint64_t ) ( freq + cumFreq ) / total_freq - ( t + 1 ) ; \n while ( rc -> range < TOP && bytestream2_get_bytes_left ( gb ) > 0 ) { \n unsigned byte = bytestream2_get_byte ( gb ) ; \n rc -> code = ( rc -> code << 8 ) | byte ; \n rc -> code1 <<= 8 ; \n rc -> range <<= 8 ; \n } \n }", "idx": 5457}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86 ( DSPContext * c , AVCodecContext * avctx ) \n { \n #if HAVE_7REGS && HAVE_TEN_OPERANDS  \n  \n  c -> mlp_filter_channel = mlp_filter_channel_x86 ; \n #endif \n }", "idx": 5731}
{"project": "FFmpeg", "commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "target": 1, "func": "void ff_h264_flush_change ( H264Context * h ) \n { \n int i , j ; \n h -> next_outputed_poc = INT_MIN ; \n h -> prev_interlaced_frame = 1 ; \n idr ( h ) ; \n h -> poc . prev_frame_num = -1 ; \n if ( h -> cur_pic_ptr ) { \n h -> cur_pic_ptr -> reference = 0 ; \n for ( j = i = 0 ; h -> delayed_pic [ i ] ; i ++ ) \n if ( h -> delayed_pic [ i ] != h -> cur_pic_ptr ) \n h -> delayed_pic [ j ++ ] = h -> delayed_pic [ i ] ; \n h -> delayed_pic [ j ] = NULL ; \n } \n ff_h264_unref_picture ( h , & h -> last_pic_for_ec ) ; \n h -> first_field = 0 ; \n ff_h264_sei_uninit ( & h -> sei ) ; \n h -> recovery_frame = -1 ; \n h -> frame_recovered = 0 ; \n h -> current_slice = 0 ; \n h -> mmco_reset = 1 ; \n for ( i = 0 ; i < h -> nb_slice_ctx ; i ++ ) \n h -> slice_ctx [ i ] . list_count = 0 ; \n }", "idx": 5755}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2 ( void * obj , const char * name , double num , int den , int64_t intnum , const AVOption * * o_out ) \n { \n const AVOption * o = av_opt_find ( obj , name , NULL , 0 , 0 ) ; \n void * dst ; \n if ( o_out ) \n * o_out = o ; \n if ( ! o || o -> offset <= 0 ) \n return AVERROR_OPTION_NOT_FOUND ; \n if ( o -> max * den < num * intnum || o -> min * den > num * intnum ) { \n av_log ( obj , AV_LOG_ERROR , \" \\n \" , num , name ) ; \n return AVERROR ( ERANGE ) ; \n } \n dst = ( ( uint8_t * ) obj ) + o -> offset ; \n switch ( o -> type ) { \n case FF_OPT_TYPE_FLAGS : \n case FF_OPT_TYPE_INT : * ( int * ) dst = llrint ( num / den ) * intnum ; break ; \n case FF_OPT_TYPE_INT64 : * ( int64_t * ) dst = llrint ( num / den ) * intnum ; break ; \n case FF_OPT_TYPE_FLOAT : * ( float * ) dst = num * intnum / den ; break ; \n case FF_OPT_TYPE_DOUBLE : * ( double * ) dst = num * intnum / den ; break ; \n case FF_OPT_TYPE_RATIONAL : \n if ( ( int ) num == num ) * ( AVRational * ) dst = ( AVRational ) { num * intnum , den } ; \n else * ( AVRational * ) dst = av_d2q ( num * intnum / den , 1 << 24 ) ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n return 0 ; \n }", "idx": 5762}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c ( uint8_t * dest , int linesize , DCTELEM * block ) \n { \n int i ; \n int dc = block [ 0 ] ; \n const uint8_t * cm ; \n dc = ( 3 * dc + 1 ) >> 1 ; \n dc = ( 17 * dc + 64 ) >> 7 ; \n cm = ff_cropTbl + MAX_NEG_CROP + dc ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dest [ 0 ] = cm [ dest [ 0 ] ] ; \n dest [ 1 ] = cm [ dest [ 1 ] ] ; \n dest [ 2 ] = cm [ dest [ 2 ] ] ; \n dest [ 3 ] = cm [ dest [ 3 ] ] ; \n dest [ 4 ] = cm [ dest [ 4 ] ] ; \n dest [ 5 ] = cm [ dest [ 5 ] ] ; \n dest [ 6 ] = cm [ dest [ 6 ] ] ; \n dest [ 7 ] = cm [ dest [ 7 ] ] ; \n dest += linesize ; \n } \n }", "idx": 5781}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter ( const uint8_t * src , int stride , int mode , int r ) \n { \n switch ( mode ) { \n case 0 : \n return src [ 0 ] ; \n case 1 : \n return ( -4 * src [ - stride ] + 53 * src [ 0 ] + 18 * src [ stride ] - 3 * src [ stride * 2 ] + 32 - r ) >> 6 ; \n case 2 : \n return ( - src [ - stride ] + 9 * src [ 0 ] + 9 * src [ stride ] - src [ stride * 2 ] + 8 - r ) >> 4 ; \n case 3 : \n return ( -3 * src [ - stride ] + 18 * src [ 0 ] + 53 * src [ stride ] - 4 * src [ stride * 2 ] + 32 - r ) >> 6 ; \n } \n return 0 ; \n }", "idx": 5789}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_nb_encode_init ( AVCodecContext * avctx ) \n { \n AMRContext * s = avctx -> priv_data ; \n if ( avctx -> sample_rate != 8000 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOSYS ) ; \n } \n avctx -> frame_size = 160 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n s -> enc_state = Encoder_Interface_init ( s -> enc_dtx ) ; \n if ( ! s -> enc_state ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> enc_mode = get_bitrate_mode ( avctx -> bit_rate , avctx ) ; \n s -> enc_bitrate = avctx -> bit_rate ; \n return 0 ; \n }", "idx": 5845}
{"project": "FFmpeg", "commit_id": "c6bdc90890250ce351b260eff69ce3c0d0745a62", "target": 1, "func": "void help ( void ) \n { \n printf ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" ) ; \n exit ( 1 ) ; \n }", "idx": 5846}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "func": "static int get_num ( ByteIOContext * pb , int * len ) \n { \n int n , n1 ; \n n = get_be16 ( pb ) ; \n ( * len ) -= 2 ; \n if ( n >= 0x4000 ) { \n return n - 0x4000 ; \n } else { \n n1 = get_be16 ( pb ) ; \n ( * len ) -= 2 ; \n return ( n << 16 ) | n1 ; \n } \n }", "idx": 5864}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC ( ff_h264_add_pixels8 ) ( uint8_t * _dst , int16_t * _src , int stride ) \n { \n int i ; \n pixel * dst = ( pixel * ) _dst ; \n dctcoef * src = ( dctcoef * ) _src ; \n stride /= sizeof ( pixel ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n dst [ 0 ] += src [ 0 ] ; \n dst [ 1 ] += src [ 1 ] ; \n dst [ 2 ] += src [ 2 ] ; \n dst [ 3 ] += src [ 3 ] ; \n dst [ 4 ] += src [ 4 ] ; \n dst [ 5 ] += src [ 5 ] ; \n dst [ 6 ] += src [ 6 ] ; \n dst [ 7 ] += src [ 7 ] ; \n dst += stride ; \n src += 8 ; \n } \n memset ( _src , 0 , sizeof ( dctcoef ) * 64 ) ; \n }", "idx": 5905}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int output_frame ( H264Context * h , AVFrame * dst , AVFrame * src ) \n { \n int i ; \n int ret = av_frame_ref ( dst , src ) ; \n if ( ret < 0 ) \n return ret ; \n if ( ! h -> sps . crop ) \n return 0 ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n int hshift = ( i > 0 ) ? h -> chroma_x_shift : 0 ; \n int vshift = ( i > 0 ) ? h -> chroma_y_shift : 0 ; \n int off = ( ( h -> sps . crop_left >> hshift ) << h -> pixel_shift ) + \n ( h -> sps . crop_top >> vshift ) * dst -> linesize [ i ] ; \n dst -> data [ i ] += off ; \n } \n return 0 ; \n }", "idx": 5908}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME ( yuv2rgb555_2 ) ( SwsContext * c , const uint16_t * buf0 , \n const uint16_t * buf1 , const uint16_t * ubuf0 , \n const uint16_t * ubuf1 , const uint16_t * vbuf0 , \n const uint16_t * vbuf1 , const uint16_t * abuf0 , \n const uint16_t * abuf1 , uint8_t * dest , \n int dstW , int yalpha , int uvalpha , int y ) \n { \n x86_reg uv_off = c -> uv_off << 1 ; \n __asm__ volatile ( \n \" \" REG_b \" \" ESP_OFFSET \" \\n \\t \" \n \" \" REG_b \" \\n \\t \" \n \" \" REG_BP \" \\n \\t \"  \n YSCALEYUV2RGB ( % % REGBP , % 5 , % 6 ) \n \" \\n \\t \"  \n #ifdef DITHER1XBPP \n \" \" BLUE_DITHER \" \\n \\t \" \n \" \" GREEN_DITHER \" \\n \\t \" \n \" \" RED_DITHER \" \\n \\t \" \n #endif \n WRITERGB15 ( % % REGb , 8280 ( % 5 ) , % % REGBP ) \n \" \" REG_BP \" \\n \\t \" \n \" \" ESP_OFFSET \" \" REG_b \" \\n \\t \" \n :: \" \" ( buf0 ) , \" \" ( buf1 ) , \" \" ( ubuf0 ) , \" \" ( ubuf1 ) , \" \" ( dest ) , \n \" \" ( & c -> redDither ) , \" \" ( uv_off ) \n ) ; \n }", "idx": 5981}
{"project": "FFmpeg", "commit_id": "1eaff98c8320d9ba48fbaec2a558f31f4104de98", "target": 1, "func": "static int flv_write_trailer ( AVFormatContext * s ) \n { \n int64_t file_size ; \n AVIOContext * pb = s -> pb ; \n FLVContext * flv = s -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVCodecContext * enc = s -> streams [ i ] -> codec ; \n FLVStreamContext * sc = s -> streams [ i ] -> priv_data ; \n if ( enc -> codec_type == AVMEDIA_TYPE_VIDEO && \n enc -> codec_id == AV_CODEC_ID_H264 ) \n put_avc_eos_tag ( pb , sc -> last_ts ) ; \n } \n file_size = avio_tell ( pb ) ; \n avio_seek ( pb , flv -> duration_offset , SEEK_SET ) ; \n put_amf_double ( pb , flv -> duration / ( double ) 1000 ) ; \n avio_seek ( pb , flv -> filesize_offset , SEEK_SET ) ; \n put_amf_double ( pb , file_size ) ; \n avio_seek ( pb , file_size , SEEK_SET ) ; \n return 0 ; \n }", "idx": 6103}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_mpv_frame_end ( MpegEncContext * s ) \n { \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration ) { \n ff_xvmc_field_end ( s ) ; \n } else \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n emms_c ( ) ; \n if ( s -> current_picture . reference ) \n ff_thread_report_progress ( & s -> current_picture_ptr -> tf , INT_MAX , 0 ) ; \n }", "idx": 6140}
{"project": "FFmpeg", "commit_id": "ff763351e74550df3b9a0465634d1ec48b15b043", "target": 1, "func": "static void uninit ( AVFilterContext * ctx ) \n { \n ZScaleContext * s = ctx -> priv ; \n zimg_filter_graph_free ( s -> graph ) ; \n av_freep ( & s -> tmp ) ; \n s -> tmp_size = 0 ; \n }", "idx": 6165}
{"project": "FFmpeg", "commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "target": 1, "func": "static void lpc_analyze_remodulate ( int32_t * decoded , const int coeffs [ 32 ] , \n int order , int qlevel , int len , int bps ) \n { \n int i , j ; \n int ebps = 1 << ( bps - 1 ) ; \n unsigned sigma = 0 ; \n for ( i = order ; i < len ; i ++ ) \n sigma |= decoded [ i ] + ebps ; \n if ( sigma < 2 * ebps ) \n return ; \n for ( i = len - 1 ; i >= order ; i -- ) { \n int64_t p = 0 ; \n for ( j = 0 ; j < order ; j ++ ) \n p += coeffs [ j ] * ( int64_t ) decoded [ i - order + j ] ; \n decoded [ i ] -= p >> qlevel ; \n } \n for ( i = order ; i < len ; i ++ , decoded ++ ) { \n int32_t p = 0 ; \n for ( j = 0 ; j < order ; j ++ ) \n p += coeffs [ j ] * ( uint32_t ) decoded [ j ] ; \n decoded [ j ] += p >> qlevel ; \n } \n }", "idx": 6272}
{"project": "FFmpeg", "commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "target": 1, "func": "static int calculate_bitrate ( AVFormatContext * s ) \n { \n AVIContext * avi = s -> priv_data ; \n int i , j ; \n int64_t lensum = 0 ; \n int64_t maxpos = 0 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n int64_t len = 0 ; \n AVStream * st = s -> streams [ i ] ; \n if ( ! st -> nb_index_entries ) \n continue ; \n for ( j = 0 ; j < st -> nb_index_entries ; j ++ ) \n len += st -> index_entries [ j ] . size ; \n maxpos = FFMAX ( maxpos , st -> index_entries [ j - 1 ] . pos ) ; \n lensum += len ; \n } \n if ( maxpos < avi -> io_fsize * 9 / 10 ) \n return 0 ; \n if ( lensum * 9 / 10 > maxpos || lensum < maxpos * 9 / 10 ) \n return 0 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n int64_t len = 0 ; \n AVStream * st = s -> streams [ i ] ; \n int64_t duration ; \n for ( j = 0 ; j < st -> nb_index_entries ; j ++ ) \n len += st -> index_entries [ j ] . size ; \n if ( st -> nb_index_entries < 2 || st -> codec -> bit_rate > 0 ) \n continue ; \n duration = st -> index_entries [ j - 1 ] . timestamp - st -> index_entries [ 0 ] . timestamp ; \n st -> codec -> bit_rate = av_rescale ( 8 * len , st -> time_base . den , duration * st -> time_base . num ) ; \n } \n return 1 ; \n }", "idx": 6307}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME ( yuy2ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , long width ) \n { \n #ifdef HAVE_MMX \n asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm4 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( - width ) , \" \" ( src1 + width * 4 ) , \" \" ( dstU + width ) , \" \" ( dstV + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = src1 [ 4 * i + 1 ] ; \n dstV [ i ] = src1 [ 4 * i + 3 ] ; \n } \n #endif \n assert ( src1 == src2 ) ; \n }", "idx": 6432}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_v_loop_filter_c ( uint8_t * dest , uint8_t * src , int stride ) { \n int i , j , xy , yz ; \n int res ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n for ( j = 1 ; j < 7 ; j ++ ) { \n xy = j * stride + i ; \n yz = j * 8 + i ; \n res = ( int ) src [ yz - 1 * 8 ] + ( ( int ) ( src [ yz + 0 * 8 ] ) * 2 ) + ( int ) src [ yz + 1 * 8 ] ; \n res += 2 ; \n res >>= 2 ; \n dest [ xy ] = ( uint8_t ) res ; \n } \n } \n }", "idx": 6452}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( uyvyToY ) ( uint8_t * dst , const uint8_t * src , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  __asm__ volatile ( \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( x86_reg ) - width ) , \" \" ( src + width * 2 ) , \" \" ( dst + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = src [ 2 * i + 1 ] ; \n #endif \n }", "idx": 6455}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yv12touyvy ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n unsigned int width , unsigned int height , \n int lumStride , int chromStride , int dstStride ) \n { \n RENAME ( yuvPlanartouyvy ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 2 ) ; \n }", "idx": 6519}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_ext_content ( AVFormatContext * s , const GUIDParseTable * g ) \n { \n ASFContext * asf = s -> priv_data ; \n AVIOContext * pb = s -> pb ; \n uint64_t size = avio_rl64 ( pb ) ; \n uint16_t nb_desc = avio_rl16 ( pb ) ; \n int i , ret ; \n for ( i = 0 ; i < nb_desc ; i ++ ) { \n uint16_t name_len , type , val_len ; \n uint8_t * name = NULL ; \n name_len = avio_rl16 ( pb ) ; \n if ( ! name_len ) \n return AVERROR_INVALIDDATA ; \n name = av_malloc ( name_len ) ; \n if ( ! name ) \n return AVERROR ( ENOMEM ) ; \n avio_get_str16le ( pb , name_len , name , \n name_len ) ; \n type = avio_rl16 ( pb ) ; \n val_len = avio_rl16 ( pb ) ; \n if ( ( ret = process_metadata ( s , name , name_len , val_len , type , & s -> metadata ) ) < 0 ) \n return ret ; \n } \n align_position ( pb , asf -> offset , size ) ; \n return 0 ; \n }", "idx": 6543}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static void input_callback ( MMAL_PORT_T * port , MMAL_BUFFER_HEADER_T * buffer ) \n { \n if ( ! buffer -> cmd ) { \n AVBufferRef * buf = buffer -> user_data ; \n av_buffer_unref ( & buf ) ; \n } \n mmal_buffer_header_release ( buffer ) ; \n }", "idx": 6575}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter ( uint8_t * src , \n const int step , \n const int stride , \n const int filter_p1 , \n const int filter_q1 , \n const int alpha , \n const int beta , \n const int lim_p0q0 , \n const int lim_q1 , \n const int lim_p1 ) \n { \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n int i , t , u , diff ; \n for ( i = 0 ; i < 4 ; i ++ , src += stride ) { \n int diff_p1p0 = src [ -2 * step ] - src [ -1 * step ] ; \n int diff_q1q0 = src [ 1 * step ] - src [ 0 * step ] ; \n int diff_p1p2 = src [ -2 * step ] - src [ -3 * step ] ; \n int diff_q1q2 = src [ 1 * step ] - src [ 2 * step ] ; \n t = src [ 0 * step ] - src [ -1 * step ] ; \n if ( ! t ) \n continue ; \n u = ( alpha * FFABS ( t ) ) >> 7 ; \n if ( u > 3 - ( filter_p1 && filter_q1 ) ) \n continue ; \n t <<= 2 ; \n if ( filter_p1 && filter_q1 ) \n t += src [ -2 * step ] - src [ 1 * step ] ; \n diff = CLIP_SYMM ( ( t + 4 ) >> 3 , lim_p0q0 ) ; \n src [ -1 * step ] = cm [ src [ -1 * step ] + diff ] ; \n src [ 0 * step ] = cm [ src [ 0 * step ] - diff ] ; \n if ( filter_p1 && FFABS ( diff_p1p2 ) <= beta ) { \n t = ( diff_p1p0 + diff_p1p2 - diff ) >> 1 ; \n src [ -2 * step ] = cm [ src [ -2 * step ] - CLIP_SYMM ( t , lim_p1 ) ] ; \n } \n if ( filter_q1 && FFABS ( diff_q1q2 ) <= beta ) { \n t = ( diff_q1q0 + diff_q1q2 + diff ) >> 1 ; \n src [ 1 * step ] = cm [ src [ 1 * step ] - CLIP_SYMM ( t , lim_q1 ) ] ; \n } \n } \n }", "idx": 6646}
{"project": "FFmpeg", "commit_id": "8772d2511a4ac45f275eaef2b4b6b1ef132c993b", "target": 1, "func": "static int normalize_bits ( int num , int width ) \n { \n if ( ! num ) \n return 0 ; \n if ( num == -1 ) \n return width ; \n if ( num < 0 ) \n num = ~ num ; \n return width - av_log2 ( num ) ; \n }", "idx": 6670}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static int srt_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_sub_ptr , AVPacket * avpkt ) \n { \n AVSubtitle * sub = data ; \n AVBPrint buffer ; \n int x1 = -1 , y1 = -1 , x2 = -1 , y2 = -1 ; \n int size , ret ; \n const uint8_t * p = av_packet_get_side_data ( avpkt , AV_PKT_DATA_SUBTITLE_POSITION , & size ) ; \n FFASSDecoderContext * s = avctx -> priv_data ; \n if ( p && size == 16 ) { \n x1 = AV_RL32 ( p ) ; \n y1 = AV_RL32 ( p + 4 ) ; \n x2 = AV_RL32 ( p + 8 ) ; \n y2 = AV_RL32 ( p + 12 ) ; \n } \n if ( avpkt -> size <= 0 ) \n return avpkt -> size ; \n av_bprint_init ( & buffer , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; \n srt_to_ass ( avctx , & buffer , avpkt -> data , x1 , y1 , x2 , y2 ) ; \n ret = ff_ass_add_rect ( sub , buffer . str , s -> readorder ++ , 0 , NULL , NULL ) ; \n av_bprint_finalize ( & buffer , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n * got_sub_ptr = sub -> num_rects > 0 ; \n return avpkt -> size ; \n }", "idx": 6708}
{"project": "FFmpeg", "commit_id": "7a206eb32f624171a35235f714d44ee9dec9abcb", "target": 0, "func": "static int alac_set_info ( ALACContext * alac ) \n { \n GetByteContext gb ; \n bytestream2_init ( & gb , alac -> avctx -> extradata , \n alac -> avctx -> extradata_size ) ; \n bytestream2_skipu ( & gb , 12 ) ; \n alac -> max_samples_per_frame = bytestream2_get_be32u ( & gb ) ; \n if ( alac -> max_samples_per_frame >= UINT_MAX / 4 ) { \n av_log ( alac -> avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n bytestream2_skipu ( & gb , 1 ) ; \n alac -> sample_size = bytestream2_get_byteu ( & gb ) ; \n alac -> rice_history_mult = bytestream2_get_byteu ( & gb ) ; \n alac -> rice_initial_history = bytestream2_get_byteu ( & gb ) ; \n alac -> rice_limit = bytestream2_get_byteu ( & gb ) ; \n alac -> channels = bytestream2_get_byteu ( & gb ) ; \n bytestream2_get_be16u ( & gb ) ; \n bytestream2_get_be32u ( & gb ) ; \n bytestream2_get_be32u ( & gb ) ; \n bytestream2_get_be32u ( & gb ) ; \n return 0 ; \n }", "idx": 6879}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int slice_end ( AVCodecContext * avctx , AVFrame * pict ) \n { \n Mpeg1Context * s1 = avctx -> priv_data ; \n MpegEncContext * s = & s1 -> mpeg_enc_ctx ; \n if ( ! s1 -> mpeg_enc_ctx_allocated || ! s -> current_picture_ptr ) \n return 0 ; \n if ( s -> avctx -> hwaccel ) { \n if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n } \n #if FF_API_XVMC  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration )  \n ff_xvmc_field_end ( s ) ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( \n ! s -> first_field ) { \n ff_er_frame_end ( & s -> er ) ; \n ff_MPV_frame_end ( s ) ; \n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { \n int ret = av_frame_ref ( pict , & s -> current_picture_ptr -> f ) ; \n if ( ret < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> current_picture_ptr ) ; \n } else { \n if ( avctx -> active_thread_type & FF_THREAD_FRAME ) \n s -> picture_number ++ ; \n if ( s -> last_picture_ptr != NULL ) { \n int ret = av_frame_ref ( pict , & s -> last_picture_ptr -> f ) ; \n if ( ret < 0 ) \n return ret ; \n ff_print_debug_info ( s , s -> last_picture_ptr ) ; \n } \n } \n return 1 ; \n } else { \n return 0 ; \n } \n }", "idx": 6956}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static void stream_close ( VideoState * is ) \n { \n VideoPicture * vp ; \n int i ; \n is -> abort_request = 1 ; \n SDL_WaitThread ( is -> read_tid , NULL ) ; \n SDL_WaitThread ( is -> refresh_tid , NULL ) ; \n packet_queue_destroy ( & is -> videoq ) ; \n packet_queue_destroy ( & is -> audioq ) ; \n packet_queue_destroy ( & is -> subtitleq ) ; \n for ( i = 0 ; i < VIDEO_PICTURE_QUEUE_SIZE ; i ++ ) { \n vp = & is -> pictq [ i ] ; \n #if CONFIG_AVFILTER  \n  \n  avfilter_unref_bufferp ( & vp -> picref ) ; \n #endif \n if ( vp -> bmp ) { \n SDL_FreeYUVOverlay ( vp -> bmp ) ; \n vp -> bmp = NULL ; \n } \n } \n SDL_DestroyMutex ( is -> pictq_mutex ) ; \n SDL_DestroyCond ( is -> pictq_cond ) ; \n SDL_DestroyMutex ( is -> subpq_mutex ) ; \n SDL_DestroyCond ( is -> subpq_cond ) ; \n SDL_DestroyCond ( is -> continue_read_thread ) ; \n #if ! CONFIG_AVFILTER  \n  \n  sws_freeContext ( is -> img_convert_ctx ) ; \n #endif \n av_free ( is ) ; \n }", "idx": 6997}
{"project": "FFmpeg", "commit_id": "560b10a6c3627cccf6735170d370cf9e3d38e805", "target": 1, "func": "static void init_gain_table ( COOKContext * q ) { \n int i ; \n q -> gain_size_factor = q -> samples_per_channel / 8 ; \n for ( i = 0 ; i < 23 ; i ++ ) { \n q -> gain_table [ i ] = pow ( ( double ) q -> pow2tab [ i + 52 ] , \n ( 1.0 / ( double ) q -> gain_size_factor ) ) ; \n } \n memset ( & q -> gain_copy , 0 , sizeof ( COOKgain ) ) ; \n memset ( & q -> gain_current , 0 , sizeof ( COOKgain ) ) ; \n memset ( & q -> gain_now , 0 , sizeof ( COOKgain ) ) ; \n memset ( & q -> gain_previous , 0 , sizeof ( COOKgain ) ) ; \n }", "idx": 6999}
{"project": "FFmpeg", "commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "target": 1, "func": "static int get_buffer_sao ( HEVCContext * s , AVFrame * frame , const HEVCSPS * sps ) \n { \n int ret , i ; \n frame -> width = s -> avctx -> width + 2 ; \n frame -> height = s -> avctx -> height + 2 ; \n if ( ( ret = ff_get_buffer ( s -> avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) \n return ret ; \n for ( i = 0 ; frame -> data [ i ] ; i ++ ) { \n int offset = frame -> linesize [ i ] + ( 1 << sps -> pixel_shift ) ; \n frame -> data [ i ] += offset ; \n } \n frame -> width = s -> avctx -> width ; \n frame -> height = s -> avctx -> height ; \n return 0 ; \n }", "idx": 7048}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void prepare_app_arguments ( int * argc_ptr , char * * * argv_ptr ) \n { \n char * argstr_flat ; \n wchar_t * * argv_w ; \n int i , buffsize = 0 , offset = 0 ; \n if ( win32_argv_utf8 ) { \n * argc_ptr = win32_argc ; \n * argv_ptr = win32_argv_utf8 ; \n return ; \n } \n win32_argc = 0 ; \n argv_w = CommandLineToArgvW ( GetCommandLineW ( ) , & win32_argc ) ; \n if ( win32_argc <= 0 || ! argv_w ) \n return ; \n for ( i = 0 ; i < win32_argc ; i ++ ) \n buffsize += WideCharToMultiByte ( CP_UTF8 , 0 , argv_w [ i ] , -1 , \n NULL , 0 , NULL , NULL ) ; \n win32_argv_utf8 = av_mallocz ( sizeof ( char * ) * ( win32_argc + 1 ) + buffsize ) ; \n argstr_flat = ( char * ) win32_argv_utf8 + sizeof ( char * ) * ( win32_argc + 1 ) ; \n if ( win32_argv_utf8 == NULL ) { \n LocalFree ( argv_w ) ; \n return ; \n } \n for ( i = 0 ; i < win32_argc ; i ++ ) { \n win32_argv_utf8 [ i ] = & argstr_flat [ offset ] ; \n offset += WideCharToMultiByte ( CP_UTF8 , 0 , argv_w [ i ] , -1 , \n & argstr_flat [ offset ] , \n buffsize - offset , NULL , NULL ) ; \n } \n win32_argv_utf8 [ i ] = NULL ; \n LocalFree ( argv_w ) ; \n * argc_ptr = win32_argc ; \n * argv_ptr = win32_argv_utf8 ; \n }", "idx": 7111}
{"project": "FFmpeg", "commit_id": "2f996b8397ee0e646a824f3dfcbd291a114af348", "target": 0, "func": "int MP3lame_encode_frame ( AVCodecContext * avctx , \n unsigned char * frame , int buf_size , void * data ) \n { \n Mp3AudioContext * s = avctx -> priv_data ; \n int num , i ; \n if ( s -> stereo ) { \n num = lame_encode_buffer_interleaved ( s -> gfp , data , \n MPA_FRAME_SIZE , frame , buf_size ) ; \n } else { \n num = lame_encode_buffer ( s -> gfp , data , data , MPA_FRAME_SIZE , \n frame , buf_size ) ; \n } \n return num ; \n }", "idx": 7122}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_b_picture_secondary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int status ; \n bitplane_decoding ( & v -> skip_mb_plane , v ) ; \n if ( status < 0 ) return -1 ; \n #if TRACE  \n  \n  if ( v -> mv_mode == MV_PMODE_MIXED_MV ) \n { \n status = bitplane_decoding ( & v -> mv_type_mb_plane , v ) ; \n if ( status < 0 ) \n return -1 ; \n #if TRACE  \n  \n  av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , status >> 1 , status & 1 ) ; \n #endif \n } \n status = bitplane_decoding ( & v -> direct_mb_plane , v ) ; \n if ( status < 0 ) return -1 ; \n #if TRACE  \n  \n  av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , status >> 1 , status & 1 ) ; \n #endif \n av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , status >> 1 , status & 1 ) ; \n #endif \n v -> s . mv_table_index = get_bits ( gb , 2 ) ; \n v -> cbpcy_vlc = & vc9_cbpcy_p_vlc [ get_bits ( gb , 2 ) ] ; \n if ( v -> dquant ) \n { \n vop_dquant_decoding ( v ) ; \n } \n if ( v -> vstransform ) \n { \n v -> ttmbf = get_bits ( gb , 1 ) ; \n if ( v -> ttmbf ) \n { \n v -> ttfrm = get_bits ( gb , 2 ) ; \n av_log ( v -> s . avctx , AV_LOG_INFO , \" \\n \" , \n ( v -> ttfrm & 2 ) ? 4 : 8 , ( v -> ttfrm & 1 ) ? 4 : 8 ) ; \n } \n } \n return 0 ; \n }", "idx": 7130}
{"project": "FFmpeg", "commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "target": 1, "func": "static int mxf_get_stream_index ( AVFormatContext * s , KLVPacket * klv ) \n { \n int i ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n MXFTrack * track = s -> streams [ i ] -> priv_data ; \n if ( ! memcmp ( klv -> key + sizeof ( mxf_essence_element_key ) , track -> track_number , sizeof ( track -> track_number ) ) ) \n return i ; \n } \n return s -> nb_streams == 1 ? 0 : -1 ; \n }", "idx": 7150}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME ( yuy2ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) \n { \n #if defined ( HAVE_MMX2 ) || defined ( HAVE_3DNOW )  \n  \n  asm volatile ( \n \" movq \" MANGLE ( bm01010101 ) \" , % % mm4 n\\ t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \"  \n PAVGB ( % % mm2 , % % mm0 ) \n PAVGB ( % % mm3 , % % mm1 ) \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \" REG_a \" \\n \\t \" \n \" \\n \\t \" \n : : \" g \" ( ( long ) - width ) , \" \" ( src1 + width * 4 ) , \" \" ( src2 + width * 4 ) , \" \" ( dstU + width ) , \" \" ( dstV + width ) \n : \" % \" \n ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) \n { \n dstU [ i ] = ( src1 [ 4 * i + 1 ] + src2 [ 4 * i + 1 ] ) >> 1 ; \n dstV [ i ] = ( src1 [ 4 * i + 3 ] + src2 [ 4 * i + 3 ] ) >> 1 ; \n } \n #endif \n }", "idx": 7174}
{"project": "FFmpeg", "commit_id": "6e1b1a27a4034c578018d5042b3c8228278c4cd6", "target": 1, "func": "static int copy_packet_data ( AVPacket * pkt , AVPacket * src , int dup ) \n { \n pkt -> data = NULL ; \n pkt -> side_data = NULL ; \n if ( pkt -> buf ) { \n AVBufferRef * ref = av_buffer_ref ( src -> buf ) ; \n if ( ! ref ) \n return AVERROR ( ENOMEM ) ; \n pkt -> buf = ref ; \n pkt -> data = ref -> data ; \n } else { \n DUP_DATA ( pkt -> data , src -> data , pkt -> size , 1 , ALLOC_BUF ) ; \n } \n #if FF_API_DESTRUCT_PACKET  \n  \n  FF_DISABLE_DEPRECATION_WARNINGS \n pkt -> destruct = dummy_destruct_packet ; \n FF_ENABLE_DEPRECATION_WARNINGS  \n #endif \n if ( pkt -> side_data_elems && dup ) \n pkt -> side_data = src -> side_data ; \n if ( pkt -> side_data_elems && ! dup ) { \n return av_copy_packet_side_data ( pkt , src ) ; \n } \n return 0 ; \n failed_alloc : \n av_destruct_packet ( pkt ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 7204}
{"project": "FFmpeg", "commit_id": "3b9a913db4d303a0305a80de496b1933cba8980f", "target": 1, "func": "offset_t url_fseek ( ByteIOContext * s , offset_t offset , int whence ) \n { \n offset_t offset1 ; \n offset_t pos = s -> pos - ( s -> write_flag ? 0 : ( s -> buf_end - s -> buffer ) ) ; \n if ( whence != SEEK_CUR && whence != SEEK_SET ) \n return - EINVAL ; \n if ( whence == SEEK_CUR ) { \n offset1 = pos + ( s -> buf_ptr - s -> buffer ) ; \n if ( offset == 0 ) \n return offset1 ; \n offset += offset1 ; \n } \n offset1 = offset - pos ; \n if ( ! s -> must_flush && \n offset1 >= 0 && offset1 < ( s -> buf_end - s -> buffer ) ) { \n s -> buf_ptr = s -> buffer + offset1 ; \n } else { \n if ( ! s -> seek ) \n return - EPIPE ; \n #ifdef CONFIG_MUXERS \n if ( s -> write_flag ) { \n flush_buffer ( s ) ; \n s -> must_flush = 1 ; \n } else \n #endif \n { \n s -> buf_end = s -> buffer ; \n } \n s -> buf_ptr = s -> buffer ; \n if ( s -> seek ( s -> opaque , offset , SEEK_SET ) == ( offset_t ) - EPIPE ) \n return - EPIPE ; \n s -> pos = offset ; \n } \n s -> eof_reached = 0 ; \n return offset ; \n }", "idx": 7351}
{"project": "FFmpeg", "commit_id": "1f28a991effadc64acd6915805b989ab43500f08", "target": 0, "func": "static int decode_unregistered_user_data ( H264SEIUnregistered * h , GetBitContext * gb , \n void * logctx , int size ) \n { \n uint8_t * user_data ; \n int e , build , i ; \n if ( size < 16 || size >= INT_MAX - 16 ) \n return AVERROR_INVALIDDATA ; \n user_data = av_malloc ( 16 + size + 1 ) ; \n if ( ! user_data ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < size + 16 ; i ++ ) \n user_data [ i ] = get_bits ( gb , 8 ) ; \n user_data [ i ] = 0 ; \n e = sscanf ( user_data + 16 , \" \" , & build ) ; \n if ( e == 1 && build > 0 ) \n h -> x264_build = build ; \n if ( e == 1 && build == 1 && ! strncmp ( user_data + 16 , \" \" , 16 ) ) \n h -> x264_build = 67 ; \n if ( strlen ( user_data + 16 ) > 0 ) \n av_log ( logctx , AV_LOG_DEBUG , \" \\\" \\\" \\n \" , user_data + 16 ) ; \n av_free ( user_data ) ; \n return 0 ; \n }", "idx": 7471}
{"project": "FFmpeg", "commit_id": "ae21776207e8a2bbe268e7c9e203f7599dd87ddb", "target": 0, "func": "void avfilter_filter_samples ( AVFilterLink * link , AVFilterBufferRef * samplesref ) \n { \n void ( * filter_samples ) ( AVFilterLink * , AVFilterBufferRef * ) ; \n AVFilterPad * dst = link -> dstpad ; \n int i ; \n FF_DPRINTF_START ( NULL , filter_samples ) ; ff_dlog_link ( NULL , link , 1 ) ; \n if ( ! ( filter_samples = dst -> filter_samples ) ) \n filter_samples = avfilter_default_filter_samples ; \n if ( ( dst -> min_perms & samplesref -> perms ) != dst -> min_perms || \n dst -> rej_perms & samplesref -> perms ) { \n av_log ( link -> dst , AV_LOG_DEBUG , \n \" \\n \" , \n samplesref -> perms , link -> dstpad -> min_perms , link -> dstpad -> rej_perms ) ; \n link -> cur_buf = avfilter_default_get_audio_buffer ( link , dst -> min_perms , \n samplesref -> audio -> nb_samples ) ; \n link -> cur_buf -> pts = samplesref -> pts ; \n link -> cur_buf -> audio -> sample_rate = samplesref -> audio -> sample_rate ; \n for ( i = 0 ; samplesref -> data [ i ] ; i ++ ) \n memcpy ( link -> cur_buf -> data [ i ] , samplesref -> data [ i ] , samplesref -> linesize [ 0 ] ) ; \n avfilter_unref_buffer ( samplesref ) ; \n } else \n link -> cur_buf = samplesref ; \n filter_samples ( link , link -> cur_buf ) ; \n }", "idx": 7472}
{"project": "FFmpeg", "commit_id": "596b5c488fa1d40f114a64d3b73e1863cab073fb", "target": 0, "func": "static av_cold void init_coef_vlc ( VLC * vlc , uint16_t * * prun_table , \n float * * plevel_table , uint16_t * * pint_table , \n const CoefVLCTable * vlc_table ) \n { \n int n = vlc_table -> n ; \n const uint8_t * table_bits = vlc_table -> huffbits ; \n const uint32_t * table_codes = vlc_table -> huffcodes ; \n const uint16_t * levels_table = vlc_table -> levels ; \n uint16_t * run_table , * level_table , * int_table ; \n float * flevel_table ; \n int i , l , j , k , level ; \n init_vlc ( vlc , VLCBITS , n , table_bits , 1 , 1 , table_codes , 4 , 4 , 0 ) ; \n run_table = av_malloc ( n * sizeof ( uint16_t ) ) ; \n level_table = av_malloc ( n * sizeof ( uint16_t ) ) ; \n flevel_table = av_malloc ( n * sizeof ( * flevel_table ) ) ; \n int_table = av_malloc ( n * sizeof ( uint16_t ) ) ; \n i = 2 ; \n level = 1 ; \n k = 0 ; \n while ( i < n ) { \n int_table [ k ] = i ; \n l = levels_table [ k ++ ] ; \n for ( j = 0 ; j < l ; j ++ ) { \n run_table [ i ] = j ; \n level_table [ i ] = level ; \n flevel_table [ i ] = level ; \n i ++ ; \n } \n level ++ ; \n } \n * prun_table = run_table ; \n * plevel_table = flevel_table ; \n * pint_table = int_table ; \n av_free ( level_table ) ; \n }", "idx": 7598}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame ( AVFilterContext * ctx ) \n { \n TileContext * tile = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n AVFilterBufferRef * out_buf = outlink -> out_buf ; \n outlink -> out_buf = NULL ; \n ff_start_frame ( outlink , out_buf ) ; \n while ( tile -> current < tile -> nb_frames ) \n draw_blank_frame ( ctx , out_buf ) ; \n ff_draw_slice ( outlink , 0 , out_buf -> video -> h , 1 ) ; \n ff_end_frame ( outlink ) ; \n tile -> current = 0 ; \n }", "idx": 7649}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "void av_register_output_format ( AVOutputFormat * format ) \n { \n AVOutputFormat * * p = & first_oformat ; \n while ( * p != NULL ) \n p = & ( * p ) -> next ; \n * p = format ; \n format -> next = NULL ; \n }", "idx": 7651}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef * avfilter_get_video_buffer_ref_from_frame ( const AVFrame * frame , \n int perms ) \n { \n AVFilterBufferRef * picref = \n avfilter_get_video_buffer_ref_from_arrays ( frame -> data , frame -> linesize , perms , \n frame -> width , frame -> height , \n frame -> format ) ; \n if ( ! picref ) \n return NULL ; \n avfilter_copy_frame_props ( picref , frame ) ; \n return picref ; \n }", "idx": 7659}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static OutputStream * new_audio_stream ( OptionsContext * o , AVFormatContext * oc ) \n { \n AVStream * st ; \n OutputStream * ost ; \n AVCodecContext * audio_enc ; \n ost = new_output_stream ( o , oc , AVMEDIA_TYPE_AUDIO ) ; \n st = ost -> st ; \n audio_enc = st -> codec ; \n audio_enc -> codec_type = AVMEDIA_TYPE_AUDIO ; \n if ( ! ost -> stream_copy ) { \n char * sample_fmt = NULL ; \n MATCH_PER_STREAM_OPT ( audio_channels , i , audio_enc -> channels , oc , st ) ; \n MATCH_PER_STREAM_OPT ( sample_fmts , str , sample_fmt , oc , st ) ; \n if ( sample_fmt && \n ( audio_enc -> sample_fmt = av_get_sample_fmt ( sample_fmt ) ) == AV_SAMPLE_FMT_NONE ) { \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , sample_fmt ) ; \n exit_program ( 1 ) ; \n } \n MATCH_PER_STREAM_OPT ( audio_sample_rate , i , audio_enc -> sample_rate , oc , st ) ; \n } \n return ost ; \n }", "idx": 7666}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_shutdown ( URLContext * h , int flags ) \n { \n if ( ! h -> prot -> url_shutdown ) \n return AVERROR ( EINVAL ) ; \n return h -> prot -> url_shutdown ( h , flags ) ; \n }", "idx": 7729}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int get_packetheader ( NUTContext * nut , ByteIOContext * bc , int prefix_length , int calculate_checksum ) \n { \n int64_t start , size , last_size ; \n start = url_ftell ( bc ) - prefix_length ; \n if ( start != nut -> packet_start + nut -> written_packet_size ) { \n av_log ( nut -> avf , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( calculate_checksum ) \n init_checksum ( bc , update_adler32 , 0 ) ; \n size = get_v ( bc ) ; \n last_size = get_v ( bc ) ; \n if ( nut -> written_packet_size != last_size ) { \n av_log ( nut -> avf , AV_LOG_ERROR , \" \\n \" , nut -> written_packet_size , last_size , start ) ; \n return -1 ; \n } \n nut -> last_packet_start = nut -> packet_start ; \n nut -> packet_start = start ; \n nut -> written_packet_size = size ; \n return size ; \n }", "idx": 7777}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "int ff_mpeg1_find_frame_end ( ParseContext * pc , const uint8_t * buf , int buf_size ) \n { \n int i ; \n uint32_t state = pc -> state ; \n if ( buf_size == 0 ) \n return 0 ; \n for ( i = 0 ; i < buf_size ; i ++ ) { \n assert ( pc -> frame_start_found >= 0 && pc -> frame_start_found <= 4 ) ; \n if ( pc -> frame_start_found & 1 ) { \n if ( state == EXT_START_CODE && ( buf [ i ] & 0xF0 ) != 0x80 ) \n pc -> frame_start_found -- ; \n else if ( state == EXT_START_CODE + 2 ) { \n if ( ( buf [ i ] & 3 ) == 3 ) pc -> frame_start_found = 0 ; \n else pc -> frame_start_found = ( pc -> frame_start_found + 1 ) & 3 ; \n } \n state ++ ; \n } else { \n i = ff_find_start_code ( buf + i , buf + buf_size , & state ) - buf - 1 ; \n if ( pc -> frame_start_found == 0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE ) { \n i ++ ; \n pc -> frame_start_found = 4 ; \n } \n if ( state == SEQ_END_CODE ) { \n pc -> state = -1 ; \n return i + 1 ; \n } \n if ( pc -> frame_start_found == 2 && state == SEQ_START_CODE ) \n pc -> frame_start_found = 0 ; \n if ( pc -> frame_start_found < 4 && state == EXT_START_CODE ) \n pc -> frame_start_found ++ ; \n if ( pc -> frame_start_found == 4 && ( state & 0xFFFFFF00 ) == 0x100 ) { \n if ( state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE ) { \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n return i - 3 ; \n } \n } \n } \n } \n pc -> state = state ; \n return END_NOT_FOUND ; \n }", "idx": 7834}
{"project": "FFmpeg", "commit_id": "bf2cba453244a74331238a472fe0e309f116f4d9", "target": 1, "func": "yuv2rgb_2_c_template ( SwsContext * c , const int16_t * buf [ 2 ] , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf [ 2 ] , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y , \n enum PixelFormat target , int hasAlpha )  \n { \n const int16_t * buf0 = buf [ 0 ] , * buf1 = buf [ 1 ] , \n * ubuf0 = ubuf [ 0 ] , * ubuf1 = ubuf [ 1 ] , \n * vbuf0 = vbuf [ 0 ] , * vbuf1 = vbuf [ 1 ] , \n * abuf0 = abuf [ 0 ] , * abuf1 = abuf [ 1 ] ; \n int yalpha1 = 4095 - yalpha ; \n int uvalpha1 = 4095 - uvalpha ; \n int i ; \n for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { \n int Y1 = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int Y2 = ( buf0 [ i * 2 + 1 ] * yalpha1 + buf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n int U = ( ubuf0 [ i ] * uvalpha1 + ubuf1 [ i ] * uvalpha ) >> 19 ; \n int V = ( vbuf0 [ i ] * uvalpha1 + vbuf1 [ i ] * uvalpha ) >> 19 ; \n int A1 , A2 ; \n const void * r = c -> table_rV [ V ] , \n * g = ( c -> table_gU [ U ] + c -> table_gV [ V ] ) , \n * b = c -> table_bU [ U ] ; \n if ( hasAlpha ) { \n A1 = ( abuf0 [ i * 2 ] * yalpha1 + abuf1 [ i * 2 ] * yalpha ) >> 19 ; \n A2 = ( abuf0 [ i * 2 + 1 ] * yalpha1 + abuf1 [ i * 2 + 1 ] * yalpha ) >> 19 ; \n } \n yuv2rgb_write ( dest , i , Y1 , Y2 , U , V , hasAlpha ? A1 : 0 , hasAlpha ? A2 : 0 , \n r , g , b , y , target , hasAlpha ) ; \n } \n }", "idx": 7885}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static int minimum_frame_bits ( VC2EncContext * s ) \n { \n int slice_x , slice_y , bits = 0 ; \n s -> size_scaler = 64 ; \n for ( slice_y = 0 ; slice_y < s -> num_y ; slice_y ++ ) { \n for ( slice_x = 0 ; slice_x < s -> num_x ; slice_x ++ ) { \n bits += count_hq_slice ( s , NULL , slice_x , slice_y , s -> q_ceil ) ; \n } \n } \n return bits ; \n }", "idx": 7892}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static inline int get_chroma_qp ( H264Context * h , int t , int qscale ) { \n return h -> pps . chroma_qp_table [ t ] [ qscale ] ; \n }", "idx": 7977}
{"project": "FFmpeg", "commit_id": "dc5d1515681b57a257443ba72bb81fb3e6e6621b", "target": 0, "func": "static int replace_int_data_in_filename ( char * buf , int buf_size , const char * filename , char placeholder , int64_t number ) \n { \n const char * p ; \n char * q , buf1 [ 20 ] , c ; \n int nd , len , addchar_count ; \n int found_count = 0 ; \n q = buf ; \n p = filename ; \n for ( ; ; ) { \n c = * p ; \n if ( c == ' \\0 ' ) \n break ; \n if ( c == ' ' && * ( p + 1 ) == ' ' ) \n addchar_count = 2 ; \n else if ( c == ' ' && ( av_isdigit ( * ( p + 1 ) ) || * ( p + 1 ) == placeholder ) ) { \n nd = 0 ; \n addchar_count = 1 ; \n while ( av_isdigit ( * ( p + addchar_count ) ) ) { \n nd = nd * 10 + * ( p + addchar_count ) - ' ' ; \n addchar_count ++ ; \n } \n if ( * ( p + addchar_count ) == placeholder ) { \n len = snprintf ( buf1 , sizeof ( buf1 ) , \" \" PRId64 , ( number < 0 ) ? nd : nd ++ , number ) ; \n if ( len < 1 ) \n goto fail ; \n if ( ( q - buf + len ) > buf_size - 1 ) \n goto fail ; \n memcpy ( q , buf1 , len ) ; \n q += len ; \n p += ( addchar_count + 1 ) ; \n addchar_count = 0 ; \n found_count ++ ; \n } \n } else \n addchar_count = 1 ; \n while ( addchar_count -- ) \n if ( ( q - buf ) < buf_size - 1 ) \n * q ++ = * p ++ ; \n else \n goto fail ; \n } \n * q = ' \\0 ' ; \n return found_count ; \n fail : \n * q = ' \\0 ' ; \n return -1 ; \n }", "idx": 8046}
{"project": "FFmpeg", "commit_id": "aa6aa2ef091818c2669c48051286ce361401f31b", "target": 0, "func": "static void apply_window_and_mdct ( AVCodecContext * avctx , const AVFrame * frame ) \n { \n WMACodecContext * s = avctx -> priv_data ; \n float * * audio = ( float * * ) frame -> extended_data ; \n int len = frame -> nb_samples ; \n int window_index = s -> frame_len_bits - s -> block_len_bits ; \n FFTContext * mdct = & s -> mdct_ctx [ window_index ] ; \n int ch ; \n const float * win = s -> windows [ window_index ] ; \n int window_len = 1 << s -> block_len_bits ; \n float n = 2.0 * 32768.0 / window_len ; \n for ( ch = 0 ; ch < avctx -> channels ; ch ++ ) { \n memcpy ( s -> output , s -> frame_out [ ch ] , window_len * sizeof ( * s -> output ) ) ; \n s -> fdsp -> vector_fmul_scalar ( s -> frame_out [ ch ] , audio [ ch ] , n , len ) ; \n s -> fdsp -> vector_fmul_reverse ( & s -> output [ window_len ] , s -> frame_out [ ch ] , \n win , len ) ; \n s -> fdsp -> vector_fmul ( s -> frame_out [ ch ] , s -> frame_out [ ch ] , win , len ) ; \n mdct -> mdct_calc ( mdct , s -> coefs [ ch ] , s -> output ) ; \n } \n }", "idx": 8085}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void diff_pixels_altivec ( int16_t * restrict block , const uint8_t * s1 , \n const uint8_t * s2 , int stride ) \n { \n int i ; \n vec_u8 perm1 = vec_lvsl ( 0 , s1 ) ; \n vec_u8 perm2 = vec_lvsl ( 0 , s2 ) ; \n const vec_u8 zero = ( const vec_u8 ) vec_splat_u8 ( 0 ) ; \n vec_s16 shorts1 , shorts2 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n vec_u8 pixl = vec_ld ( 0 , s1 ) ; \n vec_u8 pixr = vec_ld ( 15 , s1 ) ; \n vec_u8 bytes = vec_perm ( pixl , pixr , perm1 ) ; \n shorts1 = ( vec_s16 ) vec_mergeh ( zero , bytes ) ; \n pixl = vec_ld ( 0 , s2 ) ; \n pixr = vec_ld ( 15 , s2 ) ; \n bytes = vec_perm ( pixl , pixr , perm2 ) ; \n shorts2 = ( vec_s16 ) vec_mergeh ( zero , bytes ) ; \n shorts1 = vec_sub ( shorts1 , shorts2 ) ; \n vec_st ( shorts1 , 0 , ( vec_s16 * ) block ) ; \n s1 += stride ; \n s2 += stride ; \n block += 8 ; \n pixl = vec_ld ( 0 , s1 ) ; \n pixr = vec_ld ( 15 , s1 ) ; \n bytes = vec_perm ( pixl , pixr , perm1 ) ; \n shorts1 = ( vec_s16 ) vec_mergeh ( zero , bytes ) ; \n pixl = vec_ld ( 0 , s2 ) ; \n pixr = vec_ld ( 15 , s2 ) ; \n bytes = vec_perm ( pixl , pixr , perm2 ) ; \n shorts2 = ( vec_s16 ) vec_mergeh ( zero , bytes ) ; \n shorts1 = vec_sub ( shorts1 , shorts2 ) ; \n vec_st ( shorts1 , 0 , ( vec_s16 * ) block ) ; \n s1 += stride ; \n s2 += stride ; \n block += 8 ; \n } \n }", "idx": 8103}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void hds_free ( AVFormatContext * s ) \n { \n HDSContext * c = s -> priv_data ; \n int i , j ; \n if ( ! c -> streams ) \n return ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n OutputStream * os = & c -> streams [ i ] ; \n if ( os -> out ) \n avio_close ( os -> out ) ; \n os -> out = NULL ; \n if ( os -> ctx && os -> ctx_inited ) \n av_write_trailer ( os -> ctx ) ; \n if ( os -> ctx && os -> ctx -> pb ) \n av_free ( os -> ctx -> pb ) ; \n if ( os -> ctx ) \n avformat_free_context ( os -> ctx ) ; \n av_free ( os -> metadata ) ; \n for ( j = 0 ; j < os -> nb_extra_packets ; j ++ ) \n av_free ( os -> extra_packets [ j ] ) ; \n for ( j = 0 ; j < os -> nb_fragments ; j ++ ) \n av_free ( os -> fragments [ j ] ) ; \n av_free ( os -> fragments ) ; \n } \n av_freep ( & c -> streams ) ; \n }", "idx": 8112}
{"project": "FFmpeg", "commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "target": 1, "func": "yuv2ya8_2_c ( SwsContext * c , const int16_t * buf [ 2 ] , \n const int16_t * ubuf [ 2 ] , const int16_t * vbuf [ 2 ] , \n const int16_t * abuf [ 2 ] , uint8_t * dest , int dstW , \n int yalpha , int uvalpha , int y )  \n { \n int hasAlpha = abuf [ 0 ] && abuf [ 1 ] ; \n const int16_t * buf0 = buf [ 0 ] , * buf1 = buf [ 1 ] , \n * abuf0 = hasAlpha ? abuf [ 0 ] : NULL , \n * abuf1 = hasAlpha ? abuf [ 1 ] : NULL ; \n int yalpha1 = 4096 - yalpha ; \n int i ; \n for ( i = 0 ; i < dstW ; i ++ ) { \n int Y = ( buf0 [ i * 2 ] * yalpha1 + buf1 [ i * 2 ] * yalpha ) >> 19 ; \n int A ; \n Y = av_clip_uint8 ( Y ) ; \n if ( hasAlpha ) { \n A = ( abuf0 [ i * 2 ] * yalpha1 + abuf1 [ i * 2 ] * yalpha ) >> 19 ; \n A = av_clip_uint8 ( A ) ; \n } \n dest [ i * 2 ] = Y ; \n dest [ i * 2 + 1 ] = hasAlpha ? A : 255 ; \n } \n }", "idx": 8124}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "av_cold void ff_wmv2_common_init ( Wmv2Context * w ) { \n MpegEncContext * const s = & w -> s ; \n ff_init_scantable ( s -> dsp . idct_permutation , & w -> abt_scantable [ 0 ] , ff_wmv2_scantableA ) ; \n ff_init_scantable ( s -> dsp . idct_permutation , & w -> abt_scantable [ 1 ] , ff_wmv2_scantableB ) ; \n }", "idx": 8157}
{"project": "FFmpeg", "commit_id": "c9f6eab184cac379c7a44d5899979165798d45d4", "target": 1, "func": "static av_cold int ac3_decode_init ( AVCodecContext * avctx ) \n { \n AC3DecodeContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n ff_ac3_common_init ( ) ; \n ac3_tables_init ( ) ; \n ff_mdct_init ( & s -> imdct_256 , 8 , 1 , 1.0 ) ; \n ff_mdct_init ( & s -> imdct_512 , 9 , 1 , 1.0 ) ; \n ff_kbd_window_init ( s -> window , 5.0 , 256 ) ; \n dsputil_init ( & s -> dsp , avctx ) ; \n ff_fmt_convert_init ( & s -> fmt_conv , avctx ) ; \n av_lfg_init ( & s -> dith_state , 0 ) ; \n s -> mul_bias = 32767.0f ; \n if ( avctx -> channels > 0 && avctx -> request_channels > 0 && \n avctx -> request_channels < avctx -> channels && \n avctx -> request_channels <= 2 ) { \n avctx -> channels = avctx -> request_channels ; \n } \n s -> downmixed = 1 ; \n if ( avctx -> error_recognition >= FF_ER_CAREFUL ) { \n s -> input_buffer = av_mallocz ( AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE ) ; \n if ( ! s -> input_buffer ) \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n return 0 ; \n }", "idx": 8171}
{"project": "FFmpeg", "commit_id": "08a747afb98c11da48b89339c2f1c5fdc56ced7e", "target": 0, "func": "static void count_frame_bits_fixed ( AC3EncodeContext * s ) \n { \n static const int frame_bits_inc [ 8 ] = { 0 , 0 , 2 , 2 , 2 , 4 , 2 , 4 } ; \n int blk ; \n int frame_bits ; \n frame_bits = 16 ; \n if ( s -> eac3 ) { \n frame_bits += 35 ; \n frame_bits += 1 + 1 + 1 ; \n frame_bits += 2 ; \n frame_bits += 10 ; \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) \n frame_bits += 2 * s -> fbw_channels + s -> lfe_on ; \n frame_bits += s -> fbw_channels * 5 ; \n frame_bits += 10 ; \n frame_bits ++ ; \n } else { \n frame_bits += 49 ; \n frame_bits += frame_bits_inc [ s -> channel_mode ] ; \n } \n for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { \n if ( ! s -> eac3 ) { \n frame_bits += s -> fbw_channels ; \n frame_bits += s -> fbw_channels ; \n } \n frame_bits ++ ; \n if ( s -> eac3 ) \n frame_bits ++ ; \n if ( ! s -> eac3 ) { \n frame_bits += 2 * s -> fbw_channels ; \n if ( s -> lfe_on ) \n frame_bits ++ ; \n frame_bits ++ ; \n if ( ! blk ) \n frame_bits += 2 + 2 + 2 + 2 + 3 ; \n } \n if ( s -> eac3 ) \n frame_bits ++ ; \n if ( ! s -> eac3 ) { \n frame_bits ++ ; \n frame_bits ++ ; \n } \n } \n frame_bits ++ ; \n frame_bits += 1 + 16 ; \n s -> frame_bits_fixed = frame_bits ; \n }", "idx": 8181}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgev ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = 52 + qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> s . dsp . h264_h_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_h_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 8197}
{"project": "FFmpeg", "commit_id": "ac66834c759b7130fb5be51f63cb6dff9b294cba", "target": 0, "func": "int avcodec_decode_audio ( AVCodecContext * avctx , int16_t * samples , \n int * frame_size_ptr , \n uint8_t * buf , int buf_size ) \n { \n int ret ; \n * frame_size_ptr = 0 ; \n if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || buf_size ) { \n ret = avctx -> codec -> decode ( avctx , samples , frame_size_ptr , \n buf , buf_size ) ; \n avctx -> frame_number ++ ; \n } else \n ret = 0 ; \n return ret ; \n }", "idx": 8199}
{"project": "FFmpeg", "commit_id": "eb24fd64589b7eea91fa752861f0c6f07e5a48a8", "target": 0, "func": "int ff_rle_encode ( uint8_t * outbuf , int out_size , const uint8_t * ptr , int bpp , int w , int8_t add , uint8_t xor ) \n { \n int count , x ; \n uint8_t * out ; \n out = outbuf ; \n for ( x = 0 ; x < w ; x += count ) { \n if ( ( count = count_pixels ( ptr , w - x , bpp , 1 ) ) > 1 ) { \n if ( out + bpp + 1 > outbuf + out_size ) return -1 ; \n * out ++ = ( count ^ xor ) + add ; \n memcpy ( out , ptr , bpp ) ; \n out += bpp ; \n } else { \n count = count_pixels ( ptr , w - x , bpp , 0 ) ; \n * out ++ = count - 1 ; \n if ( out + bpp * count > outbuf + out_size ) return -1 ; \n memcpy ( out , ptr , bpp * count ) ; \n out += bpp * count ; \n } \n ptr += count * bpp ; \n } \n return out - outbuf ; \n }", "idx": 8211}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "void ff_fix_long_b_mvs ( MpegEncContext * s , int16_t ( * mv_table ) [ 2 ] , int f_code , int type ) \n { \n int y ; \n uint8_t * fcode_tab = s -> fcode_tab ; \n int range = ( ( ( s -> codec_id == CODEC_ID_MPEG1VIDEO ) ? 8 : 16 ) << f_code ) ; \n for ( y = 0 ; y < s -> mb_height ; y ++ ) { \n int x ; \n int xy = ( y + 1 ) * ( s -> mb_width + 2 ) + 1 ; \n int i = y * s -> mb_width ; \n for ( x = 0 ; x < s -> mb_width ; x ++ ) \n { \n if ( s -> mb_type [ i ] & type ) \n { \n if ( fcode_tab [ mv_table [ xy ] [ 0 ] + MAX_MV ] > f_code || fcode_tab [ mv_table [ xy ] [ 0 ] + MAX_MV ] == 0 ) \n { \n if ( mv_table [ xy ] [ 0 ] > 0 ) \n mv_table [ xy ] [ 0 ] = range - 1 ; \n else \n mv_table [ xy ] [ 0 ] = - range ; \n } \n if ( fcode_tab [ mv_table [ xy ] [ 1 ] + MAX_MV ] > f_code || fcode_tab [ mv_table [ xy ] [ 1 ] + MAX_MV ] == 0 ) \n { \n if ( mv_table [ xy ] [ 1 ] > 0 ) \n mv_table [ xy ] [ 1 ] = range - 1 ; \n else \n mv_table [ xy ] [ 1 ] = - range ; \n } \n } \n xy ++ ; \n i ++ ; \n } \n } \n }", "idx": 8273}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void create_cel_evals ( RoqContext * enc , RoqTempdata * tempData ) \n { \n int n = 0 , x , y , i ; \n tempData -> cel_evals = av_malloc ( enc -> width * enc -> height / 64 * sizeof ( CelEvaluation ) ) ; \n for ( y = 0 ; y < enc -> height ; y += 16 ) \n for ( x = 0 ; x < enc -> width ; x += 16 ) \n for ( i = 0 ; i < 4 ; i ++ ) { \n tempData -> cel_evals [ n ] . sourceX = x + ( i & 1 ) * 8 ; \n tempData -> cel_evals [ n ++ ] . sourceY = y + ( i & 2 ) * 4 ; \n } \n }", "idx": 8313}
{"project": "FFmpeg", "commit_id": "c97f54020d5d55511e28622551f13233bd8ceb56", "target": 0, "func": "static int video_open ( VideoState * is ) { \n int flags = SDL_HWSURFACE | SDL_ASYNCBLIT | SDL_HWACCEL ; \n int w , h ; \n if ( is_full_screen ) flags |= SDL_FULLSCREEN ; \n else flags |= SDL_RESIZABLE ; \n if ( is_full_screen && fs_screen_width ) { \n w = fs_screen_width ; \n h = fs_screen_height ; \n } else if ( ! is_full_screen && screen_width ) { \n w = screen_width ; \n h = screen_height ; \n } else if ( is -> video_st && is -> video_st -> codec -> width ) { \n w = is -> video_st -> codec -> width ; \n h = is -> video_st -> codec -> height ; \n } else { \n w = 640 ; \n h = 480 ; \n } \n #ifndef SYS_DARWIN \n screen = SDL_SetVideoMode ( w , h , 0 , flags ) ; \n #else \n screen = SDL_SetVideoMode ( w , h , 24 , flags ) ; \n #endif \n if ( ! screen ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n SDL_WM_SetCaption ( \" \" , \" \" ) ; \n is -> width = screen -> w ; \n is -> height = screen -> h ; \n return 0 ; \n }", "idx": 8370}
{"project": "FFmpeg", "commit_id": "480324e7ca0b87105fd7ee168292a0d5692af128", "target": 0, "func": "static int libgsm_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) { \n uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n int out_size = avctx -> frame_size * av_get_bytes_per_sample ( avctx -> sample_fmt ) ; \n if ( * data_size < out_size ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( buf_size < avctx -> block_align ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n switch ( avctx -> codec_id ) { \n case CODEC_ID_GSM : \n if ( gsm_decode ( avctx -> priv_data , buf , data ) ) return -1 ; \n break ; \n case CODEC_ID_GSM_MS : \n if ( gsm_decode ( avctx -> priv_data , buf , data ) || \n gsm_decode ( avctx -> priv_data , buf + 33 , ( ( int16_t * ) data ) + GSM_FRAME_SIZE ) ) return -1 ; \n } \n * data_size = out_size ; \n return avctx -> block_align ; \n }", "idx": 8487}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "static int default_lockmgr_cb ( void * * arg , enum AVLockOp op ) \n { \n void * volatile * mutex = arg ; \n int err ; \n switch ( op ) { \n case AV_LOCK_CREATE : \n return 0 ; \n case AV_LOCK_OBTAIN : \n if ( ! * mutex ) { \n pthread_mutex_t * tmp = av_malloc ( sizeof ( pthread_mutex_t ) ) ; \n if ( ! tmp ) \n return AVERROR ( ENOMEM ) ; \n if ( ( err = pthread_mutex_init ( tmp , NULL ) ) ) { \n av_free ( tmp ) ; \n return AVERROR ( err ) ; \n } \n if ( avpriv_atomic_ptr_cas ( mutex , NULL , tmp ) ) { \n pthread_mutex_destroy ( tmp ) ; \n av_free ( tmp ) ; \n } \n } \n if ( ( err = pthread_mutex_lock ( * mutex ) ) ) \n return AVERROR ( err ) ; \n return 0 ; \n case AV_LOCK_RELEASE : \n if ( ( err = pthread_mutex_unlock ( * mutex ) ) ) \n return AVERROR ( err ) ; \n return 0 ; \n case AV_LOCK_DESTROY : \n if ( * mutex ) \n pthread_mutex_destroy ( * mutex ) ; \n av_free ( * mutex ) ; \n avpriv_atomic_ptr_cas ( mutex , * mutex , NULL ) ; \n return 0 ; \n } \n return 1 ; \n }", "idx": 8794}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "av_cold int ff_vaapi_encode_close ( AVCodecContext * avctx ) \n { \n VAAPIEncodeContext * ctx = avctx -> priv_data ; \n VAAPIEncodePicture * pic , * next ; \n for ( pic = ctx -> pic_start ; pic ; pic = next ) { \n next = pic -> next ; \n vaapi_encode_free ( avctx , pic ) ; \n } \n if ( ctx -> va_context != VA_INVALID_ID ) { \n vaDestroyContext ( ctx -> hwctx -> display , ctx -> va_context ) ; \n ctx -> va_context = VA_INVALID_ID ; \n } \n if ( ctx -> va_config != VA_INVALID_ID ) { \n vaDestroyConfig ( ctx -> hwctx -> display , ctx -> va_config ) ; \n ctx -> va_config = VA_INVALID_ID ; \n } \n if ( ctx -> codec -> close ) \n ctx -> codec -> close ( avctx ) ; \n av_buffer_pool_uninit ( & ctx -> output_buffer_pool ) ; \n av_freep ( & ctx -> codec_sequence_params ) ; \n av_freep ( & ctx -> codec_picture_params ) ; \n av_buffer_unref ( & ctx -> recon_frames_ref ) ; \n av_buffer_unref ( & ctx -> input_frames_ref ) ; \n av_buffer_unref ( & ctx -> device_ref ) ; \n av_freep ( & ctx -> priv_data ) ; \n return 0 ; \n }", "idx": 8835}
{"project": "FFmpeg", "commit_id": "35cb6854bb76b4a5b6f2aea2dce81e18d7ab61cd", "target": 1, "func": "static int rle_unpack ( const unsigned char * src , int src_len , int src_count , \n unsigned char * dest , int dest_len ) \n { \n const unsigned char * ps ; \n const unsigned char * ps_end ; \n unsigned char * pd ; \n int i , l ; \n unsigned char * dest_end = dest + dest_len ; \n ps = src ; \n ps_end = src + src_len ; \n pd = dest ; \n if ( src_count & 1 ) { \n if ( ps_end - ps < 1 ) \n return 0 ; \n * pd ++ = * ps ++ ; \n } \n src_count >>= 1 ; \n i = 0 ; \n do { \n if ( ps_end - ps < 1 ) \n break ; \n l = * ps ++ ; \n if ( l & 0x80 ) { \n l = ( l & 0x7F ) * 2 ; \n if ( pd + l > dest_end || ps_end - ps < l ) \n return ps - src ; \n memcpy ( pd , ps , l ) ; \n ps += l ; \n pd += l ; \n } else { \n if ( pd + i > dest_end || ps_end - ps < 2 ) \n return ps - src ; \n for ( i = 0 ; i < l ; i ++ ) { \n * pd ++ = ps [ 0 ] ; \n * pd ++ = ps [ 1 ] ; \n } \n ps += 2 ; \n } \n i += l ; \n } while ( i < src_count ) ; \n return ps - src ; \n }", "idx": 8900}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC ( hevc_h_loop_filter_luma ) ( uint8_t * pix , ptrdiff_t stride , \n int * beta , int * tc , uint8_t * no_p , \n uint8_t * no_q ) \n { \n FUNC ( hevc_loop_filter_luma ) ( pix , stride , sizeof ( pixel ) , \n beta , tc , no_p , no_q ) ; \n }", "idx": 8963}
{"project": "FFmpeg", "commit_id": "93c04e095dc37ebdab22174e88cfa91e24940866", "target": 0, "func": "static int flv_read_metabody ( AVFormatContext * s , int64_t next_pos ) \n { \n AMFDataType type ; \n AVStream * stream , * astream , * vstream ; \n AVIOContext * ioc ; \n int i ; \n char buffer [ 11 ] ; \n astream = NULL ; \n vstream = NULL ; \n ioc = s -> pb ; \n type = avio_r8 ( ioc ) ; \n if ( type != AMF_DATA_TYPE_STRING || \n amf_get_string ( ioc , buffer , sizeof ( buffer ) ) < 0 ) \n return -1 ; \n if ( ! strcmp ( buffer , \" \" ) ) \n return 1 ; \n if ( strcmp ( buffer , \" \" ) ) \n return -1 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n stream = s -> streams [ i ] ; \n if ( stream -> codec -> codec_type == AVMEDIA_TYPE_AUDIO ) \n astream = stream ; \n else if ( stream -> codec -> codec_type == AVMEDIA_TYPE_VIDEO ) \n vstream = stream ; \n } \n if ( amf_parse_object ( s , astream , vstream , buffer , next_pos , 0 ) < 0 ) \n return -1 ; \n return 0 ; \n }", "idx": 9036}
{"project": "FFmpeg", "commit_id": "ebea370dc3909aa182bae4c728b83516a904beca", "target": 0, "func": "static int write_fragments ( struct Tracks * tracks , int start_index , \n AVIOContext * in ) \n { \n char dirname [ 100 ] , filename [ 500 ] ; \n int i , j ; \n for ( i = start_index ; i < tracks -> nb_tracks ; i ++ ) { \n struct Track * track = tracks -> tracks [ i ] ; \n const char * type = track -> is_video ? \" \" : \" \" ; \n snprintf ( dirname , sizeof ( dirname ) , \" \" , track -> bitrate ) ; \n mkdir ( dirname , 0777 ) ; \n for ( j = 0 ; j < track -> chunks ; j ++ ) { \n snprintf ( filename , sizeof ( filename ) , \" \" PRId64 \" \" , \n dirname , type , track -> offsets [ j ] . time ) ; \n avio_seek ( in , track -> offsets [ j ] . offset , SEEK_SET ) ; \n write_fragment ( filename , in ) ; \n } \n } \n return 0 ; \n }", "idx": 9047}
{"project": "FFmpeg", "commit_id": "c56e71309ec1a585ed4d4dc11ae0ba3ca7d19618", "target": 1, "func": "static int gif_image_write_image ( AVCodecContext * avctx , \n uint8_t * * bytestream , uint8_t * end , \n const uint8_t * buf , int linesize ) \n { \n GIFContext * s = avctx -> priv_data ; \n int len , height ; \n const uint8_t * ptr ; \n bytestream_put_byte ( bytestream , 0x2c ) ; \n bytestream_put_le16 ( bytestream , 0 ) ; \n bytestream_put_le16 ( bytestream , 0 ) ; \n bytestream_put_le16 ( bytestream , avctx -> width ) ; \n bytestream_put_le16 ( bytestream , avctx -> height ) ; \n bytestream_put_byte ( bytestream , 0x00 ) ; \n bytestream_put_byte ( bytestream , 0x08 ) ; \n ff_lzw_encode_init ( s -> lzw , s -> buf , avctx -> width * avctx -> height , \n 12 , FF_LZW_GIF , put_bits ) ; \n ptr = buf ; \n for ( height = avctx -> height ; height -- ; ) { \n len += ff_lzw_encode ( s -> lzw , ptr , avctx -> width ) ; \n ptr += linesize ; \n } \n len += ff_lzw_encode_flush ( s -> lzw , flush_put_bits ) ; \n ptr = s -> buf ; \n while ( len > 0 ) { \n int size = FFMIN ( 255 , len ) ; \n bytestream_put_byte ( bytestream , size ) ; \n if ( end - * bytestream < size ) \n return -1 ; \n bytestream_put_buffer ( bytestream , ptr , size ) ; \n ptr += size ; \n len -= size ; \n } \n bytestream_put_byte ( bytestream , 0x00 ) ; \n bytestream_put_byte ( bytestream , 0x3b ) ; \n return 0 ; \n }", "idx": 9095}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_stbl_tag ( AVIOContext * pb , MOVTrack * track ) \n { \n int64_t pos = avio_tell ( pb ) ; \n avio_wb32 ( pb , 0 ) ; \n ffio_wfourcc ( pb , \" \" ) ; \n mov_write_stsd_tag ( pb , track ) ; \n mov_write_stts_tag ( pb , track ) ; \n if ( ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO || \n track -> enc -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) && \n track -> has_keyframes && track -> has_keyframes < track -> entry ) \n mov_write_stss_tag ( pb , track , MOV_SYNC_SAMPLE ) ; \n if ( track -> mode == MODE_MOV && track -> flags & MOV_TRACK_STPS ) \n mov_write_stss_tag ( pb , track , MOV_PARTIAL_SYNC_SAMPLE ) ; \n if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO && \n track -> flags & MOV_TRACK_CTTS && track -> entry ) \n mov_write_ctts_tag ( pb , track ) ; \n mov_write_stsc_tag ( pb , track ) ; \n mov_write_stsz_tag ( pb , track ) ; \n mov_write_stco_tag ( pb , track ) ; \n return update_size ( pb , pos ) ; \n }", "idx": 9101}
{"project": "FFmpeg", "commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "target": 1, "func": "int avpriv_dca_convert_bitstream ( const uint8_t * src , int src_size , uint8_t * dst , \n int max_size ) \n { \n uint32_t mrk ; \n int i , tmp ; \n const uint16_t * ssrc = ( const uint16_t * ) src ; \n uint16_t * sdst = ( uint16_t * ) dst ; \n PutBitContext pb ; \n if ( ( unsigned ) src_size > ( unsigned ) max_size ) \n src_size = max_size ; \n mrk = AV_RB32 ( src ) ; \n switch ( mrk ) { \n case DCA_SYNCWORD_CORE_BE : \n memcpy ( dst , src , src_size ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_LE : \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ ) \n * sdst ++ = av_bswap16 ( * ssrc ++ ) ; \n return src_size ; \n case DCA_SYNCWORD_CORE_14B_BE : \n case DCA_SYNCWORD_CORE_14B_LE : \n init_put_bits ( & pb , dst , max_size ) ; \n for ( i = 0 ; i < ( src_size + 1 ) >> 1 ; i ++ , src += 2 ) { \n tmp = ( ( mrk == DCA_SYNCWORD_CORE_14B_BE ) ? AV_RB16 ( src ) : AV_RL16 ( src ) ) & 0x3FFF ; \n put_bits ( & pb , 14 , tmp ) ; \n } \n flush_put_bits ( & pb ) ; \n return ( put_bits_count ( & pb ) + 7 ) >> 3 ; \n default : \n return AVERROR_INVALIDDATA ; \n } \n }", "idx": 9178}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono ( AC3DecodeContext * ctx ) \n { \n int i ; \n float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; \n for ( i = 0 ; i < 256 ; i ++ ) \n output [ 1 ] [ i ] = ( output [ 2 ] [ i ] + output [ 3 ] [ i ] + output [ 4 ] [ i ] ) ; \n memset ( output [ 2 ] , 0 , sizeof ( output [ 2 ] ) ) ; \n memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; \n memset ( output [ 4 ] , 0 , sizeof ( output [ 4 ] ) ) ; \n }", "idx": 9238}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( nv21ToUV ) ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src1 , const uint8_t * src2 , \n long width , uint32_t * unused ) \n { \n RENAME ( nvXXtoUV ) ( dstV , dstU , src1 , width ) ; \n }", "idx": 9246}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int request_frame ( AVFilterLink * link ) \n { \n AVFilterContext * ctx = link -> src ; \n IDETContext * idet = ctx -> priv ; \n do { \n int ret ; \n if ( idet -> eof ) \n return AVERROR_EOF ; \n ret = ff_request_frame ( link -> src -> inputs [ 0 ] ) ; \n if ( ret == AVERROR_EOF && idet -> cur ) { \n AVFrame * next = av_frame_clone ( idet -> next ) ; \n if ( ! next ) \n return AVERROR ( ENOMEM ) ; \n filter_frame ( link -> src -> inputs [ 0 ] , next ) ; \n idet -> eof = 1 ; \n } else if ( ret < 0 ) { \n return ret ; \n } \n } while ( ! idet -> cur ) ; \n return 0 ; \n }", "idx": 9282}
{"project": "FFmpeg", "commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "target": 1, "func": "static void picmemset ( PicContext * s , AVFrame * frame , unsigned value , int run , \n int * x , int * y , int * plane , int bits_per_plane ) \n { \n uint8_t * d ; \n int shift = * plane * bits_per_plane ; \n unsigned mask = ( ( 1 << bits_per_plane ) - 1 ) << shift ; \n value <<= shift ; \n while ( run > 0 ) { \n int j ; \n for ( j = 8 - bits_per_plane ; j >= 0 ; j -= bits_per_plane ) { \n d = frame -> data [ 0 ] + * y * frame -> linesize [ 0 ] ; \n d [ * x ] |= ( value >> j ) & mask ; \n * x += 1 ; \n if ( * x == s -> width ) { \n * y -= 1 ; \n * x = 0 ; \n if ( * y < 0 ) { \n * y = s -> height - 1 ; \n * plane += 1 ; \n if ( * plane >= s -> nb_planes ) \n return ; \n value <<= bits_per_plane ; \n mask <<= bits_per_plane ; \n } \n } \n } \n run -- ; \n } \n }", "idx": 9347}
{"project": "FFmpeg", "commit_id": "e630ca5111077fa8adc972fe8a3d7e2b3e8dc91f", "target": 1, "func": "static int parse_MP4SLDescrTag ( MP4DescrParseContext * d , int64_t off , int len ) \n { \n Mp4Descr * descr = d -> active_descr ; \n int predefined ; \n if ( ! descr ) \n return -1 ; \n predefined = avio_r8 ( & d -> pb ) ; \n if ( ! predefined ) { \n int lengths ; \n int flags = avio_r8 ( & d -> pb ) ; \n descr -> sl . use_au_start = ! ! ( flags & 0x80 ) ; \n descr -> sl . use_au_end = ! ! ( flags & 0x40 ) ; \n descr -> sl . use_rand_acc_pt = ! ! ( flags & 0x20 ) ; \n descr -> sl . use_padding = ! ! ( flags & 0x08 ) ; \n descr -> sl . use_timestamps = ! ! ( flags & 0x04 ) ; \n descr -> sl . use_idle = ! ! ( flags & 0x02 ) ; \n descr -> sl . timestamp_res = avio_rb32 ( & d -> pb ) ; \n avio_rb32 ( & d -> pb ) ; \n descr -> sl . timestamp_len = avio_r8 ( & d -> pb ) ; \n descr -> sl . ocr_len = avio_r8 ( & d -> pb ) ; \n descr -> sl . au_len = avio_r8 ( & d -> pb ) ; \n descr -> sl . inst_bitrate_len = avio_r8 ( & d -> pb ) ; \n lengths = avio_rb16 ( & d -> pb ) ; \n descr -> sl . degr_prior_len = lengths >> 12 ; \n descr -> sl . au_seq_num_len = ( lengths >> 7 ) & 0x1f ; \n descr -> sl . packet_seq_num_len = ( lengths >> 2 ) & 0x1f ; \n } else { \n avpriv_report_missing_feature ( d -> s , \" \" ) ; \n return 0 ;", "idx": 9351}
{"project": "FFmpeg", "commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "target": 1, "func": "static inline void mv_pred_direct ( AVSContext * h , cavs_vector * pmv_fw , \n cavs_vector * col_mv ) \n { \n cavs_vector * pmv_bw = pmv_fw + MV_BWD_OFFS ; \n int den = h -> direct_den [ col_mv -> ref ] ; \n int m = FF_SIGNBIT ( col_mv -> x ) ; \n pmv_fw -> dist = h -> dist [ 1 ] ; \n pmv_bw -> dist = h -> dist [ 0 ] ; \n pmv_fw -> ref = 1 ; \n pmv_bw -> ref = 0 ; \n pmv_fw -> x = ( ( ( den + ( den * col_mv -> x * pmv_fw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) - m ; \n pmv_bw -> x = m - ( ( ( den + ( den * col_mv -> x * pmv_bw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) ; \n m = FF_SIGNBIT ( col_mv -> y ) ; \n pmv_fw -> y = ( ( ( den + ( den * col_mv -> y * pmv_fw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) - m ; \n pmv_bw -> y = m - ( ( ( den + ( den * col_mv -> y * pmv_bw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) ; \n }", "idx": 9528}
{"project": "FFmpeg", "commit_id": "22fa38f0c85fb31cddbb0bc22a2df5953c702b95", "target": 0, "func": "static inline void h264_deblock_q1 ( register vector unsigned char p0 , \n register vector unsigned char p1 , \n register vector unsigned char p2 , \n register vector unsigned char q0 , \n register vector unsigned char tc0 ) { \n register vector unsigned  char average = vec_avg ( p0 , q0 ) ; \n register vector unsigned  char temp ; \n register vector unsigned  char uncliped ; \n register vector unsigned  char ones ; \n register vector unsigned  char max ; \n register vector unsigned  char min ; \n temp = vec_xor ( average , p2 ) ; \n average = vec_avg ( average , p2 ) ; \n ones = vec_splat_u8 ( 1 ) ; \n temp = vec_and ( temp , ones ) ; \n uncliped = vec_subs ( average , temp ) ; \n max = vec_adds ( p1 , tc0 ) ; \n min = vec_subs ( p1 , tc0 ) ; \n p1 = vec_max ( min , uncliped ) ; \n p1 = vec_min ( max , p1 ) ; \n }", "idx": 9533}
{"project": "FFmpeg", "commit_id": "bd8ae4885b905415f0e86d4e348c4b72be81e6e6", "target": 0, "func": "AVFilterFormats * avfilter_all_colorspaces ( void ) \n { \n return avfilter_make_format_list ( 35 , \n PIX_FMT_YUV444P , PIX_FMT_YUV422P , PIX_FMT_YUV420P , \n PIX_FMT_YUV411P , PIX_FMT_YUV410P , \n PIX_FMT_YUYV422 , PIX_FMT_UYVY422 , PIX_FMT_UYYVYY411 , \n PIX_FMT_YUVJ444P , PIX_FMT_YUVJ422P , PIX_FMT_YUVJ420P , \n PIX_FMT_YUV440P , PIX_FMT_YUVJ440P , \n PIX_FMT_RGB32 , PIX_FMT_BGR32 , \n PIX_FMT_RGB32_1 , PIX_FMT_BGR32_1 , \n PIX_FMT_RGB24 , PIX_FMT_BGR24 , \n PIX_FMT_RGB565 , PIX_FMT_BGR565 , \n PIX_FMT_RGB555 , PIX_FMT_BGR555 , \n PIX_FMT_RGB8 , PIX_FMT_BGR8 , \n PIX_FMT_RGB4_BYTE , PIX_FMT_BGR4_BYTE , \n PIX_FMT_GRAY16BE , PIX_FMT_GRAY16LE , \n PIX_FMT_GRAY8 , PIX_FMT_PAL8 , \n PIX_FMT_MONOWHITE , PIX_FMT_MONOBLACK \n PIX_FMT_NV12 , PIX_FMT_NV21 ) ; \n }", "idx": 9576}
{"project": "FFmpeg", "commit_id": "a744064c4155bde063b9e8a47699542be3b8e5eb", "target": 1, "func": "static void free_geotags ( TiffContext * const s ) \n { \n int i ; \n for ( i = 0 ; i < s -> geotag_count ; i ++ ) { \n if ( s -> geotags [ i ] . val ) \n av_freep ( & s -> geotags [ i ] . val ) ; \n } \n av_freep ( & s -> geotags ) ; \n }", "idx": 9598}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "func": "void ff_bink_idct_c ( DCTELEM * block ) \n { \n int i ; \n DCTELEM temp [ 64 ] ; \n for ( i = 0 ; i < 8 ; i ++ ) \n bink_idct_col ( & temp [ i ] , & block [ i ] ) ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n IDCT_ROW ( ( & block [ 8 * i ] ) , ( & temp [ 8 * i ] ) ) ; \n } \n }", "idx": 9607}
{"project": "FFmpeg", "commit_id": "ffd7fd79441f97f1edb25181af0603ff6ea9b342", "target": 1, "func": "static int vda_h264_end_frame ( AVCodecContext * avctx ) \n { \n H264Context * h = avctx -> priv_data ; \n struct vda_context * vda_ctx = avctx -> hwaccel_context ; \n AVFrame * frame = & h -> cur_pic_ptr -> f ; \n struct vda_buffer * context ; \n AVBufferRef * buffer ; \n int status ; \n if ( ! vda_ctx -> decoder || ! vda_ctx -> priv_bitstream ) \n status = vda_sync_decode ( vda_ctx ) ; \n frame -> data [ 3 ] = ( void * ) vda_ctx -> cv_buffer ; \n if ( status ) \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , status ) ; ", "idx": 9772}
{"project": "FFmpeg", "commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "target": 1, "func": "static int channelmap_query_formats ( AVFilterContext * ctx ) \n { \n ChannelMapContext * s = ctx -> priv ; \n ff_set_common_formats ( ctx , ff_planar_sample_fmts ( ) ) ; \n ff_set_common_samplerates ( ctx , ff_all_samplerates ( ) ) ; \n ff_channel_layouts_ref ( ff_all_channel_layouts ( ) , & ctx -> inputs [ 0 ] -> out_channel_layouts ) ; \n ff_channel_layouts_ref ( s -> channel_layouts , & ctx -> outputs [ 0 ] -> in_channel_layouts ) ; \n return 0 ; \n }", "idx": 9789}
{"project": "FFmpeg", "commit_id": "c95fefa0420be9cc0f09a95041acf11114aaacd0", "target": 0, "func": "static void cin_decode_lzss ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) \n { \n uint16_t cmd ; \n int i , sz , offset , code ; \n unsigned char * dst_end = dst + dst_size ; \n const unsigned char * src_end = src + src_size ; \n while ( src < src_end && dst < dst_end ) { \n code = * src ++ ; \n for ( i = 0 ; i < 8 && src < src_end && dst < dst_end ; ++ i ) { \n if ( code & ( 1 << i ) ) { \n * dst ++ = * src ++ ; \n } else { \n cmd = AV_RL16 ( src ) ; src += 2 ; \n offset = cmd >> 4 ; \n sz = ( cmd & 0xF ) + 2 ; \n sz = FFMIN ( sz , dst_end - dst ) ; \n while ( sz -- ) { \n * dst = * ( dst - offset - 1 ) ; \n ++ dst ; \n } \n } \n } \n } \n }", "idx": 9896}
{"project": "FFmpeg", "commit_id": "84f0aba18dc8815c5cd408238909e4dc8b60684f", "target": 1, "func": "ff_rdt_parse_open ( AVFormatContext * ic , int first_stream_of_set_idx , \n void * priv_data , RTPDynamicProtocolHandler * handler )  \n { \n RDTDemuxContext * s = av_mallocz ( sizeof ( RDTDemuxContext ) ) ; \n if ( ! s ) \n return NULL ; \n s -> ic = ic ; \n s -> streams = & ic -> streams [ first_stream_of_set_idx ] ; \n do { \n s -> n_streams ++ ; \n } while ( first_stream_of_set_idx + s -> n_streams < ic -> nb_streams && \n s -> streams [ s -> n_streams ] -> priv_data == s -> streams [ 0 ] -> priv_data ) ; \n s -> prev_set_id = -1 ; \n s -> prev_stream_id = -1 ; \n s -> prev_timestamp = -1 ; \n s -> parse_packet = handler -> parse_packet ; \n s -> dynamic_protocol_context = priv_data ; \n return s ; \n }", "idx": 9913}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "int ff_set_systematic_pal2 ( uint32_t pal [ 256 ] , enum AVPixelFormat pix_fmt ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n int r , g , b ; \n switch ( pix_fmt ) { \n case AV_PIX_FMT_RGB8 : \n r = ( i >> 5 ) * 36 ; \n g = ( ( i >> 2 ) & 7 ) * 36 ; \n b = ( i & 3 ) * 85 ; \n break ; \n case AV_PIX_FMT_BGR8 : \n b = ( i >> 6 ) * 85 ; \n g = ( ( i >> 3 ) & 7 ) * 36 ; \n r = ( i & 7 ) * 36 ; \n break ; \n case AV_PIX_FMT_RGB4_BYTE : \n r = ( i >> 3 ) * 255 ; \n g = ( ( i >> 1 ) & 3 ) * 85 ; \n b = ( i & 1 ) * 255 ; \n break ; \n case AV_PIX_FMT_BGR4_BYTE : \n b = ( i >> 3 ) * 255 ; \n g = ( ( i >> 1 ) & 3 ) * 85 ; \n r = ( i & 1 ) * 255 ; \n break ; \n case AV_PIX_FMT_GRAY8 : \n r = b = g = i ; \n break ; \n default : \n return AVERROR ( EINVAL ) ; \n } \n pal [ i ] = b + ( g << 8 ) + ( r << 16 ) + ( 0xFF << 24 ) ; \n } \n return 0 ; \n }", "idx": 9934}
{"project": "FFmpeg", "commit_id": "e8c4db0d4d07738fed716b1d2f20c85aac944641", "target": 0, "func": "static int create_stream ( AVFormatContext * s ) \n { \n XCBGrabContext * c = s -> priv_data ; \n AVStream * st = avformat_new_stream ( s , NULL ) ; \n xcb_get_geometry_cookie_t gc ; \n xcb_get_geometry_reply_t * geo ; \n int ret ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n ret = av_parse_video_size ( & c -> width , & c -> height , c -> video_size ) ; \n if ( ret < 0 ) \n return ret ; \n ret = av_parse_video_rate ( & st -> avg_frame_rate , c -> framerate ) ; \n if ( ret < 0 ) \n return ret ; \n avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ; \n gc = xcb_get_geometry ( c -> conn , c -> screen -> root ) ; \n geo = xcb_get_geometry_reply ( c -> conn , gc , NULL ) ; \n c -> width = FFMIN ( geo -> width , c -> width ) ; \n c -> height = FFMIN ( geo -> height , c -> height ) ; \n c -> time_base = ( AVRational ) { st -> avg_frame_rate . den , \n st -> avg_frame_rate . num } ; \n c -> time_frame = av_gettime ( ) ; \n st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; \n st -> codec -> codec_id = AV_CODEC_ID_RAWVIDEO ; \n st -> codec -> width = c -> width ; \n st -> codec -> height = c -> height ; \n st -> codec -> time_base = c -> time_base ; \n ret = pixfmt_from_pixmap_format ( s , geo -> depth , & st -> codec -> pix_fmt ) ; \n free ( geo ) ; \n return ret ; \n }", "idx": 10161}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static int parse_presentation_segment ( AVCodecContext * avctx , \n const uint8_t * buf , int buf_size , \n int64_t pts ) \n { \n PGSSubContext * ctx = avctx -> priv_data ; \n int x , y , ret ; \n int w = bytestream_get_be16 ( & buf ) ; \n int h = bytestream_get_be16 ( & buf ) ; \n ctx -> presentation . pts = pts ; \n av_dlog ( avctx , \" \\n \" , \n w , h ) ; \n ret = ff_set_dimensions ( avctx , w , h ) ; \n if ( ret < 0 ) \n return ret ; \n buf ++ ; \n ctx -> presentation . id_number = bytestream_get_be16 ( & buf ) ; \n buf += 3 ; \n ctx -> presentation . object_number = bytestream_get_byte ( & buf ) ; \n ctx -> presentation . composition_flag = 0 ; \n if ( ! ctx -> presentation . object_number ) \n return 0 ; \n buf += 3 ; \n ctx -> presentation . composition_flag = bytestream_get_byte ( & buf ) ; \n x = bytestream_get_be16 ( & buf ) ; \n y = bytestream_get_be16 ( & buf ) ; \n av_dlog ( avctx , \" \\n \" , x , y ) ; \n if ( x > avctx -> width || y > avctx -> height ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , \n x , y , avctx -> width , avctx -> height ) ; \n x = 0 ; y = 0 ; \n } \n ctx -> presentation . x = x ; \n ctx -> presentation . y = y ; \n return 0 ; \n }", "idx": 10253}
{"project": "FFmpeg", "commit_id": "6d24231e504f71a76a8fabe87c8d7cfa826da75a", "target": 0, "func": "static int raw_init_encoder ( AVCodecContext * avctx ) \n { \n avctx -> coded_frame = ( AVFrame * ) avctx -> priv_data ; \n avctx -> coded_frame -> pict_type = FF_I_TYPE ; \n avctx -> coded_frame -> key_frame = 1 ; \n avctx -> codec_tag = findFourCC ( avctx -> pix_fmt ) ; \n return 0 ; \n }", "idx": 10410}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc23_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midv_qrt_8w_msa ( src - ( 2 * stride ) - 2 , stride , dst , stride , 8 , 1 ) ; \n }", "idx": 10429}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int film_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 4 ) \n return 0 ; \n if ( AV_RB32 ( & p -> buf [ 0 ] ) != FILM_TAG ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 10449}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_retrieve_data ( AVCodecContext * s , AVFrame * frame ) \n { \n InputStream * ist = s -> opaque ; \n DXVA2Context * ctx = ist -> hwaccel_ctx ; \n int ret ; \n ret = av_hwframe_transfer_data ( ctx -> tmp_frame , frame , 0 ) ; \n if ( ret < 0 ) \n return ret ; \n ret = av_frame_copy_props ( ctx -> tmp_frame , frame ) ; \n if ( ret < 0 ) { \n av_frame_unref ( ctx -> tmp_frame ) ; \n return ret ; \n } \n av_frame_unref ( frame ) ; \n av_frame_move_ref ( frame , ctx -> tmp_frame ) ; \n return 0 ; \n }", "idx": 10498}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static void decouple_info ( COOKContext * q , COOKSubpacket * p , int * decouple_tab ) \n { \n int i ; \n int vlc = get_bits1 ( & q -> gb ) ; \n int start = cplband [ p -> js_subband_start ] ; \n int end = cplband [ p -> subbands - 1 ] ; \n int length = end - start + 1 ; \n if ( start > end ) \n return ; \n if ( vlc ) \n for ( i = 0 ; i < length ; i ++ ) \n decouple_tab [ start + i ] = get_vlc2 ( & q -> gb , p -> ccpl . table , p -> ccpl . bits , 2 ) ; \n else \n for ( i = 0 ; i < length ; i ++ ) \n decouple_tab [ start + i ] = get_bits ( & q -> gb , p -> js_vlc_bits ) ; \n }", "idx": 10513}
{"project": "FFmpeg", "commit_id": "d1f3e475f9807b445ba37ff2fd23f71c4645de79", "target": 1, "func": "static int prepare_packet ( AVPacket * pkt , const FailingMuxerPacketData * pkt_data , int64_t pts ) \n { \n int ret ; \n FailingMuxerPacketData * data = av_malloc ( sizeof ( * data ) ) ; \n memcpy ( data , pkt_data , sizeof ( FailingMuxerPacketData ) ) ; \n ret = av_packet_from_data ( pkt , ( uint8_t * ) data , sizeof ( * data ) ) ; \n pkt -> pts = pkt -> dts = pts ; \n pkt -> duration = 1 ; \n return ret ; ", "idx": 10520}
{"project": "FFmpeg", "commit_id": "54b2d317ed99622efa07b10aca217e1a083105d9", "target": 0, "func": "static void find_best_state ( uint8_t best_state [ 256 ] [ 256 ] , const uint8_t one_state [ 256 ] ) { \n int i , j , k , m ; \n double l2tab [ 256 ] ; \n for ( i = 1 ; i < 256 ; i ++ ) \n l2tab [ i ] = log2 ( i / 256.0 ) ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n double best_len [ 256 ] ; \n double p = i / 256.0 ; \n for ( j = 0 ; j < 256 ; j ++ ) \n best_len [ j ] = 1 << 30 ; \n for ( j = FFMAX ( i - 10 , 1 ) ; j < FFMIN ( i + 11 , 256 ) ; j ++ ) { \n double occ [ 256 ] = { 0 } ; \n double len = 0 ; \n occ [ j ] = 1.0 ; \n for ( k = 0 ; k < 256 ; k ++ ) { \n double newocc [ 256 ] = { 0 } ; \n for ( m = 0 ; m < 256 ; m ++ ) { \n if ( occ [ m ] ) { \n len -= occ [ m ] * ( p * l2tab [ m ] \n + ( 1 - p ) * l2tab [ 256 - m ] ) ; \n } \n } \n if ( len < best_len [ k ] ) { \n best_len [ k ] = len ; \n best_state [ i ] [ k ] = j ; \n } \n for ( m = 0 ; m < 256 ; m ++ ) { \n if ( occ [ m ] ) { \n newocc [ one_state [ m ] ] += occ [ m ] * p ; \n newocc [ 256 - one_state [ 256 - m ] ] += occ [ m ] * ( 1 - p ) ; \n } \n } \n memcpy ( occ , newocc , sizeof ( occ ) ) ; \n } \n } \n } \n }", "idx": 10539}
{"project": "FFmpeg", "commit_id": "ff486c0f7f6b2ace3f0238660bc06cc35b389676", "target": 0, "func": "static int get_pcm ( HEVCContext * s , int x , int y ) \n { \n int log2_min_pu_size = s -> sps -> log2_min_pu_size ; \n int x_pu = x >> log2_min_pu_size ; \n int y_pu = y >> log2_min_pu_size ; \n if ( x < 0 || x_pu >= s -> sps -> min_pu_width || \n y < 0 || y_pu >= s -> sps -> min_pu_height ) \n return 2 ; \n return s -> is_pcm [ y_pu * s -> sps -> min_pu_width + x_pu ] ; \n }", "idx": 10547}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int16_t calc_lowcomp ( int16_t a , int16_t b0 , int16_t b1 , uint8_t bin ) \n { \n if ( bin < 7 ) { \n if ( ( b0 + 256 ) == b1 ) \n a = 384 ; \n else if ( b0 > b1 ) \n a = FFMAX ( 0 , a - 64 ) ; \n } \n else if ( bin < 20 ) { \n if ( ( b0 + 256 ) == b1 ) \n a = 320 ; \n else if ( b0 > b1 ) \n a = FFMAX ( 0 , a - 64 ) ; \n } \n else { \n a = FFMAX ( 0 , a - 128 ) ; \n } \n return a ; \n }", "idx": 10556}
{"project": "FFmpeg", "commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode ( HEVCContext * s , int rc_rice_param ) \n { \n int prefix = 0 ; \n int suffix = 0 ; \n int last_coeff_abs_level_remaining ; \n int i ; \n while ( prefix < CABAC_MAX_BIN && get_cabac_bypass ( & s -> HEVClc -> cc ) ) \n prefix ++ ; \n if ( prefix < 3 ) { \n for ( i = 0 ; i < rc_rice_param ; i ++ ) \n suffix = ( suffix << 1 ) | get_cabac_bypass ( & s -> HEVClc -> cc ) ; \n last_coeff_abs_level_remaining = ( prefix << rc_rice_param ) + suffix ; \n } else { \n int prefix_minus3 = prefix - 3 ; \n if ( prefix == CABAC_MAX_BIN ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , prefix ) ; \n return 0 ; \n } \n for ( i = 0 ; i < prefix_minus3 + rc_rice_param ; i ++ ) \n suffix = ( suffix << 1 ) | get_cabac_bypass ( & s -> HEVClc -> cc ) ; \n last_coeff_abs_level_remaining = ( ( ( 1 << prefix_minus3 ) + 3 - 1 ) \n << rc_rice_param ) + suffix ; \n } \n return last_coeff_abs_level_remaining ; \n }", "idx": 10609}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window ( AVFormatContext * s , int last ) \n { \n SegmentContext * seg = s -> priv_data ; \n int i , ret = 0 ; \n char buf [ 1024 ] ; \n if ( ( ret = avio_open2 ( & seg -> pb , seg -> list , AVIO_FLAG_WRITE , \n & s -> interrupt_callback , NULL ) ) < 0 ) \n goto fail ; \n avio_printf ( seg -> pb , \" \\n \" ) ; \n avio_printf ( seg -> pb , \" \\n \" ) ; \n avio_printf ( seg -> pb , \" \\n \" , ( int ) seg -> time ) ; \n avio_printf ( seg -> pb , \" \\n \" , \n FFMAX ( 0 , seg -> number - seg -> size ) ) ; \n av_log ( s , AV_LOG_VERBOSE , \" \\n \" , \n FFMAX ( 0 , seg -> number - seg -> size ) ) ; \n for ( i = FFMAX ( 0 , seg -> number - seg -> size ) ; \n i < seg -> number ; i ++ ) { \n avio_printf ( seg -> pb , \" \\n \" , ( int ) seg -> time ) ; \n if ( seg -> entry_prefix ) { \n avio_printf ( seg -> pb , \" \" , seg -> entry_prefix ) ; \n } \n ret = av_get_frame_filename ( buf , sizeof ( buf ) , s -> filename , i ) ; \n if ( ret < 0 ) { \n ret = AVERROR ( EINVAL ) ; \n goto fail ; \n } \n avio_printf ( seg -> pb , \" \\n \" , buf ) ; \n } \n if ( last ) \n avio_printf ( seg -> pb , \" \\n \" ) ; \n fail : \n avio_closep ( & seg -> pb ) ; \n return ret ; \n }", "idx": 10620}
{"project": "FFmpeg", "commit_id": "fa5dacce143f3fbe8eac14d5a99e926b2787e9e6", "target": 1, "func": "static int decode_pic_hdr ( IVI5DecContext * ctx , AVCodecContext * avctx ) \n { \n if ( get_bits ( & ctx -> gb , 5 ) != 0x1F ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n ctx -> prev_frame_type = ctx -> frame_type ; \n ctx -> frame_type = get_bits ( & ctx -> gb , 3 ) ; \n if ( ctx -> frame_type >= 5 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , ctx -> frame_type ) ; \n return -1 ; \n ctx -> frame_num = get_bits ( & ctx -> gb , 8 ) ; \n if ( ctx -> frame_type == FRAMETYPE_INTRA ) { \n ctx -> gop_invalid = 1 ; \n if ( decode_gop_header ( ctx , avctx ) ) \n return -1 ; \n ctx -> gop_invalid = 0 ; \n if ( ctx -> frame_type != FRAMETYPE_NULL ) { \n ctx -> frame_flags = get_bits ( & ctx -> gb , 8 ) ; \n ctx -> pic_hdr_size = ( ctx -> frame_flags & 1 ) ? get_bits_long ( & ctx -> gb , 24 ) : 0 ; \n ctx -> checksum = ( ctx -> frame_flags & 0x10 ) ? get_bits ( & ctx -> gb , 16 ) : 0 ; \n if ( ctx -> frame_flags & 0x20 ) \n skip_hdr_extension ( & ctx -> gb ) ; \n if ( ff_ivi_dec_huff_desc ( & ctx -> gb , ctx -> frame_flags & 0x40 , IVI_MB_HUFF , & ctx -> mb_vlc , avctx ) ) \n return -1 ; \n skip_bits ( & ctx -> gb , 3 ) ; \n align_get_bits ( & ctx -> gb ) ; \n return 0 ;", "idx": 10671}
{"project": "FFmpeg", "commit_id": "5a446bc88e49cc6400d0c646ca1eb540a727c9de", "target": 1, "func": "static void vc1_v_overlap_c ( uint8_t * src , int stride ) \n { \n int i ; \n int a , b , c , d ; \n int d1 , d2 ; \n int rnd = 1 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n a = src [ -2 * stride ] ; \n b = src [ - stride ] ; \n c = src [ 0 ] ; \n d = src [ stride ] ; \n d1 = ( a - d + 3 + rnd ) >> 3 ; \n d2 = ( a - d + b - c + 4 - rnd ) >> 3 ; \n src [ -2 * stride ] = a - d1 ; \n src [ - stride ] = b - d2 ; \n src [ 0 ] = c + d2 ; \n src [ stride ] = d + d1 ; \n src ++ ; \n rnd = ! rnd ; \n } \n }", "idx": 10723}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int sox_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n int ret , size ; \n if ( url_feof ( s -> pb ) ) \n return AVERROR_EOF ; \n size = SOX_SAMPLES * s -> streams [ 0 ] -> codec -> block_align ; \n ret = av_get_packet ( s -> pb , pkt , size ) ; \n if ( ret < 0 ) \n return AVERROR ( EIO ) ; \n pkt -> stream_index = 0 ; \n pkt -> size = ret ; \n return 0 ; \n }", "idx": 10772}
{"project": "FFmpeg", "commit_id": "d094052c8e8a036666ac02bfc52bf221ad39e4c8", "target": 1, "func": "static av_cold int svq1_encode_init ( AVCodecContext * avctx ) \n { \n SVQ1Context * const s = avctx -> priv_data ; \n dsputil_init ( & s -> dsp , avctx ) ; \n avctx -> coded_frame = ( AVFrame * ) & s -> picture ; \n s -> frame_width = avctx -> width ; \n s -> frame_height = avctx -> height ; \n s -> y_block_width = ( s -> frame_width + 15 ) / 16 ; \n s -> y_block_height = ( s -> frame_height + 15 ) / 16 ; \n s -> c_block_width = ( s -> frame_width / 4 + 15 ) / 16 ; \n s -> c_block_height = ( s -> frame_height / 4 + 15 ) / 16 ; \n s -> avctx = avctx ; \n s -> m . avctx = avctx ; \n s -> m . me . scratchpad = av_mallocz ( ( avctx -> width + 64 ) * 2 * 16 * 2 * sizeof ( uint8_t ) ) ; \n s -> m . me . map = av_mallocz ( ME_MAP_SIZE * sizeof ( uint32_t ) ) ; \n s -> m . me . score_map = av_mallocz ( ME_MAP_SIZE * sizeof ( uint32_t ) ) ; \n s -> mb_type = av_mallocz ( ( s -> y_block_width + 1 ) * s -> y_block_height * sizeof ( int16_t ) ) ; \n s -> dummy = av_mallocz ( ( s -> y_block_width + 1 ) * s -> y_block_height * sizeof ( int32_t ) ) ; \n h263_encode_init ( & s -> m ) ; \n return 0 ; \n }", "idx": 10773}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr15 ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) \n { \n unsigned i ; \n unsigned num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x3E0 ) >> 5 ; \n b = ( rgb & 0x7C00 ) >> 10 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x1F ) << 5 ) | ( ( r & 0x1F ) << 10 ) ; \n } \n }", "idx": 10849}
{"project": "FFmpeg", "commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "target": 1, "func": "static int lag_decode_prob ( GetBitContext * gb , uint32_t * value ) \n { \n static const uint8_t series [ ] = { 1 , 2 , 3 , 5 , 8 , 13 , 21 } ; \n int i ; \n int bit = 0 ; \n int bits = 0 ; \n int prevbit = 0 ; \n unsigned val ; \n for ( i = 0 ; i < 7 ; i ++ ) { \n if ( prevbit && bit ) \n break ; \n prevbit = bit ; \n bit = get_bits1 ( gb ) ; \n if ( bit && ! prevbit ) \n bits += series [ i ] ; \n } \n bits -- ; \n if ( bits < 0 || bits > 31 ) { \n * value = 0 ; \n return -1 ; \n } else if ( bits == 0 ) { \n * value = 0 ; \n return 0 ; \n } \n val = get_bits_long ( gb , bits ) ; \n val |= 1 << bits ; \n * value = val - 1 ; \n return 0 ; \n }", "idx": 10868}
{"project": "FFmpeg", "commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "target": 1, "func": "static void check_add_res ( HEVCDSPContext h , int bit_depth ) \n { \n int i ; \n LOCAL_ALIGNED_32 ( int16_t , res0 ,  [ 32 * 32 ] ) ; \n LOCAL_ALIGNED_32 ( int16_t , res1 ,  [ 32 * 32 ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , dst0 ,  [ 32 * 32 * 2 ] ) ; \n LOCAL_ALIGNED_32 ( uint8_t , dst1 ,  [ 32 * 32 * 2 ] ) ; \n for ( i = 2 ; i <= 5 ; i ++ ) { \n int block_size = 1 << i ; \n int size = block_size * block_size ; \n ptrdiff_t stride = block_size << ( bit_depth > 8 ) ; \n declare_func_emms ( AV_CPU_FLAG_MMX , void , uint8_t * dst , int16_t * res , ptrdiff_t stride ) ; \n randomize_buffers ( res0 , size ) ; \n randomize_buffers2 ( dst0 , size ) ; \n memcpy ( res1 , res0 , sizeof ( * res0 ) * size ) ; \n memcpy ( dst1 , dst0 , size ) ; \n if ( check_func ( h . add_residual [ i - 2 ] , \" \" , block_size , block_size , bit_depth ) ) { \n call_ref ( dst0 , res0 , stride ) ; \n call_new ( dst1 , res1 , stride ) ; \n if ( memcmp ( dst0 , dst1 , size ) ) \n fail ( ) ; \n bench_new ( dst1 , res1 , stride ) ; \n } \n } \n }", "idx": 10869}
{"project": "FFmpeg", "commit_id": "af8aa846fa5b9f2c7dcde451c872426528b8b561", "target": 0, "func": "static void frame_start ( H264Context * h ) { \n MpegEncContext * const s = & h -> s ; \n int i ; \n MPV_frame_start ( s , s -> avctx ) ; \n ff_er_frame_start ( s ) ; \n assert ( s -> linesize && s -> uvlinesize ) ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n h -> block_offset [ i ] = 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) + 4 * s -> linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ; \n h -> block_offset [ 24 + i ] = 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) + 8 * s -> linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n h -> block_offset [ 16 + i ] = \n h -> block_offset [ 20 + i ] = 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) + 4 * s -> uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ; \n h -> block_offset [ 24 + 16 + i ] = \n h -> block_offset [ 24 + 20 + i ] = 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) + 8 * s -> uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ; \n } \n if ( ! s -> obmc_scratchpad ) \n s -> obmc_scratchpad = av_malloc ( 16 * s -> linesize + 2 * 8 * s -> uvlinesize ) ; \n }", "idx": 11026}
{"project": "FFmpeg", "commit_id": "c9aab8a123c0bcf6adeab390db1ec783326456ca", "target": 0, "func": "static void fill_colmap ( H264Context * h , int map [ 2 ] [ 16 + 32 ] , int list , int field , int colfield , int mbafi ) { \n MpegEncContext * const s = & h -> s ; \n Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ; \n int j , old_ref , rfield ; \n int start = mbafi ? 16 : 0 ; \n int end = mbafi ? 16 + 2 * h -> ref_count [ 0 ] : h -> ref_count [ 0 ] ; \n int interl = mbafi || s -> picture_structure != PICT_FRAME ; \n memset ( map [ list ] , 0 , sizeof ( map [ list ] ) ) ; \n for ( rfield = 0 ; rfield < 2 ; rfield ++ ) { \n for ( old_ref = 0 ; old_ref < ref1 -> ref_count [ colfield ] [ list ] ; old_ref ++ ) { \n int poc = ref1 -> ref_poc [ colfield ] [ list ] [ old_ref ] ; \n if ( ! interl ) \n poc |= 3 ; \n else if ( interl && ( poc & 3 ) == 3 ) \n poc = ( poc & ~ 3 ) + rfield + 1 ; \n for ( j = start ; j < end ; j ++ ) { \n if ( 4 * h -> ref_list [ 0 ] [ j ] . frame_num + ( h -> ref_list [ 0 ] [ j ] . f . reference & 3 ) == poc ) { \n int cur_ref = mbafi ? ( j - 16 ) ^ field : j ; \n map [ list ] [ 2 * old_ref + ( rfield ^ field ) + 16 ] = cur_ref ; \n if ( rfield == field || ! interl ) \n map [ list ] [ old_ref ] = cur_ref ; \n break ; \n } \n } \n } \n } \n }", "idx": 11080}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_frame_duration ( int * pnum , int * pden , \n AVFormatContext * s , AVStream * st , \n AVCodecParserContext * pc , AVPacket * pkt ) \n { \n int frame_size ; \n * pnum = 0 ; \n * pden = 0 ; \n switch ( st -> codec . codec_type ) { \n case CODEC_TYPE_VIDEO : \n * pnum = st -> codec . frame_rate_base ; \n * pden = st -> codec . frame_rate ; \n if ( pc && pc -> repeat_pict ) { \n * pden *= 2 ; \n * pnum = ( * pnum ) * ( 2 + pc -> repeat_pict ) ; \n } \n break ; \n case CODEC_TYPE_AUDIO : \n frame_size = get_audio_frame_size ( & st -> codec , pkt -> size ) ; \n if ( frame_size < 0 ) \n break ; \n * pnum = frame_size ; \n * pden = st -> codec . sample_rate ; \n break ; \n default : \n break ; \n } \n }", "idx": 11084}
{"project": "FFmpeg", "commit_id": "c4e554701ec27b31b1b6396130b8bb2aaa0d4ad0", "target": 0, "func": "DVDemuxContext * dv_init_demux ( AVFormatContext * s ) \n { \n DVDemuxContext * c ; \n c = av_mallocz ( sizeof ( DVDemuxContext ) ) ; \n if ( ! c ) \n return NULL ; \n c -> vst = av_new_stream ( s , 0 ) ; \n c -> ast [ 0 ] = av_new_stream ( s , 0 ) ; \n if ( ! c -> vst || ! c -> ast [ 0 ] ) \n goto fail ; \n av_set_pts_info ( c -> vst , 64 , 1 , 30000 ) ; \n av_set_pts_info ( c -> ast [ 0 ] , 64 , 1 , 30000 ) ; \n c -> fctx = s ; \n c -> ast [ 1 ] = NULL ; \n c -> ach = 0 ; \n c -> frames = 0 ; \n c -> abytes = 0 ; \n c -> audio_pkt [ 0 ] . size = 0 ; \n c -> audio_pkt [ 1 ] . size = 0 ; \n c -> vst -> codec . codec_type = CODEC_TYPE_VIDEO ; \n c -> vst -> codec . codec_id = CODEC_ID_DVVIDEO ; \n c -> vst -> codec . bit_rate = 25000000 ; \n c -> ast [ 0 ] -> codec . codec_type = CODEC_TYPE_AUDIO ; \n c -> ast [ 0 ] -> codec . codec_id = CODEC_ID_PCM_S16LE ; \n s -> ctx_flags |= AVFMTCTX_NOHEADER ; \n return c ; \n fail : \n if ( c -> vst ) \n av_free ( c -> vst ) ; \n if ( c -> ast [ 0 ] ) \n av_free ( c -> ast [ 0 ] ) ; \n av_free ( c ) ; \n return NULL ; \n }", "idx": 11140}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static av_cold void init_atrac3_transforms ( ATRAC3Context * q ) { \n float enc_window [ 256 ] ; \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) \n enc_window [ i ] = ( sin ( ( ( i + 0.5 ) / 256.0 - 0.5 ) * M_PI ) + 1.0 ) * 0.5 ; \n if ( ! mdct_window [ 0 ] ) \n for ( i = 0 ; i < 256 ; i ++ ) { \n mdct_window [ i ] = enc_window [ i ] / ( enc_window [ i ] * enc_window [ i ] + enc_window [ 255 - i ] * enc_window [ 255 - i ] ) ; \n mdct_window [ 511 - i ] = mdct_window [ i ] ; \n } \n ff_mdct_init ( & mdct_ctx , 9 , 1 , 1.0 ) ; \n }", "idx": 11361}
{"project": "FFmpeg", "commit_id": "3df2be9fa7365646f22a93cfde1e4097467f498e", "target": 1, "func": "static void matroska_fix_ass_packet ( MatroskaDemuxContext * matroska , \n AVPacket * pkt , uint64_t display_duration ) \n { \n char * line , * layer , * ptr = pkt -> data , * end = ptr + pkt -> size ; \n for ( ; * ptr != ' ' && ptr < end - 1 ; ptr ++ ) ; \n if ( * ptr == ' ' ) \n layer = ++ ptr ; \n for ( ; * ptr != ' ' && ptr < end - 1 ; ptr ++ ) ; \n if ( * ptr == ' ' ) { \n int64_t end_pts = pkt -> pts + display_duration ; \n int sc = matroska -> time_scale * pkt -> pts / 10000000 ; \n int ec = matroska -> time_scale * end_pts / 10000000 ; \n int sh , sm , ss , eh , em , es , len ; \n sh = sc / 360000 ; sc -= 360000 * sh ; \n sm = sc / 6000 ; sc -= 6000 * sm ; \n ss = sc / 100 ; sc -= 100 * ss ; \n eh = ec / 360000 ; ec -= 360000 * eh ; \n em = ec / 6000 ; ec -= 6000 * em ; \n es = ec / 100 ; ec -= 100 * es ; \n * ptr ++ = ' \\0 ' ; \n len = 50 + end - ptr + FF_INPUT_BUFFER_PADDING_SIZE ; \n if ( ! ( line = av_malloc ( len ) ) ) \n return ; \n snprintf ( line , len , \" \" , \n layer , sh , sm , ss , sc , eh , em , es , ec , ptr ) ; \n av_free ( pkt -> data ) ; \n pkt -> data = line ; \n pkt -> size = strlen ( line ) ; \n } \n }", "idx": 11383}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "void FUNCC ( ff_h264_idct_dc_add ) ( uint8_t * _dst , int16_t * block , int stride ) { \n int i , j ; \n int dc = ( ( ( dctcoef * ) block ) [ 0 ] + 32 ) >> 6 ; \n pixel * dst = ( pixel * ) _dst ; \n stride >>= sizeof ( pixel ) - 1 ; \n for ( j = 0 ; j < 4 ; j ++ ) \n { \n for ( i = 0 ; i < 4 ; i ++ ) \n dst [ i ] = av_clip_pixel ( dst [ i ] + dc ) ; \n dst += stride ; \n } \n }", "idx": 11423}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "void ff_vc1_decode_blocks ( VC1Context * v ) \n { \n v -> s . esc3_level_length = 0 ; \n if ( v -> x8_type ) { \n ff_intrax8_decode_picture ( & v -> x8 , 2 * v -> pq + v -> halfpq , v -> pq * ! v -> pquantizer ) ; \n ff_er_add_slice ( & v -> s . er , 0 , 0 , \n ( v -> s . mb_x >> 1 ) - 1 , ( v -> s . mb_y >> 1 ) - 1 , \n ER_MB_END ) ; \n } else { \n v -> cur_blk_idx = 0 ; \n v -> left_blk_idx = -1 ; \n v -> topleft_blk_idx = 1 ; \n v -> top_blk_idx = 2 ; \n switch ( v -> s . pict_type ) { \n case AV_PICTURE_TYPE_I : \n if ( v -> profile == PROFILE_ADVANCED ) \n vc1_decode_i_blocks_adv ( v ) ; \n else \n vc1_decode_i_blocks ( v ) ; \n break ; \n case AV_PICTURE_TYPE_P : \n if ( v -> p_frame_skipped ) \n vc1_decode_skip_blocks ( v ) ; \n else \n vc1_decode_p_blocks ( v ) ; \n break ; \n case AV_PICTURE_TYPE_B : \n if ( v -> bi_type ) { \n if ( v -> profile == PROFILE_ADVANCED ) \n vc1_decode_i_blocks_adv ( v ) ; \n else \n vc1_decode_i_blocks ( v ) ; \n } else \n vc1_decode_b_blocks ( v ) ; \n break ; \n } \n } \n }", "idx": 11428}
{"project": "FFmpeg", "commit_id": "8ce803db51a28eb662b6271b2b223e0312bdb3d2", "target": 1, "func": "paint_mouse_pointer ( XImage * image , struct x11_grab * s )  \n { \n int x_off = s -> x_off ; \n int y_off = s -> y_off ; \n int width = s -> width ; \n int height = s -> height ; \n Display * dpy = s -> dpy ; \n XFixesCursorImage * xcim ; \n int x , y ; \n int line , column ; \n int to_line , to_column ; \n int image_addr , xcim_addr ; \n xcim = XFixesGetCursorImage ( dpy ) ; \n x = xcim -> x - xcim -> xhot ; \n y = xcim -> y - xcim -> yhot ; \n to_line = FFMIN ( ( y + xcim -> height ) , ( height + y_off ) ) ; \n to_column = FFMIN ( ( x + xcim -> width ) , ( width + x_off ) ) ; \n for ( line = FFMAX ( y , y_off ) ; line < to_line ; line ++ ) { \n for ( column = FFMAX ( x , x_off ) ; column < to_column ; column ++ ) { \n xcim_addr = ( line - y ) * xcim -> width + column - x ; \n if ( ( unsigned char ) ( xcim -> pixels [ xcim_addr ] >> 24 ) != 0 ) { \n image_addr = ( ( line - y_off ) * width + column - x_off ) * 4 ; \n image -> data [ image_addr ] = ( unsigned char ) ( xcim -> pixels [ xcim_addr ] >> 0 ) ; \n image -> data [ image_addr + 1 ] = ( unsigned char ) ( xcim -> pixels [ xcim_addr ] >> 8 ) ; \n image -> data [ image_addr + 2 ] = ( unsigned char ) ( xcim -> pixels [ xcim_addr ] >> 16 ) ; \n } \n } \n } \n XFree ( xcim ) ; \n xcim = NULL ; \n }", "idx": 11433}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int avfilter_register ( AVFilter * filter ) \n { \n if ( next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB ) \n return -1 ; \n registered_avfilters [ next_registered_avfilter_idx ++ ] = filter ; \n return 0 ; \n }", "idx": 11444}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "static av_noinline void emulated_edge_mc_sse ( uint8_t * buf , const uint8_t * src , \n ptrdiff_t buf_stride , \n ptrdiff_t src_stride , \n int block_w , int block_h , \n int src_x , int src_y , int w , int h ) \n { \n emulated_edge_mc ( buf , src , buf_stride , src_stride , block_w , block_h , \n src_x , src_y , w , h , vfixtbl_sse , & ff_emu_edge_vvar_sse , \n hfixtbl_mmxext , & ff_emu_edge_hvar_mmxext ) ; \n }", "idx": 11468}
{"project": "FFmpeg", "commit_id": "0d021cc8b30a6f81c27fbeca7f99f1ee7a20acf8", "target": 0, "func": "static av_cold int check_cuda_errors ( AVCodecContext * avctx , CUresult err , const char * func ) \n { \n if ( err != CUDA_SUCCESS ) { \n av_log ( avctx , AV_LOG_FATAL , \" \\n \" , func , err ) ; \n return 0 ; \n } \n return 1 ; \n }", "idx": 11529}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block ( GetBitContext * gb , DCTELEM * block , const uint8_t * scan , \n const uint32_t * quant ) { \n int coeff , i , n ; \n int8_t ac ; \n uint8_t dc = get_bits ( gb , 8 ) ; \n if ( dc == 255 ) \n coeff = get_bits ( gb , 6 ) ; \n if ( get_bits_count ( gb ) + ( coeff << 1 ) >= gb -> size_in_bits ) \n memset ( block , 0 , 64 * sizeof ( DCTELEM ) ) ; \n while ( coeff ) { \n ac = get_sbits ( gb , 2 ) ; \n if ( ac == -2 ) \n break ; \n PUT_COEFF ( ac ) ; \n } \n ALIGN ( 4 ) ; \n while ( coeff ) { \n ac = get_sbits ( gb , 4 ) ; \n if ( ac == -8 ) \n break ; \n PUT_COEFF ( ac ) ; \n } \n ALIGN ( 8 ) ; \n if ( get_bits_count ( gb ) + ( coeff << 3 ) >= gb -> size_in_bits ) \n while ( coeff ) { \n ac = get_sbits ( gb , 8 ) ; \n PUT_COEFF ( ac ) ; \n } \n PUT_COEFF ( dc ) ; \n return 1 ; \n }", "idx": 11543}
{"project": "FFmpeg", "commit_id": "6722e564a82bac471d92b02550b5017c09b539ba", "target": 0, "func": "static int parse_header ( OutputStream * os , const uint8_t * buf , int buf_size ) \n { \n if ( buf_size < 13 ) \n return AVERROR_INVALIDDATA ; \n if ( memcmp ( buf , \" \" , 3 ) ) \n return AVERROR_INVALIDDATA ; \n buf += 13 ; \n buf_size -= 13 ; \n while ( buf_size >= 11 + 4 ) { \n int type = buf [ 0 ] ; \n int size = AV_RB24 ( & buf [ 1 ] ) + 11 + 4 ; \n if ( size > buf_size ) \n return AVERROR_INVALIDDATA ; \n if ( type == 8 || type == 9 ) { \n if ( os -> nb_extra_packets > FF_ARRAY_ELEMS ( os -> extra_packets ) ) \n return AVERROR_INVALIDDATA ; \n os -> extra_packet_sizes [ os -> nb_extra_packets ] = size ; \n os -> extra_packets [ os -> nb_extra_packets ] = av_malloc ( size ) ; \n if ( ! os -> extra_packets [ os -> nb_extra_packets ] ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( os -> extra_packets [ os -> nb_extra_packets ] , buf , size ) ; \n os -> nb_extra_packets ++ ; \n } else if ( type == 0x12 ) { \n if ( os -> metadata ) \n return AVERROR_INVALIDDATA ; \n os -> metadata_size = size - 11 - 4 ; \n os -> metadata = av_malloc ( os -> metadata_size ) ; \n if ( ! os -> metadata ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( os -> metadata , buf + 11 , os -> metadata_size ) ; \n } \n buf += size ; \n buf_size -= size ; \n } \n if ( ! os -> metadata ) \n return AVERROR_INVALIDDATA ; \n return 0 ; \n }", "idx": 11553}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( nv12ToUV ) ( uint8_t * dstU , uint8_t * dstV , \n const uint8_t * src1 , const uint8_t * src2 , \n long width , uint32_t * unused ) \n { \n RENAME ( nvXXtoUV ) ( dstU , dstV , src1 , width ) ; \n }", "idx": 11662}
{"project": "FFmpeg", "commit_id": "30e256430eb88c6d4c382581b89bca171d79fbc0", "target": 0, "func": "int ff_thread_init ( AVCodecContext * avctx ) \n { \n if ( avctx -> thread_opaque ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n #if HAVE_W32THREADS  \n  \n  w32thread_init ( ) ; \n #endif \n if ( avctx -> codec ) { \n validate_thread_parameters ( avctx ) ; \n if ( avctx -> active_thread_type & FF_THREAD_SLICE ) \n return thread_init ( avctx ) ; \n else if ( avctx -> active_thread_type & FF_THREAD_FRAME ) \n return frame_thread_init ( avctx ) ; \n } \n return 0 ; \n }", "idx": 11665}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void copy_frame ( Jpeg2000EncoderContext * s ) \n { \n int tileno , compno , i , y , x ; \n uint8_t * line ; \n for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { \n Jpeg2000Tile * tile = s -> tile + tileno ; \n if ( s -> planar ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n Jpeg2000Component * comp = tile -> comp + compno ; \n int * dst = comp -> data ; \n line = s -> picture . data [ compno ] \n + comp -> coord [ 1 ] [ 0 ] * s -> picture . linesize [ compno ] \n + comp -> coord [ 0 ] [ 0 ] ; \n for ( y = comp -> coord [ 1 ] [ 0 ] ; y < comp -> coord [ 1 ] [ 1 ] ; y ++ ) { \n uint8_t * ptr = line ; \n for ( x = comp -> coord [ 0 ] [ 0 ] ; x < comp -> coord [ 0 ] [ 1 ] ; x ++ ) \n * dst ++ = * ptr ++ - ( 1 << 7 ) ; \n line += s -> picture . linesize [ compno ] ; \n } \n } \n } else { \n line = s -> picture . data [ 0 ] + tile -> comp [ 0 ] . coord [ 1 ] [ 0 ] * s -> picture . linesize [ 0 ] \n + tile -> comp [ 0 ] . coord [ 0 ] [ 0 ] * s -> ncomponents ; \n i = 0 ; \n for ( y = tile -> comp [ 0 ] . coord [ 1 ] [ 0 ] ; y < tile -> comp [ 0 ] . coord [ 1 ] [ 1 ] ; y ++ ) { \n uint8_t * ptr = line ; \n for ( x = tile -> comp [ 0 ] . coord [ 0 ] [ 0 ] ; x < tile -> comp [ 0 ] . coord [ 0 ] [ 1 ] ; x ++ , i ++ ) { \n for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { \n tile -> comp [ compno ] . data [ i ] = * ptr ++ - ( 1 << 7 ) ; \n } \n } \n line += s -> picture . linesize [ 0 ] ; \n } \n } \n } \n }", "idx": 11749}
{"project": "FFmpeg", "commit_id": "138568e9da0e3abfc818329ab12ea3fb667639fb", "target": 0, "func": "static int mov_read_ctts ( MOVContext * c , ByteIOContext * pb , MOV_atom_t atom ) \n { \n AVStream * st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n MOVStreamContext * sc = st -> priv_data ; \n unsigned int i , entries ; \n get_byte ( pb ) ; \n get_be24 ( pb ) ; \n entries = get_be32 ( pb ) ; \n if ( entries >= UINT_MAX / sizeof ( MOV_stts_t ) ) \n return -1 ; \n sc -> ctts_count = entries ; \n sc -> ctts_data = av_malloc ( entries * sizeof ( MOV_stts_t ) ) ; \n if ( ! sc -> ctts_data ) \n return -1 ; \n dprintf ( c -> fc , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n for ( i = 0 ; i < entries ; i ++ ) { \n int count = get_be32 ( pb ) ; \n int duration = get_be32 ( pb ) ; \n if ( duration < 0 ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" ) ; \n sc -> ctts_count = 0 ; \n url_fskip ( pb , 8 * ( entries - i - 1 ) ) ; \n break ; \n } \n sc -> ctts_data [ i ] . count = count ; \n sc -> ctts_data [ i ] . duration = duration ; \n sc -> time_rate = ff_gcd ( sc -> time_rate , duration ) ; \n } \n return 0 ; \n }", "idx": 11795}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "int64_t av_get_int ( void * obj , const char * name , const AVOption * * o_out ) \n { \n int64_t intnum = 1 ; \n double num = 1 ; \n int den = 1 ; \n av_get_number ( obj , name , o_out , & num , & den , & intnum ) ; \n return num * intnum / den ; \n }", "idx": 11806}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_ftyp ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n uint32_t minor_ver ; \n int comp_brand_size ; \n char minor_ver_str [ 11 ] ; \n char * comp_brands_str ; \n uint8_t type [ 5 ] = { 0 } ; \n avio_read ( pb , type , 4 ) ; \n if ( strcmp ( type , \" \" ) ) \n c -> isom = 1 ; \n av_log ( c -> fc , AV_LOG_DEBUG , \" \\n \" , ( char * ) & type ) ; \n av_dict_set ( & c -> fc -> metadata , \" \" , type , 0 ) ; \n minor_ver = avio_rb32 ( pb ) ; \n snprintf ( minor_ver_str , sizeof ( minor_ver_str ) , \" \" PRIu32 \" \" , minor_ver ) ; \n av_dict_set ( & c -> fc -> metadata , \" \" , minor_ver_str , 0 ) ; \n comp_brand_size = atom . size - 8 ; \n if ( comp_brand_size < 0 ) \n return AVERROR_INVALIDDATA ; \n comp_brands_str = av_malloc ( comp_brand_size + 1 ) ; \n if ( ! comp_brands_str ) \n return AVERROR ( ENOMEM ) ; \n avio_read ( pb , comp_brands_str , comp_brand_size ) ; \n comp_brands_str [ comp_brand_size ] = 0 ; \n av_dict_set ( & c -> fc -> metadata , \" \" , comp_brands_str , 0 ) ; \n av_freep ( & comp_brands_str ) ; \n return 0 ; \n }", "idx": 11979}
{"project": "FFmpeg", "commit_id": "405af431040a57c630716b3940d7240021e8b80c", "target": 0, "func": "static int cinaudio_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n CinAudioContext * cin = avctx -> priv_data ; \n const uint8_t * src = buf ; \n int16_t * samples = data ; \n int delta ; \n buf_size = FFMIN ( buf_size , * data_size / 2 ) ; \n delta = cin -> delta ; \n if ( cin -> initial_decode_frame ) { \n cin -> initial_decode_frame = 0 ; \n delta = ( int16_t ) AV_RL16 ( src ) ; src += 2 ; \n * samples ++ = delta ; \n buf_size -= 2 ; \n } \n while ( buf_size > 0 ) { \n delta += cinaudio_delta16_table [ * src ++ ] ; \n delta = av_clip_int16 ( delta ) ; \n * samples ++ = delta ; \n -- buf_size ; \n } \n cin -> delta = delta ; \n * data_size = ( uint8_t * ) samples - ( uint8_t * ) data ; \n return src - buf ; \n }", "idx": 12099}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char * seq_unpack_rle_block ( const unsigned char * src , unsigned char * dst , int dst_size ) \n { \n int i , len , sz ; \n GetBitContext gb ; \n int code_table [ 64 ] ; \n init_get_bits ( & gb , src , 64 * 8 ) ; \n for ( i = 0 , sz = 0 ; i < 64 && sz < dst_size ; i ++ ) { \n code_table [ i ] = get_sbits ( & gb , 4 ) ; \n sz += FFABS ( code_table [ i ] ) ; \n } \n src += ( get_bits_count ( & gb ) + 7 ) / 8 ; \n for ( i = 0 ; i < 64 && dst_size > 0 ; i ++ ) { \n len = code_table [ i ] ; \n if ( len < 0 ) { \n len = - len ; \n memset ( dst , * src ++ , FFMIN ( len , dst_size ) ) ; \n } else { \n memcpy ( dst , src , FFMIN ( len , dst_size ) ) ; \n src += len ; \n } \n dst += len ; \n dst_size -= len ; \n } \n return src ; \n }", "idx": 12216}
{"project": "FFmpeg", "commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "target": 1, "func": "static AVIOContext * wtvfile_open2 ( AVFormatContext * s , const uint8_t * buf , int buf_size , const uint8_t * filename , int filename_size ) \n { \n const uint8_t * buf_end = buf + buf_size ; \n while ( buf + 48 <= buf_end ) { \n int dir_length , name_size , first_sector , depth ; \n uint64_t file_length ; \n const uint8_t * name ; \n if ( ff_guidcmp ( buf , dir_entry_guid ) ) { \n av_log ( s , AV_LOG_ERROR , \" \" FF_PRI_GUID \" \" \n \" \\n \" , FF_ARG_GUID ( buf ) ) ; \n break ; \n } \n dir_length = AV_RL16 ( buf + 16 ) ; \n file_length = AV_RL64 ( buf + 24 ) ; \n name_size = 2 * AV_RL32 ( buf + 32 ) ; \n if ( buf + 48 + name_size > buf_end ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n break ; \n } \n first_sector = AV_RL32 ( buf + 40 + name_size ) ; \n depth = AV_RL32 ( buf + 44 + name_size ) ; \n name = buf + 40 ; \n if ( name_size >= filename_size && \n ! memcmp ( name , filename , filename_size ) && \n ( name_size < filename_size + 2 || ! AV_RN16 ( name + filename_size ) ) ) \n return wtvfile_open_sector ( first_sector , file_length , depth , s ) ; \n buf += dir_length ; \n } \n return 0 ; \n }", "idx": 12273}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int idcin_decode_init ( AVCodecContext * avctx ) \n { \n IdcinContext * s = avctx -> priv_data ; \n int i , j , histogram_index = 0 ; \n unsigned char * histograms ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = PIX_FMT_PAL8 ; \n dsputil_init ( & s -> dsp , avctx ) ; \n if ( s -> avctx -> extradata_size != HUFFMAN_TABLE_SIZE ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , HUFFMAN_TABLE_SIZE ) ; \n return -1 ; \n } \n histograms = ( unsigned char * ) s -> avctx -> extradata ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n for ( j = 0 ; j < HUF_TOKENS ; j ++ ) \n s -> huff_nodes [ i ] [ j ] . count = histograms [ histogram_index ++ ] ; \n huff_build_tree ( s , i ) ; \n } \n s -> frame . data [ 0 ] = NULL ; \n return 0 ; \n }", "idx": 12305}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int ogg_build_flac_headers ( const uint8_t * extradata , int extradata_size , \n OGGStreamContext * oggstream , int bitexact ) \n { \n const char * vendor = bitexact ? \" \" : LIBAVFORMAT_IDENT ; \n uint8_t * p ; \n if ( extradata_size != 34 ) \n return -1 ; \n oggstream -> header_len [ 0 ] = 51 ; \n oggstream -> header [ 0 ] = av_mallocz ( 51 ) ; \n p = oggstream -> header [ 0 ] ; \n bytestream_put_byte ( & p , 0x7F ) ; \n bytestream_put_buffer ( & p , \" \" , 4 ) ; \n bytestream_put_byte ( & p , 1 ) ; \n bytestream_put_byte ( & p , 0 ) ; \n bytestream_put_be16 ( & p , 1 ) ; \n bytestream_put_buffer ( & p , \" \" , 4 ) ; \n bytestream_put_byte ( & p , 0x00 ) ; \n bytestream_put_be24 ( & p , 34 ) ; \n bytestream_put_buffer ( & p , extradata , 34 ) ; \n oggstream -> header_len [ 1 ] = 1 + 3 + 4 + strlen ( vendor ) + 4 ; \n oggstream -> header [ 1 ] = av_mallocz ( oggstream -> header_len [ 1 ] ) ; \n p = oggstream -> header [ 1 ] ; \n bytestream_put_byte ( & p , 0x84 ) ; \n bytestream_put_be24 ( & p , oggstream -> header_len [ 1 ] - 4 ) ; \n bytestream_put_le32 ( & p , strlen ( vendor ) ) ; \n bytestream_put_buffer ( & p , vendor , strlen ( vendor ) ) ; \n bytestream_put_le32 ( & p , 0 ) ; \n return 0 ; \n }", "idx": 12353}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe ( DCAEncContext * c , int subframe ) \n { \n int i , band , ss , ch ; \n put_bits ( & c -> pb , 2 , SUBSUBFRAMES - 1 ) ; \n put_bits ( & c -> pb , 3 , 0 ) ; \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n for ( band = 0 ; band < DCAENC_SUBBANDS ; band ++ ) \n put_bits ( & c -> pb , 1 , 0 ) ; \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n for ( band = 0 ; band < DCAENC_SUBBANDS ; band ++ ) \n put_bits ( & c -> pb , 5 , c -> abits [ band ] [ ch ] ) ; \n if ( SUBSUBFRAMES > 1 ) { \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n for ( band = 0 ; band < DCAENC_SUBBANDS ; band ++ ) \n put_bits ( & c -> pb , 1 , 0 ) ; \n } \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n for ( band = 0 ; band < DCAENC_SUBBANDS ; band ++ ) \n put_bits ( & c -> pb , 7 , c -> scale_factor [ band ] [ ch ] ) ; \n if ( c -> lfe_channel ) { \n for ( i = 0 ; i < DCA_LFE_SAMPLES ; i ++ ) \n put_bits ( & c -> pb , 8 , quantize_value ( c -> downsampled_lfe [ i ] , c -> lfe_quant ) & 0xff ) ; \n put_bits ( & c -> pb , 8 , c -> lfe_scale_factor ) ; \n } \n for ( ss = 0 ; ss < SUBSUBFRAMES ; ss ++ ) \n for ( ch = 0 ; ch < c -> fullband_channels ; ch ++ ) \n for ( band = 0 ; band < DCAENC_SUBBANDS ; band ++ ) \n put_subframe_samples ( c , ss , band , ch ) ; \n put_bits ( & c -> pb , 16 , 0xffff ) ; \n }", "idx": 12357}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_gray_bitstream ( HYuvContext * s , int count ) \n { \n int i ; \n count /= 2 ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 31 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , 0 ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , 0 ) ; \n } \n } \n }", "idx": 12362}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void qdm2_init ( QDM2Context * q ) { \n static int inited = 0 ; \n if ( inited != 0 ) \n return ; \n inited = 1 ; \n qdm2_init_vlc ( ) ; \n ff_mpa_synth_init ( mpa_window ) ; \n softclip_table_init ( ) ; \n rnd_table_init ( ) ; \n init_noise_samples ( ) ; \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" ) ; \n }", "idx": 12412}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int encode_frame ( FlacEncodeContext * s ) \n { \n int ch , count ; \n count = count_frame_header ( s ) ; \n for ( ch = 0 ; ch < s -> channels ; ch ++ ) \n count += encode_residual_ch ( s , ch ) ; \n count += ( 8 - ( count & 7 ) ) & 7 ; \n count += 16 ; \n return count >> 3 ; \n }", "idx": 12429}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int decode_block_coeffs ( VP56RangeCoder * c , int16_t block [ 16 ] , \n uint8_t probs [ 16 ] [ 3 ] [ NUM_DCT_TOKENS - 1 ] , \n int i , int zero_nhood , int16_t qmul [ 2 ] ) \n { \n uint8_t * token_prob = probs [ i ] [ zero_nhood ] ; \n if ( ! vp56_rac_get_prob_branchy ( c , token_prob [ 0 ] ) ) \n return 0 ; \n return decode_block_coeffs_internal ( c , block , probs , i , token_prob , qmul ) ; \n }", "idx": 12585}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2packedXinC ( SwsContext * c , int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , \n int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , \n uint8_t * dest , int dstW , int y ) \n { \n int i ; \n switch ( c -> dstFormat ) \n { \n case PIX_FMT_BGR32 : \n case PIX_FMT_RGB32 : \n YSCALE_YUV_2_RGBX_C ( uint32_t ) \n ( ( uint32_t * ) dest ) [ i2 + 0 ] = r [ Y1 ] + g [ Y1 ] + b [ Y1 ] ; \n ( ( uint32_t * ) dest ) [ i2 + 1 ] = r [ Y2 ] + g [ Y2 ] + b [ Y2 ] ; \n } \n break ; \n case PIX_FMT_RGB24 : \n YSCALE_YUV_2_RGBX_C ( uint8_t ) \n ( ( uint8_t * ) dest ) [ 0 ] = r [ Y1 ] ; \n ( ( uint8_t * ) dest ) [ 1 ] = g [ Y1 ] ; \n ( ( uint8_t * ) dest ) [ 2 ] = b [ Y1 ] ; \n ( ( uint8_t * ) dest ) [ 3 ] = r [ Y2 ] ; \n ( ( uint8_t * ) dest ) [ 4 ] = g [ Y2 ] ; \n ( ( uint8_t * ) dest ) [ 5 ] = b [ Y2 ] ; \n dest += 6 ; \n }", "idx": 12809}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static void read_sgi_header ( ByteIOContext * f , SGIInfo * info ) \n { \n info -> magic = ( unsigned short ) get_be16 ( f ) ; \n info -> rle = get_byte ( f ) ; \n info -> bytes_per_channel = get_byte ( f ) ; \n info -> dimension = ( unsigned short ) get_be16 ( f ) ; \n info -> xsize = ( unsigned short ) get_be16 ( f ) ; \n info -> ysize = ( unsigned short ) get_be16 ( f ) ; \n info -> zsize = ( unsigned short ) get_be16 ( f ) ; \n #ifdef DEBUG \n printf ( \" \\n \" ) ; \n printf ( \" \\n \" , info -> magic ) ; \n printf ( \" \\n \" , info -> rle ) ; \n printf ( \" \\n \" , info -> bytes_per_channel ) ; \n printf ( \" \\n \" , info -> dimension ) ; \n printf ( \" \\n \" , info -> xsize ) ; \n printf ( \" \\n \" , info -> ysize ) ; \n printf ( \" \\n \" , info -> zsize ) ; \n #endif \n return ; \n }", "idx": 12814}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dct_init_x86 ( DCTContext * s ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n if ( EXTERNAL_SSE ( cpu_flags ) ) \n s -> dct32 = ff_dct32_float_sse ; \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) \n s -> dct32 = ff_dct32_float_sse2 ; \n if ( EXTERNAL_AVX ( cpu_flags ) ) \n s -> dct32 = ff_dct32_float_avx ; \n }", "idx": 12927}
{"project": "FFmpeg", "commit_id": "caa845851d790f894a2ccbe12580934f75545f92", "target": 0, "func": "static int output_data_internal ( MLPDecodeContext * m , unsigned int substr , \n uint8_t * data , unsigned int * data_size , int is32 ) \n { \n SubStream * s = & m -> substream [ substr ] ; \n unsigned int i , out_ch = 0 ; \n int32_t * data_32 = ( int32_t * ) data ; \n int16_t * data_16 = ( int16_t * ) data ; \n if ( * data_size < ( s -> max_channel + 1 ) * s -> blockpos * ( is32 ? 4 : 2 ) ) \n return -1 ; \n for ( i = 0 ; i < s -> blockpos ; i ++ ) { \n for ( out_ch = 0 ; out_ch <= s -> max_matrix_channel ; out_ch ++ ) { \n int mat_ch = s -> ch_assign [ out_ch ] ; \n int32_t sample = m -> sample_buffer [ i ] [ mat_ch ] \n << s -> output_shift [ mat_ch ] ; \n s -> lossless_check_data ^= ( sample & 0xffffff ) << mat_ch ; \n if ( is32 ) * data_32 ++ = sample << 8 ; \n else * data_16 ++ = sample >> 8 ; \n } \n } \n * data_size = i * out_ch * ( is32 ? 4 : 2 ) ; \n return 0 ; \n }", "idx": 13081}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "inline static void RENAME ( hcscale ) ( SwsContext * c , uint16_t * dst , int dstWidth , const uint8_t * src1 , const uint8_t * src2 , \n int srcW , int xInc , const int16_t * hChrFilter , \n const int16_t * hChrFilterPos , int hChrFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal ) \n { \n src1 += c -> chrSrcOffset ; \n src2 += c -> chrSrcOffset ; \n if ( c -> chrToYV12 ) { \n c -> chrToYV12 ( formatConvBuffer , formatConvBuffer + VOFW , src1 , src2 , srcW , pal ) ; \n src1 = formatConvBuffer ; \n src2 = formatConvBuffer + VOFW ; \n } \n if ( ! c -> hcscale_fast ) { \n c -> hScale ( dst , dstWidth , src1 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n c -> hScale ( dst + VOFW , dstWidth , src2 , srcW , xInc , hChrFilter , hChrFilterPos , hChrFilterSize ) ; \n } else { \n c -> hcscale_fast ( c , dst , dstWidth , src1 , src2 , srcW , xInc ) ; \n } \n if ( c -> chrConvertRange ) \n c -> chrConvertRange ( dst , dstWidth ) ; \n }", "idx": 13100}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME ( bgr24ToY ) ( uint8_t * dst , const uint8_t * src , int width , uint32_t * unused ) \n { \n #if COMPILE_TEMPLATE_MMX  \n  \n  RENAME ( bgr24ToY_mmx ) ( dst , src , width , PIX_FMT_BGR24 ) ; \n #else \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n int b = src [ i * 3 + 0 ] ; \n int g = src [ i * 3 + 1 ] ; \n int r = src [ i * 3 + 2 ] ; \n dst [ i ] = ( ( RY * r + GY * g + BY * b + ( 33 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ) ; \n } \n #endif \n }", "idx": 13205}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC ( ff_simple_idct ) ( DCTELEM * block ) \n { \n int i ; \n for ( i = 0 ; i < 8 ; i ++ ) \n FUNC ( idctRowCondDC ) ( block + i * 8 ) ; \n for ( i = 0 ; i < 8 ; i ++ ) \n FUNC ( idctSparseCol ) ( block + i ) ; \n }", "idx": 13230}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "static int read_packet ( AVFormatContext * s , uint8_t * buf , int raw_packet_size , uint8_t * * data ) \n { \n AVIOContext * pb = s -> pb ; \n int len ; \n for ( ; ; ) { \n len = ffio_read_indirect ( pb , buf , TS_PACKET_SIZE , data ) ; \n if ( len != TS_PACKET_SIZE ) \n return len < 0 ? len : AVERROR_EOF ; \n if ( ( * data ) [ 0 ] != 0x47 ) { \n avio_seek ( pb , - TS_PACKET_SIZE , SEEK_CUR ) ; \n if ( mpegts_resync ( s ) < 0 ) \n return AVERROR ( EAGAIN ) ; \n else \n continue ; \n } else { \n break ; \n } \n } \n return 0 ; \n }", "idx": 13316}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "int ff_parse_sample_rate ( unsigned * ret , const char * arg , void * log_ctx ) \n { \n char * tail ; \n double srate = av_strtod ( arg , & tail ) ; \n if ( * tail || srate < 1 || ( int ) srate != srate ) { \n av_log ( log_ctx , AV_LOG_ERROR , \" \\n \" , arg ) ; \n return AVERROR ( EINVAL ) ; \n } \n * ret = srate ; \n return 0 ; \n }", "idx": 13339}
{"project": "FFmpeg", "commit_id": "fe7547d69e6721d064c8604d0a6375a2d24b35ca", "target": 0, "func": "int ff_index_search_timestamp ( const AVIndexEntry * entries , int nb_entries , \n int64_t wanted_timestamp , int flags ) \n { \n int a , b , m ; \n int64_t timestamp ; \n a = -1 ; \n b = nb_entries ; \n if ( b && entries [ b - 1 ] . timestamp < wanted_timestamp ) \n a = b - 1 ; \n while ( b - a > 1 ) { \n m = ( a + b ) >> 1 ; \n while ( ( entries [ m ] . flags & AVINDEX_DISCARD_FRAME ) && m < b ) { \n m ++ ; \n if ( m == b && entries [ m ] . timestamp >= wanted_timestamp ) { \n m = b - 1 ; \n break ; \n } \n } \n timestamp = entries [ m ] . timestamp ; \n if ( timestamp >= wanted_timestamp ) \n b = m ; \n if ( timestamp <= wanted_timestamp ) \n a = m ; \n } \n m = ( flags & AVSEEK_FLAG_BACKWARD ) ? a : b ; \n if ( ! ( flags & AVSEEK_FLAG_ANY ) ) \n while ( m >= 0 && m < nb_entries && \n ! ( entries [ m ] . flags & AVINDEX_KEYFRAME ) ) \n m += ( flags & AVSEEK_FLAG_BACKWARD ) ? -1 : 1 ; \n if ( m == nb_entries ) \n return -1 ; \n return m ; \n }", "idx": 13462}
{"project": "FFmpeg", "commit_id": "668494acd8b20f974c7722895d4a6a14c1005f1e", "target": 1, "func": "static int codec_get_buffer ( AVCodecContext * s , AVFrame * frame ) \n { \n InputStream * ist = s -> opaque ; \n FrameBuffer * buf ; \n int ret , i ; \n if ( ! ist -> buffer_pool && ( ret = alloc_buffer ( s , ist , & ist -> buffer_pool ) ) < 0 ) \n return ret ; \n buf = ist -> buffer_pool ; \n ist -> buffer_pool = buf -> next ; \n buf -> next = NULL ; \n if ( buf -> w != s -> width || buf -> h != s -> height || buf -> pix_fmt != s -> pix_fmt ) { \n av_freep ( & buf -> base [ 0 ] ) ; \n av_free ( buf ) ; \n ist -> dr1 = 0 ; \n if ( ( ret = alloc_buffer ( s , ist , & buf ) ) < 0 ) \n return ret ; \n } \n buf -> refcount ++ ; \n frame -> opaque = buf ; \n frame -> type = FF_BUFFER_TYPE_USER ; \n frame -> extended_data = frame -> data ; \n frame -> pkt_pts = s -> pkt ? s -> pkt -> pts : AV_NOPTS_VALUE ; \n for ( i = 0 ; i < FF_ARRAY_ELEMS ( buf -> data ) ; i ++ ) { \n frame -> base [ i ] = buf -> base [ i ] ; \n frame -> data [ i ] = buf -> data [ i ] ; \n frame -> linesize [ i ] = buf -> linesize [ i ] ; \n } \n return 0 ; \n }", "idx": 13468}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static void compute_antialias_float ( MPADecodeContext * s , \n GranuleDef * g ) \n { \n float * ptr ; \n int n , i ; \n if ( g -> block_type == 2 ) { \n if ( ! g -> switch_point ) \n return ; \n n = 1 ; \n } else { \n n = SBLIMIT - 1 ; \n } \n ptr = g -> sb_hybrid + 18 ; \n for ( i = n ; i > 0 ; i -- ) { \n float tmp0 , tmp1 ; \n float * csa = & csa_table_float [ 0 ] [ 0 ] ; \n #define FLOAT_AA ( j ) \\ \n  \n  tmp0 = ptr [ -1 - j ] ; \n tmp1 = ptr [ j ] ; \n ptr [ -1 - j ] = tmp0 * csa [ 0 + 4 * j ] - tmp1 * csa [ 1 + 4 * j ] ; \n ptr [ j ] = tmp0 * csa [ 1 + 4 * j ] + tmp1 * csa [ 0 + 4 * j ] ; \n FLOAT_AA ( 0 )  \n FLOAT_AA ( 1 )  \n FLOAT_AA ( 2 )  \n FLOAT_AA ( 3 )  \n FLOAT_AA ( 4 )  \n FLOAT_AA ( 5 )  \n FLOAT_AA ( 6 )  \n FLOAT_AA ( 7 )  \n ptr += 18 ; \n } \n }", "idx": 13524}
{"project": "FFmpeg", "commit_id": "73789b85a759f3874112618120194e1712d7adcd", "target": 0, "func": "int ff_dca_core_parse ( DCACoreDecoder * s , uint8_t * data , int size ) \n { \n int ret ; \n s -> ext_audio_mask = 0 ; \n s -> xch_pos = s -> xxch_pos = s -> x96_pos = 0 ; \n if ( ( ret = init_get_bits8 ( & s -> gb , data , size ) ) < 0 ) \n return ret ; \n s -> gb_in = s -> gb ; \n if ( ( ret = parse_frame_header ( s ) ) < 0 ) \n return ret ; \n if ( ( ret = alloc_sample_buffer ( s ) ) < 0 ) \n return ret ; \n if ( ( ret = parse_frame_data ( s , HEADER_CORE , 0 ) ) < 0 ) \n return ret ; \n if ( ( ret = parse_optional_info ( s ) ) < 0 ) \n return ret ; \n if ( s -> frame_size > size && s -> frame_size < size + 4 ) \n s -> frame_size = size ; \n if ( ff_dca_seek_bits ( & s -> gb , s -> frame_size * 8 ) ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) \n return AVERROR_INVALIDDATA ; \n } \n return 0 ; \n }", "idx": 13555}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static int decode_init_mp3on4 ( AVCodecContext * avctx ) \n { \n MP3On4DecodeContext * s = avctx -> priv_data ; \n int i ; \n if ( ( avctx -> extradata_size < 2 ) || ( avctx -> extradata == NULL ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> chan_cfg = ( ( ( unsigned char * ) avctx -> extradata ) [ 1 ] >> 3 ) & 0x0f ; \n s -> frames = mp3Frames [ s -> chan_cfg ] ; \n if ( ! s -> frames ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> channels = mp3Channels [ s -> chan_cfg ] ; \n s -> mp3decctx [ 0 ] = av_mallocz ( sizeof ( MPADecodeContext ) ) ; \n avctx -> priv_data = s -> mp3decctx [ 0 ] ; \n decode_init ( avctx ) ; \n avctx -> priv_data = s ; \n s -> mp3decctx [ 0 ] -> adu_mode = 1 ; \n for ( i = 1 ; i < s -> frames ; i ++ ) { \n s -> mp3decctx [ i ] = av_mallocz ( sizeof ( MPADecodeContext ) ) ; \n s -> mp3decctx [ i ] -> compute_antialias = s -> mp3decctx [ 0 ] -> compute_antialias ; \n s -> mp3decctx [ i ] -> adu_mode = 1 ; \n s -> mp3decctx [ i ] -> avctx = avctx ; \n } \n return 0 ; \n }", "idx": 13571}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "static void init_dequant8_coeff_table ( H264Context * h ) { \n int i , q , x ; \n const int transpose = ( h -> h264dsp . h264_idct8_add != ff_h264_idct8_add_c ) ; \n h -> dequant8_coeff [ 0 ] = h -> dequant8_buffer [ 0 ] ; \n h -> dequant8_coeff [ 1 ] = h -> dequant8_buffer [ 1 ] ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( i && ! memcmp ( h -> pps . scaling_matrix8 [ 0 ] , h -> pps . scaling_matrix8 [ 1 ] , 64 * sizeof ( uint8_t ) ) ) { \n h -> dequant8_coeff [ 1 ] = h -> dequant8_buffer [ 0 ] ; \n break ; \n } \n for ( q = 0 ; q < 52 ; q ++ ) { \n int shift = div6 [ q ] ; \n int idx = rem6 [ q ] ; \n for ( x = 0 ; x < 64 ; x ++ ) \n h -> dequant8_coeff [ i ] [ q ] [ transpose ? ( x >> 3 ) | ( ( x & 7 ) << 3 ) : x ] = \n ( ( uint32_t ) dequant8_coeff_init [ idx ] [ dequant8_coeff_init_scan [ ( ( x >> 1 ) & 12 ) | ( x & 3 ) ] ] * \n h -> pps . scaling_matrix8 [ i ] [ x ] ) << shift ; \n } \n } \n }", "idx": 13712}
{"project": "FFmpeg", "commit_id": "9b2c28e6edbb43e00e0b2d99b95567189cd46e91", "target": 0, "func": "void rgb15to16 ( const uint8_t * src , uint8_t * dst , uint32_t src_size ) \n { \n #ifdef HAVE_MMX \n register const char * s = src + src_size ; \n register char * d = dst + src_size ; \n register int offs = - src_size ; \n __asm __volatile ( PREFETCH \" % 0 \" :: \" m \" \" memory \" \n __asm __volatile ( \n \" \\n \\t \" \n \" \" \n :: \" \" ( mask15b ) , \" \" ( mask15rg ) : \" \" ) ; \n while ( offs < 0 ) \n { \n __asm __volatile ( \n PREFETCH \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n MOVNTQ \" \\n \\t \" \n MOVNTQ \" \" \n : \" = m \" ( * ( d + offs ) ) \n : \" m \" ( * ( s + offs ) ) \n : \" memory \" ) ; \n offs += 16 ; \n } \n __asm __volatile ( SFENCE :: : \" memory \" ) ; \n __asm __volatile ( EMMS :: : \" memory \" ) ; \n #else \n const uint16_t * s1 = ( uint16_t * ) src ; \n uint16_t * d1 = ( uint16_t * ) dst ; \n uint16_t * e = ( ( uint8_t * ) s1 ) + src_size ; \n while ( s1 < e ) { \n register int x = * ( s1 ++ ) ; \n * ( d1 ++ ) = ( x & 0x001F ) | ( ( x & 0x7FE0 ) << 1 ) ; \n } \n #endif \n }", "idx": 13855}
{"project": "FFmpeg", "commit_id": "4749e074987d45cb98935a683a7ee8e1ee376d86", "target": 1, "func": "static int rle_unpack ( const unsigned char * src , unsigned char * dest , \n int src_len , int dest_len ) \n { \n const unsigned char * ps ; \n unsigned char * pd ; \n int i , l ; \n unsigned char * dest_end = dest + dest_len ; \n ps = src ; \n pd = dest ; \n if ( src_len & 1 ) \n * pd ++ = * ps ++ ; \n src_len >>= 1 ; \n i = 0 ; \n do { \n l = * ps ++ ; \n if ( l & 0x80 ) { \n l = ( l & 0x7F ) * 2 ; \n if ( pd + l > dest_end ) \n return ps - src ; \n memcpy ( pd , ps , l ) ; \n ps += l ; \n pd += l ; \n } else { \n if ( pd + i > dest_end ) \n return ps - src ; \n for ( i = 0 ; i < l ; i ++ ) { \n * pd ++ = ps [ 0 ] ; \n * pd ++ = ps [ 1 ] ; \n } \n ps += 2 ; \n } \n i += l ; \n } while ( i < src_len ) ; \n return ps - src ; \n }", "idx": 13859}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_16x16_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , \n dst , stride ) ; \n }", "idx": 13867}
{"project": "FFmpeg", "commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "target": 1, "func": "static int vorbis_parse ( AVCodecParserContext * s1 , AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n VorbisParseContext * s = s1 -> priv_data ; \n int duration ; \n if ( ! s -> vp && avctx -> extradata && avctx -> extradata_size ) { \n s -> vp = av_vorbis_parse_init ( avctx -> extradata , avctx -> extradata_size ) ; \n if ( ! s -> vp ) \n goto end ; \n } \n if ( ( duration = av_vorbis_parse_frame ( s -> vp , buf , buf_size ) ) >= 0 ) \n s1 -> duration = duration ; \n end : \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n return buf_size ; \n }", "idx": 13888}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int avpriv_lock_avformat ( void ) \n { \n if ( lockmgr_cb ) { \n if ( ( * lockmgr_cb ) ( & avformat_mutex , AV_LOCK_OBTAIN ) ) \n return -1 ; \n } \n return 0 ; \n }", "idx": 13906}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int libschroedinger_encode_close ( AVCodecContext * avctx ) \n { \n SchroEncoderParams * p_schro_params = avctx -> priv_data ; \n schro_encoder_free ( p_schro_params -> encoder ) ; \n ff_schro_queue_free ( & p_schro_params -> enc_frame_queue , \n libschroedinger_free_frame ) ; \n if ( p_schro_params -> enc_buf_size ) \n av_freep ( & p_schro_params -> enc_buf ) ; \n av_freep ( & p_schro_params -> format ) ; \n return 0 ; \n }", "idx": 13915}
{"project": "FFmpeg", "commit_id": "121be310607879841d19a34d9f16d4fe9ba7f18c", "target": 0, "func": "static int cinepak_decode_frame ( AVCodecContext * avctx , \n void * data , int * got_frame , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int ret = 0 , buf_size = avpkt -> size ; \n CinepakContext * s = avctx -> priv_data ; \n s -> data = buf ; \n s -> size = buf_size ; \n if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 ) \n return ret ; \n if ( s -> palette_video ) { \n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; \n if ( pal ) { \n s -> frame -> palette_has_changed = 1 ; \n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; \n } \n } \n if ( ( ret = cinepak_decode ( s ) ) < 0 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n } \n if ( s -> palette_video ) \n memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ; \n if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 ) \n return ret ; \n * got_frame = 1 ; \n return buf_size ; \n }", "idx": 13943}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static void * ff_avio_child_next ( void * obj , void * prev ) \n { \n AVIOContext * s = obj ; \n AVIOInternal * internal = s -> opaque ; \n return prev ? NULL : internal -> h ; \n }", "idx": 13969}
{"project": "FFmpeg", "commit_id": "4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816", "target": 1, "func": "static int update_dimensions ( VP8Context * s , int width , int height ) \n { \n if ( width != s -> avctx -> width || \n height != s -> avctx -> height ) { \n if ( av_image_check_size ( width , height , 0 , s -> avctx ) ) \n return AVERROR_INVALIDDATA ; \n vp8_decode_flush_impl ( s -> avctx , 1 , 0 , 1 ) ; \n avcodec_set_dimensions ( s -> avctx , width , height ) ; \n } \n s -> mb_width = ( s -> avctx -> coded_width + 15 ) / 16 ; \n s -> mb_height = ( s -> avctx -> coded_height + 15 ) / 16 ; \n s -> macroblocks_base = av_mallocz ( ( s -> mb_width + s -> mb_height * 2 + 1 ) * sizeof ( * s -> macroblocks ) ) ; \n s -> filter_strength = av_mallocz ( s -> mb_width * sizeof ( * s -> filter_strength ) ) ; \n s -> intra4x4_pred_mode_top = av_mallocz ( s -> mb_width * 4 ) ; \n s -> top_nnz = av_mallocz ( s -> mb_width * sizeof ( * s -> top_nnz ) ) ; \n s -> top_border = av_mallocz ( ( s -> mb_width + 1 ) * sizeof ( * s -> top_border ) ) ; \n if ( ! s -> macroblocks_base || ! s -> filter_strength || ! s -> intra4x4_pred_mode_top || \n ! s -> top_nnz || ! s -> top_border ) \n return AVERROR ( ENOMEM ) ; \n s -> macroblocks = s -> macroblocks_base + 1 ; \n return 0 ; \n }", "idx": 14014}
{"project": "FFmpeg", "commit_id": "f264d336fe61c12ce9607c3060aa5d3dca947c61", "target": 1, "func": "static void truespeech_apply_twopoint_filter ( TSContext * dec , int quart ) \n { \n int16_t tmp [ 146 + 60 ] , * ptr0 , * ptr1 ; \n const int16_t * filter ; \n int i , t , off ; \n t = dec -> offset2 [ quart ] ; \n if ( t == 127 ) { \n memset ( dec -> newvec , 0 , 60 * sizeof ( * dec -> newvec ) ) ; \n return ; \n } \n for ( i = 0 ; i < 146 ; i ++ ) \n tmp [ i ] = dec -> filtbuf [ i ] ; \n off = ( t / 25 ) + dec -> offset1 [ quart >> 1 ] + 18 ; \n ptr0 = tmp + 145 - off ; \n ptr1 = tmp + 146 ; \n filter = ( const int16_t * ) ts_order2_coeffs + ( t % 25 ) * 2 ; \n for ( i = 0 ; i < 60 ; i ++ ) { \n t = ( ptr0 [ 0 ] * filter [ 0 ] + ptr0 [ 1 ] * filter [ 1 ] + 0x2000 ) >> 14 ; \n ptr0 ++ ; \n dec -> newvec [ i ] = t ; \n ptr1 [ i ] = t ; \n } \n }", "idx": 14024}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "int dxva2_init ( AVCodecContext * s ) \n { \n InputStream * ist = s -> opaque ; \n int loglevel = ( ist -> hwaccel_id == HWACCEL_AUTO ) ? AV_LOG_VERBOSE : AV_LOG_ERROR ; \n DXVA2Context * ctx ; \n int ret ; \n if ( ! ist -> hwaccel_ctx ) { \n ret = dxva2_alloc ( s ) ; \n if ( ret < 0 ) \n return ret ; \n } \n ctx = ist -> hwaccel_ctx ; \n if ( s -> codec_id == AV_CODEC_ID_H264 && \n ( s -> profile & ~ FF_PROFILE_H264_CONSTRAINED ) > FF_PROFILE_H264_HIGH ) { \n av_log ( NULL , loglevel , \" \\n \" , s -> profile ) ; \n return AVERROR ( EINVAL ) ; \n } \n if ( s -> codec_id == AV_CODEC_ID_HEVC && \n s -> profile != FF_PROFILE_HEVC_MAIN && s -> profile != FF_PROFILE_HEVC_MAIN_10 ) { \n av_log ( NULL , loglevel , \" \\n \" , s -> profile ) ; \n return AVERROR ( EINVAL ) ; \n } \n av_buffer_unref ( & ctx -> hw_frames_ctx ) ; \n ret = dxva2_create_decoder ( s ) ; \n if ( ret < 0 ) { \n av_log ( NULL , loglevel , \" \\n \" ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 14108}
{"project": "FFmpeg", "commit_id": "8332321c5737cf24ebad504bf10a03818424718d", "target": 1, "func": "static int dv_read_seek ( AVFormatContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n RawDVContext * r = s -> priv_data ; \n DVDemuxContext * c = r -> dv_demux ; \n int64_t offset = dv_frame_offset ( s , c , timestamp , flags ) ; \n dv_offset_reset ( c , offset / c -> sys -> frame_size ) ; \n offset = avio_seek ( s -> pb , offset , SEEK_SET ) ; \n return ( offset < 0 ) ? offset : 0 ; \n }", "idx": 14144}
{"project": "FFmpeg", "commit_id": "ce551a3925a1cf9c7824e26a246b99b6773bda4b", "target": 1, "func": "static av_cold int seqvideo_decode_init ( AVCodecContext * avctx ) \n { \n SeqVideoContext * seq = avctx -> priv_data ; \n seq -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n seq -> frame = av_frame_alloc ( ) ; \n if ( ! seq -> frame ) \n return AVERROR ( ENOMEM ) ; \n return 0 ; \n }", "idx": 14309}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_picture_secondary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int status = 0 , index ; \n switch ( v -> s . pict_type ) \n { \n case P_TYPE : status = decode_p_picture_secondary_header ( v ) ; break ; \n case B_TYPE : status = decode_b_picture_secondary_header ( v ) ; break ; \n case BI_TYPE : \n case I_TYPE : break ; \n } \n if ( status < 0 ) return FRAME_SKIPED ; \n v -> ac_table_level = decode012 ( gb ) ; \n if ( v -> s . pict_type == I_TYPE || v -> s . pict_type == BI_TYPE ) \n { \n v -> ac2_table_level = decode012 ( gb ) ; \n } \n index = decode012 ( gb ) ; \n v -> luma_dc_vlc = & ff_msmp4_dc_luma_vlc [ index ] ; \n v -> chroma_dc_vlc = & ff_msmp4_dc_chroma_vlc [ index ] ; \n return 0 ; \n }", "idx": 14350}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int write_cvid_header ( CinepakEncContext * s , unsigned char * buf , int num_strips , int data_size ) \n { \n buf [ 0 ] = 0 ; \n AV_WB24 ( & buf [ 1 ] , data_size + CVID_HEADER_SIZE ) ; \n AV_WB16 ( & buf [ 4 ] , s -> w ) ; \n AV_WB16 ( & buf [ 6 ] , s -> h ) ; \n AV_WB16 ( & buf [ 8 ] , num_strips ) ; \n return CVID_HEADER_SIZE ; \n }", "idx": 14359}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init ( AVCodecParserContext * s ) \n { \n ParseContext1 * pc = s -> priv_data ; \n pc -> enc = av_mallocz ( sizeof ( MpegEncContext ) ) ; \n if ( ! pc -> enc ) \n return -1 ; \n pc -> first_picture = 1 ; \n return 0 ; \n }", "idx": 14362}
{"project": "FFmpeg", "commit_id": "a6d6b8a20072a5919d38258dd48cc612e2372f81", "target": 1, "func": "const AVOption * av_opt_next ( void * obj , const AVOption * last ) \n { \n AVClass * class = * ( AVClass * * ) obj ; \n if ( ! last && class -> option [ 0 ] . name ) return class -> option ; \n if ( last && last [ 1 ] . name ) return ++ last ; \n return NULL ; \n }", "idx": 14366}
{"project": "FFmpeg", "commit_id": "2d66fc543b01995d6146fc132a778d3e722ca665", "target": 1, "func": "static av_cold int init ( AVFilterContext * ctx , const char * args ) \n { \n GradFunContext * gf = ctx -> priv ; \n float thresh = 1.2 ; \n int radius = 16 ; \n if ( args ) \n sscanf ( args , \" \" , & thresh , & radius ) ; \n thresh = av_clipf ( thresh , 0.51 , 255 ) ; \n gf -> thresh = ( 1 << 15 ) / thresh ; \n gf -> radius = av_clip ( ( radius + 1 ) & ~ 1 , 4 , 32 ) ; \n gf -> blur_line = ff_gradfun_blur_line_c ; \n gf -> filter_line = ff_gradfun_filter_line_c ; \n if ( ARCH_X86 ) \n ff_gradfun_init_x86 ( gf ) ; \n av_log ( ctx , AV_LOG_VERBOSE , \" \\n \" , thresh , gf -> radius ) ; \n return 0 ; \n }", "idx": 14469}
{"project": "FFmpeg", "commit_id": "fc8fa007fb6099643a1f742a162e5e5eda760fd6", "target": 0, "func": "static int64_t rtmp_read_seek ( URLContext * s , int stream_index , \n int64_t timestamp , int flags ) \n { \n RTMP * r = s -> priv_data ; \n if ( flags & AVSEEK_FLAG_BYTE ) \n return AVERROR ( ENOSYS ) ; \n timestamp = av_rescale ( timestamp , AV_TIME_BASE , 1000 ) ; \n if ( ! RTMP_SendSeek ( r , timestamp ) ) \n return -1 ; \n return timestamp ; \n }", "idx": 14499}
{"project": "FFmpeg", "commit_id": "6df1cfa7e4d488051d7b5033c0c69df970db9f82", "target": 0, "func": "static av_cold int mace_decode_init ( AVCodecContext * avctx ) \n { \n MACEContext * ctx = avctx -> priv_data ; \n if ( avctx -> channels > 2 ) \n return -1 ; \n avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ; \n avcodec_get_frame_defaults ( & ctx -> frame ) ; \n avctx -> coded_frame = & ctx -> frame ; \n return 0 ; \n }", "idx": 14508}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g722_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n G722Context * c = avctx -> priv_data ; \n const int16_t * samples = ( const int16_t * ) frame -> data [ 0 ] ; \n int nb_samples , out_size , ret ; \n out_size = ( frame -> nb_samples + 1 ) / 2 ; \n if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , out_size ) ) ) \n return ret ; \n nb_samples = frame -> nb_samples - ( frame -> nb_samples & 1 ) ; \n if ( avctx -> trellis ) \n g722_encode_trellis ( c , avctx -> trellis , avpkt -> data , nb_samples , samples ) ; \n else \n g722_encode_no_trellis ( c , avpkt -> data , nb_samples , samples ) ; \n if ( nb_samples < frame -> nb_samples ) { \n int16_t last_samples [ 2 ] = { samples [ nb_samples ] , samples [ nb_samples ] } ; \n encode_byte ( c , & avpkt -> data [ nb_samples >> 1 ] , last_samples ) ; \n } \n if ( frame -> pts != AV_NOPTS_VALUE ) \n avpkt -> pts = frame -> pts - ff_samples_to_time_base ( avctx , avctx -> delay ) ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 14566}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_clear_fixed_vector ( float * out , const AMRFixed * in , int size ) \n { \n int i ; \n for ( i = 0 ; i < in -> n ; i ++ ) { \n int x = in -> x [ i ] , repeats = ! ( ( in -> no_repeat_mask >> i ) & 1 ) ; \n do { \n out [ x ] = 0.0 ; \n x += in -> pitch_lag ; \n } while ( x < size && repeats ) ; \n } \n }", "idx": 14599}
{"project": "FFmpeg", "commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "target": 1, "func": "static int vlc_decode_block ( MimicContext * ctx , int num_coeffs , int qscale ) \n { \n int16_t * block = ctx -> dct_block ; \n unsigned int pos ; \n ctx -> bdsp . clear_block ( block ) ; \n block [ 0 ] = get_bits ( & ctx -> gb , 8 ) << 3 ; \n for ( pos = 1 ; pos < num_coeffs ; pos ++ ) { \n uint32_t vlc , num_bits ; \n int value ; \n int coeff ; \n vlc = get_vlc2 ( & ctx -> gb , ctx -> vlc . table , ctx -> vlc . bits , 3 ) ; \n if ( ! vlc ) \n return 0 ; \n if ( vlc == -1 ) \n return AVERROR_INVALIDDATA ; \n pos += vlc & 15 ; \n num_bits = vlc >> 4 ; \n if ( pos >= 64 ) \n return AVERROR_INVALIDDATA ; \n value = get_bits ( & ctx -> gb , num_bits ) ; \n coeff = vlcdec_lookup [ num_bits ] [ value ] ; \n if ( pos < 3 ) \n coeff *= 16 ; \n else \n coeff = ( coeff * qscale ) / 1001 ; \n block [ ctx -> scantable . permutated [ pos ] ] = coeff ; \n } \n return 0 ; \n }", "idx": 14639}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int rl2_decode_init ( AVCodecContext * avctx ) \n { \n Rl2Context * s = avctx -> priv_data ; \n int back_size ; \n int i ; \n s -> avctx = avctx ; \n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; \n avcodec_get_frame_defaults ( & s -> frame ) ; \n if ( ! avctx -> extradata || avctx -> extradata_size < EXTRADATA1_SIZE ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n s -> video_base = AV_RL16 ( & avctx -> extradata [ 0 ] ) ; \n s -> clr_count = AV_RL32 ( & avctx -> extradata [ 2 ] ) ; \n if ( s -> video_base >= avctx -> width * avctx -> height ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n for ( i = 0 ; i < AVPALETTE_COUNT ; i ++ ) \n s -> palette [ i ] = 0xFF << 24 | AV_RB24 ( & avctx -> extradata [ 6 + i * 3 ] ) ; \n back_size = avctx -> extradata_size - EXTRADATA1_SIZE ; \n if ( back_size > 0 ) { \n unsigned char * back_frame = av_mallocz ( avctx -> width * avctx -> height ) ; \n if ( ! back_frame ) \n return -1 ; \n rl2_rle_decode ( s , avctx -> extradata + EXTRADATA1_SIZE , back_size , \n back_frame , avctx -> width , 0 ) ; \n s -> back_frame = back_frame ; \n } \n return 0 ; \n }", "idx": 14658}
{"project": "FFmpeg", "commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "target": 1, "func": "static void picmemset ( PicContext * s , AVFrame * frame , int value , int run , \n int * x , int * y , int * plane , int bits_per_plane ) \n { \n uint8_t * d ; \n int shift = * plane * bits_per_plane ; \n int mask = ( ( 1 << bits_per_plane ) - 1 ) << shift ; \n value <<= shift ; \n while ( run > 0 ) { \n int j ; \n for ( j = 8 - bits_per_plane ; j >= 0 ; j -= bits_per_plane ) { \n d = frame -> data [ 0 ] + * y * frame -> linesize [ 0 ] ; \n d [ * x ] |= ( value >> j ) & mask ; \n * x += 1 ; \n if ( * x == s -> width ) { \n * y -= 1 ; \n * x = 0 ; \n if ( * y < 0 ) { \n * y = s -> height - 1 ; \n * plane += 1 ; \n if ( * plane >= s -> nb_planes ) \n return ; \n value <<= bits_per_plane ; \n mask <<= bits_per_plane ; \n } \n } \n } \n run -- ; \n } \n }", "idx": 14665}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static void build_vlc ( VLC * vlc , const uint8_t * bits_table , const uint8_t * val_table , \n int nb_codes ) \n { \n uint8_t huff_size [ 256 ] ; \n uint16_t huff_code [ 256 ] ; \n memset ( huff_size , 0 , sizeof ( huff_size ) ) ; \n build_huffman_codes ( huff_size , huff_code , bits_table , val_table ) ; \n init_vlc ( vlc , 9 , nb_codes , huff_size , 1 , 1 , huff_code , 2 , 2 ) ; \n }", "idx": 14884}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_vp56dsp_init_x86 ( VP56DSPContext * c , enum AVCodecID codec ) \n { \n #if HAVE_YASM  \n  \n  int mm_flags = av_get_cpu_flags ( ) ; \n if ( CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6 ) { \n #if ARCH_X86_32  \n  \n  if ( mm_flags & AV_CPU_FLAG_MMX ) { \n c -> vp6_filter_diag4 = ff_vp6_filter_diag4_mmx ; \n } \n #endif \n if ( mm_flags & AV_CPU_FLAG_SSE2 ) { \n c -> vp6_filter_diag4 = ff_vp6_filter_diag4_sse2 ; \n } \n } \n #endif \n }", "idx": 14913}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose53i ( DWTELEM * buffer , int width , int height , int stride ) { \n int y ; \n DWTELEM * b0 = buffer + mirror ( -2 - 1 , height - 1 ) * stride ; \n DWTELEM * b1 = buffer + mirror ( -2 , height - 1 ) * stride ; \n for ( y = -2 ; y < height ; y += 2 ) { \n DWTELEM * b2 = buffer + mirror ( y + 1 , height - 1 ) * stride ; \n DWTELEM * b3 = buffer + mirror ( y + 2 , height - 1 ) * stride ; \n { START_TIMER \n if ( b1 <= b3 )  horizontal_decompose53i ( b2 , width ) ; \n if ( y + 2 < height ) horizontal_decompose53i ( b3 , width ) ; \n STOP_TIMER ( \" \" )  } \n { START_TIMER \n if ( b1 <= b3 )  vertical_decompose53iH0 ( b1 , b2 , b3 , width ) ; \n if ( b0 <= b2 ) vertical_decompose53iL0 ( b0 , b1 , b2 , width ) ; \n STOP_TIMER ( \" \" )  } \n b0 = b2 ; \n b1 = b3 ; \n } \n }", "idx": 14942}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgeh ( uint8_t * pix , int stride , int16_t bS [ 4 ] , unsigned int qp , H264Context * h ) { \n const unsigned int index_a = 52 + qp + h -> slice_alpha_c0_offset ; \n const int alpha = alpha_table [ index_a ] ; \n const int beta = ( beta_table + 52 ) [ qp + h -> slice_beta_offset ] ; \n if ( alpha == 0 || beta == 0 ) return ; \n if ( bS [ 0 ] < 4 ) { \n int8_t tc [ 4 ] ; \n tc [ 0 ] = tc0_table [ index_a ] [ bS [ 0 ] ] ; \n tc [ 1 ] = tc0_table [ index_a ] [ bS [ 1 ] ] ; \n tc [ 2 ] = tc0_table [ index_a ] [ bS [ 2 ] ] ; \n tc [ 3 ] = tc0_table [ index_a ] [ bS [ 3 ] ] ; \n h -> s . dsp . h264_v_loop_filter_luma ( pix , stride , alpha , beta , tc ) ; \n } else { \n h -> s . dsp . h264_v_loop_filter_luma_intra ( pix , stride , alpha , beta ) ; \n } \n }", "idx": 15051}
{"project": "FFmpeg", "commit_id": "7a4f74eed51f914e9bbfebaffd4a92ac6791f819", "target": 0, "func": "av_cold void ff_h264_free_context ( H264Context * h ) \n { \n int i ; \n ff_h264_free_tables ( h ) ; \n if ( h -> DPB ) { \n for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) \n ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ; \n av_freep ( & h -> DPB ) ; \n } \n h -> cur_pic_ptr = NULL ; \n for ( i = 0 ; i < h -> nb_slice_ctx ; i ++ ) \n av_freep ( & h -> slice_ctx [ i ] . rbsp_buffer ) ; \n av_freep ( & h -> slice_ctx ) ; \n h -> nb_slice_ctx = 0 ; \n for ( i = 0 ; i < MAX_SPS_COUNT ; i ++ ) \n av_freep ( h -> sps_buffers + i ) ; \n for ( i = 0 ; i < MAX_PPS_COUNT ; i ++ ) \n av_freep ( h -> pps_buffers + i ) ; \n }", "idx": 15108}
{"project": "FFmpeg", "commit_id": "252c0bfdc014c1fb6ad4fe06242c7beca58a6b41", "target": 1, "func": "int avcodec_default_reget_buffer ( AVCodecContext * s , AVFrame * pic ) \n { \n av_assert0 ( 0 ) ; \n }", "idx": 15124}
{"project": "FFmpeg", "commit_id": "3a54c221d574ec944db1eddf9df895808f32bf9e", "target": 1, "func": "static const char * read_ts ( const char * buf , int * ts_start , int * ts_end , \n int * x1 , int * y1 , int * x2 , int * y2 ) \n { \n int i , hs , ms , ss , he , me , se ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n int c = sscanf ( buf , \" \" \n \" \" , \n & hs , & ms , & ss , ts_start , & he , & me , & se , ts_end , \n x1 , x2 , y1 , y2 ) ; \n buf += strcspn ( buf , \" \\n \" ) + 1 ; \n if ( c >= 8 ) { \n * ts_start = 100 * ( ss + 60 * ( ms + 60 * hs ) ) + * ts_start / 10 ; \n * ts_end = 100 * ( se + 60 * ( me + 60 * he ) ) + * ts_end / 10 ; \n return buf ; \n } \n } \n return NULL ; \n }", "idx": 15133}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static int eval_lpc_coeffs ( const float * in , float * tgt , int n ) \n { \n int x , y ; \n double f0 , f1 , f2 ; \n if ( in [ n ] == 0 ) \n return 0 ; \n if ( ( f0 = * in ) <= 0 ) \n return 0 ; \n in -- ; \n for ( x = 1 ; x <= n ; x ++ ) { \n f1 = in [ x + 1 ] ; \n for ( y = 0 ; y < x - 1 ; y ++ ) \n f1 += in [ x - y ] * tgt [ y ] ; \n tgt [ x - 1 ] = f2 = - f1 / f0 ; \n for ( y = 0 ; y < x >> 1 ; y ++ ) { \n float temp = tgt [ y ] + tgt [ x - y - 2 ] * f2 ; \n tgt [ x - y - 2 ] += tgt [ y ] * f2 ; \n tgt [ y ] = temp ; \n } \n if ( ( f0 += f1 * f2 ) < 0 ) \n return 0 ; \n } \n return 1 ; \n }", "idx": 15249}
{"project": "FFmpeg", "commit_id": "00b3ca3c7a779e3b062d6ef0c5067c60c8f8a357", "target": 1, "func": "static int parse_inputs ( const char * * buf , AVFilterInOut * * curr_inputs , \n AVFilterInOut * * open_outputs , AVClass * log_ctx ) \n { \n int pad = 0 ; \n while ( * * buf == ' ' ) { \n char * name = parse_link_name ( buf , log_ctx ) ; \n AVFilterInOut * match ; \n if ( ! name ) \n return AVERROR ( EINVAL ) ; \n match = extract_inout ( name , open_outputs ) ; \n if ( match ) { \n av_free ( name ) ; \n } else { \n match = av_mallocz ( sizeof ( AVFilterInOut ) ) ; \n match -> name = name ; \n match -> pad_idx = pad ; \n } \n insert_inout ( curr_inputs , match ) ; \n * buf += strspn ( * buf , WHITESPACES ) ; \n pad ++ ; \n } \n return pad ; \n }", "idx": 15290}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuv444p ( AVPicture * dst , AVPicture * src , \n int width , int height ) \n { \n int src_wrap , x , y ; \n int r , g , b ; \n uint8_t * lum , * cb , * cr ; \n const uint8_t * p ; \n lum = dst -> data [ 0 ] ; \n cb = dst -> data [ 1 ] ; \n cr = dst -> data [ 2 ] ; \n src_wrap = src -> linesize [ 0 ] - width * BPP ; \n p = src -> data [ 0 ] ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) { \n RGB_IN ( r , g , b , p ) ; \n lum [ 0 ] = RGB_TO_Y_CCIR ( r , g , b ) ; \n cb [ 0 ] = RGB_TO_U_CCIR ( r , g , b , 0 ) ; \n cr [ 0 ] = RGB_TO_V_CCIR ( r , g , b , 0 ) ; \n cb ++ ; \n cr ++ ; \n lum ++ ; \n } \n p += src_wrap ; \n lum += dst -> linesize [ 0 ] - width ; \n cb += dst -> linesize [ 1 ] - width ; \n cr += dst -> linesize [ 2 ] - width ; \n } \n }", "idx": 15321}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_current_dir ( FTPContext * s ) \n { \n char * res = NULL , * start = NULL , * end = NULL ; \n int i ; \n const char * command = \" \\r \\n \" ; \n const int pwd_codes [ ] = { 257 , 0 } ; \n if ( ! ftp_send_command ( s , command , pwd_codes , & res ) ) \n goto fail ; \n for ( i = 0 ; res [ i ] ; ++ i ) { \n if ( res [ i ] == ' ' ) { \n if ( ! start ) { \n start = res + i + 1 ; \n continue ; \n } \n end = res + i ; \n break ; \n } \n } \n if ( ! end ) \n goto fail ; \n if ( end > res && end [ -1 ] == ' ' ) { \n end [ -1 ] = ' \\0 ' ; \n } else \n * end = ' \\0 ' ; \n av_strlcpy ( s -> path , start , sizeof ( s -> path ) ) ; \n av_free ( res ) ; \n return 0 ; \n fail : \n av_free ( res ) ; \n return AVERROR ( EIO ) ; \n }", "idx": 15401}
{"project": "FFmpeg", "commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "target": 1, "func": "void ff_hevc_luma_mv_merge_mode ( HEVCContext * s , int x0 , int y0 , int nPbW , \n int nPbH , int log2_cb_size , int part_idx , \n int merge_idx , MvField * mv ) \n { \n int singleMCLFlag = 0 ; \n int nCS = 1 << log2_cb_size ; \n LOCAL_ALIGNED ( 4 , MvField , mergecand_list ,  [ MRG_MAX_NUM_CANDS ] ) ; \n int nPbW2 = nPbW ; \n int nPbH2 = nPbH ; \n HEVCLocalContext * lc = & s -> HEVClc ; \n memset ( mergecand_list , 0 , MRG_MAX_NUM_CANDS * sizeof ( * mergecand_list ) ) ; \n if ( s -> pps -> log2_parallel_merge_level > 2 && nCS == 8 ) { \n singleMCLFlag = 1 ; \n x0 = lc -> cu . x ; \n y0 = lc -> cu . y ; \n nPbW = nCS ; \n nPbH = nCS ; \n part_idx = 0 ; \n } \n ff_hevc_set_neighbour_available ( s , x0 , y0 , nPbW , nPbH ) ; \n derive_spatial_merge_candidates ( s , x0 , y0 , nPbW , nPbH , log2_cb_size , \n singleMCLFlag , part_idx , \n merge_idx , mergecand_list ) ; \n if ( mergecand_list [ merge_idx ] . pred_flag [ 0 ] == 1 && \n mergecand_list [ merge_idx ] . pred_flag [ 1 ] == 1 && \n ( nPbW2 + nPbH2 ) == 12 ) { \n mergecand_list [ merge_idx ] . ref_idx [ 1 ] = -1 ; \n mergecand_list [ merge_idx ] . pred_flag [ 1 ] = 0 ; \n } \n * mv = mergecand_list [ merge_idx ] ; \n }", "idx": 15515}
{"project": "FFmpeg", "commit_id": "68900bf16bb4dda35cf5f2801ce72c15056f1939", "target": 0, "func": "static int cook_parse ( AVCodecParserContext * s1 , AVCodecContext * avctx , \n const uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * buf , int buf_size ) \n { \n CookParseContext * s = s1 -> priv_data ; \n if ( s -> duration ) \n s1 -> duration = s -> duration ; \n else if ( avctx -> extradata && avctx -> extradata_size >= 8 && avctx -> channels ) \n s -> duration = AV_RB16 ( avctx -> extradata + 4 ) / avctx -> channels ; \n * poutbuf = buf ; \n * poutbuf_size = buf_size ; \n return buf_size ; \n }", "idx": 15552}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "void compute_images_mse_16bit ( PSNRContext * s , \n const uint8_t * main_data [ 4 ] , const int main_linesizes [ 4 ] , \n const uint8_t * ref_data [ 4 ] , const int ref_linesizes [ 4 ] , \n int w , int h , double mse [ 4 ] ) \n { \n int i , c , j ; \n for ( c = 0 ; c < s -> nb_components ; c ++ ) { \n const int outw = s -> planewidth [ c ] ; \n const int outh = s -> planeheight [ c ] ; \n const uint16_t * main_line = ( uint16_t * ) main_data [ c ] ; \n const uint16_t * ref_line = ( uint16_t * ) ref_data [ c ] ; \n const int ref_linesize = ref_linesizes [ c ] / 2 ; \n const int main_linesize = main_linesizes [ c ] / 2 ; \n uint64_t m = 0 ; \n for ( i = 0 ; i < outh ; i ++ ) { \n for ( j = 0 ; j < outw ; j ++ ) \n m += pow2 ( main_line [ j ] - ref_line [ j ] ) ; \n ref_line += ref_linesize ; \n main_line += main_linesize ; \n } \n mse [ c ] = m / ( double ) ( outw * outh ) ; \n } \n }", "idx": 15589}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static void create_map ( vorbis_context * vc , unsigned floor_number ) \n { \n vorbis_floor * floors = vc -> floors ; \n vorbis_floor0 * vf ; \n int idx ; \n int blockflag , n ; \n int32_t * map ; \n for ( blockflag = 0 ; blockflag < 2 ; ++ blockflag ) { \n n = vc -> blocksize [ blockflag ] / 2 ; \n floors [ floor_number ] . data . t0 . map [ blockflag ] = \n av_malloc ( ( n + 1 ) * sizeof ( int32_t ) ) ; \n map = floors [ floor_number ] . data . t0 . map [ blockflag ] ; \n vf = & floors [ floor_number ] . data . t0 ; \n for ( idx = 0 ; idx < n ; ++ idx ) { \n map [ idx ] = floor ( BARK ( ( vf -> rate * idx ) / ( 2.0f * n ) ) * \n ( vf -> bark_map_size / BARK ( vf -> rate / 2.0f ) ) ) ; \n if ( vf -> bark_map_size - 1 < map [ idx ] ) \n map [ idx ] = vf -> bark_map_size - 1 ; \n } \n map [ n ] = -1 ; \n vf -> map_size [ blockflag ] = n ; \n } \n for ( idx = 0 ; idx <= n ; ++ idx ) { \n av_dlog ( NULL , \" \\n \" , idx , map [ idx ] ) ; \n } \n }", "idx": 15906}
{"project": "FFmpeg", "commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "target": 1, "func": "static av_cold int tdsc_init ( AVCodecContext * avctx ) \n { \n TDSCContext * ctx = avctx -> priv_data ; \n const AVCodec * codec ; \n int ret ; \n avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; \n if ( ! ( avctx -> width && avctx -> height ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n ctx -> deflatelen = avctx -> width * avctx -> height * ( 3 + 1 ) ; \n ret = av_reallocp ( & ctx -> deflatebuffer , ctx -> deflatelen ) ; \n if ( ret < 0 ) \n return ret ; \n ctx -> refframe = av_frame_alloc ( ) ; \n ctx -> jpgframe = av_frame_alloc ( ) ; \n if ( ! ctx -> refframe || ! ctx -> jpgframe ) \n return AVERROR ( ENOMEM ) ; \n codec = avcodec_find_decoder ( AV_CODEC_ID_MJPEG ) ; \n if ( ! codec ) \n return AVERROR_BUG ; \n ctx -> jpeg_avctx = avcodec_alloc_context3 ( codec ) ; \n if ( ! ctx -> jpeg_avctx ) \n return AVERROR ( ENOMEM ) ; \n ctx -> jpeg_avctx -> flags = avctx -> flags ; \n ctx -> jpeg_avctx -> flags2 = avctx -> flags2 ; \n ctx -> jpeg_avctx -> dct_algo = avctx -> dct_algo ; \n ctx -> jpeg_avctx -> idct_algo = avctx -> idct_algo ; ; \n ret = avcodec_open2 ( ctx -> jpeg_avctx , codec , NULL ) ; \n if ( ret < 0 ) \n return ret ; \n ctx -> refframe -> format = avctx -> pix_fmt ; \n return 0 ; \n }", "idx": 15987}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "static void opt_new_stream ( const char * opt , const char * arg ) \n { \n AVFormatContext * oc ; \n if ( nb_output_files <= 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ffmpeg_exit ( 1 ) ; \n } \n oc = output_files [ nb_output_files - 1 ] ; \n if ( ! strcmp ( opt , \" \" ) ) new_video_stream ( oc ) ; \n else if ( ! strcmp ( opt , \" \" ) ) new_audio_stream ( oc ) ; \n else if ( ! strcmp ( opt , \" \" ) ) new_subtitle_stream ( oc ) ; \n else assert ( 0 ) ; \n }", "idx": 16183}
{"project": "FFmpeg", "commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "target": 1, "func": "static int huf_uncompress ( GetByteContext * gb , \n uint16_t * dst , int dst_size ) \n { \n int32_t src_size , im , iM ; \n uint32_t nBits ; \n uint64_t * freq ; \n HufDec * hdec ; \n int ret , i ; \n src_size = bytestream2_get_le32 ( gb ) ; \n im = bytestream2_get_le32 ( gb ) ; \n iM = bytestream2_get_le32 ( gb ) ; \n bytestream2_skip ( gb , 4 ) ; \n nBits = bytestream2_get_le32 ( gb ) ; \n if ( im < 0 || im >= HUF_ENCSIZE || \n iM < 0 || iM >= HUF_ENCSIZE || \n src_size < 0 ) \n return AVERROR_INVALIDDATA ; \n bytestream2_skip ( gb , 4 ) ; \n freq = av_calloc ( HUF_ENCSIZE , sizeof ( * freq ) ) ; \n hdec = av_calloc ( HUF_DECSIZE , sizeof ( * hdec ) ) ; \n if ( ! freq || ! hdec ) { \n ret = AVERROR ( ENOMEM ) ; \n goto fail ; \n } \n if ( ( ret = huf_unpack_enc_table ( gb , im , iM , freq ) ) < 0 ) \n goto fail ; \n if ( nBits > 8 * bytestream2_get_bytes_left ( gb ) ) { \n ret = AVERROR_INVALIDDATA ; \n goto fail ; \n } \n if ( ( ret = huf_build_dec_table ( freq , im , iM , hdec ) ) < 0 ) \n goto fail ; \n ret = huf_decode ( freq , hdec , gb , nBits , iM , dst_size , dst ) ; \n fail : \n for ( i = 0 ; i < HUF_DECSIZE ; i ++ ) { \n if ( hdec [ i ] . p ) \n av_freep ( & hdec [ i ] . p ) ; \n } \n av_free ( freq ) ; \n av_free ( hdec ) ; \n return ret ; \n }", "idx": 16197}
{"project": "FFmpeg", "commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "target": 1, "func": "static int hevc_frame_start ( HEVCContext * s ) \n { \n HEVCLocalContext * lc = & s -> HEVClc ; \n int ret ; \n memset ( s -> horizontal_bs , 0 , 2 * s -> bs_width * ( s -> bs_height + 1 ) ) ; \n memset ( s -> vertical_bs , 0 , 2 * s -> bs_width * ( s -> bs_height + 1 ) ) ; \n memset ( s -> cbf_luma , 0 , s -> sps -> min_tb_width * s -> sps -> min_tb_height ) ; \n memset ( s -> is_pcm , 0 , s -> sps -> min_pu_width * s -> sps -> min_pu_height ) ; \n lc -> start_of_tiles_x = 0 ; \n s -> is_decoded = 0 ; \n if ( s -> pps -> tiles_enabled_flag ) \n lc -> end_of_tiles_x = s -> pps -> column_width [ 0 ] << s -> sps -> log2_ctb_size ; \n ret = ff_hevc_set_new_ref ( s , s -> sps -> sao_enabled ? & s -> sao_frame : & s -> frame , \n s -> poc ) ; \n if ( ret < 0 ) \n goto fail ; \n ret = ff_hevc_frame_rps ( s ) ; \n if ( ret < 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n goto fail ; \n } \n ret = set_side_data ( s ) ; \n if ( ret < 0 ) \n goto fail ; \n av_frame_unref ( s -> output_frame ) ; \n ret = ff_hevc_output_frame ( s , s -> output_frame , 0 ) ; \n if ( ret < 0 ) \n goto fail ; \n ff_thread_finish_setup ( s -> avctx ) ; \n return 0 ; \n fail : \n if ( s -> ref ) \n ff_thread_report_progress ( & s -> ref -> tf , INT_MAX , 0 ) ; \n s -> ref = NULL ; \n return ret ; \n }", "idx": 16203}
{"project": "FFmpeg", "commit_id": "63d6a6b91e4997737905bbd2cf5970ad90a31869", "target": 1, "func": "static void fix_coding_method_array ( int sb , int channels , sb_int8_array coding_method ) \n { \n int j , k ; \n int ch ; \n int run , case_val ; \n int switchtable [ 23 ] = { 0 , 5 , 1 , 5 , 5 , 5 , 5 , 5 , 2 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 3 , 5 , 5 , 5 , 5 , 5 , 4 } ; \n for ( ch = 0 ; ch < channels ; ch ++ ) { \n for ( j = 0 ; j < 64 ; ) { \n if ( ( coding_method [ ch ] [ sb ] [ j ] - 8 ) > 22 ) { \n run = 1 ; \n case_val = 8 ; \n } else { \n switch ( switchtable [ coding_method [ ch ] [ sb ] [ j ] ] ) { \n case 0 : run = 10 ; case_val = 10 ; break ; \n case 1 : run = 1 ; case_val = 16 ; break ; \n case 2 : run = 5 ; case_val = 24 ; break ; \n case 3 : run = 3 ; case_val = 30 ; break ; \n case 4 : run = 1 ; case_val = 30 ; break ; \n case 5 : run = 1 ; case_val = 8 ; break ; \n default : run = 1 ; case_val = 8 ; break ; \n } \n } \n for ( k = 0 ; k < run ; k ++ ) \n if ( j + k < 128 ) \n if ( coding_method [ ch ] [ sb + ( j + k ) / 64 ] [ ( j + k ) % 64 ] > coding_method [ ch ] [ sb ] [ j ] ) \n if ( k > 0 ) { \n SAMPLES_NEEDED \n memset ( & coding_method [ ch ] [ sb ] [ j + k ] , case_val , k * sizeof ( int8_t ) ) ; \n memset ( & coding_method [ ch ] [ sb ] [ j + k ] , case_val , 3 * sizeof ( int8_t ) ) ; \n } \n j += run ; \n } \n } \n }", "idx": 16205}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "void ff_mjpeg_encode_mb ( MpegEncContext * s , int16_t block [ 12 ] [ 64 ] ) \n { \n int i ; \n if ( s -> chroma_format == CHROMA_444 ) { \n encode_block ( s , block [ 0 ] , 0 ) ; \n encode_block ( s , block [ 2 ] , 2 ) ; \n encode_block ( s , block [ 4 ] , 4 ) ; \n encode_block ( s , block [ 8 ] , 8 ) ; \n encode_block ( s , block [ 5 ] , 5 ) ; \n encode_block ( s , block [ 9 ] , 9 ) ; \n if ( 16 * s -> mb_x + 8 < s -> width ) { \n encode_block ( s , block [ 1 ] , 1 ) ; \n encode_block ( s , block [ 3 ] , 3 ) ; \n encode_block ( s , block [ 6 ] , 6 ) ; \n encode_block ( s , block [ 10 ] , 10 ) ; \n encode_block ( s , block [ 7 ] , 7 ) ; \n encode_block ( s , block [ 11 ] , 11 ) ; \n } \n } else { \n for ( i = 0 ; i < 5 ; i ++ ) { \n encode_block ( s , block [ i ] , i ) ; \n } \n if ( s -> chroma_format == CHROMA_420 ) { \n encode_block ( s , block [ 5 ] , 5 ) ; \n } else { \n encode_block ( s , block [ 6 ] , 6 ) ; \n encode_block ( s , block [ 5 ] , 5 ) ; \n encode_block ( s , block [ 7 ] , 7 ) ; \n } \n } \n }", "idx": 16227}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc12_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_midh_qrt_and_aver_dst_16w_msa ( src - ( 2 * stride ) - 2 , \n stride , dst , stride , 16 , 0 ) ; \n }", "idx": 16255}
{"project": "FFmpeg", "commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "target": 1, "func": "static int ftp_abort ( URLContext * h ) \n { \n static const char * command = \" \\r \\n \" ; \n int err ; \n static const int abor_codes [ ] = { 225 , 226 , 0 } ; \n FTPContext * s = h -> priv_data ; \n if ( ftp_send_command ( s , command , NULL , NULL ) < 0 ) { \n ftp_close_both_connections ( s ) ; \n if ( ( err = ftp_connect_control_connection ( h ) ) < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n return err ; \n } \n } else { \n ftp_close_data_connection ( s ) ; \n } \n if ( ftp_status ( s , NULL , abor_codes ) < 225 ) { \n ffurl_closep ( & s -> conn_control ) ; \n if ( ( err = ftp_connect_control_connection ( h ) ) < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n return err ; \n } \n } \n return 0 ; \n }", "idx": 16370}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 16412}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_xvmc_field_end ( MpegEncContext * s ) \n { \n struct xvmc_pix_fmt * render = ( struct xvmc_pix_fmt * ) s -> current_picture . f . data [ 2 ] ; \n assert ( render ) ; \n if ( render -> filled_mv_blocks_num > 0 ) \n ff_mpeg_draw_horiz_band ( s , 0 , 0 ) ; \n }", "idx": 16437}
{"project": "FFmpeg", "commit_id": "5e2202d6f3ac2f3afd714a62437ca6b24f75c09f", "target": 1, "func": "static void mov_metadata_creation_time ( AVMetadata * * metadata , time_t time ) \n { \n char buffer [ 32 ] ; \n if ( time ) { \n time -= 2082844800 ; \n strftime ( buffer , sizeof ( buffer ) , \" \" , gmtime ( & time ) ) ; \n av_metadata_set2 ( metadata , \" \" , buffer , 0 ) ; \n } \n }", "idx": 16700}
{"project": "FFmpeg", "commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "target": 1, "func": "static int parse_palette ( AVCodecContext * avctx , GetByteContext * gbc , \n uint32_t * pal , int colors ) \n { \n int i ; \n for ( i = 0 ; i <= colors ; i ++ ) { \n uint8_t r , g , b ; \n unsigned int idx = bytestream2_get_be16 ( gbc ) ; \n if ( idx > 255 ) { \n av_log ( avctx , AV_LOG_WARNING , \n \" \\n \" , idx ) ; \n bytestream2_skip ( gbc , 6 ) ; \n continue ; \n } \n r = bytestream2_get_byte ( gbc ) ; \n bytestream2_skip ( gbc , 1 ) ; \n g = bytestream2_get_byte ( gbc ) ; \n bytestream2_skip ( gbc , 1 ) ; \n b = bytestream2_get_byte ( gbc ) ; \n bytestream2_skip ( gbc , 1 ) ; \n pal [ idx ] = ( r << 16 ) | ( g << 8 ) | b ; \n } \n return 0 ; \n }", "idx": 16755}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_int64 ( const void * a , const void * b ) \n { \n int64_t va = * ( int64_t * ) a , vb = * ( int64_t * ) b ; \n return va < vb ? -1 : va > vb ? +1 : 0 ; \n }", "idx": 16767}
{"project": "FFmpeg", "commit_id": "f6687bf5f8989d397cdef6d9d05bcb13a7ef8c4f", "target": 0, "func": "void av_xtea_crypt ( AVXTEA * ctx , uint8_t * dst , const uint8_t * src , int count , \n uint8_t * iv , int decrypt ) \n { \n int i ; \n while ( count > 0 ) { \n if ( decrypt ) { \n xtea_crypt_ecb ( ctx , dst , src , decrypt ) ; \n if ( iv ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = dst [ i ] ^ iv [ i ] ; \n memcpy ( iv , src , 8 ) ; \n } \n } else { \n if ( iv ) { \n for ( i = 0 ; i < 8 ; i ++ ) \n dst [ i ] = src [ i ] ^ iv [ i ] ; \n xtea_crypt_ecb ( ctx , dst , dst , decrypt ) ; \n memcpy ( iv , dst , 8 ) ; \n } else { \n xtea_crypt_ecb ( ctx , dst , src , decrypt ) ; \n } \n } \n src += 8 ; \n dst += 8 ; \n count -= 8 ; \n } \n }", "idx": 16795}
{"project": "FFmpeg", "commit_id": "6241e8a3821d971755217652dff01f3a45580820", "target": 0, "func": "static void read_chapter ( AVFormatContext * s , AVIOContext * pb , int len , char * ttag , ID3v2ExtraMeta * * extra_meta ) \n { \n AVRational time_base = { 1 , 1000 } ; \n uint32_t start , end ; \n AVChapter * chapter ; \n uint8_t * dst = NULL ; \n int taglen ; \n char tag [ 5 ] ; \n decode_str ( s , pb , 0 , & dst , & len ) ; \n if ( len < 16 ) \n return ; \n start = avio_rb32 ( pb ) ; \n end = avio_rb32 ( pb ) ; \n avio_skip ( pb , 8 ) ; \n chapter = avpriv_new_chapter ( s , s -> nb_chapters + 1 , time_base , start , end , dst ) ; \n if ( ! chapter ) { \n av_free ( dst ) ; \n return ; \n } \n len -= 16 ; \n while ( len > 10 ) { \n avio_read ( pb , tag , 4 ) ; \n tag [ 4 ] = 0 ; \n taglen = avio_rb32 ( pb ) ; \n avio_skip ( pb , 2 ) ; \n len -= 10 ; \n if ( taglen < 0 || taglen > len ) { \n av_free ( dst ) ; \n return ; \n } \n if ( tag [ 0 ] == ' ' ) \n read_ttag ( s , pb , taglen , & chapter -> metadata , tag ) ; \n else \n avio_skip ( pb , taglen ) ; \n len -= taglen ; \n } \n ff_metadata_conv ( & chapter -> metadata , NULL , ff_id3v2_34_metadata_conv ) ; \n ff_metadata_conv ( & chapter -> metadata , NULL , ff_id3v2_4_metadata_conv ) ; \n av_free ( dst ) ; \n }", "idx": 16808}
{"project": "FFmpeg", "commit_id": "b00fb157bae79f9735910064585fd95b8c123003", "target": 0, "func": "static int decode_sgirle8 ( AVCodecContext * avctx , uint8_t * dst , const uint8_t * src , int src_size , int width , int height , int linesize ) \n { \n const uint8_t * src_end = src + src_size ; \n int x = 0 , y = 0 ; \n #define INC_XY ( n )  \\ \n  \n  x += n ; \n if ( x >= width ) { \n y ++ ; \n if ( y >= height ) \n return 0 ; \n x = 0 ; \n } \n while ( src_end - src >= 2 ) { \n uint8_t v = * src ++ ; \n if ( v > 0 && v < 0xC0 ) { \n do { \n int length = FFMIN ( v , width - x ) ; \n memset ( dst + y * linesize + x , RGB332_TO_BGR8 ( * src ) , length ) ; \n INC_XY ( length ) ; \n v -= length ; \n } while ( v > 0 ) ; \n src ++ ; \n } else if ( v >= 0xC1 ) { \n v -= 0xC0 ; \n do { \n int length = FFMIN3 ( v , width - x , src_end - src ) ; \n if ( src_end - src < length ) \n break ; \n memcpy_rgb332_to_bgr8 ( dst + y * linesize + x , src , length ) ; \n INC_XY ( length ) ; \n src += length ; \n v -= length ; \n } while ( v > 0 ) ; \n } else { \n avpriv_request_sample ( avctx , \" \" , v ) ; \n return AVERROR_PATCHWELCOME ; \n } \n } \n return 0 ; \n }", "idx": 16984}
{"project": "FFmpeg", "commit_id": "1e901ffc619459944ae7102428f48972cd899caa", "target": 0, "func": "static int64_t wrap_timestamp ( AVStream * st , int64_t timestamp ) \n { \n if ( st -> pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st -> pts_wrap_bits < 64 && \n st -> pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE ) { \n if ( st -> pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET && \n timestamp < st -> pts_wrap_reference ) \n return timestamp + ( 1ULL << st -> pts_wrap_bits ) ; \n else if ( st -> pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET && \n timestamp >= st -> pts_wrap_reference ) \n return timestamp - ( 1ULL << st -> pts_wrap_bits ) ; \n } \n return timestamp ; \n }", "idx": 17009}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc33_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_4w_msa ( src + stride - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 4 ) ; \n }", "idx": 17118}
{"project": "FFmpeg", "commit_id": "e62ef8f2dbf1ac0a197310f2be69c93b89f838c2", "target": 0, "func": "static av_cold void set_bandwidth ( AC3EncodeContext * s , int cutoff ) \n { \n int ch , bw_code ; \n if ( cutoff ) { \n int fbw_coeffs ; \n cutoff = av_clip ( cutoff , 1 , s -> sample_rate >> 1 ) ; \n fbw_coeffs = cutoff * 2 * AC3_MAX_COEFS / s -> sample_rate ; \n bw_code = av_clip ( ( fbw_coeffs - 73 ) / 3 , 0 , 60 ) ; \n } else { \n bw_code = 50 ; \n } \n for ( ch = 0 ; ch < s -> fbw_channels ; ch ++ ) { \n s -> bandwidth_code [ ch ] = bw_code ; \n s -> nb_coefs [ ch ] = bw_code * 3 + 73 ; \n } \n if ( s -> lfe_on ) \n s -> nb_coefs [ s -> lfe_channel ] = 7 ; \n }", "idx": 17203}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int get_last_needed_nal ( H264Context * h , const uint8_t * buf , int buf_size ) \n { \n int next_avc = h -> is_avc ? 0 : buf_size ; \n int nal_index = 0 ; \n int buf_index = 0 ; \n int nals_needed = 0 ; \n while ( 1 ) { \n int nalsize = 0 ; \n int dst_length , bit_length , consumed ; \n const uint8_t * ptr ; \n if ( buf_index >= next_avc ) { \n nalsize = get_avc_nalsize ( h , buf , buf_size , & buf_index ) ; \n if ( nalsize < 0 ) \n break ; \n next_avc = buf_index + nalsize ; \n } else { \n buf_index = find_start_code ( buf , buf_size , buf_index , next_avc ) ; \n if ( buf_index >= buf_size ) \n break ; \n } \n ptr = ff_h264_decode_nal ( h , buf + buf_index , & dst_length , & consumed , \n next_avc - buf_index ) ; \n if ( ptr == NULL || dst_length < 0 ) \n return AVERROR_INVALIDDATA ; \n buf_index += consumed ; \n bit_length = get_bit_length ( h , buf , ptr , dst_length , \n buf_index , next_avc ) ; \n nal_index ++ ; \n switch ( h -> nal_unit_type ) { \n case NAL_SPS : \n case NAL_PPS : \n nals_needed = nal_index ; \n break ; \n case NAL_DPA : \n case NAL_IDR_SLICE : \n case NAL_SLICE : \n init_get_bits ( & h -> gb , ptr , bit_length ) ; \n if ( ! get_ue_golomb ( & h -> gb ) ) \n nals_needed = nal_index ; \n } \n } \n return nals_needed ; \n }", "idx": 17308}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_cdt24_entry ( int p1 , int p2 , int16_t * cdt ) \n { \n int r , b ; \n b = cdt [ p2 ] ; \n r = cdt [ p1 ] << 16 ; \n return ( b + r ) << 1 ; \n }", "idx": 17341}
{"project": "FFmpeg", "commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "target": 1, "func": "static void matroska_add_index_entries ( MatroskaDemuxContext * matroska ) \n { \n EbmlList * index_list ; \n MatroskaIndex * index ; \n int index_scale = 1 ; \n int i , j ; \n if ( matroska -> ctx -> flags & AVFMT_FLAG_IGNIDX ) \n return ; \n index_list = & matroska -> index ; \n index = index_list -> elem ; \n if ( index_list -> nb_elem && \n index [ 0 ] . time > 1E14 / matroska -> time_scale ) { \n av_log ( matroska -> ctx , AV_LOG_WARNING , \" \\n \" ) ; \n index_scale = matroska -> time_scale ; \n } \n for ( i = 0 ; i < index_list -> nb_elem ; i ++ ) { \n EbmlList * pos_list = & index [ i ] . pos ; \n MatroskaIndexPos * pos = pos_list -> elem ; \n for ( j = 0 ; j < pos_list -> nb_elem ; j ++ ) { \n MatroskaTrack * track = matroska_find_track_by_num ( matroska , \n pos [ j ] . track ) ; \n if ( track && track -> stream ) \n av_add_index_entry ( track -> stream , \n pos [ j ] . pos + matroska -> segment_start , \n index [ i ] . time / index_scale , 0 , 0 , \n AVINDEX_KEYFRAME ) ; \n } \n } \n }", "idx": 17353}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 512 ] + samples [ i + 768 ] + samples [ i + 1024 ] ) ; \n samples [ i + 256 ] = samples [ i + 512 ] = samples [ i + 768 ] = samples [ i + 1024 ] = 0 ; \n } \n }", "idx": 17357}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "void ff_vp56_init_range_decoder ( VP56RangeCoder * c , const uint8_t * buf , int buf_size ) \n { \n c -> high = 255 ; \n c -> bits = -16 ; \n c -> buffer = buf ; \n c -> end = buf + buf_size ; \n c -> code_word = bytestream_get_be24 ( & c -> buffer ) ; \n }", "idx": 17413}
{"project": "FFmpeg", "commit_id": "bc29acdc76fdbf70700cdc2f85fc2afb46e19e47", "target": 0, "func": "static int ftp_connect_control_connection ( URLContext * h ) \n { \n char buf [ CONTROL_BUFFER_SIZE ] , opts_format [ 20 ] ; \n int err ; \n AVDictionary * opts = NULL ; \n FTPContext * s = h -> priv_data ; \n const int connect_codes [ ] = { 220 , 0 } ; \n s -> conn_control_block_flag = 0 ; \n if ( ! s -> conn_control ) { \n ff_url_join ( buf , sizeof ( buf ) , \" \" , NULL , \n s -> hostname , s -> server_control_port , NULL ) ; \n if ( s -> rw_timeout != -1 ) { \n snprintf ( opts_format , sizeof ( opts_format ) , \" \" , s -> rw_timeout ) ; \n av_dict_set ( & opts , \" \" , opts_format , 0 ) ; \n } \n err = ffurl_open ( & s -> conn_control , buf , AVIO_FLAG_READ_WRITE , \n & s -> conn_control_interrupt_cb , & opts ) ; \n av_dict_free ( & opts ) ; \n if ( err < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n return err ; \n } \n if ( ! ftp_status ( s , NULL , connect_codes ) ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n err = AVERROR ( EACCES ) ; \n return err ; \n } \n if ( ( err = ftp_auth ( s ) ) < 0 ) { \n av_log ( h , AV_LOG_ERROR , \" \\n \" ) ; \n return err ; \n } \n if ( ( err = ftp_type ( s ) ) < 0 ) { \n av_dlog ( h , \" \\n \" ) ; \n return err ; \n } \n } \n return 0 ; \n }", "idx": 17439}
{"project": "FFmpeg", "commit_id": "4d321bff85cf1e9b6a18b915af185494b5ea94b6", "target": 1, "func": "void Release ( void * ctx ) \n { \n ContextInfo * ci ; \n ci = ( ContextInfo * ) ctx ; \n if ( ci -> cache ) { \n imlib_context_set_image ( ci -> cache -> image ) ; \n imlib_free_image ( ) ; \n av_free ( ci -> cache ) ; \n } \n if ( ctx ) { \n if ( ci -> imageOverlaid ) { \n imlib_context_set_image ( ci -> imageOverlaid ) ; \n imlib_free_image ( ) ; \n } \n ff_eval_free ( ci -> expr_x ) ; \n ff_eval_free ( ci -> expr_y ) ; \n ff_eval_free ( ci -> expr_R ) ; \n ff_eval_free ( ci -> expr_G ) ; \n ff_eval_free ( ci -> expr_B ) ; \n sws_freeContext ( ci -> toRGB_convert_ctx ) ; \n sws_freeContext ( ci -> fromRGB_convert_ctx ) ; \n av_free ( ctx ) ; \n } \n }", "idx": 17480}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips ( struct AACEncContext * s , \n PutBitContext * pb , const float * in , float * out , \n const float * scaled , int size , int scale_idx , \n int cb , const float lambda , const float uplim , \n int * bits , const float ROUNDING ) { \n int i ; \n if ( bits ) \n * bits = 0 ; \n if ( out ) { \n for ( i = 0 ; i < size ; i += 4 ) { \n out [ i ] = 0.0f ; \n out [ i + 1 ] = 0.0f ; \n out [ i + 2 ] = 0.0f ; \n out [ i + 3 ] = 0.0f ; \n } \n } \n }", "idx": 17513}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static void mmap_release_buffer ( AVPacket * pkt ) \n { \n struct v4l2_buffer buf ; \n int res , fd ; \n struct buff_data * buf_descriptor = pkt -> priv ; \n if ( pkt -> data == NULL ) \n return ; \n memset ( & buf , 0 , sizeof ( struct v4l2_buffer ) ) ; \n buf . type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; \n buf . memory = V4L2_MEMORY_MMAP ; \n buf . index = buf_descriptor -> index ; \n fd = buf_descriptor -> fd ; \n av_free ( buf_descriptor ) ; \n res = ioctl ( fd , VIDIOC_QBUF , & buf ) ; \n if ( res < 0 ) \n av_log ( NULL , AV_LOG_ERROR , \" \\n \" , \n strerror ( errno ) ) ; \n pkt -> data = NULL ; \n pkt -> size = 0 ; \n }", "idx": 17534}
{"project": "FFmpeg", "commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "target": 1, "func": "static void show_packets ( AVFormatContext * fmt_ctx ) \n { \n AVPacket pkt ; \n av_init_packet ( & pkt ) ; \n probe_array_header ( \" \" , 0 ) ; \n while ( ! av_read_frame ( fmt_ctx , & pkt ) ) \n show_packet ( fmt_ctx , & pkt ) ; \n probe_array_footer ( \" \" , 0 ) ; \n }", "idx": 17554}
{"project": "FFmpeg", "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7", "target": 0, "func": "static int get_riff ( AVFormatContext * s , AVIOContext * pb ) \n { \n AVIContext * avi = s -> priv_data ; \n char header [ 8 ] ; \n int i ; \n avio_read ( pb , header , 4 ) ; \n avi -> riff_end = avio_rl32 ( pb ) ; \n avi -> riff_end += avio_tell ( pb ) ; \n avio_read ( pb , header + 4 , 4 ) ; \n for ( i = 0 ; avi_headers [ i ] [ 0 ] ; i ++ ) \n if ( ! memcmp ( header , avi_headers [ i ] , 8 ) ) \n break ; \n if ( ! avi_headers [ i ] [ 0 ] ) \n return -1 ; \n if ( header [ 7 ] == 0x19 ) \n av_log ( s , AV_LOG_INFO , \" \\n \" ) ; \n return 0 ; \n }", "idx": 17597}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_free_extradata ( PayloadContext * rdt )  \n { \n int i ; \n for ( i = 0 ; i < MAX_STREAMS ; i ++ ) \n if ( rdt -> rmst [ i ] ) { \n ff_rm_free_rmstream ( rdt -> rmst [ i ] ) ; \n av_freep ( & rdt -> rmst [ i ] ) ; \n } \n if ( rdt -> rmctx ) \n av_close_input_stream ( rdt -> rmctx ) ; \n av_freep ( & rdt -> mlti_data ) ; \n av_free ( rdt ) ; \n }", "idx": 17678}
{"project": "FFmpeg", "commit_id": "3dfbdb328ed9e88cebc6462c56cfe61e55850b2e", "target": 0, "func": "static int read_quant_table ( RangeCoder * c , int16_t * quant_table , int scale ) \n { \n int v ; \n int i = 0 ; \n uint8_t state [ CONTEXT_SIZE ] ; \n memset ( state , 128 , sizeof ( state ) ) ; \n for ( v = 0 ; i < 128 ; v ++ ) { \n unsigned len = get_symbol ( c , state , 0 ) + 1 ; \n if ( len > 128 - i ) \n return AVERROR_INVALIDDATA ; \n while ( len -- ) { \n quant_table [ i ] = scale * v ; \n i ++ ; \n } \n } \n for ( i = 1 ; i < 128 ; i ++ ) \n quant_table [ 256 - i ] = - quant_table [ i ] ; \n quant_table [ 128 ] = - quant_table [ 127 ] ; \n return 2 * v - 1 ; \n }", "idx": 17723}
{"project": "FFmpeg", "commit_id": "1eb57e1d9b59db0aa63348c21bf3290bd3f5efcb", "target": 0, "func": "static int tb_unreliable ( AVCodecContext * c ) \n { \n if ( c -> time_base . den >= 101L * c -> time_base . num || \n c -> time_base . den < 5L * c -> time_base . num || \n c -> codec_id == AV_CODEC_ID_MPEG2VIDEO || \n c -> codec_id == AV_CODEC_ID_H264 ) \n return 1 ; \n return 0 ; \n }", "idx": 17735}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int svq1_decode_init ( AVCodecContext * avctx ) \n { \n MpegEncContext * s = avctx -> priv_data ; \n int i ; \n MPV_decode_defaults ( s ) ; \n s -> avctx = avctx ; \n s -> width = ( avctx -> width + 3 ) & ~ 3 ; \n s -> height = ( avctx -> height + 3 ) & ~ 3 ; \n s -> codec_id = avctx -> codec -> id ; \n avctx -> pix_fmt = PIX_FMT_YUV410P ; \n avctx -> has_b_frames = 1 ; \n s -> flags = avctx -> flags ; \n if ( MPV_common_init ( s ) < 0 ) return -1 ; \n init_vlc ( & svq1_block_type , 2 , 4 , \n & svq1_block_type_vlc [ 0 ] [ 1 ] , 2 , 1 , \n & svq1_block_type_vlc [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & svq1_motion_component , 7 , 33 , \n & mvtab [ 0 ] [ 1 ] , 2 , 1 , \n & mvtab [ 0 ] [ 0 ] , 2 , 1 ) ; \n for ( i = 0 ; i < 6 ; i ++ ) { \n init_vlc ( & svq1_intra_multistage [ i ] , 3 , 8 , \n & svq1_intra_multistage_vlc [ i ] [ 0 ] [ 1 ] , 2 , 1 , \n & svq1_intra_multistage_vlc [ i ] [ 0 ] [ 0 ] , 2 , 1 ) ; \n init_vlc ( & svq1_inter_multistage [ i ] , 3 , 8 , \n & svq1_inter_multistage_vlc [ i ] [ 0 ] [ 1 ] , 2 , 1 , \n & svq1_inter_multistage_vlc [ i ] [ 0 ] [ 0 ] , 2 , 1 ) ; \n } \n init_vlc ( & svq1_intra_mean , 8 , 256 , \n & svq1_intra_mean_vlc [ 0 ] [ 1 ] , 4 , 2 , \n & svq1_intra_mean_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; \n init_vlc ( & svq1_inter_mean , 9 , 512 , \n & svq1_inter_mean_vlc [ 0 ] [ 1 ] , 4 , 2 , \n & svq1_inter_mean_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; \n return 0 ; \n }", "idx": 17742}
{"project": "FFmpeg", "commit_id": "24130234cd9dd733116d17b724ea4c8e12ce097a", "target": 0, "func": "static int parse_fmtp ( AVFormatContext * s , \n AVStream * stream , PayloadContext * data , \n const char * attr , const char * value ) \n { \n AVCodecParameters * par = stream -> codecpar ; \n int res , i ; \n if ( ! strcmp ( attr , \" \" ) ) { \n res = parse_fmtp_config ( par , value ) ; \n if ( res < 0 ) \n return res ; \n } \n if ( par -> codec_id == AV_CODEC_ID_AAC ) { \n for ( i = 0 ; attr_names [ i ] . str ; ++ i ) { \n if ( ! av_strcasecmp ( attr , attr_names [ i ] . str ) ) { \n if ( attr_names [ i ] . type == ATTR_NAME_TYPE_INT ) { \n * ( int * ) ( ( char * ) data + \n attr_names [ i ] . offset ) = atoi ( value ) ; \n } else if ( attr_names [ i ] . type == ATTR_NAME_TYPE_STR ) \n * ( char * * ) ( ( char * ) data + \n attr_names [ i ] . offset ) = av_strdup ( value ) ; \n } \n } \n } \n return 0 ; \n }", "idx": 17786}
{"project": "FFmpeg", "commit_id": "4c8ca76965b1c29758246624940cbc529e7141f0", "target": 0, "func": "static int ffserver_set_int_param ( int * dest , const char * value , int factor , \n int min , int max , FFServerConfig * config , \n const char * error_msg , ... ) \n { \n int tmp ; \n char * tailp ; \n if ( ! value || ! value [ 0 ] ) \n goto error ; \n errno = 0 ; \n tmp = strtol ( value , & tailp , 0 ) ; \n if ( tmp < min || tmp > max ) \n goto error ; \n if ( factor ) { \n if ( FFABS ( tmp ) > INT_MAX / FFABS ( factor ) ) \n goto error ; \n tmp *= factor ; \n } \n if ( tailp [ 0 ] || errno ) \n goto error ; \n if ( dest ) \n * dest = tmp ; \n return 0 ; \n error : \n if ( config ) { \n va_list vl ; \n va_start ( vl , error_msg ) ; \n vreport_config_error ( config -> filename , config -> line_num , AV_LOG_ERROR , \n & config -> errors , error_msg , vl ) ; \n va_end ( vl ) ; \n } \n return AVERROR ( EINVAL ) ; \n }", "idx": 17787}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t find_tag ( AVIOContext * pb , uint32_t tag1 ) \n { \n unsigned int tag ; \n int64_t size ; \n for ( ; ; ) { \n if ( url_feof ( pb ) ) \n return AVERROR_EOF ; \n size = next_tag ( pb , & tag ) ; \n if ( tag == tag1 ) \n break ; \n wav_seek_tag ( pb , size , SEEK_CUR ) ; \n } \n return size ; \n }", "idx": 17792}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_float_dsp_init_x86 ( AVFloatDSPContext * fdsp ) \n { \n int cpu_flags = av_get_cpu_flags ( ) ; \n #if HAVE_6REGS && HAVE_INLINE_ASM  \n  \n  if ( INLINE_AMD3DNOWEXT ( cpu_flags ) ) { \n fdsp -> vector_fmul_window = vector_fmul_window_3dnowext ; \n } \n if ( INLINE_SSE ( cpu_flags ) ) { \n fdsp -> vector_fmul_window = vector_fmul_window_sse ; \n } \n #endif \n if ( EXTERNAL_SSE ( cpu_flags ) ) { \n fdsp -> vector_fmul = ff_vector_fmul_sse ; \n fdsp -> vector_fmac_scalar = ff_vector_fmac_scalar_sse ; \n fdsp -> vector_fmul_scalar = ff_vector_fmul_scalar_sse ; \n fdsp -> vector_fmul_add = ff_vector_fmul_add_sse ; \n fdsp -> vector_fmul_reverse = ff_vector_fmul_reverse_sse ; \n fdsp -> scalarproduct_float = ff_scalarproduct_float_sse ; \n fdsp -> butterflies_float = ff_butterflies_float_sse ; \n } \n if ( EXTERNAL_SSE2 ( cpu_flags ) ) { \n fdsp -> vector_dmul_scalar = ff_vector_dmul_scalar_sse2 ; \n } \n if ( EXTERNAL_AVX ( cpu_flags ) ) { \n fdsp -> vector_fmul = ff_vector_fmul_avx ; \n fdsp -> vector_fmac_scalar = ff_vector_fmac_scalar_avx ; \n fdsp -> vector_dmul_scalar = ff_vector_dmul_scalar_avx ; \n fdsp -> vector_fmul_add = ff_vector_fmul_add_avx ; \n fdsp -> vector_fmul_reverse = ff_vector_fmul_reverse_avx ; \n } \n }", "idx": 17803}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "static inline void get_limits ( MpegEncContext * s , int * range , int * xmin , int * ymin , int * xmax , int * ymax , int f_code ) \n { \n * range = 8 * ( 1 << ( f_code - 1 ) ) ; \n if ( s -> out_format == FMT_H263 && ! s -> h263_msmpeg4 ) \n * range *= 2 ; \n if ( s -> unrestricted_mv ) { \n * xmin = -16 ; \n * ymin = -16 ; \n if ( s -> h263_plus ) \n * range *= 2 ; \n if ( s -> avctx -> codec -> id != CODEC_ID_MPEG4 ) { \n * xmax = s -> mb_width * 16 ; \n * ymax = s -> mb_height * 16 ; \n } else { \n * xmax = s -> width ; \n * ymax = s -> height ; \n } \n } else { \n * xmin = 0 ; \n * ymin = 0 ; \n * xmax = s -> mb_width * 16 - 16 ; \n * ymax = s -> mb_height * 16 - 16 ; \n } \n }", "idx": 17807}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void mclms_predict ( WmallDecodeCtx * s , int icoef , int * pred ) \n { \n int ich , i ; \n int order = s -> mclms_order ; \n int num_channels = s -> num_channels ; \n for ( ich = 0 ; ich < num_channels ; ich ++ ) { \n pred [ ich ] = 0 ; \n if ( ! s -> is_channel_coded [ ich ] ) \n continue ; \n for ( i = 0 ; i < order * num_channels ; i ++ ) \n pred [ ich ] += s -> mclms_prevvalues [ i + s -> mclms_recent ] * \n s -> mclms_coeffs [ i + order * num_channels * ich ] ; \n for ( i = 0 ; i < ich ; i ++ ) \n pred [ ich ] += s -> channel_residues [ i ] [ icoef ] * \n s -> mclms_coeffs_cur [ i + num_channels * ich ] ; \n pred [ ich ] += 1 << s -> mclms_scaling - 1 ; \n pred [ ich ] >>= s -> mclms_scaling ; \n s -> channel_residues [ ich ] [ icoef ] += pred [ ich ] ; \n } \n }", "idx": 17877}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp ( H264Context * h , int qscale ) { \n return h -> pps . chroma_qp_table [ qscale & 0xff ] ; \n }", "idx": 17893}
{"project": "FFmpeg", "commit_id": "ac726a4f0cd2fb8619b478af51312a4282215f0e", "target": 0, "func": "static int movie_request_frame ( AVFilterLink * outlink ) \n { \n AVFilterBufferRef * outpicref ; \n MovieContext * movie = outlink -> src -> priv ; \n int ret ; \n if ( movie -> is_done ) \n return AVERROR_EOF ; \n if ( ( ret = movie_get_frame ( outlink ) ) < 0 ) \n return ret ; \n outpicref = avfilter_ref_buffer ( movie -> picref , ~ 0 ) ; \n ff_start_frame ( outlink , outpicref ) ; \n ff_draw_slice ( outlink , 0 , outlink -> h , 1 ) ; \n ff_end_frame ( outlink ) ; \n avfilter_unref_buffer ( movie -> picref ) ; \n movie -> picref = NULL ; \n return 0 ; \n }", "idx": 17913}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc31_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_8w_msa ( src - 2 , \n src - ( stride * 2 ) + \n sizeof ( uint8_t ) , stride , dst , stride , 8 ) ; \n }", "idx": 17954}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "void ff_slice_thread_free ( AVCodecContext * avctx ) \n { \n ThreadContext * c = avctx -> thread_opaque ; \n int i ; \n pthread_mutex_lock ( & c -> current_job_lock ) ; \n c -> done = 1 ; \n pthread_cond_broadcast ( & c -> current_job_cond ) ; \n pthread_mutex_unlock ( & c -> current_job_lock ) ; \n for ( i = 0 ; i < avctx -> thread_count ; i ++ ) \n pthread_join ( c -> workers [ i ] , NULL ) ; \n pthread_mutex_destroy ( & c -> current_job_lock ) ; \n pthread_cond_destroy ( & c -> current_job_cond ) ; \n pthread_cond_destroy ( & c -> last_job_cond ) ; \n av_free ( c -> workers ) ; \n av_freep ( & avctx -> thread_opaque ) ; \n }", "idx": 18171}
{"project": "FFmpeg", "commit_id": "e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0", "target": 1, "func": "static int ass_decode_frame ( AVCodecContext * avctx , void * data , int * got_sub_ptr , \n AVPacket * avpkt ) \n { \n const char * ptr = avpkt -> data ; \n int len , size = avpkt -> size ; \n while ( size > 0 ) { \n ASSDialog * dialog = ff_ass_split_dialog ( avctx -> priv_data , ptr , 0 , NULL ) ; \n int duration = dialog -> end - dialog -> start ; \n len = ff_ass_add_rect ( data , ptr , 0 , duration , 1 ) ; \n if ( len < 0 ) \n return len ; \n ptr += len ; \n size -= len ; \n } \n * got_sub_ptr = avpkt -> size > 0 ; \n return avpkt -> size ; \n }", "idx": 18175}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void add_index_entry ( AVStream * st , \n int64_t pos , int64_t timestamp , int flags ) \n { \n AVIndexEntry * entries , * ie ; \n entries = av_fast_realloc ( st -> index_entries , \n & st -> index_entries_allocated_size , \n ( st -> nb_index_entries + 1 ) * \n sizeof ( AVIndexEntry ) ) ; \n if ( entries ) { \n st -> index_entries = entries ; \n ie = & entries [ st -> nb_index_entries ++ ] ; \n ie -> pos = pos ; \n ie -> timestamp = timestamp ; \n ie -> flags = flags ; \n } \n }", "idx": 18200}
{"project": "FFmpeg", "commit_id": "5e5f75cf8abd76ada3011790a9b4f0762a72e41a", "target": 0, "func": "static void ffm_write_data ( AVFormatContext * s , \n const uint8_t * buf , int size , \n int64_t pts , int header ) \n { \n FFMContext * ffm = s -> priv_data ; \n int len ; \n if ( header && ffm -> frame_offset == 0 ) { \n ffm -> frame_offset = ffm -> packet_ptr - ffm -> packet + FFM_HEADER_SIZE ; \n ffm -> pts = pts ; \n } \n while ( size > 0 ) { \n len = ffm -> packet_end - ffm -> packet_ptr ; \n if ( len > size ) \n len = size ; \n memcpy ( ffm -> packet_ptr , buf , len ) ; \n ffm -> packet_ptr += len ; \n buf += len ; \n size -= len ; \n if ( ffm -> packet_ptr >= ffm -> packet_end ) { \n if ( ffm -> pts == 0 ) \n ffm -> pts = pts ; \n flush_packet ( s ) ; \n } \n } \n }", "idx": 18268}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC ( pred4x4_horizontal_add ) ( uint8_t * _pix , const int16_t * _block , \n ptrdiff_t stride ) \n { \n int i ; \n pixel * pix = ( pixel * ) _pix ; \n const dctcoef * block = ( const dctcoef * ) _block ; \n stride >>= sizeof ( pixel ) - 1 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n pixel v = pix [ -1 ] ; \n pix [ 0 ] = v += block [ 0 ] ; \n pix [ 1 ] = v += block [ 1 ] ; \n pix [ 2 ] = v += block [ 2 ] ; \n pix [ 3 ] = v + block [ 3 ] ; \n pix += stride ; \n block += 4 ; \n } \n }", "idx": 18279}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read ( uint8_t * dst_buf , cl_mem src_cl_buf , size_t buf_size ) \n { \n cl_int status ; \n void * mapped = clEnqueueMapBuffer ( gpu_env . command_queue , src_cl_buf , \n CL_TRUE , CL_MAP_READ , 0 , buf_size , \n 0 , NULL , NULL , & status ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n memcpy ( dst_buf , mapped , buf_size ) ; \n status = clEnqueueUnmapMemObject ( gpu_env . command_queue , src_cl_buf , mapped , 0 , NULL , NULL ) ; \n if ( status != CL_SUCCESS ) { \n av_log ( & openclutils , AV_LOG_ERROR , \" \\n \" , opencl_errstr ( status ) ) ; \n return AVERROR_EXTERNAL ; \n } \n return 0 ; \n }", "idx": 18304}
{"project": "FFmpeg", "commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "target": 1, "func": "static int mov_read_stsc ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned int i , entries ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n av_log ( c -> fc , AV_LOG_TRACE , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n if ( ! entries ) \n return 0 ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stsc_data ) ) \n return AVERROR_INVALIDDATA ; \n sc -> stsc_data = av_malloc ( entries * sizeof ( * sc -> stsc_data ) ) ; \n if ( ! sc -> stsc_data ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < entries && ! pb -> eof_reached ; i ++ ) { \n sc -> stsc_data [ i ] . first = avio_rb32 ( pb ) ; \n sc -> stsc_data [ i ] . count = avio_rb32 ( pb ) ; \n sc -> stsc_data [ i ] . id = avio_rb32 ( pb ) ; \n if ( sc -> stsc_data [ i ] . id > sc -> stsd_count ) \n return AVERROR_INVALIDDATA ; \n } \n sc -> stsc_count = i ; \n if ( pb -> eof_reached ) \n return AVERROR_EOF ; \n return 0 ; \n }", "idx": 18311}
{"project": "FFmpeg", "commit_id": "8c013a9e55d9065793ef7ca6459d1178927a2b35", "target": 0, "func": "static int avi_read_tag ( AVFormatContext * s , AVStream * st , uint32_t tag , \n uint32_t size ) \n { \n AVIOContext * pb = s -> pb ; \n char key [ 5 ] = { 0 } ; \n char * value ; \n size += ( size & 1 ) ; \n if ( size == UINT_MAX ) \n return AVERROR ( EINVAL ) ; \n value = av_malloc ( size + 1 ) ; \n if ( ! value ) \n return AVERROR ( ENOMEM ) ; \n avio_read ( pb , value , size ) ; \n value [ size ] = 0 ; \n AV_WL32 ( key , tag ) ; \n return av_dict_set ( st ? & st -> metadata : & s -> metadata , key , value , \n AV_DICT_DONT_STRDUP_VAL ) ; \n }", "idx": 18323}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid_analysis ( float out [ 91 ] [ 32 ] [ 2 ] , float in [ 5 ] [ 44 ] [ 2 ] , float L [ 2 ] [ 38 ] [ 64 ] , int is34 , int len ) \n { \n int i , j ; \n for ( i = 0 ; i < 5 ; i ++ ) { \n for ( j = 0 ; j < 38 ; j ++ ) { \n in [ i ] [ j + 6 ] [ 0 ] = L [ 0 ] [ j ] [ i ] ; \n in [ i ] [ j + 6 ] [ 1 ] = L [ 1 ] [ j ] [ i ] ; \n } \n } \n if ( is34 ) { \n hybrid4_8_12_cx ( in [ 0 ] , out , f34_0_12 , 12 , len ) ; \n hybrid4_8_12_cx ( in [ 1 ] , out + 12 , f34_1_8 , 8 , len ) ; \n hybrid4_8_12_cx ( in [ 2 ] , out + 20 , f34_2_4 , 4 , len ) ; \n hybrid4_8_12_cx ( in [ 3 ] , out + 24 , f34_2_4 , 4 , len ) ; \n hybrid4_8_12_cx ( in [ 4 ] , out + 28 , f34_2_4 , 4 , len ) ; \n for ( i = 0 ; i < 59 ; i ++ ) { \n for ( j = 0 ; j < len ; j ++ ) { \n out [ i + 32 ] [ j ] [ 0 ] = L [ 0 ] [ j ] [ i + 5 ] ; \n out [ i + 32 ] [ j ] [ 1 ] = L [ 1 ] [ j ] [ i + 5 ] ; \n } \n } \n } else { \n hybrid6_cx ( in [ 0 ] , out , f20_0_8 , len ) ; \n hybrid2_re ( in [ 1 ] , out + 6 , g1_Q2 , len , 1 ) ; \n hybrid2_re ( in [ 2 ] , out + 8 , g1_Q2 , len , 0 ) ; \n for ( i = 0 ; i < 61 ; i ++ ) { \n for ( j = 0 ; j < len ; j ++ ) { \n out [ i + 10 ] [ j ] [ 0 ] = L [ 0 ] [ j ] [ i + 3 ] ; \n out [ i + 10 ] [ j ] [ 1 ] = L [ 1 ] [ j ] [ i + 3 ] ; \n } \n } \n } \n for ( i = 0 ; i < 5 ; i ++ ) { \n memcpy ( in [ i ] , in [ i ] + 32 , 6 * sizeof ( in [ i ] [ 0 ] ) ) ; \n } \n }", "idx": 18324}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_optimal_rice_params ( RiceContext * rc , int porder , \n uint32_t * sums , int n , int pred_order ) \n { \n int i ; \n int k , cnt , part ; \n uint32_t all_bits ; \n part = ( 1 << porder ) ; \n all_bits = 4 * part ; \n cnt = ( n >> porder ) - pred_order ; \n for ( i = 0 ; i < part ; i ++ ) { \n k = find_optimal_param ( sums [ i ] , cnt ) ; \n rc -> params [ i ] = k ; \n all_bits += rice_encode_count ( sums [ i ] , cnt , k ) ; \n cnt = n >> porder ; \n } \n rc -> porder = porder ; \n return all_bits ; \n }", "idx": 18426}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_alloc ( uint8_t * pointers [ 4 ] , int linesizes [ 4 ] , \n int w , int h , enum PixelFormat pix_fmt , int align ) \n { \n int i , ret ; \n uint8_t * buf ; \n if ( ( ret = av_image_check_size ( w , h , 0 , NULL ) ) < 0 ) \n return ret ; \n if ( ( ret = av_image_fill_linesizes ( linesizes , pix_fmt , w ) ) < 0 ) \n return ret ; \n for ( i = 0 ; i < 4 ; i ++ ) \n linesizes [ i ] = FFALIGN ( linesizes [ i ] , align ) ; \n if ( ( ret = av_image_fill_pointers ( pointers , pix_fmt , h , NULL , linesizes ) ) < 0 ) \n return ret ; \n buf = av_malloc ( ret + align ) ; \n if ( ! buf ) \n return AVERROR ( ENOMEM ) ; \n if ( ( ret = av_image_fill_pointers ( pointers , pix_fmt , h , buf , linesizes ) ) < 0 ) { \n av_free ( buf ) ; \n return ret ; \n } \n if ( av_pix_fmt_descriptors [ pix_fmt ] . flags & PIX_FMT_PAL ) \n ff_set_systematic_pal2 ( ( uint32_t * ) pointers [ 1 ] , pix_fmt ) ; \n return ret ; \n }", "idx": 18438}
{"project": "FFmpeg", "commit_id": "18ff4d20201ae69fdeb2da2c90bdcbd33f7ac025", "target": 1, "func": "static int copy_chapters ( InputFile * ifile , OutputFile * ofile , int copy_metadata ) \n { \n AVFormatContext * is = ifile -> ctx ; \n AVFormatContext * os = ofile -> ctx ; \n int i ; \n for ( i = 0 ; i < is -> nb_chapters ; i ++ ) { \n AVChapter * in_ch = is -> chapters [ i ] , * out_ch ; \n int64_t ts_off = av_rescale_q ( ofile -> start_time - ifile -> ts_offset , \n AV_TIME_BASE_Q , in_ch -> time_base ) ; \n int64_t rt = ( ofile -> recording_time == INT64_MAX ) ? INT64_MAX : \n av_rescale_q ( ofile -> recording_time , AV_TIME_BASE_Q , in_ch -> time_base ) ; \n if ( in_ch -> end < ts_off ) \n continue ; \n if ( rt != INT64_MAX && in_ch -> start > rt + ts_off ) \n break ; \n out_ch = av_mallocz ( sizeof ( AVChapter ) ) ; \n if ( ! out_ch ) \n return AVERROR ( ENOMEM ) ; \n out_ch -> id = in_ch -> id ; \n out_ch -> time_base = in_ch -> time_base ; \n out_ch -> start = FFMAX ( 0 , in_ch -> start - ts_off ) ; \n out_ch -> end = FFMIN ( rt , in_ch -> end - ts_off ) ; \n if ( copy_metadata ) \n av_dict_copy ( & out_ch -> metadata , in_ch -> metadata , 0 ) ; \n os -> nb_chapters ++ ; \n os -> chapters = av_realloc ( os -> chapters , sizeof ( AVChapter ) * os -> nb_chapters ) ; \n if ( ! os -> chapters ) \n return AVERROR ( ENOMEM ) ; \n os -> chapters [ os -> nb_chapters - 1 ] = out_ch ; \n } \n return 0 ; \n }", "idx": 18474}
{"project": "FFmpeg", "commit_id": "64e105e051ca3e5088b0db64551244482b2836b4", "target": 0, "func": "static void dyn_buf_write ( void * opaque , UINT8 * buf , int buf_size ) \n { \n DynBuffer * d = opaque ; \n int new_size , new_allocated_size ; \n UINT8 * new_buffer ; \n new_size = d -> pos + buf_size ; \n new_allocated_size = d -> allocated_size ; \n while ( new_size > new_allocated_size ) { \n if ( ! new_allocated_size ) \n new_allocated_size = new_size ; \n else \n new_allocated_size = ( new_allocated_size * 3 ) / 2 ; \n } \n if ( new_allocated_size > d -> allocated_size ) { \n new_buffer = av_malloc ( new_allocated_size ) ; \n if ( ! new_buffer ) \n return ; \n memcpy ( new_buffer , d -> buffer , d -> size ) ; \n av_free ( d -> buffer ) ; \n d -> buffer = new_buffer ; \n d -> allocated_size = new_allocated_size ; \n } \n memcpy ( d -> buffer + d -> pos , buf , buf_size ) ; \n d -> pos = new_size ; \n if ( d -> pos > d -> size ) \n d -> size = d -> pos ; \n }", "idx": 18518}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int hex_to_data ( uint8_t * data , const char * p ) \n { \n int c , len , v ; \n len = 0 ; \n v = 1 ; \n for ( ; ; ) { \n skip_spaces ( & p ) ; \n if ( * p == ' \\0 ' ) \n break ; \n c = toupper ( ( unsigned char ) * p ++ ) ; \n if ( c >= ' ' && c <= ' ' ) \n c = c - ' ' ; \n else if ( c >= ' ' && c <= ' ' ) \n c = c - ' ' + 10 ; \n else \n break ; \n v = ( v << 4 ) | c ; \n if ( v & 0x100 ) { \n if ( data ) \n data [ len ] = v ; \n len ++ ; \n v = 1 ; \n } \n } \n return len ; \n }", "idx": 18529}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv ( FTPContext * s ) \n { \n char * res = NULL , * start = NULL , * end = NULL ; \n int i ; \n static const char d = ' ' ; \n static const char * command = \" \\r \\n \" ; \n static const int epsv_codes [ ] = { 229 , 0 } ; \n if ( ftp_send_command ( s , command , epsv_codes , & res ) != 229 || ! res ) \n goto fail ; \n for ( i = 0 ; res [ i ] ; ++ i ) { \n if ( res [ i ] == ' ' ) { \n start = res + i + 1 ; \n } else if ( res [ i ] == ' ' ) { \n end = res + i ; \n break ; \n } \n } \n if ( ! start || ! end ) \n goto fail ; \n * end = ' \\0 ' ; \n if ( strlen ( start ) < 5 ) \n goto fail ; \n if ( start [ 0 ] != d || start [ 1 ] != d || start [ 2 ] != d || end [ -1 ] != d ) \n goto fail ; \n start += 3 ; \n end [ -1 ] = ' \\0 ' ; \n s -> server_data_port = atoi ( start ) ; \n av_dlog ( s , \" \\n \" , s -> server_data_port ) ; \n av_free ( res ) ; \n return 0 ; \n fail : \n av_free ( res ) ; \n s -> server_data_port = -1 ; \n return AVERROR ( ENOSYS ) ; \n }", "idx": 18583}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) \n { \n long i ; \n for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { \n long a = * ( long * ) ( src1 + i ) ; \n long b = * ( long * ) ( src2 + i ) ; \n * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; \n } \n for ( ; i < w ; i ++ ) \n dst [ i ] = src1 [ i ] + src2 [ i ] ; \n }", "idx": 18624}
{"project": "FFmpeg", "commit_id": "0a359cf157957f3eb37760f731fa75dd320fd659", "target": 0, "func": "static int vc1_filter_line ( uint8_t * src , int stride , int pq ) { \n int a0 , a1 , a2 , a3 , d , clip , filt3 = 0 ; \n uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; \n a0 = ( 2 * ( src [ -2 * stride ] - src [ 1 * stride ] ) - 5 * ( src [ -1 * stride ] - src [ 0 * stride ] ) + 4 ) >> 3 ; \n if ( FFABS ( a0 ) < pq ) { \n a1 = ( 2 * ( src [ -4 * stride ] - src [ -1 * stride ] ) - 5 * ( src [ -3 * stride ] - src [ -2 * stride ] ) + 4 ) >> 3 ; \n a2 = ( 2 * ( src [ 0 * stride ] - src [ 3 * stride ] ) - 5 * ( src [ 1 * stride ] - src [ 2 * stride ] ) + 4 ) >> 3 ; \n a3 = FFMIN ( FFABS ( a1 ) , FFABS ( a2 ) ) ; \n if ( a3 < FFABS ( a0 ) ) { \n d = 5 * ( ( a0 >= 0 ? a3 : - a3 ) - a0 ) / 8 ; \n clip = ( src [ -1 * stride ] - src [ 0 * stride ] ) / 2 ; \n if ( clip ) { \n filt3 = 1 ; \n if ( clip > 0 ) \n d = av_clip ( d , 0 , clip ) ; \n else \n d = av_clip ( d , clip , 0 ) ; \n src [ -1 * stride ] = cm [ src [ -1 * stride ] - d ] ; \n src [ 0 * stride ] = cm [ src [ 0 * stride ] + d ] ; \n } \n } \n } \n return filt3 ; \n }", "idx": 18646}
{"project": "FFmpeg", "commit_id": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb", "target": 0, "func": "static int rle_unpack ( const unsigned char * src , unsigned char * dest , \n int src_count , int src_size , int dest_len ) \n { \n unsigned char * pd ; \n int i , l ; \n unsigned char * dest_end = dest + dest_len ; \n GetByteContext gb ; \n bytestream2_init ( & gb , src , src_size ) ; \n pd = dest ; \n if ( src_count & 1 ) { \n if ( bytestream2_get_bytes_left ( & gb ) < 1 ) \n return 0 ; \n * pd ++ = bytestream2_get_byteu ( & gb ) ; \n } \n src_count >>= 1 ; \n i = 0 ; \n do { \n if ( bytestream2_get_bytes_left ( & gb ) < 1 ) \n break ; \n l = bytestream2_get_byteu ( & gb ) ; \n if ( l & 0x80 ) { \n l = ( l & 0x7F ) * 2 ; \n if ( dest_end - pd < l || bytestream2_get_bytes_left ( & gb ) < l ) \n return bytestream2_tell ( & gb ) ; \n bytestream2_get_bufferu ( & gb , pd , l ) ; \n pd += l ; \n } else { \n if ( dest_end - pd < i || bytestream2_get_bytes_left ( & gb ) < 2 ) \n return bytestream2_tell ( & gb ) ; \n for ( i = 0 ; i < l ; i ++ ) { \n * pd ++ = bytestream2_get_byteu ( & gb ) ; \n * pd ++ = bytestream2_get_byteu ( & gb ) ; \n } \n bytestream2_skip ( & gb , 2 ) ; \n } \n i += l ; \n } while ( i < src_count ) ; \n return bytestream2_tell ( & gb ) ; \n }", "idx": 18648}
{"project": "FFmpeg", "commit_id": "1dff9adcb934175fe1beb14ee139ad0636daa29d", "target": 0, "func": "static int recheck_discard_flags ( AVFormatContext * s , int first ) \n { \n HLSContext * c = s -> priv_data ; \n int i , changed = 0 ; \n for ( i = 0 ; i < c -> n_playlists ; i ++ ) \n c -> playlists [ i ] -> cur_needed = 0 ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n AVStream * st = s -> streams [ i ] ; \n struct playlist * pls = c -> playlists [ s -> streams [ i ] -> id ] ; \n if ( st -> discard < AVDISCARD_ALL ) \n pls -> cur_needed = 1 ; \n } \n for ( i = 0 ; i < c -> n_playlists ; i ++ ) { \n struct playlist * pls = c -> playlists [ i ] ; \n if ( pls -> cur_needed && ! pls -> needed ) { \n pls -> needed = 1 ; \n changed = 1 ; \n pls -> cur_seq_no = select_cur_seq_no ( c , pls ) ; \n pls -> pb . eof_reached = 0 ; \n if ( c -> cur_timestamp != AV_NOPTS_VALUE ) { \n pls -> seek_timestamp = c -> cur_timestamp ; \n pls -> seek_flags = AVSEEK_FLAG_ANY ; \n pls -> seek_stream_index = -1 ; \n } \n av_log ( s , AV_LOG_INFO , \" \\n \" , i , pls -> cur_seq_no ) ; \n } else if ( first && ! pls -> cur_needed && pls -> needed ) { \n if ( pls -> input ) \n ff_format_io_close ( pls -> parent , & pls -> input ) ; \n pls -> needed = 0 ; \n changed = 1 ; \n av_log ( s , AV_LOG_INFO , \" \\n \" , i ) ; \n } \n } \n return changed ; \n }", "idx": 18649}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream * add_audio_stream ( AVFormatContext * oc , int codec_id ) \n { \n AVCodec * codec ; \n AVCodecContext * c ; \n AVStream * st ; \n st = av_new_stream ( oc , 1 ) ; \n if ( ! st ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n codec = avcodec_find_encoder ( codec_id ) ; \n if ( ! codec ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n c = & st -> codec ; \n c -> codec_type = CODEC_TYPE_AUDIO ; \n c -> bit_rate = 64000 ; \n c -> sample_rate = 44100 ; \n c -> channels = 2 ; \n if ( avcodec_open ( c , codec ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n t = 0 ; \n tincr = 2 * M_PI * 440.0 / c -> sample_rate ; \n audio_outbuf_size = 10000 ; \n audio_outbuf = malloc ( audio_outbuf_size ) ; \n if ( c -> frame_size <= 1 ) { \n audio_input_frame_size = audio_outbuf_size / c -> channels ; \n switch ( st -> codec . codec_id ) { \n case CODEC_ID_PCM_S16LE : \n case CODEC_ID_PCM_S16BE : \n case CODEC_ID_PCM_U16LE : \n case CODEC_ID_PCM_U16BE : \n audio_input_frame_size >>= 1 ; \n break ; \n default : \n break ; \n } \n } else { \n audio_input_frame_size = c -> frame_size ; \n } \n samples = malloc ( audio_input_frame_size * 2 * c -> channels ) ; \n return st ; \n }", "idx": 18700}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame ( AVFilterLink * inlink , AVFrame * src_buffer ) \n { \n AVFilterContext * ctx = inlink -> dst ; \n ATempoContext * atempo = ctx -> priv ; \n AVFilterLink * outlink = ctx -> outputs [ 0 ] ; \n int ret = 0 ; \n int n_in = src_buffer -> nb_samples ; \n int n_out = ( int ) ( 0.5 + ( ( double ) n_in ) / atempo -> tempo ) ; \n const uint8_t * src = src_buffer -> data [ 0 ] ; \n const uint8_t * src_end = src + n_in * atempo -> stride ; \n while ( src < src_end ) { \n if ( ! atempo -> dst_buffer ) { \n atempo -> dst_buffer = ff_get_audio_buffer ( outlink , n_out ) ; \n if ( ! atempo -> dst_buffer ) \n return AVERROR ( ENOMEM ) ; \n av_frame_copy_props ( atempo -> dst_buffer , src_buffer ) ; \n atempo -> dst = atempo -> dst_buffer -> data [ 0 ] ; \n atempo -> dst_end = atempo -> dst + n_out * atempo -> stride ; \n } \n yae_apply ( atempo , & src , src_end , & atempo -> dst , atempo -> dst_end ) ; \n if ( atempo -> dst == atempo -> dst_end ) { \n int n_samples = ( ( atempo -> dst - atempo -> dst_buffer -> data [ 0 ] ) / \n atempo -> stride ) ; \n ret = push_samples ( atempo , outlink , n_samples ) ; \n if ( ret < 0 ) \n goto end ; \n } \n } \n atempo -> nsamples_in += n_in ; \n end : \n av_frame_free ( & src_buffer ) ; \n return ret ; \n }", "idx": 18812}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten  void h264_loop_filter_chroma_intra_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta ) \n { \n int d ; \n for ( d = 0 ; d < 8 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n pix [ - xstride ] = ( 2 * p1 + p0 + q1 + 2 ) >> 2 ; \n pix [ 0 ] = ( 2 * q1 + q0 + p1 + 2 ) >> 2 ; \n } \n pix += ystride ; \n } \n }", "idx": 19011}
{"project": "FFmpeg", "commit_id": "fbd97184f8b68b2074b79a1698e4d9404292f7ca", "target": 1, "func": "static int link_filter_inouts ( AVFilterContext * filt_ctx , \n AVFilterInOut * * curr_inputs , \n AVFilterInOut * * open_inputs , AVClass * log_ctx ) \n { \n int pad = filt_ctx -> input_count , ret ; \n while ( pad -- ) { \n AVFilterInOut * p = * curr_inputs ; \n if ( ! p ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\\" \\\" \\n \" , \n filt_ctx -> filter -> name ) ; \n return AVERROR ( EINVAL ) ; \n } \n * curr_inputs = ( * curr_inputs ) -> next ; \n if ( p -> filter ) { \n if ( ( ret = link_filter ( p -> filter , p -> pad_idx , filt_ctx , pad , log_ctx ) ) < 0 ) \n return ret ; \n av_free ( p -> name ) ; \n av_free ( p ) ; \n } else { \n p -> filter = filt_ctx ; \n p -> pad_idx = pad ; \n insert_inout ( open_inputs , p ) ; \n } \n } \n if ( * curr_inputs ) { \n av_log ( log_ctx , AV_LOG_ERROR , \n \" \\\" \\\" \\n \" , \n filt_ctx -> filter -> name ) ; \n return AVERROR ( EINVAL ) ; \n } \n pad = filt_ctx -> output_count ; \n while ( pad -- ) { \n AVFilterInOut * currlinkn = av_mallocz ( sizeof ( AVFilterInOut ) ) ; \n currlinkn -> filter = filt_ctx ; \n currlinkn -> pad_idx = pad ; \n insert_inout ( curr_inputs , currlinkn ) ; \n } \n return 0 ; \n }", "idx": 19245}
{"project": "FFmpeg", "commit_id": "816577716bc6170bccfea3b9e865618b69a4b426", "target": 1, "func": "static av_cold int dvdsub_close ( AVCodecContext * avctx ) \n { \n DVDSubContext * ctx = avctx -> priv_data ; \n av_freep ( & ctx -> buf ) ; \n ctx -> buf_size = 0 ; \n return 0 ; \n }", "idx": 19353}
{"project": "FFmpeg", "commit_id": "919d13d2383bd7318b80ed0c5b723323a79a8996", "target": 0, "func": "static int cookie_string ( AVDictionary * dict , char * * cookies ) \n { \n AVDictionaryEntry * e = NULL ; \n int len = 1 ; \n while ( e = av_dict_get ( dict , \" \" , e , AV_DICT_IGNORE_SUFFIX ) ) \n len += strlen ( e -> key ) + strlen ( e -> value ) + 1 ; \n e = NULL ; \n if ( * cookies ) av_free ( * cookies ) ; \n * cookies = av_malloc ( len ) ; \n if ( ! cookies ) return AVERROR ( ENOMEM ) ; \n * cookies [ 0 ] = ' \\0 ' ; \n while ( e = av_dict_get ( dict , \" \" , e , AV_DICT_IGNORE_SUFFIX ) ) \n av_strlcatf ( * cookies , len , \" \\n \" , e -> key , e -> value ) ; \n return 0 ; \n }", "idx": 19411}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc ( VP8Context * s , int luma , \n uint8_t * dst , uint8_t * src , const VP56mv * mv , \n int x_off , int y_off , int block_w , int block_h , \n int width , int height , int linesize , \n vp8_mc_func mc_func [ 3 ] [ 3 ] ) \n { \n if ( AV_RN32A ( mv ) ) { \n static const uint8_t idx [ 3 ] [ 8 ] = { \n { 0 , 1 , 2 , 1 , 2 , 1 , 2 , 1 } , \n { 0 , 3 , 5 , 3 , 5 , 3 , 5 , 3 } , \n { 0 , 2 , 3 , 2 , 3 , 2 , 3 , 2 } , \n } ; \n int mx = ( mv -> x << luma ) & 7 , mx_idx = idx [ 0 ] [ mx ] ; \n int my = ( mv -> y << luma ) & 7 , my_idx = idx [ 0 ] [ my ] ; \n x_off += mv -> x >> ( 3 - luma ) ; \n y_off += mv -> y >> ( 3 - luma ) ; \n src += y_off * linesize + x_off ; \n if ( x_off < mx_idx || x_off >= width - block_w - idx [ 2 ] [ mx ] || \n y_off < my_idx || y_off >= height - block_h - idx [ 2 ] [ my ] ) { \n s -> dsp . emulated_edge_mc ( s -> edge_emu_buffer , src - my_idx * linesize - mx_idx , linesize , \n block_w + idx [ 1 ] [ mx ] , block_h + idx [ 1 ] [ my ] , \n x_off - mx_idx , y_off - my_idx , width , height ) ; \n src = s -> edge_emu_buffer + mx_idx + linesize * my_idx ; \n } \n mc_func [ my_idx ] [ mx_idx ] ( dst , linesize , src , linesize , block_h , mx , my ) ; \n } else \n mc_func [ 0 ] [ 0 ] ( dst , linesize , src + y_off * linesize + x_off , linesize , block_h , 0 , 0 ) ; \n }", "idx": 19538}
{"project": "FFmpeg", "commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "target": 1, "func": "static inline unsigned int get_uint ( ShortenContext * s , int k ) \n { \n if ( s -> version != 0 ) \n k = get_ur_golomb_shorten ( & s -> gb , ULONGSIZE ) ; \n return get_ur_golomb_shorten ( & s -> gb , k ) ; \n }", "idx": 19593}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void prepare_grab ( void ) \n { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n }", "idx": 19665}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_codec_desc ( const void * a , const void * b ) \n { \n const AVCodecDescriptor * const * da = a ; \n const AVCodecDescriptor * const * db = b ; \n return ( * da ) -> type != ( * db ) -> type ? ( * da ) -> type - ( * db ) -> type : \n strcmp ( ( * da ) -> name , ( * db ) -> name ) ; \n }", "idx": 19667}
{"project": "FFmpeg", "commit_id": "2162b862eba5aadb59c0cf7cc304c67f4a5fb946", "target": 1, "func": "static int huff_build10 ( VLC * vlc , uint8_t * len ) \n { \n HuffEntry he [ 1024 ] ; \n uint32_t codes [ 1024 ] ; \n uint8_t bits [ 1024 ] ; \n uint16_t syms [ 1024 ] ; \n uint32_t code ; \n int i ; \n for ( i = 0 ; i < 1024 ; i ++ ) { \n he [ i ] . sym = 1023 - i ; \n he [ i ] . len = len [ i ] ; \n } \n AV_QSORT ( he , 1024 , HuffEntry , huff_cmp_len10 ) ; \n code = 1 ; \n for ( i = 1023 ; i >= 0 ; i -- ) { \n codes [ i ] = code >> ( 32 - he [ i ] . len ) ; \n bits [ i ] = he [ i ] . len ; \n syms [ i ] = he [ i ] . sym ; \n code += 0x80000000u >> ( he [ i ] . len - 1 ) ; \n } \n ff_free_vlc ( vlc ) ; \n return ff_init_vlc_sparse ( vlc , FFMIN ( he [ 1023 ] . len , 12 ) , 1024 , \n bits , sizeof ( * bits ) , sizeof ( * bits ) , \n codes , sizeof ( * codes ) , sizeof ( * codes ) , \n syms , sizeof ( * syms ) , sizeof ( * syms ) , 0 ) ; \n }", "idx": 19827}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int nut_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n NUTContext * nut = s -> priv_data ; \n ByteIOContext * bc = & s -> pb ; \n int64_t pos ; \n int inited_stream_count ; \n nut -> avf = s ; \n av_set_pts_info ( s , 60 , 1 , AV_TIME_BASE ) ; \n pos = 0 ; \n for ( ; ; ) { \n if ( find_startcode ( bc , MAIN_STARTCODE , pos ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n pos = url_ftell ( bc ) ; \n if ( decode_main_header ( nut ) >= 0 ) \n break ; \n } \n s -> bit_rate = 0 ; \n nut -> stream = av_malloc ( sizeof ( StreamContext ) * nut -> stream_count ) ; \n pos = 0 ; \n for ( inited_stream_count = 0 ; inited_stream_count < nut -> stream_count ; ) { \n if ( find_startcode ( bc , STREAM_STARTCODE , pos ) < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n pos = url_ftell ( bc ) ; \n if ( decode_stream_header ( nut ) >= 0 ) \n inited_stream_count ++ ; \n } \n pos = 0 ; \n for ( ; ; ) { \n uint64_t startcode = find_any_startcode ( bc , pos ) ; \n pos = url_ftell ( bc ) ; \n if ( startcode == 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } else if ( startcode == KEYFRAME_STARTCODE ) { \n url_fseek ( bc , -8 , SEEK_CUR ) ; \n break ; \n } else if ( startcode != INFO_STARTCODE ) { \n continue ; \n } \n decode_info_header ( nut ) ; \n } \n return 0 ; \n }", "idx": 19886}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_reinit ( V4L2m2mContext * s ) \n { \n int ret ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n ret = ff_v4l2_context_set_status ( & s -> capture , VIDIOC_STREAMOFF ) ; \n if ( ret ) \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n if ( atomic_load ( & s -> refcount ) ) \n while ( sem_wait ( & s -> refsync ) == -1 && errno == EINTR ) ; \n ff_v4l2_context_release ( & s -> capture ) ; \n ret = ff_v4l2_context_get_format ( & s -> capture ) ; \n if ( ret ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n ret = ff_v4l2_context_set_format ( & s -> capture ) ; \n if ( ret ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n sem_destroy ( & s -> refsync ) ; \n sem_init ( & s -> refsync , 0 , 0 ) ; \n s -> draining = 0 ; \n s -> reinit = 0 ; \n return 0 ; \n }", "idx": 19889}
{"project": "FFmpeg", "commit_id": "12dea8a5a15343e9c404376c40ca8a1cc9d1479e", "target": 1, "func": "av_cold int ff_ivi_decode_close ( AVCodecContext * avctx ) \n { \n IVI45DecContext * ctx = avctx -> priv_data ; \n ivi_free_buffers ( & ctx -> planes [ 0 ] ) ; \n if ( ctx -> mb_vlc . cust_tab . table ) \n ff_free_vlc ( & ctx -> mb_vlc . cust_tab ) ; \n av_frame_free ( & ctx -> p_frame ) ; \n return 0 ; \n }", "idx": 19912}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_write_packet ( AVFormatContext * ctx , int stream_index , \n const uint8_t * buf , int size , int64_t pts ) \n { \n MpegMuxContext * s = ctx -> priv_data ; \n AVStream * st = ctx -> streams [ stream_index ] ; \n StreamInfo * stream = st -> priv_data ; \n int64_t dts ; \n int len ; \n if ( stream_index == s -> scr_stream_index ) \n s -> last_scr = pts ; \n #if 0  \n  \n  printf ( \" \\n \" , \n stream_index , pts / 90000.0 , s -> last_scr / 90000.0 ) ; \n #endif \n dts = AV_NOPTS_VALUE ; \n if ( stream -> start_pts == AV_NOPTS_VALUE ) { \n stream -> start_pts = pts ; \n stream -> start_dts = dts ; \n } \n while ( size > 0 ) { \n len = s -> packet_data_max_size - stream -> buffer_ptr ; \n if ( len > size ) \n len = size ; \n memcpy ( stream -> buffer + stream -> buffer_ptr , buf , len ) ; \n stream -> buffer_ptr += len ; \n buf += len ; \n size -= len ; \n while ( stream -> buffer_ptr >= s -> packet_data_max_size ) { \n flush_packet ( ctx , stream_index , \n stream -> start_pts , stream -> start_dts , s -> last_scr ) ; \n stream -> start_pts = AV_NOPTS_VALUE ; \n stream -> start_dts = AV_NOPTS_VALUE ; \n } \n } \n return 0 ; \n }", "idx": 19976}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "av_cold void avcodec_register ( AVCodec * codec ) \n { \n AVCodec * * p ; \n avcodec_init ( ) ; \n p = & first_avcodec ; \n while ( * p != NULL ) \n p = & ( * p ) -> next ; \n * p = codec ; \n codec -> next = NULL ; \n if ( codec -> init_static_data ) \n codec -> init_static_data ( codec ) ; \n }", "idx": 19998}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "static void encode_block ( MpegEncContext * s , int16_t * block , int n ) \n { \n int i , j , table_id ; \n int component , dc , last_index , val , run ; \n MJpegContext * m = s -> mjpeg_ctx ; \n component = ( n <= 3 ? 0 : ( n & 1 ) + 1 ) ; \n table_id = ( n <= 3 ? 0 : 1 ) ; \n dc = block [ 0 ] ; \n val = dc - s -> last_dc [ component ] ; \n ff_mjpeg_encode_coef ( m , table_id , val , 0 ) ; \n s -> last_dc [ component ] = dc ; \n run = 0 ; \n last_index = s -> block_last_index [ n ] ; \n table_id |= 2 ; \n for ( i = 1 ; i <= last_index ; i ++ ) { \n j = s -> intra_scantable . permutated [ i ] ; \n val = block [ j ] ; \n if ( val == 0 ) { \n run ++ ; \n } else { \n while ( run >= 16 ) { \n ff_mjpeg_encode_code ( m , table_id , 0xf0 ) ; \n run -= 16 ; \n } \n ff_mjpeg_encode_coef ( m , table_id , val , run ) ; \n run = 0 ; \n } \n } \n if ( last_index < 63 || run != 0 ) \n ff_mjpeg_encode_code ( m , table_id , 0 ) ; \n }", "idx": 20019}
{"project": "FFmpeg", "commit_id": "c9c55a56996836e7783fb27018834f230c553c98", "target": 0, "func": "static const MXFCodecUL * mxf_get_codec_ul ( const MXFCodecUL * uls , UID * uid ) \n { \n while ( uls -> id != CODEC_ID_NONE ) { \n if ( mxf_match_uid ( uls -> uid , * uid , 16 ) ) \n break ; \n uls ++ ; \n } \n return uls ; \n }", "idx": 20102}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static int seqvideo_decode_frame ( AVCodecContext * avctx , \n void * data , int * data_size , \n AVPacket * avpkt ) \n { \n const uint8_t * buf = avpkt -> data ; \n int buf_size = avpkt -> size ; \n SeqVideoContext * seq = avctx -> priv_data ; \n seq -> frame . reference = 1 ; \n seq -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; \n if ( avctx -> reget_buffer ( avctx , & seq -> frame ) ) { \n av_log ( seq -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n seqvideo_decode ( seq , buf , buf_size ) ; \n * data_size = sizeof ( AVFrame ) ; \n * ( AVFrame * ) data = seq -> frame ; \n return buf_size ; \n }", "idx": 20422}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_dequant_tables ( H264Context * h ) \n { \n int i , x ; \n init_dequant4_coeff_table ( h ) ; \n if ( h -> pps . transform_8x8_mode ) \n init_dequant8_coeff_table ( h ) ; \n if ( h -> sps . transform_bypass ) { \n for ( i = 0 ; i < 6 ; i ++ ) \n for ( x = 0 ; x < 16 ; x ++ ) \n h -> dequant4_coeff [ i ] [ 0 ] [ x ] = 1 << 6 ; \n if ( h -> pps . transform_8x8_mode ) \n for ( i = 0 ; i < 6 ; i ++ ) \n for ( x = 0 ; x < 64 ; x ++ ) \n h -> dequant8_coeff [ i ] [ 0 ] [ x ] = 1 << 6 ; \n } \n }", "idx": 20534}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME ( chrRangeToJpeg ) ( int16_t * dst , int width ) \n { \n int i ; \n for ( i = 0 ; i < width ; i ++ ) { \n dst [ i ] = ( FFMIN ( dst [ i ] , 30775 ) * 4663 - 9289992 ) >> 12 ; \n dst [ i + VOFW ] = ( FFMIN ( dst [ i + VOFW ] , 30775 ) * 4663 - 9289992 ) >> 12 ; \n } \n }", "idx": 20581}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hyscale ( SwsContext * c , int16_t * dst , int dstWidth , \n const uint8_t * src_in [ 4 ] , int srcW , int xInc , \n const int16_t * hLumFilter , \n const int16_t * hLumFilterPos , int hLumFilterSize , \n uint8_t * formatConvBuffer , \n uint32_t * pal , int isAlpha ) \n { \n void ( * toYV12 ) ( uint8_t * , const uint8_t * , int , uint32_t * ) = isAlpha ? c -> alpToYV12 : c -> lumToYV12 ; \n void ( * convertRange ) ( int16_t * , int ) = isAlpha ? NULL : c -> lumConvertRange ; \n const uint8_t * src = src_in [ isAlpha ? 3 : 0 ] ; \n if ( toYV12 ) { \n toYV12 ( formatConvBuffer , src , srcW , pal ) ; \n src = formatConvBuffer ; \n } else if ( c -> readLumPlanar && ! isAlpha ) { \n c -> readLumPlanar ( formatConvBuffer , src_in , srcW ) ; \n src = formatConvBuffer ; \n } \n if ( ! c -> hyscale_fast ) { \n c -> hyScale ( c , dst , dstWidth , src , hLumFilter , hLumFilterPos , hLumFilterSize ) ; \n } else { \n c -> hyscale_fast ( c , dst , dstWidth , src , srcW , xInc ) ; \n } \n if ( convertRange ) \n convertRange ( dst , dstWidth ) ; \n }", "idx": 20613}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten  void h264_loop_filter_chroma_c ( uint8_t * pix , int xstride , int ystride , int alpha , int beta , int8_t * tc0 ) \n { \n int i , d ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int tc = tc0 [ i ] ; \n if ( tc <= 0 ) { \n pix += 2 * ystride ; \n continue ; \n } \n for ( d = 0 ; d < 2 ; d ++ ) { \n const int p0 = pix [ -1 * xstride ] ; \n const int p1 = pix [ -2 * xstride ] ; \n const int q0 = pix [ 0 ] ; \n const int q1 = pix [ 1 * xstride ] ; \n if ( FFABS ( p0 - q0 ) < alpha && \n FFABS ( p1 - p0 ) < beta && \n FFABS ( q1 - q0 ) < beta ) { \n int delta = av_clip ( ( ( ( q0 - p0 ) << 2 ) + ( p1 - q1 ) + 4 ) >> 3 , - tc , tc ) ; \n pix [ - xstride ] = av_clip_uint8 ( p0 + delta ) ; \n pix [ 0 ] = av_clip_uint8 ( q0 - delta ) ; \n } \n pix += ystride ; \n } \n } \n }", "idx": 20617}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int set_chroma_format ( AVCodecContext * avctx ) \n { \n int num_formats = sizeof ( schro_pixel_format_map ) / \n sizeof ( schro_pixel_format_map [ 0 ] ) ; \n int idx ; \n SchroEncoderParams * p_schro_params = avctx -> priv_data ; \n for ( idx = 0 ; idx < num_formats ; ++ idx ) { \n if ( schro_pixel_format_map [ idx ] . ff_pix_fmt == avctx -> pix_fmt ) { \n p_schro_params -> format -> chroma_format = \n schro_pixel_format_map [ idx ] . schro_pix_fmt ; \n return 0 ; \n } \n } \n av_log ( avctx , AV_LOG_ERROR , \n \" \" \n \" \\n \" ) ; \n return -1 ; \n }", "idx": 20623}
{"project": "FFmpeg", "commit_id": "8728360b5664ef9db31137d8d3104cac33b9a911", "target": 1, "func": "static av_cold int mp_decode_init ( AVCodecContext * avctx ) \n { \n MotionPixelsContext * mp = avctx -> priv_data ; \n int w4 = ( avctx -> width + 3 ) & ~ 3 ; \n int h4 = ( avctx -> height + 3 ) & ~ 3 ; \n if ( avctx -> extradata_size < 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n motionpixels_tableinit ( ) ; \n mp -> avctx = avctx ; \n ff_dsputil_init ( & mp -> dsp , avctx ) ; \n mp -> changes_map = av_mallocz ( avctx -> width * h4 ) ; \n mp -> offset_bits_len = av_log2 ( avctx -> width * avctx -> height ) + 1 ; \n mp -> vpt = av_mallocz ( avctx -> height * sizeof ( YuvPixel ) ) ; \n mp -> hpt = av_mallocz ( h4 * w4 / 16 * sizeof ( YuvPixel ) ) ; \n avctx -> pix_fmt = AV_PIX_FMT_RGB555 ; \n avcodec_get_frame_defaults ( & mp -> frame ) ; \n return 0 ; \n }", "idx": 20659}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void put_payload_header ( \n AVFormatContext * s , \n ASFStream * stream , \n int presentation_time , \n int m_obj_size , \n int m_obj_offset , \n int payload_len \n ) \n { \n ASFContext * asf = s -> priv_data ; \n ByteIOContext * pb = & asf -> pb ; \n int val ; \n val = stream -> num ; \n if ( s -> streams [ val - 1 ] -> codec . coded_frame -> key_frame ) \n val |= ASF_PL_FLAG_KEY_FRAME ; \n put_byte ( pb , val ) ; \n put_byte ( pb , stream -> seq ) ; \n put_le32 ( pb , m_obj_offset ) ; \n put_byte ( pb , ASF_PAYLOAD_REPLICATED_DATA_LENGTH ) ; \n put_le32 ( pb , m_obj_size ) ; \n put_le32 ( pb , presentation_time ) ; \n if ( asf -> multi_payloads_present ) { \n put_le16 ( pb , payload_len ) ; \n } \n }", "idx": 20662}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static int h261_find_frame_end ( ParseContext * pc , AVCodecContext * avctx , const uint8_t * buf , int buf_size ) { \n int vop_found , i , j , bits_left , last_bits ; \n uint32_t state ; \n H261Context * h = avctx -> priv_data ; \n if ( h ) { \n bits_left = h -> bits_left ; \n last_bits = h -> last_bits ; \n } \n else { \n bits_left = 0 ; \n last_bits = 0 ; \n } \n vop_found = pc -> frame_start_found ; \n state = pc -> state ; \n if ( bits_left != 0 && ! vop_found ) \n state = state << ( 8 - bits_left ) | last_bits ; \n i = 0 ; \n if ( ! vop_found ) { \n for ( i = 0 ; i < buf_size ; i ++ ) { \n state = ( state << 8 ) | buf [ i ] ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n if ( ( ( ( state << j ) | ( buf [ i ] >> ( 8 - j ) ) ) >> ( 32 - 20 ) == 0x10 ) && ( ( ( state >> ( 17 - j ) ) & 0x4000 ) == 0x0 ) ) { \n i ++ ; \n vop_found = 1 ; \n break ; \n } \n } \n if ( vop_found ) \n break ; \n } \n } \n if ( vop_found ) { \n for ( ; i < buf_size ; i ++ ) { \n if ( avctx -> flags & CODEC_FLAG_TRUNCATED ) \n state = ( state << 8 ) | buf [ i ] ; \n for ( j = 0 ; j < 8 ; j ++ ) { \n if ( ( ( ( state << j ) | ( buf [ i ] >> ( 8 - j ) ) ) >> ( 32 - 20 ) == 0x10 ) && ( ( ( state >> ( 17 - j ) ) & 0x4000 ) == 0x0 ) ) { \n pc -> frame_start_found = 0 ; \n pc -> state = -1 ; \n return i - 3 ; \n } \n } \n } \n } \n pc -> frame_start_found = vop_found ; \n pc -> state = state ; \n return END_NOT_FOUND ; \n }", "idx": 20741}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME ( yuv2yuvX ) ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , \n int chrFilterSize , const int16_t * * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , int dstW , int chrDstW ) \n { \n if ( uDest ) { \n x86_reg uv_off = c -> uv_off ; \n YSCALEYUV2YV12X ( CHR_MMX_FILTER_OFFSET , uDest , chrDstW , 0 )  \n YSCALEYUV2YV12X ( CHR_MMX_FILTER_OFFSET , vDest - uv_off , chrDstW + uv_off , uv_off )  \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) { \n YSCALEYUV2YV12X ( ALP_MMX_FILTER_OFFSET , aDest , dstW , 0 )  \n } \n YSCALEYUV2YV12X ( LUM_MMX_FILTER_OFFSET , dest , dstW , 0 )  \n }", "idx": 20856}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_huffman_decode ( unsigned char * dest , unsigned char * src ) \n { \n unsigned char byte = * src ++ ; \n unsigned char ival = byte + 0x16 ; \n unsigned char * ptr = src + byte * 2 ; \n unsigned char val = ival ; \n int counter = 0 ; \n unsigned char bits = * ptr ++ ; \n while ( val != 0x16 ) { \n if ( ( 1 << counter ) & bits ) \n val = src [ byte + val - 0x17 ] ; \n else \n val = src [ val - 0x17 ] ; \n if ( val < 0x16 ) { \n * dest ++ = val ; \n val = ival ; \n } \n if ( counter ++ == 7 ) { \n counter = 0 ; \n bits = * ptr ++ ; \n } \n } \n return 0 ; \n }", "idx": 20903}
{"project": "FFmpeg", "commit_id": "f3ace37a3b8c93218630a37b7df4dc195f1215a9", "target": 1, "func": "static int ftp_status ( FTPContext * s , char * * line , const int response_codes [ ] ) \n { \n int err , i , dash = 0 , result = 0 , code_found = 0 ; \n char buf [ CONTROL_BUFFER_SIZE ] ; \n AVBPrint line_buffer ; \n if ( line ) \n av_bprint_init ( & line_buffer , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; \n while ( ! code_found || dash ) { \n if ( ( err = ftp_get_line ( s , buf , sizeof ( buf ) ) ) < 0 ) { \n av_bprint_finalize ( & line_buffer , NULL ) ; \n return err ; \n } \n av_log ( s , AV_LOG_DEBUG , \" \\n \" , buf ) ; \n if ( strlen ( buf ) < 4 ) \n continue ; \n err = 0 ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n if ( buf [ i ] < ' ' || buf [ i ] > ' ' ) \n continue ; \n err *= 10 ; \n err += buf [ i ] - ' ' ; \n } \n dash = ! ! ( buf [ 3 ] == ' ' ) ; \n for ( i = 0 ; response_codes [ i ] ; ++ i ) { \n if ( err == response_codes [ i ] ) { \n if ( line ) \n av_bprintf ( & line_buffer , \" \" , buf ) ; \n code_found = 1 ; \n result = err ; \n break ; \n } \n } \n } \n if ( line ) \n av_bprint_finalize ( & line_buffer , line ) ; \n return result ; \n }", "idx": 20918}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "double avpriv_strtod ( char * restrict nptr , char * * restrict endptr ) \n { \n char * end ; \n double res ; \n while ( isspace ( * nptr ) ) \n nptr ++ ; \n if ( ! av_strncasecmp ( nptr , \" \" , 8 ) ) { \n end = nptr + 8 ; \n res = INFINITY ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 3 ) ) { \n end = nptr + 3 ; \n res = INFINITY ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 9 ) ) { \n end = nptr + 9 ; \n res = INFINITY ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 4 ) ) { \n end = nptr + 4 ; \n res = INFINITY ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 9 ) ) { \n end = nptr + 9 ; \n res = - INFINITY ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 4 ) ) { \n end = nptr + 4 ; \n res = - INFINITY ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 3 ) ) { \n end = check_nan_suffix ( nptr + 3 ) ; \n res = NAN ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 4 ) || \n ! av_strncasecmp ( nptr , \" \" , 4 ) ) { \n end = check_nan_suffix ( nptr + 4 ) ; \n res = NAN ; \n } else if ( ! av_strncasecmp ( nptr , \" \" , 2 ) || \n ! av_strncasecmp ( nptr , \" \" , 3 ) || \n ! av_strncasecmp ( nptr , \" \" , 3 ) ) { \n res = strtoll ( nptr , & end , 16 ) ; \n } else { \n res = strtod ( nptr , & end ) ; \n } \n if ( endptr ) \n * endptr = end ; \n return res ; \n }", "idx": 20958}
{"project": "FFmpeg", "commit_id": "b2a8850969b89151677253be4d99e0ba29212749", "target": 0, "func": "static void update_video_pts ( VideoState * is , double pts , int64_t pos , int serial ) { \n double time = av_gettime ( ) / 1000000.0 ; \n is -> video_current_pts = pts ; \n is -> video_current_pts_drift = is -> video_current_pts - time ; \n is -> video_current_pos = pos ; \n is -> frame_last_pts = pts ; \n check_external_clock_sync ( is , is -> video_current_pts ) ; \n }", "idx": 20961}
{"project": "FFmpeg", "commit_id": "e30b068ef79f604ff439418da07f7e2efd01d4ea", "target": 1, "func": "static void save_bits ( WMAProDecodeCtx * s , GetBitContext * gb , int len , \n int append ) \n { \n int buflen ; \n if ( ! append ) { \n s -> frame_offset = get_bits_count ( gb ) & 7 ; \n s -> num_saved_bits = s -> frame_offset ; \n init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ; \n buflen = ( s -> num_saved_bits + len + 8 ) >> 3 ; \n if ( len <= 0 || buflen > MAX_FRAMESIZE ) { \n avpriv_request_sample ( s -> avctx , \" \" ) ; \n s -> num_saved_bits += len ; \n if ( ! append ) { \n avpriv_copy_bits ( & s -> pb , gb -> buffer + ( get_bits_count ( gb ) >> 3 ) , \n s -> num_saved_bits ) ; \n } else { \n int align = 8 - ( get_bits_count ( gb ) & 7 ) ; \n align = FFMIN ( align , len ) ; \n put_bits ( & s -> pb , align , get_bits ( gb , align ) ) ; \n len -= align ; \n avpriv_copy_bits ( & s -> pb , gb -> buffer + ( get_bits_count ( gb ) >> 3 ) , len ) ; \n skip_bits_long ( gb , len ) ; \n { \n PutBitContext tmp = s -> pb ; \n flush_put_bits ( & tmp ) ; \n init_get_bits ( & s -> gb , s -> frame_data , s -> num_saved_bits ) ; \n skip_bits ( & s -> gb , s -> frame_offset ) ;", "idx": 21007}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help ( void ) \n { \n const char * prog ; \n const OptionDef * po ; \n int i , expert ; \n prog = do_play ? \" \" : \" \" ; \n printf ( \" \" FFMPEG_VERSION \" \\n \" , \n prog ) ; \n if ( ! do_play ) { \n printf ( \" \\n \" \n \" \\n \" ) ; \n } else { \n printf ( \" \\n \" \n \" \\n \" ) ; \n } \n printf ( \" \\n \" \n \" \\n \" ) ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( i == 1 ) \n printf ( \" \\n \\n \" ) ; \n for ( po = options ; po -> name != NULL ; po ++ ) { \n char buf [ 64 ] ; \n expert = ( po -> flags & OPT_EXPERT ) != 0 ; \n if ( expert == i ) { \n strcpy ( buf , po -> name ) ; \n if ( po -> flags & HAS_ARG ) { \n strcat ( buf , \" \" ) ; \n strcat ( buf , po -> argname ) ; \n } \n printf ( \" \\n \" , buf , po -> help ) ; \n } \n } \n } \n exit ( 1 ) ; \n }", "idx": 21050}
{"project": "FFmpeg", "commit_id": "b8a2331a70b720e83e1be243f7d17941c8952ef2", "target": 1, "func": "av_cold int ffv1_common_init ( AVCodecContext * avctx ) \n { \n FFV1Context * s = avctx -> priv_data ; \n if ( ! avctx -> width || ! avctx -> height ) \n return AVERROR_INVALIDDATA ; \n s -> avctx = avctx ; \n s -> flags = avctx -> flags ; \n s -> picture . f = avcodec_alloc_frame ( ) ; \n s -> last_picture . f = av_frame_alloc ( ) ; \n ff_dsputil_init ( & s -> dsp , avctx ) ; \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n s -> num_h_slices = 1 ; \n s -> num_v_slices = 1 ; \n return 0 ; \n }", "idx": 21061}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr16 ( const uint8_t * src , uint8_t * dst , long num_pixels , const uint8_t * palette ) \n { \n long i ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n ( ( uint16_t * ) dst ) [ i ] = bswap_16 ( ( ( uint16_t * ) palette ) [ src [ i ] ] ) ; \n }", "idx": 21118}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_h_lpf_chroma_inter_msa ( uint8_t * data , int img_width , \n int alpha , int beta , int8_t * tc ) \n { \n uint8_t bs0 = 1 ; \n uint8_t bs1 = 1 ; \n uint8_t bs2 = 1 ; \n uint8_t bs3 = 1 ; \n if ( tc [ 0 ] < 0 ) \n bs0 = 0 ; \n if ( tc [ 1 ] < 0 ) \n bs1 = 0 ; \n if ( tc [ 2 ] < 0 ) \n bs2 = 0 ; \n if ( tc [ 3 ] < 0 ) \n bs3 = 0 ; \n avc_loopfilter_cb_or_cr_inter_edge_ver_msa ( data , \n bs0 , bs1 , bs2 , bs3 , \n tc [ 0 ] , tc [ 1 ] , tc [ 2 ] , tc [ 3 ] , \n alpha , beta , \n img_width ) ; \n }", "idx": 21168}
{"project": "FFmpeg", "commit_id": "2ac00d2d1d51047c6ce69d5fbe1a08392d142658", "target": 0, "func": "static int mov_read_stsc ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVStream * st ; \n MOVStreamContext * sc ; \n unsigned int i , entries ; \n if ( c -> fc -> nb_streams < 1 ) \n return 0 ; \n st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; \n sc = st -> priv_data ; \n avio_r8 ( pb ) ; \n avio_rb24 ( pb ) ; \n entries = avio_rb32 ( pb ) ; \n av_log ( c -> fc , AV_LOG_TRACE , \" \\n \" , c -> fc -> nb_streams - 1 , entries ) ; \n if ( ! entries ) \n return 0 ; \n if ( entries >= UINT_MAX / sizeof ( * sc -> stsc_data ) ) \n return AVERROR_INVALIDDATA ; \n sc -> stsc_data = av_malloc ( entries * sizeof ( * sc -> stsc_data ) ) ; \n if ( ! sc -> stsc_data ) \n return AVERROR ( ENOMEM ) ; \n for ( i = 0 ; i < entries && ! pb -> eof_reached ; i ++ ) { \n sc -> stsc_data [ i ] . first = avio_rb32 ( pb ) ; \n sc -> stsc_data [ i ] . count = avio_rb32 ( pb ) ; \n sc -> stsc_data [ i ] . id = avio_rb32 ( pb ) ; \n if ( sc -> stsc_data [ i ] . id < 0 || sc -> stsc_data [ i ] . id > sc -> stsd_count ) { \n sc -> stsc_data [ i ] . id = 0 ; \n if ( c -> fc -> error_recognition & AV_EF_EXPLODE ) { \n av_log ( c -> fc , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR_INVALIDDATA ; \n } \n } \n } \n sc -> stsc_count = i ; \n if ( pb -> eof_reached ) \n return AVERROR_EOF ; \n return 0 ; \n }", "idx": 21281}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_copy ( uint8_t * frame , int width , int height , \n const uint8_t * src , const uint8_t * src_end ) \n { \n const int size = width * height ; \n if ( src_end - src < size ) \n return -1 ; \n bytestream_get_buffer ( & src , frame , size ) ; \n return 0 ; \n }", "idx": 21284}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free ( AVFilterLink * * link ) \n { \n if ( ! * link ) \n return ; \n if ( ( * link ) -> pool ) { \n int i ; \n for ( i = 0 ; i < POOL_SIZE ; i ++ ) { \n if ( ( * link ) -> pool -> pic [ i ] ) { \n AVFilterBufferRef * picref = ( * link ) -> pool -> pic [ i ] ; \n av_freep ( & picref -> buf -> data [ 0 ] ) ; \n av_freep ( & picref -> buf ) ; \n av_freep ( & picref -> audio ) ; \n av_freep ( & picref -> video ) ; \n av_freep ( & picref ) ; \n } \n } \n av_freep ( & ( * link ) -> pool ) ; \n } \n av_freep ( link ) ; \n }", "idx": 21302}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift ( MOVStreamContext * sc , int duration ) \n { \n if ( duration < 0 ) { \n sc -> dts_shift = FFMAX ( sc -> dts_shift , - duration ) ;", "idx": 21385}
{"project": "FFmpeg", "commit_id": "a494792961a08f9f0e47e7eeed65e609178ff436", "target": 1, "func": "static void fill_table ( uint8_t * table [ 256 + 2 * YUVRGB_TABLE_HEADROOM ] , const int elemsize , \n const int inc , void * y_tab ) \n { \n int i ; \n uint8_t * y_table = y_tab ; \n y_table -= elemsize * ( inc >> 9 ) ; \n for ( i = 0 ; i < 256 + 2 * YUVRGB_TABLE_HEADROOM ; i ++ ) { \n int64_t cb = av_clip ( i - YUVRGB_TABLE_HEADROOM , 0 , 255 ) * inc ; \n table [ i ] = y_table + elemsize * ( cb >> 16 ) ; \n } \n }", "idx": 21583}
{"project": "FFmpeg", "commit_id": "f3e5a7844bbf13620ca4b6a5e19aa087c9141b15", "target": 0, "func": "static int allocate_buffers ( ALACContext * alac ) \n { \n int ch ; \n for ( ch = 0 ; ch < FFMIN ( alac -> channels , 2 ) ; ch ++ ) { \n int buf_size = alac -> max_samples_per_frame * sizeof ( int32_t ) ; \n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> predict_error_buffer [ ch ] , \n buf_size , buf_alloc_fail ) ; \n if ( alac -> sample_size == 16 ) { \n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> output_samples_buffer [ ch ] , \n buf_size , buf_alloc_fail ) ; \n } \n FF_ALLOC_OR_GOTO ( alac -> avctx , alac -> extra_bits_buffer [ ch ] , \n buf_size , buf_alloc_fail ) ; \n } \n return 0 ; \n buf_alloc_fail : \n alac_decode_close ( alac -> avctx ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 21584}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static int put_cod ( Jpeg2000EncoderContext * s ) \n { \n Jpeg2000CodingStyle * codsty = & s -> codsty ; \n if ( s -> buf_end - s -> buf < 14 ) \n return -1 ; \n bytestream_put_be16 ( & s -> buf , JPEG2000_COD ) ; \n bytestream_put_be16 ( & s -> buf , 12 ) ; \n bytestream_put_byte ( & s -> buf , 0 ) ; \n bytestream_put_byte ( & s -> buf , 0 ) ; \n bytestream_put_be16 ( & s -> buf , 1 ) ; \n if ( s -> avctx -> pix_fmt == AV_PIX_FMT_YUV444P ) { \n bytestream_put_byte ( & s -> buf , 2 ) ; \n } else { \n bytestream_put_byte ( & s -> buf , 0 ) ; \n } \n bytestream_put_byte ( & s -> buf , codsty -> nreslevels - 1 ) ; \n bytestream_put_byte ( & s -> buf , codsty -> log2_cblk_width - 2 ) ; \n bytestream_put_byte ( & s -> buf , codsty -> log2_cblk_height - 2 ) ; \n bytestream_put_byte ( & s -> buf , 0 ) ; \n bytestream_put_byte ( & s -> buf , codsty -> transform ) ; \n return 0 ; \n }", "idx": 21585}
{"project": "FFmpeg", "commit_id": "17269bdfcdb79679f6b92024d1228e876b799a63", "target": 1, "func": "static int swf_write_trailer ( AVFormatContext * s ) \n { \n SWFContext * swf = s -> priv_data ; \n ByteIOContext * pb = & s -> pb ; \n AVCodecContext * enc , * video_enc ; \n int file_size , i ; \n video_enc = NULL ; \n for ( i = 0 ; i < s -> nb_streams ; i ++ ) { \n enc = & s -> streams [ i ] -> codec ; \n if ( enc -> codec_type == CODEC_TYPE_VIDEO ) \n video_enc = enc ; \n } \n put_swf_tag ( s , TAG_END ) ; \n put_swf_end_tag ( s ) ; \n put_flush_packet ( & s -> pb ) ; \n if ( ! url_is_streamed ( & s -> pb ) && video_enc ) { \n file_size = url_ftell ( pb ) ; \n url_fseek ( pb , 4 , SEEK_SET ) ; \n put_le32 ( pb , file_size ) ; \n url_fseek ( pb , swf -> duration_pos , SEEK_SET ) ; \n put_le16 ( pb , video_enc -> frame_number ) ; \n } \n av_free ( swf ) ; \n return 0 ; \n }", "idx": 21750}
{"project": "FFmpeg", "commit_id": "bc7eb330e3d42f6cff3f95432da999bd4538e2e1", "target": 0, "func": "static void opt_frame_size ( const char * arg ) \n { \n if ( av_parse_video_frame_size ( & frame_width , & frame_height , arg ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n if ( ( frame_width % 2 ) != 0 || ( frame_height % 2 ) != 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n av_exit ( 1 ) ; \n } \n }", "idx": 21767}
{"project": "FFmpeg", "commit_id": "20fe316e47fedb28787e77e77a7011133f3d4e73", "target": 1, "func": "static int sdl_write_trailer ( AVFormatContext * s ) \n { \n SDLContext * sdl = s -> priv_data ; \n sdl -> quit = 1 ; \n if ( sdl -> overlay ) \n SDL_FreeYUVOverlay ( sdl -> overlay ) ; \n if ( sdl -> event_thread ) \n SDL_WaitThread ( sdl -> event_thread , NULL ) ; \n if ( sdl -> mutex ) \n SDL_DestroyMutex ( sdl -> mutex ) ; \n if ( sdl -> init_cond ) \n SDL_DestroyCond ( sdl -> init_cond ) ; \n if ( ! sdl -> sdl_was_already_inited ) \n SDL_Quit ( ) ; \n return 0 ; \n }", "idx": 21776}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int decode_i_picture_primary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int pqindex ; \n if ( v -> profile <= PROFILE_MAIN && get_bits ( gb , 7 ) ) \n { \n av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n } \n pqindex = get_bits ( gb , 5 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_IMPLICIT ) \n v -> pq = pquant_table [ 0 ] [ pqindex ] ; \n else \n { \n v -> pq = pquant_table [ v -> quantizer_mode - 1 ] [ pqindex ] ; \n } \n if ( pqindex < 9 ) v -> halfpq = get_bits ( gb , 1 ) ; \n if ( v -> quantizer_mode == QUANT_FRAME_EXPLICIT ) \n v -> pquantizer = get_bits ( gb , 1 ) ; \n av_log ( v -> s . avctx , AV_LOG_DEBUG , \" \\n \" , \n v -> pq , v -> halfpq ) ; \n return 0 ; \n }", "idx": 21796}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_bits ( Jpeg2000DecoderContext * s , int n ) \n { \n int res = 0 ; \n if ( s -> buf_end - s -> buf < ( ( n - s -> bit_index ) >> 8 ) ) \n return AVERROR_INVALIDDATA ; \n while ( -- n >= 0 ) { \n res <<= 1 ; \n if ( s -> bit_index == 0 ) { \n s -> bit_index = 7 + ( * s -> buf != 0xff ) ; \n s -> buf ++ ; \n } \n s -> bit_index -- ; \n res |= ( * s -> buf >> s -> bit_index ) & 1 ; \n } \n return res ; \n }", "idx": 21822}
{"project": "FFmpeg", "commit_id": "bf252f7f6fa9c79743242f3efdd30827c97407b4", "target": 0, "func": "static int mov_read_udta_string ( MOVContext * c , ByteIOContext * pb , MOVAtom atom ) \n { \n char * str = NULL ; \n int size ; \n uint16_t str_size ; \n if ( c -> itunes_metadata ) { \n int data_size = get_be32 ( pb ) ; \n int tag = get_le32 ( pb ) ; \n if ( tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) ) { \n get_be32 ( pb ) ; \n get_be32 ( pb ) ; \n str_size = data_size - 16 ; \n } else return 0 ; \n } else { \n str_size = get_be16 ( pb ) ; \n get_be16 ( pb ) ; \n } \n switch ( atom . type ) { \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n str = c -> fc -> title ; size = sizeof ( c -> fc -> title ) ; break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n str = c -> fc -> author ; size = sizeof ( c -> fc -> author ) ; break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n str = c -> fc -> copyright ; size = sizeof ( c -> fc -> copyright ) ; break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n str = c -> fc -> comment ; size = sizeof ( c -> fc -> comment ) ; break ; \n case MKTAG ( 0xa9 , ' ' , ' ' , ' ' ) : \n str = c -> fc -> album ; size = sizeof ( c -> fc -> album ) ; break ; \n } \n if ( ! str ) \n return 0 ; \n get_buffer ( pb , str , FFMIN ( size , str_size ) ) ; \n dprintf ( c -> fc , \" \\n \" , ( char * ) & atom . type , str ) ; \n return 0 ; \n }", "idx": 21828}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "static QUANT_FN ( pvq_encode_band ) \n { \n return quant_band_template ( pvq , f , rc , band , X , Y , N , b , blocks , lowband , duration , \n lowband_out , level , gain , lowband_scratch , fill , 1 ) ; \n }", "idx": 21851}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions ( AVCodecContext * s , int * width , int * height ) { \n int w_align = 1 ; \n int h_align = 1 ; \n switch ( s -> pix_fmt ) { \n case PIX_FMT_YUV420P : \n case PIX_FMT_YUYV422 : \n case PIX_FMT_UYVY422 : \n case PIX_FMT_YUV422P : \n case PIX_FMT_YUV444P : \n case PIX_FMT_GRAY8 : \n case PIX_FMT_GRAY16BE : \n case PIX_FMT_GRAY16LE : \n case PIX_FMT_YUVJ420P : \n case PIX_FMT_YUVJ422P : \n case PIX_FMT_YUVJ444P : \n case PIX_FMT_YUVA420P : \n w_align = 16 ; \n h_align = 16 ; \n break ; \n case PIX_FMT_YUV411P : \n case PIX_FMT_UYYVYY411 : \n w_align = 32 ; \n h_align = 8 ; \n break ; \n case PIX_FMT_YUV410P : \n if ( s -> codec_id == CODEC_ID_SVQ1 ) { \n w_align = 64 ; \n h_align = 64 ; \n } \n case PIX_FMT_RGB555 : \n if ( s -> codec_id == CODEC_ID_RPZA ) { \n w_align = 4 ; \n h_align = 4 ; \n } \n case PIX_FMT_PAL8 : \n case PIX_FMT_BGR8 : \n case PIX_FMT_RGB8 : \n if ( s -> codec_id == CODEC_ID_SMC ) { \n w_align = 4 ; \n h_align = 4 ; \n } \n break ; \n case PIX_FMT_BGR24 : \n if ( ( s -> codec_id == CODEC_ID_MSZH ) || ( s -> codec_id == CODEC_ID_ZLIB ) ) { \n w_align = 4 ; \n h_align = 4 ; \n } \n break ; \n default : \n w_align = 1 ; \n h_align = 1 ; \n break ; \n } \n * width = ALIGN ( * width , w_align ) ; \n * height = ALIGN ( * height , h_align ) ; \n if ( s -> codec_id == CODEC_ID_H264 ) \n * height += 2 ; \n }", "idx": 21899}
{"project": "FFmpeg", "commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "target": 1, "func": "void ff_init_cabac_decoder ( CABACContext * c , const uint8_t * buf , int buf_size ) { \n c -> bytestream_start = \n c -> bytestream = buf ; \n c -> bytestream_end = buf + buf_size ; \n #if CABAC_BITS == 16  \n  \n  c -> low = ( * c -> bytestream ++ ) << 18 ; \n c -> low += ( * c -> bytestream ++ ) << 10 ; \n #else \n c -> low = ( * c -> bytestream ++ ) << 10 ; \n #endif \n c -> low += ( ( * c -> bytestream ++ ) << 2 ) + 2 ; \n c -> range = 0x1FE ; \n }", "idx": 21919}
{"project": "FFmpeg", "commit_id": "8a9641a652ed1546fedfda22584f79d3d423096e", "target": 0, "func": "AVBitStreamFilterContext * av_bitstream_filter_init ( const char * name ) \n { \n AVBitStreamFilter * bsf = first_bitstream_filter ; \n while ( bsf ) { \n if ( ! strcmp ( name , bsf -> name ) ) { \n AVBitStreamFilterContext * bsfc = \n av_mallocz ( sizeof ( AVBitStreamFilterContext ) ) ; \n bsfc -> filter = bsf ; \n bsfc -> priv_data = \n bsf -> priv_data_size ? av_mallocz ( bsf -> priv_data_size ) : NULL ; \n return bsfc ; \n } \n bsf = bsf -> next ; \n } \n return NULL ; \n }", "idx": 21938}
{"project": "FFmpeg", "commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "target": 1, "func": "int avio_close_dyn_buf ( AVIOContext * s , uint8_t * * pbuffer ) \n { \n DynBuffer * d = s -> opaque ; \n int size ; \n static const char padbuf [ FF_INPUT_BUFFER_PADDING_SIZE ] = { 0 } ; \n int padding = 0 ; \n if ( ! s ) { \n * pbuffer = NULL ; \n return 0 ; \n } \n if ( ! s -> max_packet_size ) { \n avio_write ( s , padbuf , sizeof ( padbuf ) ) ; \n padding = FF_INPUT_BUFFER_PADDING_SIZE ; \n } \n avio_flush ( s ) ; \n * pbuffer = d -> buffer ; \n size = d -> size ; \n av_free ( d ) ; \n av_free ( s ) ; \n return size - padding ; \n }", "idx": 21971}
{"project": "FFmpeg", "commit_id": "02591641f88097aec2a573f0ae384c8b87bcfe3b", "target": 1, "func": "static void decode_subframe_lpc ( ShortenContext * s , int channel , int residual_size , int pred_order ) \n { \n int sum , i , j ; \n int coeffs [ pred_order ] ; \n for ( i = 0 ; i < pred_order ; i ++ ) \n coeffs [ i ] = get_sr_golomb_shorten ( & s -> gb , LPCQUANT ) ; \n for ( i = 0 ; i < s -> blocksize ; i ++ ) { \n sum = s -> lpcqoffset ; \n for ( j = 0 ; j < pred_order ; j ++ ) \n sum += coeffs [ j ] * s -> decoded [ channel ] [ i - j - 1 ] ; \n s -> decoded [ channel ] [ i ] = get_sr_golomb_shorten ( & s -> gb , residual_size ) + ( sum >> LPCQUANT ) ; \n } \n }", "idx": 22003}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void dwt_encode97_int ( DWTContext * s , int * t ) \n { \n int lev , \n w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; \n int * line = s -> i_linebuf ; \n line += 5 ; \n for ( lev = s -> ndeclevels - 1 ; lev >= 0 ; lev -- ) { \n int lh = s -> linelen [ lev ] [ 0 ] , \n lv = s -> linelen [ lev ] [ 1 ] , \n mh = s -> mod [ lev ] [ 0 ] , \n mv = s -> mod [ lev ] [ 1 ] , \n lp ; \n int * l ; \n l = line + mv ; \n for ( lp = 0 ; lp < lh ; lp ++ ) { \n int i , j = 0 ; \n for ( i = 0 ; i < lv ; i ++ ) \n l [ i ] = t [ w * i + lp ] ; \n sd_1d97_int ( line , mv , mv + lv ) ; \n for ( i = mv ; i < lv ; i += 2 , j ++ ) \n t [ w * j + lp ] = ( ( l [ i ] * I_LFTG_X ) + ( 1 << 16 ) ) >> 17 ; \n for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) \n t [ w * j + lp ] = ( ( l [ i ] * I_LFTG_K ) + ( 1 << 16 ) ) >> 17 ; \n } \n l = line + mh ; \n for ( lp = 0 ; lp < lv ; lp ++ ) { \n int i , j = 0 ; \n for ( i = 0 ; i < lh ; i ++ ) \n l [ i ] = t [ w * lp + i ] ; \n sd_1d97_int ( line , mh , mh + lh ) ; \n for ( i = mh ; i < lh ; i += 2 , j ++ ) \n t [ w * lp + j ] = ( ( l [ i ] * I_LFTG_X ) + ( 1 << 16 ) ) >> 17 ; \n for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) \n t [ w * lp + j ] = ( ( l [ i ] * I_LFTG_K ) + ( 1 << 16 ) ) >> 17 ; \n } \n } \n }", "idx": 22034}
{"project": "FFmpeg", "commit_id": "808c10e728db2d92ccbb0f8b3bcd4a2f4305a2cf", "target": 0, "func": "static void format_line ( void * ptr , int level , const char * fmt , va_list vl , \n AVBPrint part [ 3 ] , int * print_prefix , int type [ 2 ] ) \n { \n AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; \n av_bprint_init ( part + 0 , 0 , 1 ) ; \n av_bprint_init ( part + 1 , 0 , 1 ) ; \n av_bprint_init ( part + 2 , 0 , 65536 ) ; \n if ( type ) type [ 0 ] = type [ 1 ] = AV_CLASS_CATEGORY_NA + 16 ; \n if ( * print_prefix && avc ) { \n if ( avc -> parent_log_context_offset ) { \n AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + \n avc -> parent_log_context_offset ) ; \n if ( parent && * parent ) { \n av_bprintf ( part + 0 , \" \" , \n ( * parent ) -> item_name ( parent ) , parent ) ; \n if ( type ) type [ 0 ] = get_category ( parent ) ; \n } \n } \n av_bprintf ( part + 1 , \" \" , \n avc -> item_name ( ptr ) , ptr ) ; \n if ( type ) type [ 1 ] = get_category ( ptr ) ; \n } \n av_vbprintf ( part + 2 , fmt , vl ) ; \n if ( * part [ 0 ] . str || * part [ 1 ] . str || * part [ 2 ] . str ) { \n char lastc = part [ 2 ] . len ? part [ 2 ] . str [ part [ 2 ] . len - 1 ] : 0 ; \n * print_prefix = lastc == ' \\n ' || lastc == ' \\r ' ; \n } \n }", "idx": 22086}
{"project": "FFmpeg", "commit_id": "1f4ff53aea7c5090f31cd1323d95f7c407c9b2bb", "target": 0, "func": "static int dnxhd_init_vlc ( DNXHDContext * ctx , uint32_t cid ) \n { \n if ( cid != ctx -> cid ) { \n int index ; \n if ( ( index = ff_dnxhd_get_cid_table ( cid ) ) < 0 ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , cid ) ; \n return AVERROR ( ENOSYS ) ; \n } \n if ( ff_dnxhd_cid_table [ index ] . bit_depth != ctx -> bit_depth ) { \n av_log ( ctx -> avctx , AV_LOG_ERROR , \" \\n \" , ff_dnxhd_cid_table [ index ] . bit_depth , ctx -> bit_depth ) ; \n return AVERROR_INVALIDDATA ; \n } \n ctx -> cid_table = & ff_dnxhd_cid_table [ index ] ; \n av_log ( ctx -> avctx , AV_LOG_VERBOSE , \" \\n \" , cid ) ; \n ff_free_vlc ( & ctx -> ac_vlc ) ; \n ff_free_vlc ( & ctx -> dc_vlc ) ; \n ff_free_vlc ( & ctx -> run_vlc ) ; \n init_vlc ( & ctx -> ac_vlc , DNXHD_VLC_BITS , 257 , \n ctx -> cid_table -> ac_bits , 1 , 1 , \n ctx -> cid_table -> ac_codes , 2 , 2 , 0 ) ; \n init_vlc ( & ctx -> dc_vlc , DNXHD_DC_VLC_BITS , ctx -> bit_depth + 4 , \n ctx -> cid_table -> dc_bits , 1 , 1 , \n ctx -> cid_table -> dc_codes , 1 , 1 , 0 ) ; \n init_vlc ( & ctx -> run_vlc , DNXHD_VLC_BITS , 62 , \n ctx -> cid_table -> run_bits , 1 , 1 , \n ctx -> cid_table -> run_codes , 2 , 2 , 0 ) ; \n ctx -> cid = cid ; \n } \n return 0 ; \n }", "idx": 22089}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings ( AVCodecContext * avctx ) \n { \n X264Context * x4 = avctx -> priv_data ; \n int score = 0 ; \n score += x4 -> params . analyse . i_me_range == 0 ; \n score += x4 -> params . rc . i_qp_step == 3 ; \n score += x4 -> params . i_keyint_max == 12 ; \n score += x4 -> params . rc . i_qp_min == 2 ; \n score += x4 -> params . rc . i_qp_max == 31 ; \n score += x4 -> params . rc . f_qcompress == 0.5 ; \n score += fabs ( x4 -> params . rc . f_ip_factor - 1.25 ) < 0.01 ; \n score += fabs ( x4 -> params . rc . f_pb_factor - 1.25 ) < 0.01 ; \n score += x4 -> params . analyse . inter == 0 && x4 -> params . analyse . i_subpel_refine == 8 ; \n if ( score >= 5 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n x4 -> preset = av_strdup ( \" \" ) ; \n if ( avctx -> bit_rate == 200 * 1000 ) \n avctx -> crf = 23 ; \n } \n }", "idx": 22093}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME ( yuv2yuvX_ar ) ( SwsContext * c , const int16_t * lumFilter , \n const int16_t * * lumSrc , int lumFilterSize , \n const int16_t * chrFilter , const int16_t * * chrUSrc , \n const int16_t * * chrVSrc , \n int chrFilterSize , const int16_t * * alpSrc , \n uint8_t * dest , uint8_t * uDest , uint8_t * vDest , \n uint8_t * aDest , long dstW , long chrDstW ) \n { \n if ( uDest ) { \n YSCALEYUV2YV12X_ACCURATE ( CHR_MMX_FILTER_OFFSET , uDest , chrDstW , 0 )  \n YSCALEYUV2YV12X_ACCURATE ( CHR_MMX_FILTER_OFFSET , vDest , chrDstW + c -> uv_off , c -> uv_off )  \n } \n if ( CONFIG_SWSCALE_ALPHA && aDest ) { \n YSCALEYUV2YV12X_ACCURATE ( ALP_MMX_FILTER_OFFSET , aDest , dstW , 0 )  \n } \n YSCALEYUV2YV12X_ACCURATE ( LUM_MMX_FILTER_OFFSET , dest , dstW , 0 )  \n }", "idx": 22361}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int voc_probe ( AVProbeData * p ) \n { \n int version , check ; \n if ( p -> buf_size < 26 ) \n return 0 ; \n if ( memcmp ( p -> buf , voc_magic , sizeof ( voc_magic ) - 1 ) ) \n return 0 ; \n version = p -> buf [ 22 ] | ( p -> buf [ 23 ] << 8 ) ; \n check = p -> buf [ 24 ] | ( p -> buf [ 25 ] << 8 ) ; \n if ( ~ version + 0x1234 != check ) \n return 10 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 22379}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit ( void ) \n { \n #ifndef __MINGW32__ \n tcsetattr ( 0 , TCSANOW , & oldtty ) ; \n #endif \n }", "idx": 22392}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void ff_schro_queue_free ( FFSchroQueue * queue , void ( * free_func ) ( void * ) ) \n { \n while ( queue -> p_head ) \n free_func ( ff_schro_queue_pop ( queue ) ) ; \n }", "idx": 22531}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "AVInputFormat * av_find_input_format ( const char * short_name ) \n { \n AVInputFormat * fmt = NULL ; \n while ( ( fmt = av_iformat_next ( fmt ) ) ) \n if ( match_format ( short_name , fmt -> name ) ) \n return fmt ; \n return NULL ; \n }", "idx": 22559}
{"project": "FFmpeg", "commit_id": "b791a0831b0a027e7ba4eb6961cc0180472ac603", "target": 1, "func": "static av_cold void dsputil_init_sse2 ( DSPContext * c , AVCodecContext * avctx , \n int mm_flags ) \n { \n #if HAVE_SSE2_INLINE  \n  \n  const int high_bit_depth = avctx -> bits_per_raw_sample > 8 ; \n if ( ! high_bit_depth && avctx -> idct_algo == FF_IDCT_XVIDMMX ) { \n c -> idct_put = ff_idct_xvid_sse2_put ; \n c -> idct_add = ff_idct_xvid_sse2_add ; \n c -> idct = ff_idct_xvid_sse2 ; \n c -> idct_permutation_type = FF_SSE2_IDCT_PERM ; \n } \n #endif \n #if HAVE_SSE2_EXTERNAL  \n  \n  c -> scalarproduct_int16 = ff_scalarproduct_int16_sse2 ; \n c -> scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2 ; \n if ( mm_flags & AV_CPU_FLAG_ATOM ) { \n c -> vector_clip_int32 = ff_vector_clip_int32_int_sse2 ; \n } else { \n c -> vector_clip_int32 = ff_vector_clip_int32_sse2 ; \n } \n if ( avctx -> flags & CODEC_FLAG_BITEXACT ) { \n c -> apply_window_int16 = ff_apply_window_int16_sse2 ; \n } else if ( ! ( mm_flags & AV_CPU_FLAG_SSE2SLOW ) ) { \n c -> apply_window_int16 = ff_apply_window_int16_round_sse2 ; \n } \n c -> bswap_buf = ff_bswap32_buf_sse2 ; \n #endif \n }", "idx": 22597}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int au_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size <= 24 ) \n return 0 ; \n if ( p -> buf [ 0 ] == ' ' && p -> buf [ 1 ] == ' ' && \n p -> buf [ 2 ] == ' ' && p -> buf [ 3 ] == ' ' ) \n return AVPROBE_SCORE_MAX ; \n else \n return 0 ; \n }", "idx": 22601}
{"project": "FFmpeg", "commit_id": "2711cb28f46463760f0326d806fe5ef9551ade2c", "target": 1, "func": "static double get_diff_limited_q ( MpegEncContext * s , RateControlEntry * rce , double q ) { \n RateControlContext * rcc = & s -> rc_context ; \n AVCodecContext * a = s -> avctx ; \n const int pict_type = rce -> new_pict_type ; \n const double last_p_q = rcc -> last_qscale_for [ P_TYPE ] ; \n const double last_non_b_q = rcc -> last_qscale_for [ rcc -> last_non_b_pict_type ] ; \n if ( pict_type == I_TYPE && ( a -> i_quant_factor > 0.0 || rcc -> last_non_b_pict_type == P_TYPE ) ) \n q = last_p_q * FFABS ( a -> i_quant_factor ) + a -> i_quant_offset ; \n else if ( pict_type == B_TYPE && a -> b_quant_factor > 0.0 ) \n q = last_non_b_q * a -> b_quant_factor + a -> b_quant_offset ; \n if ( rcc -> last_non_b_pict_type == pict_type || pict_type != I_TYPE ) { \n double last_q = rcc -> last_qscale_for [ pict_type ] ; \n const int maxdiff = FF_QP2LAMBDA * a -> max_qdiff ; \n if ( q > last_q + maxdiff ) q = last_q + maxdiff ; \n else if ( q < last_q - maxdiff ) q = last_q - maxdiff ; \n } \n rcc -> last_qscale_for [ pict_type ] = q ; \n if ( pict_type != B_TYPE ) \n rcc -> last_non_b_pict_type = pict_type ; \n return q ; \n }", "idx": 22655}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_probe ( AVProbeData * p ) \n { \n const unsigned char * ptr = p -> buf ; \n int i , v , num = 0 ; \n if ( AV_RB24 ( ptr ) == 0xEFBBBF ) \n ptr += 3 ; \n while ( * ptr == ' \\r ' || * ptr == ' \\n ' ) \n ptr ++ ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n if ( ( num == i || num + 1 == i ) \n && sscanf ( ptr , \" \" , & v ) == 1 ) \n return AVPROBE_SCORE_MAX ; \n num = atoi ( ptr ) ; \n ptr += strcspn ( ptr , \" \\n \" ) + 1 ; \n } \n return 0 ; \n }", "idx": 22702}
{"project": "FFmpeg", "commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "target": 1, "func": "static av_cold int dnxhd_decode_close ( AVCodecContext * avctx ) \n { \n DNXHDContext * ctx = avctx -> priv_data ; \n ff_free_vlc ( & ctx -> ac_vlc ) ; \n ff_free_vlc ( & ctx -> dc_vlc ) ; \n ff_free_vlc ( & ctx -> run_vlc ) ; \n av_freep ( & ctx -> mb_scan_index ) ; \n av_freep ( & ctx -> rows ) ; \n return 0 ; \n }", "idx": 22718}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct_test ( AC3MDCTContext * mdct , AVLFG * lfg ) \n { \n int16_t input [ MDCT_SAMPLES ] ; \n int32_t output [ AC3_MAX_COEFS ] ; \n float input1 [ MDCT_SAMPLES ] ; \n float output1 [ AC3_MAX_COEFS ] ; \n float s , a , err , e , emax ; \n int i , k , n ; \n for ( i = 0 ; i < MDCT_SAMPLES ; i ++ ) { \n input [ i ] = ( av_lfg_get ( lfg ) % 65535 - 32767 ) * 9 / 10 ; \n input1 [ i ] = input [ i ] ; \n } \n mdct512 ( mdct , output , input ) ; \n for ( k = 0 ; k < AC3_MAX_COEFS ; k ++ ) { \n s = 0 ; \n for ( n = 0 ; n < MDCT_SAMPLES ; n ++ ) { \n a = ( 2 * M_PI * ( 2 * n + 1 + MDCT_SAMPLES / 2 ) * ( 2 * k + 1 ) / ( 4 * MDCT_SAMPLES ) ) ; \n s += input1 [ n ] * cos ( a ) ; \n } \n output1 [ k ] = -2 * s / MDCT_SAMPLES ; \n } \n err = 0 ; \n emax = 0 ; \n for ( i = 0 ; i < AC3_MAX_COEFS ; i ++ ) { \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , i , output [ i ] , output1 [ i ] ) ; \n e = output [ i ] - output1 [ i ] ; \n if ( e > emax ) \n emax = e ; \n err += e * e ; \n } \n av_log ( NULL , AV_LOG_DEBUG , \" \\n \" , err / AC3_MAX_COEFS , emax ) ; \n }", "idx": 22826}
{"project": "FFmpeg", "commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "target": 1, "func": "static AVRational update_sar ( int old_w , int old_h , AVRational sar , int new_w , int new_h ) \n { \n if ( ! sar . num ) \n sar = ( AVRational ) { 1 , 1 } ; \n sar = av_mul_q ( sar , ( AVRational ) { new_h * old_w , new_w * old_h } ) ; \n return sar ; \n }", "idx": 22833}
{"project": "FFmpeg", "commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "target": 1, "func": "static void create_default_qtables ( uint8_t * qtables , uint8_t q ) \n { \n int factor = q ; \n int i ; \n factor = av_clip ( q , 1 , 99 ) ; \n if ( q < 50 ) \n q = 5000 / factor ; \n else \n q = 200 - factor * 2 ; \n for ( i = 0 ; i < 128 ; i ++ ) { \n int val = ( default_quantizers [ i ] * q + 50 ) / 100 ; \n val = av_clip ( val , 1 , 255 ) ; \n qtables [ i ] = val ; \n } \n }", "idx": 22944}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_close ( AudioFrameQueue * afq ) \n { \n while ( afq -> frame_queue ) \n delete_next_frame ( afq ) ; \n memset ( afq , 0 , sizeof ( * afq ) ) ; \n }", "idx": 22949}
{"project": "FFmpeg", "commit_id": "81cc7d0bd1eab0aa782ff8dd49e087025a42cdee", "target": 1, "func": "static void lumRangeToJpeg16_c ( int16_t * _dst , int width ) \n { \n int i ; \n int32_t * dst = ( int32_t * ) _dst ; \n for ( i = 0 ; i < width ; i ++ ) \n dst [ i ] = ( FFMIN ( dst [ i ] , 30189 << 4 ) * 19077 - ( 39057361 << 4 ) ) >> 14 ; \n }", "idx": 22955}
{"project": "FFmpeg", "commit_id": "8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f", "target": 1, "func": "static av_cold int vp3_decode_end ( AVCodecContext * avctx ) \n { \n Vp3DecodeContext * s = avctx -> priv_data ; \n int i ; \n if ( avctx -> is_copy && ! s -> current_frame . data [ 0 ] ) \n return 0 ; \n av_free ( s -> superblock_coding ) ; \n av_free ( s -> all_fragments ) ; \n av_free ( s -> coded_fragment_list [ 0 ] ) ; \n av_free ( s -> dct_tokens_base ) ; \n av_free ( s -> superblock_fragments ) ; \n av_free ( s -> macroblock_coding ) ; \n av_free ( s -> motion_val [ 0 ] ) ; \n av_free ( s -> motion_val [ 1 ] ) ; \n av_free ( s -> edge_emu_buffer ) ; \n if ( avctx -> is_copy ) return 0 ; \n for ( i = 0 ; i < 16 ; i ++ ) { \n free_vlc ( & s -> dc_vlc [ i ] ) ; \n free_vlc ( & s -> ac_vlc_1 [ i ] ) ; \n free_vlc ( & s -> ac_vlc_2 [ i ] ) ; \n free_vlc ( & s -> ac_vlc_3 [ i ] ) ; \n free_vlc ( & s -> ac_vlc_4 [ i ] ) ; \n } \n free_vlc ( & s -> superblock_run_length_vlc ) ; \n free_vlc ( & s -> fragment_run_length_vlc ) ; \n free_vlc ( & s -> mode_code_vlc ) ; \n free_vlc ( & s -> motion_vector_vlc ) ; \n if ( s -> golden_frame . data [ 0 ] ) \n ff_thread_release_buffer ( avctx , & s -> golden_frame ) ; \n if ( s -> last_frame . data [ 0 ] && s -> last_frame . type != FF_BUFFER_TYPE_COPY ) \n ff_thread_release_buffer ( avctx , & s -> last_frame ) ; \n return 0 ; \n }", "idx": 22976}
{"project": "FFmpeg", "commit_id": "9a0f60a0f89a7a71839dfa9def5a26f2037aed62", "target": 0, "func": "static int mpeg4_decode_gop_header ( MpegEncContext * s , GetBitContext * gb ) \n { \n int hours , minutes , seconds ; \n if ( ! show_bits ( gb , 23 ) ) { \n av_log ( s -> avctx , AV_LOG_WARNING , \" \\n \" ) ; \n return -1 ; \n } \n hours = get_bits ( gb , 5 ) ; \n minutes = get_bits ( gb , 6 ) ; \n skip_bits1 ( gb ) ; \n seconds = get_bits ( gb , 6 ) ; \n s -> time_base = seconds + 60 * ( minutes + 60 * hours ) ; \n skip_bits1 ( gb ) ; \n skip_bits1 ( gb ) ; \n return 0 ; \n }", "idx": 23123}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_restart ( FTPContext * s , int64_t pos ) \n { \n char command [ CONTROL_BUFFER_SIZE ] ; \n const int rest_codes [ ] = { 350 , 0 } ; \n snprintf ( command , sizeof ( command ) , \" \" PRId64 \" \\r \\n \" , pos ) ; \n if ( ! ftp_send_command ( s , command , rest_codes , NULL ) ) \n return AVERROR ( EIO ) ; \n return 0 ; \n }", "idx": 23136}
{"project": "FFmpeg", "commit_id": "bb146bb57bea6647f9c080aa4f9323a3a789ad22", "target": 0, "func": "theora_gptopts ( AVFormatContext * ctx , int idx , uint64_t gp , int64_t * dts )  \n { \n struct ogg * ogg = ctx -> priv_data ; \n struct ogg_stream * os = ogg -> streams + idx ; \n struct theora_params * thp = os -> private ; \n uint64_t iframe = gp >> thp -> gpshift ; \n uint64_t pframe = gp & thp -> gpmask ; \n if ( thp -> version < 0x030201 ) \n iframe ++ ; \n if ( ! pframe ) \n os -> pflags |= AV_PKT_FLAG_KEY ; \n if ( dts ) \n * dts = iframe + pframe ; \n return iframe + pframe ; \n }", "idx": 23159}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void av_build_index_raw ( AVFormatContext * s ) \n { \n AVPacket pkt1 , * pkt = & pkt1 ; \n int ret ; \n AVStream * st ; \n st = s -> streams [ 0 ] ; \n av_read_frame_flush ( s ) ; \n url_fseek ( & s -> pb , s -> data_offset , SEEK_SET ) ; \n for ( ; ; ) { \n ret = av_read_frame ( s , pkt ) ; \n if ( ret < 0 ) \n break ; \n if ( pkt -> stream_index == 0 && st -> parser && \n ( pkt -> flags & PKT_FLAG_KEY ) ) { \n add_index_entry ( st , st -> parser -> frame_offset , pkt -> dts , \n AVINDEX_KEYFRAME ) ; \n } \n av_free_packet ( pkt ) ; \n } \n }", "idx": 23161}
{"project": "FFmpeg", "commit_id": "dbc1163b203b175d246b7454c32ac176f84006d1", "target": 0, "func": "static inline int decode_ac_coeffs ( GetBitContext * gb , int16_t * out , \n int blocks_per_slice , \n int plane_size_factor , \n const uint8_t * scan ) \n { \n int pos , block_mask , run , level , sign , run_cb_index , lev_cb_index ; \n int max_coeffs , bits_left ; \n run = 4 ; \n level = 2 ; \n max_coeffs = blocks_per_slice << 6 ; \n block_mask = blocks_per_slice - 1 ; \n for ( pos = blocks_per_slice - 1 ; pos < max_coeffs ; ) { \n run_cb_index = ff_prores_run_to_cb_index [ FFMIN ( run , 15 ) ] ; \n lev_cb_index = ff_prores_lev_to_cb_index [ FFMIN ( level , 9 ) ] ; \n bits_left = get_bits_left ( gb ) ; \n if ( bits_left <= 0 || ( bits_left <= 8 && ! show_bits ( gb , bits_left ) ) ) \n return 0 ; \n run = decode_vlc_codeword ( gb , ff_prores_ac_codebook [ run_cb_index ] ) ; \n if ( run < 0 ) \n return AVERROR_INVALIDDATA ; \n bits_left = get_bits_left ( gb ) ; \n if ( bits_left <= 0 || ( bits_left <= 8 && ! show_bits ( gb , bits_left ) ) ) \n return AVERROR_INVALIDDATA ; \n level = decode_vlc_codeword ( gb , ff_prores_ac_codebook [ lev_cb_index ] ) + 1 ; \n if ( level < 0 ) \n return AVERROR_INVALIDDATA ; \n pos += run + 1 ; \n if ( pos >= max_coeffs ) \n break ; \n sign = get_sbits ( gb , 1 ) ; \n out [ ( ( pos & block_mask ) << 6 ) + scan [ pos >> plane_size_factor ] ] = \n ( level ^ sign ) - sign ; \n } \n return 0 ; \n }", "idx": 23184}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME ( yuv422ptoyuy2 ) ( const uint8_t * ysrc , const uint8_t * usrc , const uint8_t * vsrc , uint8_t * dst , \n long width , long height , \n long lumStride , long chromStride , long dstStride ) \n { \n RENAME ( yuvPlanartoyuy2 ) ( ysrc , usrc , vsrc , dst , width , height , lumStride , chromStride , dstStride , 1 ) ; \n }", "idx": 23250}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , \n uint32_t length ) \n { \n int v , i ; \n if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { \n if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < length ; i ++ ) { \n v = bytestream2_get_byte ( & s -> gb ) ; \n s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; \n } \n } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { \n if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || \n ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) \n return AVERROR_INVALIDDATA ; \n for ( i = 0 ; i < length / 2 ; i ++ ) { \n v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; \n if ( s -> bit_depth > 8 ) \n AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; \n else \n s -> transparent_color_be [ i ] = v ; \n } \n } else { \n return AVERROR_INVALIDDATA ; \n } \n bytestream2_skip ( & s -> gb , 4 ) ; \n s -> has_trns = 1 ; \n return 0 ; \n }", "idx": 23309}
{"project": "FFmpeg", "commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "target": 1, "func": "static inline int wv_get_value_integer ( WavpackFrameContext * s , uint32_t * crc , \n int S ) \n { \n unsigned bit ; \n if ( s -> extra_bits ) { \n S <<= s -> extra_bits ; \n if ( s -> got_extra_bits && \n get_bits_left ( & s -> gb_extra_bits ) >= s -> extra_bits ) { \n S |= get_bits_long ( & s -> gb_extra_bits , s -> extra_bits ) ; \n * crc = * crc * 9 + ( S & 0xffff ) * 3 + ( ( unsigned ) S >> 16 ) ; \n } \n } \n bit = ( S & s -> and ) | s -> or ; \n bit = ( ( S + bit ) << s -> shift ) - bit ; \n if ( s -> hybrid ) \n bit = av_clip ( bit , s -> hybrid_minclip , s -> hybrid_maxclip ) ; \n return bit << s -> post_shift ; \n }", "idx": 23323}
{"project": "FFmpeg", "commit_id": "289520fd97395ffd5bf933ac80487e858bc4039d", "target": 0, "func": "static int load_matrix ( MpegEncContext * s , uint16_t matrix0 [ 64 ] , uint16_t matrix1 [ 64 ] , int intra ) \n { \n int i ; \n for ( i = 0 ; i < 64 ; i ++ ) { \n int j = s -> dsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; \n int v = get_bits ( & s -> gb , 8 ) ; \n if ( v == 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( intra && i == 0 && v != 8 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , v ) ; \n v = 8 ; \n } \n matrix0 [ j ] = v ; \n if ( matrix1 ) \n matrix1 [ j ] = v ; \n } \n return 0 ; \n }", "idx": 23344}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int copy_from ( IpvideoContext * s , AVFrame * src , AVFrame * dst , int delta_x , int delta_y ) \n { \n int current_offset = s -> pixel_ptr - dst -> data [ 0 ] ; \n int motion_offset = current_offset + delta_y * dst -> linesize [ 0 ] \n + delta_x * ( 1 + s -> is_16bpp ) ; \n if ( motion_offset < 0 ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , motion_offset ) ; \n return AVERROR_INVALIDDATA ; \n } else if ( motion_offset > s -> upper_motion_limit_offset ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" , \n motion_offset , s -> upper_motion_limit_offset ) ; \n return AVERROR_INVALIDDATA ; \n } \n if ( src -> data [ 0 ] == NULL ) { \n av_log ( s -> avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( EINVAL ) ; \n } \n s -> hdsp . put_pixels_tab [ ! s -> is_16bpp ] [ 0 ] ( s -> pixel_ptr , src -> data [ 0 ] + motion_offset , \n dst -> linesize [ 0 ] , 8 ) ; \n return 0 ; \n }", "idx": 23361}
{"project": "FFmpeg", "commit_id": "b3f9f7a33337e9b64e6044b0010e2722fa0b2f9c", "target": 0, "func": "static PESContext * add_pes_stream ( MpegTSContext * ts , int pid , int pcr_pid , int stream_type ) \n { \n MpegTSFilter * tss ; \n PESContext * pes ; \n pes = av_mallocz ( sizeof ( PESContext ) ) ; \n if ( ! pes ) \n return 0 ; \n pes -> ts = ts ; \n pes -> stream = ts -> stream ; \n pes -> pid = pid ; \n pes -> pcr_pid = pcr_pid ; \n pes -> stream_type = stream_type ; \n pes -> state = MPEGTS_SKIP ; \n pes -> pts = AV_NOPTS_VALUE ; \n pes -> dts = AV_NOPTS_VALUE ; \n tss = mpegts_open_pes_filter ( ts , pid , mpegts_push_data , pes ) ; \n if ( ! tss ) { \n av_free ( pes ) ; \n return 0 ; \n } \n return pes ; \n }", "idx": 23425}
{"project": "FFmpeg", "commit_id": "dde0af2df1caffb9e33855c08fc691dbbbbc72b3", "target": 0, "func": "static int vble_unpack ( VBLEContext * ctx , GetBitContext * gb ) \n { \n int i ; \n static const uint8_t LUT [ 256 ] = { \n 8 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 6 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 7 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 6 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n 5 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 4 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 1 , 0 , \n } ; \n for ( i = 0 ; i < ctx -> size ; i ++ ) { \n int val = show_bits ( gb , 8 ) ; \n if ( val ) { \n val = LUT [ val ] ; \n skip_bits ( gb , val + 1 ) ; \n ctx -> len [ i ] = val ; \n } else { \n skip_bits ( gb , 8 ) ; \n if ( ! get_bits1 ( gb ) ) \n return -1 ; \n ctx -> len [ i ] = 8 ; \n } \n } \n memset ( ctx -> val , 0 , ctx -> size ) ; \n for ( i = 0 ; i < ctx -> size ; i ++ ) { \n if ( get_bits_left ( gb ) < ctx -> len [ i ] ) \n return -1 ; \n if ( ctx -> len [ i ] ) \n ctx -> val [ i ] = ( 1 << ctx -> len [ i ] ) + get_bits ( gb , ctx -> len [ i ] ) - 1 ; \n } \n return 0 ; \n }", "idx": 23465}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "int ffurl_alloc ( URLContext * * puc , const char * filename , int flags , \n const AVIOInterruptCB * int_cb ) \n { \n URLProtocol * up = NULL ; \n char proto_str [ 128 ] , proto_nested [ 128 ] , * ptr ; \n size_t proto_len = strspn ( filename , URL_SCHEME_CHARS ) ; \n if ( filename [ proto_len ] != ' ' || is_dos_path ( filename ) ) \n strcpy ( proto_str , \" \" ) ; \n else \n av_strlcpy ( proto_str , filename , \n FFMIN ( proto_len + 1 , sizeof ( proto_str ) ) ) ; \n av_strlcpy ( proto_nested , proto_str , sizeof ( proto_nested ) ) ; \n if ( ( ptr = strchr ( proto_nested , ' ' ) ) ) \n * ptr = ' \\0 ' ; \n while ( up = ffurl_protocol_next ( up ) ) { \n if ( ! strcmp ( proto_str , up -> name ) ) \n return url_alloc_for_protocol ( puc , up , filename , flags , int_cb ) ; \n if ( up -> flags & URL_PROTOCOL_FLAG_NESTED_SCHEME && \n ! strcmp ( proto_nested , up -> name ) ) \n return url_alloc_for_protocol ( puc , up , filename , flags , int_cb ) ; \n } \n * puc = NULL ; \n return AVERROR_PROTOCOL_NOT_FOUND ; \n }", "idx": 23470}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_get_buffer ( AVCodecContext * s , AVFrame * frame , int flags ) \n { \n InputStream * ist = s -> opaque ; \n DXVA2Context * ctx = ist -> hwaccel_ctx ; \n return av_hwframe_get_buffer ( ctx -> hw_frames_ctx , frame , 0 ) ; \n }", "idx": 23560}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_h_weak_loop_filter ( uint8_t * src , const int stride , \n const int filter_p1 , const int filter_q1 , \n const int alpha , const int beta , \n const int lim_p0q0 , const int lim_q1 , \n const int lim_p1 ) \n { \n rv40_weak_loop_filter ( src , stride , 1 , filter_p1 , filter_q1 , \n alpha , beta , lim_p0q0 , lim_q1 , lim_p1 ) ; \n }", "idx": 23627}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int do_bit_allocation ( AC3DecodeContext * ctx , int flags ) \n { \n ac3_audio_block * ab = & ctx -> audio_block ; \n int i , snroffst = 0 ; \n if ( ! flags ) \n return 0 ; \n if ( ab -> flags & AC3_AB_SNROFFSTE ) { \n snroffst += ab -> csnroffst ; \n if ( ab -> flags & AC3_AB_CPLINU ) \n snroffst += ab -> cplfsnroffst ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n snroffst += ab -> fsnroffst [ i ] ; \n if ( ctx -> bsi . flags & AC3_BSI_LFEON ) \n snroffst += ab -> lfefsnroffst ; \n if ( ! snroffst ) { \n memset ( ab -> cplbap , 0 , sizeof ( ab -> cplbap ) ) ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n memset ( ab -> bap [ i ] , 0 , sizeof ( ab -> bap [ i ] ) ) ; \n memset ( ab -> lfebap , 0 , sizeof ( ab -> lfebap ) ) ; \n return 0 ; \n } \n } \n if ( ( ab -> flags & AC3_AB_CPLINU ) && ( flags & 64 ) ) \n if ( _do_bit_allocation ( ctx , 5 ) ) \n return -1 ; \n for ( i = 0 ; i < ctx -> bsi . nfchans ; i ++ ) \n if ( flags & ( 1 << i ) ) \n if ( _do_bit_allocation ( ctx , i ) ) \n return -1 ; \n if ( ( ctx -> bsi . flags & AC3_BSI_LFEON ) && ( flags & 32 ) ) \n if ( _do_bit_allocation ( ctx , 6 ) ) \n return -1 ; \n return 0 ; \n }", "idx": 23668}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_mono ( float * samples ) \n { \n int i ; \n for ( i = 0 ; i < 256 ; i ++ ) { \n samples [ i ] += ( samples [ i + 256 ] + samples [ i + 512 ] + samples [ i + 768 ] ) ; \n samples [ i + 256 ] = samples [ i + 512 ] = samples [ i + 768 ] = 0 ; \n } \n }", "idx": 23704}
{"project": "FFmpeg", "commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "target": 1, "func": "int av_image_check_sar ( unsigned int w , unsigned int h , AVRational sar ) \n { \n int64_t scaled_dim ; \n if ( ! sar . den ) \n return AVERROR ( EINVAL ) ; \n if ( ! sar . num || sar . num == sar . den ) \n return 0 ; \n if ( sar . num < sar . den ) \n scaled_dim = av_rescale_rnd ( w , sar . num , sar . den , AV_ROUND_ZERO ) ; \n else \n scaled_dim = av_rescale_rnd ( h , sar . den , sar . num , AV_ROUND_ZERO ) ; \n if ( scaled_dim > 0 ) \n return 0 ; \n return AVERROR ( EINVAL ) ; \n }", "idx": 23762}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_gray_bitstream ( HYuvContext * s , int count ) \n { \n int i ; \n OPEN_READER ( re , & s -> gb ) ; \n count /= 2 ; \n if ( count >= ( get_bits_left ( & s -> gb ) ) / ( 32 * 2 ) ) { \n for ( i = 0 ; i < count && get_bits_left ( & s -> gb ) > 0 ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , 0 ) ; \n } \n } else { \n for ( i = 0 ; i < count ; i ++ ) { \n READ_2PIX ( s -> temp [ 0 ] [ 2 * i ] , s -> temp [ 0 ] [ 2 * i + 1 ] , 0 ) ; \n } \n } \n CLOSE_READER ( re , & s -> gb ) ; \n }", "idx": 23769}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int ( int x , int y , Jpeg2000Cblk * cblk , \n Jpeg2000Component * comp , \n Jpeg2000T1Context * t1 , Jpeg2000Band * band ) \n { \n int i , j ; \n int w = cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] ; \n for ( j = 0 ; j < ( cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] ) ; ++ j ) { \n int32_t * datap = & comp -> i_data [ ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( y + j ) + x ] ; \n int * src = t1 -> data [ j ] ; \n if ( band -> i_stepsize == 16384 ) { \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = src [ i ] / 2 ; \n } else { \n for ( i = 0 ; i < w ; ++ i ) \n datap [ i ] = ( src [ i ] * ( int64_t ) band -> i_stepsize ) / 32768 ; \n } \n } \n }", "idx": 23854}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "static void rdft_calc_c ( RDFTContext * s , FFTSample * data ) \n { \n int i , i1 , i2 ; \n FFTComplex ev , od ; \n const int n = 1 << s -> nbits ; \n const float k1 = 0.5 ; \n const float k2 = 0.5 - s -> inverse ; \n const FFTSample * tcos = s -> tcos ; \n const FFTSample * tsin = s -> tsin ; \n if ( ! s -> inverse ) { \n s -> fft . fft_permute ( & s -> fft , ( FFTComplex * ) data ) ; \n s -> fft . fft_calc ( & s -> fft , ( FFTComplex * ) data ) ; \n } \n ev . re = data [ 0 ] ; \n data [ 0 ] = ev . re + data [ 1 ] ; \n data [ 1 ] = ev . re - data [ 1 ] ; \n for ( i = 1 ; i < ( n >> 2 ) ; i ++ ) { \n i1 = 2 * i ; \n i2 = n - i1 ; \n ev . re = k1 * ( data [ i1 ] + data [ i2 ] ) ; \n od . im = - k2 * ( data [ i1 ] - data [ i2 ] ) ; \n ev . im = k1 * ( data [ i1 + 1 ] - data [ i2 + 1 ] ) ; \n od . re = k2 * ( data [ i1 + 1 ] + data [ i2 + 1 ] ) ; \n data [ i1 ] = ev . re + od . re * tcos [ i ] - od . im * tsin [ i ] ; \n data [ i1 + 1 ] = ev . im + od . im * tcos [ i ] + od . re * tsin [ i ] ; \n data [ i2 ] = ev . re - od . re * tcos [ i ] + od . im * tsin [ i ] ; \n data [ i2 + 1 ] = - ev . im + od . im * tcos [ i ] + od . re * tsin [ i ] ; \n } \n data [ 2 * i + 1 ] = s -> sign_convention * data [ 2 * i + 1 ] ; \n if ( s -> inverse ) { \n data [ 0 ] *= k1 ; \n data [ 1 ] *= k1 ; \n s -> fft . fft_permute ( & s -> fft , ( FFTComplex * ) data ) ; \n s -> fft . fft_calc ( & s -> fft , ( FFTComplex * ) data ) ; \n } \n }", "idx": 23872}
{"project": "FFmpeg", "commit_id": "aca490777f9da2a71b537874ed4e16105bb3df02", "target": 0, "func": "static av_cold int g726_init ( AVCodecContext * avctx ) \n { \n AVG726Context * c = ( AVG726Context * ) avctx -> priv_data ; \n unsigned int index = ( avctx -> bit_rate + avctx -> sample_rate / 2 ) / avctx -> sample_rate - 2 ; \n if ( \n ( avctx -> bit_rate != 16000 && avctx -> bit_rate != 24000 && \n avctx -> bit_rate != 32000 && avctx -> bit_rate != 40000 ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_rate != 8000 && avctx -> strict_std_compliance > FF_COMPLIANCE_INOFFICIAL ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> channels != 1 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( index > 3 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" , index + 2 ) ; \n return -1 ; \n } \n g726_reset ( & c -> c , index ) ; \n c -> code_size = c -> c . tbls -> bits ; \n c -> bit_buffer = 0 ; \n c -> bits_left = 0 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n if ( ! avctx -> coded_frame ) \n return AVERROR ( ENOMEM ) ; \n avctx -> coded_frame -> key_frame = 1 ; \n return 0 ; \n }", "idx": 23877}
{"project": "FFmpeg", "commit_id": "48e52e4edd12adbc36eee0eebe1b97ffe0255be3", "target": 0, "func": "static int nvenc_find_free_reg_resource ( AVCodecContext * avctx ) \n { \n NvencContext * ctx = avctx -> priv_data ; \n NvencDynLoadFunctions * dl_fn = & ctx -> nvenc_dload_funcs ; \n NV_ENCODE_API_FUNCTION_LIST * p_nvenc = & dl_fn -> nvenc_funcs ; \n int i ; \n if ( ctx -> nb_registered_frames == FF_ARRAY_ELEMS ( ctx -> registered_frames ) ) { \n for ( i = 0 ; i < ctx -> nb_registered_frames ; i ++ ) { \n if ( ! ctx -> registered_frames [ i ] . mapped ) { \n if ( ctx -> registered_frames [ i ] . regptr ) { \n p_nvenc -> nvEncUnregisterResource ( ctx -> nvencoder , \n ctx -> registered_frames [ i ] . regptr ) ; \n ctx -> registered_frames [ i ] . regptr = NULL ; \n } \n return i ; \n } \n } \n } else { \n return ctx -> nb_registered_frames ++ ; \n } \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 24072}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_connect ( URLContext * uc , AVDictionary * * options ) \n { \n int err = \n uc -> prot -> url_open2 ? uc -> prot -> url_open2 ( uc , \n uc -> filename , \n uc -> flags , \n options ) : \n uc -> prot -> url_open ( uc , uc -> filename , uc -> flags ) ; \n if ( err ) \n return err ; \n uc -> is_connected = 1 ; \n if ( ( uc -> flags & AVIO_FLAG_WRITE ) || ! strcmp ( uc -> prot -> name , \" \" ) ) \n if ( ! uc -> is_streamed && ffurl_seek ( uc , 0 , SEEK_SET ) < 0 ) \n uc -> is_streamed = 1 ; \n return 0 ; \n }", "idx": 24205}
{"project": "FFmpeg", "commit_id": "9745f19ffc9031ce480e43d7cf1053b58100d70f", "target": 0, "func": "static av_cold int ass_decode_init ( AVCodecContext * avctx ) \n { \n avctx -> subtitle_header = av_malloc ( avctx -> extradata_size ) ; \n if ( ! avctx -> extradata ) \n return AVERROR ( ENOMEM ) ; \n memcpy ( avctx -> subtitle_header , avctx -> extradata , avctx -> extradata_size ) ; \n avctx -> subtitle_header_size = avctx -> extradata_size ; \n return 0 ; \n }", "idx": 24269}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_h_loop_filter_simple_c ( uint8_t * dst , ptrdiff_t stride , int flim ) \n { \n int i ; \n for ( i = 0 ; i < 16 ; i ++ ) \n if ( simple_limit ( dst + i * stride , 1 , flim ) ) \n filter_common ( dst + i * stride , 1 , 1 ) ; \n }", "idx": 24291}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pam_encode_close ( AVCodecContext * avctx ) \n { \n av_frame_free ( & avctx -> coded_frame ) ; \n return 0 ; \n }", "idx": 24371}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_init_encoder ( vorbis_info * vi , AVCodecContext * avccontext ) \n { \n OggVorbisContext * context = avccontext -> priv_data ; \n double cfreq ; \n if ( avccontext -> flags & CODEC_FLAG_QSCALE ) { \n if ( vorbis_encode_setup_vbr ( vi , avccontext -> channels , \n avccontext -> sample_rate , \n avccontext -> global_quality / ( float ) FF_QP2LAMBDA / 10.0 ) ) \n return -1 ; \n } else { \n int minrate = avccontext -> rc_min_rate > 0 ? avccontext -> rc_min_rate : -1 ; \n int maxrate = avccontext -> rc_min_rate > 0 ? avccontext -> rc_max_rate : -1 ; \n if ( vorbis_encode_setup_managed ( vi , avccontext -> channels , \n avccontext -> sample_rate , minrate , \n avccontext -> bit_rate , maxrate ) ) \n return -1 ; \n if ( minrate == -1 && maxrate == -1 ) \n if ( vorbis_encode_ctl ( vi , OV_ECTL_RATEMANAGE2_SET , NULL ) ) \n return -1 ; \n } \n if ( avccontext -> cutoff > 0 ) { \n cfreq = avccontext -> cutoff / 1000.0 ; \n if ( vorbis_encode_ctl ( vi , OV_ECTL_LOWPASS_SET , & cfreq ) ) \n return -1 ; \n } \n if ( context -> iblock ) { \n vorbis_encode_ctl ( vi , OV_ECTL_IBLOCK_SET , & context -> iblock ) ; \n } \n return vorbis_encode_setup_init ( vi ) ; \n }", "idx": 24375}
{"project": "FFmpeg", "commit_id": "439c3d5bcc4a4560eaf5fd43c6e156e3d9bc42f2", "target": 1, "func": "static int encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , \n const AVFrame * frame , int * got_packet_ptr ) \n { \n NellyMoserEncodeContext * s = avctx -> priv_data ; \n int ret ; \n if ( s -> last_frame ) \n return 0 ; \n memcpy ( s -> buf , s -> buf + NELLY_SAMPLES , NELLY_BUF_LEN * sizeof ( * s -> buf ) ) ; \n if ( frame ) { \n memcpy ( s -> buf + NELLY_BUF_LEN , frame -> data [ 0 ] , \n frame -> nb_samples * sizeof ( * s -> buf ) ) ; \n if ( frame -> nb_samples < NELLY_SAMPLES ) { \n memset ( s -> buf + NELLY_BUF_LEN + avctx -> frame_size , 0 , \n ( NELLY_SAMPLES - frame -> nb_samples ) * sizeof ( * s -> buf ) ) ; \n if ( frame -> nb_samples >= NELLY_BUF_LEN ) \n s -> last_frame = 1 ; \n } \n if ( ( ret = ff_af_queue_add ( & s -> afq , frame ) < 0 ) ) \n return ret ; \n } else { \n memset ( s -> buf + NELLY_BUF_LEN , 0 , NELLY_SAMPLES * sizeof ( * s -> buf ) ) ; \n s -> last_frame = 1 ; \n } \n if ( ( ret = ff_alloc_packet ( avpkt , NELLY_BLOCK_LEN ) ) ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return ret ; \n } \n encode_block ( s , avpkt -> data , avpkt -> size ) ; \n ff_af_queue_remove ( & s -> afq , avctx -> frame_size , & avpkt -> pts , \n & avpkt -> duration ) ; \n * got_packet_ptr = 1 ; \n return 0 ; \n }", "idx": 24400}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "static char * check_nan_suffix ( char * s ) \n { \n char * start = s ; \n if ( * s ++ != ' ' ) \n return start ; \n while ( ( * s >= ' ' && * s <= ' ' ) || ( * s >= ' ' && * s <= ' ' ) || \n ( * s >= ' ' && * s <= ' ' ) || * s == ' ' ) \n s ++ ; \n return * s == ' ' ? s + 1 : start ; \n }", "idx": 24433}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void diff_bytes_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { \n long i ; \n #if ! HAVE_FAST_UNALIGNED  \n  \n  if ( ( long ) src2 & ( sizeof ( long ) -1 ) ) { \n for ( i = 0 ; i + 7 < w ; i += 8 ) { \n dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; \n dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; \n dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; \n dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; \n dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; \n dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; \n dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; \n dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; \n } \n } else \n #endif \n for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { \n long a = * ( long * ) ( src1 + i ) ; \n long b = * ( long * ) ( src2 + i ) ; \n * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; \n } \n for ( ; i < w ; i ++ ) \n dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; \n }", "idx": 24472}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_filter_mb_fast ( const H264Context * h , H264SliceContext * sl , \n int mb_x , int mb_y , uint8_t * img_y , \n uint8_t * img_cb , uint8_t * img_cr , \n unsigned int linesize , unsigned int uvlinesize ) \n { \n assert ( ! FRAME_MBAFF ( h ) ) ; \n if ( ! h -> h264dsp . h264_loop_filter_strength || h -> pps . chroma_qp_diff ) { \n ff_h264_filter_mb ( h , sl , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize ) ; \n return ; \n } \n #if CONFIG_SMALL  \n  \n  h264_filter_mb_fast_internal ( h , sl , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize , h -> pixel_shift ) ; \n #else \n if ( h -> pixel_shift ) { \n h264_filter_mb_fast_internal ( h , sl , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize , 1 ) ; \n } else { \n h264_filter_mb_fast_internal ( h , sl , mb_x , mb_y , img_y , img_cb , img_cr , linesize , uvlinesize , 0 ) ; \n } \n #endif \n }", "idx": 24488}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC ( pred8x8_left_dc ) ( uint8_t * _src , int stride ) { \n int i ; \n int dc0 , dc2 ; \n pixel4 dc0splat , dc2splat ; \n pixel * src = ( pixel * ) _src ; \n stride /= sizeof ( pixel ) ; \n dc0 = dc2 = 0 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n dc0 += src [ -1 + i * stride ] ; \n dc2 += src [ -1 + ( i + 4 ) * stride ] ; \n } \n dc0splat = PIXEL_SPLAT_X4 ( ( dc0 + 2 ) >> 2 ) ; \n dc2splat = PIXEL_SPLAT_X4 ( ( dc2 + 2 ) >> 2 ) ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc0splat ; \n } \n for ( i = 4 ; i < 8 ; i ++ ) { \n ( ( pixel4 * ) ( src + i * stride ) ) [ 0 ] = \n ( ( pixel4 * ) ( src + i * stride ) ) [ 1 ] = dc2splat ; \n } \n }", "idx": 24621}
{"project": "FFmpeg", "commit_id": "48aecf5a7dd8e914d44cb4210a09172dbd8d5d86", "target": 1, "func": "static void alloc_and_copy ( uint8_t * * poutbuf , int * poutbuf_size , \n const uint8_t * sps_pps , uint32_t sps_pps_size , \n const uint8_t * in , uint32_t in_size ) { \n uint32_t offset = * poutbuf_size ; \n uint8_t nal_header_size = offset ? 3 : 4 ; \n * poutbuf_size += sps_pps_size + in_size + nal_header_size ; \n * poutbuf = av_realloc ( * poutbuf , * poutbuf_size ) ; \n if ( sps_pps ) \n memcpy ( * poutbuf + offset , sps_pps , sps_pps_size ) ; \n memcpy ( * poutbuf + sps_pps_size + nal_header_size + offset , in , in_size ) ; \n if ( ! offset ) \n AV_WB32 ( * poutbuf + sps_pps_size , 1 ) ; \n else { \n ( * poutbuf + offset ) [ 0 ] = ( * poutbuf + offset ) [ 1 ] = 0 ; \n ( * poutbuf + offset ) [ 2 ] = 1 ; \n } \n }", "idx": 24625}
{"project": "FFmpeg", "commit_id": "40ad05bab206c932a32171d45581080c914b06ec", "target": 0, "func": "int float_near_ulp ( float a , float b , unsigned max_ulp ) \n { \n union av_intfloat32 x , y ; \n x . f = a ; \n y . f = b ; \n if ( is_negative ( x ) != is_negative ( y ) ) { \n return a == b ; \n } \n if ( abs ( x . i - y . i ) <= max_ulp ) \n return 1 ; \n return 0 ; \n }", "idx": 24629}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int roq_dpcm_encode_init ( AVCodecContext * avctx ) \n { \n ROQDPCMContext * context = avctx -> priv_data ; \n if ( avctx -> channels > 2 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_rate != 22050 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n if ( avctx -> sample_fmt != AV_SAMPLE_FMT_S16 ) { \n av_log ( avctx , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n avctx -> frame_size = ROQ_FIRST_FRAME_SIZE ; \n context -> lastSample [ 0 ] = context -> lastSample [ 1 ] = 0 ; \n avctx -> coded_frame = avcodec_alloc_frame ( ) ; \n return 0 ; \n }", "idx": 24631}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void ff_wmv2_idct_put_c ( uint8_t * dest , int line_size , DCTELEM * block ) \n { \n ff_wmv2_idct_c ( block ) ; \n put_pixels_clamped_c ( block , dest , line_size ) ; \n }", "idx": 24668}
{"project": "FFmpeg", "commit_id": "93c39db5f1544d1220488cfeb93bfe812a52f374", "target": 1, "func": "static int aiff_read_packet ( AVFormatContext * s , \n AVPacket * pkt ) \n { \n AVStream * st = s -> streams [ 0 ] ; \n AIFFInputContext * aiff = s -> priv_data ; \n int64_t max_size ; \n int res , size ; \n max_size = aiff -> data_end - avio_tell ( s -> pb ) ; \n if ( max_size <= 0 ) \n return AVERROR_EOF ; \n switch ( st -> codecpar -> codec_id ) { \n case AV_CODEC_ID_ADPCM_IMA_QT : \n case AV_CODEC_ID_GSM : \n case AV_CODEC_ID_QDM2 : \n case AV_CODEC_ID_QCELP : \n size = st -> codecpar -> block_align ; \n break ; \n default : \n size = st -> codecpar -> block_align ? ( MAX_SIZE / st -> codecpar -> block_align ) * st -> codecpar -> block_align : MAX_SIZE ; \n size = FFMIN ( max_size , size ) ; \n res = av_get_packet ( s -> pb , pkt , size ) ; \n if ( res < 0 ) \n return res ; \n if ( size >= st -> codecpar -> block_align ) \n pkt -> flags &= ~ AV_PKT_FLAG_CORRUPT ; \n pkt -> stream_index = 0 ; \n pkt -> duration = ( res / st -> codecpar -> block_align ) * aiff -> block_duration ; \n return 0 ;", "idx": 24732}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter ( float * out , float * in , int order , int direction , \n float * tns_coefs , int ltp_used , int w , int filt , \n int start_i , int len ) \n { \n int i , j , inc , start = start_i ; \n float tmp [ TNS_MAX_ORDER + 1 ] ; \n if ( direction ) { \n inc = -1 ; \n start = ( start + len ) - 1 ; \n } else { \n inc = 1 ; \n } \n if ( ! ltp_used ) { \n for ( i = 0 ; i < len ; i ++ , start += inc ) \n out [ i ] = in [ start ] ; \n for ( j = 1 ; j <= FFMIN ( i , order ) ; j ++ ) \n out [ i ] += tns_coefs [ j ] * in [ start - j * inc ] ; \n } else { \n for ( i = 0 ; i < len ; i ++ , start += inc ) { \n tmp [ 0 ] = out [ i ] = in [ start ] ; \n for ( j = 1 ; j <= FFMIN ( i , order ) ; j ++ ) \n out [ i ] += tmp [ j ] * tns_coefs [ j ] ; \n for ( j = order ; j > 0 ; j -- ) \n tmp [ j ] = tmp [ j - 1 ] ; \n } \n } \n }", "idx": 24761}
{"project": "FFmpeg", "commit_id": "ce19aec15b4291dc48e791d89a1f940babc22cdc", "target": 0, "func": "const uint8_t * ff_h263_find_resync_marker ( const uint8_t * av_restrict p , const uint8_t * av_restrict end ) \n { \n av_assert2 ( p < end ) ; \n end -= 2 ; \n p ++ ; \n for ( ; p < end ; p += 2 ) { \n if ( ! * p ) { \n if ( ! p [ -1 ] && p [ 1 ] ) return p - 1 ; \n else if ( ! p [ 1 ] && p [ 2 ] ) return p ; \n } \n } \n return end + 2 ; \n }", "idx": 24829}
{"project": "FFmpeg", "commit_id": "39e0accb7a934bfe3d42324b016dd8790790746d", "target": 1, "func": "static unsigned int find_best ( struct vf_instance * vf ) { \n int is_format_okay = vf -> next -> query_format ( vf -> next , IMGFMT_YV12 ) ; \n if ( ( is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW ) || ( is_format_okay & VFCAP_CSP_SUPPORTED ) ) \n return IMGFMT_YV12 ; \n else \n return 0 ; \n }", "idx": 25066}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int fourxm_probe ( AVProbeData * p ) \n { \n if ( p -> buf_size < 12 ) \n return 0 ; \n if ( ( AV_RL32 ( & p -> buf [ 0 ] ) != RIFF_TAG ) || \n ( AV_RL32 ( & p -> buf [ 8 ] ) != _4XMV_TAG ) ) \n return 0 ; \n return AVPROBE_SCORE_MAX ; \n }", "idx": 25091}
{"project": "FFmpeg", "commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "target": 1, "func": "static int aac_sync ( uint64_t state , AACAC3ParseContext * hdr_info , \n int * need_next_header , int * new_frame_start ) \n { \n GetBitContext bits ; \n AACADTSHeaderInfo hdr ; \n int size ; \n union { \n uint64_t u64 ; \n uint8_t u8 [ 8 ] ; \n } tmp ; \n tmp . u64 = av_be2ne64 ( state ) ; \n init_get_bits ( & bits , tmp . u8 + 8 - AAC_ADTS_HEADER_SIZE , AAC_ADTS_HEADER_SIZE * 8 ) ; \n if ( ( size = avpriv_aac_parse_header ( & bits , & hdr ) ) < 0 ) \n return 0 ; \n * need_next_header = 0 ; \n * new_frame_start = 1 ; \n hdr_info -> sample_rate = hdr . sample_rate ; \n hdr_info -> channels = ff_mpeg4audio_channels [ hdr . chan_config ] ; \n hdr_info -> samples = hdr . samples ; \n hdr_info -> bit_rate = hdr . bit_rate ; \n return size ; \n }", "idx": 25130}
{"project": "FFmpeg", "commit_id": "b86651a208ee67666a7305b002bc9f14b21dae7f", "target": 1, "func": "static av_cold int rv40_decode_init ( AVCodecContext * avctx ) \n { \n RV34DecContext * r = avctx -> priv_data ; \n r -> rv30 = 0 ; \n ff_rv34_decode_init ( avctx ) ; \n if ( ! aic_top_vlc . bits ) \n rv40_init_tables ( ) ; \n r -> parse_slice_header = rv40_parse_slice_header ; \n r -> decode_intra_types = rv40_decode_intra_types ; \n r -> decode_mb_info = rv40_decode_mb_info ; \n r -> loop_filter = rv40_loop_filter ; \n r -> luma_dc_quant_i = rv40_luma_dc_quant [ 0 ] ; \n r -> luma_dc_quant_p = rv40_luma_dc_quant [ 1 ] ; \n return 0 ; \n }", "idx": 25149}
{"project": "FFmpeg", "commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "target": 1, "func": "static void FUNC ( put_hevc_epel_bi_w_h ) ( uint8_t * _dst , ptrdiff_t _dststride , uint8_t * _src , ptrdiff_t _srcstride , \n int16_t * src2 , \n int height , int denom , int wx0 , int wx1 , \n int ox0 , int ox1 , intptr_t mx , intptr_t my , int width ) \n { \n int x , y ; \n pixel * src = ( pixel * ) _src ; \n ptrdiff_t srcstride = _srcstride / sizeof ( pixel ) ; \n pixel * dst = ( pixel * ) _dst ; \n ptrdiff_t dststride = _dststride / sizeof ( pixel ) ; \n const int8_t * filter = ff_hevc_epel_filters [ mx - 1 ] ; \n int shift = 14 + 1 - BIT_DEPTH ; \n int log2Wd = denom + shift - 1 ; \n ox0 = ox0 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n ox1 = ox1 * ( 1 << ( BIT_DEPTH - 8 ) ) ; \n for ( y = 0 ; y < height ; y ++ ) { \n for ( x = 0 ; x < width ; x ++ ) \n dst [ x ] = av_clip_pixel ( ( ( EPEL_FILTER ( src , 1 ) >> ( BIT_DEPTH - 8 ) ) * wx1 + src2 [ x ] * wx0 + \n ( ( ox0 + ox1 + 1 ) << log2Wd ) ) >> ( log2Wd + 1 ) ) ; \n src += srcstride ; \n dst += dststride ; \n src2 += MAX_PB_SIZE ; \n } \n }", "idx": 25181}
{"project": "FFmpeg", "commit_id": "a7f27453f64d9020b92b01687baeb5909c6cdad0", "target": 0, "func": "static int mov_read_ares ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) \n { \n AVCodecContext * codec = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] -> codec ; \n if ( codec -> codec_tag == MKTAG ( ' ' , ' ' , ' ' , ' ' ) && \n codec -> codec_id == AV_CODEC_ID_H264 && \n atom . size > 11 ) { \n avio_skip ( pb , 10 ) ; \n if ( avio_rb16 ( pb ) == 0xd4d ) \n codec -> width = 1440 ; \n return 0 ; \n } \n return mov_read_avid ( c , pb , atom ) ; \n }", "idx": 25357}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_read_packet ( AVFormatContext * s , AVPacket * pkt ) \n { \n LibQuviContext * qc = s -> priv_data ; \n return av_read_frame ( qc -> fmtctx , pkt ) ; \n }", "idx": 25501}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "AVFrame * avcodec_alloc_frame ( void ) \n { \n AVFrame * frame = av_mallocz ( sizeof ( AVFrame ) ) ; \n if ( frame == NULL ) \n return NULL ; \n FF_DISABLE_DEPRECATION_WARNINGS \n avcodec_get_frame_defaults ( frame ) ; \n FF_ENABLE_DEPRECATION_WARNINGS \n return frame ; \n }", "idx": 25526}
{"project": "FFmpeg", "commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "target": 1, "func": "static int add_hfyu_left_prediction_int16_c ( uint16_t * dst , const uint16_t * src , unsigned mask , int w , int acc ) { \n int i ; \n for ( i = 0 ; i < w - 1 ; i ++ ) { \n acc += src [ i ] ; \n dst [ i ] = acc & mask ; \n i ++ ; \n acc += src [ i ] ; \n dst [ i ] = acc & mask ; \n } \n for ( ; i < w ; i ++ ) { \n acc += src [ i ] ; \n dst [ i ] = acc & mask ; \n } \n return acc ; \n }", "idx": 25530}
{"project": "FFmpeg", "commit_id": "f57b00e89749b559da7cd99a4b630c90617e17d4", "target": 1, "func": "static const ID3v2EMFunc * get_extra_meta_func ( const char * tag , int isv34 ) \n { \n int i = 0 ; \n while ( ff_id3v2_extra_meta_funcs [ i ] . tag3 ) { \n if ( ! memcmp ( tag , \n ( isv34 ? \n ff_id3v2_extra_meta_funcs [ i ] . tag4 : \n ff_id3v2_extra_meta_funcs [ i ] . tag3 ) , \n ( isv34 ? 4 : 3 ) ) ) \n return & ff_id3v2_extra_meta_funcs [ i ] ; \n i ++ ; \n } \n return NULL ; \n }", "idx": 25557}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "int av_buffersrc_add_ref ( AVFilterContext * buffer_filter , \n AVFilterBufferRef * picref , int flags ) \n { \n BufferSourceContext * c = buffer_filter -> priv ; \n AVFilterBufferRef * buf ; \n int ret ; \n if ( ! picref ) { \n c -> eof = 1 ; \n return 0 ; \n } else if ( c -> eof ) \n return AVERROR ( EINVAL ) ; \n if ( ! av_fifo_space ( c -> fifo ) && \n ( ret = av_fifo_realloc2 ( c -> fifo , av_fifo_size ( c -> fifo ) + \n sizeof ( buf ) ) ) < 0 ) \n return ret ; \n if ( ! ( flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT ) ) { \n ret = check_format_change ( buffer_filter , picref ) ; \n if ( ret < 0 ) \n return ret ; \n } \n if ( flags & AV_BUFFERSRC_FLAG_NO_COPY ) \n buf = picref ; \n else \n buf = copy_buffer_ref ( buffer_filter , picref ) ; \n if ( ( ret = av_fifo_generic_write ( c -> fifo , & buf , sizeof ( buf ) , NULL ) ) < 0 ) { \n if ( buf != picref ) \n avfilter_unref_buffer ( buf ) ; \n return ret ; \n } \n c -> nb_failed_requests = 0 ; \n return 0 ; \n }", "idx": 25566}
{"project": "FFmpeg", "commit_id": "8be23d424feea50d4ee892cdbdd6abd9a807709f", "target": 0, "func": "static av_cold int roq_decode_init ( AVCodecContext * avctx ) \n { \n RoqContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n if ( avctx -> width % 16 || avctx -> height % 16 ) { \n av_log ( avctx , AV_LOG_ERROR , \n \" \\n \" ) ; \n return AVERROR_PATCHWELCOME ; \n } \n s -> width = avctx -> width ; \n s -> height = avctx -> height ; \n s -> last_frame = av_frame_alloc ( ) ; \n s -> current_frame = av_frame_alloc ( ) ; \n if ( ! s -> current_frame || ! s -> last_frame ) { \n av_frame_free ( & s -> current_frame ) ; \n av_frame_free ( & s -> last_frame ) ; \n return AVERROR ( ENOMEM ) ; \n } \n avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; \n return 0 ; \n }", "idx": 25593}
{"project": "FFmpeg", "commit_id": "204cb29b3c84a74cbcd059d353c70c8bdc567d98", "target": 1, "func": "static av_cold int shorten_decode_close ( AVCodecContext * avctx ) \n { \n ShortenContext * s = avctx -> priv_data ; \n int i ; \n for ( i = 0 ; i < s -> channels ; i ++ ) { \n s -> decoded [ i ] -= s -> nwrap ; \n av_freep ( & s -> decoded [ i ] ) ; \n av_freep ( & s -> offset [ i ] ) ; \n } \n av_freep ( & s -> bitstream ) ; \n av_freep ( & s -> coeffs ) ; \n return 0 ; \n }", "idx": 25672}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc13_msa ( uint8_t * dst , const uint8_t * src , \n ptrdiff_t stride ) \n { \n avc_luma_hv_qrt_and_aver_dst_4x4_msa ( src + stride - 2 , \n src - ( stride * 2 ) , \n stride , dst , stride ) ; \n }", "idx": 25693}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static void render_line ( int x0 , uint8_t y0 , int x1 , int y1 , float * buf ) \n { \n int dy = y1 - y0 ; \n int adx = x1 - x0 ; \n int ady = FFABS ( dy ) ; \n int sy = dy < 0 ? -1 : 1 ; \n buf [ x0 ] = ff_vorbis_floor1_inverse_db_table [ y0 ] ; \n if ( ady * 2 <= adx ) { \n render_line_unrolled ( x0 , y0 , x1 , sy , ady , adx , buf ) ; \n } else { \n int base = dy / adx ; \n int x = x0 ; \n uint8_t y = y0 ; \n int err = - adx ; \n ady -= FFABS ( base ) * adx ; \n while ( ++ x < x1 ) { \n y += base ; \n err += ady ; \n if ( err >= 0 ) { \n err -= adx ; \n y += sy ; \n } \n buf [ x ] = ff_vorbis_floor1_inverse_db_table [ y ] ; \n } \n } \n }", "idx": 25729}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static BufferPoolEntry * get_pool ( AVBufferPool * pool ) \n { \n BufferPoolEntry * cur = NULL , * last = NULL ; \n do { \n FFSWAP ( BufferPoolEntry * , cur , last ) ; \n cur = avpriv_atomic_ptr_cas ( ( void * volatile * ) & pool -> pool , last , NULL ) ; \n if ( ! cur ) \n return NULL ; \n } while ( cur != last ) ; \n return cur ; \n }", "idx": 25737}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static void switch_buffer ( MPADecodeContext * s , int * pos , int * end_pos , \n int * end_pos2 ) \n { \n if ( s -> in_gb . buffer && * pos >= s -> gb . size_in_bits ) { \n s -> gb = s -> in_gb ; \n s -> in_gb . buffer = NULL ; \n assert ( ( get_bits_count ( & s -> gb ) & 7 ) == 0 ) ; \n skip_bits_long ( & s -> gb , * pos - * end_pos ) ; \n * end_pos2 = \n * end_pos = * end_pos2 + get_bits_count ( & s -> gb ) - * pos ; \n * pos = get_bits_count ( & s -> gb ) ; \n } \n }", "idx": 25738}
{"project": "FFmpeg", "commit_id": "4ffe5e2aa5241f8da9afd2c8fbc854dcc916c5f9", "target": 1, "func": "static int read_old_huffman_tables ( HYuvContext * s ) { \n #if 1  \n  \n  GetBitContext gb ; \n int i ; \n init_get_bits ( & gb , classic_shift_luma , sizeof ( classic_shift_luma ) * 8 ) ; \n if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 ) \n return -1 ; \n init_get_bits ( & gb , classic_shift_chroma , sizeof ( classic_shift_chroma ) * 8 ) ; \n if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 ) \n return -1 ; \n for ( i = 0 ; i < 256 ; i ++ ) s -> bits [ 0 ] [ i ] = classic_add_luma [ i ] ; \n for ( i = 0 ; i < 256 ; i ++ ) s -> bits [ 1 ] [ i ] = classic_add_chroma [ i ] ; \n if ( s -> bitstream_bpp >= 24 ) { \n memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ) ; \n memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ) ; \n } \n memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ) ; \n memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ) ; \n for ( i = 0 ; i < 3 ; i ++ ) { \n ff_free_vlc ( & s -> vlc [ i ] ) ; \n init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ; \n } \n generate_joint_tables ( s ) ; \n return 0 ; \n #else \n av_log ( s -> avctx , AV_LOG_DEBUG , \" \\n \" ) ; \n return -1 ; \n #endif \n }", "idx": 25748}
{"project": "FFmpeg", "commit_id": "29d46d7bce1c67852e4c6e22605144eb32b21072", "target": 1, "func": "static void json_print_section_header ( WriterContext * wctx ) \n { \n JSONContext * json = wctx -> priv ; \n AVBPrint buf ; \n const struct section * section = wctx -> section [ wctx -> level ] ; \n const struct section * parent_section = wctx -> level ? \n wctx -> section [ wctx -> level - 1 ] : NULL ; \n if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) \n printf ( \" \\n \" ) ; \n if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { \n printf ( \" \\n \" ) ; \n json -> indent_level ++ ; \n } else { \n av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; \n json_escape_str ( & buf , section -> name , wctx ) ; \n JSON_INDENT ( ) ; \n json -> indent_level ++ ; \n if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { \n printf ( \" \\\" \\\" \\n \" , buf . str ) ; \n } else if ( ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { \n printf ( \" \\\" \\\" \" , buf . str , json -> item_start_end ) ; \n } else { \n printf ( \" \" , json -> item_start_end ) ; \n if ( parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { \n if ( ! json -> compact ) \n JSON_INDENT ( ) ; \n printf ( \" \\\" \\\" \\\" \\\" \" , section -> name , json -> item_sep ) ; \n } \n } \n av_bprint_finalize ( & buf , NULL ) ; \n } \n }", "idx": 25787}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "static int w64_read_header ( AVFormatContext * s , AVFormatParameters * ap ) \n { \n int64_t size ; \n AVIOContext * pb = s -> pb ; \n WAVContext * wav = s -> priv_data ; \n AVStream * st ; \n uint8_t guid [ 16 ] ; \n avio_read ( pb , guid , 16 ) ; \n if ( memcmp ( guid , guid_riff , 16 ) ) \n return -1 ; \n if ( avio_rl64 ( pb ) < 16 + 8 + 16 + 8 + 16 + 8 ) \n return -1 ; \n avio_read ( pb , guid , 16 ) ; \n if ( memcmp ( guid , guid_wave , 16 ) ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n size = find_guid ( pb , guid_fmt ) ; \n if ( size < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n st = av_new_stream ( s , 0 ) ; \n if ( ! st ) \n return AVERROR ( ENOMEM ) ; \n ff_get_wav_header ( pb , st -> codec , size - 24 ) ; \n avio_skip ( pb , FFALIGN ( size , INT64_C ( 8 ) ) - size ) ; \n st -> need_parsing = AVSTREAM_PARSE_FULL ; \n av_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; \n size = find_guid ( pb , guid_data ) ; \n if ( size < 0 ) { \n av_log ( s , AV_LOG_ERROR , \" \\n \" ) ; \n return -1 ; \n } \n wav -> data_end = avio_tell ( pb ) + size - 24 ; \n wav -> w64 = 1 ; \n return 0 ; \n }", "idx": 25868}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr15 ( const uint8_t * src , uint8_t * dst , long src_size ) \n { \n long i ; \n long num_pixels = src_size >> 1 ; \n for ( i = 0 ; i < num_pixels ; i ++ ) \n { \n unsigned b , g , r ; \n register uint16_t rgb ; \n rgb = src [ 2 * i ] ; \n r = rgb & 0x1F ; \n g = ( rgb & 0x3E0 ) >> 5 ; \n b = ( rgb & 0x7C00 ) >> 10 ; \n dst [ 2 * i ] = ( b & 0x1F ) | ( ( g & 0x1F ) << 5 ) | ( ( r & 0x1F ) << 10 ) ; \n } \n }", "idx": 25869}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int standard_decode_picture_primary_header ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n int status = 0 ; \n if ( v -> finterpflag ) v -> interpfrm = get_bits ( gb , 1 ) ; \n skip_bits ( gb , 2 ) ; \n if ( v -> rangered ) v -> rangeredfrm = get_bits ( gb , 1 ) ; \n v -> s . pict_type = get_bits ( gb , 1 ) ; \n if ( v -> s . avctx -> max_b_frames ) \n { \n if ( ! v -> s . pict_type ) \n { \n if ( get_bits ( gb , 1 ) ) v -> s . pict_type = I_TYPE ; \n else v -> s . pict_type = B_TYPE ; \n } \n else v -> s . pict_type = P_TYPE ; \n } \n else v -> s . pict_type ++ ; \n switch ( v -> s . pict_type ) \n { \n case I_TYPE : status = decode_i_picture_header ( v ) ; break ; \n case P_TYPE : status = decode_p_picture_primary_header ( v ) ; break ; \n case BI_TYPE : \n case B_TYPE : status = decode_b_picture_primary_header ( v ) ; break ; \n } \n if ( status == FRAME_SKIPED ) \n { \n av_log ( v -> s . avctx , AV_LOG_INFO , \" \\n \" ) ; \n return status ; \n } \n return 0 ; \n }", "idx": 25947}
{"project": "FFmpeg", "commit_id": "a18456a2032e49385447a1d0d2f146f65fe9a5e1", "target": 0, "func": "static FFServerIPAddressACL * parse_dynamic_acl ( FFServerStream * stream , HTTPContext * c ) \n { \n FILE * f ; \n char line [ 1024 ] ; \n char cmd [ 1024 ] ; \n FFServerIPAddressACL * acl = NULL ; \n int line_num = 0 ; \n const char * p ; \n f = fopen ( stream -> dynamic_acl , \" \" ) ; \n if ( ! f ) { \n perror ( stream -> dynamic_acl ) ; \n return NULL ; \n } \n acl = av_mallocz ( sizeof ( FFServerIPAddressACL ) ) ; \n for ( ; ; ) { \n if ( fgets ( line , sizeof ( line ) , f ) == NULL ) \n break ; \n line_num ++ ; \n p = line ; \n while ( av_isspace ( * p ) ) \n p ++ ; \n if ( * p == ' \\0 ' || * p == ' ' ) \n continue ; \n ffserver_get_arg ( cmd , sizeof ( cmd ) , & p ) ; \n if ( ! av_strcasecmp ( cmd , \" \" ) ) \n ffserver_parse_acl_row ( NULL , NULL , acl , p , stream -> dynamic_acl , line_num ) ; \n } \n fclose ( f ) ; \n return acl ; \n }", "idx": 25948}
{"project": "FFmpeg", "commit_id": "f2e9a0ecbef5027f9532c49ffcdfc11d199f6150", "target": 1, "func": "static av_cold int qsv_decode_close ( AVCodecContext * avctx ) \n { \n QSVOtherContext * s = avctx -> priv_data ; \n ff_qsv_decode_close ( & s -> qsv ) ; \n qsv_clear_buffers ( s ) ; \n av_fifo_free ( s -> packet_fifo ) ; \n return 0 ; \n }", "idx": 26030}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_tm_pred4x4_mode ( int mode , int mb_x , int mb_y ) \n { \n if ( ! mb_x ) { \n return mb_y ? VERT_VP8_PRED : DC_129_PRED ; \n } else { \n return mb_y ? mode : HOR_VP8_PRED ; \n } \n }", "idx": 26100}
{"project": "FFmpeg", "commit_id": "49cf36f4e3e9183611859af1a07dc6a82ab47288", "target": 1, "func": "static int decode_5 ( SANMVideoContext * ctx ) \n { \n #if HAVE_BIGENDIAN  \n  \n  uint16_t * frm ; \n int npixels ; \n #endif \n uint8_t * dst = ( uint8_t * ) ctx -> frm0 ; \n if ( rle_decode ( ctx , dst , ctx -> buf_size ) ) \n return AVERROR_INVALIDDATA ; \n #if HAVE_BIGENDIAN  \n  \n  npixels = ctx -> npixels ; \n frm = ctx -> frm0 ; \n while ( npixels -- ) \n * frm ++ = av_bswap16 ( * frm ) ; \n #endif \n return 0 ; \n }", "idx": 26294}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_key_prefix ( WriterContext * wctx ) \n { \n FlatContext * flat = wctx -> priv ; \n const struct section * parent_section = wctx -> section [ wctx -> level - 1 ] ; \n printf ( \" \" , flat -> section_header [ wctx -> level ] . str ) ; \n if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { \n int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? \n wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; \n printf ( \" \" , n , flat -> sep_str ) ; \n } \n }", "idx": 26360}
{"project": "FFmpeg", "commit_id": "3dea28cc2ef22861347918b6740c4c05c46a6614", "target": 0, "func": "static void idr ( H264Context * h ) { \n int i ; \n ff_h264_remove_all_refs ( h ) ; \n h -> prev_frame_num = -1 ; \n h -> prev_frame_num_offset = 0 ; \n h -> prev_poc_msb = 1 << 16 ; \n h -> prev_poc_lsb = 0 ; \n for ( i = 0 ; i < MAX_DELAYED_PIC_COUNT ; i ++ ) \n h -> last_pocs [ i ] = INT_MIN ; \n }", "idx": 26390}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void abort_codec_experimental ( AVCodec * c , int encoder ) \n { \n const char * codec_string = encoder ? \" \" : \" \" ; \n AVCodec * codec ; \n av_log ( NULL , AV_LOG_FATAL , \" \" \n \" \\n \\n \" , \n codec_string , c -> name ) ; \n codec = encoder ? avcodec_find_encoder ( c -> id ) : avcodec_find_decoder ( c -> id ) ; \n if ( ! ( codec -> capabilities & CODEC_CAP_EXPERIMENTAL ) ) \n av_log ( NULL , AV_LOG_FATAL , \" \\n \" , \n codec_string , codec -> name ) ; \n exit ( 1 ) ; \n }", "idx": 26428}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hyscale_fast_c ( SwsContext * c , int16_t * dst , int dstWidth , \n const uint8_t * src , int srcW , int xInc ) \n { \n int i ; \n unsigned int xpos = 0 ; \n for ( i = 0 ; i < dstWidth ; i ++ ) { \n register unsigned int xx = xpos >> 16 ; \n register unsigned int xalpha = ( xpos & 0xFFFF ) >> 9 ; \n dst [ i ] = ( src [ xx ] << 7 ) + ( src [ xx + 1 ] - src [ xx ] ) * xalpha ; \n xpos += xInc ; \n } \n }", "idx": 26435}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_i_mbs ( VC9Context * v ) \n { \n GetBitContext * gb = & v -> s . gb ; \n MpegEncContext * s = & v -> s ; \n int current_mb = 0 ; \n uint8_t cbpcy [ 4 ] , previous_cbpcy [ 4 ] , predicted_cbpcy , \n * p_cbpcy \n ; \n memset ( v -> previous_line_cbpcy , 0 , s -> mb_stride << 2 ) ; \n if ( v -> pq < 5 ) v -> ttmb_vlc = & vc9_ttmb_vlc [ 0 ] ; \n else if ( v -> pq < 13 ) v -> ttmb_vlc = & vc9_ttmb_vlc [ 1 ] ; \n else v -> ttmb_vlc = & vc9_ttmb_vlc [ 2 ] ; \n for ( s -> mb_y = 0 ; s -> mb_y < s -> mb_height ; s -> mb_y ++ ) \n { \n * ( ( uint32_t * ) previous_cbpcy ) = 0x00000000 ; \n p_cbpcy = v -> previous_line_cbpcy + 4 ; \n for ( s -> mb_x = 0 ; s -> mb_x < s -> mb_width ; s -> mb_x ++ , p_cbpcy += 4 ) \n { \n GET_CBPCY ( ff_msmp4_mb_i_vlc . table , MB_INTRA_VLC_BITS ) ; \n s -> ac_pred = get_bits ( gb , 1 ) ; \n #if TRACE > 2  \n  \n  av_log ( s -> avctx , AV_LOG_DEBUG , \" \" \n \" \\n \" , current_mb , \n p_cbpcy [ 0 ] , p_cbpcy [ 1 ] , p_cbpcy [ 2 ] , p_cbpcy [ 3 ] , \n previous_cbpcy [ 0 ] , previous_cbpcy [ 1 ] , previous_cbpcy [ 2 ] , previous_cbpcy [ 3 ] , \n cbpcy [ 0 ] , cbpcy [ 1 ] , cbpcy [ 2 ] , cbpcy [ 3 ] ) ; \n #endif \n * ( ( uint32_t * ) p_cbpcy ) = * ( ( uint32_t * ) previous_cbpcy ) ; \n * ( ( uint32_t * ) previous_cbpcy ) = * ( ( uint32_t * ) cbpcy ) ; \n current_mb ++ ; \n } \n } \n return 0 ; \n }", "idx": 26437}
{"project": "FFmpeg", "commit_id": "beefafda639dd53fc59c21d8a7cf8334da9a1062", "target": 1, "func": "static inline int wv_get_value_integer ( WavpackFrameContext * s , uint32_t * crc , int S ) \n { \n int bit ; \n if ( s -> extra_bits ) { \n S <<= s -> extra_bits ; \n if ( s -> got_extra_bits ) { \n S |= get_bits ( & s -> gb_extra_bits , s -> extra_bits ) ; \n * crc = * crc * 9 + ( S & 0xffff ) * 3 + ( ( unsigned ) S >> 16 ) ; \n } \n } \n bit = ( S & s -> and ) | s -> or ; \n return ( ( ( S + bit ) << s -> shift ) - bit ) << s -> post_shift ; \n }", "idx": 26559}
{"project": "FFmpeg", "commit_id": "42f9132218ca11a8e9a3c82a175b46bca092113e", "target": 0, "func": "static int mxf_read_seek ( AVFormatContext * s , int stream_index , int64_t sample_time , int flags ) \n { \n AVStream * st = s -> streams [ stream_index ] ; \n int64_t seconds ; \n MXFContext * mxf = s -> priv_data ; \n int64_t seekpos ; \n int ret ; \n MXFIndexTable * t ; \n if ( mxf -> nb_index_tables <= 0 ) { \n if ( ! s -> bit_rate ) \n return AVERROR_INVALIDDATA ; \n if ( sample_time < 0 ) \n sample_time = 0 ; \n seconds = av_rescale ( sample_time , st -> time_base . num , st -> time_base . den ) ; \n if ( ( ret = avio_seek ( s -> pb , ( s -> bit_rate * seconds ) >> 3 , SEEK_SET ) ) < 0 ) \n return ret ; \n ff_update_cur_dts ( s , st , sample_time ) ; \n mxf -> current_edit_unit = sample_time ; \n } else { \n t = & mxf -> index_tables [ 0 ] ; \n sample_time = FFMAX ( sample_time , 0 ) ; \n if ( t -> fake_index ) { \n if ( ( sample_time = ff_index_search_timestamp ( t -> fake_index , t -> nb_ptses , sample_time , flags ) ) < 0 ) \n return sample_time ; \n } else { \n sample_time = FFMIN ( sample_time , st -> duration - 1 ) ; \n } \n if ( ( ret = mxf_edit_unit_absolute_offset ( mxf , t , sample_time , & sample_time , & seekpos , 1 ) ) << 0 ) \n return ret ; \n ff_update_cur_dts ( s , st , sample_time ) ; \n mxf -> current_edit_unit = sample_time ; \n avio_seek ( s -> pb , seekpos , SEEK_SET ) ; \n } \n return 0 ; \n }", "idx": 26568}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int fft_init ( AVCodecContext * avctx , AC3MDCTContext * mdct , int ln ) \n { \n int i , n , n2 ; \n float alpha ; \n n = 1 << ln ; \n n2 = n >> 1 ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> costab , n2 * sizeof ( * mdct -> costab ) , fft_alloc_fail ) ; \n FF_ALLOC_OR_GOTO ( avctx , mdct -> sintab , n2 * sizeof ( * mdct -> sintab ) , fft_alloc_fail ) ; \n for ( i = 0 ; i < n2 ; i ++ ) { \n alpha = 2.0 * M_PI * i / n ; \n mdct -> costab [ i ] = FIX15 ( cos ( alpha ) ) ; \n mdct -> sintab [ i ] = FIX15 ( sin ( alpha ) ) ; \n } \n return 0 ; \n fft_alloc_fail : \n mdct_end ( mdct ) ; \n return AVERROR ( ENOMEM ) ; \n }", "idx": 26730}
{"project": "FFmpeg", "commit_id": "a91d82b5cc7d828ea9779aae1595f60e7e257d29", "target": 1, "func": "static int sbr_hf_calc_npatches ( AACContext * ac , SpectralBandReplication * sbr ) \n { \n int i , k , sb = 0 ; \n int msb = sbr -> k [ 0 ] ; \n int usb = sbr -> kx [ 1 ] ; \n int goal_sb = ( ( 1000 << 11 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ; \n sbr -> num_patches = 0 ; \n if ( goal_sb < sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) { \n for ( k = 0 ; sbr -> f_master [ k ] < goal_sb ; k ++ ) ; \n } else \n k = sbr -> n_master ; \n do { \n int odd = 0 ; \n for ( i = k ; i == k || sb > ( sbr -> k [ 0 ] - 1 + msb - odd ) ; i -- ) { \n sb = sbr -> f_master [ i ] ; \n odd = ( sb + sbr -> k [ 0 ] ) & 1 ; \n } \n sbr -> patch_num_subbands [ sbr -> num_patches ] = FFMAX ( sb - usb , 0 ) ; \n sbr -> patch_start_subband [ sbr -> num_patches ] = sbr -> k [ 0 ] - odd - sbr -> patch_num_subbands [ sbr -> num_patches ] ; \n if ( sbr -> patch_num_subbands [ sbr -> num_patches ] > 0 ) { \n usb = sb ; \n msb = sb ; \n sbr -> num_patches ++ ; \n } else \n msb = sbr -> kx [ 1 ] ; \n if ( sbr -> f_master [ k ] - sb < 3 ) \n k = sbr -> n_master ; \n } while ( sb != sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) ; \n if ( sbr -> patch_num_subbands [ sbr -> num_patches - 1 ] < 3 && sbr -> num_patches > 1 ) \n sbr -> num_patches -- ; \n if ( sbr -> num_patches > 6 ) { \n av_log ( ac -> avccontext , AV_LOG_ERROR , \" \\n \" , sbr -> num_patches ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 26862}
{"project": "FFmpeg", "commit_id": "0de1319ee0109facefe9804ffe0f0d0df36b27ad", "target": 0, "func": "static int http_start_receive_data ( HTTPContext * c ) \n { \n int fd ; \n if ( c -> stream -> feed_opened ) \n return -1 ; \n if ( c -> stream -> readonly ) \n return -1 ; \n fd = open ( c -> stream -> feed_filename , O_RDWR ) ; \n if ( fd < 0 ) { \n http_log ( \" \\n \" , strerror ( errno ) ) ; \n return -1 ; \n } \n c -> feed_fd = fd ; \n if ( c -> stream -> truncate ) { \n ffm_write_write_index ( c -> feed_fd , FFM_PACKET_SIZE ) ; \n ftruncate ( c -> feed_fd , FFM_PACKET_SIZE ) ; \n http_log ( \" \\n \" , c -> stream -> feed_filename ) ; \n } else { \n if ( ( c -> stream -> feed_write_index = ffm_read_write_index ( fd ) ) < 0 ) { \n http_log ( \" \\n \" , strerror ( errno ) ) ; \n return -1 ; \n } \n } \n c -> stream -> feed_write_index = FFMAX ( ffm_read_write_index ( fd ) , FFM_PACKET_SIZE ) ; \n c -> stream -> feed_size = lseek ( fd , 0 , SEEK_END ) ; \n lseek ( fd , 0 , SEEK_SET ) ; \n c -> buffer_ptr = c -> buffer ; \n c -> buffer_end = c -> buffer + FFM_PACKET_SIZE ; \n c -> stream -> feed_opened = 1 ; \n c -> chunked_encoding = ! ! av_stristr ( c -> buffer , \" \" ) ; \n return 0 ; \n }", "idx": 26880}
{"project": "FFmpeg", "commit_id": "39f7620d76c7a133535ed7a535f7a74fefa6e435", "target": 0, "func": "static av_cold int dcadec_init ( AVCodecContext * avctx ) \n { \n DCAContext * s = avctx -> priv_data ; \n s -> avctx = avctx ; \n s -> core . avctx = avctx ; \n s -> exss . avctx = avctx ; \n s -> xll . avctx = avctx ; \n s -> lbr . avctx = avctx ; \n ff_dca_init_vlcs ( ) ; \n if ( ff_dca_core_init ( & s -> core ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n if ( ff_dca_lbr_init ( & s -> lbr ) < 0 ) \n return AVERROR ( ENOMEM ) ; \n ff_dcadsp_init ( & s -> dcadsp ) ; \n s -> core . dcadsp = & s -> dcadsp ; \n s -> xll . dcadsp = & s -> dcadsp ; \n s -> lbr . dcadsp = & s -> dcadsp ; \n s -> crctab = av_crc_get_table ( AV_CRC_16_CCITT ) ; \n switch ( avctx -> request_channel_layout & ~ AV_CH_LAYOUT_NATIVE ) { \n case 0 : \n s -> request_channel_layout = 0 ; \n break ; \n case AV_CH_LAYOUT_STEREO : \n case AV_CH_LAYOUT_STEREO_DOWNMIX : \n s -> request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO ; \n break ; \n case AV_CH_LAYOUT_5POINT0 : \n s -> request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0 ; \n break ; \n case AV_CH_LAYOUT_5POINT1 : \n s -> request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1 ; \n break ; \n default : \n av_log ( avctx , AV_LOG_WARNING , \" \\n \" ) ; \n break ; \n } \n avctx -> sample_fmt = AV_SAMPLE_FMT_S32P ; \n avctx -> bits_per_raw_sample = 24 ; \n return 0 ; \n }", "idx": 26947}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC ( ff_h264_idct_add ) ( uint8_t * _dst , DCTELEM * _block , int stride ) \n { \n int i ; \n INIT_CLIP \n pixel * dst = ( pixel * ) _dst ; \n dctcoef * block = ( dctcoef * ) _block ; \n stride /= sizeof ( pixel ) ; \n block [ 0 ] += 1 << 5 ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ; \n const int z1 = block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ; \n const int z2 = ( block [ i + 4 * 1 ] >> 1 ) - block [ i + 4 * 3 ] ; \n const int z3 = block [ i + 4 * 1 ] + ( block [ i + 4 * 3 ] >> 1 ) ; \n block [ i + 4 * 0 ] = z0 + z3 ; \n block [ i + 4 * 1 ] = z1 + z2 ; \n block [ i + 4 * 2 ] = z1 - z2 ; \n block [ i + 4 * 3 ] = z0 - z3 ; \n } \n for ( i = 0 ; i < 4 ; i ++ ) { \n const int z0 = block [ 0 + 4 * i ] + block [ 2 + 4 * i ] ; \n const int z1 = block [ 0 + 4 * i ] - block [ 2 + 4 * i ] ; \n const int z2 = ( block [ 1 + 4 * i ] >> 1 ) - block [ 3 + 4 * i ] ; \n const int z3 = block [ 1 + 4 * i ] + ( block [ 3 + 4 * i ] >> 1 ) ; \n dst [ i + 0 * stride ] = CLIP ( dst [ i + 0 * stride ] + ( ( z0 + z3 ) >> 6 ) ) ; \n dst [ i + 1 * stride ] = CLIP ( dst [ i + 1 * stride ] + ( ( z1 + z2 ) >> 6 ) ) ; \n dst [ i + 2 * stride ] = CLIP ( dst [ i + 2 * stride ] + ( ( z1 - z2 ) >> 6 ) ) ; \n dst [ i + 3 * stride ] = CLIP ( dst [ i + 3 * stride ] + ( ( z0 - z3 ) >> 6 ) ) ; \n } \n }", "idx": 27081}
