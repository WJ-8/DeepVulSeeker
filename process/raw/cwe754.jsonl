{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        wscanf(L\"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_03_bad()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fputs(\"string\", stdout) == EOF)\n    {\n        printLine(\"fputs failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n         * we are checking to see if the return value is greater than zero (which will be true) */\n        if (ImpersonateNamedPipeClient(hPipe) > 0)\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n    if (RpcImpersonateClient(0) != RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_03_bad()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    PUTS(\"string\");\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n           but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n        if (hMutex == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n         * -- However, since we're not even DOING anything with the pipe\n         * it's debatable whether this is really a bug\n         */\n        ImpersonateNamedPipeClient(hPipe);\n        printLine(\"Impersonated\");\n        if (!RevertToSelf())\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgetws(data, 100, stdin) < 0)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (putchar((int)'A') == EOF)\n    {\n        printLine(\"putchar failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (REMOVE(\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (putwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"putwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgetws(data, 100, stdin) < 0)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_02_bad()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    putc((int)'A', stdout);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            printLine(\"Failed to impersonate\");\n        }\n        else\n        {\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snwprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check if ImpersonateSelf() fails */\n    ImpersonateSelf(SecurityImpersonation);\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (PUTS(\"string\") == EOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n         * we are checking to see if the return value is greater than zero (which will be true) */\n        if (ImpersonateNamedPipeClient(hPipe) > 0)\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    putchar((int)'A');\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FLAW: Do not check the return value */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n     * but we are checking to see if the return value is less than 0 */\n    if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            printLine(\"Failed to impersonate\");\n        }\n        else\n        {\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        swscanf(SRC, L\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n     * but we are checking to see if the return value is less than 0 */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_03_bad()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_01_bad()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: Do not check the return value */\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (putchar((int)'A') == EOF)\n    {\n        printLine(\"putchar failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fwscanf(stdin, L\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (PUTS(L\"string\") == 0)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_01_bad()\n{\n    /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (PUTS(L\"string\") == 0)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (putc((int)'A', stdout) == EOF)\n    {\n        printLine(\"putc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_10_bad()\n{\n    if(globalTrue)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    putc((int)'A', stdout);\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_14_bad()\n{\n    if(globalFive==5)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fwprintf(stdout, L\"%s\\n\", L\"string\");\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        swscanf(SRC, L\"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n         * but we are checking to see if the return value is 0 */\n        if (wscanf(L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void good4() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: Do not check the return value */\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_18_bad()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FLAW: Do not check the return value */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n         * but we are checking to see if the return value is 0 */\n        if (scanf(\"%99s\\0\", data) == 0)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_03_bad()\n{\n    if(5==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (putchar((int)'A') == EOF)\n    {\n        printLine(\"putchar failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fputs(\"string\", stdout);\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_16_bad()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_01_bad()\n{\n    /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n     * we are checking to see if the return value is 0 */\n    if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n    {\n        printLine(\"fprintf failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_16_bad()\n{\n    while(1)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (PUTS(L\"string\") == WEOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        scanf(\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        swscanf(SRC, L\"%99s\\0\", data);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_01_bad()\n{\n    /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n     * we are checking to see if the return value is 0 */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (putc((int)'A', stdout) == EOF)\n    {\n        printLine(\"putc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_18_bad()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n           but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n        if (hMutex == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (putc((int)'A', stdout) == EOF)\n    {\n        printLine(\"putc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_01_bad()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n           but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n        if (hMutex == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputc((int)'A', stdout) == 0)\n    {\n        printLine(\"fputc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fputwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"fputwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n    {\n        printLine(\"fprintf failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (REMOVE(\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_01_bad()\n{\n    /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n     * but we are checking to see if the return value is less than 0 */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    REMOVE(L\"removemebad.txt\");\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void bad8() { }"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            printLine(\"Failed to impersonate\");\n        }\n        else\n        {\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (putwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"putwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void bad4() { }"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_01_bad()\n{\n    /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putc((int)'A', stdout) == 0)\n    {\n        printLine(\"putc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n     * we are checking to see if the return value is 0 */\n    if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n    {\n        printLine(\"fprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_03_bad()\n{\n    if(5==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fscanf(stdin, \"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_18_bad()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n         * we are checking to see if the return value is greater than zero (which will be true) */\n        if (ImpersonateNamedPipeClient(hPipe) > 0)\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fscanf(stdin, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fwscanf(stdin, L\"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_02_bad()\n{\n    if(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_01_bad()\n{\n    /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputws(L\"string\", stdout) == 0)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    putwc((wchar_t)L'A', stdout);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: Do not check the return value */\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fputws(L\"string\", stdout) == WEOF)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void good3() { }"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_02_bad()\n{\n    if(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgetws(data, 100, stdin);\n        printWLine(data);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_01_bad()\n{\n    /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putchar((int)'A') == 0)\n    {\n        printLine(\"putchar failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putwchar((wchar_t)L'A') == 0)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_18_bad()\n{\n    goto sink;\nsink:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void good8() { }"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n         * but we are checking to see if the return value is 0 */\n        if (scanf(\"%99s\\0\", data) == 0)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (putwchar((wchar_t)L'A') == WEOF)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_01_bad()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n         * we are checking to see if the return value is greater than zero (which will be true) */\n        if (ImpersonateNamedPipeClient(hPipe) > 0)\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void good9() { }"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_03_bad()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fwscanf(stdin, L\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_02_bad()\n{\n    if(1)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_18_bad()\n{\n    goto sink;\nsink:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: Do not check the return value */\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_01_bad()\n{\n    /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputc((int)'A', stdout) == 0)\n    {\n        printLine(\"fputc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fputs(\"string\", stdout) == EOF)\n    {\n        printLine(\"fputs failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fprintf(stdout, \"%s\\n\", \"string\");\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgetws(data, 100, stdin) < 0)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_18_bad()\n{\n    goto sink;\nsink:\n    RpcImpersonateClient(0);\n    /* FLAW: Do not check if RpcImpersonateClient() fails */\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: Check to see if ImpersonateSelf() fails */\n    if (!ImpersonateSelf(SecurityImpersonation))\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void bad7() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_03_bad()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (REMOVE(\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putchar((int)'A') == 0)\n    {\n        printLine(\"putchar failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgets(data, 100, stdin) < 0)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_16_bad()\n{\n    while(1)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n           but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n        if (hMutex == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fputc((int)'A', stdout) == EOF)\n    {\n        printLine(\"fputc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (putchar((int)'A') == EOF)\n    {\n        printLine(\"putchar failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_01_bad()\n{\n    /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n    if (RpcImpersonateClient(0) != RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fputwc((wchar_t)L'A', stdout);\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        sscanf(SRC, \"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putwc((wchar_t)L'A', stdout) == 0)\n    {\n        printLine(\"putwc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_02_bad()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_02_bad()\n{\n    if(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_16_bad()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_18_bad()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n         * -- However, since we're not even DOING anything with the pipe\n         * it's debatable whether this is really a bug\n         */\n        ImpersonateNamedPipeClient(hPipe);\n        printLine(\"Impersonated\");\n        if (!RevertToSelf())\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (REMOVE(\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgetws(data, 100, stdin);\n        printWLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_16_bad()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (putwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"putwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (PUTS(\"string\") == 0)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n         * but we are checking to see if the return value is 0 */\n        if (wscanf(L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (PUTS(\"string\") == EOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fputwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"fputwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_01_bad()\n{\n    /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putwchar((wchar_t)L'A') == 0)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_01_bad()\n{\n    /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputs(\"string\", stdout) == 0)\n    {\n        printLine(\"fputs failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgets(data, 100, stdin) < 0)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n     * are failing if the return value is RPC_S_OK */\n    if (RpcImpersonateClient(0) == RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgets(data, 100, stdin);\n        printLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fputs(\"string\", stdout);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (PUTS(L\"string\") == WEOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_18_bad()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FLAW: Do not check the return value */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    putwc((wchar_t)L'A', stdout);\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n         * but we are checking to see if the return value is 0 */\n        if (scanf(\"%99s\\0\", data) == 0)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void bad3() { }"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    PUTS(L\"string\");\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputwc((wchar_t)L'A', stdout) == 0)\n    {\n        printLine(\"fputwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fputwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"fputwc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            printLine(\"Failed to impersonate\");\n        }\n        else\n        {\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (PUTS(L\"string\") == WEOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_01_bad()\n{\n    /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putwc((wchar_t)L'A', stdout) == 0)\n    {\n        printLine(\"putwc failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_01_bad()\n{\n    /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (REMOVE(L\"removemebad.txt\") == 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n    {\n        printLine(\"fprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putc((int)'A', stdout) == 0)\n    {\n        printLine(\"putc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fputws(L\"string\", stdout);\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void good7() { }"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_01_bad()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n           but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n        if (hMutex == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FLAW: Do not check the return value */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void bad2() { }"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fputc((int)'A', stdout);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fwprintf(stdout, L\"%s\\n\", L\"string\");\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgets(data, 100, stdin);\n        printLine(data);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (putwchar((wchar_t)L'A') == WEOF)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (putwchar((wchar_t)L'A') == WEOF)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        wscanf(L\"%99s\\0\", data);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_18_bad()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snwprintf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_01_bad()\n{\n    /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (REMOVE(\"removemebad.txt\") == 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n    {\n        printLine(\"fprintf failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_16_bad()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void bad1() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n    {\n        printLine(\"fprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (putwchar((wchar_t)L'A') == WEOF)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_18_bad()\n{\n    goto sink;\nsink:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n           but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n        if (hMutex == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_02_bad()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_02_bad()\n{\n    if(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fputs(\"string\", stdout) == EOF)\n    {\n        printLine(\"fputs failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_01_bad()\n{\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: Do not check the return value */\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_01_bad()\n{\n    /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n     * but we are checking to see if the return value is less than 0 */\n    if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void bad5() { }"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (REMOVE(L\"removemebad.txt\") == 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void good1() { }"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_01_bad()\n{\n    {\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                    PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n         * which isn't actually an error in terms of waiting for a client. */\n        if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n        {\n            CloseHandle(hPipe);\n            exit(1);\n        }\n        /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n         * -- However, since we're not even DOING anything with the pipe\n         * it's debatable whether this is really a bug\n         */\n        ImpersonateNamedPipeClient(hPipe);\n        printLine(\"Impersonated\");\n        if (!RevertToSelf())\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fputwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"fputwc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fprintf(stdout, \"%s\\n\", \"string\");\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (RpcImpersonateClient(0) != RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_03_bad()\n{\n    if(5==5)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fputs(\"string\", stdout) == EOF)\n    {\n        printLine(\"fputs failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (putc((int)'A', stdout) == EOF)\n    {\n        printLine(\"putc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_18_bad()\n{\n    goto sink;\nsink:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n         * we are checking to see if the return value is greater than zero (which will be true) */\n        if (ImpersonateNamedPipeClient(hPipe) > 0)\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fputws(L\"string\", stdout) == WEOF)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgetws(data, 100, stdin);\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_01_bad()\n{\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_07_bad()\n{\n    if(staticFive==5)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (putwc((wchar_t)L'A', stdout) == WEOF)\n    {\n        printLine(\"putwc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, L\"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_01_bad()\n{\n    RpcImpersonateClient(0);\n    /* FLAW: Do not check if RpcImpersonateClient() fails */\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgetws(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgetws failed!\");\n            exit(1);\n        }\n        printWLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_02_bad()\n{\n    if(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n         * but we are checking to see if the return value is 0 */\n        if (wscanf(L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fputws(L\"string\", stdout);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputws(L\"string\", stdout) == 0)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fputwc((wchar_t)L'A', stdout);\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (PUTS(\"string\") == EOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_16_bad()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fscanf(stdin, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (REMOVE(L\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (REMOVE(L\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_02_bad()\n{\n    if(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FIX: check for the correct return value */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fputc((int)'A', stdout) == EOF)\n    {\n        printLine(\"fputc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (REMOVE(\"removemebad.txt\") == 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_01_bad()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexW(NULL, FALSE, NULL);\n        /* FLAW: Do not check the return value */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (scanf(\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"scanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_rename_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        RENAME(OLD_BAD_FILE_NAME, \"newbadfilename.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgetws(data, 100, stdin);\n        printWLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_03_bad()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void good2() { }"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_03_bad()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fputc((int)'A', stdout) == EOF)\n    {\n        printLine(\"fputc failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_01_bad()\n{\n    /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n     * are failing if the return value is RPC_S_OK */\n    if (RpcImpersonateClient(0) == RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        scanf(\"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_01_bad()\n{\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n         * we are checking to see if the return value is greater than zero (which will be true) */\n        if (ImpersonateNamedPipeClient(hPipe) > 0)\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        wscanf(L\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_03_bad()\n{\n    if(5==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_02_bad()\n{\n    if(1)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    putchar((int)'A');\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void good6() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    REMOVE(\"removemebad.txt\");\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check the return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    PUTS(\"string\");\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_05_bad()\n{\n    if(staticTrue)\n    {\n        RpcImpersonateClient(0);\n        /* FLAW: Do not check if RpcImpersonateClient() fails */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_01_bad()\n{\n    /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwchar((wchar_t)L'A');\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void bad6() { }"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_18_bad()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFSIZE,\n                    BUFSIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: Do not check the return value */\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_03_bad()\n{\n    if(5==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (!ImpersonateSelf(SecurityImpersonation))\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fscanf(stdin, \"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    REMOVE(\"removemebad.txt\");\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_rename_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n         * if the return value is greater than zero (true) */\n        if (ImpersonateSelf(SecurityImpersonation) > 0)\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputs(\"string\", stdout) == 0)\n    {\n        printLine(\"fputs failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (REMOVE(L\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void bad9() { }"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_16_bad()\n{\n    while(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_01_bad()\n{\n    /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (fputwc((wchar_t)L'A', stdout) == 0)\n    {\n        printLine(\"fputwc failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fputc((int)'A', stdout) == EOF)\n    {\n        printLine(\"fputc failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_02_bad()\n{\n    if(1)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: wscanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (wscanf(L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    putwchar((wchar_t)L'A');\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    putwchar((wchar_t)L'A');\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    REMOVE(L\"removemebad.txt\");\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Check to see if ImpersonateSelf() fails */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_01_bad()\n{\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FLAW: Do not check the return value */\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeA(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FIX: check for the correct return value */\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"sscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_scanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fputws(L\"string\", stdout) == WEOF)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putchar_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputws(L\"string\", stdout) == 0)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (!ImpersonateSelf(SecurityImpersonation))\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        scanf(\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_01_bad()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fscanf(stdin, \"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        sscanf(SRC, \"%99s\\0\", data);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (REMOVE(L\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fputc((int)'A', stdout);\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n     * if the return value is greater than zero (true) */\n    if (ImpersonateSelf(SecurityImpersonation) > 0)\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_01_bad()\n{\n    /* FLAW: Do not check if ImpersonateSelf() fails */\n    ImpersonateSelf(SecurityImpersonation);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (PUTS(\"string\") == EOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_01_bad()\n{\n    /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (PUTS(\"string\") == 0)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: Check to see if ImpersonateSelf() fails */\n    if (!ImpersonateSelf(SecurityImpersonation))\n    {\n        exit(1);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fputws(L\"string\", stdout) == WEOF)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fscanf(stdin, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgets(data, 100, stdin) < 0)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        sscanf(SRC, \"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgets(data, 100, stdin);\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (PUTS(L\"string\") == WEOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n     * we are checking to see if the return value is 0 */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (RpcImpersonateClient(0) != RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_01_bad()\n{\n    /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n     * if the return value is greater than zero (true) */\n    if (ImpersonateSelf(SecurityImpersonation) > 0)\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void good5() { }"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    PUTS(L\"string\");\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
