{"project": "qemu", "commit_id": "aa1530dec499f7525d2ccaa0e3a876dc8089ed1e", "target": 1, "func": "static void filter_mirror_setup ( NetFilterState * nf , Error * * errp ) \n { \n MirrorState * s = FILTER_MIRROR ( nf ) ; \n Chardev * chr ; \n chr = qemu_chr_find ( s -> outdev ) ; \n if ( chr == NULL ) { \n error_set ( errp , ERROR_CLASS_DEVICE_NOT_FOUND , \n \" \" , s -> outdev ) ; \n qemu_chr_fe_init ( & s -> chr_out , chr , errp ) ;", "idx": 8}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int64_t sub64 ( const int64_t a , const int64_t b ) \n { \n return a - b ; \n }", "idx": 10}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback ( FWCfgState * s , uint16_t key , FWCfgCallback callback , \n void * callback_opaque , uint8_t * data , size_t len ) \n { \n int arch = ! ! ( key & FW_CFG_ARCH_LOCAL ) ; \n assert ( key & FW_CFG_WRITE_CHANNEL ) ; \n key &= FW_CFG_ENTRY_MASK ; \n assert ( key < FW_CFG_MAX_ENTRY && len <= 65535 ) ; \n s -> entries [ arch ] [ key ] . data = data ; \n s -> entries [ arch ] [ key ] . len = len ; \n s -> entries [ arch ] [ key ] . callback_opaque = callback_opaque ; \n s -> entries [ arch ] [ key ] . callback = callback ; \n }", "idx": 15}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void emulated_push_error ( EmulatedState * card , uint64_t code ) \n { \n EmulEvent * event = ( EmulEvent * ) g_malloc ( sizeof ( EmulEvent ) ) ; \n assert ( event ) ; \n event -> p . error . type = EMUL_ERROR ; \n event -> p . error . code = code ; \n emulated_push_event ( card , event ) ; \n }", "idx": 22}
{"project": "qemu", "commit_id": "c39ce112b60ffafbaf700853e32bea74cbb2c148", "target": 0, "func": "static void do_busid_cmd ( ESPState * s , uint8_t * buf , uint8_t busid ) \n { \n int32_t datalen ; \n int lun ; \n DPRINTF ( \" \\n \" , busid ) ; \n lun = busid & 7 ; \n s -> current_req = scsi_req_new ( s -> current_dev , 0 , lun , NULL ) ; \n datalen = scsi_req_enqueue ( s -> current_req , buf ) ; \n s -> ti_size = datalen ; \n if ( datalen != 0 ) { \n s -> rregs [ ESP_RSTAT ] = STAT_TC ; \n s -> dma_left = 0 ; \n s -> dma_counter = 0 ; \n if ( datalen > 0 ) { \n s -> rregs [ ESP_RSTAT ] |= STAT_DI ; \n } else { \n s -> rregs [ ESP_RSTAT ] |= STAT_DO ; \n } \n scsi_req_continue ( s -> current_req ) ; \n } \n s -> rregs [ ESP_RINTR ] = INTR_BS | INTR_FC ; \n s -> rregs [ ESP_RSEQ ] = SEQ_CD ; \n esp_raise_irq ( s ) ; \n }", "idx": 51}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void gdb_do_syscall ( gdb_syscall_complete_cb cb , const char * fmt , ... ) \n { \n va_list va ; \n char buf [ 256 ] ; \n char * p ; \n target_ulong addr ; \n uint64_t i64 ; \n GDBState * s ; \n s = gdbserver_state ; \n if ( ! s ) \n return ; \n gdb_current_syscall_cb = cb ; \n s -> state = RS_SYSCALL ; \n #ifndef CONFIG_USER_ONLY \n vm_stop ( EXCP_DEBUG ) ; \n #endif \n s -> state = RS_IDLE ; \n va_start ( va , fmt ) ; \n p = buf ; \n * ( p ++ ) = ' ' ; \n while ( * fmt ) { \n if ( * fmt == ' ' ) { \n fmt ++ ; \n switch ( * fmt ++ ) { \n case ' ' : \n addr = va_arg ( va , target_ulong ) ; \n p += snprintf ( p , & buf [ sizeof ( buf ) ] - p , TARGET_FMT_lx , addr ) ; \n break ; \n case ' ' : \n if ( * ( fmt ++ ) != ' ' ) \n goto bad_format ; \n i64 = va_arg ( va , uint64_t ) ; \n p += snprintf ( p , & buf [ sizeof ( buf ) ] - p , \" \" PRIx64 , i64 ) ; \n break ; \n case ' ' : \n addr = va_arg ( va , target_ulong ) ; \n p += snprintf ( p , & buf [ sizeof ( buf ) ] - p , TARGET_FMT_lx \" \" , \n addr , va_arg ( va , int ) ) ; \n break ; \n default : \n bad_format : \n fprintf ( stderr , \" \\n \" , \n fmt - 1 ) ; \n break ; \n } \n } else { \n * ( p ++ ) = * ( fmt ++ ) ; \n } \n } \n * p = 0 ; \n va_end ( va ) ; \n put_packet ( s , buf ) ; \n #ifdef CONFIG_USER_ONLY \n gdb_handlesig ( s -> c_cpu , 0 ) ; \n #else \n cpu_interrupt ( s -> c_cpu , CPU_INTERRUPT_EXIT ) ; \n #endif \n }", "idx": 71}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tricore_cpu_initfn ( Object * obj ) \n { \n CPUState * cs = CPU ( obj ) ; \n TriCoreCPU * cpu = TRICORE_CPU ( obj ) ; \n CPUTriCoreState * env = & cpu -> env ; \n cs -> env_ptr = env ; \n cpu_exec_init ( cs , & error_abort ) ; \n if ( tcg_enabled ( ) ) { \n tricore_tcg_init ( ) ; \n } \n }", "idx": 88}
{"project": "qemu", "commit_id": "35f754620615138aaae0ef72602f84c88fd8de0f", "target": 1, "func": "struct vhost_net * vhost_net_init ( VLANClientState * backend , int devfd , \n bool force ) \n { \n return NULL ; \n }", "idx": 143}
{"project": "qemu", "commit_id": "3e4f910c8d490a1490409a7e381dbbb229f9d272", "target": 1, "func": "static void ehci_mem_writew ( void * ptr , target_phys_addr_t addr , uint32_t val ) \n { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n }", "idx": 155}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void xendev_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n dc -> props = xendev_properties ; \n set_bit ( DEVICE_CATEGORY_MISC , dc -> categories ) ; \n }", "idx": 161}
{"project": "qemu", "commit_id": "1fa795a853255fcc93e5d3e2a92d161a2ed96eb8", "target": 1, "func": "static uint64_t qdev_get_prop_mask64 ( Property * prop ) \n { \n assert ( prop -> info == & qdev_prop_bit ) ; \n return 0x1 << prop -> bitnr ; \n }", "idx": 162}
{"project": "qemu", "commit_id": "12b7f57e2cfcd665cf5a21b4ae3c23b9361c5c05", "target": 0, "func": "static void smp_parse ( const char * optarg ) \n { \n int smp , sockets = 0 , threads = 0 , cores = 0 ; \n char * endptr ; \n char option [ 128 ] ; \n smp = strtoul ( optarg , & endptr , 10 ) ; \n if ( endptr != optarg ) { \n if ( * endptr == ' ' ) { \n endptr ++ ; \n } \n } \n if ( get_param_value ( option , 128 , \" \" , endptr ) != 0 ) \n sockets = strtoull ( option , NULL , 10 ) ; \n if ( get_param_value ( option , 128 , \" \" , endptr ) != 0 ) \n cores = strtoull ( option , NULL , 10 ) ; \n if ( get_param_value ( option , 128 , \" \" , endptr ) != 0 ) \n threads = strtoull ( option , NULL , 10 ) ; \n if ( get_param_value ( option , 128 , \" \" , endptr ) != 0 ) \n max_cpus = strtoull ( option , NULL , 10 ) ; \n if ( smp == 0 || sockets == 0 ) { \n sockets = sockets > 0 ? sockets : 1 ; \n cores = cores > 0 ? cores : 1 ; \n threads = threads > 0 ? threads : 1 ; \n if ( smp == 0 ) { \n smp = cores * threads * sockets ; \n } \n } else { \n if ( cores == 0 ) { \n threads = threads > 0 ? threads : 1 ; \n cores = smp / ( sockets * threads ) ; \n } else { \n threads = smp / ( cores * sockets ) ; \n } \n } \n smp_cpus = smp ; \n smp_cores = cores > 0 ? cores : 1 ; \n smp_threads = threads > 0 ? threads : 1 ; \n if ( max_cpus == 0 ) \n max_cpus = smp_cpus ; \n }", "idx": 174}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pwt_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n struct omap_pwt_s * s = ( struct omap_pwt_s * ) opaque ; \n int offset = addr & OMAP_MPUI_REG_MASK ; \n if ( size != 1 ) { \n return omap_badwidth_read8 ( opaque , addr ) ; \n } \n switch ( offset ) { \n case 0x00 : \n return s -> frc ; \n case 0x04 : \n return s -> vrc ; \n case 0x08 : \n return s -> gcr ; \n } \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 227}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t lduw_be_phys ( target_phys_addr_t addr ) \n { \n return lduw_phys_internal ( addr , DEVICE_BIG_ENDIAN ) ; \n }", "idx": 235}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_bool ( Visitor * v , const char * name , bool * obj , \n Error * * errp ) \n { \n StringInputVisitor * siv = to_siv ( v ) ; \n if ( siv -> string ) { \n if ( ! strcasecmp ( siv -> string , \" \" ) || \n ! strcasecmp ( siv -> string , \" \" ) || \n ! strcasecmp ( siv -> string , \" \" ) ) { \n * obj = true ; \n return ; \n } \n if ( ! strcasecmp ( siv -> string , \" \" ) || \n ! strcasecmp ( siv -> string , \" \" ) || \n ! strcasecmp ( siv -> string , \" \" ) ) { \n * obj = false ; \n return ; \n } \n } \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : \" \" , \n \" \" ) ; \n }", "idx": 257}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t sp804_read ( void * opaque , target_phys_addr_t offset , \n unsigned size ) \n { \n sp804_state * s = ( sp804_state * ) opaque ; \n if ( offset < 0x20 ) { \n return arm_timer_read ( s -> timer [ 0 ] , offset ) ; \n } \n if ( offset < 0x40 ) { \n return arm_timer_read ( s -> timer [ 1 ] , offset - 0x20 ) ; \n } \n if ( offset >= 0xfe0 && offset <= 0xffc ) { \n return sp804_ids [ ( offset - 0xfe0 ) >> 2 ] ; \n } \n switch ( offset ) { \n case 0xf00 : \n case 0xf04 : \n return 0 ; \n } \n hw_error ( \" \\n \" , __func__ , ( int ) offset ) ; \n return 0 ; \n }", "idx": 292}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void timerlist_rearm ( QEMUTimerList * timer_list ) \n { \n if ( timer_list -> clock -> type == QEMU_CLOCK_VIRTUAL ) { \n qemu_start_warp_timer ( ) ; \n } \n timerlist_notify ( timer_list ) ; \n }", "idx": 298}
{"project": "qemu", "commit_id": "13f59ae8157e8ec238fa8aefe5309909a1eeb7e2", "target": 0, "func": "bool error_is_type ( Error * err , const char * fmt ) \n { \n const char * error_class ; \n char * ptr ; \n char * end ; \n if ( ! err ) { \n return false ; \n } \n ptr = strstr ( fmt , \" \" ) ; \n assert ( ptr != NULL ) ; \n ptr += strlen ( \" \" ) ; \n end = strchr ( ptr , ' \\' ' ) ; \n assert ( end != NULL ) ; \n error_class = error_get_field ( err , \" \" ) ; \n if ( strlen ( error_class ) != end - ptr ) { \n return false ; \n } \n return strncmp ( ptr , error_class , end - ptr ) == 0 ; \n }", "idx": 311}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_main ( OneNANDState * s , int sec , int secn , \n void * dest ) \n { \n if ( s -> bdrv_cur ) \n return bdrv_read ( s -> bdrv_cur , sec , dest , secn ) < 0 ; \n else if ( sec + secn > s -> secs_cur ) \n return 1 ; \n memcpy ( dest , s -> current + ( sec << 9 ) , secn << 9 ) ; \n return 0 ; \n }", "idx": 319}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_pop_next_tx_descr ( VMXNET3State * s , \n int qidx , \n struct Vmxnet3_TxDesc * txd , \n uint32_t * descr_idx )  \n { \n Vmxnet3Ring * ring = & s -> txq_descr [ qidx ] . tx_ring ; \n PCIDevice * d = PCI_DEVICE ( s ) ; \n vmxnet3_ring_read_curr_cell ( d , ring , txd ) ; \n if ( txd -> gen == vmxnet3_ring_curr_gen ( ring ) ) { \n smp_rmb ( ) ; \n vmxnet3_ring_read_curr_cell ( d , ring , txd ) ; \n VMXNET3_RING_DUMP ( VMW_RIPRN , \" \" , qidx , ring ) ; \n * descr_idx = vmxnet3_ring_curr_cell_idx ( ring ) ; \n vmxnet3_inc_tx_consumption_counter ( s , qidx ) ; \n return true ; \n } \n return false ; \n }", "idx": 345}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_BookE ( CPUPPCState * env ) \n { \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  env -> excp_vectors [ POWERPC_EXCP_CRITICAL ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_MCHECK ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_DSI ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_ISI ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_EXTERNAL ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_ALIGN ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_PROGRAM ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_FPU ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_SYSCALL ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_APU ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_DECR ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_FIT ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_WDT ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_DTLB ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_ITLB ] = 0x00000000 ; \n env -> excp_vectors [ POWERPC_EXCP_DEBUG ] = 0x00000000 ; \n env -> excp_prefix = 0x00000000 ; \n env -> ivor_mask = 0x0000FFE0 ; \n env -> ivpr_mask = 0xFFFF0000 ; \n env -> hreset_vector = 0xFFFFFFFCUL ; \n #endif \n }", "idx": 346}
{"project": "qemu", "commit_id": "0ccb9c1d8128a020720d5c6abf99a470742a1b94", "target": 1, "func": "DISAS_INSN ( divw ) \n { \n TCGv reg ; \n TCGv tmp ; \n TCGv src ; \n int sign ; \n sign = ( insn & 0x100 ) != 0 ; \n reg = DREG ( insn , 9 ) ; \n if ( sign ) { \n tcg_gen_ext16s_i32 ( QREG_DIV1 , reg ) ; \n } else { \n tcg_gen_ext16u_i32 ( QREG_DIV1 , reg ) ; \n } \n SRC_EA ( env , src , OS_WORD , sign , NULL ) ; \n tcg_gen_mov_i32 ( QREG_DIV2 , src ) ; \n if ( sign ) { \n gen_helper_divs ( cpu_env , tcg_const_i32 ( 1 ) ) ; \n } else { \n gen_helper_divu ( cpu_env , tcg_const_i32 ( 1 ) ) ; \n } \n tmp = tcg_temp_new ( ) ; \n src = tcg_temp_new ( ) ; \n tcg_gen_ext16u_i32 ( tmp , QREG_DIV1 ) ; \n tcg_gen_shli_i32 ( src , QREG_DIV2 , 16 ) ; \n tcg_gen_or_i32 ( reg , tmp , src ) ; \n set_cc_op ( s , CC_OP_FLAGS ) ; \n }", "idx": 354}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static void handle_user_command ( Monitor * mon , const char * cmdline ) \n { \n QDict * qdict ; \n const mon_cmd_t * cmd ; \n qdict = qdict_new ( ) ; \n cmd = monitor_parse_command ( mon , cmdline , 0 , mon -> cmd_table , qdict ) ; \n if ( ! cmd ) \n goto out ; \n if ( handler_is_async ( cmd ) ) { \n user_async_cmd_handler ( mon , cmd , qdict ) ; \n } else if ( handler_is_qobject ( cmd ) ) { \n QObject * data = NULL ; \n cmd -> mhandler . cmd_new ( mon , qdict , & data ) ; \n assert ( ! monitor_has_error ( mon ) ) ; \n if ( data ) { \n cmd -> user_print ( mon , data ) ; \n qobject_decref ( data ) ; \n } \n } else { \n cmd -> mhandler . cmd ( mon , qdict ) ; \n } \n out : \n QDECREF ( qdict ) ; \n }", "idx": 378}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_exception_return ( DisasContext * s , TCGv pc ) \n { \n TCGv tmp ; \n store_reg ( s , 15 , pc ) ; \n tmp = load_cpu_field ( spsr ) ; \n gen_set_cpsr ( tmp , 0xffffffff ) ; \n dead_tmp ( tmp ) ; \n s -> is_jmp = DISAS_UPDATE ; \n }", "idx": 390}
{"project": "qemu", "commit_id": "db0289b9b26cb653d5662f5d6a2a52d70243cd56", "target": 1, "func": "static bool bdrv_drain_recurse ( BlockDriverState * bs , bool begin ) \n { \n BdrvChild * child , * tmp ; \n bool waited ; \n bdrv_drain_invoke ( bs , begin ) ; \n waited = BDRV_POLL_WHILE ( bs , atomic_read ( & bs -> in_flight ) > 0 ) ; \n QLIST_FOREACH_SAFE ( child , & bs -> children , next , tmp )  { \n BlockDriverState * bs = child -> bs ; \n bool in_main_loop = \n qemu_get_current_aio_context ( ) == qemu_get_aio_context ( ) ; \n assert ( bs -> refcnt > 0 ) ; \n if ( in_main_loop ) { \n bdrv_ref ( bs ) ; \n } \n waited |= bdrv_drain_recurse ( bs , begin ) ; \n if ( in_main_loop ) { \n bdrv_unref ( bs ) ; \n } \n } \n return waited ; \n }", "idx": 396}
{"project": "qemu", "commit_id": "ecbb5ea1041d2894f5efb9317acd519c4fd81ad5", "target": 1, "func": "uint64_t helper_sublv ( uint64_t op1 , uint64_t op2 ) \n { \n uint64_t tmp = op1 ; \n op1 = ( uint32_t ) ( op1 - op2 ) ; \n if ( unlikely ( ( ( ~ tmp ) ^ op1 ^ ( -1UL ) ) & ( ( ~ tmp ) ^ op2 ) & ( 1UL << 31 ) ) ) { \n helper_excp ( EXCP_ARITH , EXCP_ARITH_OVERFLOW ) ; \n } \n return op1 ; \n }", "idx": 427}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "void configure_alarms ( char const * opt ) \n { \n int i ; \n int cur = 0 ; \n int count = ARRAY_SIZE ( alarm_timers ) - 1 ; \n char * arg ; \n char * name ; \n struct qemu_alarm_timer tmp ; \n if ( ! strcmp ( opt , \" \" ) ) { \n show_available_alarms ( ) ; \n exit ( 0 ) ; \n } \n arg = g_strdup ( opt ) ; \n name = strtok ( arg , \" \" ) ; \n while ( name ) { \n for ( i = 0 ; i < count && alarm_timers [ i ] . name ; i ++ ) { \n if ( ! strcmp ( alarm_timers [ i ] . name , name ) ) \n break ; \n } \n if ( i == count ) { \n fprintf ( stderr , \" \\n \" , name ) ; \n goto next ; \n } \n if ( i < cur ) \n goto next ; \n tmp = alarm_timers [ i ] ; \n alarm_timers [ i ] = alarm_timers [ cur ] ; \n alarm_timers [ cur ] = tmp ; \n cur ++ ; \n next : \n name = strtok ( NULL , \" \" ) ; \n } \n g_free ( arg ) ; \n if ( cur ) { \n for ( i = cur ; i < count ; i ++ ) \n alarm_timers [ i ] . name = NULL ; \n } else { \n show_available_alarms ( ) ; \n exit ( 1 ) ; \n } \n }", "idx": 449}
{"project": "qemu", "commit_id": "bef0fd5958120542f126f2dedbfce65d8839a94d", "target": 0, "func": "void ide_sector_read ( IDEState * s ) \n { \n int64_t sector_num ; \n int ret , n ; \n s -> status = READY_STAT | SEEK_STAT ; \n s -> error = 0 ; \n sector_num = ide_get_sector ( s ) ; \n n = s -> nsector ; \n if ( n == 0 ) { \n ide_transfer_stop ( s ) ; \n } else { \n #if defined ( DEBUG_IDE )  \n  \n  printf ( \" \" PRId64 \" \\n \" , sector_num ) ; \n #endif \n if ( n > s -> req_nb_sectors ) \n n = s -> req_nb_sectors ; \n bdrv_acct_start ( s -> bs , & s -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; \n ret = bdrv_read ( s -> bs , sector_num , s -> io_buffer , n ) ; \n bdrv_acct_done ( s -> bs , & s -> acct ) ; \n if ( ret != 0 ) { \n if ( ide_handle_rw_error ( s , - ret , \n BM_STATUS_PIO_RETRY | BM_STATUS_RETRY_READ ) ) \n { \n return ; \n } \n } \n ide_transfer_start ( s , s -> io_buffer , 512 * n , ide_sector_read ) ; \n ide_set_irq ( s -> bus ) ; \n ide_set_sector ( s , sector_num + n ) ; \n s -> nsector -= n ; \n } \n }", "idx": 497}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_pio ( ioreq_t * req ) \n { \n int i ; \n if ( req -> dir == IOREQ_READ ) { \n if ( ! req -> data_is_ptr ) { \n req -> data = do_inp ( req -> addr , req -> size ) ; \n } else { \n uint32_t tmp ; \n for ( i = 0 ; i < req -> count ; i ++ ) { \n tmp = do_inp ( req -> addr , req -> size ) ; \n write_phys_req_item ( req -> data , req , i , & tmp ) ; \n } \n } \n } else if ( req -> dir == IOREQ_WRITE ) { \n if ( ! req -> data_is_ptr ) { \n do_outp ( req -> addr , req -> size , req -> data ) ; \n } else { \n for ( i = 0 ; i < req -> count ; i ++ ) { \n uint32_t tmp = 0 ; \n read_phys_req_item ( req -> data , req , i , & tmp ) ; \n do_outp ( req -> addr , req -> size , tmp ) ; \n } \n } \n } \n }", "idx": 498}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_display_character ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n uint8_t c = rtas_ld ( args , 0 ) ; \n VIOsPAPRDevice * sdev = vty_lookup ( spapr , 0 ) ; \n if ( ! sdev ) { \n rtas_st ( rets , 0 , -1 ) ; \n } else { \n vty_putchars ( sdev , & c , sizeof ( c ) ) ; \n rtas_st ( rets , 0 , 0 ) ; \n } \n }", "idx": 512}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_rd_badreq_sectors ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors ) \n { \n return \n nb_sectors < 0 || \n sector_num < 0 || \n nb_sectors > bs -> total_sectors || \n sector_num > bs -> total_sectors - nb_sectors ; \n }", "idx": 521}
{"project": "qemu", "commit_id": "2d40564aaab3a99fe6ce00fc0fc893c02e9443ec", "target": 1, "func": "static int handle_update_file_cred ( int dirfd , const char * name , FsCred * credp ) \n { \n int fd , ret ; \n fd = openat ( dirfd , name , O_NONBLOCK | O_NOFOLLOW ) ; \n if ( fd < 0 ) { \n return fd ; \n } \n ret = fchmod ( fd , credp -> fc_mode & 07777 ) ; \n if ( ret < 0 ) { \n goto err_out ; \n } \n ret = fchownat ( fd , \" \" , credp -> fc_uid , credp -> fc_gid , AT_EMPTY_PATH ) ; \n err_out : \n close ( fd ) ; \n return ret ; \n }", "idx": 526}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop ( void * fdt , const char * node_path , \n const char * property , void * val_array , int size ) \n { \n int offset ; \n offset = fdt_path_offset ( fdt , node_path ) ; \n if ( offset < 0 ) \n return offset ; \n return fdt_setprop ( fdt , offset , property , val_array , size ) ; \n }", "idx": 536}
{"project": "qemu", "commit_id": "c9f4b77ad5783bd84bca4ab99d4b3d6ee61de01c", "target": 1, "func": "static void pc_dimm_check_memdev_is_busy ( Object * obj , const char * name , \n Object * val , Error * * errp ) \n { \n MemoryRegion * mr ; \n mr = host_memory_backend_get_memory ( MEMORY_BACKEND ( val ) , errp ) ; \n if ( memory_region_is_mapped ( mr ) ) { \n char * path = object_get_canonical_path_component ( val ) ; \n error_setg ( errp , \" \" , path ) ; \n g_free ( path ) ; \n } else { \n qdev_prop_allow_set_link_before_realize ( obj , name , val , errp ) ; \n } \n }", "idx": 670}
{"project": "qemu", "commit_id": "83d768b5640946b7da55ce8335509df297e2c7cd", "target": 1, "func": "static void virtio_scsi_complete_req ( VirtIOSCSIReq * req ) \n { \n VirtIOSCSI * s = req -> dev ; \n VirtQueue * vq = req -> vq ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( s ) ; \n qemu_iovec_from_buf ( & req -> resp_iov , 0 , & req -> resp , req -> resp_size ) ; \n virtqueue_push ( vq , & req -> elem , req -> qsgl . size + req -> resp_iov . size ) ; \n if ( s -> dataplane_started && ! s -> dataplane_fenced ) { \n virtio_scsi_dataplane_notify ( vdev , req ) ; \n } else { \n virtio_notify ( vdev , vq ) ; \n } \n if ( req -> sreq ) { \n req -> sreq -> hba_private = NULL ; \n scsi_req_unref ( req -> sreq ) ; \n } \n virtio_scsi_free_req ( req ) ; \n }", "idx": 696}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "static int inet_connect_addr ( struct addrinfo * addr , bool block , \n bool * in_progress ) \n { \n int sock , rc ; \n if ( in_progress ) { \n * in_progress = false ; \n } \n sock = qemu_socket ( addr -> ai_family , addr -> ai_socktype , addr -> ai_protocol ) ; \n if ( sock < 0 ) { \n fprintf ( stderr , \" \\n \" , __func__ , \n inet_strfamily ( addr -> ai_family ) , strerror ( errno ) ) ; \n return -1 ; \n } \n setsockopt ( sock , SOL_SOCKET , SO_REUSEADDR , & on , sizeof ( on ) ) ; \n if ( ! block ) { \n socket_set_nonblock ( sock ) ; \n } \n do { \n rc = 0 ; \n if ( connect ( sock , addr -> ai_addr , addr -> ai_addrlen ) < 0 ) { \n rc = - socket_error ( ) ; \n } \n } while ( rc == - EINTR ) ; \n if ( ! block && QEMU_SOCKET_RC_INPROGRESS ( rc ) ) { \n if ( in_progress ) { \n * in_progress = true ; \n } \n } else if ( rc < 0 ) { \n closesocket ( sock ) ; \n return -1 ; \n } \n return sock ; \n }", "idx": 705}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfci ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n gen_helper_rfci ( cpu_env ) ; \n gen_sync_exception ( ctx ) ; \n #endif \n }", "idx": 712}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void vvfat_close ( BlockDriverState * bs ) \n { \n BDRVVVFATState * s = bs -> opaque ; \n vvfat_close_current_file ( s ) ; \n array_free ( & ( s -> fat ) ) ; \n array_free ( & ( s -> directory ) ) ; \n array_free ( & ( s -> mapping ) ) ; \n if ( s -> cluster_buffer ) \n free ( s -> cluster_buffer ) ; \n }", "idx": 782}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void test_io_channel_setup_sync ( SocketAddressLegacy * listen_addr , \n SocketAddressLegacy * connect_addr , \n QIOChannel * * src , \n QIOChannel * * dst ) \n { \n QIOChannelSocket * lioc ; \n lioc = qio_channel_socket_new ( ) ; \n qio_channel_socket_listen_sync ( lioc , listen_addr , & error_abort ) ; \n if ( listen_addr -> type == SOCKET_ADDRESS_LEGACY_KIND_INET ) { \n SocketAddressLegacy * laddr = qio_channel_socket_get_local_address ( \n lioc , & error_abort ) ; \n g_free ( connect_addr -> u . inet . data -> port ) ; \n connect_addr -> u . inet . data -> port = g_strdup ( laddr -> u . inet . data -> port ) ; \n qapi_free_SocketAddressLegacy ( laddr ) ; \n } \n * src = QIO_CHANNEL ( qio_channel_socket_new ( ) ) ; \n qio_channel_socket_connect_sync ( \n QIO_CHANNEL_SOCKET ( * src ) , connect_addr , & error_abort ) ; \n qio_channel_set_delay ( * src , false ) ; \n qio_channel_wait ( QIO_CHANNEL ( lioc ) , G_IO_IN ) ; \n * dst = QIO_CHANNEL ( qio_channel_socket_accept ( lioc , & error_abort ) ) ; \n g_assert ( * dst ) ; \n test_io_channel_set_socket_bufs ( * src , * dst ) ; \n object_unref ( OBJECT ( lioc ) ) ; \n }", "idx": 814}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void monitor_readline ( const char * prompt , int is_password , \n char * buf , int buf_size ) \n { \n readline_start ( prompt , is_password , monitor_readline_cb , NULL ) ; \n readline_show_prompt ( ) ; \n monitor_readline_buf = buf ; \n monitor_readline_buf_size = buf_size ; \n monitor_readline_started = 1 ; \n while ( monitor_readline_started ) { \n main_loop_wait ( 10 ) ; \n } \n }", "idx": 815}
{"project": "qemu", "commit_id": "72f0d0bf51362011c4d841a89fb8f5cfb16e0bf3", "target": 1, "func": "static int mp_pacl_removexattr ( FsContext * ctx , \n const char * path , const char * name ) \n { \n int ret ; \n char * buffer ; \n buffer = rpath ( ctx , path ) ; \n ret = lremovexattr ( buffer , MAP_ACL_ACCESS ) ; \n if ( ret == -1 && errno == ENODATA ) { \n errno = 0 ; \n ret = 0 ; \n } \n g_free ( buffer ) ; \n return ret ; \n }", "idx": 859}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_load_IRQ_queue ( QEMUFile * f , IRQQueue * q ) \n { \n unsigned int i ; \n for ( i = 0 ; i < BF_WIDTH ( MAX_IRQ ) ; i ++ ) \n qemu_get_be32s ( f , & q -> queue [ i ] ) ; \n qemu_get_sbe32s ( f , & q -> next ) ; \n qemu_get_sbe32s ( f , & q -> priority ) ; \n }", "idx": 882}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pin_cfg_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n struct omap_mpu_state_s * s = ( struct omap_mpu_state_s * ) opaque ; \n if ( size != 4 ) { \n return omap_badwidth_read32 ( opaque , addr ) ; \n } \n switch ( addr ) { \n case 0x00 : \n case 0x04 : \n case 0x08 : \n return s -> func_mux_ctrl [ addr >> 2 ] ; \n case 0x0c : \n return s -> comp_mode_ctrl [ 0 ] ; \n case 0x10 : \n case 0x14 : \n case 0x18 : \n case 0x1c : \n case 0x20 : \n case 0x24 : \n case 0x28 : \n case 0x2c : \n case 0x30 : \n case 0x34 : \n case 0x38 : \n return s -> func_mux_ctrl [ ( addr >> 2 ) - 1 ] ; \n case 0x40 : \n case 0x44 : \n case 0x48 : \n case 0x4c : \n return s -> pull_dwn_ctrl [ ( addr & 0xf ) >> 2 ] ; \n case 0x50 : \n return s -> gate_inh_ctrl [ 0 ] ; \n case 0x60 : \n return s -> voltage_ctrl [ 0 ] ; \n case 0x70 : \n return s -> test_dbg_ctrl [ 0 ] ; \n case 0x80 : \n return s -> mod_conf_ctrl [ 0 ] ; \n } \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 979}
{"project": "qemu", "commit_id": "271a916e8a4188b0ec94bafff18aa93de0047820", "target": 1, "func": "static always_inline void gen_rldimi ( DisasContext * ctx , int mbn , int shn ) \n { \n uint64_t mask ; \n uint32_t sh , mb ; \n sh = SH ( ctx -> opcode ) | ( shn << 5 ) ; \n mb = MB ( ctx -> opcode ) | ( mbn << 5 ) ; \n if ( likely ( sh == 0 ) ) { \n if ( likely ( mb == 0 ) ) { \n gen_op_load_gpr_T0 ( rS ( ctx -> opcode ) ) ; \n goto do_store ; \n } else if ( likely ( mb == 63 ) ) { \n gen_op_load_gpr_T0 ( rA ( ctx -> opcode ) ) ; \n goto do_store ; \n } \n gen_op_load_gpr_T0 ( rS ( ctx -> opcode ) ) ; \n gen_op_load_gpr_T1 ( rA ( ctx -> opcode ) ) ; \n goto do_mask ; \n } \n gen_op_load_gpr_T0 ( rS ( ctx -> opcode ) ) ; \n gen_op_load_gpr_T1 ( rA ( ctx -> opcode ) ) ; \n gen_op_rotli64_T0 ( sh ) ; \n do_mask : \n mask = MASK ( mb , 63 - sh ) ; \n gen_andi_T0_64 ( ctx , mask ) ; \n gen_andi_T1_64 ( ctx , ~ mask ) ; \n gen_op_or ( ) ; \n do_store : \n gen_op_store_T0_gpr ( rA ( ctx -> opcode ) ) ; \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx ) ; \n }", "idx": 1033}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_set_notdirty ( CPUState * env , ram_addr_t ram_addr ) \n { \n LOG_INT ( \" \\n \" , \n ( unsigned long ) ram_addr ) ; \n if ( phys_ram_dirty [ ram_addr >> TARGET_PAGE_BITS ] != 0xff ) \n return ; \n if ( nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE ) \n nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL ; \n else \n ram_pages_to_update [ nb_ram_pages_to_update ++ ] = ram_addr ; \n }", "idx": 1064}
{"project": "qemu", "commit_id": "c34d2451ed32651e14e309f94009be07d231ee96", "target": 1, "func": "static inline int seek_to_sector ( BlockDriverState * bs , int64_t sector_num ) \n { \n BDRVParallelsState * s = bs -> opaque ; \n uint32_t index , offset , position ; \n index = sector_num / s -> tracks ; \n offset = sector_num % s -> tracks ; \n if ( ( index > s -> catalog_size ) || ( s -> catalog_bitmap [ index ] == 0 ) ) \n return -1 ; \n position = ( s -> catalog_bitmap [ index ] + offset ) * 512 ; \n if ( lseek ( s -> fd , position , SEEK_SET ) != position ) \n return -1 ; \n return 0 ; \n }", "idx": 1091}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reload_compare_timer ( IMXEPITState * s ) \n { \n if ( ( s -> cr & ( CR_EN | CR_OCIEN ) ) == ( CR_EN | CR_OCIEN ) ) { \n uint32_t tmp = imx_epit_update_count ( s ) ; \n uint64_t next ; \n if ( tmp > s -> cmp ) { \n next = tmp - s -> cmp ; \n } else { \n next = tmp - s -> cmp + ( ( s -> cr & CR_RLD ) ? TIMER_MAX : s -> lr ) ; \n } \n ptimer_set_count ( s -> timer_cmp , next ) ; \n } \n }", "idx": 1101}
{"project": "qemu", "commit_id": "eca3ed0343ba413937f34ad4f8c4822dc82924e5", "target": 1, "func": "static int handle_intercept ( CPUS390XState * env ) \n { \n struct kvm_run * run = env -> kvm_run ; \n int icpt_code = run -> s390_sieic . icptcode ; \n int r = 0 ; \n dprintf ( \" \\n \" , icpt_code , \n ( long ) env -> kvm_run -> psw_addr ) ; \n switch ( icpt_code ) { \n case ICPT_INSTRUCTION : \n r = handle_instruction ( env , run ) ; \n case ICPT_WAITPSW : \n case ICPT_CPU_STOP : \n if ( s390_del_running_cpu ( env ) == 0 ) { \n case ICPT_SOFT_INTERCEPT : \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n case ICPT_IO : \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n default : \n fprintf ( stderr , \" \\n \" , icpt_code ) ; \n exit ( 1 ) ; \n return r ;", "idx": 1131}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static gboolean qio_channel_websock_handshake_send ( QIOChannel * ioc , \n GIOCondition condition , \n gpointer user_data ) \n { \n QIOTask * task = user_data ; \n QIOChannelWebsock * wioc = QIO_CHANNEL_WEBSOCK ( \n qio_task_get_source ( task ) ) ; \n Error * err = NULL ; \n ssize_t ret ; \n ret = qio_channel_write ( wioc -> master , \n ( char * ) wioc -> encoutput . buffer , \n wioc -> encoutput . offset , \n & err ) ; \n if ( ret < 0 ) { \n trace_qio_channel_websock_handshake_fail ( ioc ) ; \n qio_task_set_error ( task , err ) ; \n qio_task_complete ( task ) ; \n return FALSE ; \n } \n buffer_advance ( & wioc -> encoutput , ret ) ; \n if ( wioc -> encoutput . offset == 0 ) { \n trace_qio_channel_websock_handshake_complete ( ioc ) ; \n qio_task_complete ( task ) ; \n return FALSE ; \n } \n trace_qio_channel_websock_handshake_pending ( ioc , G_IO_OUT ) ; \n return TRUE ; \n }", "idx": 1150}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_uint8 ( TestInputVisitorData * data , \n const void * unused ) \n { \n test_native_list_integer_helper ( data , unused , \n USER_DEF_NATIVE_LIST_UNION_KIND_U8 ) ; \n }", "idx": 1161}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_disk_class_initfn ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n SCSIDeviceClass * sc = SCSI_DEVICE_CLASS ( klass ) ; \n sc -> init = scsi_disk_initfn ; \n sc -> destroy = scsi_destroy ; \n sc -> alloc_req = scsi_new_request ; \n sc -> unit_attention_reported = scsi_disk_unit_attention_reported ; \n dc -> fw_name = \" \" ; \n dc -> desc = \" \" ; \n dc -> reset = scsi_disk_reset ; \n dc -> props = scsi_disk_properties ; \n dc -> vmsd = & vmstate_scsi_disk_state ; \n }", "idx": 1180}
{"project": "qemu", "commit_id": "5add35bec1e249bb5345a47008c8f298d4760be4", "target": 0, "func": "static void test_tco2_status_bits ( void ) \n { \n TestData d ; \n uint16_t ticks = 8 ; \n uint16_t val ; \n int ret ; \n d . args = \" \" ; \n test_init ( & d ) ; \n stop_tco ( & d ) ; \n clear_tco_status ( & d ) ; \n reset_on_second_timeout ( true ) ; \n set_tco_timeout ( & d , ticks ) ; \n load_tco ( & d ) ; \n start_tco ( & d ) ; \n clock_step ( ticks * TCO_TICK_NSEC * 2 ) ; \n val = qpci_io_readw ( d . dev , d . tco_io_base + TCO2_STS ) ; \n ret = val & ( TCO_SECOND_TO_STS | TCO_BOOT_STS ) ? 1 : 0 ; \n g_assert ( ret == 1 ) ; \n qpci_io_writew ( d . dev , d . tco_io_base + TCO2_STS , val ) ; \n g_assert_cmpint ( qpci_io_readw ( d . dev , d . tco_io_base + TCO2_STS ) , == , 0 ) ; \n qtest_end ( ) ; \n }", "idx": 1193}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "int bdrv_child_check_perm ( BdrvChild * c , uint64_t perm , uint64_t shared , \n Error * * errp ) \n { \n return bdrv_check_update_perm ( c -> bs , perm , shared , c , errp ) ; \n }", "idx": 1219}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_flush_cb ( void * opaque , int ret ) \n { \n IDEState * s = opaque ; \n s -> pio_aiocb = NULL ; \n if ( ret == - ECANCELED ) { \n return ; \n } \n if ( ret < 0 ) { \n if ( ide_handle_rw_error ( s , - ret , IDE_RETRY_FLUSH ) ) { \n return ; \n } \n } \n if ( s -> bs ) { \n block_acct_done ( bdrv_get_stats ( s -> bs ) , & s -> acct ) ; \n } \n s -> status = READY_STAT | SEEK_STAT ; \n ide_cmd_done ( s ) ; \n ide_set_irq ( s -> bus ) ; \n }", "idx": 1249}
{"project": "qemu", "commit_id": "adbecc89731cf3e0ae656d50ea9fa58c589c4bdc", "target": 0, "func": "static int ehci_init_transfer ( EHCIPacket * p ) \n { \n uint32_t cpage , offset , bytes , plen ; \n dma_addr_t page ; \n USBBus * bus = & p -> queue -> ehci -> bus ; \n BusState * qbus = BUS ( bus ) ; \n cpage = get_field ( p -> qtd . token , QTD_TOKEN_CPAGE ) ; \n bytes = get_field ( p -> qtd . token , QTD_TOKEN_TBYTES ) ; \n offset = p -> qtd . bufptr [ 0 ] & ~ QTD_BUFPTR_MASK ; \n qemu_sglist_init ( & p -> sgl , qbus -> parent , 5 , p -> queue -> ehci -> as ) ; \n while ( bytes > 0 ) { \n if ( cpage > 4 ) { \n fprintf ( stderr , \" \\n \" , cpage ) ; \n return -1 ; \n } \n page = p -> qtd . bufptr [ cpage ] & QTD_BUFPTR_MASK ; \n page += offset ; \n plen = bytes ; \n if ( plen > 4096 - offset ) { \n plen = 4096 - offset ; \n offset = 0 ; \n cpage ++ ; \n } \n qemu_sglist_add ( & p -> sgl , page , plen ) ; \n bytes -= plen ; \n } \n return 0 ; \n }", "idx": 1265}
{"project": "qemu", "commit_id": "260fecf13b0d30621dc88da03dc1b502b7358c6b", "target": 0, "func": "BdrvChild * bdrv_open_child ( const char * filename , \n QDict * options , const char * bdref_key , \n BlockDriverState * parent , \n const BdrvChildRole * child_role , \n bool allow_none , Error * * errp ) \n { \n BdrvChild * c = NULL ; \n BlockDriverState * bs ; \n QDict * image_options ; \n int ret ; \n char * bdref_key_dot ; \n const char * reference ; \n assert ( child_role != NULL ) ; \n bdref_key_dot = g_strdup_printf ( \" \" , bdref_key ) ; \n qdict_extract_subqdict ( options , & image_options , bdref_key_dot ) ; \n g_free ( bdref_key_dot ) ; \n reference = qdict_get_try_str ( options , bdref_key ) ; \n if ( ! filename && ! reference && ! qdict_size ( image_options ) ) { \n if ( ! allow_none ) { \n error_setg ( errp , \" \\\" \\\" \" , \n bdref_key ) ; \n } \n QDECREF ( image_options ) ; \n goto done ; \n } \n bs = NULL ; \n ret = bdrv_open_inherit ( & bs , filename , reference , image_options , 0 , \n parent , child_role , errp ) ; \n if ( ret < 0 ) { \n goto done ; \n } \n c = bdrv_attach_child ( parent , bs , child_role ) ; \n done : \n qdict_del ( options , bdref_key ) ; \n return c ; \n }", "idx": 1292}
{"project": "qemu", "commit_id": "4c1396cb576c9b14425558b73de1584c7a9735d7", "target": 1, "func": "static void vapic_write ( void * opaque , hwaddr addr , uint64_t data , \n unsigned int size ) \n { \n CPUState * cs = current_cpu ; \n X86CPU * cpu = X86_CPU ( cs ) ; \n CPUX86State * env = & cpu -> env ; \n hwaddr rom_paddr ; \n VAPICROMState * s = opaque ; \n cpu_synchronize_state ( cs ) ; \n switch ( size ) { \n case 2 : \n if ( s -> state == VAPIC_INACTIVE ) { \n rom_paddr = ( env -> segs [ R_CS ] . base + env -> eip ) & ROM_BLOCK_MASK ; \n s -> rom_state_paddr = rom_paddr + data ; \n s -> state = VAPIC_STANDBY ; \n } \n if ( vapic_prepare ( s ) < 0 ) { \n s -> state = VAPIC_INACTIVE ; \n s -> rom_state_paddr = 0 ; \n break ; \n } \n break ; \n case 1 : \n if ( kvm_enabled ( ) ) { \n pause_all_vcpus ( ) ; \n patch_byte ( cpu , env -> eip - 2 , 0x66 ) ; \n patch_byte ( cpu , env -> eip - 1 , 0x90 ) ; \n resume_all_vcpus ( ) ; \n } \n if ( s -> state == VAPIC_ACTIVE ) { \n break ; \n } \n if ( update_rom_mapping ( s , env , env -> eip ) < 0 ) { \n break ; \n } \n if ( find_real_tpr_addr ( s , env ) < 0 ) { \n break ; \n } \n vapic_enable ( s , cpu ) ; \n break ; \n default : \n case 4 : \n if ( ! kvm_irqchip_in_kernel ( ) ) { \n apic_poll_irq ( cpu -> apic_state ) ; \n } \n break ; \n } \n }", "idx": 1337}
{"project": "qemu", "commit_id": "7c72ac49ae9f38fa0125296e05988655157decb5", "target": 0, "func": "static bool riccb_needed ( void * opaque ) \n { \n #ifdef CONFIG_KVM \n if ( kvm_enabled ( ) ) { \n return kvm_s390_get_ri ( ) ; \n } \n #endif \n return 0 ; \n }", "idx": 1347}
{"project": "qemu", "commit_id": "8a0e11045d5f50d300e0ab1ba05f4c8217fb5dcb", "target": 0, "func": "PCIBus * pci_pmac_u3_init ( qemu_irq * pic , \n MemoryRegion * address_space_mem , \n MemoryRegion * address_space_io ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n PCIHostState * h ; \n UNINState * d ; \n dev = qdev_create ( NULL , TYPE_U3_AGP_HOST_BRIDGE ) ; \n qdev_init_nofail ( dev ) ; \n s = SYS_BUS_DEVICE ( dev ) ; \n h = PCI_HOST_BRIDGE ( dev ) ; \n d = U3_AGP_HOST_BRIDGE ( dev ) ; \n memory_region_init ( & d -> pci_mmio , OBJECT ( d ) , \" \" , 0x100000000ULL ) ; \n memory_region_init_alias ( & d -> pci_hole , OBJECT ( d ) , \" \" , & d -> pci_mmio , \n 0x80000000ULL , 0x70000000ULL ) ; \n memory_region_add_subregion ( address_space_mem , 0x80000000ULL , \n & d -> pci_hole ) ; \n h -> bus = pci_register_bus ( dev , \" \" , \n pci_unin_set_irq , pci_unin_map_irq , \n pic , \n & d -> pci_mmio , \n address_space_io , \n PCI_DEVFN ( 11 , 0 ) , 4 , TYPE_PCI_BUS ) ; \n sysbus_mmio_map ( s , 0 , 0xf0800000 ) ; \n sysbus_mmio_map ( s , 1 , 0xf0c00000 ) ; \n pci_create_simple ( h -> bus , 11 << 3 , \" \" ) ; \n return h -> bus ; \n }", "idx": 1366}
{"project": "qemu", "commit_id": "0e438cdc932a785de72166af4641aafa103a6670", "target": 1, "func": "void coroutine_fn qemu_co_mutex_lock ( CoMutex * mutex ) \n { \n Coroutine * self = qemu_coroutine_self ( ) ; \n trace_qemu_co_mutex_lock_entry ( mutex , self ) ; \n while ( mutex -> locked ) { \n qemu_co_queue_wait ( & mutex -> queue ) ; \n } \n mutex -> locked = true ; \n trace_qemu_co_mutex_lock_return ( mutex , self ) ; \n }", "idx": 1385}
{"project": "qemu", "commit_id": "962d4b2834e6a3b37784391a906b5fe2a7e96b74", "target": 1, "func": "static void fw_cfg_write ( FWCfgState * s , uint8_t value ) \n { \n int arch = ! ! ( s -> cur_entry & FW_CFG_ARCH_LOCAL ) ; \n FWCfgEntry * e = & s -> entries [ arch ] [ s -> cur_entry & FW_CFG_ENTRY_MASK ] ; \n FW_CFG_DPRINTF ( \" \\n \" , value ) ; \n if ( s -> cur_entry & FW_CFG_WRITE_CHANNEL && s -> cur_offset < e -> len ) { \n e -> data [ s -> cur_offset ++ ] = value ; \n if ( s -> cur_offset == e -> len ) { \n e -> callback ( e -> callback_opaque , e -> data ) ; \n s -> cur_offset = 0 ; \n } \n } \n }", "idx": 1407}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "func": "int qemu_peek_buffer ( QEMUFile * f , uint8_t * buf , int size , size_t offset ) \n { \n int pending ; \n int index ; \n assert ( ! qemu_file_is_writable ( f ) ) ; \n index = f -> buf_index + offset ; \n pending = f -> buf_size - index ; \n if ( pending < size ) { \n qemu_fill_buffer ( f ) ; \n index = f -> buf_index + offset ; \n pending = f -> buf_size - index ; \n } \n if ( pending <= 0 ) { \n return 0 ; \n } \n if ( size > pending ) { \n size = pending ; \n } \n memcpy ( buf , f -> buf + index , size ) ; \n return size ; \n }", "idx": 1409}
{"project": "qemu", "commit_id": "61f52e06f0a21bab782f98ef3ea789aa6d0aa046", "target": 1, "func": "static int ahci_dma_rw_buf ( IDEDMA * dma , int is_write ) \n { \n AHCIDevice * ad = DO_UPCAST ( AHCIDevice , dma , dma ) ; \n IDEState * s = & ad -> port . ifs [ 0 ] ; \n uint8_t * p = s -> io_buffer + s -> io_buffer_index ; \n int l = s -> io_buffer_size - s -> io_buffer_index ; \n if ( ahci_populate_sglist ( ad , & s -> sg ) ) { \n return 0 ; \n } \n if ( is_write ) { \n dma_buf_read ( p , l , & s -> sg ) ; \n } else { \n dma_buf_write ( p , l , & s -> sg ) ; \n } \n ad -> cur_cmd -> status = cpu_to_le32 ( le32_to_cpu ( ad -> cur_cmd -> status ) + l ) ; \n s -> io_buffer_index += l ; \n DPRINTF ( ad -> port_no , \" \\n \" , l ) ; \n return 1 ; \n }", "idx": 1410}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static DeviceState * sun4c_intctl_init ( target_phys_addr_t addr , \n qemu_irq * parent_irq ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n unsigned int i ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_init ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n for ( i = 0 ; i < MAX_PILS ; i ++ ) { \n sysbus_connect_irq ( s , i , parent_irq [ i ] ) ; \n } \n sysbus_mmio_map ( s , 0 , addr ) ; \n return dev ; \n }", "idx": 1418}
{"project": "qemu", "commit_id": "fff895dfdbe41965f7b0430e3d9e8b7bd8fc8eda", "target": 1, "func": "static bool adding_first_cpu ( void ) \n { \n CPUState * cpu ; \n size_t count = 0 ; \n CPU_FOREACH ( cpu ) { \n count ++ ; \n if ( count > 1 ) { \n return false ; \n } \n } \n return true ; \n }", "idx": 1451}
{"project": "qemu", "commit_id": "b1b1dad31f3a092e046b09795f4476705c4e564e", "target": 1, "func": "static int aio_write_f ( int argc , char * * argv ) \n { \n int nr_iov , c ; \n int pattern = 0xcd ; \n struct aio_ctx * ctx = calloc ( 1 , sizeof ( struct aio_ctx ) ) ; \n BlockDriverAIOCB * acb ; \n while ( ( c = getopt ( argc , argv , \" \" ) ) != EOF ) { \n switch ( c ) { \n case ' ' : \n ctx -> Cflag = 1 ; \n break ; \n case ' ' : \n ctx -> qflag = 1 ; \n break ; \n case ' ' : \n pattern = parse_pattern ( optarg ) ; \n if ( pattern < 0 ) { \n return 0 ; \n } \n break ; \n default : \n return command_usage ( & aio_write_cmd ) ; \n } \n } \n if ( optind > argc - 2 ) { \n return command_usage ( & aio_write_cmd ) ; \n } \n ctx -> offset = cvtnum ( argv [ optind ] ) ; \n if ( ctx -> offset < 0 ) { \n printf ( \" \\n \" , argv [ optind ] ) ; \n return 0 ; \n } \n optind ++ ; \n if ( ctx -> offset & 0x1ff ) { \n printf ( \" \" PRId64 \" \\n \" , \n ctx -> offset ) ; \n return 0 ; \n } \n nr_iov = argc - optind ; \n ctx -> buf = create_iovec ( & ctx -> qiov , & argv [ optind ] , nr_iov , pattern ) ; \n gettimeofday ( & ctx -> t1 , NULL ) ; \n acb = bdrv_aio_writev ( bs , ctx -> offset >> 9 , & ctx -> qiov , \n ctx -> qiov . size >> 9 , aio_write_done , ctx ) ; \n if ( ! acb ) { \n free ( ctx -> buf ) ; \n return - EIO ; \n } \n return 0 ; \n }", "idx": 1509}
{"project": "qemu", "commit_id": "924e8a2bbc7cc62b3996efe9a2a460f541c04520", "target": 1, "func": "static coroutine_fn int quorum_co_flush ( BlockDriverState * bs ) \n { \n BDRVQuorumState * s = bs -> opaque ; \n QuorumVoteVersion * winner = NULL ; \n QuorumVotes error_votes ; \n QuorumVoteValue result_value ; \n int i ; \n int result = 0 ; \n QLIST_INIT ( & error_votes . vote_list ) ; \n error_votes . compare = quorum_64bits_compare ; \n for ( i = 0 ; i < s -> num_children ; i ++ ) { \n result = bdrv_co_flush ( s -> children [ i ] -> bs ) ; \n result_value . l = result ; \n quorum_count_vote ( & error_votes , & result_value , i ) ; \n } \n winner = quorum_get_vote_winner ( & error_votes ) ; \n result = winner -> value . l ; \n quorum_free_vote_list ( & error_votes ) ; \n return result ; \n }", "idx": 1528}
{"project": "qemu", "commit_id": "9456c2fbcd82dd82328ac6e7602a815582b1043e", "target": 0, "func": "void r4k_helper_tlbr ( CPUMIPSState * env ) \n { \n r4k_tlb_t * tlb ; \n uint8_t ASID ; \n int idx ; \n ASID = env -> CP0_EntryHi & 0xFF ; \n idx = ( env -> CP0_Index & ~ 0x80000000 ) % env -> tlb -> nb_tlb ; \n tlb = & env -> tlb -> mmu . r4k . tlb [ idx ] ; \n if ( ASID != tlb -> ASID ) \n cpu_mips_tlb_flush ( env , 1 ) ; \n r4k_mips_tlb_flush_extra ( env , env -> tlb -> nb_tlb ) ; \n env -> CP0_EntryHi = tlb -> VPN | tlb -> ASID ; \n env -> CP0_PageMask = tlb -> PageMask ; \n env -> CP0_EntryLo0 = tlb -> G | ( tlb -> V0 << 1 ) | ( tlb -> D0 << 2 ) | \n ( ( target_ulong ) tlb -> RI0 << CP0EnLo_RI ) | \n ( ( target_ulong ) tlb -> XI0 << CP0EnLo_XI ) | \n ( tlb -> C0 << 3 ) | ( tlb -> PFN [ 0 ] >> 6 ) ; \n env -> CP0_EntryLo1 = tlb -> G | ( tlb -> V1 << 1 ) | ( tlb -> D1 << 2 ) | \n ( ( target_ulong ) tlb -> RI1 << CP0EnLo_RI ) | \n ( ( target_ulong ) tlb -> XI1 << CP0EnLo_XI ) | \n ( tlb -> C1 << 3 ) | ( tlb -> PFN [ 1 ] >> 6 ) ; \n }", "idx": 1565}
{"project": "qemu", "commit_id": "0ce470cd4ca88e84e547a3b95159d23ce6be419e", "target": 0, "func": "int kvmppc_fixup_cpu ( PowerPCCPU * cpu ) \n { \n CPUState * cs = CPU ( cpu ) ; \n int smt ; \n smt = kvmppc_smt_threads ( ) ; \n cs -> cpu_index = ( cs -> cpu_index / smp_threads ) * smt \n + ( cs -> cpu_index % smp_threads ) ; \n return 0 ; \n }", "idx": 1572}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_flush ( void * opaque ) \n { \n int16_t tag ; \n size_t offset = 7 ; \n V9fsPDU * cancel_pdu ; \n V9fsPDU * pdu = opaque ; \n V9fsState * s = pdu -> s ; \n pdu_unmarshal ( pdu , offset , \" \" , & tag ) ; \n QLIST_FOREACH ( cancel_pdu , & s -> active_list , next )  { \n if ( cancel_pdu -> tag == tag ) { \n break ; \n } \n } \n if ( cancel_pdu ) { \n cancel_pdu -> cancelled = 1 ; \n qemu_co_queue_wait ( & cancel_pdu -> complete ) ; \n cancel_pdu -> cancelled = 0 ; \n free_pdu ( pdu -> s , cancel_pdu ) ; \n } \n complete_pdu ( s , pdu , 7 ) ; \n return ; \n }", "idx": 1673}
{"project": "qemu", "commit_id": "e8ca1db29b349e780743c504cb735c8e1d542a8c", "target": 1, "func": "void qemu_savevm_send_postcopy_advise ( QEMUFile * f ) \n { \n uint64_t tmp [ 2 ] ; \n tmp [ 0 ] = cpu_to_be64 ( getpagesize ( ) ) ; \n tmp [ 1 ] = cpu_to_be64 ( 1ul << qemu_target_page_bits ( ) ) ; \n trace_qemu_savevm_send_postcopy_advise ( ) ; \n qemu_savevm_command_send ( f , MIG_CMD_POSTCOPY_ADVISE , 16 , ( uint8_t * ) tmp ) ; \n }", "idx": 1675}
{"project": "qemu", "commit_id": "4bac52f5c4b3dd5d0bd7568377ad7e957d5e3c6a", "target": 1, "func": "static void add_qemu_cpu_model_features ( S390FeatBitmap fbm ) \n { \n static const int feats [ ] = { \n S390_FEAT_DAT_ENH , \n S390_FEAT_IDTE_SEGMENT , \n S390_FEAT_STFLE , \n S390_FEAT_SENSE_RUNNING_STATUS , \n S390_FEAT_EXTENDED_IMMEDIATE , \n S390_FEAT_EXTENDED_TRANSLATION_2 , \n S390_FEAT_MSA , \n S390_FEAT_EXTENDED_TRANSLATION_3 , \n S390_FEAT_LONG_DISPLACEMENT , \n S390_FEAT_LONG_DISPLACEMENT_FAST , \n S390_FEAT_ETF2_ENH , \n S390_FEAT_STORE_CLOCK_FAST , \n S390_FEAT_MOVE_WITH_OPTIONAL_SPEC , \n S390_FEAT_ETF3_ENH , \n S390_FEAT_COMPARE_AND_SWAP_AND_STORE , \n S390_FEAT_COMPARE_AND_SWAP_AND_STORE_2 , \n S390_FEAT_GENERAL_INSTRUCTIONS_EXT , \n S390_FEAT_EXECUTE_EXT , \n S390_FEAT_FLOATING_POINT_SUPPPORT_ENH , \n S390_FEAT_STFLE_45 , \n S390_FEAT_STFLE_49 , \n S390_FEAT_LOCAL_TLB_CLEARING , \n S390_FEAT_INTERLOCKED_ACCESS_2 , \n S390_FEAT_STFLE_53 , \n S390_FEAT_MSA_EXT_5 , \n S390_FEAT_MSA_EXT_3 , \n S390_FEAT_MSA_EXT_4 , \n } ; \n int i ; \n for ( i = 0 ; i < ARRAY_SIZE ( feats ) ; i ++ ) { \n set_bit ( feats [ i ] , fbm ) ; \n } \n }", "idx": 1677}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_decr ( const struct MonitorDef * md , int val ) \n { \n CPUState * env = mon_get_cpu ( ) ; \n if ( ! env ) \n return 0 ; \n return cpu_ppc_load_decr ( env ) ; \n }", "idx": 1683}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST ( qobject_to_qlist_test ) \n { \n QList * qlist ; \n qlist = qlist_new ( ) ; \n fail_unless ( qobject_to_qlist ( QOBJECT ( qlist ) ) == qlist ) ; \n g_free ( qlist ) ; \n }", "idx": 1688}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "CharDriverState * qemu_chr_find ( const char * name ) \n { \n CharDriverState * chr ; \n TAILQ_FOREACH ( chr , & chardevs , next )  { \n if ( strcmp ( chr -> label , name ) != 0 ) \n continue ; \n return chr ; \n } \n return NULL ; \n }", "idx": 1701}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "static void vm_completion ( ReadLineState * rs , const char * str ) \n { \n size_t len ; \n BlockDriverState * bs ; \n BdrvNextIterator * it = NULL ; \n len = strlen ( str ) ; \n readline_set_completion_index ( rs , len ) ; \n while ( ( it = bdrv_next ( it , & bs ) ) ) { \n SnapshotInfoList * snapshots , * snapshot ; \n AioContext * ctx = bdrv_get_aio_context ( bs ) ; \n bool ok = false ; \n aio_context_acquire ( ctx ) ; \n if ( bdrv_can_snapshot ( bs ) ) { \n ok = bdrv_query_snapshot_info_list ( bs , & snapshots , NULL ) == 0 ; \n } \n aio_context_release ( ctx ) ; \n if ( ! ok ) { \n continue ; \n } \n snapshot = snapshots ; \n while ( snapshot ) { \n char * completion = snapshot -> value -> name ; \n if ( ! strncmp ( str , completion , len ) ) { \n readline_add_completion ( rs , completion ) ; \n } \n completion = snapshot -> value -> id ; \n if ( ! strncmp ( str , completion , len ) ) { \n readline_add_completion ( rs , completion ) ; \n } \n snapshot = snapshot -> next ; \n } \n qapi_free_SnapshotInfoList ( snapshots ) ; \n } \n }", "idx": 1750}
{"project": "qemu", "commit_id": "229609dd45ee572fb343366a5bf440afb25cf614", "target": 1, "func": "static int check_for_evdev ( void ) \n { \n SDL_SysWMinfo info ; \n XkbDescPtr desc ; \n int has_evdev = 0 ; \n const char * keycodes ; \n SDL_VERSION ( & info . version ) ; \n if ( ! SDL_GetWMInfo ( & info ) ) \n return 0 ; \n desc = XkbGetKeyboard ( info . info . x11 . display , \n XkbGBN_AllComponentsMask , \n XkbUseCoreKbd ) ; \n if ( desc == NULL || desc -> names == NULL ) \n return 0 ; \n keycodes = XGetAtomName ( info . info . x11 . display , desc -> names -> keycodes ) ; \n if ( keycodes == NULL ) \n fprintf ( stderr , \" \\n \" ) ; \n else if ( strstart ( keycodes , \" \" , NULL ) ) \n has_evdev = 1 ; \n else if ( ! strstart ( keycodes , \" \" , NULL ) ) \n fprintf ( stderr , \n \" \\n \" , \n keycodes ) ; \n XkbFreeClientMap ( desc , XkbGBN_AllComponentsMask , True ) ; \n return has_evdev ; \n }", "idx": 1787}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult memory_region_oldmmio_read_accessor ( MemoryRegion * mr , \n hwaddr addr , \n uint64_t * value , \n unsigned size , \n unsigned shift , \n uint64_t mask , \n MemTxAttrs attrs ) \n { \n uint64_t tmp ; \n tmp = mr -> ops -> old_mmio . read [ ctz32 ( size ) ] ( mr -> opaque , addr ) ; \n if ( mr -> subpage ) { \n trace_memory_region_subpage_read ( get_cpu_index ( ) , mr , addr , tmp , size ) ; \n } else if ( TRACE_MEMORY_REGION_OPS_READ_ENABLED ) { \n hwaddr abs_addr = memory_region_to_absolute_addr ( mr , addr ) ; \n trace_memory_region_ops_read ( get_cpu_index ( ) , mr , abs_addr , tmp , size ) ; \n } \n * value |= ( tmp & mask ) << shift ; \n return MEMTX_OK ; \n }", "idx": 1798}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_spciconf_readb ( void * opaque , target_phys_addr_t addr ) \n { \n PCIBonitoState * s = opaque ; \n uint32_t pciaddr ; \n uint16_t status ; \n DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n pciaddr = bonito_sbridge_pciaddr ( s , addr ) ; \n if ( pciaddr == 0xffffffff ) { \n return 0xff ; \n } \n s -> pcihost -> config_reg = ( pciaddr ) | ( 1u << 31 ) ; \n status = pci_get_word ( s -> dev . config + PCI_STATUS ) ; \n status &= ~ ( PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT ) ; \n pci_set_word ( s -> dev . config + PCI_STATUS , status ) ; \n return pci_data_read ( s -> pcihost -> bus , s -> pcihost -> config_reg , 1 ) ; \n }", "idx": 1851}
{"project": "qemu", "commit_id": "e3cb6ba65d265f2cc1313ee26e879407ff24663c", "target": 0, "func": "static void qdev_get_legacy_property ( DeviceState * dev , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n Property * prop = opaque ; \n if ( prop -> info -> print ) { \n char buffer [ 1024 ] ; \n char * ptr = buffer ; \n prop -> info -> print ( dev , prop , buffer , sizeof ( buffer ) ) ; \n visit_type_str ( v , & ptr , name , errp ) ; \n } else { \n error_set ( errp , QERR_PERMISSION_DENIED ) ; \n } \n }", "idx": 1856}
{"project": "qemu", "commit_id": "6ee5920243cc5fe35d219fa2883a673b91808c0f", "target": 0, "func": "START_TEST ( escaped_string ) \n { \n int i ; \n struct { \n const char * encoded ; \n const char * decoded ; \n } test_cases [ ] = { \n { \" \\\" \\\\ \\\" \\\" \" , \" \\\" \" } , \n { \" \\\" \\\\ \\\" \\\\ \\\" \\\" \" , \n \" \\\" \\\" \" } , \n { \" \\\" \\\\ \\\" \" , \" \\n \" } , \n { \" \\\" \\\\ \\\" \" , \" \" } , \n { \" \\\" \\\\ \\\" \" , \" \\xc2 \\xa2 \" } , \n { \" \\\" \\\\ \\\" \" , \" \\xe2 \\x82 \\xac \" } , \n { } \n } ; \n for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { \n QObject * obj ; \n QString * str ; \n obj = qobject_from_json ( test_cases [ i ] . encoded ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QSTRING ) ; \n str = qobject_to_qstring ( obj ) ; \n fail_unless ( strcmp ( qstring_get_str ( str ) , test_cases [ i ] . decoded ) == 0 ) ; \n QDECREF ( str ) ; \n } \n }", "idx": 1914}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_mrs ( DisasContext * s , uint32_t insn , unsigned int op0 , \n unsigned int op1 , unsigned int op2 , \n unsigned int crn , unsigned int crm , unsigned int rt ) \n { \n unsupported_encoding ( s , insn ) ; \n }", "idx": 1915}
{"project": "qemu", "commit_id": "0fbc20740342713f282b118b4a446c4c43df3f4a", "target": 1, "func": "int kvm_irqchip_add_msi_route ( KVMState * s , MSIMessage msg ) \n { \n struct kvm_irq_routing_entry kroute ; \n int virq ; \n if ( ! kvm_gsi_routing_enabled ( ) ) { \n return - ENOSYS ; \n } \n virq = kvm_irqchip_get_virq ( s ) ; \n if ( virq < 0 ) { \n return virq ; \n } \n kroute . gsi = virq ; \n kroute . type = KVM_IRQ_ROUTING_MSI ; \n kroute . flags = 0 ; \n kroute . u . msi . address_lo = ( uint32_t ) msg . address ; \n kroute . u . msi . address_hi = msg . address >> 32 ; \n kroute . u . msi . data = le32_to_cpu ( msg . data ) ; \n kvm_add_routing_entry ( s , & kroute ) ; \n kvm_irqchip_commit_routes ( s ) ; \n return virq ; \n }", "idx": 1956}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_sigreturn ( CPUS390XState * env ) \n { \n sigframe * frame ; \n abi_ulong frame_addr = env -> regs [ 15 ] ; \n target_sigset_t target_set ; \n sigset_t set ; \n trace_user_do_sigreturn ( env , frame_addr ) ; \n if ( ! lock_user_struct ( VERIFY_READ , frame , frame_addr , 1 ) ) { \n goto badframe ; \n } \n __get_user ( target_set . sig [ 0 ] , & frame -> sc . oldmask [ 0 ] ) ; \n target_to_host_sigset_internal ( & set , & target_set ) ; \n set_sigmask ( & set ) ; \n if ( restore_sigregs ( env , & frame -> sregs ) ) { \n goto badframe ; \n } \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n return - TARGET_QEMU_ESIGRETURN ; \n badframe : \n force_sig ( TARGET_SIGSEGV ) ; \n return 0 ; \n }", "idx": 2014}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST ( qobject_to_qint_test ) \n { \n QInt * qi ; \n qi = qint_from_int ( 0 ) ; \n fail_unless ( qobject_to_qint ( QOBJECT ( qi ) ) == qi ) ; \n QDECREF ( qi ) ; \n }", "idx": 2034}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_label ( TCGContext * s , TCGLabel * l , tcg_insn_unit * ptr ) \n { \n intptr_t value = ( intptr_t ) ptr ; \n TCGRelocation * r ; \n assert ( ! l -> has_value ) ; \n for ( r = l -> u . first_reloc ; r != NULL ; r = r -> next ) { \n patch_reloc ( r -> ptr , r -> type , value , r -> addend ) ; \n } \n l -> has_value = 1 ; \n l -> u . value_ptr = ptr ; \n }", "idx": 2055}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState * bdrv_lookup_bs ( const char * device , \n const char * node_name , \n Error * * errp ) \n { \n BlockBackend * blk ; \n BlockDriverState * bs ; \n if ( device ) { \n blk = blk_by_name ( device ) ; \n if ( blk ) { \n return blk_bs ( blk ) ; \n } \n } \n if ( node_name ) { \n bs = bdrv_find_node ( node_name ) ; \n if ( bs ) { \n return bs ; \n } \n } \n error_setg ( errp , \" \" , \n device ? device : \" \" , \n node_name ? node_name : \" \" ) ; \n return NULL ; \n }", "idx": 2068}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int qcow2_set_up_encryption ( BlockDriverState * bs , const char * encryptfmt , \n QemuOpts * opts , Error * * errp ) \n { \n BDRVQcow2State * s = bs -> opaque ; \n QCryptoBlockCreateOptions * cryptoopts = NULL ; \n QCryptoBlock * crypto = NULL ; \n int ret = - EINVAL ; \n QDict * options , * encryptopts ; \n options = qemu_opts_to_qdict ( opts , NULL ) ; \n qdict_extract_subqdict ( options , & encryptopts , \" \" ) ; \n QDECREF ( options ) ; \n if ( ! g_str_equal ( encryptfmt , \" \" ) ) { \n error_setg ( errp , \" \" , \n encryptfmt ) ; \n ret = - EINVAL ; \n goto out ; \n } \n cryptoopts = block_crypto_create_opts_init ( \n Q_CRYPTO_BLOCK_FORMAT_QCOW , encryptopts , errp ) ; \n if ( ! cryptoopts ) { \n ret = - EINVAL ; \n goto out ; \n } \n s -> crypt_method_header = QCOW_CRYPT_AES ; \n crypto = qcrypto_block_create ( cryptoopts , \n NULL , NULL , \n bs , errp ) ; \n if ( ! crypto ) { \n ret = - EINVAL ; \n goto out ; \n } \n ret = qcow2_update_header ( bs ) ; \n if ( ret < 0 ) { \n error_setg_errno ( errp , - ret , \" \" ) ; \n goto out ; \n } \n out : \n QDECREF ( encryptopts ) ; \n qcrypto_block_free ( crypto ) ; \n qapi_free_QCryptoBlockCreateOptions ( cryptoopts ) ; \n return ret ; \n }", "idx": 2143}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void tilegx_cpu_class_init ( ObjectClass * oc , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( oc ) ; \n CPUClass * cc = CPU_CLASS ( oc ) ; \n TileGXCPUClass * tcc = TILEGX_CPU_CLASS ( oc ) ; \n tcc -> parent_realize = dc -> realize ; \n dc -> realize = tilegx_cpu_realizefn ; \n tcc -> parent_reset = cc -> reset ; \n cc -> reset = tilegx_cpu_reset ; \n cc -> has_work = tilegx_cpu_has_work ; \n cc -> do_interrupt = tilegx_cpu_do_interrupt ; \n cc -> cpu_exec_interrupt = tilegx_cpu_exec_interrupt ; \n cc -> dump_state = tilegx_cpu_dump_state ; \n cc -> set_pc = tilegx_cpu_set_pc ; \n cc -> handle_mmu_fault = tilegx_cpu_handle_mmu_fault ; \n cc -> gdb_num_core_regs = 0 ; \n }", "idx": 2147}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void dma_complete ( DMAAIOCB * dbs , int ret ) \n { \n trace_dma_complete ( dbs , ret , dbs -> common . cb ) ; \n dma_bdrv_unmap ( dbs ) ; \n if ( dbs -> common . cb ) { \n dbs -> common . cb ( dbs -> common . opaque , ret ) ; \n } \n qemu_iovec_destroy ( & dbs -> iov ) ; \n if ( dbs -> bh ) { \n qemu_bh_delete ( dbs -> bh ) ; \n dbs -> bh = NULL ; \n } \n qemu_aio_unref ( dbs ) ; \n }", "idx": 2183}
{"project": "qemu", "commit_id": "da4bc86c540991902e32e4e840c6ada573240254", "target": 1, "func": "static int proxy_mkdir ( FsContext * fs_ctx , V9fsPath * dir_path , \n const char * name , FsCred * credp ) \n { \n int retval ; \n V9fsString fullname ; \n v9fs_string_init ( & fullname ) ; \n v9fs_string_sprintf ( & fullname , \" \" , dir_path -> data , name ) ; \n retval = v9fs_request ( fs_ctx -> private , T_MKDIR , NULL , & fullname , \n credp -> fc_mode , credp -> fc_uid , credp -> fc_gid ) ; \n v9fs_string_free ( & fullname ) ; \n if ( retval < 0 ) { \n errno = - retval ; \n retval = -1 ; \n } \n v9fs_string_free ( & fullname ) ; \n return retval ; \n }", "idx": 2209}
{"project": "qemu", "commit_id": "ef4760626e88bc3e7a1b46c7370378cbd12d379f", "target": 1, "func": "static uint32_t eepro100_read4 ( EEPRO100State * s , uint32_t addr ) \n { \n uint32_t val ; \n if ( addr <= sizeof ( s -> mem ) - sizeof ( val ) ) { \n memcpy ( & val , & s -> mem [ addr ] , sizeof ( val ) ) ; \n } \n switch ( addr ) { \n case SCBStatus : \n TRACE ( OTHER , logout ( \" \\n \" , regname ( addr ) , val ) ) ; \n break ; \n case SCBPointer : \n #if 0  \n  \n  val = eepro100_read_pointer ( s ) ; \n #endif \n TRACE ( OTHER , logout ( \" \\n \" , regname ( addr ) , val ) ) ; \n break ; \n case SCBPort : \n val = eepro100_read_port ( s ) ; \n TRACE ( OTHER , logout ( \" \\n \" , regname ( addr ) , val ) ) ; \n break ; \n case SCBCtrlMDI : \n val = eepro100_read_mdi ( s ) ; \n break ; \n default : \n logout ( \" \\n \" , regname ( addr ) , val ) ; \n missing ( \" \" ) ; \n } \n return val ; \n }", "idx": 2253}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void vty_putchars ( VIOsPAPRDevice * sdev , uint8_t * buf , int len ) \n { \n VIOsPAPRVTYDevice * dev = VIO_SPAPR_VTY_DEVICE ( sdev ) ; \n qemu_chr_fe_write ( dev -> chardev , buf , len ) ; \n }", "idx": 2326}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_m ( int a , const int * b ) \n { \n asm volatile ( \" \\n \" : \" \" ( a ) : \" \" ( b ) ) ; \n return a ; \n }", "idx": 2330}
{"project": "qemu", "commit_id": "bd69fe8448024258d046e2a15d4cf5c498188144", "target": 1, "func": "QEMUOptionParameter * append_option_parameters ( QEMUOptionParameter * dest , \n QEMUOptionParameter * list ) \n { \n size_t num_options , num_dest_options ; \n num_options = count_option_parameters ( dest ) ; \n num_dest_options = num_options ; \n num_options += count_option_parameters ( list ) ; \n dest = qemu_realloc ( dest , ( num_options + 1 ) * sizeof ( QEMUOptionParameter ) ) ; \n while ( list && list -> name ) { \n if ( get_option_parameter ( dest , list -> name ) == NULL ) { \n dest [ num_dest_options ++ ] = * list ; \n } \n list ++ ; \n } \n return dest ; \n }", "idx": 2350}
{"project": "qemu", "commit_id": "525989a50a70ea0ffa2b1cdf56279765bb2b7de0", "target": 1, "func": "void stream_start ( const char * job_id , BlockDriverState * bs , \n BlockDriverState * base , const char * backing_file_str , \n int64_t speed , BlockdevOnError on_error , Error * * errp ) \n { \n StreamBlockJob * s ; \n BlockDriverState * iter ; \n int orig_bs_flags ; \n orig_bs_flags = bdrv_get_flags ( bs ) ; \n if ( ! ( orig_bs_flags & BDRV_O_RDWR ) ) { \n if ( bdrv_reopen ( bs , orig_bs_flags | BDRV_O_RDWR , errp ) != 0 ) { \n return ; \n } \n } \n s = block_job_create ( job_id , & stream_job_driver , bs , \n BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED | \n BLK_PERM_GRAPH_MOD , \n BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED | \n BLK_PERM_WRITE , \n speed , BLOCK_JOB_DEFAULT , NULL , NULL , errp ) ; \n if ( ! s ) { \n goto fail ; \n } \n for ( iter = backing_bs ( bs ) ; iter && iter != base ; iter = backing_bs ( iter ) ) { \n block_job_add_bdrv ( & s -> common , \" \" , iter , 0 , \n BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED , \n & error_abort ) ; \n } \n s -> base = base ; \n s -> backing_file_str = g_strdup ( backing_file_str ) ; \n s -> bs_flags = orig_bs_flags ; \n s -> on_error = on_error ; \n trace_stream_start ( bs , base , s ) ; \n block_job_start ( & s -> common ) ; \n return ; \n fail : \n if ( orig_bs_flags != bdrv_get_flags ( bs ) ) { \n bdrv_reopen ( bs , s -> bs_flags , NULL ) ; \n } \n }", "idx": 2352}
{"project": "qemu", "commit_id": "ea15fb067212bb79291f9b76c5c76d45b62f58e1", "target": 1, "func": "static void tcg_target_qemu_prologue ( TCGContext * s ) \n { \n int i , frame_size ; \n frame_size = ARRAY_SIZE ( tcg_target_callee_save_regs ) * 4 \n + TCG_STATIC_CALL_ARGS_SIZE ; \n frame_size = ( frame_size + TCG_TARGET_STACK_ALIGN - 1 ) & \n ~ ( TCG_TARGET_STACK_ALIGN - 1 ) ; \n tcg_out_addi ( s , TCG_REG_SP , - frame_size ) ; \n for ( i = 0 ; i < ARRAY_SIZE ( tcg_target_callee_save_regs ) ; i ++ ) { \n tcg_out_st ( s , TCG_TYPE_I32 , tcg_target_callee_save_regs [ i ] , \n TCG_REG_SP , TCG_STATIC_CALL_ARGS_SIZE + i * 4 ) ; \n } \n tcg_out_opc_reg ( s , OPC_JR , 0 , tcg_target_call_iarg_regs [ 1 ] ) , 0 ) ; \n tcg_out_mov ( s , TCG_TYPE_PTR , TCG_AREG0 , tcg_target_call_iarg_regs [ 0 ] ) ; \n tb_ret_addr = s -> code_ptr ; \n for ( i = 0 ; i < ARRAY_SIZE ( tcg_target_callee_save_regs ) ; i ++ ) { \n tcg_out_ld ( s , TCG_TYPE_I32 , tcg_target_callee_save_regs [ i ] , \n TCG_REG_SP , TCG_STATIC_CALL_ARGS_SIZE + i * 4 ) ; \n } \n tcg_out_opc_reg ( s , OPC_JR , 0 , TCG_REG_RA , 0 ) ; \n tcg_out_addi ( s , TCG_REG_SP , frame_size ) ; \n }", "idx": 2367}
{"project": "qemu", "commit_id": "4020db0475b3e527b3bdc97dff873c2be9da2698", "target": 1, "func": "static void virtio_scsi_vring_teardown ( VirtIOSCSI * s ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( s ) ; \n VirtIOSCSICommon * vs = VIRTIO_SCSI_COMMON ( s ) ; \n int i ; \n if ( s -> ctrl_vring ) { \n vring_teardown ( & s -> ctrl_vring -> vring , vdev , 0 ) ; \n } \n if ( s -> event_vring ) { \n vring_teardown ( & s -> event_vring -> vring , vdev , 1 ) ; \n } \n if ( s -> cmd_vrings ) { \n for ( i = 0 ; i < vs -> conf . num_queues && s -> cmd_vrings [ i ] ; i ++ ) { \n vring_teardown ( & s -> cmd_vrings [ i ] -> vring , vdev , 2 + i ) ; \n } \n free ( s -> cmd_vrings ) ; \n s -> cmd_vrings = NULL ; \n } \n }", "idx": 2376}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "set_rdt ( E1000State * s , int index , uint32_t val )  \n { \n s -> check_rxov = 0 ; \n s -> mac_reg [ index ] = val & 0xffff ; \n if ( e1000_has_rxbufs ( s , 1 ) ) { \n qemu_flush_queued_packets ( & s -> nic -> nc ) ; \n } \n }", "idx": 2483}
{"project": "qemu", "commit_id": "c9e659c9ee75d33ff11a8573cea738ad26bb6f86", "target": 1, "func": "unsigned int s390_cpu_set_state ( uint8_t cpu_state , S390CPU * cpu ) \n { \n trace_cpu_set_state ( CPU ( cpu ) -> cpu_index , cpu_state ) ; \n switch ( cpu_state ) { \n case CPU_STATE_STOPPED : \n case CPU_STATE_CHECK_STOP : \n s390_cpu_halt ( cpu ) ; \n break ; \n case CPU_STATE_OPERATING : \n case CPU_STATE_LOAD : \n s390_cpu_unhalt ( cpu ) ; \n break ; \n default : \n error_report ( \" \" , \n cpu_state ) ; \n exit ( 1 ) ; \n cpu -> env . cpu_state = cpu_state ; \n return s390_count_running_cpus ( ) ;", "idx": 2493}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void e1000_io_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n E1000State * s = opaque ; \n ( void ) s ; \n }", "idx": 2507}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_clkm_init ( MemoryRegion * memory , target_phys_addr_t mpu_base , \n target_phys_addr_t dsp_base , struct omap_mpu_state_s * s ) \n { \n memory_region_init_io ( & s -> clkm_iomem , & omap_clkm_ops , s , \n \" \" , 0x100 ) ; \n memory_region_init_io ( & s -> clkdsp_iomem , & omap_clkdsp_ops , s , \n \" \" , 0x1000 ) ; \n s -> clkm . arm_idlect1 = 0x03ff ; \n s -> clkm . arm_idlect2 = 0x0100 ; \n s -> clkm . dsp_idlect1 = 0x0002 ; \n omap_clkm_reset ( s ) ; \n s -> clkm . cold_start = 0x3a ; \n memory_region_add_subregion ( memory , mpu_base , & s -> clkm_iomem ) ; \n memory_region_add_subregion ( memory , dsp_base , & s -> clkdsp_iomem ) ; \n }", "idx": 2508}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t bonito_pciconf_readl ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n PCIBonitoState * s = opaque ; \n PCIDevice * d = PCI_DEVICE ( s ) ; \n DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n return d -> config_read ( d , addr , 4 ) ; \n }", "idx": 2521}
{"project": "qemu", "commit_id": "17cce735780f0ff6a2ef173c34614bd47acd56e5", "target": 1, "func": "static void vdi_close ( BlockDriverState * bs ) \n { \n BDRVVdiState * s = bs -> opaque ; \n g_free ( s -> bmap ) ; \n migrate_del_blocker ( s -> migration_blocker ) ; \n error_free ( s -> migration_blocker ) ; \n }", "idx": 2529}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static int handle_instruction ( S390CPU * cpu , struct kvm_run * run ) \n { \n unsigned int ipa0 = ( run -> s390_sieic . ipa & 0xff00 ) ; \n uint8_t ipa1 = run -> s390_sieic . ipa & 0x00ff ; \n int r = -1 ; \n DPRINTF ( \" \\n \" , \n run -> s390_sieic . ipa , run -> s390_sieic . ipb ) ; \n switch ( ipa0 ) { \n case IPA0_B2 : \n r = handle_b2 ( cpu , run , ipa1 ) ; \n break ; \n case IPA0_B9 : \n r = handle_b9 ( cpu , run , ipa1 ) ; \n break ; \n case IPA0_EB : \n r = handle_eb ( cpu , run , run -> s390_sieic . ipb & 0xff ) ; \n break ; \n case IPA0_E3 : \n r = handle_e3 ( cpu , run , run -> s390_sieic . ipb & 0xff ) ; \n break ; \n case IPA0_DIAG : \n r = handle_diag ( cpu , run , run -> s390_sieic . ipb ) ; \n break ; \n case IPA0_SIGP : \n r = handle_sigp ( cpu , ipa1 , run -> s390_sieic . ipb ) ; \n break ; \n } \n if ( r < 0 ) { \n r = 0 ; \n kvm_s390_program_interrupt ( cpu , PGM_OPERATION ) ; \n } \n return r ; \n }", "idx": 2548}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_fstat ( FsContext * fs_ctx , int fid_type , \n V9fsFidOpenState * fs , struct stat * stbuf ) \n { \n V9fsSynthOpenState * synth_open = fs -> private ; \n v9fs_synth_fill_statbuf ( synth_open -> node , stbuf ) ; \n return 0 ; \n }", "idx": 2559}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static uint32_t virtio_balloon_get_features ( VirtIODevice * vdev ) \n { \n return 0 ; \n }", "idx": 2560}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "BlockDriverAIOCB * bdrv_aio_write ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n BlockDriver * drv = bs -> drv ; \n BlockDriverAIOCB * ret ; \n if ( ! drv ) \n return NULL ; \n if ( bs -> read_only ) \n return NULL ; \n if ( sector_num == 0 && bs -> boot_sector_enabled && nb_sectors > 0 ) { \n memcpy ( bs -> boot_sector_data , buf , 512 ) ; \n } \n ret = drv -> bdrv_aio_write ( bs , sector_num , buf , nb_sectors , cb , opaque ) ; \n if ( ret ) { \n bs -> wr_bytes += ( unsigned ) nb_sectors * SECTOR_SIZE ; \n bs -> wr_ops ++ ; \n } \n return ret ; \n }", "idx": 2561}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t icp_pic_read ( void * opaque , target_phys_addr_t offset , \n unsigned size ) \n { \n icp_pic_state * s = ( icp_pic_state * ) opaque ; \n switch ( offset >> 2 ) { \n case 0 : \n return s -> level & s -> irq_enabled ; \n case 1 : \n return s -> level ; \n case 2 : \n return s -> irq_enabled ; \n case 4 : \n return s -> level & 1 ; \n case 8 : \n return s -> level & s -> fiq_enabled ; \n case 9 : \n return s -> level ; \n case 10 : \n return s -> fiq_enabled ; \n case 3 : \n case 5 : \n case 11 : \n default : \n printf ( \" \\n \" , ( int ) offset ) ; \n return 0 ; \n } \n }", "idx": 2582}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static int vmsvga_post_load ( void * opaque , int version_id ) \n { \n struct vmsvga_state_s * s = opaque ; \n s -> invalidated = 1 ; \n if ( s -> config ) \n s -> fifo = ( uint32_t * ) s -> fifo_ptr ; \n return 0 ; \n }", "idx": 2584}
{"project": "qemu", "commit_id": "8d2f850a5ab7579a852f23b28273940a47dfd7ff", "target": 0, "func": "static inline void check_alignment ( CPUS390XState * env , uint64_t v , \n int wordsize , uintptr_t ra ) \n { \n if ( v % wordsize ) { \n CPUState * cs = CPU ( s390_env_get_cpu ( env ) ) ; \n cpu_restore_state ( cs , ra ) ; \n program_interrupt ( env , PGM_SPECIFICATION , 6 ) ; \n } \n }", "idx": 2596}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static int mm_start_timer ( struct qemu_alarm_timer * t ) \n { \n TIMECAPS tc ; \n memset ( & tc , 0 , sizeof ( tc ) ) ; \n timeGetDevCaps ( & tc , sizeof ( tc ) ) ; \n mm_period = tc . wPeriodMin ; \n timeBeginPeriod ( mm_period ) ; \n mm_timer = timeSetEvent ( 1 , \n mm_period , \n mm_alarm_handler , \n ( DWORD_PTR ) t , \n TIME_ONESHOT | TIME_CALLBACK_FUNCTION ) ; \n if ( ! mm_timer ) { \n fprintf ( stderr , \" \\n \" , \n GetLastError ( ) ) ; \n timeEndPeriod ( mm_period ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 2651}
{"project": "qemu", "commit_id": "b18f1141d0afa00de11a8e079f4f5305c9e36893", "target": 1, "func": "static void test_validate_fail_union_native_list ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefNativeListUnion * tmp = NULL ; \n Error * err = NULL ; \n Visitor * v ; \n v = validate_test_init ( data , \n \" \" ) ; \n visit_type_UserDefNativeListUnion ( v , & tmp , NULL , & err ) ; \n g_assert ( err ) ; \n qapi_free_UserDefNativeListUnion ( tmp ) ; \n }", "idx": 2669}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int send_mono_rect ( VncState * vs , int w , int h , uint32_t bg , uint32_t fg ) \n { \n size_t bytes ; \n int stream = 1 ; \n int level = tight_conf [ vs -> tight_compression ] . mono_zlib_level ; \n bytes = ( ( w + 7 ) / 8 ) * h ; \n vnc_write_u8 ( vs , ( stream | VNC_TIGHT_EXPLICIT_FILTER ) << 4 ) ; \n vnc_write_u8 ( vs , VNC_TIGHT_FILTER_PALETTE ) ; \n vnc_write_u8 ( vs , 1 ) ; \n switch ( vs -> clientds . pf . bytes_per_pixel ) { \n case 4 : \n { \n uint32_t buf [ 2 ] = { bg , fg } ; \n size_t ret = sizeof ( buf ) ; \n if ( vs -> tight_pixel24 ) { \n tight_pack24 ( vs , ( unsigned char * ) buf , 2 , & ret ) ; \n } \n vnc_write ( vs , buf , ret ) ; \n tight_encode_mono_rect32 ( vs -> tight . buffer , w , h , bg , fg ) ; \n break ; \n } \n case 2 : \n vnc_write ( vs , & bg , 2 ) ; \n vnc_write ( vs , & fg , 2 ) ; \n tight_encode_mono_rect16 ( vs -> tight . buffer , w , h , bg , fg ) ; \n break ; \n default : \n vnc_write_u8 ( vs , bg ) ; \n vnc_write_u8 ( vs , fg ) ; \n tight_encode_mono_rect8 ( vs -> tight . buffer , w , h , bg , fg ) ; \n break ; \n } \n vs -> tight . offset = bytes ; \n bytes = tight_compress_data ( vs , stream , bytes , level , Z_DEFAULT_STRATEGY ) ; \n return ( bytes >= 0 ) ; \n }", "idx": 2713}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "void qmp_screendump ( const char * filename , Error * * errp ) \n { \n QemuConsole * previous_active_console ; \n bool cswitch ; \n previous_active_console = active_console ; \n cswitch = previous_active_console && previous_active_console -> index != 0 ; \n if ( cswitch ) { \n console_select ( 0 ) ; \n } \n if ( consoles [ 0 ] && consoles [ 0 ] -> hw_screen_dump ) { \n consoles [ 0 ] -> hw_screen_dump ( consoles [ 0 ] -> hw , filename , cswitch , errp ) ; \n } else { \n error_setg ( errp , \" \" ) ; \n } \n if ( cswitch ) { \n console_select ( previous_active_console -> index ) ; \n } \n }", "idx": 2763}
{"project": "qemu", "commit_id": "f0ddf11b23260f0af84fb529486a8f9ba2d19401", "target": 0, "func": "DISAS_INSN ( cas2l ) \n { \n uint16_t ext1 , ext2 ; \n TCGv addr1 , addr2 , regs ; \n ext1 = read_im16 ( env , s ) ; \n if ( ext1 & 0x8000 ) { \n addr1 = AREG ( ext1 , 12 ) ; \n } else { \n addr1 = DREG ( ext1 , 12 ) ; \n } \n ext2 = read_im16 ( env , s ) ; \n if ( ext2 & 0x8000 ) { \n addr2 = AREG ( ext2 , 12 ) ; \n } else { \n addr2 = DREG ( ext2 , 12 ) ; \n } \n regs = tcg_const_i32 ( REG ( ext2 , 6 ) | \n ( REG ( ext1 , 6 ) << 3 ) | \n ( REG ( ext2 , 0 ) << 6 ) | \n ( REG ( ext1 , 0 ) << 9 ) ) ; \n gen_helper_cas2l ( cpu_env , regs , addr1 , addr2 ) ; \n tcg_temp_free ( regs ) ; \n s -> cc_op = CC_OP_CMPL ; \n s -> cc_op_synced = 1 ; \n }", "idx": 2795}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static void cirrus_bitblt_rop_nop ( CirrusVGAState * s , \n uint8_t * dst , const uint8_t * src , \n int dstpitch , int srcpitch , \n int bltwidth , int bltheight ) \n { \n }", "idx": 2797}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static void page_flush_tb ( void ) \n { \n int i ; \n for ( i = 0 ; i < V_L1_SIZE ; i ++ ) { \n page_flush_tb_1 ( V_L1_SHIFT / L2_BITS - 1 , l1_map + i ) ; \n } \n }", "idx": 2800}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_wait ( QemuCond * cond , QemuMutex * mutex ) \n { \n cond -> waiters ++ ; \n qemu_mutex_unlock ( mutex ) ; \n WaitForSingleObject ( cond -> sema , INFINITE ) ; \n if ( InterlockedDecrement ( & cond -> waiters ) == cond -> target ) { \n SetEvent ( cond -> continue_event ) ; \n } \n qemu_mutex_lock ( mutex ) ; \n }", "idx": 2844}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int connect_namedsocket ( const char * path ) \n { \n int sockfd , size ; \n struct sockaddr_un helper ; \n if ( strlen ( path ) >= sizeof ( helper . sun_path ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n sockfd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; \n if ( sockfd < 0 ) { \n fprintf ( stderr , \" \\n \" , strerror ( errno ) ) ; \n return -1 ; \n } \n strcpy ( helper . sun_path , path ) ; \n helper . sun_family = AF_UNIX ; \n size = strlen ( helper . sun_path ) + sizeof ( helper . sun_family ) ; \n if ( connect ( sockfd , ( struct sockaddr * ) & helper , size ) < 0 ) { \n fprintf ( stderr , \" \\n \" , path , strerror ( errno ) ) ; \n close ( sockfd ) ; \n return -1 ; \n } \n unlink ( path ) ; \n return sockfd ; \n }", "idx": 2871}
{"project": "qemu", "commit_id": "b4fe97c8230c34ebd407a9f23894b9c614807540", "target": 0, "func": "static void guest_file_init ( void ) \n { \n QTAILQ_INIT ( & guest_file_state . filehandles ) ; \n }", "idx": 2892}
{"project": "qemu", "commit_id": "6d74ca5aa83b83fb52332f7735c61ecb7a5328c1", "target": 1, "func": "static uint32_t virtio_ioport_read ( VirtIOPCIProxy * proxy , uint32_t addr ) \n { \n VirtIODevice * vdev = proxy -> vdev ; \n uint32_t ret = 0xFFFFFFFF ; \n switch ( addr ) { \n case VIRTIO_PCI_HOST_FEATURES : \n ret = vdev -> get_features ( vdev ) ; \n ret |= ( 1 << VIRTIO_F_NOTIFY_ON_EMPTY ) ; \n ret |= ( 1 << VIRTIO_RING_F_INDIRECT_DESC ) ; \n ret |= ( 1 << VIRTIO_F_BAD_FEATURE ) ; \n break ; \n case VIRTIO_PCI_GUEST_FEATURES : \n ret = vdev -> features ; \n break ; \n case VIRTIO_PCI_QUEUE_PFN : \n ret = virtio_queue_get_addr ( vdev , vdev -> queue_sel ) \n >> VIRTIO_PCI_QUEUE_ADDR_SHIFT ; \n break ; \n case VIRTIO_PCI_QUEUE_NUM : \n ret = virtio_queue_get_num ( vdev , vdev -> queue_sel ) ; \n break ; \n case VIRTIO_PCI_QUEUE_SEL : \n ret = vdev -> queue_sel ; \n break ; \n case VIRTIO_PCI_STATUS : \n ret = vdev -> status ; \n break ; \n case VIRTIO_PCI_ISR : \n ret = vdev -> isr ; \n vdev -> isr = 0 ; \n qemu_set_irq ( proxy -> pci_dev . irq [ 0 ] , 0 ) ; \n break ; \n case VIRTIO_MSI_CONFIG_VECTOR : \n ret = vdev -> config_vector ; \n break ; \n case VIRTIO_MSI_QUEUE_VECTOR : \n ret = virtio_queue_vector ( vdev , vdev -> queue_sel ) ; \n break ; \n default : \n break ; \n } \n return ret ; \n }", "idx": 2948}
{"project": "qemu", "commit_id": "7696414729b2d0f870c80ad1dd637d854bc78847", "target": 1, "func": "static void gen_st ( DisasContext * ctx , uint32_t opc , int rt , \n int base , int16_t offset ) \n { \n TCGv t0 = tcg_temp_new ( ) ; \n TCGv t1 = tcg_temp_new ( ) ; \n int mem_idx = ctx -> mem_idx ; \n gen_base_offset_addr ( ctx , t0 , base , offset ) ; \n gen_load_gpr ( t1 , rt ) ; \n switch ( opc ) { \n #if defined ( TARGET_MIPS64 )  \n  \n  case OPC_SD : \n tcg_gen_qemu_st_tl ( t1 , t0 , mem_idx , MO_TEQ | \n ctx -> default_tcg_memop_mask ) ; \n break ; \n case OPC_SDL : \n gen_helper_0e2i ( sdl , t1 , t0 , mem_idx ) ; \n break ; \n case OPC_SDR : \n gen_helper_0e2i ( sdr , t1 , t0 , mem_idx ) ; \n break ; \n #endif \n case OPC_SW : \n tcg_gen_qemu_st_tl ( t1 , t0 , mem_idx , MO_TEUL | \n ctx -> default_tcg_memop_mask ) ; \n break ; \n case OPC_SH : \n tcg_gen_qemu_st_tl ( t1 , t0 , mem_idx , MO_TEUW | \n ctx -> default_tcg_memop_mask ) ; \n break ; \n case OPC_SB : \n tcg_gen_qemu_st_tl ( t1 , t0 , mem_idx , MO_8 ) ; \n break ; \n case OPC_SWL : \n gen_helper_0e2i ( swl , t1 , t0 , mem_idx ) ; \n break ; \n case OPC_SWR : \n gen_helper_0e2i ( swr , t1 , t0 , mem_idx ) ; \n break ; \n } \n tcg_temp_free ( t0 ) ; \n tcg_temp_free ( t1 ) ; \n }", "idx": 2965}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void * qpa_audio_init ( void ) \n { \n return & conf ; \n }", "idx": 2973}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void timer_deinit ( QEMUTimer * ts ) \n { \n assert ( ts -> expire_time == -1 ) ; \n ts -> timer_list = NULL ; \n }", "idx": 2978}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict * qmp_check_input_obj ( QObject * input_obj , Error * * errp ) \n { \n const QDictEntry * ent ; \n int has_exec_key = 0 ; \n QDict * input_dict ; \n if ( qobject_type ( input_obj ) != QTYPE_QDICT ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT , \" \" ) ; \n return NULL ; \n } \n input_dict = qobject_to_qdict ( input_obj ) ; \n for ( ent = qdict_first ( input_dict ) ; ent ; ent = qdict_next ( input_dict , ent ) ) { \n const char * arg_name = qdict_entry_key ( ent ) ; \n const QObject * arg_obj = qdict_entry_value ( ent ) ; \n if ( ! strcmp ( arg_name , \" \" ) ) { \n if ( qobject_type ( arg_obj ) != QTYPE_QSTRING ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT_MEMBER , \n \" \" , \" \" ) ; \n return NULL ; \n } \n has_exec_key = 1 ; \n } else if ( ! strcmp ( arg_name , \" \" ) ) { \n if ( qobject_type ( arg_obj ) != QTYPE_QDICT ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT_MEMBER , \n \" \" , \" \" ) ; \n return NULL ; \n } \n } else if ( ! strcmp ( arg_name , \" \" ) ) { \n } else { \n error_setg ( errp , QERR_QMP_EXTRA_MEMBER , arg_name ) ; \n return NULL ; \n } \n } \n if ( ! has_exec_key ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT , \" \" ) ; \n return NULL ; \n } \n return input_dict ; \n }", "idx": 2982}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_read ( void * opaque , const uint8_t * buf , int size ) \n { \n int i ; \n for ( i = 0 ; i < size ; i ++ ) \n term_handle_byte ( buf [ i ] ) ; \n }", "idx": 2985}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void dma_acct_start ( BlockDriverState * bs , BlockAcctCookie * cookie , \n QEMUSGList * sg , enum BlockAcctType type ) \n { \n block_acct_start ( bdrv_get_stats ( bs ) , cookie , sg -> size , type ) ; \n }", "idx": 3019}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "xilinx_axienet_data_stream_push ( StreamSlave * obj , uint8_t * buf , size_t size , \n uint32_t * hdr )  \n { \n XilinxAXIEnetStreamSlave * ds = XILINX_AXI_ENET_DATA_STREAM ( obj ) ; \n XilinxAXIEnet * s = ds -> enet ; \n if ( ! ( s -> tc & TC_TX ) ) { \n return size ; \n } \n if ( ! ( s -> tc & TC_JUM ) ) { \n if ( size > 1518 && size <= 1522 && ! ( s -> tc & TC_VLAN ) ) { \n return size ; \n } \n } \n if ( hdr [ 0 ] & 1 ) { \n unsigned int start_off = hdr [ 1 ] >> 16 ; \n unsigned int write_off = hdr [ 1 ] & 0xffff ; \n uint32_t tmp_csum ; \n uint16_t csum ; \n tmp_csum = net_checksum_add ( size - start_off , \n ( uint8_t * ) buf + start_off ) ; \n tmp_csum += hdr [ 2 ] & 0xffff ; \n csum = net_checksum_finish ( tmp_csum ) ; \n buf [ write_off ] = csum >> 8 ; \n buf [ write_off + 1 ] = csum & 0xff ; \n } \n qemu_send_packet ( qemu_get_queue ( s -> nic ) , buf , size ) ; \n s -> stats . tx_bytes += size ; \n s -> regs [ R_IS ] |= IS_TX_COMPLETE ; \n enet_update_irq ( s ) ; \n return size ; \n }", "idx": 3039}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_set_a20 ( CPUX86State * env , int a20_state ) \n { \n a20_state = ( a20_state != 0 ) ; \n if ( a20_state != a20_enabled ) { \n #if defined ( DEBUG_MMU )  \n  \n  printf ( \" \\n \" , a20_state ) ; \n #endif \n cpu_interrupt ( env , 0 ) ; \n tlb_flush ( env ) ; \n a20_enabled = a20_state ; \n if ( a20_enabled ) \n a20_mask = 0xffffffff ; \n else \n a20_mask = 0xffefffff ; \n } \n }", "idx": 3047}
{"project": "qemu", "commit_id": "92f2b4e71e988ad2751c71717e9fe3387753442a", "target": 0, "func": "uint64_t HELPER ( cvd ) ( int32_t bin ) \n { \n uint64_t dec = 0x0c ; \n int shift = 4 ; \n if ( bin < 0 ) { \n bin = - bin ; \n dec = 0x0d ; \n } \n for ( shift = 4 ; ( shift < 64 ) && bin ; shift += 4 ) { \n int current_number = bin % 10 ; \n dec |= ( current_number ) << shift ; \n bin /= 10 ; \n } \n return dec ; \n }", "idx": 3059}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "bool io_mem_read ( MemoryRegion * mr , hwaddr addr , uint64_t * pval , unsigned size ) \n { \n return memory_region_dispatch_read ( mr , addr , pval , size ) ; \n }", "idx": 3071}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_input_end_list ( Visitor * v ) \n { \n QmpInputVisitor * qiv = to_qiv ( v ) ; \n qmp_input_pop ( qiv , & error_abort ) ; \n }", "idx": 3192}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint32 ( QEMUFile * f , void * pv , size_t size ) \n { \n uint32_t * v = pv ; \n qemu_get_be32s ( f , v ) ; \n return 0 ; \n }", "idx": 3195}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "static void * data_plane_thread ( void * opaque ) \n { \n VirtIOBlockDataPlane * s = opaque ; \n do { \n event_poll ( & s -> event_poll ) ; \n } while ( s -> started || s -> num_reqs > 0 ) ; \n return NULL ; \n }", "idx": 3207}
{"project": "qemu", "commit_id": "ca9bd24cf1d53775169ba9adc17e265554d1afed", "target": 1, "func": "void bdrv_close_all ( void ) \n { \n BlockDriverState * bs ; \n QTAILQ_FOREACH ( bs , & bdrv_states , device_list )  { \n AioContext * aio_context = bdrv_get_aio_context ( bs ) ; \n aio_context_acquire ( aio_context ) ; \n bdrv_close ( bs ) ; \n aio_context_release ( aio_context ) ; \n } \n }", "idx": 3215}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void monitor_init ( CharDriverState * chr , int flags ) \n { \n static int is_first_init = 1 ; \n Monitor * mon ; \n if ( is_first_init ) { \n monitor_qapi_event_init ( ) ; \n sortcmdlist ( ) ; \n is_first_init = 0 ; \n } \n mon = g_malloc ( sizeof ( * mon ) ) ; \n monitor_data_init ( mon ) ; \n mon -> chr = chr ; \n mon -> flags = flags ; \n if ( flags & MONITOR_USE_READLINE ) { \n mon -> rs = readline_init ( monitor_readline_printf , \n monitor_readline_flush , \n mon , \n monitor_find_completion ) ; \n monitor_read_command ( mon , 0 ) ; \n } \n if ( monitor_is_qmp ( mon ) ) { \n qemu_chr_add_handlers ( chr , monitor_can_read , monitor_qmp_read , \n monitor_qmp_event , mon ) ; \n qemu_chr_fe_set_echo ( chr , true ) ; \n json_message_parser_init ( & mon -> qmp . parser , handle_qmp_command ) ; \n } else { \n qemu_chr_add_handlers ( chr , monitor_can_read , monitor_read , \n monitor_event , mon ) ; \n } \n qemu_mutex_lock ( & monitor_lock ) ; \n QLIST_INSERT_HEAD ( & mon_list , mon , entry ) ; \n qemu_mutex_unlock ( & monitor_lock ) ; \n if ( ! default_mon || ( flags & MONITOR_IS_DEFAULT ) ) \n default_mon = mon ; \n }", "idx": 3219}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static sPAPRDRConnector * spapr_phb_get_pci_drc ( sPAPRPHBState * phb , \n PCIDevice * pdev ) \n { \n uint32_t busnr = pci_bus_num ( PCI_BUS ( qdev_get_parent_bus ( DEVICE ( pdev ) ) ) ) ; \n return spapr_dr_connector_by_id ( SPAPR_DR_CONNECTOR_TYPE_PCI , \n ( phb -> index << 16 ) | \n ( busnr << 8 ) | \n pdev -> devfn ) ; \n }", "idx": 3224}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_kbd_put_keycode ( void * opaque , int keycode ) \n { \n KBDState * s = opaque ; \n if ( s -> count < sizeof ( s -> data ) ) { \n s -> data [ s -> wptr ] = keycode ; \n if ( ++ s -> wptr == sizeof ( s -> data ) ) \n s -> wptr = 0 ; \n s -> count ++ ; \n } \n }", "idx": 3234}
{"project": "qemu", "commit_id": "c8e6c93857885a19e959ec622d92a256d1cd98eb", "target": 1, "func": "static void nvdimm_build_nfit ( GSList * device_list , GArray * table_offsets , \n GArray * table_data , GArray * linker ) \n { \n GArray * structures = nvdimm_build_device_structure ( device_list ) ; \n void * header ; \n acpi_add_table ( table_offsets , table_data ) ; \n header = acpi_data_push ( table_data , sizeof ( NvdimmNfitHeader ) ) ; \n g_array_append_vals ( table_data , structures -> data , structures -> len ) ; \n build_header ( linker , table_data , header , \" \" , \n sizeof ( NvdimmNfitHeader ) + structures -> len , 1 , NULL ) ; \n g_array_free ( structures , true ) ; \n }", "idx": 3249}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static int v9fs_do_mksock ( V9fsState * s , V9fsString * path ) \n { \n return s -> ops -> mksock ( & s -> ctx , path -> data ) ; \n }", "idx": 3255}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void make_dirty ( uint8_t device ) \n { \n QPCIDevice * dev ; \n QPCIBar bmdma_bar , ide_bar ; \n uint8_t status ; \n size_t len = 512 ; \n uintptr_t guest_buf ; \n void * buf ; \n dev = get_pci_device ( & bmdma_bar , & ide_bar ) ; \n guest_buf = guest_alloc ( guest_malloc , len ) ; \n buf = g_malloc ( len ) ; \n memset ( buf , rand ( ) % 255 + 1 , len ) ; \n g_assert ( guest_buf ) ; \n g_assert ( buf ) ; \n memwrite ( guest_buf , buf , len ) ; \n PrdtEntry prdt [ ] = { \n { \n . addr = cpu_to_le32 ( guest_buf ) , \n . size = cpu_to_le32 ( len | PRDT_EOT ) , \n } , \n } ; \n status = send_dma_request ( CMD_WRITE_DMA , 1 , 1 , prdt , \n ARRAY_SIZE ( prdt ) , NULL ) ; \n g_assert_cmphex ( status , == , BM_STS_INTR ) ; \n assert_bit_clear ( qpci_io_readb ( dev , ide_bar , reg_status ) , DF | ERR ) ; \n g_free ( buf ) ; \n }", "idx": 3284}
{"project": "qemu", "commit_id": "49f676a00ab540fac1d2008be26434cf85607722", "target": 0, "func": "unsigned long find_next_bit ( const unsigned long * addr , unsigned long size , \n unsigned long offset ) \n { \n const unsigned long * p = addr + BITOP_WORD ( offset ) ; \n unsigned long result = offset & ~ ( BITS_PER_LONG - 1 ) ; \n unsigned long tmp ; \n if ( offset >= size ) { \n return size ; \n } \n size -= result ; \n offset %= BITS_PER_LONG ; \n if ( offset ) { \n tmp = * ( p ++ ) ; \n tmp &= ( ~ 0UL << offset ) ; \n if ( size < BITS_PER_LONG ) { \n goto found_first ; \n } \n if ( tmp ) { \n goto found_middle ; \n } \n size -= BITS_PER_LONG ; \n result += BITS_PER_LONG ; \n } \n while ( size & ~ ( BITS_PER_LONG - 1 ) ) { \n if ( ( tmp = * ( p ++ ) ) ) { \n goto found_middle ; \n } \n result += BITS_PER_LONG ; \n size -= BITS_PER_LONG ; \n } \n if ( ! size ) { \n return result ; \n } \n tmp = * p ; \n found_first : \n tmp &= ( ~ 0UL >> ( BITS_PER_LONG - size ) ) ; \n if ( tmp == 0UL ) { \n return result + size ; \n } \n found_middle : \n return result + ctzl ( tmp ) ; \n }", "idx": 3302}
{"project": "qemu", "commit_id": "5f2a80adc6fd2b2e4e0579a6613a9913e3cc9a05", "target": 0, "func": "uint64_t helper_cmpbge ( uint64_t op1 , uint64_t op2 ) \n { \n uint8_t opa , opb , res ; \n int i ; \n res = 0 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n opa = op1 >> ( i * 8 ) ; \n opb = op2 >> ( i * 8 ) ; \n if ( opa >= opb ) { \n res |= 1 << i ; \n } \n } \n return res ; \n }", "idx": 3309}
{"project": "qemu", "commit_id": "81cf8d8adc64203567e03326c13ea4abec9fe5df", "target": 0, "func": "void helper_check_iol ( CPUX86State * env , uint32_t t0 ) \n { \n check_io ( env , t0 , 4 ) ; \n }", "idx": 3312}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "static inline uint64_t do_fri ( CPUPPCState * env , uint64_t arg , \n int rounding_mode ) \n { \n CPU_DoubleU farg ; \n farg . ll = arg ; \n if ( unlikely ( float64_is_signaling_nan ( farg . d ) ) ) { \n farg . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN | \n POWERPC_EXCP_FP_VXCVI ) ; \n } else if ( unlikely ( float64_is_quiet_nan ( farg . d ) || \n float64_is_infinity ( farg . d ) ) ) { \n farg . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXCVI ) ; \n } else { \n set_float_rounding_mode ( rounding_mode , & env -> fp_status ) ; \n farg . ll = float64_round_to_int ( farg . d , & env -> fp_status ) ; \n fpscr_set_rounding_mode ( env ) ; \n } \n return farg . ll ; \n }", "idx": 3339}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int DMA_write_memory ( int nchan , void * buf , int pos , int len ) \n { \n struct dma_regs * r = & dma_controllers [ nchan > 3 ] . regs [ nchan & 3 ] ; \n target_phys_addr_t addr = ( ( r -> pageh & 0x7f ) << 24 ) | ( r -> page << 16 ) | r -> now [ ADDR ] ; \n if ( r -> mode & 0x20 ) { \n int i ; \n uint8_t * p = buf ; \n cpu_physical_memory_write ( addr - pos - len , buf , len ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n uint8_t b = p [ len - i - 1 ] ; \n p [ i ] = b ; \n } \n } \n else \n cpu_physical_memory_write ( addr + pos , buf , len ) ; \n return len ; \n }", "idx": 3344}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "LinuxAioState * aio_get_linux_aio ( AioContext * ctx ) \n { \n if ( ! ctx -> linux_aio ) { \n ctx -> linux_aio = laio_init ( ) ; \n laio_attach_aio_context ( ctx -> linux_aio , ctx ) ; \n } \n return ctx -> linux_aio ; \n }", "idx": 3365}
{"project": "qemu", "commit_id": "30fd3e27907dfd1c0c66cc1339657af1a2ce1d4b", "target": 0, "func": "static ssize_t qio_channel_command_readv ( QIOChannel * ioc , \n const struct iovec * iov , \n size_t niov , \n int * * fds , \n size_t * nfds , \n Error * * errp ) \n { \n QIOChannelCommand * cioc = QIO_CHANNEL_COMMAND ( ioc ) ; \n ssize_t ret ; \n retry : \n ret = readv ( cioc -> readfd , iov , niov ) ; \n if ( ret < 0 ) { \n if ( errno == EAGAIN || \n errno == EWOULDBLOCK ) { \n return QIO_CHANNEL_ERR_BLOCK ; \n } \n if ( errno == EINTR ) { \n goto retry ; \n } \n error_setg_errno ( errp , errno , \n \" \" ) ; \n return -1 ; \n } \n return ret ; \n }", "idx": 3436}
{"project": "qemu", "commit_id": "016f5cf6ff465411733878a17c8f8febb7668321", "target": 1, "func": "void bdrv_flush ( BlockDriverState * bs ) \n { \n if ( bs -> drv && bs -> drv -> bdrv_flush ) \n bs -> drv -> bdrv_flush ( bs ) ; ", "idx": 3461}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void block_job_cancel_sync ( BlockJob * job ) \n { \n BlockDriverState * bs = job -> bs ; \n assert ( bs -> job == job ) ; \n block_job_cancel ( job ) ; \n while ( bs -> job != NULL && bs -> job -> busy ) { \n qemu_aio_wait ( ) ; \n } \n }", "idx": 3464}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void vtd_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n X86IOMMUClass * x86_class = X86_IOMMU_CLASS ( klass ) ; \n dc -> reset = vtd_reset ; \n dc -> vmsd = & vtd_vmstate ; \n dc -> props = vtd_properties ; \n dc -> hotpluggable = false ; \n x86_class -> realize = vtd_realize ; \n x86_class -> int_remap = vtd_int_remap ; \n }", "idx": 3477}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static void audio_capture ( void * opaque , void * buf , int size ) \n { \n VncState * vs = opaque ; \n vnc_lock_output ( vs ) ; \n vnc_write_u8 ( vs , VNC_MSG_SERVER_QEMU ) ; \n vnc_write_u8 ( vs , VNC_MSG_SERVER_QEMU_AUDIO ) ; \n vnc_write_u16 ( vs , VNC_MSG_SERVER_QEMU_AUDIO_DATA ) ; \n vnc_write_u32 ( vs , size ) ; \n vnc_write ( vs , buf , size ) ; \n vnc_unlock_output ( vs ) ; \n vnc_flush ( vs ) ; \n }", "idx": 3494}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_update_ip_checksums ( struct NetTxPkt * pkt ) \n { \n uint16_t csum ; \n uint32_t ph_raw_csum ; \n assert ( pkt ) ; \n uint8_t gso_type = pkt -> virt_hdr . gso_type & ~ VIRTIO_NET_HDR_GSO_ECN ; \n struct ip_header * ip_hdr ; \n if ( VIRTIO_NET_HDR_GSO_TCPV4 != gso_type && \n VIRTIO_NET_HDR_GSO_UDP != gso_type ) { \n return ; \n } \n ip_hdr = pkt -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_base ; \n if ( pkt -> payload_len + pkt -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_len > \n ETH_MAX_IP_DGRAM_LEN ) { \n return ; \n } \n ip_hdr -> ip_len = cpu_to_be16 ( pkt -> payload_len + \n pkt -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_len ) ; \n ip_hdr -> ip_sum = 0 ; \n csum = net_raw_checksum ( ( uint8_t * ) ip_hdr , \n pkt -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_len ) ; \n ip_hdr -> ip_sum = cpu_to_be16 ( csum ) ; \n ph_raw_csum = eth_calc_pseudo_hdr_csum ( ip_hdr , pkt -> payload_len ) ; \n csum = cpu_to_be16 ( ~ net_checksum_finish ( ph_raw_csum ) ) ; \n iov_from_buf ( & pkt -> vec [ NET_TX_PKT_PL_START_FRAG ] , pkt -> payload_frags , \n pkt -> virt_hdr . csum_offset , & csum , sizeof ( csum ) ) ; \n }", "idx": 3662}
{"project": "qemu", "commit_id": "882b3b97697affb36ca3d174f42f846232008979", "target": 1, "func": "int css_create_css_image ( uint8_t cssid , bool default_image ) \n { \n trace_css_new_image ( cssid , default_image ? \" \" : \" \" ) ; \n if ( cssid > MAX_CSSID ) { \n return - EINVAL ; \n } \n if ( channel_subsys . css [ cssid ] ) { \n return - EBUSY ; \n } \n channel_subsys . css [ cssid ] = g_malloc0 ( sizeof ( CssImage ) ) ; \n if ( default_image ) { \n channel_subsys . default_cssid = cssid ; \n } \n return 0 ; \n }", "idx": 3698}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "static void pxa2xx_pic_save ( QEMUFile * f , void * opaque ) \n { \n PXA2xxPICState * s = ( PXA2xxPICState * ) opaque ; \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) \n qemu_put_be32s ( f , & s -> int_enabled [ i ] ) ; \n for ( i = 0 ; i < 2 ; i ++ ) \n qemu_put_be32s ( f , & s -> int_pending [ i ] ) ; \n for ( i = 0 ; i < 2 ; i ++ ) \n qemu_put_be32s ( f , & s -> is_fiq [ i ] ) ; \n qemu_put_be32s ( f , & s -> int_idle ) ; \n for ( i = 0 ; i < PXA2XX_PIC_SRCS ; i ++ ) \n qemu_put_be32s ( f , & s -> priority [ i ] ) ; \n }", "idx": 3747}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_co_send_request ( BDRVNBDState * s , struct nbd_request * request , \n struct iovec * iov , int offset ) \n { \n int rc , ret ; \n qemu_co_mutex_lock ( & s -> send_mutex ) ; \n s -> send_coroutine = qemu_coroutine_self ( ) ; \n qemu_aio_set_fd_handler ( s -> sock , nbd_reply_ready , nbd_restart_write , \n nbd_have_request , NULL , s ) ; \n rc = nbd_send_request ( s -> sock , request ) ; \n if ( rc >= 0 && iov ) { \n ret = qemu_co_sendv ( s -> sock , iov , request -> len , offset ) ; \n if ( ret != request -> len ) { \n errno = - EIO ; \n rc = -1 ; \n } \n } \n qemu_aio_set_fd_handler ( s -> sock , nbd_reply_ready , NULL , \n nbd_have_request , NULL , s ) ; \n s -> send_coroutine = NULL ; \n qemu_co_mutex_unlock ( & s -> send_mutex ) ; \n return rc ; \n }", "idx": 3757}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "void replay_save_input_event ( InputEvent * evt ) \n { \n InputKeyEvent * key ; \n InputBtnEvent * btn ; \n InputMoveEvent * move ; \n replay_put_dword ( evt -> type ) ; \n switch ( evt -> type ) { \n case INPUT_EVENT_KIND_KEY : \n key = evt -> u . key ; \n replay_put_dword ( key -> key -> type ) ; \n switch ( key -> key -> type ) { \n case KEY_VALUE_KIND_NUMBER : \n replay_put_qword ( key -> key -> u . number ) ; \n replay_put_byte ( key -> down ) ; \n break ; \n case KEY_VALUE_KIND_QCODE : \n replay_put_dword ( key -> key -> u . qcode ) ; \n replay_put_byte ( key -> down ) ; \n break ; \n case KEY_VALUE_KIND__MAX : \n break ; \n } \n break ; \n case INPUT_EVENT_KIND_BTN : \n btn = evt -> u . btn ; \n replay_put_dword ( btn -> button ) ; \n replay_put_byte ( btn -> down ) ; \n break ; \n case INPUT_EVENT_KIND_REL : \n move = evt -> u . rel ; \n replay_put_dword ( move -> axis ) ; \n replay_put_qword ( move -> value ) ; \n break ; \n case INPUT_EVENT_KIND_ABS : \n move = evt -> u . abs ; \n replay_put_dword ( move -> axis ) ; \n replay_put_qword ( move -> value ) ; \n break ; \n case INPUT_EVENT_KIND__MAX : \n break ; \n } \n }", "idx": 3761}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_set_parent_bus ( DeviceState * dev , BusState * bus ) \n { \n Property * prop ; \n if ( qdev_hotplug ) { \n assert ( bus -> allow_hotplug ) ; \n } \n dev -> parent_bus = bus ; \n QTAILQ_INSERT_HEAD ( & bus -> children , dev , sibling ) ; \n qdev_prop_set_defaults ( dev , dev -> parent_bus -> info -> props ) ; \n for ( prop = qdev_get_bus_info ( dev ) -> props ; prop && prop -> name ; prop ++ ) { \n qdev_property_add_legacy ( dev , prop , NULL ) ; \n qdev_property_add_static ( dev , prop , NULL ) ; \n } \n }", "idx": 3774}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "int object_property_get_enum ( Object * obj , const char * name , \n const char * typename , Error * * errp ) \n { \n Error * err = NULL ; \n StringOutputVisitor * sov ; \n Visitor * v ; \n char * str ; \n int ret ; \n ObjectProperty * prop = object_property_find ( obj , name , errp ) ; \n EnumProperty * enumprop ; \n if ( prop == NULL ) { \n return 0 ; \n } \n if ( ! g_str_equal ( prop -> type , typename ) ) { \n error_setg ( errp , \" \" , \n name , object_class_get_name ( \n object_get_class ( obj ) ) , typename ) ; \n return 0 ; \n } \n enumprop = prop -> opaque ; \n sov = string_output_visitor_new ( false ) ; \n object_property_get ( obj , string_output_get_visitor ( sov ) , name , & err ) ; \n if ( err ) { \n error_propagate ( errp , err ) ; \n string_output_visitor_cleanup ( sov ) ; \n return 0 ; \n } \n str = string_output_get_string ( sov ) ; \n string_output_visitor_cleanup ( sov ) ; \n v = string_input_visitor_new ( str ) ; \n visit_type_enum ( v , name , & ret , enumprop -> strings , errp ) ; \n g_free ( str ) ; \n visit_free ( v ) ; \n return ret ; \n }", "idx": 3786}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_sti_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n struct omap_sti_s * s = ( struct omap_sti_s * ) opaque ; \n if ( size != 4 ) { \n return omap_badwidth_read32 ( opaque , addr ) ; \n } \n switch ( addr ) { \n case 0x00 : \n return 0x10 ; \n case 0x10 : \n return s -> sysconfig ; \n case 0x14 : \n return 0x00 ; \n case 0x18 : \n return s -> irqst ; \n case 0x1c : \n return s -> irqen ; \n case 0x24 : \n case 0x28 : \n return 0 ; \n case 0x2c : \n return s -> clkcontrol ; \n case 0x30 : \n return s -> serial_config ; \n } \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 3789}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int pollfds_fill ( GArray * pollfds , fd_set * rfds , fd_set * wfds , \n fd_set * xfds ) \n { \n int nfds = -1 ; \n int i ; \n for ( i = 0 ; i < pollfds -> len ; i ++ ) { \n GPollFD * pfd = & g_array_index ( pollfds , GPollFD , i ) ; \n int fd = pfd -> fd ; \n int events = pfd -> events ; \n if ( events & G_IO_IN ) { \n FD_SET ( fd , rfds ) ; \n nfds = MAX ( nfds , fd ) ; \n } \n if ( events & G_IO_OUT ) { \n FD_SET ( fd , wfds ) ; \n nfds = MAX ( nfds , fd ) ; \n } \n if ( events & G_IO_PRI ) { \n FD_SET ( fd , xfds ) ; \n nfds = MAX ( nfds , fd ) ; \n } \n } \n return nfds ; \n }", "idx": 3799}
{"project": "qemu", "commit_id": "dcc772e2f2b7c2a68644133fea2b874f6751a57b", "target": 0, "func": "void qemu_bh_schedule_idle ( QEMUBH * bh ) \n { \n if ( bh -> scheduled ) \n return ; \n bh -> scheduled = 1 ; \n bh -> idle = 1 ; \n }", "idx": 3800}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_phys ( target_phys_addr_t addr , uint32_t val ) \n { \n stl_phys_internal ( addr , val , DEVICE_NATIVE_ENDIAN ) ; \n }", "idx": 3814}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void multiwrite_user_cb ( MultiwriteCB * mcb ) \n { \n int i ; \n for ( i = 0 ; i < mcb -> num_callbacks ; i ++ ) { \n mcb -> callbacks [ i ] . cb ( mcb -> callbacks [ i ] . opaque , mcb -> error ) ; \n if ( mcb -> callbacks [ i ] . free_qiov ) { \n qemu_iovec_destroy ( mcb -> callbacks [ i ] . free_qiov ) ; \n } \n g_free ( mcb -> callbacks [ i ] . free_qiov ) ; \n } \n }", "idx": 3858}
{"project": "qemu", "commit_id": "4fd37a98d1248bae54a9f71ee1c252d2b2f1efd5", "target": 0, "func": "char * get_boot_devices_list ( uint32_t * size ) \n { \n FWBootEntry * i ; \n uint32_t total = 0 ; \n char * list = NULL ; \n QTAILQ_FOREACH ( i , & fw_boot_order , link )  { \n char * devpath = NULL , * bootpath ; \n int len ; \n if ( i -> dev ) { \n devpath = qdev_get_fw_dev_path ( i -> dev ) ; \n assert ( devpath ) ; \n } \n if ( i -> suffix && devpath ) { \n bootpath = qemu_malloc ( strlen ( devpath ) + strlen ( i -> suffix ) + 1 ) ; \n sprintf ( bootpath , \" \" , devpath , i -> suffix ) ; \n qemu_free ( devpath ) ; \n } else if ( devpath ) { \n bootpath = devpath ; \n } else { \n bootpath = strdup ( i -> suffix ) ; \n assert ( bootpath ) ; \n } \n if ( total ) { \n list [ total - 1 ] = ' \\n ' ; \n } \n len = strlen ( bootpath ) + 1 ; \n list = qemu_realloc ( list , total + len ) ; \n memcpy ( & list [ total ] , bootpath , len ) ; \n total += len ; \n qemu_free ( bootpath ) ; \n } \n * size = total ; \n return list ; \n }", "idx": 3859}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void framebuffer_update_request ( VncState * vs , int incremental , \n int x_position , int y_position , \n int w , int h ) \n { \n int i ; \n const size_t width = surface_width ( vs -> vd -> ds ) / VNC_DIRTY_PIXELS_PER_BIT ; \n const size_t height = surface_height ( vs -> vd -> ds ) ; \n if ( y_position > height ) { \n y_position = height ; \n } \n if ( y_position + h >= height ) { \n h = height - y_position ; \n } \n vs -> need_update = 1 ; \n if ( ! incremental ) { \n vs -> force_update = 1 ; \n for ( i = 0 ; i < h ; i ++ ) { \n bitmap_set ( vs -> dirty [ y_position + i ] , 0 , width ) ; \n bitmap_clear ( vs -> dirty [ y_position + i ] , width , \n VNC_DIRTY_BITS - width ) ; \n } \n } \n }", "idx": 3907}
{"project": "qemu", "commit_id": "e7658fcc4c29a29c578acde26f7714023b93b46e", "target": 1, "func": "static int tpm_passthrough_unix_write ( int fd , const uint8_t * buf , uint32_t len ) \n { \n int ret , remain ; \n remain = len ; \n while ( len > 0 ) { \n ret = write ( fd , buf , remain ) ; \n if ( ret < 0 ) { \n if ( errno != EINTR && errno != EAGAIN ) { \n return -1 ; \n } \n } else if ( ret == 0 ) { \n break ; \n } else { \n buf += ret ; \n remain -= ret ; \n } \n } \n return len - remain ; \n }", "idx": 3917}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void cris_cpu_initfn ( Object * obj ) \n { \n CPUState * cs = CPU ( obj ) ; \n CRISCPU * cpu = CRIS_CPU ( obj ) ; \n CRISCPUClass * ccc = CRIS_CPU_GET_CLASS ( obj ) ; \n CPUCRISState * env = & cpu -> env ; \n static bool tcg_initialized ; \n cs -> env_ptr = env ; \n cpu_exec_init ( cs , & error_abort ) ; \n env -> pregs [ PR_VR ] = ccc -> vr ; \n #ifndef CONFIG_USER_ONLY \n qdev_init_gpio_in ( DEVICE ( cpu ) , cris_cpu_set_irq , 2 ) ; \n #endif \n if ( tcg_enabled ( ) && ! tcg_initialized ) { \n tcg_initialized = true ; \n if ( env -> pregs [ PR_VR ] < 32 ) { \n cris_initialize_crisv10_tcg ( ) ; \n } else { \n cris_initialize_tcg ( ) ; \n } \n } \n }", "idx": 3968}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void exec_start_incoming_migration ( const char * command , Error * * errp ) \n { \n QEMUFile * f ; \n DPRINTF ( \" \\n \" ) ; \n f = qemu_popen_cmd ( command , \" \" ) ; \n if ( f == NULL ) { \n error_setg_errno ( errp , errno , \" \" ) ; \n return ; \n } \n qemu_set_fd_handler2 ( qemu_get_fd ( f ) , NULL , \n exec_accept_incoming_migration , NULL , f ) ; \n }", "idx": 3992}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "static void io_mem_init ( void ) \n { \n cpu_register_io_memory ( IO_MEM_ROM >> IO_MEM_SHIFT , error_mem_read , unassigned_mem_write , NULL ) ; \n cpu_register_io_memory ( IO_MEM_UNASSIGNED >> IO_MEM_SHIFT , unassigned_mem_read , unassigned_mem_write , NULL ) ; \n cpu_register_io_memory ( IO_MEM_NOTDIRTY >> IO_MEM_SHIFT , error_mem_read , notdirty_mem_write , NULL ) ; \n io_mem_nb = 5 ; \n phys_ram_dirty = qemu_vmalloc ( phys_ram_size >> TARGET_PAGE_BITS ) ; \n memset ( phys_ram_dirty , 0xff , phys_ram_size >> TARGET_PAGE_BITS ) ; \n }", "idx": 3994}
{"project": "qemu", "commit_id": "46abb8124006887d071921c5e657eeec3c50a9e2", "target": 1, "func": "static void virtio_balloon_device_realize ( DeviceState * dev , Error * * errp ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( dev ) ; \n VirtIOBalloon * s = VIRTIO_BALLOON ( dev ) ; \n int ret ; \n virtio_init ( vdev , \" \" , VIRTIO_ID_BALLOON , \n sizeof ( struct virtio_balloon_config ) ) ; \n ret = qemu_add_balloon_handler ( virtio_balloon_to_target , \n virtio_balloon_stat , s ) ; \n if ( ret < 0 ) { \n error_setg ( errp , \" \" ) ; \n virtio_cleanup ( vdev ) ; \n return ; \n } \n s -> ivq = virtio_add_queue ( vdev , 128 , virtio_balloon_handle_output ) ; \n s -> dvq = virtio_add_queue ( vdev , 128 , virtio_balloon_handle_output ) ; \n s -> svq = virtio_add_queue ( vdev , 128 , virtio_balloon_receive_stats ) ; \n reset_stats ( s ) ; \n register_savevm ( dev , \" \" , -1 , 1 , \n virtio_balloon_save , virtio_balloon_load , s ) ; \n object_property_add ( OBJECT ( dev ) , \" \" , \" \" , \n balloon_stats_get_all , NULL , NULL , s , NULL ) ; \n object_property_add ( OBJECT ( dev ) , \" \" , \" \" , \n balloon_stats_get_poll_interval , \n balloon_stats_set_poll_interval , \n NULL , s , NULL ) ; \n }", "idx": 4061}
{"project": "qemu", "commit_id": "cd9953f720e1d57cfa86bc0882abced45ba96d3c", "target": 1, "func": "static int resize_peers ( IVShmemState * s , int new_min_size ) \n { \n int j , old_size ; \n if ( new_min_size <= 0 || new_min_size > IVSHMEM_MAX_PEERS ) { \n return -1 ; \n } \n if ( new_min_size <= s -> nb_peers ) { \n return 0 ; \n } \n old_size = s -> nb_peers ; \n s -> nb_peers = new_min_size ; \n IVSHMEM_DPRINTF ( \" \\n \" , s -> nb_peers ) ; \n s -> peers = g_realloc ( s -> peers , s -> nb_peers * sizeof ( Peer ) ) ; \n for ( j = old_size ; j < s -> nb_peers ; j ++ ) { \n s -> peers [ j ] . eventfds = g_new0 ( EventNotifier , s -> vectors ) ; \n s -> peers [ j ] . nb_eventfds = 0 ; \n } \n return 0 ; \n }", "idx": 4076}
{"project": "qemu", "commit_id": "caffdac363801cd2cf2bf01ad013a8c1e1e43800", "target": 1, "func": "static int s390_virtio_blk_init ( VirtIOS390Device * s390_dev ) \n { \n VirtIOBlkS390 * dev = VIRTIO_BLK_S390 ( s390_dev ) ; \n DeviceState * vdev = DEVICE ( & dev -> vdev ) ; \n virtio_blk_set_conf ( vdev , & ( dev -> blk ) ) ; \n qdev_set_parent_bus ( vdev , BUS ( & s390_dev -> bus ) ) ; \n if ( qdev_init ( vdev ) < 0 ) { \n return -1 ; \n } \n return s390_virtio_device_init ( s390_dev , VIRTIO_DEVICE ( vdev ) ) ; \n }", "idx": 4081}
{"project": "qemu", "commit_id": "52e60cdd342dc48116edb81b443ba8c0a0c6f1a3", "target": 1, "func": "static void aarch64_cpu_class_init ( ObjectClass * oc , void * data ) \n { \n CPUClass * cc = CPU_CLASS ( oc ) ; \n cc -> dump_state = aarch64_cpu_dump_state ; \n cc -> set_pc = aarch64_cpu_set_pc ; \n cc -> gdb_read_register = aarch64_cpu_gdb_read_register ; \n cc -> gdb_write_register = aarch64_cpu_gdb_write_register ; \n cc -> gdb_num_core_regs = 34 ; \n cc -> gdb_core_xml_file = \" \" ; \n }", "idx": 4090}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usb_net_handle_dataout ( USBNetState * s , USBPacket * p ) \n { \n int ret = p -> len ; \n int sz = sizeof ( s -> out_buf ) - s -> out_ptr ; \n struct rndis_packet_msg_type * msg = \n ( struct rndis_packet_msg_type * ) s -> out_buf ; \n uint32_t len ; \n #ifdef TRAFFIC_DEBUG \n fprintf ( stderr , \" \\n \" , p -> len ) ; \n { \n int i ; \n fprintf ( stderr , \" \" ) ; \n for ( i = 0 ; i < p -> len ; i ++ ) { \n if ( ! ( i & 15 ) ) \n fprintf ( stderr , \" \\n \" , i ) ; \n fprintf ( stderr , \" \" , p -> data [ i ] ) ; \n } \n fprintf ( stderr , \" \\n \\n \" ) ; \n } \n #endif \n if ( sz > ret ) \n sz = ret ; \n memcpy ( & s -> out_buf [ s -> out_ptr ] , p -> data , sz ) ; \n s -> out_ptr += sz ; \n if ( ! s -> rndis ) { \n if ( ret < 64 ) { \n qemu_send_packet ( & s -> nic -> nc , s -> out_buf , s -> out_ptr ) ; \n s -> out_ptr = 0 ; \n } \n return ret ; \n } \n len = le32_to_cpu ( msg -> MessageLength ) ; \n if ( s -> out_ptr < 8 || s -> out_ptr < len ) \n return ret ; \n if ( le32_to_cpu ( msg -> MessageType ) == RNDIS_PACKET_MSG ) { \n uint32_t offs = 8 + le32_to_cpu ( msg -> DataOffset ) ; \n uint32_t size = le32_to_cpu ( msg -> DataLength ) ; \n if ( offs + size <= len ) \n qemu_send_packet ( & s -> nic -> nc , s -> out_buf + offs , size ) ; \n } \n s -> out_ptr -= len ; \n memmove ( s -> out_buf , & s -> out_buf [ len ] , s -> out_ptr ) ; \n return ret ; \n }", "idx": 4112}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_get_backing_file_depth ( BlockDriverState * bs ) \n { \n if ( ! bs -> drv ) { \n return 0 ; \n } \n if ( ! bs -> backing_hd ) { \n return 0 ; \n } \n return 1 + bdrv_get_backing_file_depth ( bs -> backing_hd ) ; \n }", "idx": 4118}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void hmp_change_read_arg ( Monitor * mon , const char * password , \n void * opaque ) \n { \n qmp_change_vnc_password ( password , NULL ) ; \n monitor_read_command ( mon , 1 ) ; \n }", "idx": 4137}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static bool pcie_has_upstream_port ( PCIDevice * dev ) \n { \n PCIDevice * parent_dev = pci_bridge_get_device ( dev -> bus ) ; \n return parent_dev && \n pci_is_express ( parent_dev ) && \n parent_dev -> exp . exp_cap && \n ( pcie_cap_get_type ( parent_dev ) == PCI_EXP_TYPE_ROOT_PORT || \n pcie_cap_get_type ( parent_dev ) == PCI_EXP_TYPE_DOWNSTREAM ) ; \n }", "idx": 4194}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_gtdt ( GArray * table_data , GArray * linker )  \n { \n int gtdt_start = table_data -> len ; \n AcpiGenericTimerTable * gtdt ; \n gtdt = acpi_data_push ( table_data , sizeof * gtdt ) ; \n gtdt -> secure_el1_interrupt = ARCH_TIMER_S_EL1_IRQ + 16 ; \n gtdt -> secure_el1_flags = ACPI_EDGE_SENSITIVE ; \n gtdt -> non_secure_el1_interrupt = ARCH_TIMER_NS_EL1_IRQ + 16 ; \n gtdt -> non_secure_el1_flags = ACPI_EDGE_SENSITIVE ; \n gtdt -> virtual_timer_interrupt = ARCH_TIMER_VIRT_IRQ + 16 ; \n gtdt -> virtual_timer_flags = ACPI_EDGE_SENSITIVE ; \n gtdt -> non_secure_el2_interrupt = ARCH_TIMER_NS_EL2_IRQ + 16 ; \n gtdt -> non_secure_el2_flags = ACPI_EDGE_SENSITIVE ; \n build_header ( linker , table_data , \n ( void * ) ( table_data -> data + gtdt_start ) , \" \" , \n table_data -> len - gtdt_start , 2 , NULL ) ; \n }", "idx": 4219}
{"project": "qemu", "commit_id": "f1a6cf3ef734aab142d5f7ce52e219474ababf6b", "target": 1, "func": "static target_ulong h_random ( PowerPCCPU * cpu , sPAPRMachineState * spapr , \n target_ulong opcode , target_ulong * args ) \n { \n sPAPRRngState * rngstate ; \n HRandomData hrdata ; \n rngstate = SPAPR_RNG ( object_resolve_path_type ( \" \" , TYPE_SPAPR_RNG , NULL ) ) ; \n if ( ! rngstate || ! rngstate -> backend ) { \n return H_HARDWARE ; \n } \n qemu_sem_init ( & hrdata . sem , 0 ) ; \n hrdata . val . v64 = 0 ; \n hrdata . received = 0 ; \n qemu_mutex_unlock_iothread ( ) ; \n while ( hrdata . received < 8 ) { \n rng_backend_request_entropy ( rngstate -> backend , 8 - hrdata . received , \n random_recv , & hrdata ) ; \n qemu_sem_wait ( & hrdata . sem ) ; \n } \n qemu_mutex_lock_iothread ( ) ; \n qemu_sem_destroy ( & hrdata . sem ) ; \n args [ 0 ] = hrdata . val . v64 ; \n return H_SUCCESS ; \n }", "idx": 4232}
{"project": "qemu", "commit_id": "02e57e1c14a32aa1ed64e79d349d8e0e37cfaa27", "target": 1, "func": "static void sdhci_sysbus_realize ( DeviceState * dev , Error * * errp ) \n { \n SDHCIState * s = SYSBUS_SDHCI ( dev ) ; \n SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ; \n sdhci_common_realize ( s , errp ) ; \n if ( errp && * errp ) { \n return ; \n } \n if ( s -> dma_mr ) { \n address_space_init ( s -> dma_as , s -> dma_mr , \" \" ) ; \n } else { \n s -> dma_as = & address_space_memory ; \n } \n sysbus_init_irq ( sbd , & s -> irq ) ; \n sysbus_init_mmio ( sbd , & s -> iomem ) ; \n }", "idx": 4242}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void * rndis_queue_response ( USBNetState * s , unsigned int length ) \n { \n struct rndis_response * r = \n qemu_mallocz ( sizeof ( struct rndis_response ) + length ) ; \n TAILQ_INSERT_TAIL ( & s -> rndis_resp , r , entries ) ; \n r -> length = length ; \n return & r -> buf [ 0 ] ; \n }", "idx": 4270}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static char * visitor_get ( TestOutputVisitorData * data ) \n { \n data -> str = string_output_get_string ( data -> sov ) ; \n g_assert ( data -> str ) ; \n return data -> str ; \n }", "idx": 4273}
{"project": "qemu", "commit_id": "2569da0cb64506ea05323544c26f3aaffbf3f9fe", "target": 0, "func": "static void do_change_vnc ( const char * target ) \n { \n if ( strcmp ( target , \" \" ) == 0 || \n strcmp ( target , \" \" ) == 0 ) { \n char password [ 9 ] ; \n monitor_readline ( \" \" , 1 , password , sizeof ( password ) ) ; \n if ( vnc_display_password ( NULL , password ) < 0 ) \n term_printf ( \" \\n \" ) ; \n } else { \n if ( vnc_display_open ( NULL , target ) < 0 ) \n term_printf ( \" \\n \" , target ) ; \n } \n }", "idx": 4294}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int rom_add_blob ( const char * name , const void * blob , size_t len , \n target_phys_addr_t addr ) \n { \n Rom * rom ; \n rom = g_malloc0 ( sizeof ( * rom ) ) ; \n rom -> name = g_strdup ( name ) ; \n rom -> addr = addr ; \n rom -> romsize = len ; \n rom -> data = g_malloc0 ( rom -> romsize ) ; \n memcpy ( rom -> data , blob , len ) ; \n rom_insert ( rom ) ; \n return 0 ; \n }", "idx": 4321}
{"project": "qemu", "commit_id": "f24582d6ad8a080e008974c000bf0ae635d036ac", "target": 1, "func": "void qmp_output_visitor_cleanup ( QmpOutputVisitor * v ) \n { \n QStackEntry * e , * tmp ; \n QTAILQ_FOREACH_SAFE ( e , & v -> stack , node , tmp )  { \n QTAILQ_REMOVE ( & v -> stack , e , node ) ; \n if ( e -> value ) { \n qobject_decref ( e -> value ) ; \n } \n g_free ( e ) ; \n } \n g_free ( v ) ; \n }", "idx": 4351}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_udp ( QemuOpts * opts , CharDriverState * * _chr ) \n { \n CharDriverState * chr = NULL ; \n NetCharDriver * s = NULL ; \n int fd = -1 ; \n int ret ; \n chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n s = g_malloc0 ( sizeof ( NetCharDriver ) ) ; \n fd = inet_dgram_opts ( opts ) ; \n if ( fd < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n ret = - errno ; \n goto return_err ; \n } \n s -> fd = fd ; \n s -> bufcnt = 0 ; \n s -> bufptr = 0 ; \n chr -> opaque = s ; \n chr -> chr_write = udp_chr_write ; \n chr -> chr_update_read_handler = udp_chr_update_read_handler ; \n chr -> chr_close = udp_chr_close ; \n * _chr = chr ; \n return 0 ; \n return_err : \n g_free ( chr ) ; \n g_free ( s ) ; \n if ( fd >= 0 ) { \n closesocket ( fd ) ; \n } \n return ret ; \n }", "idx": 4352}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpsr ( CPUSPARCState * env , target_ulong new_psr ) \n { \n if ( ( new_psr & PSR_CWP ) >= env -> nwindows ) { \n cpu_raise_exception_ra ( env , TT_ILL_INSN , GETPC ( ) ) ; \n } else { \n cpu_put_psr ( env , new_psr ) ; \n } \n }", "idx": 4354}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpstate ( CPUSPARCState * env , target_ulong new_state ) \n { \n cpu_change_pstate ( env , new_state & 0xf3f ) ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  if ( cpu_interrupts_enabled ( env ) ) { \n cpu_check_irqs ( env ) ; \n } \n #endif \n }", "idx": 4373}
{"project": "qemu", "commit_id": "135a972b45203ba992afc99ef4f061be8a5acae0", "target": 1, "func": "void tb_flush ( CPUState * cpu ) \n { \n #if defined ( DEBUG_FLUSH )  \n  \n  printf ( \" \\n \" , \n ( unsigned long ) ( tcg_ctx . code_gen_ptr - tcg_ctx . code_gen_buffer ) , \n tcg_ctx . tb_ctx . nb_tbs , tcg_ctx . tb_ctx . nb_tbs > 0 ? \n ( ( unsigned long ) ( tcg_ctx . code_gen_ptr - tcg_ctx . code_gen_buffer ) ) / \n tcg_ctx . tb_ctx . nb_tbs : 0 ) ; \n #endif \n if ( ( unsigned long ) ( tcg_ctx . code_gen_ptr - tcg_ctx . code_gen_buffer ) \n > tcg_ctx . code_gen_buffer_size ) { \n cpu_abort ( cpu , \" \\n \" ) ; \n tcg_ctx . tb_ctx . nb_tbs = 0 ; \n CPU_FOREACH ( cpu ) { \n memset ( cpu -> tb_jmp_cache , 0 , sizeof ( cpu -> tb_jmp_cache ) ) ; \n cpu -> tb_flushed = true ; \n qht_reset_size ( & tcg_ctx . tb_ctx . htable , CODE_GEN_HTABLE_SIZE ) ; \n page_flush_tb ( ) ; \n tcg_ctx . code_gen_ptr = tcg_ctx . code_gen_buffer ; \n tcg_ctx . tb_ctx . tb_flush_count ++ ;", "idx": 4380}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "int register_savevm ( DeviceState * dev , \n const char * idstr , \n int instance_id , \n int version_id , \n SaveStateHandler * save_state , \n LoadStateHandler * load_state , \n void * opaque ) \n { \n SaveVMHandlers * ops = g_malloc0 ( sizeof ( SaveVMHandlers ) ) ; \n ops -> save_state = save_state ; \n ops -> load_state = load_state ; \n return register_savevm_live ( dev , idstr , instance_id , version_id , \n ops , opaque ) ; \n }", "idx": 4381}
{"project": "qemu", "commit_id": "805017b7791200f1b72deef17dc98fd272b941eb", "target": 0, "func": "static void test_validate_union ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefUnion * tmp = NULL ; \n Visitor * v ; \n Error * err = NULL ; \n v = validate_test_init ( data , \" \" ) ; \n visit_type_UserDefUnion ( v , & tmp , NULL , & err ) ; \n g_assert ( ! err ) ; \n qapi_free_UserDefUnion ( tmp ) ; \n }", "idx": 4408}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "VMChangeStateEntry * qemu_add_vm_change_state_handler ( VMChangeStateHandler * cb , \n void * opaque ) \n { \n VMChangeStateEntry * e ; \n e = qemu_mallocz ( sizeof ( * e ) ) ; \n e -> cb = cb ; \n e -> opaque = opaque ; \n LIST_INSERT_HEAD ( & vm_change_state_head , e , entries ) ; \n return e ; \n }", "idx": 4461}
{"project": "qemu", "commit_id": "88045ac55592cacc92567aa46cb6917854bf7241", "target": 0, "func": "static void rtas_read_pci_config ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n uint32_t val , size , addr ; \n PCIDevice * dev = find_dev ( spapr , 0 , rtas_ld ( args , 0 ) ) ; \n if ( ! dev ) { \n rtas_st ( rets , 0 , -1 ) ; \n return ; \n } \n size = rtas_ld ( args , 1 ) ; \n addr = rtas_pci_cfgaddr ( rtas_ld ( args , 0 ) ) ; \n val = pci_host_config_read_common ( dev , addr , pci_config_size ( dev ) , size ) ; \n rtas_st ( rets , 0 , 0 ) ; \n rtas_st ( rets , 1 , val ) ; \n }", "idx": 4494}
{"project": "qemu", "commit_id": "5ee163e8ea2fb6610339f494e039159e08a69066", "target": 0, "func": "void qmp_dump_guest_memory ( bool paging , const char * file , bool has_begin , \n int64_t begin , bool has_length , int64_t length , \n Error * * errp ) \n { \n const char * p ; \n int fd = -1 ; \n DumpState * s ; \n int ret ; \n if ( has_begin && ! has_length ) { \n error_set ( errp , QERR_MISSING_PARAMETER , \" \" ) ; \n return ; \n } \n if ( ! has_begin && has_length ) { \n error_set ( errp , QERR_MISSING_PARAMETER , \" \" ) ; \n return ; \n } \n #if ! defined ( WIN32 )  \n  \n  if ( strstart ( file , \" \" , & p ) ) { \n fd = monitor_get_fd ( cur_mon , p , errp ) ; \n if ( fd == -1 ) { \n return ; \n } \n } \n #endif \n if ( strstart ( file , \" \" , & p ) ) { \n fd = qemu_open ( p , O_WRONLY | O_CREAT | O_TRUNC | O_BINARY , S_IRUSR ) ; \n if ( fd < 0 ) { \n error_setg_file_open ( errp , errno , p ) ; \n return ; \n } \n } \n if ( fd == -1 ) { \n error_set ( errp , QERR_INVALID_PARAMETER , \" \" ) ; \n return ; \n } \n s = g_malloc ( sizeof ( DumpState ) ) ; \n ret = dump_init ( s , fd , paging , has_begin , begin , length , errp ) ; \n if ( ret < 0 ) { \n g_free ( s ) ; \n return ; \n } \n if ( create_vmcore ( s ) < 0 && ! error_is_set ( s -> errp ) ) { \n error_set ( errp , QERR_IO_ERROR ) ; \n } \n g_free ( s ) ; \n }", "idx": 4495}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_requests_pending ( BlockDriverState * bs ) \n { \n if ( ! QLIST_EMPTY ( & bs -> tracked_requests ) ) { \n return true ; \n } \n if ( ! qemu_co_queue_empty ( & bs -> throttled_reqs [ 0 ] ) ) { \n return true ; \n } \n if ( ! qemu_co_queue_empty ( & bs -> throttled_reqs [ 1 ] ) ) { \n return true ; \n } \n if ( bs -> file && bdrv_requests_pending ( bs -> file ) ) { \n return true ; \n } \n if ( bs -> backing_hd && bdrv_requests_pending ( bs -> backing_hd ) ) { \n return true ; \n } \n return false ; \n }", "idx": 4511}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void etsec_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n dc -> realize = etsec_realize ; \n dc -> reset = etsec_reset ; \n dc -> props = etsec_properties ; \n }", "idx": 4522}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "static int bdrv_qed_is_allocated ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , int * pnum ) \n { \n BDRVQEDState * s = bs -> opaque ; \n uint64_t pos = ( uint64_t ) sector_num * BDRV_SECTOR_SIZE ; \n size_t len = ( size_t ) nb_sectors * BDRV_SECTOR_SIZE ; \n QEDIsAllocatedCB cb = { \n . is_allocated = -1 , \n . pnum = pnum , \n } ; \n QEDRequest request = { . l2_table = NULL } ; \n async_context_push ( ) ; \n qed_find_cluster ( s , & request , pos , len , qed_is_allocated_cb , & cb ) ; \n while ( cb . is_allocated == -1 ) { \n qemu_aio_wait ( ) ; \n } \n async_context_pop ( ) ; \n qed_unref_l2_cache_entry ( request . l2_table ) ; \n return cb . is_allocated ; \n }", "idx": 4557}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_get_u64 ( struct vhost_dev * dev , int request , uint64_t * u64 ) \n { \n VhostUserMsg msg = { \n . request = request , \n . flags = VHOST_USER_VERSION , \n } ; \n if ( vhost_user_one_time_request ( request ) && dev -> vq_index != 0 ) { \n return 0 ; \n } \n vhost_user_write ( dev , & msg , NULL , 0 ) ; \n if ( vhost_user_read ( dev , & msg ) < 0 ) { \n return 0 ; \n } \n if ( msg . request != request ) { \n error_report ( \" \" , \n request , msg . request ) ; \n return -1 ; \n } \n if ( msg . size != sizeof ( m . u64 ) ) { \n error_report ( \" \" ) ; \n return -1 ; \n } \n * u64 = msg . u64 ; \n return 0 ; \n }", "idx": 4578}
{"project": "qemu", "commit_id": "fa131d94a5c00c6bbea39358d4bca7bf98f6c1f5", "target": 1, "func": "ObjectClass * object_class_dynamic_cast_assert ( ObjectClass * class , \n const char * typename , \n const char * file , int line , \n const char * func ) \n { \n ObjectClass * ret = object_class_dynamic_cast ( class , typename ) ; \n if ( ! ret && class ) { \n fprintf ( stderr , \" \\n \" , \n file , line , func , class , typename ) ; \n abort ( ) ; \n } \n return ret ; \n }", "idx": 4583}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_set_bootindex ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n NvmeCtrl * s = NVME ( obj ) ; \n int32_t boot_index ; \n Error * local_err = NULL ; \n visit_type_int32 ( v , & boot_index , name , & local_err ) ; \n if ( local_err ) { \n goto out ; \n } \n check_boot_index ( boot_index , & local_err ) ; \n if ( local_err ) { \n goto out ; \n } \n s -> conf . bootindex = boot_index ; \n out : \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n } \n }", "idx": 4594}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( divwu ) \n { \n if ( T1 == 0 ) { \n T0 = 0 ; \n } else { \n T0 /= T1 ; \n } \n RETURN ( ) ; \n }", "idx": 4598}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "void * rom_add_blob ( const char * name , const void * blob , size_t len , \n hwaddr addr , const char * fw_file_name , \n FWCfgReadCallback fw_callback , void * callback_opaque ) \n { \n Rom * rom ; \n void * data = NULL ; \n rom = g_malloc0 ( sizeof ( * rom ) ) ; \n rom -> name = g_strdup ( name ) ; \n rom -> addr = addr ; \n rom -> romsize = len ; \n rom -> datasize = len ; \n rom -> data = g_malloc0 ( rom -> datasize ) ; \n memcpy ( rom -> data , blob , len ) ; \n rom_insert ( rom ) ; \n if ( fw_file_name && fw_cfg ) { \n char devpath [ 100 ] ; \n snprintf ( devpath , sizeof ( devpath ) , \" \" , fw_file_name ) ; \n if ( rom_file_has_mr ) { \n data = rom_set_mr ( rom , OBJECT ( fw_cfg ) , devpath ) ; \n } else { \n data = rom -> data ; \n } \n fw_cfg_add_file_callback ( fw_cfg , fw_file_name , \n fw_callback , callback_opaque , \n data , rom -> romsize ) ; \n } \n return data ; \n }", "idx": 4600}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int qed_write_table ( BDRVQEDState * s , uint64_t offset , QEDTable * table , \n unsigned int index , unsigned int n , bool flush ) \n { \n unsigned int sector_mask = BDRV_SECTOR_SIZE / sizeof ( uint64_t ) - 1 ; \n unsigned int start , end , i ; \n QEDTable * new_table ; \n struct iovec iov ; \n QEMUIOVector qiov ; \n size_t len_bytes ; \n int ret ; \n trace_qed_write_table ( s , offset , table , index , n ) ; \n start = index & ~ sector_mask ; \n end = ( index + n + sector_mask ) & ~ sector_mask ; \n len_bytes = ( end - start ) * sizeof ( uint64_t ) ; \n new_table = qemu_blockalign ( s -> bs , len_bytes ) ; \n iov = ( struct iovec ) { \n . iov_base = new_table -> offsets , \n . iov_len = len_bytes , \n } ; \n qemu_iovec_init_external ( & qiov , & iov , 1 ) ; \n for ( i = start ; i < end ; i ++ ) { \n uint64_t le_offset = cpu_to_le64 ( table -> offsets [ i ] ) ; \n new_table -> offsets [ i - start ] = le_offset ; \n } \n offset += start * sizeof ( uint64_t ) ; \n ret = bdrv_pwritev ( s -> bs -> file , offset , & qiov ) ; \n trace_qed_write_table_cb ( s , table , flush , ret ) ; \n if ( ret < 0 ) { \n goto out ; \n } \n if ( flush ) { \n qed_acquire ( s ) ; \n ret = bdrv_flush ( s -> bs ) ; \n qed_release ( s ) ; \n if ( ret < 0 ) { \n goto out ; \n } \n } \n ret = 0 ; \n out : \n qemu_vfree ( new_table ) ; \n return ret ; \n }", "idx": 4606}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void vnc_init_basic_info ( SocketAddress * addr , \n VncBasicInfo * info , \n Error * * errp ) \n { \n switch ( addr -> type ) { \n case SOCKET_ADDRESS_KIND_INET : \n info -> host = g_strdup ( addr -> u . inet -> host ) ; \n info -> service = g_strdup ( addr -> u . inet -> port ) ; \n if ( addr -> u . inet -> ipv6 ) { \n info -> family = NETWORK_ADDRESS_FAMILY_IPV6 ; \n } else { \n info -> family = NETWORK_ADDRESS_FAMILY_IPV4 ; \n } \n break ; \n case SOCKET_ADDRESS_KIND_UNIX : \n info -> host = g_strdup ( \" \" ) ; \n info -> service = g_strdup ( addr -> u . q_unix -> path ) ; \n info -> family = NETWORK_ADDRESS_FAMILY_UNIX ; \n break ; \n default : \n error_setg ( errp , \" \" , \n addr -> type ) ; \n break ; \n } \n return ; \n }", "idx": 4612}
{"project": "qemu", "commit_id": "273a2142176098fe2c27f263d86ad66b133b43cb", "target": 0, "func": "static void disable_interrupt ( EEPRO100State * s ) \n { \n if ( s -> int_stat ) { \n logout ( \" \\n \" ) ; \n qemu_irq_lower ( s -> pci_dev -> irq [ 0 ] ) ; \n s -> int_stat = 0 ; \n } \n }", "idx": 4636}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_fstat ( FsContext * fs_ctx , int fid_type , \n V9fsFidOpenState * fs , struct stat * stbuf ) \n { \n int fd ; \n if ( fid_type == P9_FID_DIR ) { \n fd = dirfd ( fs -> dir ) ; \n } else { \n fd = fs -> fd ; \n } \n return fstat ( fd , stbuf ) ; \n }", "idx": 4708}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_data_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n CMD646BAR * cmd646bar = opaque ; \n if ( size == 1 ) { \n return ide_ioport_read ( cmd646bar -> bus , addr ) ; \n } else if ( addr == 0 ) { \n if ( size == 2 ) { \n return ide_data_readw ( cmd646bar -> bus , addr ) ; \n } else { \n return ide_data_readl ( cmd646bar -> bus , addr ) ; \n } \n } \n return ( ( uint64_t ) 1 << ( size * 8 ) ) - 1 ; \n }", "idx": 4713}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "int kvm_arch_insert_sw_breakpoint ( CPUState * env , struct kvm_sw_breakpoint * bp ) \n { \n static const uint8_t int3 = 0xcc ; \n if ( cpu_memory_rw_debug ( env , bp -> pc , ( uint8_t * ) & bp -> saved_insn , 1 , 0 ) || \n cpu_memory_rw_debug ( env , bp -> pc , ( uint8_t * ) & int3 , 1 , 1 ) ) \n return - EINVAL ; \n return 0 ; \n }", "idx": 4723}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void OPPROTO op_check_addo ( void ) \n { \n if ( likely ( ! ( ( ( uint32_t ) T2 ^ ( uint32_t ) T1 ^ UINT32_MAX ) & \n ( ( uint32_t ) T2 ^ ( uint32_t ) T0 ) & ( 1UL << 31 ) ) ) ) { \n xer_ov = 0 ; \n } else { \n xer_so = 1 ; \n xer_ov = 1 ; \n } \n RETURN ( ) ; \n }", "idx": 4757}
{"project": "qemu", "commit_id": "b6b2c9628084f1672b92393cf84039a075a95301", "target": 1, "func": "static gpointer writeout_thread ( gpointer opaque ) \n { \n TraceRecord * recordptr ; \n union { \n TraceRecord rec ; \n uint8_t bytes [ sizeof ( TraceRecord ) + sizeof ( uint64_t ) ] ; \n } dropped ; \n unsigned int idx = 0 ; \n int dropped_count ; \n size_t unused  __attribute__ ( ( unused ) ) ; \n for ( ; ; ) { \n wait_for_trace_records_available ( ) ; \n if ( g_atomic_int_get ( & dropped_events ) ) { \n dropped . rec . event = DROPPED_EVENT_ID , \n dropped . rec . timestamp_ns = get_clock ( ) ; \n dropped . rec . length = sizeof ( TraceRecord ) + sizeof ( uint64_t ) , \n dropped . rec . reserved = 0 ; \n while ( 1 ) { \n dropped_count = g_atomic_int_get ( & dropped_events ) ; \n if ( g_atomic_int_compare_and_exchange ( & dropped_events , \n dropped_count , 0 ) ) { \n break ; \n } \n } \n dropped . rec . arguments [ 0 ] = dropped_count ; \n unused = fwrite ( & dropped . rec , dropped . rec . length , 1 , trace_fp ) ; \n } \n while ( get_trace_record ( idx , & recordptr ) ) { \n unused = fwrite ( recordptr , recordptr -> length , 1 , trace_fp ) ; \n writeout_idx += recordptr -> length ; \n free ( recordptr ) ; \n idx = writeout_idx % TRACE_BUF_LEN ; \n } \n fflush ( trace_fp ) ; \n } \n return NULL ; \n }", "idx": 4767}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "AUXBus * aux_init_bus ( DeviceState * parent , const char * name ) \n { \n AUXBus * bus ; \n bus = AUX_BUS ( qbus_create ( TYPE_AUX_BUS , parent , name ) ) ; \n bus -> bridge = AUXTOI2C ( qdev_create ( BUS ( bus ) , TYPE_AUXTOI2C ) ) ; \n bus -> aux_io = g_malloc ( sizeof ( * bus -> aux_io ) ) ; \n memory_region_init ( bus -> aux_io , OBJECT ( bus ) , \" \" , ( 1 << 20 ) ) ; \n address_space_init ( & bus -> aux_addr_space , bus -> aux_io , \" \" ) ; \n return bus ; \n }", "idx": 4794}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void qdev_print_devinfo ( DeviceClass * dc ) \n { \n error_printf ( \" \\\" \\\" \" , object_class_get_name ( OBJECT_CLASS ( dc ) ) ) ; \n if ( dc -> bus_type ) { \n error_printf ( \" \" , dc -> bus_type ) ; \n } \n if ( qdev_class_has_alias ( dc ) ) { \n error_printf ( \" \\\" \\\" \" , qdev_class_get_alias ( dc ) ) ; \n } \n if ( dc -> desc ) { \n error_printf ( \" \\\" \\\" \" , dc -> desc ) ; \n } \n if ( dc -> no_user ) { \n error_printf ( \" \" ) ; \n } \n error_printf ( \" \\n \" ) ; \n }", "idx": 4818}
{"project": "qemu", "commit_id": "cab565c412a5634ce26f4d24ae65907c3108bdb0", "target": 0, "func": "uint32_t HELPER ( neon_acgt_f32 ) ( uint32_t a , uint32_t b ) \n { \n float32 f0 = float32_abs ( make_float32 ( a ) ) ; \n float32 f1 = float32_abs ( make_float32 ( b ) ) ; \n if ( float32_compare_quiet ( f0 , f1 , NFS ) == float_relation_greater ) { \n return ~ 0 ; \n } \n return 0 ; \n }", "idx": 4832}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "sosendto ( struct socket *  so , struct  mbuf * m ) \n { \n Slirp * slirp = so -> slirp ; \n int ret ; \n struct sockaddr_in addr ; \n DEBUG_CALL ( \" \" ) ; \n DEBUG_ARG ( \" \" , so ) ; \n DEBUG_ARG ( \" \" , m ) ; \n addr . sin_family = AF_INET ; \n if ( ( so -> so_faddr . s_addr & slirp -> vnetwork_mask . s_addr ) == \n slirp -> vnetwork_addr . s_addr ) { \n if ( so -> so_faddr . s_addr == slirp -> vnameserver_addr . s_addr ) { \n if ( get_dns_addr ( & addr . sin_addr ) < 0 ) \n addr . sin_addr = loopback_addr ; \n } else { \n addr . sin_addr = loopback_addr ; \n } \n } else \n addr . sin_addr = so -> so_faddr ; \n addr . sin_port = so -> so_fport ; \n DEBUG_MISC ( ( dfd , \" \\n \" , ntohs ( addr . sin_port ) , inet_ntoa ( addr . sin_addr ) ) ) ; \n ret = sendto ( so -> s , m -> m_data , m -> m_len , 0 , \n ( struct sockaddr * ) & addr , sizeof ( struct sockaddr ) ) ; \n if ( ret < 0 ) \n return -1 ; \n if ( so -> so_expire ) \n so -> so_expire = curtime + SO_EXPIRE ; \n so -> so_state &= SS_PERSISTENT_MASK ; \n so -> so_state |= SS_ISFCONNECTED ; \n return 0 ; \n }", "idx": 4847}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "long do_rt_sigreturn ( CPUSH4State * regs ) \n { \n struct target_rt_sigframe * frame ; \n abi_ulong frame_addr ; \n sigset_t blocked ; \n target_ulong r0 ; \n frame_addr = regs -> gregs [ 15 ] ; \n trace_user_do_rt_sigreturn ( regs , frame_addr ) ; \n if ( ! lock_user_struct ( VERIFY_READ , frame , frame_addr , 1 ) ) { \n goto badframe ; \n } \n target_to_host_sigset ( & blocked , & frame -> uc . tuc_sigmask ) ; \n do_sigprocmask ( SIG_SETMASK , & blocked , NULL ) ; \n restore_sigcontext ( regs , & frame -> uc . tuc_mcontext , & r0 ) ; \n if ( do_sigaltstack ( frame_addr + \n offsetof ( struct target_rt_sigframe , uc . tuc_stack ) , \n 0 , get_sp_from_cpustate ( regs ) ) == - EFAULT ) { \n goto badframe ; \n } \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n return r0 ; \n badframe : \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n force_sig ( TARGET_SIGSEGV ) ; \n return 0 ; \n }", "idx": 4886}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static void patch_reloc ( uint8_t * code_ptr , int type , \n intptr_t value , intptr_t addend ) \n { \n uint32_t insn ; \n value += addend ; \n switch ( type ) { \n case R_SPARC_32 : \n if ( value != ( uint32_t ) value ) { \n tcg_abort ( ) ; \n } \n * ( uint32_t * ) code_ptr = value ; \n break ; \n case R_SPARC_WDISP16 : \n value -= ( intptr_t ) code_ptr ; \n if ( ! check_fit_tl ( value >> 2 , 16 ) ) { \n tcg_abort ( ) ; \n } \n insn = * ( uint32_t * ) code_ptr ; \n insn &= ~ INSN_OFF16 ( -1 ) ; \n insn |= INSN_OFF16 ( value ) ; \n * ( uint32_t * ) code_ptr = insn ; \n break ; \n case R_SPARC_WDISP19 : \n value -= ( intptr_t ) code_ptr ; \n if ( ! check_fit_tl ( value >> 2 , 19 ) ) { \n tcg_abort ( ) ; \n } \n insn = * ( uint32_t * ) code_ptr ; \n insn &= ~ INSN_OFF19 ( -1 ) ; \n insn |= INSN_OFF19 ( value ) ; \n * ( uint32_t * ) code_ptr = insn ; \n break ; \n default : \n tcg_abort ( ) ; \n } \n }", "idx": 4891}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_unlinkat ( FsContext * ctx , V9fsPath * dir , \n const char * name , int flags ) \n { \n errno = EPERM ; \n return -1 ; \n }", "idx": 4903}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_start_object ( QJSON * json , const char * name ) \n { \n json_emit_element ( json , name ) ; \n qstring_append ( json -> str , \" \" ) ; \n json -> omit_comma = true ; \n }", "idx": 4909}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST ( qdict_get_int_test ) \n { \n int ret ; \n const int value = 100 ; \n const char * key = \" \" ; \n qdict_put ( tests_dict , key , qint_from_int ( value ) ) ; \n ret = qdict_get_int ( tests_dict , key ) ; \n fail_unless ( ret == value ) ; \n }", "idx": 4913}
{"project": "qemu", "commit_id": "806c9d71abbcd283c0a6d8250e5a6db951ba9494", "target": 0, "func": "static void float64_maddsub_update_excp ( CPUPPCState * env , float64 arg1 , \n float64 arg2 , float64 arg3 , \n unsigned int madd_flags ) \n { \n if ( unlikely ( ( float64_is_infinity ( arg1 ) && float64_is_zero ( arg2 ) ) || \n ( float64_is_zero ( arg1 ) && float64_is_infinity ( arg2 ) ) ) ) { \n arg1 = float_invalid_op_excp ( env , POWERPC_EXCP_FP_VXIMZ , 1 ) ; \n } else if ( unlikely ( float64_is_signaling_nan ( arg1 , & env -> fp_status ) || \n float64_is_signaling_nan ( arg2 , & env -> fp_status ) || \n float64_is_signaling_nan ( arg3 , & env -> fp_status ) ) ) { \n float_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN , 1 ) ; \n } else if ( ( float64_is_infinity ( arg1 ) || float64_is_infinity ( arg2 ) ) && \n float64_is_infinity ( arg3 ) ) { \n uint8_t aSign , bSign , cSign ; \n aSign = float64_is_neg ( arg1 ) ; \n bSign = float64_is_neg ( arg2 ) ; \n cSign = float64_is_neg ( arg3 ) ; \n if ( madd_flags & float_muladd_negate_c ) { \n cSign ^= 1 ; \n } \n if ( aSign ^ bSign ^ cSign ) { \n float_invalid_op_excp ( env , POWERPC_EXCP_FP_VXISI , 1 ) ; \n } \n } \n }", "idx": 4916}
{"project": "qemu", "commit_id": "00cf57747db98c6a9e4219cea39ac3113dde6993", "target": 0, "func": "static uint32_t check_alarm ( RTCState * s ) \n { \n uint8_t alarm_hour , alarm_min , alarm_sec ; \n uint8_t cur_hour , cur_min , cur_sec ; \n alarm_sec = rtc_from_bcd ( s , s -> cmos_data [ RTC_SECONDS_ALARM ] ) ; \n alarm_min = rtc_from_bcd ( s , s -> cmos_data [ RTC_MINUTES_ALARM ] ) ; \n alarm_hour = rtc_from_bcd ( s , s -> cmos_data [ RTC_HOURS_ALARM ] ) ; \n alarm_hour = convert_hour ( s , alarm_hour ) ; \n cur_sec = rtc_from_bcd ( s , s -> cmos_data [ RTC_SECONDS ] ) ; \n cur_min = rtc_from_bcd ( s , s -> cmos_data [ RTC_MINUTES ] ) ; \n cur_hour = rtc_from_bcd ( s , s -> cmos_data [ RTC_HOURS ] ) ; \n cur_hour = convert_hour ( s , cur_hour ) ; \n if ( ( ( s -> cmos_data [ RTC_SECONDS_ALARM ] & 0xc0 ) == 0xc0 \n || alarm_sec == cur_sec ) && \n ( ( s -> cmos_data [ RTC_MINUTES_ALARM ] & 0xc0 ) == 0xc0 \n || alarm_min == cur_min ) && \n ( ( s -> cmos_data [ RTC_HOURS_ALARM ] & 0xc0 ) == 0xc0 \n || alarm_hour == cur_hour ) ) { \n return 1 ; \n } \n return 0 ; \n }", "idx": 4930}
{"project": "qemu", "commit_id": "ce0bd027df9c62766a5417521d0f08f27359d43f", "target": 0, "func": "static int get_dns_addr ( struct in_addr * pdns_addr ) \n { \n char buff [ 512 ] ; \n char buff2 [ 257 ] ; \n FILE * f ; \n int found = 0 ; \n struct in_addr tmp_addr ; \n f = fopen ( \" \" , \" \" ) ; \n if ( ! f ) \n return -1 ; \n #ifdef DEBUG \n lprint ( \" \" ) ; \n #endif \n while ( fgets ( buff , 512 , f ) != NULL ) { \n if ( sscanf ( buff , \" \\t \" , buff2 ) == 1 ) { \n if ( ! inet_aton ( buff2 , & tmp_addr ) ) \n continue ; \n if ( tmp_addr . s_addr == loopback_addr . s_addr ) \n tmp_addr = our_addr ; \n if ( ! found ) \n * pdns_addr = tmp_addr ; \n #ifdef DEBUG \n else \n lprint ( \" , \" ) ; \n #endif \n if ( ++ found > 3 ) { \n #ifdef DEBUG \n lprint ( \" \" ) ; \n #endif \n break ; \n } \n #ifdef DEBUG \n else \n lprint ( \" \" , inet_ntoa ( tmp_addr ) ) ; \n #endif \n } \n } \n fclose ( f ) ; \n if ( ! found ) \n return -1 ; \n return 0 ; \n }", "idx": 4937}
{"project": "qemu", "commit_id": "2bbf11d753761ca537333c2bd7ddadb06758f62c", "target": 0, "func": "static bool aio_epoll_try_enable ( AioContext * ctx ) \n { \n AioHandler * node ; \n struct epoll_event event ; \n QLIST_FOREACH ( node , & ctx -> aio_handlers , node )  { \n int r ; \n if ( node -> deleted || ! node -> pfd . events ) { \n continue ; \n } \n event . events = epoll_events_from_pfd ( node -> pfd . events ) ; \n event . data . ptr = node ; \n r = epoll_ctl ( ctx -> epollfd , EPOLL_CTL_ADD , node -> pfd . fd , & event ) ; \n if ( r ) { \n return false ; \n } \n } \n ctx -> epoll_enabled = true ; \n return true ; \n }", "idx": 4945}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_parse ( const char * opt ) \n { \n const char * endp , * p ; \n int vlan ; \n if ( strstart ( opt , \" \" , & endp ) ) { \n if ( ! * endp || * endp == ' ' ) { \n if ( * endp ) \n if ( ! strstart ( endp , \" \" , 0 ) ) \n opt = endp + 1 ; \n return bt_hci_parse ( opt ) ; \n } \n } else if ( strstart ( opt , \" \" , & endp ) ) { \n if ( ! * endp || * endp == ' ' ) { \n if ( * endp ) { \n if ( strstart ( endp , \" \" , & p ) ) { \n vlan = strtol ( p , ( char * * ) & endp , 0 ) ; \n if ( * endp ) { \n fprintf ( stderr , \" \\n \" , p ) ; \n return 1 ; \n } \n } else { \n fprintf ( stderr , \" \\n \" , endp + 1 ) ; \n return 1 ; \n } \n } else \n vlan = 0 ; \n bt_vhci_add ( vlan ) ; \n return 0 ; \n } \n } else if ( strstart ( opt , \" \" , & endp ) ) \n return ! bt_device_add ( endp ) ; \n fprintf ( stderr , \" \\n \" , opt ) ; \n return 1 ; \n }", "idx": 4948}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpui_io_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned size ) \n { \n omap_badwidth_write16 ( opaque , addr , value ) ; \n }", "idx": 4949}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void term_handle_command ( char * cmdline ) \n { \n char * p , * pstart ; \n int argc ; \n const char * args [ MAX_ARGS + 1 ] ; \n term_cmd_t * cmd ; \n #ifdef DEBUG \n term_printf ( \" \\n \" , cmdline ) ; \n #endif \n argc = 0 ; \n p = cmdline ; \n for ( ; ; ) { \n while ( isspace ( * p ) ) \n p ++ ; \n if ( * p == ' \\0 ' ) \n break ; \n pstart = p ; \n while ( * p != ' \\0 ' && ! isspace ( * p ) ) \n p ++ ; \n args [ argc ] = pstart ; \n argc ++ ; \n if ( argc >= MAX_ARGS ) \n break ; \n if ( * p == ' \\0 ' ) \n break ; \n * p ++ = ' \\0 ' ; \n } \n args [ argc ] = NULL ; \n #ifdef DEBUG \n for ( i = 0 ; i < argc ; i ++ ) { \n term_printf ( \" \" , args [ i ] ) ; \n } \n term_printf ( \" \\n \" ) ; \n #endif \n if ( argc <= 0 ) \n return ; \n for ( cmd = term_cmds ; cmd -> name != NULL ; cmd ++ ) { \n if ( compare_cmd ( args [ 0 ] , cmd -> name ) ) \n goto found ; \n } \n term_printf ( \" \\n \" , args [ 0 ] ) ; \n return ; \n found : \n cmd -> handler ( argc , args ) ; \n }", "idx": 4960}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static void m5206_mbar_writew ( void * opaque , target_phys_addr_t offset , \n uint32_t value ) \n { \n m5206_mbar_state * s = ( m5206_mbar_state * ) opaque ; \n int width ; \n offset &= 0x3ff ; \n if ( offset > 0x200 ) { \n hw_error ( \" \" , ( int ) offset ) ; \n } \n width = m5206_mbar_width [ offset >> 2 ] ; \n if ( width > 2 ) { \n uint32_t tmp ; \n tmp = m5206_mbar_readl ( opaque , offset & ~ 3 ) ; \n if ( offset & 3 ) { \n tmp = ( tmp & 0xffff0000 ) | value ; \n } else { \n tmp = ( tmp & 0x0000ffff ) | ( value << 16 ) ; \n } \n m5206_mbar_writel ( opaque , offset & ~ 3 , tmp ) ; \n return ; \n } else if ( width < 2 ) { \n m5206_mbar_writeb ( opaque , offset , value >> 8 ) ; \n m5206_mbar_writeb ( opaque , offset + 1 , value & 0xff ) ; \n return ; \n } \n m5206_mbar_write ( s , offset , value , 2 ) ; \n }", "idx": 4971}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_peek_byte ( QEMUFile * f , int offset ) \n { \n int index = f -> buf_index + offset ; \n assert ( ! qemu_file_is_writable ( f ) ) ; \n assert ( offset < IO_BUF_SIZE ) ; \n if ( index >= f -> buf_size ) { \n qemu_fill_buffer ( f ) ; \n index = f -> buf_index + offset ; \n if ( index >= f -> buf_size ) { \n return 0 ; \n } \n } \n return f -> buf [ index ] ; \n }", "idx": 4976}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "monitor_protocol_event_queue ( MonitorEvent  event , \n QObject * data ) \n { \n MonitorEventState * evstate ; \n int64_t now = qemu_clock_get_ns ( QEMU_CLOCK_REALTIME ) ; \n assert ( event < QEVENT_MAX ) ; \n qemu_mutex_lock ( & monitor_event_state_lock ) ; \n evstate = & ( monitor_event_state [ event ] ) ; \n trace_monitor_protocol_event_queue ( event , \n data , \n evstate -> rate , \n evstate -> last , \n now ) ; \n if ( ! evstate -> rate ) { \n monitor_protocol_event_emit ( event , data ) ; \n evstate -> last = now ; \n } else { \n int64_t delta = now - evstate -> last ; \n if ( evstate -> data || \n delta < evstate -> rate ) { \n if ( evstate -> data ) { \n qobject_decref ( evstate -> data ) ; \n } else { \n int64_t then = evstate -> last + evstate -> rate ; \n timer_mod_ns ( evstate -> timer , then ) ; \n } \n evstate -> data = data ; \n qobject_incref ( evstate -> data ) ; \n } else { \n monitor_protocol_event_emit ( event , data ) ; \n evstate -> last = now ; \n } \n } \n qemu_mutex_unlock ( & monitor_event_state_lock ) ; \n }", "idx": 4992}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void * qemu_memalign ( size_t alignment , size_t size ) \n { \n if ( ! size ) { \n abort ( ) ; \n } \n return oom_check ( VirtualAlloc ( NULL , size , MEM_COMMIT , PAGE_READWRITE ) ) ; \n }", "idx": 5002}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void slow_bar_writel ( void * opaque , target_phys_addr_t addr , uint32_t val ) \n { \n AssignedDevRegion * d = opaque ; \n uint32_t * out = ( uint32_t * ) ( d -> u . r_virtbase + addr ) ; \n DEBUG ( \" \" TARGET_FMT_plx \" \\n \" , addr , val ) ; \n * out = val ; \n }", "idx": 5008}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "SCSIDevice * scsi_bus_legacy_add_drive ( SCSIBus * bus , DriveInfo * dinfo , int unit ) \n { \n const char * driver ; \n DeviceState * dev ; \n driver = bdrv_is_sg ( dinfo -> bdrv ) ? \" \" : \" \" ; \n dev = qdev_create ( & bus -> qbus , driver ) ; \n qdev_prop_set_uint32 ( dev , \" \" , unit ) ; \n qdev_prop_set_drive ( dev , \" \" , dinfo ) ; \n if ( qdev_init ( dev ) < 0 ) \n return NULL ; \n return DO_UPCAST ( SCSIDevice , qdev , dev ) ; \n }", "idx": 5020}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_stop ( MemoryListener * listener , MemoryRegionSection * section ) \n { \n XenIOState * state = container_of ( listener , XenIOState , memory_listener ) ; \n state -> log_for_dirtybit = NULL ; \n xc_hvm_track_dirty_vram ( xen_xc , xen_domid , 0 , 0 , NULL ) ; \n }", "idx": 5027}
{"project": "qemu", "commit_id": "ede9c94acf6cd1968de4188c0228b714ab871a86", "target": 0, "func": "static int vtd_int_remap ( X86IOMMUState * iommu , MSIMessage * src , \n MSIMessage * dst , uint16_t sid ) \n { \n return vtd_interrupt_remap_msi ( INTEL_IOMMU_DEVICE ( iommu ) , src , dst ) ; \n }", "idx": 5036}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void core_region_nop ( MemoryListener * listener , \n MemoryRegionSection * section ) \n { \n cpu_register_physical_memory_log ( section , section -> readonly ) ; \n }", "idx": 5041}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 uint64_to_float32 ( uint64 a STATUS_PARAM ) \n { \n int8 shiftCount ; \n if ( a == 0 ) return 0 ; \n shiftCount = countLeadingZeros64 ( a ) - 40 ; \n if ( 0 <= shiftCount ) { \n return packFloat32 ( 1 > 0 , 0x95 - shiftCount , a << shiftCount ) ; \n } \n else { \n shiftCount += 7 ; \n if ( shiftCount < 0 ) { \n shift64RightJamming ( a , - shiftCount , & a ) ; \n } \n else { \n a <<= shiftCount ; \n } \n return roundAndPackFloat32 ( 1 > 0 , 0x9C - shiftCount , a STATUS_VAR ) ; \n } \n }", "idx": 5048}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void do_change_vnc ( const char * target , const char * arg ) \n { \n if ( strcmp ( target , \" \" ) == 0 || \n strcmp ( target , \" \" ) == 0 ) { \n char password [ 9 ] ; \n if ( arg ) { \n strncpy ( password , arg , sizeof ( password ) ) ; \n password [ sizeof ( password ) - 1 ] = ' \\0 ' ; \n } else \n monitor_readline ( \" \" , 1 , password , sizeof ( password ) ) ; \n if ( vnc_display_password ( NULL , password ) < 0 ) \n term_printf ( \" \\n \" ) ; \n } else { \n if ( vnc_display_open ( NULL , target ) < 0 ) \n term_printf ( \" \\n \" , target ) ; \n } \n }", "idx": 5051}
{"project": "qemu", "commit_id": "24d3bd67aca958c8ea103646d9d326de00056e4d", "target": 0, "func": "static struct scsi_task * iscsi_do_inquiry ( struct iscsi_context * iscsi , int lun , \n int evpd , int pc , Error * * errp ) \n { \n int full_size ; \n struct scsi_task * task = NULL ; \n task = iscsi_inquiry_sync ( iscsi , lun , evpd , pc , 64 ) ; \n if ( task == NULL || task -> status != SCSI_STATUS_GOOD ) { \n goto fail ; \n } \n full_size = scsi_datain_getfullsize ( task ) ; \n if ( full_size > task -> datain . size ) { \n scsi_free_scsi_task ( task ) ; \n task = iscsi_inquiry_sync ( iscsi , lun , evpd , pc , full_size ) ; \n if ( task == NULL || task -> status != SCSI_STATUS_GOOD ) { \n goto fail ; \n } \n } \n return task ; \n fail : \n error_setg ( errp , \" \" , \n iscsi_get_error ( iscsi ) ) ; \n if ( task ) { \n scsi_free_scsi_task ( task ) ; \n return NULL ; \n } \n return NULL ; \n }", "idx": 5052}
{"project": "qemu", "commit_id": "1c0fbfa3dedf49115e194e533a7b6a640a28447c", "target": 1, "func": "static void virtio_net_add_queue ( VirtIONet * n , int index ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( n ) ; \n n -> vqs [ index ] . rx_vq = virtio_add_queue ( vdev , 256 , virtio_net_handle_rx ) ; \n if ( n -> net_conf . tx && ! strcmp ( n -> net_conf . tx , \" \" ) ) { \n n -> vqs [ index ] . tx_vq = \n virtio_add_queue ( vdev , 256 , virtio_net_handle_tx_timer ) ; \n n -> vqs [ index ] . tx_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , \n virtio_net_tx_timer , \n & n -> vqs [ index ] ) ; \n } else { \n n -> vqs [ index ] . tx_vq = \n virtio_add_queue ( vdev , 256 , virtio_net_handle_tx_bh ) ; \n n -> vqs [ index ] . tx_bh = qemu_bh_new ( virtio_net_tx_bh , & n -> vqs [ index ] ) ; \n } \n n -> vqs [ index ] . tx_waiting = 0 ; \n n -> vqs [ index ] . n = n ; \n }", "idx": 5072}
{"project": "qemu", "commit_id": "a614f52dc70fd4c424a6248ae98c42494b9a89e7", "target": 0, "func": "static int grackle_pci_host_init ( PCIDevice * d ) \n { \n pci_config_set_vendor_id ( d -> config , PCI_VENDOR_ID_MOTOROLA ) ; \n pci_config_set_device_id ( d -> config , PCI_DEVICE_ID_MOTOROLA_MPC106 ) ; \n d -> config [ 0x08 ] = 0x00 ; \n d -> config [ 0x09 ] = 0x01 ; \n pci_config_set_class ( d -> config , PCI_CLASS_BRIDGE_HOST ) ; \n return 0 ; \n }", "idx": 5081}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void icp_realize ( DeviceState * dev , Error * * errp ) \n { \n ICPState * icp = ICP ( dev ) ; \n ICPStateClass * icpc = ICP_GET_CLASS ( dev ) ; \n Object * obj ; \n Error * err = NULL ; \n obj = object_property_get_link ( OBJECT ( dev ) , ICP_PROP_XICS , & err ) ; \n if ( ! obj ) { \n error_setg ( errp , \" \" ICP_PROP_XICS \" \" , \n __func__ , error_get_pretty ( err ) ) ; \n return ; \n } \n icp -> xics = XICS_FABRIC ( obj ) ; \n if ( icpc -> realize ) { \n icpc -> realize ( dev , errp ) ; \n } \n qemu_register_reset ( icp_reset , dev ) ; \n }", "idx": 5085}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int ( TestInputVisitorData * data , \n const void * unused ) \n { \n test_native_list_integer_helper ( data , unused , \n USER_DEF_NATIVE_LIST_UNION_KIND_INTEGER ) ; \n }", "idx": 5087}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_max ( void ) \n { \n char * str = g_strdup_printf ( \" \" , ULLONG_MAX ) ; \n char f = ' ' ; \n const char * endptr = & f ; \n uint64_t res = 999 ; \n int err ; \n err = qemu_strtoull ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , ULLONG_MAX ) ; \n g_assert ( endptr == str + strlen ( str ) ) ; \n g_free ( str ) ; \n }", "idx": 5091}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static inline void * array_get_next ( array_t * array ) { \n unsigned int next = array -> next ; \n void * result ; \n if ( array_ensure_allocated ( array , next ) < 0 ) \n return NULL ; \n array -> next = next + 1 ; \n result = array_get ( array , next ) ; \n return result ; \n }", "idx": 5098}
{"project": "qemu", "commit_id": "d8b7e0adf562277180f96ecbd7f1777a384a0308", "target": 0, "func": "static int raw_read ( BlockDriverState * bs , int64_t sector_num , \n uint8_t * buf , int nb_sectors ) \n { \n return bdrv_read ( bs -> file , sector_num , buf , nb_sectors ) ; \n }", "idx": 5101}
{"project": "qemu", "commit_id": "e1556ad5b8143a15c26067c3862fe20631c0053f", "target": 1, "func": "static uint32_t omap2_gpio_module_readp ( void * opaque , target_phys_addr_t addr ) \n { \n return omap2_gpio_module_readp ( opaque , addr ) >> ( ( addr & 3 ) << 3 ) ; \n }", "idx": 5116}
{"project": "qemu", "commit_id": "6f6867493cc00974de594a509cee5a3be61c64aa", "target": 1, "func": "static void guest_fsfreeze_cleanup ( void ) \n { \n int64_t ret ; \n Error * err = NULL ; \n if ( ga_is_frozen ( ga_state ) == GUEST_FSFREEZE_STATUS_FROZEN ) { \n ret = qmp_guest_fsfreeze_thaw ( & err ) ; \n if ( ret < 0 || err ) { \n slog ( \" \" ) ; \n } \n } \n }", "idx": 5122}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static ssize_t flush_buf ( VirtIOSerialPort * port , \n const uint8_t * buf , ssize_t len ) \n { \n VirtConsole * vcon = VIRTIO_CONSOLE ( port ) ; \n ssize_t ret ; \n if ( ! vcon -> chr ) { \n return len ; \n } \n ret = qemu_chr_fe_write ( vcon -> chr , buf , len ) ; \n trace_virtio_console_flush_buf ( port -> id , len , ret ) ; \n if ( ret < len ) { \n VirtIOSerialPortClass * k = VIRTIO_SERIAL_PORT_GET_CLASS ( port ) ;", "idx": 5157}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static void tcp_chr_read ( void * opaque ) \n { \n CharDriverState * chr = opaque ; \n TCPCharDriver * s = chr -> opaque ; \n uint8_t buf [ READ_BUF_LEN ] ; \n int len , size ; \n if ( ! s -> connected || s -> max_size <= 0 ) \n return ; \n len = sizeof ( buf ) ; \n if ( len > s -> max_size ) \n len = s -> max_size ; \n size = tcp_chr_recv ( chr , ( void * ) buf , len ) ; \n if ( size == 0 ) { \n s -> connected = 0 ; \n if ( s -> listen_fd >= 0 ) { \n qemu_set_fd_handler ( s -> listen_fd , tcp_chr_accept , NULL , chr ) ; \n } \n qemu_set_fd_handler ( s -> fd , NULL , NULL , NULL ) ; \n closesocket ( s -> fd ) ; \n s -> fd = -1 ; \n qemu_chr_event ( chr , CHR_EVENT_CLOSED ) ; \n } else if ( size > 0 ) { \n if ( s -> do_telnetopt ) \n tcp_chr_process_IAC_bytes ( chr , s , buf , & size ) ; \n if ( size > 0 ) \n qemu_chr_read ( chr , buf , size ) ; \n if ( s -> msgfd != -1 ) { \n close ( s -> msgfd ) ; \n s -> msgfd = -1 ; \n } \n } \n }", "idx": 5158}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "void virtio_panic ( const char * string ) \n { \n sclp_print ( string ) ; \n disabled_wait ( ) ; \n while ( 1 ) { } \n }", "idx": 5177}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "bool migrate_zero_blocks ( void ) \n { \n MigrationState * s ; \n s = migrate_get_current ( ) ; \n return s -> enabled_capabilities [ MIGRATION_CAPABILITY_ZERO_BLOCKS ] ; \n }", "idx": 5180}
{"project": "qemu", "commit_id": "574ef17191f5ec5a3cc4782c1f59dc5eb8279654", "target": 0, "func": "static int ehci_state_executing ( EHCIQueue * q ) \n { \n EHCIPacket * p = QTAILQ_FIRST ( & q -> packets ) ; \n int again = 0 ; \n assert ( p != NULL ) ; \n assert ( p -> qtdaddr == q -> qtdaddr ) ; \n ehci_execute_complete ( q ) ; \n if ( p -> usb_status == USB_RET_ASYNC ) { \n goto out ; \n } \n if ( p -> usb_status == USB_RET_PROCERR ) { \n again = -1 ; \n goto out ; \n } \n if ( ! q -> async ) { \n int transactCtr = get_field ( q -> qh . epcap , QH_EPCAP_MULT ) ; \n transactCtr -- ; \n set_field ( & q -> qh . epcap , transactCtr , QH_EPCAP_MULT ) ; \n } \n if ( p -> usb_status == USB_RET_NAK ) { \n ehci_set_state ( q -> ehci , q -> async , EST_HORIZONTALQH ) ; \n } else { \n ehci_set_state ( q -> ehci , q -> async , EST_WRITEBACK ) ; \n } \n again = 1 ; \n out : \n ehci_flush_qh ( q ) ; \n return again ; \n }", "idx": 5197}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void check_exception ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n uint32_t mask , buf , len ; \n uint64_t xinfo ; \n if ( ( nargs < 6 ) || ( nargs > 7 ) || nret != 1 ) { \n rtas_st ( rets , 0 , -3 ) ; \n return ; \n } \n xinfo = rtas_ld ( args , 1 ) ; \n mask = rtas_ld ( args , 2 ) ; \n buf = rtas_ld ( args , 4 ) ; \n len = rtas_ld ( args , 5 ) ; \n if ( nargs == 7 ) { \n xinfo |= ( uint64_t ) rtas_ld ( args , 6 ) << 32 ; \n } \n if ( ( mask & EVENT_MASK_EPOW ) && pending_epow ) { \n if ( sizeof ( * pending_epow ) < len ) { \n len = sizeof ( * pending_epow ) ; \n } \n cpu_physical_memory_write ( buf , pending_epow , len ) ; \n g_free ( pending_epow ) ; \n pending_epow = NULL ; \n rtas_st ( rets , 0 , 0 ) ; \n } else { \n rtas_st ( rets , 0 , 1 ) ; \n } \n }", "idx": 5252}
{"project": "qemu", "commit_id": "75b0713e189a981e5bfd087d5f35705446bbb12a", "target": 1, "func": "static void nvdimm_build_nfit ( GSList * device_list , GArray * table_offsets , \n GArray * table_data , BIOSLinker * linker ) \n { \n GArray * structures = nvdimm_build_device_structure ( device_list ) ; \n unsigned int header ; \n acpi_add_table ( table_offsets , table_data ) ; \n header = table_data -> len ; \n acpi_data_push ( table_data , sizeof ( NvdimmNfitHeader ) ) ; \n g_array_append_vals ( table_data , structures -> data , structures -> len ) ; \n build_header ( linker , table_data , \n ( void * ) ( table_data -> data + header ) , \" \" , \n sizeof ( NvdimmNfitHeader ) + structures -> len , 1 , NULL , NULL ) ; \n g_array_free ( structures , true ) ; \n }", "idx": 5255}
{"project": "qemu", "commit_id": "9adea5f7f7a23ef4a1231289a36a94c52347b142", "target": 0, "func": "do_send_recv ( int  sockfd , struct  iovec * iov , unsigned iov_cnt , bool do_send ) \n { \n #if defined CONFIG_IOVEC  & & defined CONFIG_POSIX \n ssize_t ret ; \n struct msghdr msg ; \n memset ( & msg , 0 , sizeof ( msg ) ) ; \n msg . msg_iov = iov ; \n msg . msg_iovlen = iov_cnt ; \n do { \n ret = do_send \n ? sendmsg ( sockfd , & msg , 0 ) \n : recvmsg ( sockfd , & msg , 0 ) ; \n } while ( ret < 0 && errno == EINTR ) ; \n return ret ; \n #else  \n  \n  \n  \n  \n  \n  unsigned i = 0 ; \n ssize_t ret = 0 ; \n while ( i < iov_cnt ) { \n ssize_t r = do_send \n ? send ( sockfd , iov [ i ] . iov_base , iov [ i ] . iov_len , 0 ) \n : recv ( sockfd , iov [ i ] . iov_base , iov [ i ] . iov_len , 0 ) ; \n if ( r > 0 ) { \n ret += r ; \n } else if ( ! r ) { \n break ; \n } else if ( errno == EINTR ) { \n continue ; \n } else { \n if ( ret == 0 ) { \n ret = -1 ; \n } \n break ; \n } \n i ++ ; \n } \n return ret ; \n #endif  \n  \n  }", "idx": 5289}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST ( keyword_literal ) \n { \n QObject * obj ; \n QBool * qbool ; \n QString * str ; \n obj = qobject_from_json ( \" \" ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; \n qbool = qobject_to_qbool ( obj ) ; \n fail_unless ( qbool_get_int ( qbool ) != 0 ) ; \n str = qobject_to_json ( obj ) ; \n fail_unless ( strcmp ( qstring_get_str ( str ) , \" \" ) == 0 ) ; \n QDECREF ( str ) ; \n QDECREF ( qbool ) ; \n obj = qobject_from_json ( \" \" ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; \n qbool = qobject_to_qbool ( obj ) ; \n fail_unless ( qbool_get_int ( qbool ) == 0 ) ; \n str = qobject_to_json ( obj ) ; \n fail_unless ( strcmp ( qstring_get_str ( str ) , \" \" ) == 0 ) ; \n QDECREF ( str ) ; \n QDECREF ( qbool ) ; \n obj = qobject_from_jsonf ( \" \" , false ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; \n qbool = qobject_to_qbool ( obj ) ; \n fail_unless ( qbool_get_int ( qbool ) == 0 ) ; \n QDECREF ( qbool ) ; \n obj = qobject_from_jsonf ( \" \" , true ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; \n qbool = qobject_to_qbool ( obj ) ; \n fail_unless ( qbool_get_int ( qbool ) != 0 ) ; \n QDECREF ( qbool ) ; \n }", "idx": 5290}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_rt_sigreturn ( CPUAlphaState * env ) \n { \n abi_ulong frame_addr = env -> ir [ IR_A0 ] ; \n struct target_rt_sigframe * frame ; \n sigset_t set ; \n if ( ! lock_user_struct ( VERIFY_READ , frame , frame_addr , 1 ) ) { \n goto badframe ; \n } \n target_to_host_sigset ( & set , & frame -> uc . tuc_sigmask ) ; \n do_sigprocmask ( SIG_SETMASK , & set , NULL ) ; \n if ( restore_sigcontext ( env , & frame -> uc . tuc_mcontext ) ) { \n goto badframe ; \n } \n if ( do_sigaltstack ( frame_addr + offsetof ( struct target_rt_sigframe , \n uc . tuc_stack ) , \n 0 , env -> ir [ IR_SP ] ) == - EFAULT ) { \n goto badframe ; \n } \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n return env -> ir [ IR_V0 ] ; \n badframe : \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n force_sig ( TARGET_SIGSEGV ) ; \n }", "idx": 5359}
{"project": "qemu", "commit_id": "f7838b5290de03f7cb2dbee5bd1ceae67b4a5ef0", "target": 0, "func": "static void cortex_a9_initfn ( Object * obj ) \n { \n ARMCPU * cpu = ARM_CPU ( obj ) ; \n cpu -> dtb_compatible = \" \" ; \n set_feature ( & cpu -> env , ARM_FEATURE_V7 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_VFP3 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_VFP_FP16 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_NEON ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_THUMB2EE ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_V7MP ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_CBAR ) ; \n cpu -> midr = 0x410fc090 ; \n cpu -> reset_fpsid = 0x41033090 ; \n cpu -> mvfr0 = 0x11110222 ; \n cpu -> mvfr1 = 0x01111111 ; \n cpu -> ctr = 0x80038003 ; \n cpu -> reset_sctlr = 0x00c50078 ; \n cpu -> id_pfr0 = 0x1031 ; \n cpu -> id_pfr1 = 0x11 ; \n cpu -> id_dfr0 = 0x000 ; \n cpu -> id_afr0 = 0 ; \n cpu -> id_mmfr0 = 0x00100103 ; \n cpu -> id_mmfr1 = 0x20000000 ; \n cpu -> id_mmfr2 = 0x01230000 ; \n cpu -> id_mmfr3 = 0x00002111 ; \n cpu -> id_isar0 = 0x00101111 ; \n cpu -> id_isar1 = 0x13112111 ; \n cpu -> id_isar2 = 0x21232041 ; \n cpu -> id_isar3 = 0x11112131 ; \n cpu -> id_isar4 = 0x00111142 ; \n cpu -> dbgdidr = 0x35141000 ; \n cpu -> clidr = ( 1 << 27 ) | ( 1 << 24 ) | 3 ; \n cpu -> ccsidr [ 0 ] = 0xe00fe015 ; \n cpu -> ccsidr [ 1 ] = 0x200fe015 ; \n define_arm_cp_regs ( cpu , cortexa9_cp_reginfo ) ; \n }", "idx": 5366}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static void bt_hci_reset ( struct bt_hci_s * hci ) \n { \n hci -> acl_len = 0 ; \n hci -> last_cmd = 0 ; \n hci -> lm . connecting = 0 ; \n hci -> event_mask [ 0 ] = 0xff ; \n hci -> event_mask [ 1 ] = 0xff ; \n hci -> event_mask [ 2 ] = 0xff ; \n hci -> event_mask [ 3 ] = 0xff ; \n hci -> event_mask [ 4 ] = 0xff ; \n hci -> event_mask [ 5 ] = 0x1f ; \n hci -> event_mask [ 6 ] = 0x00 ; \n hci -> event_mask [ 7 ] = 0x00 ; \n hci -> device . inquiry_scan = 0 ; \n hci -> device . page_scan = 0 ; \n if ( hci -> device . lmp_name ) \n g_free ( ( void * ) hci -> device . lmp_name ) ; \n hci -> device . lmp_name = NULL ; \n hci -> device . class [ 0 ] = 0x00 ; \n hci -> device . class [ 1 ] = 0x00 ; \n hci -> device . class [ 2 ] = 0x00 ; \n hci -> voice_setting = 0x0000 ; \n hci -> conn_accept_tout = 0x1f40 ; \n hci -> lm . inquiry_mode = 0x00 ; \n hci -> psb_handle = 0x000 ; \n hci -> asb_handle = 0x000 ; \n timer_del ( hci -> lm . inquiry_done ) ; \n timer_del ( hci -> lm . inquiry_next ) ; \n timer_del ( hci -> conn_accept_timer ) ; \n }", "idx": 5379}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static void net_tx_pkt_do_sw_csum ( struct NetTxPkt * pkt ) \n { \n struct iovec * iov = & pkt -> vec [ NET_TX_PKT_L2HDR_FRAG ] ; \n uint32_t csum_cntr ; \n uint16_t csum = 0 ; \n uint32_t iov_len = pkt -> payload_frags + NET_TX_PKT_PL_START_FRAG - 1 ; \n uint16_t csl ; \n struct ip_header * iphdr ; \n size_t csum_offset = pkt -> virt_hdr . csum_start + pkt -> virt_hdr . csum_offset ; \n iov_from_buf ( iov , iov_len , csum_offset , & csum , sizeof csum ) ; \n csl = pkt -> payload_len ; \n csum_cntr = \n net_checksum_add_iov ( iov , iov_len , pkt -> virt_hdr . csum_start , csl ) ; \n iphdr = pkt -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_base ; \n csum_cntr += eth_calc_pseudo_hdr_csum ( iphdr , csl ) ; \n csum = cpu_to_be16 ( net_checksum_finish ( csum_cntr ) ) ; \n iov_from_buf ( iov , iov_len , csum_offset , & csum , sizeof csum ) ; \n }", "idx": 5380}
{"project": "qemu", "commit_id": "9bcec938aab22a1b7ced916a6895e5029d4ed04f", "target": 1, "func": "void apic_reset_irq_delivered ( void ) \n { \n trace_apic_reset_irq_delivered ( apic_irq_delivered ) ; \n apic_irq_delivered = 0 ; \n }", "idx": 5402}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static TAPState * net_tap_fd_init ( VLANState * vlan , int fd ) \n { \n TAPState * s ; \n s = qemu_mallocz ( sizeof ( TAPState ) ) ; \n if ( ! s ) \n return NULL ; \n s -> fd = fd ; \n s -> vc = qemu_new_vlan_client ( vlan , tap_receive , s ) ; \n qemu_set_fd_handler ( s -> fd , tap_send , NULL , s ) ; \n snprintf ( s -> vc -> info_str , sizeof ( s -> vc -> info_str ) , \" \" , fd ) ; \n return s ; \n }", "idx": 5403}
{"project": "qemu", "commit_id": "74c85296dc880568005b8e7572e08a39d66bcdca", "target": 0, "func": "static ram_addr_t s390_virtio_device_num_vq ( VirtIOS390Device * dev ) \n { \n VirtIODevice * vdev = dev -> vdev ; \n int num_vq ; \n for ( num_vq = 0 ; num_vq < VIRTIO_PCI_QUEUE_MAX ; num_vq ++ ) { \n if ( ! virtio_queue_get_num ( vdev , num_vq ) ) { \n break ; \n } \n } \n return num_vq ; \n }", "idx": 5459}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int jazz_led_init ( SysBusDevice * dev ) \n { \n LedState * s = FROM_SYSBUS ( LedState , dev ) ; \n memory_region_init_io ( & s -> iomem , & led_ops , s , \" \" , 1 ) ; \n sysbus_init_mmio ( dev , & s -> iomem ) ; \n s -> con = graphic_console_init ( jazz_led_update_display , \n jazz_led_invalidate_display , \n NULL , \n jazz_led_text_update , s ) ; \n return 0 ; \n }", "idx": 5464}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t hpet_ram_readb ( void * opaque , target_phys_addr_t addr ) \n { \n printf ( \" \" PRIx64 \" \\n \" , addr ) ; \n return 0 ; \n }", "idx": 5467}
{"project": "qemu", "commit_id": "60e68042cf70f271308dc6b4b22b609d054af929", "target": 0, "func": "static bool x86_cpu_has_work ( CPUState * cs ) \n { \n X86CPU * cpu = X86_CPU ( cs ) ; \n CPUX86State * env = & cpu -> env ; \n return ( ( cs -> interrupt_request & ( CPU_INTERRUPT_HARD | \n CPU_INTERRUPT_POLL ) ) && \n ( env -> eflags & IF_MASK ) ) || \n ( cs -> interrupt_request & ( CPU_INTERRUPT_NMI | \n CPU_INTERRUPT_INIT | \n CPU_INTERRUPT_SIPI | \n CPU_INTERRUPT_MCE ) ) ; \n }", "idx": 5484}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "static void sd_reset ( SDState * sd , BlockBackend * blk ) \n { \n uint64_t size ; \n uint64_t sect ; \n if ( blk ) { \n blk_get_geometry ( blk , & sect ) ; \n } else { \n sect = 0 ; \n } \n size = sect << 9 ; \n sect = sd_addr_to_wpnum ( size ) + 1 ; \n sd -> state = sd_idle_state ; \n sd -> rca = 0x0000 ; \n sd_set_ocr ( sd ) ; \n sd_set_scr ( sd ) ; \n sd_set_cid ( sd ) ; \n sd_set_csd ( sd , size ) ; \n sd_set_cardstatus ( sd ) ; \n sd_set_sdstatus ( sd ) ; \n sd -> blk = blk ; \n if ( sd -> wp_groups ) \n g_free ( sd -> wp_groups ) ; \n sd -> wp_switch = blk ? blk_is_read_only ( blk ) : false ; \n sd -> wpgrps_size = sect ; \n sd -> wp_groups = bitmap_new ( sd -> wpgrps_size ) ; \n memset ( sd -> function_group , 0 , sizeof ( sd -> function_group ) ) ; \n sd -> erase_start = 0 ; \n sd -> erase_end = 0 ; \n sd -> size = size ; \n sd -> blk_len = 0x200 ; \n sd -> pwd_len = 0 ; \n sd -> expecting_acmd = false ; \n }", "idx": 5487}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "struct GuestAgentInfo * qmp_guest_info ( Error * * errp ) \n { \n GuestAgentInfo * info = g_malloc0 ( sizeof ( GuestAgentInfo ) ) ; \n info -> version = g_strdup ( QEMU_VERSION ) ; \n qmp_for_each_command ( qmp_command_info , info ) ; \n return info ; \n }", "idx": 5510}
{"project": "qemu", "commit_id": "d9d3aaea0b3fbb5028e20316bdb93359487cd01f", "target": 1, "func": "void replay_configure ( QemuOpts * opts ) \n { \n const char * fname ; \n const char * rr ; \n ReplayMode mode = REPLAY_MODE_NONE ; \n Location loc ; \n if ( ! opts ) { \n return ; \n } \n loc_push_none ( & loc ) ; \n qemu_opts_loc_restore ( opts ) ; \n rr = qemu_opt_get ( opts , \" \" ) ; \n if ( ! rr ) { \n return ; \n } else if ( ! strcmp ( rr , \" \" ) ) { \n mode = REPLAY_MODE_RECORD ; \n } else if ( ! strcmp ( rr , \" \" ) ) { \n mode = REPLAY_MODE_PLAY ; \n } else { \n error_report ( \" \" , rr ) ; \n exit ( 1 ) ; \n } \n fname = qemu_opt_get ( opts , \" \" ) ; \n if ( ! fname ) { \n error_report ( \" \" ) ; \n exit ( 1 ) ; \n } \n replay_enable ( fname , mode ) ; \n loc_pop ( & loc ) ; \n }", "idx": 5521}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "void scsi_req_dequeue ( SCSIRequest * req ) \n { \n trace_scsi_req_dequeue ( req -> dev -> id , req -> lun , req -> tag ) ; \n if ( req -> enqueued ) { \n QTAILQ_REMOVE ( & req -> dev -> requests , req , next ) ; \n req -> enqueued = false ; \n scsi_req_unref ( req ) ; \n } \n }", "idx": 5526}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_test_bit ( int64_t bitnum , const uint8_t * bitmap ) \n { \n return ( bitmap [ bitnum / 8 ] & ( 1 << ( bitnum & 7 ) ) ) != 0 ; \n }", "idx": 5566}
{"project": "qemu", "commit_id": "40fda982f2e887f7d5cc36b8a7e3b5a07a1e6704", "target": 0, "func": "static void kvmppc_host_cpu_class_init ( ObjectClass * oc , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( oc ) ; \n PowerPCCPUClass * pcc = POWERPC_CPU_CLASS ( oc ) ; \n uint32_t vmx = kvmppc_get_vmx ( ) ; \n uint32_t dfp = kvmppc_get_dfp ( ) ; \n uint32_t dcache_size = kvmppc_read_int_cpu_dt ( \" \" ) ; \n uint32_t icache_size = kvmppc_read_int_cpu_dt ( \" \" ) ; \n pcc -> pvr = mfpvr ( ) ; \n if ( vmx != -1 ) { \n alter_insns ( & pcc -> insns_flags , PPC_ALTIVEC , vmx > 0 ) ; \n alter_insns ( & pcc -> insns_flags2 , PPC2_VSX , vmx > 1 ) ; \n } \n if ( dfp != -1 ) { \n alter_insns ( & pcc -> insns_flags2 , PPC2_DFP , dfp ) ; \n } \n if ( dcache_size != -1 ) { \n pcc -> l1_dcache_size = dcache_size ; \n } \n if ( icache_size != -1 ) { \n pcc -> l1_icache_size = icache_size ; \n } \n dc -> cannot_destroy_with_object_finalize_yet = true ; \n }", "idx": 5573}
{"project": "qemu", "commit_id": "53333801e7bb41487147599e1b16b60ebea74695", "target": 1, "func": "static void test_acpi_one ( const char * params ) \n { \n char * args ; \n uint8_t signature_low ; \n uint8_t signature_high ; \n uint16_t signature ; \n int i ; \n uint32_t off ; \n args = g_strdup_printf ( \" \" , \n params ? params : \" \" , disk ) ; \n qtest_start ( args ) ; \n #define TEST_DELAY  (1 * G_USEC_PER_SEC / 10)  \n  \n  #define TEST_CYCLES  MAX((60 * G_USEC_PER_SEC / TEST_DELAY), 1)  \n  \n  \n  \n  \n  for ( i = 0 ; i < TEST_CYCLES ; ++ i ) { \n signature_low = readb ( BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET ) ; \n signature_high = readb ( BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1 ) ; \n signature = ( signature_high << 8 ) | signature_low ; \n if ( signature == SIGNATURE ) { \n break ; \n } \n g_usleep ( TEST_DELAY ) ; \n } \n g_assert_cmphex ( signature , == , SIGNATURE ) ; \n for ( off = 0xf0000 ; off < 0x100000 ; off += 0x10 ) \n { \n uint8_t sig [ ] = \" \" ; \n int i ; \n for ( i = 0 ; i < sizeof sig - 1 ; ++ i ) { \n sig [ i ] = readb ( off + i ) ; \n } \n if ( ! memcmp ( sig , \" \" , sizeof sig ) ) { \n break ; \n } \n } \n g_assert_cmphex ( off , < , 0x100000 ) ; \n qtest_quit ( global_qtest ) ; \n g_free ( args ) ; \n }", "idx": 5601}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_dpll_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned size ) \n { \n struct dpll_ctl_s * s = ( struct dpll_ctl_s * ) opaque ; \n uint16_t diff ; \n static const int bypass_div [ 4 ] = { 1 , 2 , 4 , 4 } ; \n int div , mult ; \n if ( size != 2 ) { \n return omap_badwidth_write16 ( opaque , addr , value ) ; \n } \n if ( addr == 0x00 ) { \n diff = s -> mode & value ; \n s -> mode = value & 0x2fff ; \n if ( diff & ( 0x3ff << 2 ) ) { \n if ( value & ( 1 << 4 ) ) { \n div = ( ( value >> 5 ) & 3 ) + 1 ; \n mult = MIN ( ( value >> 7 ) & 0x1f , 1 ) ; \n } else { \n div = bypass_div [ ( ( value >> 2 ) & 3 ) ] ; \n mult = 1 ; \n } \n omap_clk_setrate ( s -> dpll , div , mult ) ; \n } \n s -> mode = ( s -> mode & 0xfffe ) | ( ( s -> mode >> 4 ) & 1 ) ; \n s -> mode |= 2 ; \n } else { \n OMAP_BAD_REG ( addr ) ; \n } \n }", "idx": 5638}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsneg ( DisasContext * ctx ) \n { \n if ( unlikely ( ! ctx -> spe_enabled ) ) { \n gen_exception ( ctx , POWERPC_EXCP_APU ) ; \n return ; \n } \n #if defined ( TARGET_PPC64 )  \n  \n  tcg_gen_xori_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x8000000080000000LL ) ; \n #else \n tcg_gen_xori_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x80000000 ) ; \n tcg_gen_xori_tl ( cpu_gprh [ rD ( ctx -> opcode ) ] , cpu_gprh [ rA ( ctx -> opcode ) ] , 0x80000000 ) ; \n #endif \n }", "idx": 5640}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qmp_input_start_list ( Visitor * v , const char * name , Error * * errp ) \n { \n QmpInputVisitor * qiv = to_qiv ( v ) ; \n QObject * qobj = qmp_input_get_object ( qiv , name , true ) ; \n if ( ! qobj || qobject_type ( qobj ) != QTYPE_QLIST ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : \" \" , \n \" \" ) ; \n return ; \n } \n qmp_input_push ( qiv , qobj , errp ) ; \n }", "idx": 5648}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void nvic_sysreg_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned size ) \n { \n uint32_t offset = addr ; \n if ( size == 4 ) { \n nvic_writel ( opaque , offset , value ) ; \n return ; \n } \n hw_error ( \" \\n \" , size , offset ) ; \n }", "idx": 5660}
{"project": "qemu", "commit_id": "3716d5902d743e9a395b7d82f48df4fa56ed1ad3", "target": 0, "func": "static void pci_init_bus_master ( PCIDevice * pci_dev ) \n { \n AddressSpace * dma_as = pci_device_iommu_address_space ( pci_dev ) ; \n memory_region_init_alias ( & pci_dev -> bus_master_enable_region , \n OBJECT ( pci_dev ) , \" \" , \n dma_as -> root , 0 , memory_region_size ( dma_as -> root ) ) ; \n memory_region_set_enabled ( & pci_dev -> bus_master_enable_region , false ) ; \n address_space_init ( & pci_dev -> bus_master_as , \n & pci_dev -> bus_master_enable_region , pci_dev -> name ) ; \n }", "idx": 5666}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier_poll ( AioContext * ctx , \n EventNotifier * notifier , \n EventNotifierHandler * io_poll_begin , \n EventNotifierHandler * io_poll_end ) \n { \n aio_set_fd_poll ( ctx , event_notifier_get_fd ( notifier ) , \n ( IOHandler * ) io_poll_begin , \n ( IOHandler * ) io_poll_end ) ; \n }", "idx": 5674}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t m5208_sys_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n switch ( addr ) { \n case 0x110 : \n { \n int n ; \n for ( n = 0 ; n < 32 ; n ++ ) { \n if ( ram_size < ( 2u << n ) ) \n break ; \n } \n return ( n - 1 ) | 0x40000000 ; \n } \n case 0x114 : \n return 0 ; \n default : \n hw_error ( \" \\n \" , ( int ) addr ) ; \n return 0 ; \n } \n }", "idx": 5682}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "func": "static int vhost_user_set_vring_addr ( struct vhost_dev * dev , \n struct vhost_vring_addr * addr ) \n { \n VhostUserMsg msg = { \n . request = VHOST_USER_SET_VRING_ADDR , \n . flags = VHOST_USER_VERSION , \n . payload . addr = * addr , \n . size = sizeof ( msg . payload . addr ) , \n } ; \n vhost_user_write ( dev , & msg , NULL , 0 ) ; \n return 0 ; \n }", "idx": 5713}
{"project": "qemu", "commit_id": "3da9eebda96780ead8ba44b8140c54f4a54c61f6", "target": 1, "func": "static void vmstate_subsection_save ( QEMUFile * f , const VMStateDescription * vmsd , \n void * opaque ) \n { \n const VMStateSubsection * sub = vmsd -> subsections ; \n while ( sub && sub -> needed ) { \n if ( sub -> needed ( opaque ) ) { \n const VMStateDescription * vmsd = sub -> vmsd ; \n uint8_t len ; \n qemu_put_byte ( f , QEMU_VM_SUBSECTION ) ; \n len = strlen ( vmsd -> name ) ; \n qemu_put_byte ( f , len ) ; \n qemu_put_buffer ( f , ( uint8_t * ) vmsd -> name , len ) ; \n qemu_put_be32 ( f , vmsd -> version_id ) ; \n assert ( ! vmsd -> subsections ) ; \n vmstate_save_state ( f , vmsd , opaque ) ; \n } \n sub ++ ; \n } \n }", "idx": 5768}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static const char * token_get_value ( QObject * obj ) \n { \n return qdict_get_str ( qobject_to_qdict ( obj ) , \" \" ) ; \n }", "idx": 5816}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_store_d ( struct fs_dma_ctrl * ctrl , int c ) \n { \n target_phys_addr_t addr = channel_reg ( ctrl , c , RW_SAVED_DATA ) ; \n D ( printf ( \" \" TARGET_FMT_plx \" \\n \" , __func__ , c , addr ) ) ; \n cpu_physical_memory_write ( addr , \n ( void * ) & ctrl -> channels [ c ] . current_d , \n sizeof ctrl -> channels [ c ] . current_d ) ; \n }", "idx": 5825}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_ulpd_pm_init ( MemoryRegion * system_memory , \n target_phys_addr_t base , \n struct omap_mpu_state_s * mpu ) \n { \n memory_region_init_io ( & mpu -> ulpd_pm_iomem , & omap_ulpd_pm_ops , mpu , \n \" \" , 0x800 ) ; \n memory_region_add_subregion ( system_memory , base , & mpu -> ulpd_pm_iomem ) ; \n omap_ulpd_pm_reset ( mpu ) ; \n }", "idx": 5827}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "int usb_device_detach ( USBDevice * dev ) \n { \n USBBus * bus = usb_bus_from_device ( dev ) ; \n USBPort * port ; \n if ( ! dev -> attached ) { \n error_report ( \" \\n \" , \n dev -> product_desc ) ; \n return -1 ; \n } \n dev -> attached -- ; \n QTAILQ_FOREACH ( port , & bus -> used , next )  { \n if ( port -> dev == dev ) \n break ; \n } \n assert ( port != NULL ) ; \n QTAILQ_REMOVE ( & bus -> used , port , next ) ; \n bus -> nused -- ; \n usb_attach ( port , NULL ) ; \n QTAILQ_INSERT_TAIL ( & bus -> free , port , next ) ; \n bus -> nfree ++ ; \n return 0 ; \n }", "idx": 5831}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "int select_watchdog ( const char * p ) \n { \n WatchdogTimerModel * model ; \n if ( watchdog ) { \n fprintf ( stderr , \n \" \\n \" ) ; \n return 1 ; \n } \n if ( strcmp ( p , \" \" ) == 0 ) { \n LIST_FOREACH ( model , & watchdog_list , entry )  { \n fprintf ( stderr , \" \\t \\t \\n \" , \n model -> wdt_name , model -> wdt_description ) ; \n } \n return 2 ; \n } \n LIST_FOREACH ( model , & watchdog_list , entry )  { \n if ( strcasecmp ( model -> wdt_name , p ) == 0 ) { \n watchdog = model ; \n return 0 ; \n } \n } \n fprintf ( stderr , \" \\n \" ) ; \n LIST_FOREACH ( model , & watchdog_list , entry )  { \n fprintf ( stderr , \" \\t \\t \\n \" , \n model -> wdt_name , model -> wdt_description ) ; \n } \n return 1 ; \n }", "idx": 5867}
{"project": "qemu", "commit_id": "f7b9358e2cf12a5eb07f5f9301fdadc932f9ee03", "target": 0, "func": "static void gicv3_cpuif_el_change_hook ( ARMCPU * cpu , void * opaque ) \n { \n }", "idx": 5880}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static char * vnc_socket_remote_addr ( const char * format , int fd ) { \n struct sockaddr_storage sa ; \n socklen_t salen ; \n salen = sizeof ( sa ) ; \n if ( getpeername ( fd , ( struct sockaddr * ) & sa , & salen ) < 0 ) \n return NULL ; \n return addr_to_string ( format , & sa , salen ) ; \n }", "idx": 5913}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static uint32_t pci_unin_main_config_readl ( void * opaque , \n target_phys_addr_t addr ) \n { \n UNINState * s = opaque ; \n uint32_t val ; \n val = s -> config_reg ; \n #ifdef TARGET_WORDS_BIGENDIAN \n val = bswap32 ( val ) ; \n #endif \n UNIN_DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr , val ) ; \n return val ; \n }", "idx": 5928}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_dma_read_prp ( NvmeCtrl * n , uint8_t * ptr , uint32_t len , \n uint64_t prp1 , uint64_t prp2 ) \n { \n QEMUSGList qsg ; \n QEMUIOVector iov ; \n uint16_t status = NVME_SUCCESS ; \n if ( nvme_map_prp ( & qsg , & iov , prp1 , prp2 , len , n ) ) { \n return NVME_INVALID_FIELD | NVME_DNR ; \n } \n if ( qsg . nsg > 0 ) { \n if ( dma_buf_read ( ptr , len , & qsg ) ) { \n status = NVME_INVALID_FIELD | NVME_DNR ; \n } \n qemu_sglist_destroy ( & qsg ) ; \n } else { \n if ( qemu_iovec_to_buf ( & iov , 0 , ptr , len ) != len ) { \n status = NVME_INVALID_FIELD | NVME_DNR ; \n } \n qemu_iovec_destroy ( & iov ) ; \n } \n return status ; \n }", "idx": 5937}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState * i2c_create_slave ( i2c_bus * bus , const char * name , uint8_t addr ) \n { \n DeviceState * dev ; \n dev = qdev_create ( & bus -> qbus , name ) ; \n qdev_prop_set_uint8 ( dev , \" \" , addr ) ; \n qdev_init ( dev ) ; \n return dev ; \n }", "idx": 5970}
{"project": "qemu", "commit_id": "92335a0d4021a3b44ccc88c9fc6c0fd2113f1882", "target": 1, "func": "static void strongarm_gpio_write ( void * opaque , hwaddr offset , \n uint64_t value , unsigned size ) \n { \n StrongARMGPIOInfo * s = opaque ; \n switch ( offset ) { \n case GPDR : \n s -> dir = value ; \n strongarm_gpio_handler_update ( s ) ; \n break ; \n case GPSR : \n s -> olevel |= value ; \n strongarm_gpio_handler_update ( s ) ; \n s -> gpsr = value ; \n break ; \n case GPCR : \n s -> olevel &= ~ value ; \n strongarm_gpio_handler_update ( s ) ; \n break ; \n case GRER : \n s -> rising = value ; \n break ; \n case GFER : \n s -> falling = value ; \n break ; \n case GAFR : \n s -> gafr = value ; \n break ; \n case GEDR : \n s -> status &= ~ value ; \n strongarm_gpio_irq_update ( s ) ; \n break ; \n default : \n printf ( \" \" TARGET_FMT_plx \" \\n \" , __func__ , offset ) ; \n } \n }", "idx": 5983}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int vhost_scsi_exit ( DeviceState * qdev ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( qdev ) ; \n VHostSCSI * s = VHOST_SCSI ( qdev ) ; \n VirtIOSCSICommon * vs = VIRTIO_SCSI_COMMON ( qdev ) ; \n migrate_del_blocker ( s -> migration_blocker ) ; \n error_free ( s -> migration_blocker ) ; \n vhost_scsi_set_status ( vdev , 0 ) ; \n g_free ( s -> dev . vqs ) ; \n return virtio_scsi_common_exit ( vs ) ; \n }", "idx": 5996}
{"project": "qemu", "commit_id": "2d9907a3332888e43bc73fe9b98a32f8de662526", "target": 0, "func": "void pmac_format_nvram_partition ( MacIONVRAMState * nvr , int len ) \n { \n unsigned int i ; \n uint32_t start = 0 , end ; \n struct OpenBIOS_nvpart_v1 * part_header ; \n part_header = ( struct OpenBIOS_nvpart_v1 * ) nvr -> data ; \n part_header -> signature = OPENBIOS_PART_SYSTEM ; \n pstrcpy ( part_header -> name , sizeof ( part_header -> name ) , \" \" ) ; \n end = start + sizeof ( struct OpenBIOS_nvpart_v1 ) ; \n for ( i = 0 ; i < nb_prom_envs ; i ++ ) \n end = OpenBIOS_set_var ( nvr -> data , end , prom_envs [ i ] ) ; \n nvr -> data [ end ++ ] = ' \\0 ' ; \n end = start + ( ( end - start + 15 ) & ~ 15 ) ; \n if ( end < DEF_SYSTEM_SIZE ) \n end = DEF_SYSTEM_SIZE ; \n OpenBIOS_finish_partition ( part_header , end - start ) ; \n start = end ; \n part_header = ( struct OpenBIOS_nvpart_v1 * ) & nvr -> data [ start ] ; \n part_header -> signature = OPENBIOS_PART_FREE ; \n pstrcpy ( part_header -> name , sizeof ( part_header -> name ) , \" \" ) ; \n end = len ; \n OpenBIOS_finish_partition ( part_header , end - start ) ; \n }", "idx": 6005}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_slq ( DisasContext * ctx ) \n { \n int l1 = gen_new_label ( ) ; \n TCGv t0 = tcg_temp_new ( ) ; \n TCGv t1 = tcg_temp_new ( ) ; \n tcg_gen_andi_tl ( t1 , cpu_gpr [ rB ( ctx -> opcode ) ] , 0x1F ) ; \n tcg_gen_shl_tl ( t0 , cpu_gpr [ rS ( ctx -> opcode ) ] , t1 ) ; \n tcg_gen_subfi_tl ( t1 , 32 , t1 ) ; \n tcg_gen_shr_tl ( t1 , cpu_gpr [ rS ( ctx -> opcode ) ] , t1 ) ; \n tcg_gen_or_tl ( t1 , t0 , t1 ) ; \n gen_store_spr ( SPR_MQ , t1 ) ; \n tcg_gen_andi_tl ( t1 , cpu_gpr [ rB ( ctx -> opcode ) ] , 0x20 ) ; \n tcg_gen_mov_tl ( cpu_gpr [ rA ( ctx -> opcode ) ] , t0 ) ; \n tcg_gen_brcondi_tl ( TCG_COND_EQ , t1 , 0 , l1 ) ; \n tcg_gen_movi_tl ( cpu_gpr [ rA ( ctx -> opcode ) ] , 0 ) ; \n gen_set_label ( l1 ) ; \n tcg_temp_free ( t0 ) ; \n tcg_temp_free ( t1 ) ; \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n }", "idx": 6012}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "vmxnet3_pop_rxc_descr ( VMXNET3State * s , int qidx , uint32_t * descr_gen )  \n { \n uint8_t ring_gen ; \n struct Vmxnet3_RxCompDesc rxcd ; \n hwaddr daddr = \n vmxnet3_ring_curr_cell_pa ( & s -> rxq_descr [ qidx ] . comp_ring ) ; \n pci_dma_read ( PCI_DEVICE ( s ) , daddr , \n & rxcd , sizeof ( struct Vmxnet3_RxCompDesc ) ) ; \n ring_gen = vmxnet3_ring_curr_gen ( & s -> rxq_descr [ qidx ] . comp_ring ) ; \n if ( rxcd . gen != ring_gen ) { \n * descr_gen = ring_gen ; \n vmxnet3_inc_rx_completion_counter ( s , qidx ) ; \n return daddr ; \n } \n return 0 ; \n }", "idx": 6027}
{"project": "qemu", "commit_id": "51941e4695c6f6c1f786bacef7e8c3a477570e04", "target": 0, "func": "void vncws_tls_handshake_peek ( void * opaque ) \n { \n VncState * vs = opaque ; \n long ret ; \n if ( ! vs -> ws_tls . session ) { \n char peek [ 4 ] ; \n ret = qemu_recv ( vs -> csock , peek , sizeof ( peek ) , MSG_PEEK ) ; \n if ( ret && ( strncmp ( peek , \" \\x16 \" , 1 ) == 0 \n || strncmp ( peek , \" \\x80 \" , 1 ) == 0 ) ) { \n VNC_DEBUG ( \" \" ) ; \n vnc_tls_client_setup ( vs , 1 ) ; \n vncws_start_tls_handshake ( vs ) ; \n } else { \n vncws_handshake_read ( vs ) ; \n } \n } else { \n qemu_set_fd_handler2 ( vs -> csock , NULL , vncws_handshake_read , NULL , vs ) ; \n } \n }", "idx": 6047}
{"project": "qemu", "commit_id": "dd941cdcfec536aad6a310a153778142ed9f3e92", "target": 0, "func": "bool check_hw_breakpoints ( CPUX86State * env , bool force_dr6_update ) \n { \n target_ulong dr6 ; \n int reg ; \n bool hit_enabled = false ; \n dr6 = env -> dr [ 6 ] & ~ 0xf ; \n for ( reg = 0 ; reg < DR7_MAX_BP ; reg ++ ) { \n bool bp_match = false ; \n bool wp_match = false ; \n switch ( hw_breakpoint_type ( env -> dr [ 7 ] , reg ) ) { \n case DR7_TYPE_BP_INST : \n if ( env -> dr [ reg ] == env -> eip ) { \n bp_match = true ; \n } \n break ; \n case DR7_TYPE_DATA_WR : \n case DR7_TYPE_DATA_RW : \n if ( env -> cpu_watchpoint [ reg ] && \n env -> cpu_watchpoint [ reg ] -> flags & BP_WATCHPOINT_HIT ) { \n wp_match = true ; \n } \n break ; \n case DR7_TYPE_IO_RW : \n break ; \n } \n if ( bp_match || wp_match ) { \n dr6 |= 1 << reg ; \n if ( hw_breakpoint_enabled ( env -> dr [ 7 ] , reg ) ) { \n hit_enabled = true ; \n } \n } \n } \n if ( hit_enabled || force_dr6_update ) { \n env -> dr [ 6 ] = dr6 ; \n } \n return hit_enabled ; \n }", "idx": 6053}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "void arm_translate_init ( void ) \n { \n cpu_env = tcg_global_reg_new ( TCG_TYPE_PTR , TCG_AREG0 , \" \" ) ; \n cpu_T [ 0 ] = tcg_global_reg_new ( TCG_TYPE_I32 , TCG_AREG1 , \" \" ) ; \n cpu_T [ 1 ] = tcg_global_reg_new ( TCG_TYPE_I32 , TCG_AREG2 , \" \" ) ; \n }", "idx": 6072}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "void virtio_9p_push_and_notify ( V9fsPDU * pdu ) \n { \n V9fsState * s = pdu -> s ; \n V9fsVirtioState * v = container_of ( s , V9fsVirtioState , state ) ; \n VirtQueueElement * elem = & v -> elems [ pdu -> idx ] ; \n virtqueue_push ( v -> vq , elem , pdu -> size ) ; \n virtio_notify ( VIRTIO_DEVICE ( v ) , v -> vq ) ; \n }", "idx": 6074}
{"project": "qemu", "commit_id": "2b147555f78c3c20080b201fd1506467fa0ddf43", "target": 0, "func": "static int kvm_s390_check_clear_cmma ( KVMState * s ) \n { \n struct kvm_device_attr attr = { \n . group = KVM_S390_VM_MEM_CTRL , \n . attr = KVM_S390_VM_MEM_CLR_CMMA , \n } ; \n return kvm_vm_ioctl ( s , KVM_HAS_DEVICE_ATTR , & attr ) ; \n }", "idx": 6087}
{"project": "qemu", "commit_id": "7e486f7577764a07aa35588e119903c80a5c30a2", "target": 1, "func": "static inline uint32_t vmsvga_fifo_read_raw ( struct vmsvga_state_s * s ) \n { \n uint32_t cmd = s -> fifo [ CMD ( stop ) >> 2 ] ; \n s -> cmd -> stop = cpu_to_le32 ( CMD ( stop ) + 4 ) ; \n if ( CMD ( stop ) >= CMD ( max ) ) { \n s -> cmd -> stop = s -> cmd -> min ; \n } \n return cmd ; \n }", "idx": 6107}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void dead_tmp ( TCGv tmp ) \n { \n tcg_temp_free ( tmp ) ; \n num_temps -- ; \n }", "idx": 6133}
{"project": "qemu", "commit_id": "3ac216270a62418519c08e88c17005a8f1539cf2", "target": 1, "func": "int bdrv_has_zero_init ( BlockDriverState * bs ) \n { \n assert ( bs -> drv ) ; \n if ( bs -> drv -> bdrv_has_zero_init ) { \n return bs -> drv -> bdrv_has_zero_init ( bs ) ; \n } \n return 1 ; \n }", "idx": 6153}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState * qemu_chr_open_mux ( CharDriverState * drv ) \n { \n CharDriverState * chr ; \n MuxDriver * d ; \n chr = qemu_chr_alloc ( ) ; \n d = g_malloc0 ( sizeof ( MuxDriver ) ) ; \n chr -> opaque = d ; \n d -> drv = drv ; \n d -> focus = -1 ; \n chr -> chr_write = mux_chr_write ; \n chr -> chr_update_read_handler = mux_chr_update_read_handler ; \n chr -> chr_accept_input = mux_chr_accept_input ; \n chr -> chr_set_fe_open = NULL ; \n if ( drv -> chr_add_watch ) { \n chr -> chr_add_watch = mux_chr_add_watch ; \n } \n chr -> explicit_be_open = muxes_realized ? 0 : 1 ; \n chr -> is_mux = 1 ; \n return chr ; \n }", "idx": 6155}
{"project": "qemu", "commit_id": "d3b12f5dec4b27ebab58fb5797cb67bacced773b", "target": 0, "func": "static void dummy_event_handler ( void * opaque ) \n { \n }", "idx": 6185}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_watchpoint_remove_by_ref ( CPUState * env , CPUWatchpoint * watchpoint ) \n { \n TAILQ_REMOVE ( & env -> watchpoints , watchpoint , entry ) ; \n tlb_flush_page ( env , watchpoint -> vaddr ) ; \n qemu_free ( watchpoint ) ; \n }", "idx": 6197}
{"project": "qemu", "commit_id": "80ac2390358c906215a849670ca5b7a3d1d112a3", "target": 0, "func": "void armv7m_nvic_set_pending ( void * opaque , int irq , bool secure ) \n { \n NVICState * s = ( NVICState * ) opaque ; \n bool banked = exc_is_banked ( irq ) ; \n VecInfo * vec ; \n assert ( irq > ARMV7M_EXCP_RESET && irq < s -> num_irq ) ; \n assert ( ! secure || banked ) ; \n vec = ( banked && secure ) ? & s -> sec_vectors [ irq ] : & s -> vectors [ irq ] ; \n trace_nvic_set_pending ( irq , secure , vec -> enabled , vec -> prio ) ; \n if ( irq >= ARMV7M_EXCP_HARD && irq < ARMV7M_EXCP_PENDSV ) { \n int running = nvic_exec_prio ( s ) ; \n bool escalate = false ; \n if ( vec -> prio >= running ) { \n trace_nvic_escalate_prio ( irq , vec -> prio , running ) ; \n escalate = true ; \n } else if ( ! vec -> enabled ) { \n trace_nvic_escalate_disabled ( irq ) ; \n escalate = true ; \n } \n if ( escalate ) { \n if ( running < 0 ) { \n cpu_abort ( & s -> cpu -> parent_obj , \n \" \" \n \" \\n \" , irq , running ) ; \n } \n irq = ARMV7M_EXCP_HARD ; \n if ( arm_feature ( & s -> cpu -> env , ARM_FEATURE_M_SECURITY ) && \n ( secure || \n ! ( s -> cpu -> env . v7m . aircr & R_V7M_AIRCR_BFHFNMINS_MASK ) ) ) { \n vec = & s -> sec_vectors [ irq ] ; \n } else { \n vec = & s -> vectors [ irq ] ; \n } \n s -> cpu -> env . v7m . hfsr |= R_V7M_HFSR_FORCED_MASK ; \n } \n } \n if ( ! vec -> pending ) { \n vec -> pending = 1 ; \n nvic_irq_update ( s ) ; \n } \n }", "idx": 6198}
{"project": "qemu", "commit_id": "b40acf99bef69fa8ab0f9092ff162fde945eec12", "target": 0, "func": "void portio_list_init ( PortioList * piolist , \n const MemoryRegionPortio * callbacks , \n void * opaque , const char * name ) \n { \n unsigned n = 0 ; \n while ( callbacks [ n ] . size ) { \n ++ n ; \n } \n piolist -> ports = callbacks ; \n piolist -> nr = 0 ; \n piolist -> regions = g_new0 ( MemoryRegion * , n ) ; \n piolist -> aliases = g_new0 ( MemoryRegion * , n ) ; \n piolist -> address_space = NULL ; \n piolist -> opaque = opaque ; \n piolist -> name = name ; \n }", "idx": 6199}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtsr ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n #else \n TCGv t0 ; \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n return ; \n } \n t0 = tcg_const_tl ( SR ( ctx -> opcode ) ) ; \n gen_helper_store_sr ( cpu_env , t0 , cpu_gpr [ rS ( ctx -> opcode ) ] ) ; \n tcg_temp_free ( t0 ) ; \n #endif \n }", "idx": 6207}
{"project": "qemu", "commit_id": "36cccb8c575b74a691f685911fbb0301af19f924", "target": 1, "func": "static void device_initfn ( Object * obj ) \n { \n DeviceState * dev = DEVICE ( obj ) ; \n ObjectClass * class ; \n Property * prop ; \n if ( qdev_hotplug ) { \n dev -> hotplugged = 1 ; \n qdev_hot_added = true ; \n } \n dev -> instance_id_alias = -1 ; \n dev -> realized = false ; \n object_property_add_bool ( obj , \" \" , \n device_get_realized , device_set_realized , NULL ) ; \n object_property_add_bool ( obj , \" \" , \n device_get_hotpluggable , NULL , NULL ) ; \n object_property_add_bool ( obj , \" \" , \n device_get_hotplugged , device_set_hotplugged , \n & error_abort ) ; \n class = object_get_class ( OBJECT ( dev ) ) ; \n do { \n for ( prop = DEVICE_CLASS ( class ) -> props ; prop && prop -> name ; prop ++ ) { \n qdev_property_add_legacy ( dev , prop , & error_abort ) ; \n qdev_property_add_static ( dev , prop , & error_abort ) ; \n } \n class = object_class_get_parent ( class ) ; \n } while ( class != object_class_by_name ( TYPE_DEVICE ) ) ; \n object_property_add_link ( OBJECT ( dev ) , \" \" , TYPE_BUS , \n ( Object * * ) & dev -> parent_bus , NULL , 0 , \n & error_abort ) ; \n QLIST_INIT ( & dev -> gpios ) ; \n }", "idx": 6275}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "func": "static inline void cris_update_result ( DisasContext * dc , TCGv res ) \n { \n if ( dc -> update_cc ) { \n if ( dc -> cc_size == 4 && \n ( dc -> cc_op == CC_OP_SUB \n || dc -> cc_op == CC_OP_ADD ) ) \n return ; \n tcg_gen_mov_tl ( cc_result , res ) ; \n } \n }", "idx": 6286}
{"project": "qemu", "commit_id": "6d21e4208f382dd8ca1f7995a6dd9ea7ca281163", "target": 0, "func": "static inline TranslationBlock * tb_find_fast ( CPUState * cpu , \n TranslationBlock * last_tb , \n int tb_exit ) \n { \n CPUArchState * env = ( CPUArchState * ) cpu -> env_ptr ; \n TranslationBlock * tb ; \n target_ulong cs_base , pc ; \n uint32_t flags ; \n cpu_get_tb_cpu_state ( env , & pc , & cs_base , & flags ) ; \n tb_lock ( ) ; \n tb = atomic_rcu_read ( & cpu -> tb_jmp_cache [ tb_jmp_cache_hash_func ( pc ) ] ) ; \n if ( unlikely ( ! tb || tb -> pc != pc || tb -> cs_base != cs_base || \n tb -> flags != flags ) ) { \n tb = tb_find_slow ( cpu , pc , cs_base , flags ) ; \n } \n #ifndef CONFIG_USER_ONLY \n if ( tb -> page_addr [ 1 ] != -1 ) { \n last_tb = NULL ; \n } \n #endif \n if ( last_tb && ! qemu_loglevel_mask ( CPU_LOG_TB_NOCHAIN ) ) { \n if ( cpu -> tb_flushed ) { \n cpu -> tb_flushed = false ; \n } else { \n tb_add_jump ( last_tb , tb_exit , tb ) ; \n } \n } \n tb_unlock ( ) ; \n return tb ; \n }", "idx": 6287}
{"project": "qemu", "commit_id": "80cba1b71eb9a75404d1effddec8ffa9f0d6d6fb", "target": 1, "func": "static int proxy_init ( FsContext * ctx ) \n { \n V9fsProxy * proxy = g_malloc ( sizeof ( V9fsProxy ) ) ; \n int sock_id ; \n if ( ctx -> export_flags & V9FS_PROXY_SOCK_NAME ) { \n sock_id = connect_namedsocket ( ctx -> fs_root ) ; \n } else { \n sock_id = atoi ( ctx -> fs_root ) ; \n if ( sock_id < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n } \n g_free ( ctx -> fs_root ) ; \n proxy -> in_iovec . iov_base = g_malloc ( PROXY_MAX_IO_SZ + PROXY_HDR_SZ ) ; \n proxy -> in_iovec . iov_len = PROXY_MAX_IO_SZ + PROXY_HDR_SZ ; \n proxy -> out_iovec . iov_base = g_malloc ( PROXY_MAX_IO_SZ + PROXY_HDR_SZ ) ; \n proxy -> out_iovec . iov_len = PROXY_MAX_IO_SZ + PROXY_HDR_SZ ; \n ctx -> private = proxy ; \n proxy -> sockfd = sock_id ; \n qemu_mutex_init ( & proxy -> mutex ) ; \n ctx -> export_flags |= V9FS_PATHNAME_FSCONTEXT ; \n ctx -> exops . get_st_gen = proxy_ioc_getversion ; \n return 0 ; \n }", "idx": 6308}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "int kvm_arch_init ( MachineState * ms , KVMState * s ) \n { \n MachineClass * mc = MACHINE_GET_CLASS ( ms ) ; \n mc -> default_cpu_type = S390_CPU_TYPE_NAME ( \" \" ) ; \n cap_sync_regs = kvm_check_extension ( s , KVM_CAP_SYNC_REGS ) ; \n cap_async_pf = kvm_check_extension ( s , KVM_CAP_ASYNC_PF ) ; \n cap_mem_op = kvm_check_extension ( s , KVM_CAP_S390_MEM_OP ) ; \n cap_s390_irq = kvm_check_extension ( s , KVM_CAP_S390_INJECT_IRQ ) ; \n if ( ! kvm_check_extension ( s , KVM_CAP_S390_GMAP ) \n || ! kvm_check_extension ( s , KVM_CAP_S390_COW ) ) { \n phys_mem_set_alloc ( legacy_s390_alloc ) ; \n } \n kvm_vm_enable_cap ( s , KVM_CAP_S390_USER_SIGP , 0 ) ; \n kvm_vm_enable_cap ( s , KVM_CAP_S390_VECTOR_REGISTERS , 0 ) ; \n kvm_vm_enable_cap ( s , KVM_CAP_S390_USER_STSI , 0 ) ; \n if ( ri_allowed ( ) ) { \n if ( kvm_vm_enable_cap ( s , KVM_CAP_S390_RI , 0 ) == 0 ) { \n cap_ri = 1 ; \n } \n } \n if ( gs_allowed ( ) ) { \n if ( kvm_vm_enable_cap ( s , KVM_CAP_S390_GS , 0 ) == 0 ) { \n cap_gs = 1 ; \n } \n } \n return 0 ; \n }", "idx": 6314}
{"project": "qemu", "commit_id": "366d4f7e0007a5540897fbac6e377c57d8c79a73", "target": 1, "func": "static void cg3_reg_write ( void * opaque , hwaddr addr , uint64_t val , \n unsigned size ) \n { \n CG3State * s = opaque ; \n uint8_t regval ; \n int i ; \n DPRINTF ( \" \" PRIx64 \" \" HWADDR_PRIx \" \\n \" , \n val , addr , size ) ; \n switch ( addr ) { \n case CG3_REG_BT458_ADDR : \n s -> dac_index = val ; \n s -> dac_state = 0 ; \n break ; \n case CG3_REG_BT458_COLMAP : \n if ( size == 1 ) { \n val <<= 24 ; \n } \n for ( i = 0 ; i < size ; i ++ ) { \n regval = val >> 24 ; \n switch ( s -> dac_state ) { \n case 0 : \n s -> r [ s -> dac_index ] = regval ; \n s -> dac_state ++ ; \n break ; \n case 1 : \n s -> g [ s -> dac_index ] = regval ; \n s -> dac_state ++ ; \n break ; \n case 2 : \n s -> b [ s -> dac_index ] = regval ; \n s -> dac_index = ( s -> dac_index + 1 ) & 0xff ; \n default : \n s -> dac_state = 0 ; \n break ; \n } \n val <<= 8 ; \n } \n s -> full_update = 1 ; \n break ; \n case CG3_REG_FBC_CTRL : \n s -> regs [ 0 ] = val ; \n break ; \n case CG3_REG_FBC_STATUS : \n if ( s -> regs [ 1 ] & CG3_SR_PENDING_INT ) { \n s -> regs [ 1 ] &= ~ CG3_SR_PENDING_INT ; \n qemu_irq_lower ( s -> irq ) ; \n } \n break ; \n case CG3_REG_FBC_CURSTART . . . CG3_REG_SIZE : \n s -> regs [ addr - 0x10 ] = val ; \n break ; \n default : \n qemu_log_mask ( LOG_UNIMP , \n \" \" \n \" \" HWADDR_PRIx \" \" PRIx64 \" \\n \" , \n addr , size , val ) ; \n break ; \n } \n }", "idx": 6339}
{"project": "qemu", "commit_id": "c5825ac6c861bfe1a4adfa27517931b56079e298", "target": 1, "func": "static void qxl_dirty_surfaces ( PCIQXLDevice * qxl ) \n { \n intptr_t vram_start ; \n int i ; \n if ( qxl -> mode != QXL_MODE_NATIVE && qxl -> mode != QXL_MODE_COMPAT ) { \n return ; \n } \n qxl_set_dirty ( & qxl -> vga . vram , qxl -> shadow_rom . draw_area_offset , \n qxl -> shadow_rom . surface0_area_size ) ; \n vram_start = ( intptr_t ) memory_region_get_ram_ptr ( & qxl -> vram_bar ) ; \n for ( i = 0 ; i < qxl -> ssd . num_surfaces ; i ++ ) { \n QXLSurfaceCmd * cmd ; \n intptr_t surface_offset ; \n int surface_size ; \n if ( qxl -> guest_surfaces . cmds [ i ] == 0 ) { \n continue ; \n } \n cmd = qxl_phys2virt ( qxl , qxl -> guest_surfaces . cmds [ i ] , \n MEMSLOT_GROUP_GUEST ) ; \n assert ( cmd ) ; \n assert ( cmd -> type == QXL_SURFACE_CMD_CREATE ) ; \n surface_offset = ( intptr_t ) qxl_phys2virt ( qxl , \n cmd -> u . surface_create . data , \n MEMSLOT_GROUP_GUEST ) ; \n assert ( surface_offset ) ; \n surface_offset -= vram_start ; \n surface_size = cmd -> u . surface_create . height * \n abs ( cmd -> u . surface_create . stride ) ; \n trace_qxl_surfaces_dirty ( qxl -> id , i , ( int ) surface_offset , surface_size ) ; \n qxl_set_dirty ( & qxl -> vram_bar , surface_offset , surface_size ) ; \n } \n }", "idx": 6352}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void a9_scu_write ( void * opaque , target_phys_addr_t offset , \n uint64_t value , unsigned size ) \n { \n a9mp_priv_state * s = ( a9mp_priv_state * ) opaque ; \n uint32_t mask ; \n uint32_t shift ; \n switch ( size ) { \n case 1 : \n mask = 0xff ; \n break ; \n case 2 : \n mask = 0xffff ; \n break ; \n case 4 : \n mask = 0xffffffff ; \n break ; \n default : \n fprintf ( stderr , \" \\n \" , \n size , ( unsigned ) offset ) ; \n return ; \n } \n switch ( offset ) { \n case 0x00 : \n s -> scu_control = value & 1 ; \n break ; \n case 0x4 : \n break ; \n case 0x08 : case 0x09 : case 0x0A : case 0x0B : \n shift = ( offset - 0x8 ) * 8 ; \n s -> scu_status &= ~ ( mask << shift ) ; \n s -> scu_status |= ( ( value & mask ) << shift ) ; \n break ; \n case 0x0c : \n break ; \n case 0x40 : \n case 0x44 : \n break ; \n case 0x50 : \n case 0x54 : \n default : \n break ; \n } \n }", "idx": 6401}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void s390_virtio_net_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n VirtIOS390DeviceClass * k = VIRTIO_S390_DEVICE_CLASS ( klass ) ; \n k -> init = s390_virtio_net_init ; \n dc -> props = s390_virtio_net_properties ; \n dc -> alias = \" \" ; \n }", "idx": 6404}
{"project": "qemu", "commit_id": "24f3902b088cd4f2dbebfd90527b5d81d6a050e9", "target": 1, "func": "static int qemu_savevm_state ( QEMUFile * f , Error * * errp ) \n { \n int ret ; \n MigrationParams params = { \n . blk = 0 , \n . shared = 0 \n } ; \n MigrationState * ms = migrate_init ( & params ) ; \n ms -> to_dst_file = f ; \n if ( qemu_savevm_state_blocked ( errp ) ) { \n return - EINVAL ; \n } \n qemu_mutex_unlock_iothread ( ) ; \n qemu_savevm_state_header ( f ) ; \n qemu_savevm_state_begin ( f , & params ) ; \n qemu_mutex_lock_iothread ( ) ; \n while ( qemu_file_get_error ( f ) == 0 ) { \n if ( qemu_savevm_state_iterate ( f , false ) > 0 ) { \n break ; \n } \n } \n ret = qemu_file_get_error ( f ) ; \n if ( ret == 0 ) { \n qemu_savevm_state_complete_precopy ( f , false ) ; \n ret = qemu_file_get_error ( f ) ; \n } \n qemu_savevm_state_cleanup ( ) ; \n if ( ret != 0 ) { \n error_setg_errno ( errp , - ret , \" \" ) ; \n } \n return ret ; \n }", "idx": 6425}
{"project": "qemu", "commit_id": "44696296d5c2ffccef9d43d37d4f525bba7d9f5c", "target": 1, "func": "static void t_gen_lsl ( TCGv d , TCGv a , TCGv b ) \n { \n TCGv t0 , t_31 ; \n t0 = tcg_temp_new ( TCG_TYPE_TL ) ; \n t_31 = tcg_temp_new ( TCG_TYPE_TL ) ; \n tcg_gen_shl_tl ( d , a , b ) ; \n tcg_gen_movi_tl ( t_31 , 31 ) ; \n tcg_gen_sub_tl ( t0 , t_31 , b ) ; \n tcg_gen_sar_tl ( t0 , t0 , t_31 ) ; \n tcg_gen_and_tl ( t0 , t0 , d ) ; \n tcg_gen_xor_tl ( d , d , t0 ) ; \n tcg_temp_free ( t0 ) ; \n tcg_temp_free ( t_31 ) ; \n }", "idx": 6440}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "bool virtio_scsi_handle_ctrl_vq ( VirtIOSCSI * s , VirtQueue * vq ) \n { \n VirtIOSCSIReq * req ; \n bool progress = false ; \n virtio_scsi_acquire ( s ) ; \n while ( ( req = virtio_scsi_pop_req ( s , vq ) ) ) { \n progress = true ; \n virtio_scsi_handle_ctrl_req ( s , req ) ; \n } \n virtio_scsi_release ( s ) ; \n return progress ; \n }", "idx": 6445}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void gus_realizefn ( DeviceState * dev , Error * * errp ) \n { \n ISADevice * d = ISA_DEVICE ( dev ) ; \n GUSState * s = GUS ( dev ) ; \n IsaDmaClass * k ; \n struct audsettings as ; \n AUD_register_card ( \" \" , & s -> card ) ; \n as . freq = s -> freq ; \n as . nchannels = 2 ; \n as . fmt = AUD_FMT_S16 ; \n as . endianness = GUS_ENDIANNESS ; \n s -> voice = AUD_open_out ( \n & s -> card , \n NULL , \n \" \" , \n s , \n GUS_callback , \n & as \n ) ; \n if ( ! s -> voice ) { \n AUD_remove_card ( & s -> card ) ; \n error_setg ( errp , \" \" ) ; \n return ; \n } \n s -> shift = 2 ; \n s -> samples = AUD_get_buffer_size_out ( s -> voice ) >> s -> shift ; \n s -> mixbuf = g_malloc0 ( s -> samples << s -> shift ) ; \n isa_register_portio_list ( d , s -> port , gus_portio_list1 , s , \" \" ) ; \n isa_register_portio_list ( d , ( s -> port + 0x100 ) & 0xf00 , \n gus_portio_list2 , s , \" \" ) ; \n s -> isa_dma = isa_get_dma ( isa_bus_from_device ( d ) , s -> emu . gusdma ) ; \n k = ISADMA_GET_CLASS ( s -> isa_dma ) ; \n k -> register_channel ( s -> isa_dma , s -> emu . gusdma , GUS_read_DMA , s ) ; \n s -> emu . himemaddr = s -> himem ; \n s -> emu . gusdatapos = s -> emu . himemaddr + 1024 * 1024 + 32 ; \n s -> emu . opaque = s ; \n isa_init_irq ( d , & s -> pic , s -> emu . gusirq ) ; \n AUD_set_active_out ( s -> voice , 1 ) ; \n }", "idx": 6461}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static inline bool migration_bitmap_clear_dirty ( RAMState * rs , ram_addr_t addr ) \n { \n bool ret ; \n int nr = addr >> TARGET_PAGE_BITS ; \n unsigned long * bitmap = atomic_rcu_read ( & rs -> ram_bitmap ) -> bmap ; \n ret = test_and_clear_bit ( nr , bitmap ) ; \n if ( ret ) { \n rs -> migration_dirty_pages -- ; \n } \n return ret ; \n }", "idx": 6467}
{"project": "qemu", "commit_id": "46764fe09ca2e0f15c0981a672c166ed8cf57e72", "target": 1, "func": "static void do_flush_queued_data ( VirtIOSerialPort * port , VirtQueue * vq , \n VirtIODevice * vdev ) \n { \n VirtIOSerialPortClass * vsc ; \n assert ( port ) ; \n assert ( virtio_queue_ready ( vq ) ) ; \n vsc = VIRTIO_SERIAL_PORT_GET_CLASS ( port ) ; \n while ( ! port -> throttled ) { \n unsigned int i ; \n if ( ! port -> elem ) { \n port -> elem = virtqueue_pop ( vq , sizeof ( VirtQueueElement ) ) ; \n if ( ! port -> elem ) { \n break ; \n port -> iov_idx = 0 ; \n port -> iov_offset = 0 ; \n for ( i = port -> iov_idx ; i < port -> elem -> out_num ; i ++ ) { \n size_t buf_size ; \n ssize_t ret ; \n buf_size = port -> elem -> out_sg [ i ] . iov_len - port -> iov_offset ; \n ret = vsc -> have_data ( port , \n port -> elem -> out_sg [ i ] . iov_base \n + port -> iov_offset , \n buf_size ) ; \n if ( port -> throttled ) { \n port -> iov_idx = i ; \n if ( ret > 0 ) { \n port -> iov_offset += ret ; \n break ; \n port -> iov_offset = 0 ; \n if ( port -> throttled ) { \n break ; \n virtqueue_push ( vq , port -> elem , 0 ) ; \n g_free ( port -> elem ) ; \n port -> elem = NULL ; \n virtio_notify ( vdev , vq ) ;", "idx": 6508}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void nvme_clear_ctrl ( NvmeCtrl * n ) \n { \n int i ; \n for ( i = 0 ; i < n -> num_queues ; i ++ ) { \n if ( n -> sq [ i ] != NULL ) { \n nvme_free_sq ( n -> sq [ i ] , n ) ; \n } \n } \n for ( i = 0 ; i < n -> num_queues ; i ++ ) { \n if ( n -> cq [ i ] != NULL ) { \n nvme_free_cq ( n -> cq [ i ] , n ) ; \n } \n } \n bdrv_flush ( n -> conf . bs ) ; \n n -> bar . cc = 0 ; \n }", "idx": 6595}
{"project": "qemu", "commit_id": "eff6ff9431aa9776062a5f4a08d1f6503ca9995a", "target": 0, "func": "void r4k_helper_tlbwi ( CPUMIPSState * env ) \n { \n r4k_tlb_t * tlb ; \n int idx ; \n target_ulong VPN ; \n uint16_t ASID ; \n bool G , V0 , D0 , V1 , D1 ; \n idx = ( env -> CP0_Index & ~ 0x80000000 ) % env -> tlb -> nb_tlb ; \n tlb = & env -> tlb -> mmu . r4k . tlb [ idx ] ; \n VPN = env -> CP0_EntryHi & ( TARGET_PAGE_MASK << 1 ) ; \n #if defined ( TARGET_MIPS64 )  \n  \n  VPN &= env -> SEGMask ; \n #endif \n ASID = env -> CP0_EntryHi & env -> CP0_EntryHi_ASID_mask ; \n G = env -> CP0_EntryLo0 & env -> CP0_EntryLo1 & 1 ; \n V0 = ( env -> CP0_EntryLo0 & 2 ) != 0 ; \n D0 = ( env -> CP0_EntryLo0 & 4 ) != 0 ; \n V1 = ( env -> CP0_EntryLo1 & 2 ) != 0 ; \n D1 = ( env -> CP0_EntryLo1 & 4 ) != 0 ; \n if ( tlb -> VPN != VPN || tlb -> ASID != ASID || tlb -> G != G || \n ( tlb -> V0 && ! V0 ) || ( tlb -> D0 && ! D0 ) || \n ( tlb -> V1 && ! V1 ) || ( tlb -> D1 && ! D1 ) ) { \n r4k_mips_tlb_flush_extra ( env , env -> tlb -> nb_tlb ) ; \n } \n r4k_invalidate_tlb ( env , idx , 0 ) ; \n r4k_fill_tlb ( env , idx ) ; \n }", "idx": 6609}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static uint8_t ide_wait_clear ( uint8_t flag ) \n { \n QPCIDevice * dev ; \n QPCIBar bmdma_bar , ide_bar ; \n uint8_t data ; \n time_t st ; \n dev = get_pci_device ( & bmdma_bar , & ide_bar ) ; \n time ( & st ) ; \n while ( true ) { \n data = qpci_io_readb ( dev , ide_bar , reg_status ) ; \n if ( ! ( data & flag ) ) { \n return data ; \n } \n if ( difftime ( time ( NULL ) , st ) > 5.0 ) { \n break ; \n } \n nsleep ( 400 ) ; \n } \n g_assert_not_reached ( ) ; \n }", "idx": 6627}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_lifecycle ( void ) \n { \n Coroutine * coroutine ; \n unsigned int i , max ; \n double duration ; \n max = 1000000 ; \n g_test_timer_start ( ) ; \n for ( i = 0 ; i < max ; i ++ ) { \n coroutine = qemu_coroutine_create ( empty_coroutine ) ; \n qemu_coroutine_enter ( coroutine , NULL ) ; \n } \n duration = g_test_timer_elapsed ( ) ; \n g_test_message ( \" \\n \" , max , duration ) ; \n }", "idx": 6630}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_4xx_tlbsx_ ( void ) \n { \n int tmp = xer_ov ; \n T0 = ppcemb_tlb_search ( env , T0 , env -> spr [ SPR_40x_PID ] ) ; \n if ( T0 != -1 ) \n tmp |= 0x02 ; \n env -> crf [ 0 ] = tmp ; \n }", "idx": 6644}
{"project": "qemu", "commit_id": "bce6261eb2d879625126485d4ddd28cacb93152e", "target": 1, "func": "static void virtconsole_realize ( DeviceState * dev , Error * * errp ) \n { \n VirtIOSerialPort * port = VIRTIO_SERIAL_PORT ( dev ) ; \n VirtConsole * vcon = VIRTIO_CONSOLE ( dev ) ; \n VirtIOSerialPortClass * k = VIRTIO_SERIAL_PORT_GET_CLASS ( dev ) ; \n if ( port -> id == 0 && ! k -> is_console ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n return ; \n } \n if ( vcon -> chr ) { \n vcon -> chr -> explicit_fe_open = 1 ; \n qemu_chr_add_handlers ( vcon -> chr , chr_can_read , chr_read , chr_event , \n vcon ) ; \n } \n }", "idx": 6661}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_done ( CPUSPARCState * env ) \n { \n trap_state * tsptr = cpu_tsptr ( env ) ; \n env -> pc = tsptr -> tnpc ; \n env -> npc = tsptr -> tnpc + 4 ; \n cpu_put_ccr ( env , tsptr -> tstate >> 32 ) ; \n env -> asi = ( tsptr -> tstate >> 24 ) & 0xff ; \n cpu_change_pstate ( env , ( tsptr -> tstate >> 8 ) & 0xf3f ) ; \n cpu_put_cwp64 ( env , tsptr -> tstate & 0xff ) ; \n if ( cpu_has_hypervisor ( env ) ) { \n uint32_t new_gl = ( tsptr -> tstate >> 40 ) & 7 ; \n env -> hpstate = env -> htstate [ env -> tl ] ; \n cpu_gl_switch_gregs ( env , new_gl ) ; \n env -> gl = new_gl ; \n } \n env -> tl -- ; \n trace_win_helper_done ( env -> tl ) ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  if ( cpu_interrupts_enabled ( env ) ) { \n cpu_check_irqs ( env ) ; \n } \n #endif \n }", "idx": 6682}
{"project": "qemu", "commit_id": "5b498459b441f4639fd4c39c35345637bfc6c16c", "target": 1, "func": "static void tcp_chr_disconnect ( CharDriverState * chr ) \n { \n TCPCharDriver * s = chr -> opaque ; \n if ( ! s -> connected ) { \n return ; \n } \n s -> connected = 0 ; \n if ( s -> listen_ioc ) { \n s -> listen_tag = qio_channel_add_watch ( \n QIO_CHANNEL ( s -> listen_ioc ) , G_IO_IN , tcp_chr_accept , chr , NULL ) ; \n } \n tcp_set_msgfds ( chr , NULL , 0 ) ; \n remove_fd_in_watch ( chr ) ; \n object_unref ( OBJECT ( s -> sioc ) ) ; \n s -> sioc = NULL ; \n object_unref ( OBJECT ( s -> ioc ) ) ; \n s -> ioc = NULL ; \n g_free ( chr -> filename ) ; \n chr -> filename = SocketAddress_to_str ( \" \" , s -> addr , \n s -> is_listen , s -> is_telnet ) ; \n qemu_chr_be_event ( chr , CHR_EVENT_CLOSED ) ; \n if ( s -> reconnect_time ) { \n qemu_chr_socket_restart_timer ( chr ) ; \n } \n }", "idx": 6710}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static inline void menelaus_rtc_stop ( MenelausState * s ) \n { \n qemu_del_timer ( s -> rtc . hz_tm ) ; \n s -> rtc . next -= qemu_get_clock ( rt_clock ) ; \n if ( s -> rtc . next < 1 ) \n s -> rtc . next = 1 ; \n }", "idx": 6740}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "int ide_get_geometry ( BusState * bus , int unit , \n int16_t * cyls , int8_t * heads , int8_t * secs ) \n { \n IDEState * s = & DO_UPCAST ( IDEBus , qbus , bus ) -> ifs [ unit ] ; \n if ( s -> drive_kind != IDE_HD || ! s -> bs ) { \n return -1 ; \n } \n * cyls = s -> cylinders ; \n * heads = s -> heads ; \n * secs = s -> sectors ; \n return 0 ; \n }", "idx": 6748}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_dcread ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n TCGv EA , val ; \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n gen_set_access_type ( ctx , ACCESS_CACHE ) ; \n EA = tcg_temp_new ( ) ; \n gen_addr_reg_index ( ctx , EA ) ; \n val = tcg_temp_new ( ) ; \n gen_qemu_ld32u ( ctx , val , EA ) ; \n tcg_temp_free ( val ) ; \n tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , EA ) ; \n tcg_temp_free ( EA ) ; \n #endif \n }", "idx": 6809}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_i64 ( FWCfgState * s , uint16_t key , uint64_t value ) \n { \n uint64_t * copy ; \n copy = g_malloc ( sizeof ( value ) ) ; \n * copy = cpu_to_le64 ( value ) ; \n return fw_cfg_add_bytes ( s , key , ( uint8_t * ) copy , sizeof ( value ) ) ; \n }", "idx": 6815}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static uint16_t nvme_del_sq ( NvmeCtrl * n , NvmeCmd * cmd ) \n { \n NvmeDeleteQ * c = ( NvmeDeleteQ * ) cmd ; \n NvmeRequest * req , * next ; \n NvmeSQueue * sq ; \n NvmeCQueue * cq ; \n uint16_t qid = le16_to_cpu ( c -> qid ) ; \n if ( ! qid || nvme_check_sqid ( n , qid ) ) { \n return NVME_INVALID_QID | NVME_DNR ; \n } \n sq = n -> sq [ qid ] ; \n while ( ! QTAILQ_EMPTY ( & sq -> out_req_list ) ) { \n req = QTAILQ_FIRST ( & sq -> out_req_list ) ; \n assert ( req -> aiocb ) ; \n bdrv_aio_cancel ( req -> aiocb ) ; \n } \n if ( ! nvme_check_cqid ( n , sq -> cqid ) ) { \n cq = n -> cq [ sq -> cqid ] ; \n QTAILQ_REMOVE ( & cq -> sq_list , sq , entry ) ; \n nvme_post_cqes ( cq ) ; \n QTAILQ_FOREACH_SAFE ( req , & cq -> req_list , entry , next )  { \n if ( req -> sq == sq ) { \n QTAILQ_REMOVE ( & cq -> req_list , req , entry ) ; \n QTAILQ_INSERT_TAIL ( & sq -> req_list , req , entry ) ; \n } \n } \n } \n nvme_free_sq ( sq , n ) ; \n return NVME_SUCCESS ; \n }", "idx": 6826}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_multiply ( TCGv dst , TCGv src1 , TCGv src2 , int sign_ext ) \n { \n TCGv_i32 r_src1 , r_src2 ; \n TCGv_i64 r_temp , r_temp2 ; \n r_src1 = tcg_temp_new_i32 ( ) ; \n r_src2 = tcg_temp_new_i32 ( ) ; \n tcg_gen_trunc_tl_i32 ( r_src1 , src1 ) ; \n tcg_gen_trunc_tl_i32 ( r_src2 , src2 ) ; \n r_temp = tcg_temp_new_i64 ( ) ; \n r_temp2 = tcg_temp_new_i64 ( ) ; \n if ( sign_ext ) { \n tcg_gen_ext_i32_i64 ( r_temp , r_src2 ) ; \n tcg_gen_ext_i32_i64 ( r_temp2 , r_src1 ) ; \n } else { \n tcg_gen_extu_i32_i64 ( r_temp , r_src2 ) ; \n tcg_gen_extu_i32_i64 ( r_temp2 , r_src1 ) ; \n } \n tcg_gen_mul_i64 ( r_temp2 , r_temp , r_temp2 ) ; \n tcg_gen_shri_i64 ( r_temp , r_temp2 , 32 ) ; \n tcg_gen_trunc_i64_tl ( cpu_tmp0 , r_temp ) ; \n tcg_temp_free_i64 ( r_temp ) ; \n tcg_gen_andi_tl ( cpu_y , cpu_tmp0 , 0xffffffff ) ; \n tcg_gen_trunc_i64_tl ( dst , r_temp2 ) ; \n tcg_temp_free_i64 ( r_temp2 ) ; \n tcg_temp_free_i32 ( r_src1 ) ; \n tcg_temp_free_i32 ( r_src2 ) ; \n }", "idx": 6835}
{"project": "qemu", "commit_id": "2f4dc3c1b2a453a8255d9b97c7cb87860123e495", "target": 0, "func": "AioContext * aio_context_new ( void ) \n { \n return ( AioContext * ) g_source_new ( & aio_source_funcs , sizeof ( AioContext ) ) ; \n }", "idx": 6839}
{"project": "qemu", "commit_id": "032a7c4e425f1f0b71942768696f53f93947f8fa", "target": 1, "func": "static int lance_init ( SysBusDevice * dev ) \n { \n SysBusPCNetState * d = FROM_SYSBUS ( SysBusPCNetState , dev ) ; \n PCNetState * s = & d -> state ; \n memory_region_init_io ( & s -> mmio , & lance_mem_ops , s , \" \" , 4 ) ; \n qdev_init_gpio_in ( & dev -> qdev , parent_lance_reset , 1 ) ; \n sysbus_init_mmio_region ( dev , & s -> mmio ) ; \n sysbus_init_irq ( dev , & s -> irq ) ; \n s -> phys_mem_read = ledma_memory_read ; \n s -> phys_mem_write = ledma_memory_write ; \n return pcnet_common_init ( & dev -> qdev , s , & net_lance_info ) ; \n }", "idx": 6886}
{"project": "qemu", "commit_id": "d42cf28837801cd1f835089fe9db2a42a1af55cd", "target": 0, "func": "void bdrv_drained_begin ( BlockDriverState * bs ) \n { \n if ( ! bs -> quiesce_counter ++ ) { \n aio_disable_external ( bdrv_get_aio_context ( bs ) ) ; \n bdrv_parent_drained_begin ( bs ) ; \n } \n bdrv_io_unplugged_begin ( bs ) ; \n bdrv_drain_recurse ( bs ) ; \n if ( qemu_in_coroutine ( ) ) { \n bdrv_co_yield_to_drain ( bs ) ; \n } else { \n bdrv_drain_poll ( bs ) ; \n } \n bdrv_io_unplugged_end ( bs ) ; \n }", "idx": 6921}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t block_crypto_init_func ( QCryptoBlock * block , \n void * opaque , \n size_t headerlen , \n Error * * errp ) \n { \n struct BlockCryptoCreateData * data = opaque ; \n int ret ; \n data -> size += headerlen ; \n qemu_opt_set_number ( data -> opts , BLOCK_OPT_SIZE , data -> size , & error_abort ) ; \n ret = bdrv_create_file ( data -> filename , data -> opts , errp ) ; \n if ( ret < 0 ) { \n return -1 ; \n } \n data -> blk = blk_new_open ( data -> filename , NULL , NULL , \n BDRV_O_RDWR | BDRV_O_PROTOCOL , errp ) ; \n if ( ! data -> blk ) { \n return -1 ; \n } \n return 0 ; \n }", "idx": 6931}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "void HELPER ( ucf64_set_fpscr ) ( CPUUniCore32State * env , uint32_t val ) \n { \n int i ; \n uint32_t changed ; \n changed = env -> ucf64 . xregs [ UC32_UCF64_FPSCR ] ; \n env -> ucf64 . xregs [ UC32_UCF64_FPSCR ] = ( val & UCF64_FPSCR_MASK ) ; \n changed ^= val ; \n if ( changed & ( UCF64_FPSCR_RND_MASK ) ) { \n i = UCF64_FPSCR_RND ( val ) ; \n switch ( i ) { \n case 0 : \n i = float_round_nearest_even ; \n break ; \n case 1 : \n i = float_round_to_zero ; \n break ; \n case 2 : \n i = float_round_up ; \n break ; \n case 3 : \n i = float_round_down ; \n break ; \n default : \n cpu_abort ( env , \" \" ) ; \n } \n set_float_rounding_mode ( i , & env -> ucf64 . fp_status ) ; \n } \n i = ucf64_exceptbits_to_host ( UCF64_FPSCR_TRAPEN ( val ) ) ; \n set_float_exception_flags ( i , & env -> ucf64 . fp_status ) ; \n }", "idx": 6941}
{"project": "qemu", "commit_id": "e04fb07fd1676e9facd7f3f878c1bbe03bccd26b", "target": 1, "func": "static void qemu_rbd_close ( BlockDriverState * bs ) \n { \n BDRVRBDState * s = bs -> opaque ; \n close ( s -> fds [ 0 ] ) ; \n close ( s -> fds [ 1 ] ) ; \n qemu_aio_set_fd_handler ( s -> fds [ RBD_FD_READ ] , NULL , NULL , NULL ) ; \n rbd_close ( s -> image ) ; \n rados_ioctx_destroy ( s -> io_ctx ) ; \n g_free ( s -> snap ) ; \n rados_shutdown ( s -> cluster ) ; \n }", "idx": 6960}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "void slirp_output ( const uint8_t * pkt , int pkt_len ) \n { \n #ifdef DEBUG_SLIRP \n printf ( \" \\n \" ) ; \n hex_dump ( stdout , pkt , pkt_len ) ; \n #endif \n if ( ! slirp_vc ) \n return ; \n qemu_send_packet ( slirp_vc , pkt , pkt_len ) ; \n }", "idx": 7021}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_connect ( VncDisplay * vd , int csock , int skipauth , bool websocket ) \n { \n VncState * vs = g_malloc0 ( sizeof ( VncState ) ) ; \n int i ; \n vs -> csock = csock ; \n if ( skipauth ) { \n vs -> auth = VNC_AUTH_NONE ; \n #ifdef CONFIG_VNC_TLS \n vs -> subauth = VNC_AUTH_INVALID ; \n #endif \n } else { \n vs -> auth = vd -> auth ; \n #ifdef CONFIG_VNC_TLS \n vs -> subauth = vd -> subauth ; \n #endif \n } \n vs -> lossy_rect = g_malloc0 ( VNC_STAT_ROWS * sizeof ( * vs -> lossy_rect ) ) ; \n for ( i = 0 ; i < VNC_STAT_ROWS ; ++ i ) { \n vs -> lossy_rect [ i ] = g_malloc0 ( VNC_STAT_COLS * sizeof ( uint8_t ) ) ; \n } \n VNC_DEBUG ( \" \\n \" , csock ) ; \n dcl -> idle = 0 ; \n socket_set_nonblock ( vs -> csock ) ; \n #ifdef CONFIG_VNC_WS \n if ( websocket ) { \n vs -> websocket = 1 ; \n qemu_set_fd_handler2 ( vs -> csock , NULL , vncws_handshake_read , NULL , vs ) ; \n } else \n #endif \n { \n qemu_set_fd_handler2 ( vs -> csock , NULL , vnc_client_read , NULL , vs ) ; \n } \n vnc_client_cache_addr ( vs ) ; \n vnc_qmp_event ( vs , QEVENT_VNC_CONNECTED ) ; \n vnc_set_share_mode ( vs , VNC_SHARE_MODE_CONNECTING ) ; \n vs -> vd = vd ; \n #ifdef CONFIG_VNC_WS \n if ( ! vs -> websocket )  \n #endif \n { \n vnc_init_state ( vs ) ; \n } \n }", "idx": 7056}
{"project": "qemu", "commit_id": "0ff0fad23d3693ecf7a0c462cdb48f0e60f93808", "target": 0, "func": "static void tcp_chr_disconnect ( CharDriverState * chr ) \n { \n TCPCharDriver * s = chr -> opaque ; \n s -> connected = 0 ; \n if ( s -> listen_chan ) { \n s -> listen_tag = g_io_add_watch ( s -> listen_chan , G_IO_IN , \n tcp_chr_accept , chr ) ; \n } \n remove_fd_in_watch ( chr ) ; \n g_io_channel_unref ( s -> chan ) ; \n s -> chan = NULL ; \n closesocket ( s -> fd ) ; \n s -> fd = -1 ; \n SocketAddress_to_str ( chr -> filename , CHR_MAX_FILENAME_SIZE , \n \" \" , s -> addr , s -> is_listen , s -> is_telnet ) ; \n qemu_chr_be_event ( chr , CHR_EVENT_CLOSED ) ; \n if ( s -> reconnect_time ) { \n qemu_chr_socket_restart_timer ( chr ) ; \n } \n }", "idx": 7070}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER ( ucf64_si2df ) ( float32 x , CPUUniCore32State * env ) \n { \n return int32_to_float64 ( ucf64_stoi ( x ) , & env -> ucf64 . fp_status ) ; \n }", "idx": 7073}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject * parse_literal ( JSONParserContext * ctxt ) \n { \n QObject * token ; \n token = parser_context_pop_token ( ctxt ) ; \n assert ( token ) ; \n switch ( token_get_type ( token ) ) { \n case JSON_STRING : \n return QOBJECT ( qstring_from_escaped_str ( ctxt , token ) ) ; \n case JSON_INTEGER : { \n int64_t value ; \n errno = 0 ; \n value = strtoll ( token_get_value ( token ) , NULL , 10 ) ; \n if ( errno != ERANGE ) { \n return QOBJECT ( qint_from_int ( value ) ) ; \n } \n } \n case JSON_FLOAT : \n return QOBJECT ( qfloat_from_double ( strtod ( token_get_value ( token ) , \n NULL ) ) ) ; \n default : \n abort ( ) ; \n } \n }", "idx": 7076}
{"project": "qemu", "commit_id": "ff589551c8e8e9e95e211b9d8daafb4ed39f1aec", "target": 0, "func": "uint64_t esp_reg_read ( ESPState * s , uint32_t saddr ) \n { \n uint32_t old_val ; \n trace_esp_mem_readb ( saddr , s -> rregs [ saddr ] ) ; \n switch ( saddr ) { \n case ESP_FIFO : \n if ( s -> ti_size > 0 ) { \n s -> ti_size -- ; \n if ( ( s -> rregs [ ESP_RSTAT ] & STAT_PIO_MASK ) == 0 ) { \n qemu_log_mask ( LOG_UNIMP , \n \" \\n \" ) ; \n s -> rregs [ ESP_FIFO ] = 0 ; \n } else { \n s -> rregs [ ESP_FIFO ] = s -> ti_buf [ s -> ti_rptr ++ ] ; \n } \n esp_raise_irq ( s ) ; \n } \n if ( s -> ti_size == 0 ) { \n s -> ti_rptr = 0 ; \n s -> ti_wptr = 0 ; \n } \n break ; \n case ESP_RINTR : \n old_val = s -> rregs [ ESP_RINTR ] ; \n s -> rregs [ ESP_RINTR ] = 0 ; \n s -> rregs [ ESP_RSTAT ] &= ~ STAT_TC ; \n s -> rregs [ ESP_RSEQ ] = SEQ_CD ; \n esp_lower_irq ( s ) ; \n return old_val ; \n case ESP_TCHI : \n if ( ! s -> tchi_written ) { \n return s -> chip_id ; \n } \n default : \n break ; \n } \n return s -> rregs [ saddr ] ; \n }", "idx": 7078}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "static void co_test_cb ( void * opaque ) \n { \n WorkerTestData * data = opaque ; \n active = 1 ; \n data -> n = 0 ; \n data -> ret = - EINPROGRESS ; \n thread_pool_submit_co ( worker_cb , data ) ; \n g_assert_cmpint ( data -> n , == , 1 ) ; \n data -> ret = 0 ; \n active -- ; \n }", "idx": 7083}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "int nbd_client_session_co_flush ( NbdClientSession * client ) \n { \n struct nbd_request request = { . type = NBD_CMD_FLUSH } ; \n struct nbd_reply reply ; \n ssize_t ret ; \n if ( ! ( client -> nbdflags & NBD_FLAG_SEND_FLUSH ) ) { \n return 0 ; \n } \n if ( client -> nbdflags & NBD_FLAG_SEND_FUA ) { \n request . type |= NBD_CMD_FLAG_FUA ; \n } \n request . from = 0 ; \n request . len = 0 ; \n nbd_coroutine_start ( client , & request ) ; \n ret = nbd_co_send_request ( client , & request , NULL , 0 ) ; \n if ( ret < 0 ) { \n reply . error = - ret ; \n } else { \n nbd_co_receive_reply ( client , & request , & reply , NULL , 0 ) ; \n } \n nbd_coroutine_end ( client , & request ) ; \n return - reply . error ; \n }", "idx": 7090}
{"project": "qemu", "commit_id": "97a83ec3a9d83f2e86b8b93178d8e8b64ccc7486", "target": 0, "func": "static void i440fx_pcihost_initfn ( Object * obj ) \n { \n PCIHostState * s = PCI_HOST_BRIDGE ( obj ) ; \n I440FXState * d = I440FX_PCI_HOST_BRIDGE ( obj ) ; \n memory_region_init_io ( & s -> conf_mem , obj , & pci_host_conf_le_ops , s , \n \" \" , 4 ) ; \n memory_region_init_io ( & s -> data_mem , obj , & pci_host_data_le_ops , s , \n \" \" , 4 ) ; \n object_property_add ( obj , PCI_HOST_PROP_PCI_HOLE_START , \" \" , \n i440fx_pcihost_get_pci_hole_start , \n NULL , NULL , NULL , NULL ) ; \n object_property_add ( obj , PCI_HOST_PROP_PCI_HOLE_END , \" \" , \n i440fx_pcihost_get_pci_hole_end , \n NULL , NULL , NULL , NULL ) ; \n object_property_add ( obj , PCI_HOST_PROP_PCI_HOLE64_START , \" \" , \n i440fx_pcihost_get_pci_hole64_start , \n NULL , NULL , NULL , NULL ) ; \n object_property_add ( obj , PCI_HOST_PROP_PCI_HOLE64_END , \" \" , \n i440fx_pcihost_get_pci_hole64_end , \n NULL , NULL , NULL , NULL ) ; \n d -> pci_info . w32 . end = IO_APIC_DEFAULT_ADDRESS ; \n }", "idx": 7115}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_mutex_unlock_iothread ( void ) { }", "idx": 7152}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void parallel_isa_realizefn ( DeviceState * dev , Error * * errp ) \n { \n static int index ; \n ISADevice * isadev = ISA_DEVICE ( dev ) ; \n ISAParallelState * isa = ISA_PARALLEL ( dev ) ; \n ParallelState * s = & isa -> state ; \n int base ; \n uint8_t dummy ; \n if ( ! s -> chr ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n if ( isa -> index == -1 ) { \n isa -> index = index ; \n } \n if ( isa -> index >= MAX_PARALLEL_PORTS ) { \n error_setg ( errp , \" \" , \n MAX_PARALLEL_PORTS ) ; \n return ; \n } \n if ( isa -> iobase == -1 ) { \n isa -> iobase = isa_parallel_io [ isa -> index ] ; \n } \n index ++ ; \n base = isa -> iobase ; \n isa_init_irq ( isadev , & s -> irq , isa -> isairq ) ; \n qemu_register_reset ( parallel_reset , s ) ; \n if ( qemu_chr_fe_ioctl ( s -> chr , CHR_IOCTL_PP_READ_STATUS , & dummy ) == 0 ) { \n s -> hw_driver = 1 ; \n s -> status = dummy ; \n } \n isa_register_portio_list ( isadev , base , \n ( s -> hw_driver \n ? & isa_parallel_portio_hw_list [ 0 ] \n : & isa_parallel_portio_sw_list [ 0 ] ) , \n s , \" \" ) ; \n }", "idx": 7157}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_bmdma_long_prdt ( void ) \n { \n QPCIDevice * dev ; \n QPCIBar bmdma_bar , ide_bar ; \n uint8_t status ; \n PrdtEntry prdt [ ] = { \n { \n . addr = 0 , \n . size = cpu_to_le32 ( 0x1000 | PRDT_EOT ) , \n } , \n } ; \n dev = get_pci_device ( & bmdma_bar , & ide_bar ) ; \n status = send_dma_request ( CMD_READ_DMA , 0 , 1 , \n prdt , ARRAY_SIZE ( prdt ) , NULL ) ; \n g_assert_cmphex ( status , == , BM_STS_ACTIVE | BM_STS_INTR ) ; \n assert_bit_clear ( qpci_io_readb ( dev , ide_bar , reg_status ) , DF | ERR ) ; \n status = send_dma_request ( CMD_READ_DMA | CMDF_ABORT , 0 , 1 , \n prdt , ARRAY_SIZE ( prdt ) , NULL ) ; \n g_assert_cmphex ( status , == , BM_STS_INTR ) ; \n assert_bit_clear ( qpci_io_readb ( dev , ide_bar , reg_status ) , DF | ERR ) ; \n }", "idx": 7164}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "static void memory_region_update_coalesced_range ( MemoryRegion * mr ) \n { \n FlatRange * fr ; \n CoalescedMemoryRange * cmr ; \n AddrRange tmp ; \n FOR_EACH_FLAT_RANGE ( fr , & address_space_memory . current_map )  { \n if ( fr -> mr == mr ) { \n qemu_unregister_coalesced_mmio ( int128_get64 ( fr -> addr . start ) , \n int128_get64 ( fr -> addr . size ) ) ; \n QTAILQ_FOREACH ( cmr , & mr -> coalesced , link )  { \n tmp = addrrange_shift ( cmr -> addr , \n int128_sub ( fr -> addr . start , \n int128_make64 ( fr -> offset_in_region ) ) ) ; \n if ( ! addrrange_intersects ( tmp , fr -> addr ) ) { \n continue ; \n } \n tmp = addrrange_intersection ( tmp , fr -> addr ) ; \n qemu_register_coalesced_mmio ( int128_get64 ( tmp . start ) , \n int128_get64 ( tmp . size ) ) ; \n } \n } \n } \n }", "idx": 7169}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static int qxl_init_secondary ( PCIDevice * dev ) \n { \n static int device_id = 1 ; \n PCIQXLDevice * qxl = DO_UPCAST ( PCIQXLDevice , pci , dev ) ; \n qxl -> id = device_id ++ ; \n qxl_init_ramsize ( qxl , 16 ) ; \n memory_region_init_ram ( & qxl -> vga . vram , \" \" , qxl -> vga . vram_size ) ; \n vmstate_register_ram ( & qxl -> vga . vram , & qxl -> pci . qdev ) ; \n qxl -> vga . vram_ptr = memory_region_get_ram_ptr ( & qxl -> vga . vram ) ; \n return qxl_init_common ( qxl ) ; \n }", "idx": 7171}
{"project": "qemu", "commit_id": "84961407a50bb02d34ab9cca7a21cdb4ff7c25fe", "target": 1, "func": "static void gd_set_keycode_type ( GtkDisplayState * s ) \n { \n #ifdef GDK_WINDOWING_X11 \n GdkDisplay * display = gtk_widget_get_display ( s -> window ) ; \n if ( GDK_IS_X11_DISPLAY ( display ) ) { \n Display * x11_display = gdk_x11_display_get_xdisplay ( display ) ; \n XkbDescPtr desc = XkbGetKeyboard ( x11_display , XkbGBN_AllComponentsMask , \n XkbUseCoreKbd ) ; \n char * keycodes = NULL ; \n if ( desc && desc -> names ) { \n keycodes = XGetAtomName ( x11_display , desc -> names -> keycodes ) ; \n if ( keycodes == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n } else if ( strstart ( keycodes , \" \" , NULL ) ) { \n s -> has_evdev = true ; \n } else if ( ! strstart ( keycodes , \" \" , NULL ) ) { \n fprintf ( stderr , \" \" \n \" \\n \" , keycodes ) ; \n #endif", "idx": 7206}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_client_set_memory ( struct CPUPhysMemoryClient * client , \n target_phys_addr_t start_addr , \n ram_addr_t size , \n ram_addr_t phys_offset ) \n { \n kvm_set_phys_mem ( start_addr , size , phys_offset ) ; \n }", "idx": 7211}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_offset ( int regno , TCGMemOp size ) \n { \n int offs = offsetof ( CPUARMState , vfp . regs [ regno * 2 ] ) ; \n #ifdef HOST_WORDS_BIGENDIAN \n offs += ( 8 - ( 1 << size ) ) ; \n #endif \n return offs ; \n }", "idx": 7231}
{"project": "qemu", "commit_id": "6e13610aa454beba52944e8df6d93158d68ab911", "target": 1, "func": "static int qcow2_save_vmstate ( BlockDriverState * bs , QEMUIOVector * qiov , \n int64_t pos ) \n { \n BDRVQcowState * s = bs -> opaque ; \n int64_t total_sectors = bs -> total_sectors ; \n int growable = bs -> growable ; \n int ret ; \n BLKDBG_EVENT ( bs -> file , BLKDBG_VMSTATE_SAVE ) ; \n bs -> growable = 1 ; \n ret = bdrv_pwritev ( bs , qcow2_vm_state_offset ( s ) + pos , qiov ) ; \n bs -> growable = growable ; \n bs -> total_sectors = total_sectors ; \n return ret ; \n }", "idx": 7263}
{"project": "qemu", "commit_id": "99f2cf4b2dad7b37c69759deb0d0b19d3ec1a24a", "target": 1, "func": "static void local_mapped_file_attr ( int dirfd , const char * name , \n struct stat * stbuf ) \n { \n FILE * fp ; \n char buf [ ATTR_MAX ] ; \n int map_dirfd ; \n map_dirfd = openat ( dirfd , VIRTFS_META_DIR , \n O_RDONLY | O_DIRECTORY | O_NOFOLLOW ) ; \n if ( map_dirfd == -1 ) { \n return ; \n } \n fp = local_fopenat ( map_dirfd , name , \" \" ) ; \n close_preserve_errno ( map_dirfd ) ; \n if ( ! fp ) { \n return ; \n } \n memset ( buf , 0 , ATTR_MAX ) ; \n while ( fgets ( buf , ATTR_MAX , fp ) ) { \n if ( ! strncmp ( buf , \" \" , 10 ) ) { \n stbuf -> st_uid = atoi ( buf + 11 ) ; \n } else if ( ! strncmp ( buf , \" \" , 10 ) ) { \n stbuf -> st_gid = atoi ( buf + 11 ) ; \n } else if ( ! strncmp ( buf , \" \" , 11 ) ) { \n stbuf -> st_mode = atoi ( buf + 12 ) ; \n } else if ( ! strncmp ( buf , \" \" , 11 ) ) { \n stbuf -> st_rdev = atoi ( buf + 12 ) ; \n } \n memset ( buf , 0 , ATTR_MAX ) ; \n } \n fclose ( fp ) ; \n }", "idx": 7308}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void legacy_kbd_event ( DeviceState * dev , QemuConsole * src , \n InputEvent * evt ) \n { \n QEMUPutKbdEntry * entry = ( QEMUPutKbdEntry * ) dev ; \n int scancodes [ 3 ] , i , count ; \n if ( ! entry || ! entry -> put_kbd ) { \n return ; \n } \n count = qemu_input_key_value_to_scancode ( evt -> key -> key , \n evt -> key -> down , \n scancodes ) ; \n for ( i = 0 ; i < count ; i ++ ) { \n entry -> put_kbd ( entry -> opaque , scancodes [ i ] ) ; \n } \n }", "idx": 7316}
{"project": "qemu", "commit_id": "c169998802505c244b8bcad562633f29de7d74a4", "target": 0, "func": "PITState * pit_init ( int base , qemu_irq irq ) \n { \n PITState * pit = & pit_state ; \n PITChannelState * s ; \n s = & pit -> channels [ 0 ] ; \n s -> irq_timer = qemu_new_timer ( vm_clock , pit_irq_timer , s ) ; \n s -> irq = irq ; \n vmstate_register ( base , & vmstate_pit , pit ) ; \n qemu_register_reset ( pit_reset , pit ) ; \n register_ioport_write ( base , 4 , 1 , pit_ioport_write , pit ) ; \n register_ioport_read ( base , 3 , 1 , pit_ioport_read , pit ) ; \n pit_reset ( pit ) ; \n return pit ; \n }", "idx": 7322}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_literal ( void ) \n { \n QObject * obj = qobject_from_json ( \" \" , NULL ) ; \n g_assert ( obj == NULL ) ; \n }", "idx": 7349}
{"project": "qemu", "commit_id": "441692ddd8321d5e0f09b163e86410e578d87236", "target": 1, "func": "static inline int onenand_load_main ( OneNANDState * s , int sec , int secn , \n void * dest ) \n { \n if ( s -> blk_cur ) { \n return blk_read ( s -> blk_cur , sec , dest , secn ) < 0 ; \n } else if ( sec + secn > s -> secs_cur ) { \n return 1 ; \n } \n memcpy ( dest , s -> current + ( sec << 9 ) , secn << 9 ) ; \n return 0 ; \n }", "idx": 7353}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "static void flush_trace_file ( void ) \n { \n if ( ! trace_fp ) { \n trace_fp = fopen ( trace_file_name , \" \" ) ; \n if ( ! trace_fp ) { \n trace_file_enabled = false ; \n return ; \n } \n write_header ( trace_fp ) ; \n } \n if ( trace_fp ) { \n size_t unused ; \n unused = fwrite ( trace_buf , trace_idx * sizeof ( trace_buf [ 0 ] ) , 1 , trace_fp ) ; \n } \n }", "idx": 7355}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fxtoq ( CPUSPARCState * env , int64_t src ) \n { \n QT0 = int64_to_float128 ( src , & env -> fp_status ) ; \n }", "idx": 7359}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix3_ide_initfn ( PCIDevice * dev ) \n { \n PCIIDEState * d = DO_UPCAST ( PCIIDEState , dev , dev ) ; \n pci_config_set_vendor_id ( d -> dev . config , PCI_VENDOR_ID_INTEL ) ; \n pci_config_set_device_id ( d -> dev . config , PCI_DEVICE_ID_INTEL_82371SB_1 ) ; \n return pci_piix_ide_initfn ( d ) ; \n }", "idx": 7377}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_getpeername ( int fd , abi_ulong target_addr , \n abi_ulong target_addrlen_addr ) \n { \n socklen_t addrlen ; \n void * addr ; \n abi_long ret ; \n if ( get_user_u32 ( addrlen , target_addrlen_addr ) ) \n return - TARGET_EFAULT ; \n if ( addrlen < 0 || addrlen > MAX_SOCK_ADDR ) \n return - TARGET_EINVAL ; \n addr = alloca ( addrlen ) ; \n ret = get_errno ( getpeername ( fd , addr , & addrlen ) ) ; \n if ( ! is_error ( ret ) ) { \n host_to_target_sockaddr ( target_addr , addr , addrlen ) ; \n if ( put_user_u32 ( addrlen , target_addrlen_addr ) ) \n ret = - TARGET_EFAULT ; \n } \n return ret ; \n }", "idx": 7378}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "void ppc_hash64_set_external_hpt ( PowerPCCPU * cpu , void * hpt , int shift , \n Error * * errp ) \n { \n CPUPPCState * env = & cpu -> env ; \n Error * local_err = NULL ; \n cpu_synchronize_state ( CPU ( cpu ) ) ; \n env -> external_htab = hpt ; \n ppc_hash64_set_sdr1 ( cpu , ( target_ulong ) ( uintptr_t ) hpt | ( shift - 18 ) , \n & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n env -> htab_base = -1 ; \n if ( kvm_enabled ( ) ) { \n if ( kvmppc_put_books_sregs ( cpu ) < 0 ) { \n error_setg ( errp , \" \" ) ; \n } \n } \n }", "idx": 7383}
{"project": "qemu", "commit_id": "672558d2ea8dd782d1d2adc6e16af3bc34029a36", "target": 1, "func": "void numa_set_mem_node_id ( ram_addr_t addr , uint64_t size , uint32_t node ) \n { \n struct numa_addr_range * range = g_malloc0 ( sizeof ( * range ) ) ; \n if ( ! size ) { \n return ; \n } \n range -> mem_start = addr ; \n range -> mem_end = addr + size - 1 ; \n QLIST_INSERT_HEAD ( & numa_info [ node ] . addr , range , entry ) ; \n }", "idx": 7394}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_bound_d ( int v , int b ) \n { \n int r = v ; \n asm ( \" \\t \\n \" : \" \" ( r ) : \" \" ( b ) ) ; \n return r ; \n }", "idx": 7400}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static const char * pxb_host_root_bus_path ( PCIHostState * host_bridge , \n PCIBus * rootbus ) \n { \n PXBBus * bus = PXB_BUS ( rootbus ) ; \n snprintf ( bus -> bus_path , 8 , \" \" , pxb_bus_num ( rootbus ) ) ; \n return bus -> bus_path ; \n }", "idx": 7446}
{"project": "qemu", "commit_id": "717adf960933da0650d995f050d457063d591914", "target": 0, "func": "int qemu_strtou64 ( const char * nptr , const char * * endptr , int base , \n uint64_t * result ) \n { \n char * p ; \n int err = 0 ; \n if ( ! nptr ) { \n if ( endptr ) { \n * endptr = nptr ; \n } \n err = - EINVAL ; \n } else { \n errno = 0 ; \n * result = strtoull ( nptr , & p , base ) ; \n if ( errno == ERANGE ) { \n * result = -1 ; \n } \n err = check_strtox_error ( nptr , p , endptr , errno ) ; \n } \n return err ; \n }", "idx": 7450}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "void v9fs_string_init ( V9fsString * str ) \n { \n str -> data = NULL ; \n str -> size = 0 ; \n }", "idx": 7484}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void do_spawn_thread ( ThreadPool * pool ) \n { \n QemuThread t ; \n if ( ! pool -> new_threads ) { \n return ; \n } \n pool -> new_threads -- ; \n pool -> pending_threads ++ ; \n qemu_thread_create ( & t , \" \" , worker_thread , pool , QEMU_THREAD_DETACHED ) ; \n }", "idx": 7487}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_net_tx_complete ( NetClientState * nc , ssize_t len ) \n { \n VirtIONet * n = qemu_get_nic_opaque ( nc ) ; \n VirtIONetQueue * q = virtio_net_get_subqueue ( nc ) ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( n ) ; \n virtqueue_push ( q -> tx_vq , & q -> async_tx . elem , 0 ) ; \n virtio_notify ( vdev , q -> tx_vq ) ; \n q -> async_tx . elem . out_num = 0 ; \n virtio_queue_set_notification ( q -> tx_vq , 1 ) ; \n virtio_net_flush_tx ( q ) ; \n }", "idx": 7502}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_mcast_init ( NetClientState * peer , \n const char * model , \n const char * name , \n const char * host_str , \n const char * localaddr_str ) \n { \n NetSocketState * s ; \n int fd ; \n struct sockaddr_in saddr ; \n struct in_addr localaddr , * param_localaddr ; \n if ( parse_host_port ( & saddr , host_str ) < 0 ) \n return -1 ; \n if ( localaddr_str != NULL ) { \n if ( inet_aton ( localaddr_str , & localaddr ) == 0 ) \n return -1 ; \n param_localaddr = & localaddr ; \n } else { \n param_localaddr = NULL ; \n } \n fd = net_socket_mcast_create ( & saddr , param_localaddr ) ; \n if ( fd < 0 ) \n return -1 ; \n s = net_socket_fd_init ( peer , model , name , fd , 0 ) ; \n if ( ! s ) \n return -1 ; \n s -> dgram_dst = saddr ; \n snprintf ( s -> nc . info_str , sizeof ( s -> nc . info_str ) , \n \" \" , \n inet_ntoa ( saddr . sin_addr ) , ntohs ( saddr . sin_port ) ) ; \n return 0 ; \n }", "idx": 7522}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl041_device_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ; \n k -> init = pl041_init ; \n set_bit ( DEVICE_CATEGORY_SOUND , dc -> categories ) ; \n dc -> no_user = 1 ; \n dc -> reset = pl041_device_reset ; \n dc -> vmsd = & vmstate_pl041 ; \n dc -> props = pl041_device_properties ; \n }", "idx": 7528}
{"project": "qemu", "commit_id": "ece2d05ed4adb9a9aa3ca9da0496be769dfb3a25", "target": 1, "func": "static int cd_read_sector ( IDEState * s , int lba , uint8_t * buf , int sector_size ) \n { \n int ret ; \n switch ( sector_size ) { \n case 2048 : \n block_acct_start ( blk_get_stats ( s -> blk ) , & s -> acct , \n 4 * BDRV_SECTOR_SIZE , BLOCK_ACCT_READ ) ; \n ret = blk_read ( s -> blk , ( int64_t ) lba << 2 , buf , 4 ) ; \n block_acct_done ( blk_get_stats ( s -> blk ) , & s -> acct ) ; \n break ; \n case 2352 : \n block_acct_start ( blk_get_stats ( s -> blk ) , & s -> acct , \n 4 * BDRV_SECTOR_SIZE , BLOCK_ACCT_READ ) ; \n ret = blk_read ( s -> blk , ( int64_t ) lba << 2 , buf + 16 , 4 ) ; \n block_acct_done ( blk_get_stats ( s -> blk ) , & s -> acct ) ; \n if ( ret < 0 ) \n return ret ; \n cd_data_to_raw ( buf , lba ) ; \n break ; \n default : \n ret = - EIO ; \n break ; \n } \n return ret ; \n }", "idx": 7538}
{"project": "qemu", "commit_id": "81145834d39897c6f153ac26a4077f90f269c5fc", "target": 1, "func": "static int cow_read ( BlockDriverState * bs , int64_t sector_num , \n uint8_t * buf , int nb_sectors ) \n { \n BDRVCowState * s = bs -> opaque ; \n int ret , n ; \n while ( nb_sectors > 0 ) { \n if ( cow_is_allocated ( bs , sector_num , nb_sectors , & n ) ) { \n ret = bdrv_pread ( bs -> file , \n s -> cow_sectors_offset + sector_num * 512 , \n buf , n * 512 ) ; \n if ( ret != n * 512 ) \n return -1 ; \n } else { \n if ( bs -> backing_hd ) { \n ret = bdrv_read ( bs -> backing_hd , sector_num , buf , n ) ; \n if ( ret < 0 ) \n return -1 ; \n } else { \n memset ( buf , 0 , n * 512 ) ; \n } \n } \n nb_sectors -= n ; \n sector_num += n ; \n buf += n * 512 ; \n } \n return 0 ; \n }", "idx": 7540}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static HotplugHandler * spapr_get_hotpug_handler ( MachineState * machine , \n DeviceState * dev ) \n { \n if ( object_dynamic_cast ( OBJECT ( dev ) , TYPE_PC_DIMM ) || \n object_dynamic_cast ( OBJECT ( dev ) , TYPE_SPAPR_CPU_CORE ) ) { \n return HOTPLUG_HANDLER ( machine ) ; \n } \n return NULL ; \n }", "idx": 7580}
{"project": "qemu", "commit_id": "cf0f7cf903073f9dd9979dd33d52618b384ac2cb", "target": 1, "func": "void kvm_init_cpu_signals ( CPUState * cpu ) \n { \n int r ; \n sigset_t set ; \n struct sigaction sigact ; \n memset ( & sigact , 0 , sizeof ( sigact ) ) ; \n sigact . sa_handler = dummy_signal ; \n sigaction ( SIG_IPI , & sigact , NULL ) ; \n pthread_sigmask ( SIG_BLOCK , NULL , & set ) ; \n #if defined KVM_HAVE_MCE_INJECTION  \n  \n  sigdelset ( & set , SIGBUS ) ; \n pthread_sigmask ( SIG_SETMASK , & set , NULL ) ; \n #endif \n sigdelset ( & set , SIG_IPI ) ; \n r = kvm_set_signal_mask ( cpu , & set ) ; \n if ( r ) { \n fprintf ( stderr , \" \\n \" , strerror ( - r ) ) ; \n exit ( 1 ) ; \n } \n }", "idx": 7665}
{"project": "qemu", "commit_id": "3e40ba0faf0822fa78336fe6cd9d677ea9b14f1b", "target": 1, "func": "static void vfio_disable_msix ( VFIODevice * vdev ) \n { \n msix_unset_vector_notifiers ( & vdev -> pdev ) ; \n if ( vdev -> nr_vectors ) { \n vfio_disable_irqindex ( vdev , VFIO_PCI_MSIX_IRQ_INDEX ) ; \n vfio_disable_msi_common ( vdev ) ; \n DPRINTF ( \" \\n \" , __func__ , vdev -> host . domain , \n vdev -> host . bus , vdev -> host . slot , vdev -> host . function ) ;", "idx": 7678}
{"project": "qemu", "commit_id": "36cf2a37132c7f01fa9adb5f95f5312b27742fd4", "target": 1, "func": "void virtqueue_map_sg ( struct iovec * sg , hwaddr * addr , \n size_t num_sg , int is_write ) \n { \n unsigned int i ; \n hwaddr len ; \n for ( i = 0 ; i < num_sg ; i ++ ) { \n len = sg [ i ] . iov_len ; \n sg [ i ] . iov_base = cpu_physical_memory_map ( addr [ i ] , & len , is_write ) ; \n if ( sg [ i ] . iov_base == NULL || len != sg [ i ] . iov_len ) { \n error_report ( \" \" ) ;", "idx": 7690}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void ehci_async_complete_packet ( USBPort * port , USBPacket * packet ) \n { \n EHCIQueue * q ; \n EHCIState * s = port -> opaque ; \n uint32_t portsc = s -> portsc [ port -> index ] ; \n if ( portsc & PORTSC_POWNER ) { \n USBPort * companion = s -> companion_ports [ port -> index ] ; \n companion -> ops -> complete ( companion , packet ) ; \n return ; \n } \n q = container_of ( packet , EHCIQueue , packet ) ; \n trace_usb_ehci_queue_action ( q , \" \" ) ; \n assert ( q -> async == EHCI_ASYNC_INFLIGHT ) ; \n q -> async = EHCI_ASYNC_FINISHED ; \n q -> usb_status = packet -> len ; \n }", "idx": 7706}
{"project": "qemu", "commit_id": "c2d76497b6eafcaedc806e07804e7bed55a98a0b", "target": 1, "func": "void get_tmp_filename ( char * filename , int size ) \n { \n char temp_dir [ MAX_PATH ] ; \n GetTempPath ( MAX_PATH , temp_dir ) ; \n GetTempFileName ( temp_dir , \" \" , 0 , filename ) ; \n }", "idx": 7770}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_clock_enable ( QEMUClockType type , bool enabled ) \n { \n QEMUClock * clock = qemu_clock_ptr ( type ) ; \n QEMUTimerList * tl ; \n bool old = clock -> enabled ; \n clock -> enabled = enabled ; \n if ( enabled && ! old ) { \n qemu_clock_notify ( type ) ; \n } else if ( ! enabled && old ) { \n QLIST_FOREACH ( tl , & clock -> timerlists , list )  { \n qemu_event_wait ( & tl -> timers_done_ev ) ; \n } \n } \n }", "idx": 7791}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t grlib_gptimer_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n GPTimerUnit * unit = opaque ; \n target_phys_addr_t timer_addr ; \n int id ; \n uint32_t value = 0 ; \n addr &= 0xff ; \n switch ( addr ) { \n case SCALER_OFFSET : \n trace_grlib_gptimer_readl ( -1 , addr , unit -> scaler ) ; \n return unit -> scaler ; \n case SCALER_RELOAD_OFFSET : \n trace_grlib_gptimer_readl ( -1 , addr , unit -> reload ) ; \n return unit -> reload ; \n case CONFIG_OFFSET : \n trace_grlib_gptimer_readl ( -1 , addr , unit -> config ) ; \n return unit -> config ; \n default : \n break ; \n } \n timer_addr = ( addr % TIMER_BASE ) ; \n id = ( addr - TIMER_BASE ) / TIMER_BASE ; \n if ( id >= 0 && id < unit -> nr_timers ) { \n switch ( timer_addr ) { \n case COUNTER_OFFSET : \n value = ptimer_get_count ( unit -> timers [ id ] . ptimer ) ; \n trace_grlib_gptimer_readl ( id , addr , value ) ; \n return value ; \n case COUNTER_RELOAD_OFFSET : \n value = unit -> timers [ id ] . reload ; \n trace_grlib_gptimer_readl ( id , addr , value ) ; \n return value ; \n case CONFIG_OFFSET : \n trace_grlib_gptimer_readl ( id , addr , unit -> timers [ id ] . config ) ; \n return unit -> timers [ id ] . config ; \n default : \n break ; \n } \n } \n trace_grlib_gptimer_readl ( -1 , addr , 0 ) ; \n return 0 ; \n }", "idx": 7792}
{"project": "qemu", "commit_id": "6d8048341995b31a77dc2e0dcaaf4e3df0e3121a", "target": 0, "func": "static int get_cpsr ( QEMUFile * f , void * opaque , size_t size , \n VMStateField * field ) \n { \n ARMCPU * cpu = opaque ; \n CPUARMState * env = & cpu -> env ; \n uint32_t val = qemu_get_be32 ( f ) ; \n if ( arm_feature ( env , ARM_FEATURE_M ) ) { \n if ( val & XPSR_EXCP ) { \n uint32_t newval = val ; \n newval &= ( CPSR_NZCV | CPSR_Q | CPSR_IT | CPSR_GE ) ; \n if ( val & CPSR_T ) { \n newval |= XPSR_T ; \n } \n if ( val & CPSR_F ) { \n env -> v7m . faultmask = 1 ; \n } \n if ( val & CPSR_I ) { \n env -> v7m . primask = 1 ; \n } \n val = newval ; \n } \n xpsr_write ( env , val , ~ XPSR_EXCP ) ; \n return 0 ; \n } \n env -> aarch64 = ( ( val & PSTATE_nRW ) == 0 ) ; \n if ( is_a64 ( env ) ) { \n pstate_write ( env , val ) ; \n return 0 ; \n } \n cpsr_write ( env , val , 0xffffffff , CPSRWriteRaw ) ; \n return 0 ; \n }", "idx": 7797}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t m5206_mbar_readl ( void * opaque , target_phys_addr_t offset ) \n { \n m5206_mbar_state * s = ( m5206_mbar_state * ) opaque ; \n int width ; \n offset &= 0x3ff ; \n if ( offset >= 0x200 ) { \n hw_error ( \" \" , ( int ) offset ) ; \n } \n width = m5206_mbar_width [ offset >> 2 ] ; \n if ( width < 4 ) { \n uint32_t val ; \n val = m5206_mbar_readw ( opaque , offset ) << 16 ; \n val |= m5206_mbar_readw ( opaque , offset + 2 ) ; \n return val ; \n } \n return m5206_mbar_read ( s , offset , 4 ) ; \n }", "idx": 7819}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "uint64_t qcow2_alloc_compressed_cluster_offset ( BlockDriverState * bs , \n uint64_t offset , \n int compressed_size ) \n { \n BDRVQcowState * s = bs -> opaque ; \n int l2_index , ret ; \n uint64_t * l2_table ; \n int64_t cluster_offset ; \n int nb_csectors ; \n ret = get_cluster_table ( bs , offset , & l2_table , & l2_index ) ; \n if ( ret < 0 ) { \n return 0 ; \n } \n cluster_offset = be64_to_cpu ( l2_table [ l2_index ] ) ; \n if ( cluster_offset & L2E_OFFSET_MASK ) { \n qcow2_cache_put ( bs , s -> l2_table_cache , ( void * * ) & l2_table ) ; \n return 0 ; \n } \n cluster_offset = qcow2_alloc_bytes ( bs , compressed_size ) ; \n if ( cluster_offset < 0 ) { \n qcow2_cache_put ( bs , s -> l2_table_cache , ( void * * ) & l2_table ) ; \n return 0 ; \n } \n nb_csectors = ( ( cluster_offset + compressed_size - 1 ) >> 9 ) - \n ( cluster_offset >> 9 ) ; \n cluster_offset |= QCOW_OFLAG_COMPRESSED | \n ( ( uint64_t ) nb_csectors << s -> csize_shift ) ; \n BLKDBG_EVENT ( bs -> file , BLKDBG_L2_UPDATE_COMPRESSED ) ; \n qcow2_cache_entry_mark_dirty ( bs , s -> l2_table_cache , l2_table ) ; \n l2_table [ l2_index ] = cpu_to_be64 ( cluster_offset ) ; \n ret = qcow2_cache_put ( bs , s -> l2_table_cache , ( void * * ) & l2_table ) ; \n if ( ret < 0 ) { \n return 0 ; \n } \n return cluster_offset ; \n }", "idx": 7826}
{"project": "qemu", "commit_id": "318347234d7069b62d38391dd27e269a3107d668", "target": 0, "func": "void spapr_core_unplug_request ( HotplugHandler * hotplug_dev , DeviceState * dev , \n Error * * errp ) \n { \n int index ; \n sPAPRDRConnector * drc ; \n sPAPRDRConnectorClass * drck ; \n Error * local_err = NULL ; \n CPUCore * cc = CPU_CORE ( dev ) ; \n int smt = kvmppc_smt_threads ( ) ; \n if ( ! spapr_find_cpu_slot ( MACHINE ( hotplug_dev ) , cc -> core_id , & index ) ) { \n error_setg ( errp , \" \" , \n cc -> core_id ) ; \n return ; \n } \n if ( index == 0 ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n drc = spapr_dr_connector_by_id ( SPAPR_DR_CONNECTOR_TYPE_CPU , index * smt ) ; \n g_assert ( drc ) ; \n drck = SPAPR_DR_CONNECTOR_GET_CLASS ( drc ) ; \n drck -> detach ( drc , dev , spapr_core_release , NULL , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n spapr_hotplug_req_remove_by_index ( drc ) ; \n }", "idx": 7837}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_up_char ( void ) \n { \n int idx ; \n if ( term_hist_entry == 0 ) \n return ; \n if ( term_hist_entry == -1 ) { \n for ( idx = 0 ; idx < TERM_MAX_CMDS ; idx ++ ) { \n if ( term_history [ idx ] == NULL ) \n break ; \n } \n term_hist_entry = idx ; \n } \n term_hist_entry -- ; \n if ( term_hist_entry >= 0 ) { \n pstrcpy ( term_cmd_buf , sizeof ( term_cmd_buf ) , \n term_history [ term_hist_entry ] ) ; \n term_cmd_buf_index = term_cmd_buf_size = strlen ( term_cmd_buf ) ; \n } \n }", "idx": 7877}
{"project": "qemu", "commit_id": "e6ae5981ea4b0f6feb223009a5108582e7644f8f", "target": 0, "func": "static inline int nvic_exec_prio ( NVICState * s ) \n { \n CPUARMState * env = & s -> cpu -> env ; \n int running ; \n if ( env -> daif & PSTATE_F ) { \n running = -1 ; \n } else if ( env -> daif & PSTATE_I ) { \n running = 0 ; \n } else if ( env -> v7m . basepri > 0 ) { \n running = env -> v7m . basepri & nvic_gprio_mask ( s ) ; \n } else { \n running = NVIC_NOEXC_PRIO ; \n } \n return MIN ( running , s -> exception_prio ) ; \n }", "idx": 7929}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16 ( QEMUFile * f , void * pv , size_t size ) \n { \n uint16_t * v = pv ; \n qemu_get_be16s ( f , v ) ; \n return 0 ; \n }", "idx": 7949}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void * qemu_malloc ( size_t size ) \n { \n if ( ! size && ! allow_zero_malloc ( ) ) { \n abort ( ) ; \n } \n return oom_check ( malloc ( size ? size : 1 ) ) ; \n }", "idx": 7955}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "static bool timer_mod_ns_locked ( QEMUTimerList * timer_list , \n QEMUTimer * ts , int64_t expire_time ) \n { \n QEMUTimer * * pt , * t ; \n pt = & timer_list -> active_timers ; \n for ( ; ; ) { \n t = * pt ; \n if ( ! timer_expired_ns ( t , expire_time ) ) { \n break ; \n } \n pt = & t -> next ; \n } \n ts -> expire_time = MAX ( expire_time , 0 ) ; \n ts -> next = * pt ; \n * pt = ts ; \n return pt == & timer_list -> active_timers ; \n }", "idx": 7963}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_9p_start ( void ) \n { \n char * args ; \n test_share = g_strdup ( \" \" ) ; \n g_assert_nonnull ( mkdtemp ( test_share ) ) ; \n args = g_strdup_printf ( \" \" \n \" \" , \n test_share , mount_tag ) ; \n qtest_start ( args ) ; \n g_free ( args ) ; \n }", "idx": 7969}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float64 int32_to_float64 ( int32 a STATUS_PARAM ) \n { \n flag zSign ; \n uint32 absA ; \n int8 shiftCount ; \n bits64 zSig ; \n if ( a == 0 ) return 0 ; \n zSign = ( a < 0 ) ; \n absA = zSign ? - a : a ; \n shiftCount = countLeadingZeros32 ( absA ) + 21 ; \n zSig = absA ; \n return packFloat64 ( zSign , 0x432 - shiftCount , zSig << shiftCount ) ; \n }", "idx": 7995}
{"project": "qemu", "commit_id": "577d0a38070d1d6c4c7fab5c2054380770b1ec6b", "target": 0, "func": "void blkconf_serial ( BlockConf * conf , char * * serial ) \n { \n DriveInfo * dinfo ; \n if ( ! * serial ) { \n dinfo = drive_get_by_blockdev ( conf -> bs ) ; \n if ( * dinfo -> serial ) { \n * serial = g_strdup ( dinfo -> serial ) ; \n } \n } \n }", "idx": 7998}
{"project": "qemu", "commit_id": "4cae4d5acaea23f3def84c8dc67ef5106323e5cb", "target": 1, "func": "static void peripheral_device_del_completion ( ReadLineState * rs , \n const char * str , size_t len ) \n { \n Object * peripheral ; \n GSList * list = NULL , * item ; \n peripheral = object_resolve_path ( \" \" , NULL ) ; \n if ( peripheral == NULL ) { \n return ; \n } \n object_child_foreach ( peripheral , qdev_build_hotpluggable_device_list , \n & list ) ; \n for ( item = list ; item ; item = g_slist_next ( item ) ) { \n DeviceState * dev = item -> data ; \n if ( dev -> id && ! strncmp ( str , dev -> id , len ) ) { \n readline_add_completion ( rs , dev -> id ) ; \n } \n } \n g_slist_free ( list ) ; \n }", "idx": 8024}
{"project": "qemu", "commit_id": "cfaf6d36ae761da1033159d85d670706ffb24fb9", "target": 0, "func": "static void tcp_accept_incoming_migration ( void * opaque ) \n { \n struct sockaddr_in addr ; \n socklen_t addrlen = sizeof ( addr ) ; \n int s = ( unsigned long ) opaque ; \n QEMUFile * f ; \n int c , ret ; \n do { \n c = qemu_accept ( s , ( struct sockaddr * ) & addr , & addrlen ) ; \n } while ( c == -1 && socket_error ( ) == EINTR ) ; \n DPRINTF ( \" \\n \" ) ; \n if ( c == -1 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return ; \n } \n f = qemu_fopen_socket ( c ) ; \n if ( f == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto out ; \n } \n ret = qemu_loadvm_state ( f ) ; \n if ( ret < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto out_fopen ; \n } \n qemu_announce_self ( ) ; \n DPRINTF ( \" \\n \" ) ; \n qemu_set_fd_handler2 ( s , NULL , NULL , NULL , NULL ) ; \n close ( s ) ; \n if ( autostart ) \n vm_start ( ) ; \n out_fopen : \n qemu_fclose ( f ) ; \n out : \n close ( c ) ; \n }", "idx": 8044}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_info_network ( int argc , const char * * argv ) \n { \n int i , j ; \n NetDriverState * nd ; \n for ( i = 0 ; i < nb_nics ; i ++ ) { \n nd = & nd_table [ i ] ; \n term_printf ( \" \" , i , nd -> ifname ) ; \n for ( j = 0 ; j < 6 ; j ++ ) { \n if ( j > 0 ) \n term_printf ( \" \" ) ; \n term_printf ( \" \" , nd -> macaddr [ j ] ) ; \n } \n term_printf ( \" \\n \" ) ; \n } \n }", "idx": 8073}
{"project": "qemu", "commit_id": "86a6a9bf551ffa183880480b37c5836d3916687a", "target": 0, "func": "void xen_invalidate_map_cache ( void ) \n { \n unsigned long i ; \n MapCacheRev * reventry ; \n bdrv_drain_all ( ) ; \n QTAILQ_FOREACH ( reventry , & mapcache -> locked_entries , next )  { \n DPRINTF ( \" \" \n \" \" TARGET_FMT_plx \" \\n \" , \n reventry -> paddr_index , reventry -> vaddr_req ) ; \n } \n mapcache_lock ( ) ; \n for ( i = 0 ; i < mapcache -> nr_buckets ; i ++ ) { \n MapCacheEntry * entry = & mapcache -> entry [ i ] ; \n if ( entry -> vaddr_base == NULL ) { \n continue ; \n } \n if ( entry -> lock > 0 ) { \n continue ; \n } \n if ( munmap ( entry -> vaddr_base , entry -> size ) != 0 ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n entry -> paddr_index = 0 ; \n entry -> vaddr_base = NULL ; \n entry -> size = 0 ; \n g_free ( entry -> valid_mapping ) ; \n entry -> valid_mapping = NULL ; \n } \n mapcache -> last_entry = NULL ; \n mapcache_unlock ( ) ; \n }", "idx": 8081}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_clkdsp_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n struct omap_mpu_state_s * s = ( struct omap_mpu_state_s * ) opaque ; \n if ( size != 2 ) { \n return omap_badwidth_read16 ( opaque , addr ) ; \n } \n switch ( addr ) { \n case 0x04 : \n return s -> clkm . dsp_idlect1 ; \n case 0x08 : \n return s -> clkm . dsp_idlect2 ; \n case 0x14 : \n return s -> clkm . dsp_rstct2 ; \n case 0x18 : \n return ( s -> clkm . clocking_scheme << 11 ) | s -> clkm . cold_start | \n ( s -> cpu -> env . halted << 6 ) ; \n } \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 8086}
{"project": "qemu", "commit_id": "aab2293687ee54a409f3fb53a1ab3595b595e0fb", "target": 1, "func": "static int fd_close ( MigrationState * s ) \n { \n DPRINTF ( \" \\n \" ) ; \n if ( s -> fd != -1 ) { \n close ( s -> fd ) ; \n s -> fd = -1 ; \n } \n return 0 ; \n }", "idx": 8088}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "struct USBEndpoint * usb_ep_get ( USBDevice * dev , int pid , int ep ) \n { \n struct USBEndpoint * eps = pid == USB_TOKEN_IN ? dev -> ep_in : dev -> ep_out ; \n if ( ep == 0 ) { \n return & dev -> ep_ctl ; \n } \n assert ( pid == USB_TOKEN_IN || pid == USB_TOKEN_OUT ) ; \n assert ( ep > 0 && ep <= USB_MAX_ENDPOINTS ) ; \n return eps + ep - 1 ; \n }", "idx": 8149}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void pointer_event ( VncState * vs , int button_mask , int x , int y ) \n { \n static uint32_t bmap [ INPUT_BUTTON_MAX ] = { \n [ INPUT_BUTTON_LEFT ] = 0x01 , \n [ INPUT_BUTTON_MIDDLE ] = 0x02 , \n [ INPUT_BUTTON_RIGHT ] = 0x04 , \n [ INPUT_BUTTON_WHEEL_UP ] = 0x08 , \n [ INPUT_BUTTON_WHEEL_DOWN ] = 0x10 , \n } ; \n QemuConsole * con = vs -> vd -> dcl . con ; \n int width = surface_width ( vs -> vd -> ds ) ; \n int height = surface_height ( vs -> vd -> ds ) ; \n if ( vs -> last_bmask != button_mask ) { \n qemu_input_update_buttons ( con , bmap , vs -> last_bmask , button_mask ) ; \n vs -> last_bmask = button_mask ; \n } \n if ( vs -> absolute ) { \n qemu_input_queue_abs ( con , INPUT_AXIS_X , x , width ) ; \n qemu_input_queue_abs ( con , INPUT_AXIS_Y , y , height ) ; \n } else if ( vnc_has_feature ( vs , VNC_FEATURE_POINTER_TYPE_CHANGE ) ) { \n qemu_input_queue_rel ( con , INPUT_AXIS_X , x - 0x7FFF ) ; \n qemu_input_queue_rel ( con , INPUT_AXIS_Y , y - 0x7FFF ) ; \n } else { \n if ( vs -> last_x != -1 ) { \n qemu_input_queue_rel ( con , INPUT_AXIS_X , x - vs -> last_x ) ; \n qemu_input_queue_rel ( con , INPUT_AXIS_Y , y - vs -> last_y ) ; \n } \n vs -> last_x = x ; \n vs -> last_y = y ; \n } \n qemu_input_event_sync ( ) ; \n }", "idx": 8173}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_uint16 ( Visitor * v , uint16_t * obj , const char * name , Error * * errp ) \n { \n int64_t value ; \n if ( ! error_is_set ( errp ) ) { \n if ( v -> type_uint16 ) { \n v -> type_uint16 ( v , obj , name , errp ) ; \n } else { \n value = * obj ; \n v -> type_int ( v , & value , name , errp ) ; \n if ( value < 0 || value > UINT16_MAX ) { \n error_set ( errp , QERR_INVALID_PARAMETER_VALUE , name ? name : \" \" , \n \" \" ) ; \n return ; \n } \n * obj = value ; \n } \n } \n }", "idx": 8177}
{"project": "qemu", "commit_id": "bd83b3620517ef9f2079cfda465953e60263f623", "target": 1, "func": "void qemu_iovec_destroy ( QEMUIOVector * qiov ) \n { \n assert ( qiov -> nalloc != -1 ) ; \n g_free ( qiov -> iov ) ; \n }", "idx": 8226}
{"project": "qemu", "commit_id": "b0f2027cde31c645524256763672e09eeb204a9a", "target": 1, "func": "bool virtio_blk_data_plane_create ( VirtIODevice * vdev , VirtIOBlkConf * blk , \n VirtIOBlockDataPlane * * dataplane ) \n { \n VirtIOBlockDataPlane * s ; \n int fd ; \n * dataplane = NULL ; \n if ( ! blk -> data_plane ) { \n return true ; \n if ( blk -> scsi ) { \n error_report ( \" \" ) ; \n if ( blk -> config_wce ) { \n error_report ( \" \" \n \" \" ) ; \n fd = raw_get_aio_fd ( blk -> conf . bs ) ; \n if ( fd < 0 ) { \n error_report ( \" \" \n \" \" ) ; \n s = g_new0 ( VirtIOBlockDataPlane , 1 ) ; \n s -> vdev = vdev ; \n s -> fd = fd ; \n s -> blk = blk ; \n bdrv_set_in_use ( blk -> conf . bs , 1 ) ; \n * dataplane = s ; \n return true ;", "idx": 8233}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void ecc_mem_writeb ( void * opaque , target_phys_addr_t addr , uint32_t val ) \n { \n printf ( \" \" TARGET_FMT_plx \" \\n \" , \n addr , val & 0xff ) ; \n }", "idx": 8250}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_write_em ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors ) \n { \n int async_ret ; \n BlockDriverAIOCB * acb ; \n struct iovec iov ; \n QEMUIOVector qiov ; \n async_ret = NOT_DONE ; \n iov . iov_base = ( void * ) buf ; \n iov . iov_len = nb_sectors * BDRV_SECTOR_SIZE ; \n qemu_iovec_init_external ( & qiov , & iov , 1 ) ; \n acb = bs -> drv -> bdrv_aio_writev ( bs , sector_num , & qiov , nb_sectors , \n bdrv_rw_em_cb , & async_ret ) ; \n if ( acb == NULL ) { \n async_ret = -1 ; \n goto fail ; \n } \n while ( async_ret == NOT_DONE ) { \n qemu_aio_wait ( ) ; \n } \n fail : \n return async_ret ; \n }", "idx": 8255}
{"project": "qemu", "commit_id": "0cd09c3a6cc2230ba38c462fc410b4acce59eb6f", "target": 0, "func": "static uint32_t virtio_9p_get_features ( VirtIODevice * vdev , uint32_t features ) \n { \n features |= 1 << VIRTIO_9P_MOUNT_TAG ; \n return features ; \n }", "idx": 8262}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t error_mem_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n abort ( ) ; \n }", "idx": 8284}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static void openpic_set_irq ( void * opaque , int n_IRQ , int level ) \n { \n OpenPICState * opp = opaque ; \n IRQSource * src ; \n if ( n_IRQ >= MAX_IRQ ) { \n fprintf ( stderr , \" \\n \" , __func__ , n_IRQ ) ; \n abort ( ) ; \n } \n src = & opp -> src [ n_IRQ ] ; \n DPRINTF ( \" \\n \" , \n n_IRQ , level , src -> ivpr ) ; \n if ( src -> level ) { \n src -> pending = level ; \n if ( ! level ) { \n src -> ivpr &= ~ IVPR_ACTIVITY_MASK ; \n } \n } else { \n if ( level ) { \n src -> pending = 1 ; \n } \n } \n openpic_update_irq ( opp , n_IRQ ) ; \n }", "idx": 8297}
{"project": "qemu", "commit_id": "9f14b0add1dcdbfa2ee61051d068211fb0a1fcc9", "target": 0, "func": "static void rng_egd_finalize ( Object * obj ) \n { \n RngEgd * s = RNG_EGD ( obj ) ; \n if ( s -> chr ) { \n qemu_chr_add_handlers ( s -> chr , NULL , NULL , NULL , NULL ) ; \n qemu_chr_fe_release ( s -> chr ) ; \n } \n g_free ( s -> chr_name ) ; \n rng_egd_free_requests ( s ) ; \n }", "idx": 8374}
{"project": "qemu", "commit_id": "f278d4947fff814dcde2ef2acad36d172ff8be35", "target": 1, "func": "int pic_read_irq ( DeviceState * d ) \n { \n PICCommonState * s = DO_UPCAST ( PICCommonState , dev . qdev , d ) ; \n int irq , irq2 , intno ; \n irq = pic_get_irq ( s ) ; \n if ( irq >= 0 ) { \n if ( irq == 2 ) { \n irq2 = pic_get_irq ( slave_pic ) ; \n if ( irq2 >= 0 ) { \n pic_intack ( slave_pic , irq2 ) ; \n } else { \n irq2 = 7 ; \n intno = slave_pic -> irq_base + irq2 ; \n } else { \n intno = s -> irq_base + irq ; \n pic_intack ( s , irq ) ; \n } else { \n irq = 7 ; \n intno = s -> irq_base + irq ; \n #if defined ( DEBUG_PIC ) || defined ( DEBUG_IRQ_LATENCY )  \n  \n  if ( irq == 2 ) { \n irq = irq2 + 8 ; \n #endif  \n  \n  #ifdef DEBUG_IRQ_LATENCY \n printf ( \" \\n \" , \n irq , \n ( double ) ( qemu_get_clock_ns ( vm_clock ) - \n irq_time [ irq ] ) * 1000000.0 / get_ticks_per_sec ( ) ) ; \n #endif \n DPRINTF ( \" \\n \" , irq ) ; \n return intno ;", "idx": 8440}
{"project": "qemu", "commit_id": "b021d1c04452276f4926eed2d104ccbd1037a6e1", "target": 1, "func": "void memory_region_notify_one ( IOMMUNotifier * notifier , \n IOMMUTLBEntry * entry ) \n { \n IOMMUNotifierFlag request_flags ; \n if ( notifier -> start > entry -> iova + entry -> addr_mask + 1 || \n notifier -> end < entry -> iova ) { \n return ; \n } \n if ( entry -> perm & IOMMU_RW ) { \n request_flags = IOMMU_NOTIFIER_MAP ; \n } else { \n request_flags = IOMMU_NOTIFIER_UNMAP ; \n } \n if ( notifier -> notifier_flags & request_flags ) { \n notifier -> notify ( notifier , entry ) ; \n } \n }", "idx": 8449}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void udp_chr_close ( CharDriverState * chr ) \n { \n NetCharDriver * s = chr -> opaque ; \n if ( s -> tag ) { \n g_source_remove ( s -> tag ) ; \n s -> tag = 0 ; \n } \n if ( s -> chan ) { \n g_io_channel_unref ( s -> chan ) ; \n closesocket ( s -> fd ) ; \n } \n g_free ( s ) ; \n qemu_chr_be_event ( chr , CHR_EVENT_CLOSED ) ; \n }", "idx": 8451}
{"project": "qemu", "commit_id": "24355b79bdaf6ab12f7c610b032fc35ec045cd55", "target": 1, "func": "static void scsi_write_same_complete ( void * opaque , int ret ) \n { \n WriteSameCBData * data = opaque ; \n SCSIDiskReq * r = data -> r ; \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; \n assert ( r -> req . aiocb != NULL ) ; \n r -> req . aiocb = NULL ; \n aio_context_acquire ( blk_get_aio_context ( s -> qdev . conf . blk ) ) ; \n if ( scsi_disk_req_check_error ( r , ret , true ) ) { \n goto done ; \n } \n block_acct_done ( blk_get_stats ( s -> qdev . conf . blk ) , & r -> acct ) ; \n data -> nb_sectors -= data -> iov . iov_len / 512 ; \n data -> sector += data -> iov . iov_len / 512 ; \n data -> iov . iov_len = MIN ( data -> nb_sectors * 512 , data -> iov . iov_len ) ; \n if ( data -> iov . iov_len ) { \n block_acct_start ( blk_get_stats ( s -> qdev . conf . blk ) , & r -> acct , \n data -> iov . iov_len , BLOCK_ACCT_WRITE ) ; \n qemu_iovec_init_external ( & data -> qiov , & data -> iov , 1 ) ; \n r -> req . aiocb = blk_aio_pwritev ( s -> qdev . conf . blk , \n data -> sector << BDRV_SECTOR_BITS , \n & data -> qiov , 0 , \n scsi_write_same_complete , data ) ; \n return ; \n } \n scsi_req_complete ( & r -> req , GOOD ) ; \n done : \n scsi_req_unref ( & r -> req ) ; \n qemu_vfree ( data -> iov . iov_base ) ; \n g_free ( data ) ; \n }", "idx": 8469}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "void xen_be_unbind_evtchn ( struct XenDevice * xendev ) \n { \n if ( xendev -> local_port == -1 ) { \n return ; \n } \n qemu_set_fd_handler ( xc_evtchn_fd ( xendev -> evtchndev ) , NULL , NULL , NULL ) ; \n xc_evtchn_unbind ( xendev -> evtchndev , xendev -> local_port ) ; \n xen_be_printf ( xendev , 2 , \" \\n \" , xendev -> local_port ) ; \n xendev -> local_port = -1 ; \n }", "idx": 8566}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int ppc_hash64_check_prot ( int prot , int rw , int access_type ) \n { \n int ret ; \n if ( access_type == ACCESS_CODE ) { \n if ( prot & PAGE_EXEC ) { \n ret = 0 ; \n } else { \n ret = -2 ; \n } \n } else if ( rw ) { \n if ( prot & PAGE_WRITE ) { \n ret = 0 ; \n } else { \n ret = -2 ; \n } \n } else { \n if ( prot & PAGE_READ ) { \n ret = 0 ; \n } else { \n ret = -2 ; \n } \n } \n return ret ; \n }", "idx": 8574}
{"project": "qemu", "commit_id": "d7b61ecc61f84d23f98f1ee270fb48b41834ca00", "target": 0, "func": "static int unin_agp_pci_host_init ( PCIDevice * d ) \n { \n pci_config_set_vendor_id ( d -> config , PCI_VENDOR_ID_APPLE ) ; \n pci_config_set_device_id ( d -> config , PCI_DEVICE_ID_APPLE_UNI_N_AGP ) ; \n d -> config [ 0x08 ] = 0x00 ; \n pci_config_set_class ( d -> config , PCI_CLASS_BRIDGE_HOST ) ; \n d -> config [ 0x0C ] = 0x08 ; \n d -> config [ 0x0D ] = 0x10 ; \n return 0 ; \n }", "idx": 8624}
{"project": "qemu", "commit_id": "8978b34af3250354e0b67340a7e920f909beda13", "target": 0, "func": "static void float_number ( void ) \n { \n int i ; \n struct { \n const char * encoded ; \n double decoded ; \n int skip ; \n } test_cases [ ] = { \n { \" \" , 32.43 } , \n { \" \" , 0.222 } , \n { \" \" , -32.12313 } , \n { \" \" , -32.20e-10 , . skip = 1 } , \n { } , \n } ; \n for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { \n QObject * obj ; \n QFloat * qfloat ; \n obj = qobject_from_json ( test_cases [ i ] . encoded ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QFLOAT ) ; \n qfloat = qobject_to_qfloat ( obj ) ; \n g_assert ( qfloat_get_double ( qfloat ) == test_cases [ i ] . decoded ) ; \n if ( test_cases [ i ] . skip == 0 ) { \n QString * str ; \n str = qobject_to_json ( obj ) ; \n g_assert ( strcmp ( qstring_get_str ( str ) , test_cases [ i ] . encoded ) == 0 ) ; \n QDECREF ( str ) ; \n } \n QDECREF ( qfloat ) ; \n } \n }", "idx": 8625}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void ecc_mem_write ( void * opaque , target_phys_addr_t addr , uint64_t val , \n unsigned size ) \n { \n ECCState * s = opaque ; \n switch ( addr >> 2 ) { \n case ECC_MER : \n if ( s -> version == ECC_MCC ) \n s -> regs [ ECC_MER ] = ( val & ECC_MER_MASK_0 ) ; \n else if ( s -> version == ECC_EMC ) \n s -> regs [ ECC_MER ] = s -> version | ( val & ECC_MER_MASK_1 ) ; \n else if ( s -> version == ECC_SMC ) \n s -> regs [ ECC_MER ] = s -> version | ( val & ECC_MER_MASK_2 ) ; \n trace_ecc_mem_writel_mer ( val ) ; \n break ; \n case ECC_MDR : \n s -> regs [ ECC_MDR ] = val & ECC_MDR_MASK ; \n trace_ecc_mem_writel_mdr ( val ) ; \n break ; \n case ECC_MFSR : \n s -> regs [ ECC_MFSR ] = val ; \n qemu_irq_lower ( s -> irq ) ; \n trace_ecc_mem_writel_mfsr ( val ) ; \n break ; \n case ECC_VCR : \n s -> regs [ ECC_VCR ] = val ; \n trace_ecc_mem_writel_vcr ( val ) ; \n break ; \n case ECC_DR : \n s -> regs [ ECC_DR ] = val ; \n trace_ecc_mem_writel_dr ( val ) ; \n break ; \n case ECC_ECR0 : \n s -> regs [ ECC_ECR0 ] = val ; \n trace_ecc_mem_writel_ecr0 ( val ) ; \n break ; \n case ECC_ECR1 : \n s -> regs [ ECC_ECR0 ] = val ; \n trace_ecc_mem_writel_ecr1 ( val ) ; \n break ; \n } \n }", "idx": 8647}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_op_mull_T0_T1 ( void ) \n { \n TCGv tmp1 = tcg_temp_new ( TCG_TYPE_I64 ) ; \n TCGv tmp2 = tcg_temp_new ( TCG_TYPE_I64 ) ; \n tcg_gen_extu_i32_i64 ( tmp1 , cpu_T [ 0 ] ) ; \n tcg_gen_extu_i32_i64 ( tmp2 , cpu_T [ 1 ] ) ; \n tcg_gen_mul_i64 ( tmp1 , tmp1 , tmp2 ) ; \n tcg_gen_trunc_i64_i32 ( cpu_T [ 0 ] , tmp1 ) ; \n tcg_gen_shri_i64 ( tmp1 , tmp1 , 32 ) ; \n tcg_gen_trunc_i64_i32 ( cpu_T [ 1 ] , tmp1 ) ; \n }", "idx": 8666}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_subfco ( void ) \n { \n T2 = T0 ; \n T0 = T1 - T0 ; \n if ( likely ( T0 > T1 ) ) { \n xer_ca = 0 ; \n } else { \n xer_ca = 1 ; \n } \n if ( likely ( ! ( ( ( ~ T2 ) ^ T1 ^ ( -1 ) ) & ( ( ~ T2 ) ^ T0 ) & ( 1 << 31 ) ) ) ) { \n xer_ov = 0 ; \n } else { \n xer_so = 1 ; \n xer_ov = 1 ; \n } \n }", "idx": 8719}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_del_sq ( NvmeCtrl * n , NvmeCmd * cmd ) \n { \n NvmeDeleteQ * c = ( NvmeDeleteQ * ) cmd ; \n NvmeRequest * req , * next ; \n NvmeSQueue * sq ; \n NvmeCQueue * cq ; \n uint16_t qid = le16_to_cpu ( c -> qid ) ; \n if ( ! qid || nvme_check_sqid ( n , qid ) ) { \n return NVME_INVALID_QID | NVME_DNR ; \n } \n sq = n -> sq [ qid ] ; \n while ( ! QTAILQ_EMPTY ( & sq -> out_req_list ) ) { \n req = QTAILQ_FIRST ( & sq -> out_req_list ) ; \n assert ( req -> aiocb ) ; \n blk_aio_cancel ( req -> aiocb ) ; \n } \n if ( ! nvme_check_cqid ( n , sq -> cqid ) ) { \n cq = n -> cq [ sq -> cqid ] ; \n QTAILQ_REMOVE ( & cq -> sq_list , sq , entry ) ; \n nvme_post_cqes ( cq ) ; \n QTAILQ_FOREACH_SAFE ( req , & cq -> req_list , entry , next )  { \n if ( req -> sq == sq ) { \n QTAILQ_REMOVE ( & cq -> req_list , req , entry ) ; \n QTAILQ_INSERT_TAIL ( & sq -> req_list , req , entry ) ; \n } \n } \n } \n nvme_free_sq ( sq , n ) ; \n return NVME_SUCCESS ; \n }", "idx": 8724}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_btst ( TCGv d , TCGv a , TCGv b ) \n { \n TCGv sbit ; \n TCGv bset ; \n TCGv t0 ; \n int l1 ; \n l1 = gen_new_label ( ) ; \n sbit = tcg_temp_new ( TCG_TYPE_TL ) ; \n bset = tcg_temp_new ( TCG_TYPE_TL ) ; \n t0 = tcg_temp_new ( TCG_TYPE_TL ) ; \n tcg_gen_andi_tl ( sbit , b , 31 ) ; \n tcg_gen_shl_tl ( t0 , tcg_const_tl ( 1 ) , sbit ) ; \n tcg_gen_and_tl ( bset , a , t0 ) ; \n tcg_gen_shr_tl ( bset , bset , sbit ) ; \n tcg_gen_shli_tl ( bset , bset , 3 ) ; \n tcg_gen_shl_tl ( sbit , tcg_const_tl ( 2 ) , sbit ) ; \n tcg_gen_subi_tl ( sbit , sbit , 1 ) ; \n tcg_gen_and_tl ( sbit , a , sbit ) ; \n tcg_gen_andi_tl ( d , cpu_PR [ PR_CCS ] , ~ ( X_FLAG | N_FLAG | Z_FLAG ) ) ; \n tcg_gen_or_tl ( d , d , bset ) ; \n tcg_gen_brcondi_tl ( TCG_COND_NE , sbit , 0 , l1 ) ; \n tcg_gen_ori_tl ( d , d , Z_FLAG ) ; \n gen_set_label ( l1 ) ; \n tcg_temp_free ( sbit ) ; \n tcg_temp_free ( bset ) ; \n }", "idx": 8750}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "static void test_parse_path ( void ) \n { \n g_test_trap_subprocess ( \" \" , 0 , 0 ) ; \n g_test_trap_assert_passed ( ) ; \n g_test_trap_assert_stdout ( \" \" ) ; \n g_test_trap_assert_stderr ( \" \" ) ; \n }", "idx": 8827}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_unordered ( floatx80 a , floatx80 b , float_status * status ) \n { \n if ( ( ( extractFloatx80Exp ( a ) == 0x7FFF ) \n && ( uint64_t ) ( extractFloatx80Frac ( a ) << 1 ) ) \n || ( ( extractFloatx80Exp ( b ) == 0x7FFF ) \n && ( uint64_t ) ( extractFloatx80Frac ( b ) << 1 ) ) \n ) { \n float_raise ( float_flag_invalid , status ) ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 8837}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static void usbredir_do_attach ( void * opaque ) \n { \n USBRedirDevice * dev = opaque ; \n if ( ( dev -> dev . port -> speedmask & USB_SPEED_MASK_SUPER ) && ! ( \n usbredirparser_peer_has_cap ( dev -> parser , \n usb_redir_cap_ep_info_max_packet_size ) && \n usbredirparser_peer_has_cap ( dev -> parser , \n usb_redir_cap_32bits_bulk_length ) && \n usbredirparser_peer_has_cap ( dev -> parser , \n usb_redir_cap_64bits_ids ) ) ) { \n ERROR ( \" \\n \" ) ; \n usbredir_reject_device ( dev ) ; \n return ; \n } \n if ( usb_device_attach ( & dev -> dev ) != 0 ) { \n WARNING ( \" \\n \" ) ; \n usbredir_reject_device ( dev ) ; \n } \n }", "idx": 8838}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fctidz ( uint64_t arg ) \n { \n CPU_DoubleU farg ; \n farg . ll = arg ; \n if ( unlikely ( float64_is_signaling_nan ( farg . d ) ) ) { \n farg . ll = fload_invalid_op_excp ( POWERPC_EXCP_FP_VXSNAN | POWERPC_EXCP_FP_VXCVI ) ; \n } else if ( unlikely ( float64_is_nan ( farg . d ) || float64_is_infinity ( farg . d ) ) ) { \n farg . ll = fload_invalid_op_excp ( POWERPC_EXCP_FP_VXCVI ) ; \n } else { \n farg . ll = float64_to_int64_round_to_zero ( farg . d , & env -> fp_status ) ; \n } \n return farg . ll ; \n }", "idx": 8853}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static void vtd_iommu_notify_flag_changed ( MemoryRegion * iommu , \n IOMMUNotifierFlag old , \n IOMMUNotifierFlag new ) \n { \n VTDAddressSpace * vtd_as = container_of ( iommu , VTDAddressSpace , iommu ) ; \n if ( new & IOMMU_NOTIFIER_MAP ) { \n error_report ( \" \" \n \" \" \n \" \" , \n vtd_as -> bus -> qbus . name , PCI_SLOT ( vtd_as -> devfn ) , \n PCI_FUNC ( vtd_as -> devfn ) ) ; \n exit ( 1 ) ; \n } \n }", "idx": 8862}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_long_reg_write ( XenPCIPassthroughState * s , XenPTReg * cfg_entry , \n uint32_t * val , uint32_t dev_value , \n uint32_t valid_mask ) \n { \n XenPTRegInfo * reg = cfg_entry -> reg ; \n uint32_t writable_mask = 0 ; \n uint32_t throughable_mask = get_throughable_mask ( s , reg , valid_mask ) ; \n writable_mask = reg -> emu_mask & ~ reg -> ro_mask & valid_mask ; \n cfg_entry -> data = XEN_PT_MERGE_VALUE ( * val , cfg_entry -> data , writable_mask ) ; \n * val = XEN_PT_MERGE_VALUE ( * val , dev_value , throughable_mask ) ; \n return 0 ; \n }", "idx": 8864}
{"project": "qemu", "commit_id": "fa6252b0565526ec2347e248172f91771e0d9f47", "target": 1, "func": "coroutine_fn iscsi_co_write_zeroes ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , BdrvRequestFlags flags ) \n { \n IscsiLun * iscsilun = bs -> opaque ; \n struct IscsiTask iTask ; \n uint64_t lba ; \n uint32_t nb_blocks ; \n if ( ! is_request_lun_aligned ( sector_num , nb_sectors , iscsilun ) ) { \n return - EINVAL ; \n } \n if ( ! iscsilun -> lbp . lbpws ) { \n return - ENOTSUP ; \n } \n lba = sector_qemu2lun ( sector_num , iscsilun ) ; \n nb_blocks = sector_qemu2lun ( nb_sectors , iscsilun ) ; \n if ( iscsilun -> zeroblock == NULL ) { \n iscsilun -> zeroblock = g_malloc0 ( iscsilun -> block_size ) ; \n } \n iscsi_co_init_iscsitask ( iscsilun , & iTask ) ; \n retry : \n if ( iscsi_writesame16_task ( iscsilun -> iscsi , iscsilun -> lun , lba , \n iscsilun -> zeroblock , iscsilun -> block_size , \n nb_blocks , 0 , ! ! ( flags & BDRV_REQ_MAY_UNMAP ) , \n 0 , 0 , iscsi_co_generic_cb , & iTask ) == NULL ) { \n return - EIO ; \n } \n while ( ! iTask . complete ) { \n iscsi_set_events ( iscsilun ) ; \n qemu_coroutine_yield ( ) ; \n } \n if ( iTask . task != NULL ) { \n scsi_free_scsi_task ( iTask . task ) ; \n iTask . task = NULL ; \n } \n if ( iTask . do_retry ) { \n goto retry ; \n } \n if ( iTask . status != SCSI_STATUS_GOOD ) { \n return - EIO ; \n } \n return 0 ; \n }", "idx": 8873}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static BlkverifyAIOCB * blkverify_aio_get ( BlockDriverState * bs , bool is_write , \n int64_t sector_num , QEMUIOVector * qiov , \n int nb_sectors , \n BlockCompletionFunc * cb , \n void * opaque ) \n { \n BlkverifyAIOCB * acb = qemu_aio_get ( & blkverify_aiocb_info , bs , cb , opaque ) ; \n acb -> is_write = is_write ; \n acb -> sector_num = sector_num ; \n acb -> nb_sectors = nb_sectors ; \n acb -> ret = - EINPROGRESS ; \n acb -> done = 0 ; \n acb -> qiov = qiov ; \n acb -> buf = NULL ; \n acb -> verify = NULL ; \n return acb ; \n }", "idx": 8874}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_list ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefOneList * head = NULL ; \n Visitor * v ; \n v = validate_test_init ( data , \" \" ) ; \n visit_type_UserDefOneList ( v , NULL , & head , & error_abort ) ; \n qapi_free_UserDefOneList ( head ) ; \n }", "idx": 8915}
{"project": "qemu", "commit_id": "871271615108fd58273423d98b7cefe08e6f75a0", "target": 0, "func": "void monitor_init ( CharDriverState * chr , int show_banner ) \n { \n int i ; \n if ( is_first_init ) { \n key_timer = qemu_new_timer ( vm_clock , release_keys , NULL ) ; \n if ( ! key_timer ) \n return ; \n for ( i = 0 ; i < MAX_MON ; i ++ ) { \n monitor_hd [ i ] = NULL ; \n } \n is_first_init = 0 ; \n } \n for ( i = 0 ; i < MAX_MON ; i ++ ) { \n if ( monitor_hd [ i ] == NULL ) { \n monitor_hd [ i ] = chr ; \n break ; \n } \n } \n hide_banner = ! show_banner ; \n qemu_chr_add_handlers ( chr , term_can_read , term_read , term_event , cur_mon ) ; \n readline_start ( \" \" , 0 , monitor_command_cb , NULL ) ; \n }", "idx": 8978}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int iommu_dma_memory_rw ( DMAContext * dma , dma_addr_t addr , \n void * buf , dma_addr_t len , DMADirection dir ) \n { \n target_phys_addr_t paddr , plen ; \n int err ; \n #ifdef DEBUG_IOMMU \n fprintf ( stderr , \" \" DMA_ADDR_FMT \" \" \n DMA_ADDR_FMT \" \\n \" , dma , addr , len , dir ) ; \n #endif \n while ( len ) { \n err = dma -> translate ( dma , addr , & paddr , & plen , dir ) ; \n if ( err ) { \n memset ( buf , 0 , len ) ; \n return -1 ; \n } \n if ( plen > len ) { \n plen = len ; \n } \n address_space_rw ( dma -> as , paddr , buf , plen , dir == DMA_DIRECTION_FROM_DEVICE ) ; \n len -= plen ; \n addr += plen ; \n buf += plen ; \n } \n return 0 ; \n }", "idx": 9001}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST ( simple_list ) \n { \n int i ; \n struct { \n const char * encoded ; \n LiteralQObject decoded ; \n } test_cases [ ] = { \n { \n . encoded = \" \" , \n . decoded = QLIT_QLIST ( ( ( LiteralQObject [ ] ) { \n QLIT_QINT ( 43 ) , \n QLIT_QINT ( 42 ) , \n { } \n } ) ) , \n } , \n { \n . encoded = \" \" , \n . decoded = QLIT_QLIST ( ( ( LiteralQObject [ ] ) { \n QLIT_QINT ( 43 ) , \n { } \n } ) ) , \n } , \n { \n . encoded = \" \" , \n . decoded = QLIT_QLIST ( ( ( LiteralQObject [ ] ) { \n { } \n } ) ) , \n } , \n { \n . encoded = \" \" , \n . decoded = QLIT_QLIST ( ( ( LiteralQObject [ ] ) { \n QLIT_QDICT ( ( ( LiteralQDictEntry [ ] ) { \n { } , \n } ) ) , \n { } , \n } ) ) , \n } , \n { } \n } ; \n for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { \n QObject * obj ; \n QString * str ; \n obj = qobject_from_json ( test_cases [ i ] . encoded ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QLIST ) ; \n fail_unless ( compare_litqobj_to_qobj ( & test_cases [ i ] . decoded , obj ) == 1 ) ; \n str = qobject_to_json ( obj ) ; \n qobject_decref ( obj ) ; \n obj = qobject_from_json ( qstring_get_str ( str ) ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QLIST ) ; \n fail_unless ( compare_litqobj_to_qobj ( & test_cases [ i ] . decoded , obj ) == 1 ) ; \n qobject_decref ( obj ) ; \n QDECREF ( str ) ; \n } \n }", "idx": 9032}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void readline_update ( ReadLineState * rs ) \n { \n int i , delta , len ; \n if ( rs -> cmd_buf_size != rs -> last_cmd_buf_size || \n memcmp ( rs -> cmd_buf , rs -> last_cmd_buf , rs -> cmd_buf_size ) != 0 ) { \n for ( i = 0 ; i < rs -> last_cmd_buf_index ; i ++ ) { \n monitor_printf ( rs -> mon , \" \\033 \" ) ; \n } \n rs -> cmd_buf [ rs -> cmd_buf_size ] = ' \\0 ' ; \n if ( rs -> read_password ) { \n len = strlen ( rs -> cmd_buf ) ; \n for ( i = 0 ; i < len ; i ++ ) \n monitor_printf ( rs -> mon , \" \" ) ; \n } else { \n monitor_printf ( rs -> mon , \" \" , rs -> cmd_buf ) ; \n } \n monitor_printf ( rs -> mon , \" \\033 \" ) ; \n memcpy ( rs -> last_cmd_buf , rs -> cmd_buf , rs -> cmd_buf_size ) ; \n rs -> last_cmd_buf_size = rs -> cmd_buf_size ; \n rs -> last_cmd_buf_index = rs -> cmd_buf_size ; \n } \n if ( rs -> cmd_buf_index != rs -> last_cmd_buf_index ) { \n delta = rs -> cmd_buf_index - rs -> last_cmd_buf_index ; \n if ( delta > 0 ) { \n for ( i = 0 ; i < delta ; i ++ ) { \n monitor_printf ( rs -> mon , \" \\033 \" ) ; \n } \n } else { \n delta = - delta ; \n for ( i = 0 ; i < delta ; i ++ ) { \n monitor_printf ( rs -> mon , \" \\033 \" ) ; \n } \n } \n rs -> last_cmd_buf_index = rs -> cmd_buf_index ; \n } \n monitor_flush ( rs -> mon ) ; \n }", "idx": 9051}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_update_rings ( VirtIODevice * vdev , int n ) \n { \n VRing * vring = & vdev -> vq [ n ] . vring ; \n if ( ! vring -> desc ) { \n return ; \n } \n vring -> avail = vring -> desc + vring -> num * sizeof ( VRingDesc ) ; \n vring -> used = vring_align ( vring -> avail + \n offsetof ( VRingAvail , ring [ vring -> num ] ) , \n vring -> align ) ; \n virtio_init_region_cache ( vdev , n ) ; \n }", "idx": 9079}
{"project": "qemu", "commit_id": "c8389550dedc65892fba9c3df29423efd802f544", "target": 1, "func": "static void vmgenid_realize ( DeviceState * dev , Error * * errp ) \n { \n VmGenIdState * vms = VMGENID ( dev ) ; \n if ( ! vms -> write_pointer_available ) { \n error_setg ( errp , \" \" \n \" \" , VMGENID_DEVICE ) ; \n return ; \n } \n if ( ! find_vmgenid_dev ( ) ) { \n error_setg ( errp , \" \" , VMGENID_DEVICE ) ; \n return ; \n } \n qemu_register_reset ( vmgenid_handle_reset , vms ) ; \n }", "idx": 9110}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_window_check1 ( DisasContext * dc , unsigned r1 ) \n { \n if ( dc -> tb -> flags & XTENSA_TBFLAG_EXCM ) { \n return ; \n } \n if ( option_enabled ( dc , XTENSA_OPTION_WINDOWED_REGISTER ) && \n r1 / 4 > dc -> used_window ) { \n int label = gen_new_label ( ) ; \n TCGv_i32 ws = tcg_temp_new_i32 ( ) ; \n dc -> used_window = r1 / 4 ; \n tcg_gen_deposit_i32 ( ws , cpu_SR [ WINDOW_START ] , cpu_SR [ WINDOW_START ] , \n dc -> config -> nareg / 4 , dc -> config -> nareg / 4 ) ; \n tcg_gen_shr_i32 ( ws , ws , cpu_SR [ WINDOW_BASE ] ) ; \n tcg_gen_andi_i32 ( ws , ws , ( 2 << ( r1 / 4 ) ) - 2 ) ; \n tcg_gen_brcondi_i32 ( TCG_COND_EQ , ws , 0 , label ) ; \n { \n TCGv_i32 pc = tcg_const_i32 ( dc -> pc ) ; \n TCGv_i32 w = tcg_const_i32 ( r1 / 4 ) ; \n gen_advance_ccount_cond ( dc ) ; \n gen_helper_window_check ( cpu_env , pc , w ) ; \n tcg_temp_free ( w ) ; \n tcg_temp_free ( pc ) ; \n } \n gen_set_label ( label ) ; \n tcg_temp_free ( ws ) ; \n } \n }", "idx": 9142}
{"project": "qemu", "commit_id": "9d8f818cdee83e726a5dd14b645738ec632d2577", "target": 0, "func": "int nbd_client_co_pdiscard ( BlockDriverState * bs , int64_t offset , int bytes ) \n { \n NBDClientSession * client = nbd_get_client_session ( bs ) ; \n NBDRequest request = { \n . type = NBD_CMD_TRIM , \n . from = offset , \n . len = bytes , \n } ; \n assert ( ! ( client -> info . flags & NBD_FLAG_READ_ONLY ) ) ; \n if ( ! ( client -> info . flags & NBD_FLAG_SEND_TRIM ) ) { \n return 0 ; \n } \n return nbd_co_request ( bs , & request , NULL ) ; \n }", "idx": 9207}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static QEMUCursor * qxl_cursor ( PCIQXLDevice * qxl , QXLCursor * cursor , \n uint32_t group_id ) \n { \n QEMUCursor * c ; \n size_t size ; \n c = cursor_alloc ( cursor -> header . width , cursor -> header . height ) ; \n c -> hot_x = cursor -> header . hot_spot_x ; \n c -> hot_y = cursor -> header . hot_spot_y ; \n switch ( cursor -> header . type ) { \n case SPICE_CURSOR_TYPE_ALPHA : \n size = sizeof ( uint32_t ) * cursor -> header . width * cursor -> header . height ; \n qxl_unpack_chunks ( c -> data , size , qxl , & cursor -> chunk , group_id ) ; \n if ( qxl -> debug > 2 ) { \n cursor_print_ascii_art ( c , \" \" ) ; \n } \n break ; \n default : \n fprintf ( stderr , \" \\n \" , \n __FUNCTION__ , cursor -> header . type ) ; \n goto fail ; \n } \n return c ; \n fail : \n cursor_put ( c ) ; \n return NULL ; \n }", "idx": 9211}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QFloat * qfloat_from_double ( double value ) \n { \n QFloat * qf ; \n qf = g_malloc ( sizeof ( * qf ) ) ; \n qf -> value = value ; \n QOBJECT_INIT ( qf , & qfloat_type ) ; \n return qf ; \n }", "idx": 9218}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void * qemu_blockalign ( BlockDriverState * bs , size_t size ) \n { \n return qemu_memalign ( bdrv_opt_mem_align ( bs ) , size ) ; \n }", "idx": 9220}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static void spapr_drc_release ( sPAPRDRConnector * drc ) \n { \n sPAPRDRConnectorClass * drck = SPAPR_DR_CONNECTOR_GET_CLASS ( drc ) ; \n drck -> release ( drc -> dev ) ; \n drc -> awaiting_release = false ; \n g_free ( drc -> fdt ) ; \n drc -> fdt = NULL ; \n drc -> fdt_start_offset = 0 ; \n object_property_del ( OBJECT ( drc ) , \" \" , & error_abort ) ; \n drc -> dev = NULL ; \n }", "idx": 9226}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_narrow ( int size , TCGv dest , TCGv src ) \n { \n switch ( size ) { \n case 0 : gen_helper_neon_narrow_u8 ( dest , src ) ; break ; \n case 1 : gen_helper_neon_narrow_u16 ( dest , src ) ; break ; \n case 2 : tcg_gen_trunc_i64_i32 ( dest , src ) ; break ; \n default : abort ( ) ; \n } \n }", "idx": 9249}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "void spapr_dt_events ( void * fdt , uint32_t check_exception_irq ) \n { \n int event_sources , epow_events ; \n uint32_t irq_ranges [ ] = { cpu_to_be32 ( check_exception_irq ) , cpu_to_be32 ( 1 ) } ; \n uint32_t interrupts [ ] = { cpu_to_be32 ( check_exception_irq ) , 0 } ; \n _FDT ( event_sources = fdt_add_subnode ( fdt , 0 , \" \" ) ) ; \n _FDT ( fdt_setprop ( fdt , event_sources , \" \" , NULL , 0 ) ) ; \n _FDT ( fdt_setprop_cell ( fdt , event_sources , \" \" , 2 ) ) ; \n _FDT ( fdt_setprop ( fdt , event_sources , \" \" , \n irq_ranges , sizeof ( irq_ranges ) ) ) ; \n _FDT ( epow_events = fdt_add_subnode ( fdt , event_sources , \" \" ) ) ; \n _FDT ( fdt_setprop ( fdt , epow_events , \" \" , \n interrupts , sizeof ( interrupts ) ) ) ; \n }", "idx": 9307}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_capabilities ( MigrationCapabilityStatusList * params , \n Error * * errp ) \n { \n MigrationState * s = migrate_get_current ( ) ; \n MigrationCapabilityStatusList * cap ; \n if ( s -> state == MIG_STATE_ACTIVE || s -> state == MIG_STATE_SETUP ) { \n error_set ( errp , QERR_MIGRATION_ACTIVE ) ; \n return ; \n } \n for ( cap = params ; cap ; cap = cap -> next ) { \n s -> enabled_capabilities [ cap -> value -> capability ] = cap -> value -> state ; \n } \n }", "idx": 9334}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "void qmp_qmp_capabilities ( Error * * errp ) \n { \n cur_mon -> qmp . in_command_mode = true ; \n }", "idx": 9346}
{"project": "qemu", "commit_id": "a78b1299f1bbb9608e3e3a36a7f16cf700a2789d", "target": 0, "func": "static inline int handle_cpu_signal ( uintptr_t pc , unsigned long address , \n int is_write , sigset_t * old_set ) \n { \n CPUState * cpu = current_cpu ; \n CPUClass * cc ; \n int ret ; \n if ( helper_retaddr ) { \n pc = helper_retaddr ; \n } else { \n pc += GETPC_ADJ ; \n } \n if ( ! cpu || ! cpu -> running ) { \n printf ( \" \" \n PRIxPTR \" \\n \" , __func__ , pc ) ; \n abort ( ) ; \n } \n #if defined ( DEBUG_SIGNAL )  \n  \n  printf ( \" \\n \" , \n pc , address , is_write , * ( unsigned long * ) old_set ) ; \n #endif \n if ( is_write && h2g_valid ( address ) ) { \n switch ( page_unprotect ( h2g ( address ) , pc ) ) { \n case 0 : \n break ; \n case 1 : \n return 1 ; \n case 2 : \n helper_retaddr = 0 ; \n cpu_exit_tb_from_sighandler ( cpu , old_set ) ; \n default : \n g_assert_not_reached ( ) ; \n } \n } \n address = h2g_nocheck ( address ) ; \n cc = CPU_GET_CLASS ( cpu ) ; \n g_assert ( cc -> handle_mmu_fault ) ; \n ret = cc -> handle_mmu_fault ( cpu , address , is_write , MMU_USER_IDX ) ; \n if ( ret == 0 ) { \n return 1 ; \n } \n helper_retaddr = 0 ; \n if ( ret < 0 ) { \n return 0 ; \n } \n cpu_restore_state ( cpu , pc ) ; \n sigprocmask ( SIG_SETMASK , old_set , NULL ) ; \n cpu_loop_exit ( cpu ) ; \n return 1 ; \n }", "idx": 9375}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline bool media_is_cd ( SCSIDiskState * s ) \n { \n uint64_t nb_sectors ; \n if ( s -> qdev . type != TYPE_ROM ) { \n return false ; \n } \n if ( ! bdrv_is_inserted ( s -> qdev . conf . bs ) ) { \n return false ; \n } \n bdrv_get_geometry ( s -> qdev . conf . bs , & nb_sectors ) ; \n return nb_sectors <= CD_MAX_SECTORS ; \n }", "idx": 9390}
{"project": "qemu", "commit_id": "e2dd21e510ed66daeb4c5d58638450c1fb8c6fea", "target": 1, "func": "static void wait_for_serial ( const char * side ) \n { \n char * serialpath = g_strdup_printf ( \" \" , tmpfs , side ) ; \n FILE * serialfile = fopen ( serialpath , \" \" ) ; \n const char * arch = qtest_get_arch ( ) ; \n int started = ( strcmp ( side , \" \" ) == 0 && \n strcmp ( arch , \" \" ) == 0 ) ? 0 : 1 ; \n do { \n int readvalue = fgetc ( serialfile ) ; \n if ( ! started ) { \n switch ( readvalue ) { \n case ' ' : \n started = 1 ; \n break ; \n case EOF : \n fseek ( serialfile , 0 , SEEK_SET ) ; \n usleep ( 1000 ) ; \n break ; \n } \n continue ; \n } \n switch ( readvalue ) { \n case ' ' : \n break ; \n case ' ' : \n fclose ( serialfile ) ; \n g_free ( serialpath ) ; \n return ; \n case EOF : \n started = ( strcmp ( side , \" \" ) == 0 && \n strcmp ( arch , \" \" ) == 0 ) ? 0 : 1 ; \n fseek ( serialfile , 0 , SEEK_SET ) ; \n usleep ( 1000 ) ; \n break ; \n default : \n fprintf ( stderr , \" \\n \" , readvalue , side ) ; \n g_assert_not_reached ( ) ; \n } \n } while ( true ) ; \n }", "idx": 9441}
{"project": "qemu", "commit_id": "35f9304d925a5423c51bd2c83a81fa3cc2b6e680", "target": 1, "func": "static target_ulong remove_hpte ( CPUPPCState * env , target_ulong ptex , \n target_ulong avpn , \n target_ulong flags , \n target_ulong * vp , target_ulong * rp ) \n { \n uint8_t * hpte ; \n target_ulong v , r , rb ; \n if ( ( ptex * HASH_PTE_SIZE_64 ) & ~ env -> htab_mask ) { \n return REMOVE_PARM ; \n } \n hpte = env -> external_htab + ( ptex * HASH_PTE_SIZE_64 ) ; \n while ( ! lock_hpte ( hpte , HPTE_V_HVLOCK ) ) { \n assert ( 0 ) ; \n } \n v = ldq_p ( hpte ) ; \n r = ldq_p ( hpte + ( HASH_PTE_SIZE_64 / 2 ) ) ; \n if ( ( v & HPTE_V_VALID ) == 0 || \n ( ( flags & H_AVPN ) && ( v & ~ 0x7fULL ) != avpn ) || \n ( ( flags & H_ANDCOND ) && ( v & avpn ) != 0 ) ) { \n stq_p ( hpte , v & ~ HPTE_V_HVLOCK ) ; \n assert ( ! ( ldq_p ( hpte ) & HPTE_V_HVLOCK ) ) ; \n return REMOVE_NOT_FOUND ; \n } \n * vp = v & ~ HPTE_V_HVLOCK ; \n * rp = r ; \n stq_p ( hpte , 0 ) ; \n rb = compute_tlbie_rb ( v , r , ptex ) ; \n ppc_tlb_invalidate_one ( env , rb ) ; \n assert ( ! ( ldq_p ( hpte ) & HPTE_V_HVLOCK ) ) ; \n return REMOVE_SUCCESS ; \n }", "idx": 9495}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "SerialState * serial_init ( int base , qemu_irq irq , int baudbase , \n CharDriverState * chr ) \n { \n SerialState * s ; \n s = qemu_mallocz ( sizeof ( SerialState ) ) ; \n if ( ! s ) \n return NULL ; \n s -> irq = irq ; \n s -> baudbase = baudbase ; \n s -> tx_timer = qemu_new_timer ( vm_clock , serial_tx_done , s ) ; \n if ( ! s -> tx_timer ) \n return NULL ; \n qemu_register_reset ( serial_reset , s ) ; \n serial_reset ( s ) ; \n register_savevm ( \" \" , base , 2 , serial_save , serial_load , s ) ; \n register_ioport_write ( base , 8 , 1 , serial_ioport_write , s ) ; \n register_ioport_read ( base , 8 , 1 , serial_ioport_read , s ) ; \n s -> chr = chr ; \n qemu_chr_add_handlers ( chr , serial_can_receive1 , serial_receive1 , \n serial_event , s ) ; \n return s ; \n }", "idx": 9512}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void kvmclock_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n dc -> realize = kvmclock_realize ; \n dc -> vmsd = & kvmclock_vmsd ; \n dc -> props = kvmclock_properties ; \n }", "idx": 9514}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "static int64_t guest_file_handle_add ( FILE * fh , Error * * errp ) \n { \n GuestFileHandle * gfh ; \n int64_t handle ; \n handle = ga_get_fd_handle ( ga_state , errp ) ; \n if ( handle < 0 ) { \n return -1 ; \n } \n gfh = g_malloc0 ( sizeof ( GuestFileHandle ) ) ; \n gfh -> id = handle ; \n gfh -> fh = fh ; \n QTAILQ_INSERT_TAIL ( & guest_file_state . filehandles , gfh , next ) ; \n return handle ; \n }", "idx": 9523}
{"project": "qemu", "commit_id": "55e00a19b6dc8f20e5688866451bb4a60e649459", "target": 0, "func": "static void armv7m_nvic_class_init ( ObjectClass * klass , void * data ) \n { \n NVICClass * nc = NVIC_CLASS ( klass ) ; \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n SysBusDeviceClass * sdc = SYS_BUS_DEVICE_CLASS ( klass ) ; \n nc -> parent_reset = dc -> reset ; \n nc -> parent_init = sdc -> init ; \n sdc -> init = armv7m_nvic_init ; \n dc -> vmsd = & vmstate_nvic ; \n dc -> reset = armv7m_nvic_reset ; \n dc -> props = armv7m_nvic_properties ; \n }", "idx": 9579}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_qh_do_overlay ( EHCIQueue * q ) \n { \n int i ; \n int dtoggle ; \n int ping ; \n int eps ; \n int reload ; \n dtoggle = q -> qh . token & QTD_TOKEN_DTOGGLE ; \n ping = q -> qh . token & QTD_TOKEN_PING ; \n q -> qh . current_qtd = q -> qtdaddr ; \n q -> qh . next_qtd = q -> qtd . next ; \n q -> qh . altnext_qtd = q -> qtd . altnext ; \n q -> qh . token = q -> qtd . token ; \n eps = get_field ( q -> qh . epchar , QH_EPCHAR_EPS ) ; \n if ( eps == EHCI_QH_EPS_HIGH ) { \n q -> qh . token &= ~ QTD_TOKEN_PING ; \n q -> qh . token |= ping ; \n } \n reload = get_field ( q -> qh . epchar , QH_EPCHAR_RL ) ; \n set_field ( & q -> qh . altnext_qtd , reload , QH_ALTNEXT_NAKCNT ) ; \n for ( i = 0 ; i < 5 ; i ++ ) { \n q -> qh . bufptr [ i ] = q -> qtd . bufptr [ i ] ; \n } \n if ( ! ( q -> qh . epchar & QH_EPCHAR_DTC ) ) { \n q -> qh . token &= ~ QTD_TOKEN_DTOGGLE ; \n q -> qh . token |= dtoggle ; \n } \n q -> qh . bufptr [ 1 ] &= ~ BUFPTR_CPROGMASK_MASK ; \n q -> qh . bufptr [ 2 ] &= ~ BUFPTR_FRAMETAG_MASK ; \n put_dwords ( NLPTR_GET ( q -> qhaddr ) , ( uint32_t * ) & q -> qh , sizeof ( EHCIqh ) >> 2 ) ; \n return 0 ; \n }", "idx": 9583}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readw ( void * opaque , target_phys_addr_t addr ) \n { \n IntelHDAState * d = opaque ; \n const IntelHDAReg * reg = intel_hda_reg_find ( d , addr ) ; \n return intel_hda_reg_read ( d , reg , 0xffff ) ; \n }", "idx": 9585}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_ibm_read_pci_config ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n uint64_t buid ; \n uint32_t size , addr ; \n if ( ( nargs != 4 ) || ( nret != 2 ) ) { \n rtas_st ( rets , 0 , -1 ) ; \n return ; \n } \n buid = ( ( uint64_t ) rtas_ld ( args , 1 ) << 32 ) | rtas_ld ( args , 2 ) ; \n size = rtas_ld ( args , 3 ) ; \n addr = rtas_ld ( args , 0 ) ; \n finish_read_pci_config ( spapr , buid , addr , size , rets ) ; \n }", "idx": 9586}
{"project": "qemu", "commit_id": "5923f85fb82df7c8c60a89458a5ae856045e5ab1", "target": 1, "func": "static bool acpi_get_mcfg ( AcpiMcfgInfo * mcfg ) \n { \n Object * pci_host ; \n QObject * o ; \n pci_host = acpi_get_i386_pci_host ( ) ; \n g_assert ( pci_host ) ; \n o = object_property_get_qobject ( pci_host , PCIE_HOST_MCFG_BASE , NULL ) ; \n if ( ! o ) { \n return false ; \n } \n mcfg -> mcfg_base = qnum_get_int ( qobject_to_qnum ( o ) ) ; \n qobject_decref ( o ) ; \n o = object_property_get_qobject ( pci_host , PCIE_HOST_MCFG_SIZE , NULL ) ; \n assert ( o ) ; \n mcfg -> mcfg_size = qnum_get_int ( qobject_to_qnum ( o ) ) ; \n qobject_decref ( o ) ; \n return true ; \n }", "idx": 9611}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static void unassigned_mem_writel ( void * opaque , target_phys_addr_t addr , uint32_t val ) \n { \n #ifdef DEBUG_UNASSIGNED \n printf ( \" \" TARGET_FMT_plx \" \\n \" , addr , val ) ; \n #endif \n #if defined ( TARGET_ALPHA ) || defined ( TARGET_SPARC ) || defined ( TARGET_MICROBLAZE )  \n  \n  do_unassigned_access ( addr , 1 , 0 , 0 , 4 ) ; \n #endif \n }", "idx": 9613}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_utimensat ( FsContext * s , V9fsPath * fs_path , \n const struct timespec * buf ) \n { \n int retval ; \n retval = v9fs_request ( s -> private , T_UTIME , NULL , \" \" , \n fs_path , \n buf [ 0 ] . tv_sec , buf [ 0 ] . tv_nsec , \n buf [ 1 ] . tv_sec , buf [ 1 ] . tv_nsec ) ; \n if ( retval < 0 ) { \n errno = - retval ; \n } \n return retval ; \n }", "idx": 9642}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static int csrhci_write ( struct CharDriverState * chr , \n const uint8_t * buf , int len ) \n { \n struct csrhci_s * s = ( struct csrhci_s * ) chr -> opaque ; \n int plen = s -> in_len ; \n if ( ! s -> enable ) \n return 0 ; \n s -> in_len += len ; \n memcpy ( s -> inpkt + plen , buf , len ) ; \n while ( 1 ) { \n if ( s -> in_len >= 2 && plen < 2 ) \n s -> in_hdr = csrhci_header_len ( s -> inpkt ) + 1 ; \n if ( s -> in_len >= s -> in_hdr && plen < s -> in_hdr ) \n s -> in_data = csrhci_data_len ( s -> inpkt ) + s -> in_hdr ; \n if ( s -> in_len >= s -> in_data ) { \n csrhci_in_packet ( s , s -> inpkt ) ; \n memmove ( s -> inpkt , s -> inpkt + s -> in_len , s -> in_len - s -> in_data ) ; \n s -> in_len -= s -> in_data ; \n s -> in_hdr = INT_MAX ; \n s -> in_data = INT_MAX ; \n plen = 0 ; \n } else \n break ; \n } \n return len ; \n }", "idx": 9660}
{"project": "qemu", "commit_id": "4782a23b270ecbb9ce0ca6f3f1b60857a09cef0e", "target": 0, "func": "static void do_program_interrupt ( CPUS390XState * env ) \n { \n uint64_t mask , addr ; \n LowCore * lowcore ; \n hwaddr len = TARGET_PAGE_SIZE ; \n int ilen = env -> int_pgm_ilen ; \n switch ( ilen ) { \n case ILEN_LATER : \n ilen = get_ilen ( cpu_ldub_code ( env , env -> psw . addr ) ) ; \n break ; \n case ILEN_LATER_INC : \n ilen = get_ilen ( cpu_ldub_code ( env , env -> psw . addr ) ) ; \n env -> psw . addr += ilen ; \n break ; \n default : \n assert ( ilen == 2 || ilen == 4 || ilen == 6 ) ; \n } \n qemu_log_mask ( CPU_LOG_INT , \" \\n \" , \n __func__ , env -> int_pgm_code , ilen ) ; \n lowcore = cpu_physical_memory_map ( env -> psa , & len , 1 ) ; \n lowcore -> pgm_ilen = cpu_to_be16 ( ilen ) ; \n lowcore -> pgm_code = cpu_to_be16 ( env -> int_pgm_code ) ; \n lowcore -> program_old_psw . mask = cpu_to_be64 ( get_psw_mask ( env ) ) ; \n lowcore -> program_old_psw . addr = cpu_to_be64 ( env -> psw . addr ) ; \n mask = be64_to_cpu ( lowcore -> program_new_psw . mask ) ; \n addr = be64_to_cpu ( lowcore -> program_new_psw . addr ) ; \n cpu_physical_memory_unmap ( lowcore , len , 1 , len ) ; \n DPRINTF ( \" \" PRIx64 \" \" PRIx64 \" \\n \" , __func__ , \n env -> int_pgm_code , ilen , env -> psw . mask , \n env -> psw . addr ) ; \n load_psw ( env , mask , addr ) ; \n }", "idx": 9666}
{"project": "qemu", "commit_id": "29e179bc3f5e804ab58b975e65c91cb9cd287846", "target": 0, "func": "int get_physical_address ( CPUState * env , target_ulong * physical , \n int * prot , target_ulong address , \n int rw , int access_type ) \n { \n if ( ( address >= 0x80000000 && address < 0xc0000000 ) || \n address >= 0xe0000000 ) { \n if ( ! ( env -> sr & SR_MD ) \n && ( address < 0xe0000000 || address > 0xe4000000 ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n return ( rw & PAGE_WRITE ) ? MMU_DTLB_MISS_WRITE : \n MMU_DTLB_MISS_READ ; \n } \n * physical = address & 0x1FFFFFFF ; \n * prot = PAGE_READ | PAGE_WRITE ; \n return MMU_OK ; \n } \n if ( ! env -> mmucr & MMUCR_AT ) { \n * physical = address & 0x1FFFFFFF ; \n * prot = PAGE_READ | PAGE_WRITE ; \n return MMU_OK ; \n } \n return get_mmu_address ( env , physical , prot , address , rw , access_type ) ; \n }", "idx": 9669}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_fetch_data_kind ( void ) \n { \n if ( replay_file ) { \n if ( ! replay_has_unread_data ) { \n replay_data_kind = replay_get_byte ( ) ; \n if ( replay_data_kind == EVENT_INSTRUCTION ) { \n replay_state . instructions_count = replay_get_dword ( ) ; \n } \n replay_check_error ( ) ; \n replay_has_unread_data = 1 ; \n if ( replay_data_kind >= EVENT_COUNT ) { \n error_report ( \" \" , replay_data_kind ) ; \n exit ( 1 ) ; \n } \n } \n } \n }", "idx": 9699}
{"project": "qemu", "commit_id": "19d2b5e6ff7202c2bf45c547efa85ae6c2d76bbd", "target": 0, "func": "static void DMA_run ( void ) \n { \n struct dma_cont * d ; \n int icont , ichan ; \n int rearm = 0 ; \n static int running = 0 ; \n if ( running ) { \n rearm = 1 ; \n goto out ; \n } else { \n running = 1 ; \n } \n d = dma_controllers ; \n for ( icont = 0 ; icont < 2 ; icont ++ , d ++ ) { \n for ( ichan = 0 ; ichan < 4 ; ichan ++ ) { \n int mask ; \n mask = 1 << ichan ; \n if ( ( 0 == ( d -> mask & mask ) ) && ( 0 != ( d -> status & ( mask << 4 ) ) ) ) { \n channel_run ( icont , ichan ) ; \n rearm = 1 ; \n } \n } \n } \n running = 0 ; \n out : \n if ( rearm ) \n qemu_bh_schedule_idle ( dma_bh ) ; \n }", "idx": 9700}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline void reset_bit ( uint32_t * field , int bit ) \n { \n field [ bit >> 5 ] &= ~ ( 1 << ( bit & 0x1F ) ) ; \n }", "idx": 9712}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_aio_cancel_async ( BlockAIOCB * acb ) \n { \n if ( acb -> aiocb_info -> cancel_async ) { \n acb -> aiocb_info -> cancel_async ( acb ) ; \n } \n }", "idx": 9743}
{"project": "qemu", "commit_id": "2c0ef9f411ae6081efa9eca5b3eab2dbeee45a6c", "target": 0, "func": "Visitor * qapi_dealloc_get_visitor ( QapiDeallocVisitor * v ) \n { \n return & v -> visitor ; \n }", "idx": 9745}
{"project": "qemu", "commit_id": "fc9c0a9c4b2c07cf2b8683f2617af584f14c93e7", "target": 1, "func": "void block_job_sleep_ns ( BlockJob * job , QEMUClockType type , int64_t ns ) \n { \n assert ( job -> busy ) ; \n if ( block_job_is_cancelled ( job ) ) { \n return ; \n } \n job -> busy = false ; \n if ( ! block_job_should_pause ( job ) ) { \n co_aio_sleep_ns ( blk_get_aio_context ( job -> blk ) , type , ns ) ; \n } \n if ( block_job_should_pause ( job ) ) { \n qemu_coroutine_yield ( ) ; \n } \n job -> busy = true ; \n }", "idx": 9780}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_reset ( DeviceState * dev ) \n { \n ADBDevice * d = ADB_DEVICE ( dev ) ; \n MouseState * s = ADB_MOUSE ( dev ) ; \n d -> handler = 2 ; \n d -> devaddr = ADB_DEVID_MOUSE ; \n s -> last_buttons_state = s -> buttons_state = 0 ; \n s -> dx = s -> dy = s -> dz = 0 ; \n }", "idx": 9793}
{"project": "qemu", "commit_id": "f8a83245d9ec685bc6aa6173d6765fe03e20688f", "target": 1, "func": "static void raw_close ( BlockDriverState * bs ) \n { \n BDRVRawState * s = bs -> opaque ; \n if ( s -> fd >= 0 ) { \n close ( s -> fd ) ; \n s -> fd = -1 ; \n if ( s -> aligned_buf != NULL ) \n qemu_free ( s -> aligned_buf ) ; \n } \n }", "idx": 9795}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST ( simple_dict ) \n { \n int i ; \n struct { \n const char * encoded ; \n LiteralQObject decoded ; \n } test_cases [ ] = { \n { \n . encoded = \" \\\" \\\" \\\" \\\" \\\" \\\" \" , \n . decoded = QLIT_QDICT ( ( ( LiteralQDictEntry [ ] ) { \n { \" \" , QLIT_QINT ( 42 ) } , \n { \" \" , QLIT_QSTR ( \" \" ) } , \n { } \n } ) ) , \n } , { \n . encoded = \" \" , \n . decoded = QLIT_QDICT ( ( ( LiteralQDictEntry [ ] ) { \n { } \n } ) ) , \n } , { \n . encoded = \" \\\" \\\" \" , \n . decoded = QLIT_QDICT ( ( ( LiteralQDictEntry [ ] ) { \n { \" \" , QLIT_QINT ( 43 ) } , \n { } \n } ) ) , \n } , \n { } \n } ; \n for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { \n QObject * obj ; \n QString * str ; \n obj = qobject_from_json ( test_cases [ i ] . encoded ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QDICT ) ; \n fail_unless ( compare_litqobj_to_qobj ( & test_cases [ i ] . decoded , obj ) == 1 ) ; \n str = qobject_to_json ( obj ) ; \n qobject_decref ( obj ) ; \n obj = qobject_from_json ( qstring_get_str ( str ) ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QDICT ) ; \n fail_unless ( compare_litqobj_to_qobj ( & test_cases [ i ] . decoded , obj ) == 1 ) ; \n qobject_decref ( obj ) ; \n QDECREF ( str ) ; \n } \n }", "idx": 9860}
{"project": "qemu", "commit_id": "a0efbf16604770b9d805bcf210ec29942321134f", "target": 0, "func": "static void i440fx_pcihost_get_pci_hole64_end ( Object * obj , Visitor * v , \n const char * name , void * opaque , \n Error * * errp ) \n { \n PCIHostState * h = PCI_HOST_BRIDGE ( obj ) ; \n Range w64 ; \n pci_bus_get_w64_range ( h -> bus , & w64 ) ; \n visit_type_uint64 ( v , name , & w64 . end , errp ) ; \n }", "idx": 9861}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_stsch ( S390CPU * cpu , uint64_t reg1 , uint32_t ipb ) \n { \n int cssid , ssid , schid , m ; \n SubchDev * sch ; \n uint64_t addr ; \n int cc ; \n SCHIB schib ; \n CPUS390XState * env = & cpu -> env ; \n uint8_t ar ; \n addr = decode_basedisp_s ( env , ipb , & ar ) ; \n if ( addr & 3 ) { \n program_interrupt ( env , PGM_SPECIFICATION , 2 ) ; \n return ; \n } \n if ( ioinst_disassemble_sch_ident ( reg1 , & m , & cssid , & ssid , & schid ) ) { \n if ( ! s390_cpu_virt_mem_check_write ( cpu , addr , ar , sizeof ( schib ) ) ) { \n program_interrupt ( env , PGM_OPERAND , 2 ) ; \n } \n return ; \n } \n trace_ioinst_sch_id ( \" \" , cssid , ssid , schid ) ; \n sch = css_find_subch ( m , cssid , ssid , schid ) ; \n if ( sch ) { \n if ( css_subch_visible ( sch ) ) { \n css_do_stsch ( sch , & schib ) ; \n cc = 0 ; \n } else { \n cc = 3 ; \n } \n } else { \n if ( css_schid_final ( m , cssid , ssid , schid ) ) { \n cc = 3 ; \n } else { \n memset ( & schib , 0 , sizeof ( schib ) ) ; \n cc = 0 ; \n } \n } \n if ( cc != 3 ) { \n if ( s390_cpu_virt_mem_write ( cpu , addr , ar , & schib , \n sizeof ( schib ) ) != 0 ) { \n return ; \n } \n } else { \n if ( s390_cpu_virt_mem_check_write ( cpu , addr , ar , sizeof ( schib ) ) != 0 ) { \n return ; \n } \n } \n setcc ( cpu , cc ) ; \n }", "idx": 9866}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static void cow_close ( BlockDriverState * bs ) \n { \n }", "idx": 9872}
{"project": "qemu", "commit_id": "8daea510951dd309a44cea8de415c685c43851cf", "target": 1, "func": "void qdev_prop_set_drive ( DeviceState * dev , const char * name , \n BlockBackend * value , Error * * errp ) \n { \n object_property_set_str ( OBJECT ( dev ) , value ? blk_name ( value ) : \" \" , \n name , errp ) ; \n }", "idx": 9893}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_slirp_redir ( const char * redir_str ) \n { \n struct slirp_config_str * config ; \n if ( QTAILQ_EMPTY ( & slirp_stacks ) ) { \n config = g_malloc ( sizeof ( * config ) ) ; \n pstrcpy ( config -> str , sizeof ( config -> str ) , redir_str ) ; \n config -> flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY ; \n config -> next = slirp_configs ; \n slirp_configs = config ; \n return 0 ; \n } \n return slirp_hostfwd ( QTAILQ_FIRST ( & slirp_stacks ) , redir_str , 1 ) ; \n }", "idx": 9894}
{"project": "qemu", "commit_id": "b0b1d69079fcb9453f45aade9e9f6b71422147b0", "target": 1, "func": "static void kvm_invoke_set_guest_debug ( void * data ) \n { \n struct kvm_set_guest_debug_data * dbg_data = data ; \n CPUState * env = dbg_data -> env ; \n if ( env -> kvm_vcpu_dirty ) { \n kvm_arch_put_registers ( env ) ; \n env -> kvm_vcpu_dirty = 0 ; \n } \n dbg_data -> err = kvm_vcpu_ioctl ( env , KVM_SET_GUEST_DEBUG , & dbg_data -> dbg ) ; \n }", "idx": 9904}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static void bdrv_rw_em_cb ( void * opaque , int ret ) \n { \n * ( int * ) opaque = ret ; \n }", "idx": 9964}
{"project": "qemu", "commit_id": "9d6f106552fa5ad9e3128b5052863835526ba271", "target": 0, "func": "void ppc_set_compat ( PowerPCCPU * cpu , uint32_t compat_pvr , Error * * errp ) \n { \n int ret = 0 ; \n CPUPPCState * env = & cpu -> env ; \n PowerPCCPUClass * host_pcc ; \n cpu -> compat_pvr = compat_pvr ; \n switch ( compat_pvr ) { \n case CPU_POWERPC_LOGICAL_2_05 : \n env -> spr [ SPR_PCR ] = PCR_TM_DIS | PCR_VSX_DIS | PCR_COMPAT_2_07 | \n PCR_COMPAT_2_06 | PCR_COMPAT_2_05 ; \n break ; \n case CPU_POWERPC_LOGICAL_2_06 : \n case CPU_POWERPC_LOGICAL_2_06_PLUS : \n env -> spr [ SPR_PCR ] = PCR_TM_DIS | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 ; \n break ; \n case CPU_POWERPC_LOGICAL_2_07 : \n env -> spr [ SPR_PCR ] = PCR_COMPAT_2_07 ; \n break ; \n default : \n env -> spr [ SPR_PCR ] = 0 ; \n break ; \n } \n host_pcc = kvm_ppc_get_host_cpu_class ( ) ; \n if ( host_pcc ) { \n env -> spr [ SPR_PCR ] &= host_pcc -> pcr_mask ; \n } \n if ( kvm_enabled ( ) ) { \n ret = kvmppc_set_compat ( cpu , cpu -> compat_pvr ) ; \n if ( ret < 0 ) { \n error_setg_errno ( errp , - ret , \n \" \" ) ; \n } \n } \n }", "idx": 9969}
{"project": "qemu", "commit_id": "acf6e5f0962c4be670d4a93ede77423512521876", "target": 0, "func": "static coroutine_fn int sd_co_pdiscard ( BlockDriverState * bs , int64_t offset , \n int count ) \n { \n SheepdogAIOCB acb ; \n BDRVSheepdogState * s = bs -> opaque ; \n QEMUIOVector discard_iov ; \n struct iovec iov ; \n uint32_t zero = 0 ; \n if ( ! s -> discard_supported ) { \n return 0 ; \n } \n memset ( & discard_iov , 0 , sizeof ( discard_iov ) ) ; \n memset ( & iov , 0 , sizeof ( iov ) ) ; \n iov . iov_base = & zero ; \n iov . iov_len = sizeof ( zero ) ; \n discard_iov . iov = & iov ; \n discard_iov . niov = 1 ; \n if ( ! QEMU_IS_ALIGNED ( offset | count , BDRV_SECTOR_SIZE ) ) { \n return - ENOTSUP ; \n } \n sd_aio_setup ( & acb , s , & discard_iov , offset >> BDRV_SECTOR_BITS , \n count >> BDRV_SECTOR_BITS , AIOCB_DISCARD_OBJ ) ; \n retry : \n if ( check_overlapping_aiocb ( s , & acb ) ) { \n qemu_co_queue_wait ( & s -> overlapping_queue ) ; \n goto retry ; \n } \n sd_co_rw_vector ( & acb ) ; \n QLIST_REMOVE ( & acb , aiocb_siblings ) ; \n qemu_co_queue_restart_all ( & s -> overlapping_queue ) ; \n return acb . ret ; \n }", "idx": 10004}
{"project": "qemu", "commit_id": "880a7578381d1c7ed4d41c7599ae3cc06567a824", "target": 0, "func": "static void gdb_vm_stopped ( void * opaque , int reason ) \n { \n GDBState * s = opaque ; \n char buf [ 256 ] ; \n const char * type ; \n int ret ; \n if ( s -> state == RS_SYSCALL ) \n return ; \n cpu_single_step ( s -> env , 0 ) ; \n if ( reason == EXCP_DEBUG ) { \n if ( s -> env -> watchpoint_hit ) { \n switch ( s -> env -> watchpoint_hit -> flags & BP_MEM_ACCESS ) { \n case BP_MEM_READ : \n type = \" \" ; \n break ; \n case BP_MEM_ACCESS : \n type = \" \" ; \n break ; \n default : \n type = \" \" ; \n break ; \n } \n snprintf ( buf , sizeof ( buf ) , \" \" TARGET_FMT_lx \" \" , \n SIGTRAP , type , s -> env -> watchpoint_hit -> vaddr ) ; \n put_packet ( s , buf ) ; \n s -> env -> watchpoint_hit = NULL ; \n return ; \n } \n tb_flush ( s -> env ) ; \n ret = SIGTRAP ; \n } else if ( reason == EXCP_INTERRUPT ) { \n ret = SIGINT ; \n } else { \n ret = 0 ; \n } \n snprintf ( buf , sizeof ( buf ) , \" \" , ret ) ; \n put_packet ( s , buf ) ; \n }", "idx": 10013}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "void qemu_peer_set_offload ( NetClientState * nc , int csum , int tso4 , int tso6 , \n int ecn , int ufo ) \n { \n if ( ! nc -> peer || ! nc -> peer -> info -> set_offload ) { \n return ; \n } \n nc -> peer -> info -> set_offload ( nc -> peer , csum , tso4 , tso6 , ecn , ufo ) ; \n }", "idx": 10015}
{"project": "qemu", "commit_id": "071663dfc3b93e3f3e573d726cfb685fd25472fa", "target": 0, "func": "uint32_t helper_bcdsetsgn ( ppc_avr_t * r , ppc_avr_t * b , uint32_t ps ) \n { \n int i ; \n int invalid = 0 ; \n int sgnb = bcd_get_sgn ( b ) ; \n * r = * b ; \n bcd_put_digit ( r , bcd_preferred_sgn ( sgnb , ps ) , 0 ) ; \n for ( i = 1 ; i < 32 ; i ++ ) { \n bcd_get_digit ( b , i , & invalid ) ; \n if ( unlikely ( invalid ) ) { \n return CRF_SO ; \n } \n } \n return bcd_cmp_zero ( r ) ; \n }", "idx": 10018}
{"project": "qemu", "commit_id": "393a98924eb00df76231384b86652e1d5f964d67", "target": 0, "func": "uint32_t msix_bar_size ( PCIDevice * dev ) \n { \n return ( dev -> cap_present & QEMU_PCI_CAP_MSIX ) ? \n dev -> msix_bar_size : 0 ; \n }", "idx": 10020}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "VirtIODevice * virtio_blk_init ( DeviceState * dev , BlockConf * conf ) \n { \n VirtIOBlock * s ; \n int cylinders , heads , secs ; \n static int virtio_blk_id ; \n s = ( VirtIOBlock * ) virtio_common_init ( \" \" , VIRTIO_ID_BLOCK , \n sizeof ( struct virtio_blk_config ) , \n sizeof ( VirtIOBlock ) ) ; \n s -> vdev . get_config = virtio_blk_update_config ; \n s -> vdev . get_features = virtio_blk_get_features ; \n s -> vdev . reset = virtio_blk_reset ; \n s -> bs = conf -> dinfo -> bdrv ; \n s -> conf = conf ; \n s -> rq = NULL ; \n s -> sector_mask = ( s -> conf -> logical_block_size / BDRV_SECTOR_SIZE ) - 1 ; \n bdrv_guess_geometry ( s -> bs , & cylinders , & heads , & secs ) ; \n s -> vq = virtio_add_queue ( & s -> vdev , 128 , virtio_blk_handle_output ) ; \n qemu_add_vm_change_state_handler ( virtio_blk_dma_restart_cb , s ) ; \n register_savevm ( \" \" , virtio_blk_id ++ , 2 , \n virtio_blk_save , virtio_blk_load , s ) ; \n return & s -> vdev ; \n }", "idx": 10056}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "static bool e1000_has_rxbufs ( E1000State * s , size_t total_size ) \n { \n int bufs ; \n if ( total_size <= s -> rxbuf_size ) { \n return s -> mac_reg [ RDH ] != s -> mac_reg [ RDT ] || ! s -> check_rxov ; \n } \n if ( s -> mac_reg [ RDH ] < s -> mac_reg [ RDT ] ) { \n bufs = s -> mac_reg [ RDT ] - s -> mac_reg [ RDH ] ; \n } else if ( s -> mac_reg [ RDH ] > s -> mac_reg [ RDT ] || ! s -> check_rxov ) { \n bufs = s -> mac_reg [ RDLEN ] / sizeof ( struct e1000_rx_desc ) + \n s -> mac_reg [ RDT ] - s -> mac_reg [ RDH ] ; \n } else { \n return false ; \n } \n return total_size <= bufs * s -> rxbuf_size ; \n }", "idx": 10077}
{"project": "qemu", "commit_id": "d2164ad35c411d97abd2aa5c6f160283d215e214", "target": 1, "func": "static int get_uint8_equal ( QEMUFile * f , void * pv , size_t size , \n VMStateField * field ) \n { \n uint8_t * v = pv ; \n uint8_t v2 ; \n qemu_get_8s ( f , & v2 ) ; \n if ( * v == v2 ) { \n return 0 ; \n error_report ( \" \" , * v , v2 ) ; \n return - EINVAL ;", "idx": 10110}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_move ( ioreq_t * req ) \n { \n int i ; \n if ( ! req -> data_is_ptr ) { \n if ( req -> dir == IOREQ_READ ) { \n for ( i = 0 ; i < req -> count ; i ++ ) { \n read_phys_req_item ( req -> addr , req , i , & req -> data ) ; \n } \n } else if ( req -> dir == IOREQ_WRITE ) { \n for ( i = 0 ; i < req -> count ; i ++ ) { \n write_phys_req_item ( req -> addr , req , i , & req -> data ) ; \n } \n } \n } else { \n uint64_t tmp ; \n if ( req -> dir == IOREQ_READ ) { \n for ( i = 0 ; i < req -> count ; i ++ ) { \n read_phys_req_item ( req -> addr , req , i , & tmp ) ; \n write_phys_req_item ( req -> data , req , i , & tmp ) ; \n } \n } else if ( req -> dir == IOREQ_WRITE ) { \n for ( i = 0 ; i < req -> count ; i ++ ) { \n read_phys_req_item ( req -> data , req , i , & tmp ) ; \n write_phys_req_item ( req -> addr , req , i , & tmp ) ; \n } \n } \n } \n }", "idx": 10124}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "bool qemu_savevm_state_blocked ( Monitor * mon ) \n { \n SaveStateEntry * se ; \n QTAILQ_FOREACH ( se , & savevm_handlers , entry )  { \n if ( se -> no_migrate ) { \n monitor_printf ( mon , \" \\n \" , \n se -> idstr ) ; \n return true ; \n } \n } \n return false ; \n }", "idx": 10133}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_abso ( DisasContext * ctx ) \n { \n int l1 = gen_new_label ( ) ; \n int l2 = gen_new_label ( ) ; \n int l3 = gen_new_label ( ) ; \n tcg_gen_movi_tl ( cpu_ov , 0 ) ; \n tcg_gen_brcondi_tl ( TCG_COND_GE , cpu_gpr [ rA ( ctx -> opcode ) ] , 0 , l2 ) ; \n tcg_gen_brcondi_tl ( TCG_COND_NE , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x80000000 , l1 ) ; \n tcg_gen_movi_tl ( cpu_ov , 1 ) ; \n tcg_gen_movi_tl ( cpu_so , 1 ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_neg_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n tcg_gen_br ( l3 ) ; \n gen_set_label ( l2 ) ; \n tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n gen_set_label ( l3 ) ; \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx , cpu_gpr [ rD ( ctx -> opcode ) ] ) ; \n }", "idx": 10137}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState * sysbus_create_varargs ( const char * name , \n target_phys_addr_t addr , ... ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n va_list va ; \n qemu_irq irq ; \n int n ; \n dev = qdev_create ( NULL , name ) ; \n s = sysbus_from_qdev ( dev ) ; \n qdev_init ( dev ) ; \n if ( addr != ( target_phys_addr_t ) - 1 ) { \n sysbus_mmio_map ( s , 0 , addr ) ; \n } \n va_start ( va , addr ) ; \n n = 0 ; \n while ( 1 ) { \n irq = va_arg ( va , qemu_irq ) ; \n if ( ! irq ) { \n break ; \n } \n sysbus_connect_irq ( s , n , irq ) ; \n n ++ ; \n } \n return dev ; \n }", "idx": 10146}
{"project": "qemu", "commit_id": "2b584959ed300ddff4acba0d7554becad5f274fd", "target": 0, "func": "void bdrv_set_translation_hint ( BlockDriverState * bs , int translation ) \n { \n bs -> translation = translation ; \n }", "idx": 10187}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_preadv ( BlockDriverState * bs , uint64_t offset , \n uint64_t bytes , QEMUIOVector * qiov , \n int flags ) \n { \n BDRVRawState * s = bs -> opaque ; \n if ( offset > UINT64_MAX - s -> offset ) { \n return - EINVAL ; \n } \n offset += s -> offset ; \n BLKDBG_EVENT ( bs -> file , BLKDBG_READ_AIO ) ; \n return bdrv_co_preadv ( bs -> file , offset , bytes , qiov , flags ) ; \n }", "idx": 10193}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static bool balloon_stats_supported ( const VirtIOBalloon * s ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( s ) ; \n return vdev -> guest_features & ( 1 << VIRTIO_BALLOON_F_STATS_VQ ) ; \n }", "idx": 10212}
{"project": "qemu", "commit_id": "82258945ef2cc4a4ec7cdcef02e751bd30cb199f", "target": 1, "func": "static void pm_update_sci ( PIIX4PMState * s ) \n { \n int sci_level , pmsts ; \n int64_t expire_time ; \n pmsts = get_pmsts ( s ) ; \n sci_level = ( ( ( pmsts & s -> pmen ) & \n ( RTC_EN | PWRBTN_EN | GBL_EN | TMROF_EN ) ) != 0 ) ; \n qemu_set_irq ( s -> irq , sci_level ) ; \n if ( ( s -> pmen & TMROF_EN ) && ! ( pmsts & TMROF_EN ) ) { \n expire_time = muldiv64 ( s -> tmr_overflow_time , ticks_per_sec , PM_FREQ ) ; \n qemu_mod_timer ( s -> tmr_timer , expire_time ) ; \n s -> tmr_overflow_time += 0x800000 ; \n } else { \n qemu_del_timer ( s -> tmr_timer ) ; \n } \n }", "idx": 10215}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static void g364fb_init ( DeviceState * dev , G364State * s ) \n { \n s -> vram = g_malloc0 ( s -> vram_size ) ; \n s -> con = graphic_console_init ( g364fb_update_display , \n g364fb_invalidate_display , \n g364fb_screen_dump , NULL , s ) ; \n memory_region_init_io ( & s -> mem_ctrl , & g364fb_ctrl_ops , s , \" \" , 0x180000 ) ; \n memory_region_init_ram_ptr ( & s -> mem_vram , \" \" , \n s -> vram_size , s -> vram ) ; \n vmstate_register_ram ( & s -> mem_vram , dev ) ; \n memory_region_set_coalescing ( & s -> mem_vram ) ; \n }", "idx": 10239}
{"project": "qemu", "commit_id": "a8d411abac9347aadeac87687b8a3c9895ea0fd7", "target": 0, "func": "void helper_xssqrtqp ( CPUPPCState * env , uint32_t opcode ) \n { \n ppc_vsr_t xb ; \n ppc_vsr_t xt ; \n float_status tstat ; \n getVSR ( rB ( opcode ) + 32 , & xb , env ) ; \n memset ( & xt , 0 , sizeof ( xt ) ) ; \n helper_reset_fpstatus ( env ) ; \n if ( unlikely ( Rc ( opcode ) != 0 ) ) { \n abort ( ) ; \n } \n tstat = env -> fp_status ; \n set_float_exception_flags ( 0 , & tstat ) ; \n xt . f128 = float128_sqrt ( xb . f128 , & tstat ) ; \n env -> fp_status . float_exception_flags |= tstat . float_exception_flags ; \n if ( unlikely ( tstat . float_exception_flags & float_flag_invalid ) ) { \n if ( float128_is_signaling_nan ( xb . f128 , & tstat ) ) { \n float_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN , 1 ) ; \n xt . f128 = float128_snan_to_qnan ( xb . f128 ) ; \n } else if ( float128_is_quiet_nan ( xb . f128 , & tstat ) ) { \n xt . f128 = xb . f128 ; \n } else if ( float128_is_neg ( xb . f128 ) && ! float128_is_zero ( xb . f128 ) ) { \n float_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSQRT , 1 ) ; \n set_snan_bit_is_one ( 0 , & env -> fp_status ) ; \n xt . f128 = float128_default_nan ( & env -> fp_status ) ; \n } \n } \n helper_compute_fprf_float128 ( env , xt . f128 ) ; \n putVSR ( rD ( opcode ) + 32 , & xt , env ) ; \n float_check_status ( env ) ; \n }", "idx": 10264}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "static int is_dup_page ( uint8_t * page , uint8_t ch ) \n { \n uint32_t val = ch << 24 | ch << 16 | ch << 8 | ch ; \n uint32_t * array = ( uint32_t * ) page ; \n int i ; \n for ( i = 0 ; i < ( TARGET_PAGE_SIZE / 4 ) ; i ++ ) { \n if ( array [ i ] != val ) \n return 0 ; \n } \n return 1 ; \n }", "idx": 10274}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "func": "void qxl_log_command ( PCIQXLDevice * qxl , const char * ring , QXLCommandExt * ext ) \n { \n bool compat = ext -> flags & QXL_COMMAND_FLAG_COMPAT ; \n void * data ; \n if ( ! qxl -> cmdlog ) { \n return ; \n } \n fprintf ( stderr , \" \" PRId64 \" \" , qemu_get_clock_ns ( vm_clock ) , \n qxl -> id , ring ) ; \n fprintf ( stderr , \" \" PRIx64 \" \" , ext -> cmd . data , \n qxl_name ( qxl_type , ext -> cmd . type ) , \n compat ? \" \" : \" \" ) ; \n data = qxl_phys2virt ( qxl , ext -> cmd . data , ext -> group_id ) ; \n switch ( ext -> cmd . type ) { \n case QXL_CMD_DRAW : \n if ( ! compat ) { \n qxl_log_cmd_draw ( qxl , data , ext -> group_id ) ; \n } else { \n qxl_log_cmd_draw_compat ( qxl , data , ext -> group_id ) ; \n } \n break ; \n case QXL_CMD_SURFACE : \n qxl_log_cmd_surface ( qxl , data ) ; \n break ; \n case QXL_CMD_CURSOR : \n qxl_log_cmd_cursor ( qxl , data , ext -> group_id ) ; \n break ; \n } \n fprintf ( stderr , \" \\n \" ) ; \n }", "idx": 10283}
{"project": "qemu", "commit_id": "7dfbfc7927c1f7ab9f6910768ed6d966645b5866", "target": 0, "func": "int vnc_display_disable_login ( DisplayState * ds ) \n { \n VncDisplay * vs = ds ? ( VncDisplay * ) ds -> opaque : vnc_display ; \n if ( ! vs ) { \n return -1 ; \n } \n if ( vs -> password ) { \n g_free ( vs -> password ) ; \n } \n vs -> password = NULL ; \n vs -> auth = VNC_AUTH_VNC ; \n return 0 ; \n }", "idx": 10288}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void read_storage_element0_info ( SCLPDevice * sclp , SCCB * sccb ) \n { \n int i , assigned ; \n int subincrement_id = SCLP_STARTING_SUBINCREMENT_ID ; \n ReadStorageElementInfo * storage_info = ( ReadStorageElementInfo * ) sccb ; \n sclpMemoryHotplugDev * mhd = get_sclp_memory_hotplug_dev ( ) ; \n assert ( mhd ) ; \n if ( ( ram_size >> mhd -> increment_size ) >= 0x10000 ) { \n sccb -> h . response_code = cpu_to_be16 ( SCLP_RC_SCCB_BOUNDARY_VIOLATION ) ; \n return ; \n } \n storage_info -> max_id = cpu_to_be16 ( mhd -> standby_mem_size ? 1 : 0 ) ; \n assigned = ram_size >> mhd -> increment_size ; \n storage_info -> assigned = cpu_to_be16 ( assigned ) ; \n for ( i = 0 ; i < assigned ; i ++ ) { \n storage_info -> entries [ i ] = cpu_to_be32 ( subincrement_id ) ; \n subincrement_id += SCLP_INCREMENT_UNIT ; \n } \n sccb -> h . response_code = cpu_to_be16 ( SCLP_RC_NORMAL_READ_COMPLETION ) ; \n }", "idx": 10293}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_rx_pkt_attach_data ( struct NetRxPkt * pkt , const void * data , \n size_t len , bool strip_vlan ) \n { \n uint16_t tci = 0 ; \n uint16_t ploff ; \n assert ( pkt ) ; \n pkt -> vlan_stripped = false ; \n if ( strip_vlan ) { \n pkt -> vlan_stripped = eth_strip_vlan ( data , pkt -> ehdr_buf , & ploff , & tci ) ; \n } \n if ( pkt -> vlan_stripped ) { \n pkt -> vec [ 0 ] . iov_base = pkt -> ehdr_buf ; \n pkt -> vec [ 0 ] . iov_len = ploff - sizeof ( struct vlan_header ) ; \n pkt -> vec [ 1 ] . iov_base = ( uint8_t * ) data + ploff ; \n pkt -> vec [ 1 ] . iov_len = len - ploff ; \n pkt -> vec_len = 2 ; \n pkt -> tot_len = len - ploff + sizeof ( struct eth_header ) ; \n } else { \n pkt -> vec [ 0 ] . iov_base = ( void * ) data ; \n pkt -> vec [ 0 ] . iov_len = len ; \n pkt -> vec_len = 1 ; \n pkt -> tot_len = len ; \n } \n pkt -> tci = tci ; \n }", "idx": 10317}
{"project": "qemu", "commit_id": "95c318f5e1f88d7e5bcc6deac17330fd4806a2d3", "target": 1, "func": "static int subpage_register ( subpage_t * mmio , uint32_t start , uint32_t end , \n ram_addr_t memory , ram_addr_t region_offset ) \n { \n int idx , eidx ; \n if ( start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE ) \n return -1 ; \n idx = SUBPAGE_IDX ( start ) ; \n eidx = SUBPAGE_IDX ( end ) ; \n #if defined ( DEBUG_SUBPAGE )  \n  \n  printf ( \" \\n \" , __func__ , \n mmio , start , end , idx , eidx , memory ) ; \n #endif \n memory = ( memory >> IO_MEM_SHIFT ) & ( IO_MEM_NB_ENTRIES - 1 ) ; \n for ( ; idx <= eidx ; idx ++ ) { \n mmio -> sub_io_index [ idx ] = memory ; \n mmio -> region_offset [ idx ] = region_offset ; \n } \n return 0 ; \n }", "idx": 10349}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_null ( Visitor * v , const char * name , Error * * errp ) \n { \n QmpOutputVisitor * qov = to_qov ( v ) ; \n qmp_output_add_obj ( qov , name , qnull ( ) ) ; \n }", "idx": 10376}
{"project": "qemu", "commit_id": "463c534db516701ac732ac606c33c7101cf22e56", "target": 0, "func": "static void xhci_child_detach ( USBPort * uport , USBDevice * child ) \n { \n USBBus * bus = usb_bus_from_device ( child ) ; \n XHCIState * xhci = container_of ( bus , XHCIState , bus ) ; \n xhci_detach_slot ( xhci , uport ) ; \n }", "idx": 10383}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( addme ) \n { \n T1 = T0 ; \n T0 += xer_ca + ( -1 ) ; \n if ( T1 != 0 ) \n xer_ca = 1 ; \n RETURN ( ) ; \n }", "idx": 10389}
{"project": "qemu", "commit_id": "8ce1ee4618f4a557959f5a5731f6726b30416df5", "target": 1, "func": "GuestMemoryBlockInfo * qmp_guest_get_memory_block_info ( Error * * errp ) \n { \n Error * local_err = NULL ; \n char * dirpath ; \n int dirfd ; \n char * buf ; \n GuestMemoryBlockInfo * info ; \n dirpath = g_strdup_printf ( \" \" ) ; \n dirfd = open ( dirpath , O_RDONLY | O_DIRECTORY ) ; \n if ( dirfd == -1 ) { \n error_setg_errno ( errp , errno , \" \\\" \\\" \" , dirpath ) ; \n g_free ( dirpath ) ; \n return NULL ; \n } \n g_free ( dirpath ) ; \n buf = g_malloc0 ( 20 ) ; \n ga_read_sysfs_file ( dirfd , \" \" , buf , 20 , & local_err ) ; \n if ( local_err ) { \n g_free ( buf ) ; \n error_propagate ( errp , local_err ) ; \n return NULL ; \n } \n info = g_new0 ( GuestMemoryBlockInfo , 1 ) ; \n info -> size = strtol ( buf , NULL , 16 ) ; \n g_free ( buf ) ; \n return info ; \n }", "idx": 10409}
{"project": "qemu", "commit_id": "f76f665547f4a954a2c83552a88816fc2a316be0", "target": 1, "func": "static int virtio_balloon_init_pci ( PCIDevice * pci_dev ) \n { \n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ; \n VirtIODevice * vdev ; \n vdev = virtio_balloon_init ( & pci_dev -> qdev ) ; \n virtio_init_pci ( proxy , vdev ) ; \n return 0 ; ", "idx": 10422}
{"project": "qemu", "commit_id": "1104d83c726d2b20f9cec7b99ab3570a2fdbd46d", "target": 1, "func": "int nbd_client_co_pdiscard ( BlockDriverState * bs , int64_t offset , int bytes ) \n { \n NBDClientSession * client = nbd_get_client_session ( bs ) ; \n NBDRequest request = { \n . type = NBD_CMD_TRIM , \n . from = offset , \n . len = bytes , \n } ; \n if ( ! ( client -> info . flags & NBD_FLAG_SEND_TRIM ) ) { \n return 0 ; \n } \n return nbd_co_request ( bs , & request , NULL ) ; \n }", "idx": 10462}
{"project": "qemu", "commit_id": "fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa", "target": 0, "func": "static void vnc_disconnect_finish ( VncState * vs ) \n { \n if ( vs -> input . buffer ) qemu_free ( vs -> input . buffer ) ; \n if ( vs -> output . buffer ) qemu_free ( vs -> output . buffer ) ; \n #ifdef CONFIG_VNC_TLS \n vnc_tls_client_cleanup ( vs ) ; \n #endif \n #ifdef CONFIG_VNC_SASL \n vnc_sasl_client_cleanup ( vs ) ; \n #endif \n audio_del ( vs ) ; \n VncState * p , * parent = NULL ; \n for ( p = vs -> vd -> clients ; p != NULL ; p = p -> next ) { \n if ( p == vs ) { \n if ( parent ) \n parent -> next = p -> next ; \n else \n vs -> vd -> clients = p -> next ; \n break ; \n } \n parent = p ; \n } \n if ( ! vs -> vd -> clients ) \n dcl -> idle = 1 ; \n vnc_remove_timer ( vs -> vd ) ; \n qemu_free ( vs ) ; \n }", "idx": 10494}
{"project": "qemu", "commit_id": "e6908bfe8e07f2b452e78e677da1b45b1c0f6829", "target": 1, "func": "static void set_pixel_format ( VncState * vs , \n int bits_per_pixel , int depth , \n int big_endian_flag , int true_color_flag , \n int red_max , int green_max , int blue_max , \n int red_shift , int green_shift , int blue_shift ) \n { \n if ( ! true_color_flag ) { \n vs -> client_pf . rmax = red_max ; \n vs -> client_pf . rbits = hweight_long ( red_max ) ; \n vs -> client_pf . rshift = red_shift ; \n vs -> client_pf . rmask = red_max << red_shift ; \n vs -> client_pf . gmax = green_max ; \n vs -> client_pf . gbits = hweight_long ( green_max ) ; \n vs -> client_pf . gshift = green_shift ; \n vs -> client_pf . gmask = green_max << green_shift ; \n vs -> client_pf . bmax = blue_max ; \n vs -> client_pf . bbits = hweight_long ( blue_max ) ; \n vs -> client_pf . bshift = blue_shift ; \n vs -> client_pf . bmask = blue_max << blue_shift ; \n vs -> client_pf . bits_per_pixel = bits_per_pixel ; \n vs -> client_pf . bytes_per_pixel = bits_per_pixel / 8 ; \n vs -> client_pf . depth = bits_per_pixel == 32 ? 24 : bits_per_pixel ; \n vs -> client_be = big_endian_flag ; \n set_pixel_conversion ( vs ) ; \n graphic_hw_invalidate ( NULL ) ; \n graphic_hw_update ( NULL ) ;", "idx": 10501}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint8_t qpci_pc_config_readb ( QPCIBus * bus , int devfn , uint8_t offset ) \n { \n outl ( 0xcf8 , ( 1 << 31 ) | ( devfn << 8 ) | offset ) ; \n return inb ( 0xcfc ) ; \n }", "idx": 10522}
{"project": "qemu", "commit_id": "28143b409f698210d85165ca518235ac7e7c5ac5", "target": 0, "func": "int kvm_has_xcrs ( void ) \n { \n return kvm_state -> xcrs ; \n }", "idx": 10575}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bl ( TCGv dst , TCGv_i32 src ) \n { \n gen_mov_reg_V ( cpu_tmp0 , src ) ; \n gen_mov_reg_N ( dst , src ) ; \n tcg_gen_xor_tl ( dst , dst , cpu_tmp0 ) ; \n }", "idx": 10579}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tilegx_cpu_initfn ( Object * obj ) \n { \n CPUState * cs = CPU ( obj ) ; \n TileGXCPU * cpu = TILEGX_CPU ( obj ) ; \n CPUTLGState * env = & cpu -> env ; \n static bool tcg_initialized ; \n cs -> env_ptr = env ; \n cpu_exec_init ( cs , & error_abort ) ; \n if ( tcg_enabled ( ) && ! tcg_initialized ) { \n tcg_initialized = true ; \n tilegx_tcg_init ( ) ; \n } \n }", "idx": 10590}
{"project": "qemu", "commit_id": "df46189412567906312684eb72ba87c6a86a4cdb", "target": 1, "func": "getouraddr ( void ) \n { \n char buff [ 256 ] ; \n struct hostent * he = NULL ; \n if ( gethostname ( buff , 256 ) == 0 ) \n he = gethostbyname ( buff ) ; \n if ( he ) \n our_addr = * ( struct in_addr * ) he -> h_addr ; \n if ( our_addr . s_addr == 0 ) \n our_addr . s_addr = loopback_addr . s_addr ; \n }", "idx": 10592}
{"project": "qemu", "commit_id": "249127d0dfeb2cf5e24d9353b6d54c91c1666ddc", "target": 1, "func": "static void spapr_cpu_core_realize_child ( Object * child , Error * * errp ) \n { \n Error * local_err = NULL ; \n sPAPRMachineState * spapr = SPAPR_MACHINE ( qdev_get_machine ( ) ) ; \n CPUState * cs = CPU ( child ) ; \n PowerPCCPU * cpu = POWERPC_CPU ( cs ) ; \n Object * obj ; \n obj = object_new ( spapr -> icp_type ) ; \n object_property_add_child ( OBJECT ( cpu ) , \" \" , obj , NULL ) ; \n object_property_add_const_link ( obj , \" \" , OBJECT ( spapr ) , & error_abort ) ; \n object_property_set_bool ( obj , true , \" \" , & local_err ) ; \n if ( local_err ) { \n goto error ; \n } \n object_property_set_bool ( child , true , \" \" , & local_err ) ; \n if ( local_err ) { \n goto error ; \n } \n spapr_cpu_init ( spapr , cpu , & local_err ) ; \n if ( local_err ) { \n goto error ; \n } \n xics_cpu_setup ( XICS_FABRIC ( spapr ) , cpu , ICP ( obj ) ) ; \n return ; \n error : \n object_unparent ( obj ) ; \n error_propagate ( errp , local_err ) ; \n }", "idx": 10599}
{"project": "qemu", "commit_id": "90527d2a8bb08ca5b4774eacfdd6b8fe9671c077", "target": 1, "func": "static int get_real_id ( const char * devpath , const char * idname , uint16_t * val ) \n { \n FILE * f ; \n char name [ 128 ] ; \n long id ; \n snprintf ( name , sizeof ( name ) , \" \" , devpath , idname ) ; \n f = fopen ( name , \" \" ) ; \n if ( f == NULL ) { \n error_report ( \" \" , __func__ , name ) ; \n return -1 ; \n } \n if ( fscanf ( f , \" \\n \" , & id ) == 1 ) { \n * val = id ; \n } else { \n return -1 ; \n } \n return 0 ; \n }", "idx": 10611}
{"project": "qemu", "commit_id": "dfda68377e20943f474505e75238cb96bc6874bf", "target": 1, "func": "static int get_S2prot ( CPUARMState * env , int s2ap , int xn ) \n { \n int prot = 0 ; \n if ( s2ap & 1 ) { \n prot |= PAGE_READ ; \n } \n if ( s2ap & 2 ) { \n prot |= PAGE_WRITE ; \n } \n if ( ! xn ) { \n prot |= PAGE_EXEC ; \n } \n return prot ; \n }", "idx": 10679}
{"project": "qemu", "commit_id": "c4523aae0664aecaa366d45e3d0f3d810ca33062", "target": 1, "func": "void qvirtio_pci_foreach ( QPCIBus * bus , uint16_t device_type , \n void ( * func ) ( QVirtioDevice * d , void * data ) , void * data ) \n { \n QVirtioPCIForeachData d = { . func = func , \n . device_type = device_type , \n . user_data = data } ; \n qpci_device_foreach ( bus , PCI_VENDOR_ID_REDHAT_QUMRANET , -1 , \n qvirtio_pci_foreach_callback , & d ) ; \n }", "idx": 10683}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_slbmfee ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n return ; \n } \n gen_helper_load_slb_esid ( cpu_gpr [ rS ( ctx -> opcode ) ] , cpu_env , \n cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n #endif \n }", "idx": 10685}
{"project": "qemu", "commit_id": "4096974e1885913dfe2931863be47bd35b266521", "target": 1, "func": "static int qcow2_make_empty ( BlockDriverState * bs ) \n { \n BDRVQcow2State * s = bs -> opaque ; \n uint64_t offset , end_offset ; \n int step = QEMU_ALIGN_DOWN ( INT_MAX , s -> cluster_size ) ; \n int l1_clusters , ret = 0 ; \n l1_clusters = DIV_ROUND_UP ( s -> l1_size , s -> cluster_size / sizeof ( uint64_t ) ) ; \n if ( s -> qcow_version >= 3 && ! s -> snapshots && \n 3 + l1_clusters <= s -> refcount_block_size && \n s -> crypt_method_header != QCOW_CRYPT_LUKS ) { \n return make_completely_empty ( bs ) ; \n } \n end_offset = bs -> total_sectors * BDRV_SECTOR_SIZE ; \n for ( offset = 0 ; offset < end_offset ; offset += step ) { \n ret = qcow2_cluster_discard ( bs , offset , MIN ( step , end_offset - offset ) , \n QCOW2_DISCARD_SNAPSHOT , true ) ; \n if ( ret < 0 ) { \n break ; \n } \n } \n return ret ; \n }", "idx": 10692}
{"project": "qemu", "commit_id": "2a7e6857cd3178d705a49c4adde2f3af26ed3ae1", "target": 0, "func": "static VncBasicInfoList * qmp_query_server_entry ( QIOChannelSocket * ioc , \n bool websocket , \n VncBasicInfoList * prev ) \n { \n VncBasicInfoList * list ; \n VncBasicInfo * info ; \n Error * err = NULL ; \n SocketAddress * addr ; \n addr = qio_channel_socket_get_local_address ( ioc , & err ) ; \n if ( ! addr ) { \n error_free ( err ) ; \n return prev ; \n } \n info = g_new0 ( VncBasicInfo , 1 ) ; \n vnc_init_basic_info ( addr , info , & err ) ; \n qapi_free_SocketAddress ( addr ) ; \n if ( err ) { \n qapi_free_VncBasicInfo ( info ) ; \n error_free ( err ) ; \n return prev ; \n } \n info -> websocket = websocket ; \n list = g_new0 ( VncBasicInfoList , 1 ) ; \n list -> value = info ; \n list -> next = prev ; \n return list ; \n }", "idx": 10722}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "uint32_t HELPER ( get_cp_reg ) ( CPUARMState * env , void * rip ) \n { \n const ARMCPRegInfo * ri = rip ; \n return ri -> readfn ( env , ri ) ; \n }", "idx": 10728}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static NetSocketState * net_socket_fd_init_dgram ( VLANState * vlan , int fd , \n int is_connected ) \n { \n struct sockaddr_in saddr ; \n int newfd ; \n socklen_t saddr_len ; \n NetSocketState * s ; \n if ( is_connected ) { \n if ( getsockname ( fd , ( struct sockaddr * ) & saddr , & saddr_len ) == 0 ) { \n if ( saddr . sin_addr . s_addr == 0 ) { \n fprintf ( stderr , \" \\n \" , \n fd ) ; \n return NULL ; \n } \n newfd = net_socket_mcast_create ( & saddr ) ; \n if ( newfd < 0 ) { \n close ( fd ) ; \n return NULL ; \n } \n dup2 ( newfd , fd ) ; \n close ( newfd ) ; \n } else { \n fprintf ( stderr , \" \\n \" , \n fd , strerror ( errno ) ) ; \n return NULL ; \n } \n } \n s = qemu_mallocz ( sizeof ( NetSocketState ) ) ; \n if ( ! s ) \n return NULL ; \n s -> fd = fd ; \n s -> vc = qemu_new_vlan_client ( vlan , net_socket_receive_dgram , s ) ; \n qemu_set_fd_handler ( s -> fd , net_socket_send_dgram , NULL , s ) ; \n if ( is_connected ) s -> dgram_dst = saddr ; \n snprintf ( s -> vc -> info_str , sizeof ( s -> vc -> info_str ) , \n \" \" , \n fd , is_connected ? \" \" : \" \" , \n inet_ntoa ( saddr . sin_addr ) , ntohs ( saddr . sin_port ) ) ; \n return s ; \n }", "idx": 10729}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint64_equal ( QEMUFile * f , void * pv , size_t size ) \n { \n uint64_t * v = pv ; \n uint64_t v2 ; \n qemu_get_be64s ( f , & v2 ) ; \n if ( * v == v2 ) { \n return 0 ; \n } \n return - EINVAL ; \n }", "idx": 10803}
{"project": "qemu", "commit_id": "82a93a1d307064f35c363f79b04b0a0149ac53d9", "target": 1, "func": "void spapr_drc_detach ( sPAPRDRConnector * drc , DeviceState * d , Error * * errp ) \n { \n trace_spapr_drc_detach ( spapr_drc_index ( drc ) ) ; \n if ( drc -> isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED ) { \n trace_spapr_drc_awaiting_isolated ( spapr_drc_index ( drc ) ) ; \n drc -> awaiting_release = true ; \n return ; \n } \n if ( spapr_drc_type ( drc ) != SPAPR_DR_CONNECTOR_TYPE_PCI && \n drc -> allocation_state != SPAPR_DR_ALLOCATION_STATE_UNUSABLE ) { \n trace_spapr_drc_awaiting_unusable ( spapr_drc_index ( drc ) ) ; \n drc -> awaiting_release = true ; \n return ; \n } \n if ( drc -> awaiting_allocation ) { \n drc -> awaiting_release = true ; \n trace_spapr_drc_awaiting_allocation ( spapr_drc_index ( drc ) ) ; \n return ; \n } \n spapr_drc_release ( drc ) ; \n }", "idx": 10813}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_set_log_base ( struct vhost_dev * dev , uint64_t base , \n struct vhost_log * log ) \n { \n int fds [ VHOST_MEMORY_MAX_NREGIONS ] ; \n size_t fd_num = 0 ; \n bool shmfd = virtio_has_feature ( dev -> protocol_features , \n VHOST_USER_PROTOCOL_F_LOG_SHMFD ) ; \n VhostUserMsg msg = { \n . request = VHOST_USER_SET_LOG_BASE , \n . flags = VHOST_USER_VERSION , \n . u64 = base , \n . size = sizeof ( m . u64 ) , \n } ; \n if ( shmfd && log -> fd != -1 ) { \n fds [ fd_num ++ ] = log -> fd ; \n } \n vhost_user_write ( dev , & msg , fds , fd_num ) ; \n if ( shmfd ) { \n msg . size = 0 ; \n if ( vhost_user_read ( dev , & msg ) < 0 ) { \n return 0 ; \n } \n if ( msg . request != VHOST_USER_SET_LOG_BASE ) { \n error_report ( \" \" \n \" \" , \n VHOST_USER_SET_LOG_BASE , msg . request ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 10815}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void * vmstate_base_addr ( void * opaque , VMStateField * field , bool alloc ) \n { \n void * base_addr = opaque + field -> offset ; \n if ( field -> flags & VMS_POINTER ) { \n if ( alloc && ( field -> flags & VMS_ALLOC ) ) { \n gsize size = 0 ; \n if ( field -> flags & VMS_VBUFFER ) { \n size = vmstate_size ( opaque , field ) ; \n } else { \n int n_elems = vmstate_n_elems ( opaque , field ) ; \n if ( n_elems ) { \n size = n_elems * field -> size ; \n } \n } \n if ( size ) { \n * ( ( void * * ) base_addr + field -> start ) = g_malloc ( size ) ; \n } \n } \n base_addr = * ( void * * ) base_addr + field -> start ; \n } \n return base_addr ; \n }", "idx": 10820}
{"project": "qemu", "commit_id": "4fa62005d0a85df9bb14ea9f53109d7c5f66eeb9", "target": 1, "func": "static int coroutine_fn v9fs_complete_renameat ( V9fsPDU * pdu , int32_t olddirfid , \n V9fsString * old_name , \n int32_t newdirfid , \n V9fsString * new_name ) \n { \n int err = 0 ; \n V9fsState * s = pdu -> s ; \n V9fsFidState * newdirfidp = NULL , * olddirfidp = NULL ; \n olddirfidp = get_fid ( pdu , olddirfid ) ; \n if ( olddirfidp == NULL ) { \n err = - ENOENT ; \n goto out ; \n } \n if ( newdirfid != -1 ) { \n newdirfidp = get_fid ( pdu , newdirfid ) ; \n if ( newdirfidp == NULL ) { \n err = - ENOENT ; \n goto out ; \n } \n } else { \n newdirfidp = get_fid ( pdu , olddirfid ) ; \n } \n err = v9fs_co_renameat ( pdu , & olddirfidp -> path , old_name , \n & newdirfidp -> path , new_name ) ; \n if ( err < 0 ) { \n goto out ; \n } \n if ( s -> ctx . export_flags & V9FS_PATHNAME_FSCONTEXT ) { \n v9fs_fix_fid_paths ( pdu , & olddirfidp -> path , old_name , \n & newdirfidp -> path , new_name ) ; \n } \n out : \n if ( olddirfidp ) { \n put_fid ( pdu , olddirfidp ) ; \n } \n if ( newdirfidp ) { \n put_fid ( pdu , newdirfidp ) ; \n } \n return err ; \n }", "idx": 10860}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_set_eeh_option ( PowerPCCPU * cpu , \n sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , uint32_t nret , \n target_ulong rets ) \n { \n sPAPRPHBState * sphb ; \n sPAPRPHBClass * spc ; \n uint32_t addr , option ; \n uint64_t buid ; \n int ret ; \n if ( ( nargs != 4 ) || ( nret != 1 ) ) { \n goto param_error_exit ; \n } \n buid = ( ( uint64_t ) rtas_ld ( args , 1 ) << 32 ) | rtas_ld ( args , 2 ) ; \n addr = rtas_ld ( args , 0 ) ; \n option = rtas_ld ( args , 3 ) ; \n sphb = find_phb ( spapr , buid ) ; \n if ( ! sphb ) { \n goto param_error_exit ; \n } \n spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS ( sphb ) ; \n if ( ! spc -> eeh_set_option ) { \n goto param_error_exit ; \n } \n ret = spc -> eeh_set_option ( sphb , addr , option ) ; \n rtas_st ( rets , 0 , ret ) ; \n return ; \n param_error_exit : \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n }", "idx": 10889}
{"project": "qemu", "commit_id": "9d40cd8a68cfc7606f4548cc9e812bab15c6dc28", "target": 0, "func": "static bool nvic_user_access_ok ( NVICState * s , hwaddr offset ) \n { \n switch ( offset ) { \n case 0xf00 : \n return s -> cpu -> env . v7m . ccr & R_V7M_CCR_USERSETMPEND_MASK ; \n default : \n return false ; \n } \n }", "idx": 10897}
{"project": "qemu", "commit_id": "2a62914bd8209d97e918f30f0de74bec2bf622c4", "target": 0, "func": "static int64_t cpu_get_icount_locked ( void ) \n { \n int64_t icount ; \n CPUState * cpu = current_cpu ; \n icount = timers_state . qemu_icount ; \n if ( cpu ) { \n if ( ! cpu_can_do_io ( cpu ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n } \n icount -= ( cpu -> icount_decr . u16 . low + cpu -> icount_extra ) ; \n } \n return timers_state . qemu_icount_bias + cpu_icount_to_ns ( icount ) ; \n }", "idx": 10932}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_start ( CPUState * cs , run_on_cpu_data arg ) \n { \n S390CPU * cpu = S390_CPU ( cs ) ; \n SigpInfo * si = arg . host_ptr ; \n if ( s390_cpu_get_state ( cpu ) != CPU_STATE_STOPPED ) { \n si -> cc = SIGP_CC_ORDER_CODE_ACCEPTED ; \n return ; \n } \n s390_cpu_set_state ( CPU_STATE_OPERATING , cpu ) ; \n si -> cc = SIGP_CC_ORDER_CODE_ACCEPTED ; \n }", "idx": 10938}
{"project": "qemu", "commit_id": "2563c9c6b8670400c48e562034b321a7cf3d9a85", "target": 1, "func": "static ssize_t drop_sync ( QIOChannel * ioc , size_t size ) \n { \n ssize_t ret = 0 ; \n char small [ 1024 ] ; \n char * buffer ; \n buffer = sizeof ( small ) < size ? small : g_malloc ( MIN ( 65536 , size ) ) ; \n while ( size > 0 ) { \n ssize_t count = read_sync ( ioc , buffer , MIN ( 65536 , size ) ) ; \n if ( count <= 0 ) { \n goto cleanup ; \n } \n assert ( count <= size ) ; \n size -= count ; \n ret += count ; \n } \n cleanup : \n if ( buffer != small ) { \n g_free ( buffer ) ; \n } \n return ret ; \n }", "idx": 10964}
{"project": "qemu", "commit_id": "262a69f4282e44426c7a132138581d400053e0a1", "target": 1, "func": "void * qemu_get_virtqueue_element ( VirtIODevice * vdev , QEMUFile * f , size_t sz ) \n { \n VirtQueueElement * elem ; \n VirtQueueElementOld data ; \n int i ; \n qemu_get_buffer ( f , ( uint8_t * ) & data , sizeof ( VirtQueueElementOld ) ) ; \n #ifdef NDEBUG \n #error  building with NDEBUG is not supported  \n  \n  #endif \n assert ( ARRAY_SIZE ( data . in_addr ) >= data . in_num ) ; \n assert ( ARRAY_SIZE ( data . out_addr ) >= data . out_num ) ; \n elem = virtqueue_alloc_element ( sz , data . out_num , data . in_num ) ; \n elem -> index = data . index ; \n for ( i = 0 ; i < elem -> in_num ; i ++ ) { \n elem -> in_addr [ i ] = data . in_addr [ i ] ; \n } \n for ( i = 0 ; i < elem -> out_num ; i ++ ) { \n elem -> out_addr [ i ] = data . out_addr [ i ] ; \n } \n for ( i = 0 ; i < elem -> in_num ; i ++ ) { \n elem -> in_sg [ i ] . iov_base = 0 ; \n elem -> in_sg [ i ] . iov_len = data . in_sg [ i ] . iov_len ; \n } \n for ( i = 0 ; i < elem -> out_num ; i ++ ) { \n elem -> out_sg [ i ] . iov_base = 0 ; \n elem -> out_sg [ i ] . iov_len = data . out_sg [ i ] . iov_len ; \n } \n virtqueue_map ( vdev , elem ) ; \n return elem ; \n }", "idx": 10965}
{"project": "qemu", "commit_id": "c4237dfa635900e4d1cdc6038d5efe3507f45f0c", "target": 1, "func": "static void mirror_read_complete ( void * opaque , int ret ) \n { \n MirrorOp * op = opaque ; \n MirrorBlockJob * s = op -> s ; \n if ( ret < 0 ) { \n BlockDriverState * source = s -> common . bs ; \n BlockErrorAction action ; \n bdrv_set_dirty ( source , op -> sector_num , op -> nb_sectors ) ; \n action = mirror_error_action ( s , true , - ret ) ; \n if ( action == BLOCK_ERROR_ACTION_REPORT && s -> ret >= 0 ) { \n s -> ret = ret ; \n } \n mirror_iteration_done ( op , ret ) ; \n return ; \n } \n bdrv_aio_writev ( s -> target , op -> sector_num , & op -> qiov , op -> nb_sectors , \n mirror_write_complete , op ) ; \n }", "idx": 10970}
{"project": "qemu", "commit_id": "e268ca52328eb0460ae0d10b7f4313a63d5b000c", "target": 0, "func": "static BlockDriverAIOCB * qcow_aio_writev ( BlockDriverState * bs , \n int64_t sector_num , QEMUIOVector * qiov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n BDRVQcowState * s = bs -> opaque ; \n QCowAIOCB * acb ; \n s -> cluster_cache_offset = -1 ; \n acb = qemu_aio_get ( bs , cb , opaque ) ; \n if ( ! acb ) \n return NULL ; \n acb -> hd_aiocb = NULL ; \n acb -> sector_num = sector_num ; \n acb -> qiov = qiov ; \n if ( qiov -> niov > 1 ) { \n acb -> buf = acb -> orig_buf = qemu_memalign ( 512 , qiov -> size ) ; \n qemu_iovec_to_buffer ( qiov , acb -> buf ) ; \n } else { \n acb -> buf = ( uint8_t * ) qiov -> iov -> iov_base ; \n } \n acb -> nb_sectors = nb_sectors ; \n acb -> n = 0 ; \n qcow_aio_write_cb ( acb , 0 ) ; \n return & acb -> common ; \n }", "idx": 10986}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static uint32_t vmsvga_bios_read ( void * opaque , uint32_t address ) \n { \n printf ( \" \\n \" , __FUNCTION__ ) ; \n return 0xcafe ; \n }", "idx": 11006}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_lcreate ( void * opaque ) \n { \n int32_t dfid , flags , mode ; \n gid_t gid ; \n ssize_t err = 0 ; \n ssize_t offset = 7 ; \n V9fsString name ; \n V9fsFidState * fidp ; \n struct stat stbuf ; \n V9fsQID qid ; \n int32_t iounit ; \n V9fsPDU * pdu = opaque ; \n pdu_unmarshal ( pdu , offset , \" \" , & dfid , & name , & flags , \n & mode , & gid ) ; \n fidp = get_fid ( pdu , dfid ) ; \n if ( fidp == NULL ) { \n err = - ENOENT ; \n goto out_nofid ; \n } \n flags = get_dotl_openflags ( pdu -> s , flags ) ; \n err = v9fs_co_open2 ( pdu , fidp , & name , gid , \n flags | O_CREAT , mode , & stbuf ) ; \n if ( err < 0 ) { \n goto out ; \n } \n fidp -> fid_type = P9_FID_FILE ; \n fidp -> open_flags = flags ; \n if ( flags & O_EXCL ) { \n fidp -> flags |= FID_NON_RECLAIMABLE ; \n } \n iounit = get_iounit ( pdu , & fidp -> path ) ; \n stat_to_qid ( & stbuf , & qid ) ; \n offset += pdu_marshal ( pdu , offset , \" \" , & qid , iounit ) ; \n err = offset ; \n out : \n put_fid ( pdu , fidp ) ; \n out_nofid : \n trace_v9fs_lcreate_return ( pdu -> tag , pdu -> id , \n qid . type , qid . version , qid . path , iounit ) ; \n complete_pdu ( pdu -> s , pdu , err ) ; \n v9fs_string_free ( & name ) ; \n }", "idx": 11055}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "g_malloc ( size_t n_bytes )  \n { \n void * mem ; \n __coverity_negative_sink__ ( n_bytes ) ; \n mem = malloc ( n_bytes == 0 ? 1 : n_bytes ) ; \n if ( ! mem ) __coverity_panic__ ( ) ; \n return mem ; \n }", "idx": 11095}
{"project": "qemu", "commit_id": "2ed1ebcf65edf6757d8904000889ce52cc0a9d1b", "target": 0, "func": "void qemu_get_timedate ( struct tm * tm , int offset ) \n { \n time_t ti ; \n time ( & ti ) ; \n ti += offset ; \n if ( rtc_date_offset == -1 ) { \n if ( rtc_utc ) \n gmtime_r ( & ti , tm ) ; \n else \n localtime_r ( & ti , tm ) ; \n } else { \n ti -= rtc_date_offset ; \n gmtime_r ( & ti , tm ) ; \n } \n }", "idx": 11124}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_lpg_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n struct omap_lpg_s * s = ( struct omap_lpg_s * ) opaque ; \n int offset = addr & OMAP_MPUI_REG_MASK ; \n if ( size != 1 ) { \n return omap_badwidth_read8 ( opaque , addr ) ; \n } \n switch ( offset ) { \n case 0x00 : \n return s -> control ; \n case 0x04 : \n return s -> power ; \n } \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 11132}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static int local_mksock ( FsContext * ctx2 , const char * path ) \n { \n struct sockaddr_un addr ; \n int s ; \n addr . sun_family = AF_UNIX ; \n snprintf ( addr . sun_path , 108 , \" \" , rpath ( ctx2 , path ) ) ; \n s = socket ( PF_UNIX , SOCK_STREAM , 0 ) ; \n if ( s == -1 ) { \n return -1 ; \n } \n if ( bind ( s , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ) { \n close ( s ) ; \n return -1 ; \n } \n close ( s ) ; \n return 0 ; \n }", "idx": 11155}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static void virtio_device_free_virtqueues ( VirtIODevice * vdev ) \n { \n int i ; \n if ( ! vdev -> vq ) { \n return ; \n } \n for ( i = 0 ; i < VIRTIO_QUEUE_MAX ; i ++ ) { \n VRingMemoryRegionCaches * caches ; \n if ( vdev -> vq [ i ] . vring . num == 0 ) { \n break ; \n } \n caches = atomic_read ( & vdev -> vq [ i ] . vring . caches ) ; \n atomic_set ( & vdev -> vq [ i ] . vring . caches , NULL ) ; \n virtio_free_region_cache ( caches ) ; \n } \n g_free ( vdev -> vq ) ; \n }", "idx": 11160}
{"project": "qemu", "commit_id": "97a2ae34537882df34810d538ab1f51085499d2c", "target": 1, "func": "static int coroutine_fn raw_co_write_zeroes ( \n BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , BdrvRequestFlags flags ) \n { \n BDRVRawState * s = bs -> opaque ; \n if ( ! ( flags & BDRV_REQ_MAY_UNMAP ) ) { \n return - ENOTSUP ; \n } \n if ( ! s -> discard_zeroes ) { \n return - ENOTSUP ; \n } \n return paio_submit_co ( bs , s -> fd , sector_num , NULL , nb_sectors , \n QEMU_AIO_DISCARD ) ; \n }", "idx": 11254}
{"project": "qemu", "commit_id": "f7736b91c40a617e93505e32dcbd2cb56aad8a23", "target": 0, "func": "static int dma_buf_prepare ( BMDMAState * bm , int is_write ) \n { \n IDEState * s = bmdma_active_if ( bm ) ; \n struct { \n uint32_t addr ; \n uint32_t size ; \n } prd ; \n int l , len ; \n qemu_sglist_init ( & s -> sg , s -> nsector / ( TARGET_PAGE_SIZE / 512 ) + 1 ) ; \n s -> io_buffer_size = 0 ; \n for ( ; ; ) { \n if ( bm -> cur_prd_len == 0 ) { \n if ( bm -> cur_prd_last || \n ( bm -> cur_addr - bm -> addr ) >= 4096 ) \n return s -> io_buffer_size != 0 ; \n cpu_physical_memory_read ( bm -> cur_addr , ( uint8_t * ) & prd , 8 ) ; \n bm -> cur_addr += 8 ; \n prd . addr = le32_to_cpu ( prd . addr ) ; \n prd . size = le32_to_cpu ( prd . size ) ; \n len = prd . size & 0xfffe ; \n if ( len == 0 ) \n len = 0x10000 ; \n bm -> cur_prd_len = len ; \n bm -> cur_prd_addr = prd . addr ; \n bm -> cur_prd_last = ( prd . size & 0x80000000 ) ; \n } \n l = bm -> cur_prd_len ; \n if ( l > 0 ) { \n qemu_sglist_add ( & s -> sg , bm -> cur_prd_addr , l ) ; \n bm -> cur_prd_addr += l ; \n bm -> cur_prd_len -= l ; \n s -> io_buffer_size += l ; \n } \n } \n return 1 ; \n }", "idx": 11263}
{"project": "qemu", "commit_id": "1294ca797c6bee39d4dbc3e92010873ce4047e0e", "target": 0, "func": "static int usb_host_claim_interfaces ( USBHostDevice * s , int configuration ) \n { \n USBDevice * udev = USB_DEVICE ( s ) ; \n struct libusb_config_descriptor * conf ; \n int rc , i ; \n for ( i = 0 ; i < USB_MAX_INTERFACES ; i ++ ) { \n udev -> altsetting [ i ] = 0 ; \n } \n udev -> ninterfaces = 0 ; \n udev -> configuration = 0 ; \n if ( configuration == 0 ) { \n return USB_RET_SUCCESS ; \n } \n usb_host_detach_kernel ( s ) ; \n rc = libusb_get_active_config_descriptor ( s -> dev , & conf ) ; \n if ( rc != 0 ) { \n return USB_RET_STALL ; \n } \n for ( i = 0 ; i < conf -> bNumInterfaces ; i ++ ) { \n trace_usb_host_claim_interface ( s -> bus_num , s -> addr , configuration , i ) ; \n rc = libusb_claim_interface ( s -> dh , i ) ; \n usb_host_libusb_error ( \" \" , rc ) ; \n if ( rc != 0 ) { \n return USB_RET_STALL ; \n } \n s -> ifs [ i ] . claimed = true ; \n } \n udev -> ninterfaces = conf -> bNumInterfaces ; \n udev -> configuration = configuration ; \n libusb_free_config_descriptor ( conf ) ; \n return USB_RET_SUCCESS ; \n }", "idx": 11264}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_completion ( void ) \n { \n int len , i , j , max_width , nb_cols ; \n char * cmdline ; \n nb_completions = 0 ; \n cmdline = qemu_malloc ( term_cmd_buf_index + 1 ) ; \n if ( ! cmdline ) \n return ; \n memcpy ( cmdline , term_cmd_buf , term_cmd_buf_index ) ; \n cmdline [ term_cmd_buf_index ] = ' \\0 ' ; \n find_completion ( cmdline ) ; \n qemu_free ( cmdline ) ; \n if ( nb_completions <= 0 ) \n return ; \n if ( nb_completions == 1 ) { \n len = strlen ( completions [ 0 ] ) ; \n for ( i = completion_index ; i < len ; i ++ ) { \n term_insert_char ( completions [ 0 ] [ i ] ) ; \n } \n if ( len > 0 && completions [ 0 ] [ len - 1 ] != ' ' ) \n term_insert_char ( ' ' ) ; \n } else { \n term_printf ( \" \\n \" ) ; \n max_width = 0 ; \n for ( i = 0 ; i < nb_completions ; i ++ ) { \n len = strlen ( completions [ i ] ) ; \n if ( len > max_width ) \n max_width = len ; \n } \n max_width += 2 ; \n if ( max_width < 10 ) \n max_width = 10 ; \n else if ( max_width > 80 ) \n max_width = 80 ; \n nb_cols = 80 / max_width ; \n j = 0 ; \n for ( i = 0 ; i < nb_completions ; i ++ ) { \n term_printf ( \" \" , max_width , completions [ i ] ) ; \n if ( ++ j == nb_cols || i == ( nb_completions - 1 ) ) { \n term_printf ( \" \\n \" ) ; \n j = 0 ; \n } \n } \n term_show_prompt2 ( ) ; \n } \n }", "idx": 11270}
{"project": "qemu", "commit_id": "36bcac16fdd6ecb75314db06171f54dcd400ab8c", "target": 1, "func": "static int parse_vdiname ( BDRVSheepdogState * s , const char * filename , \n char * vdi , uint32_t * snapid , char * tag ) \n { \n char * p , * q , * uri ; \n const char * host_spec , * vdi_spec ; \n int nr_sep , ret ; \n strstart ( filename , \" \" , & filename ) ; \n p = q = g_strdup ( filename ) ; \n nr_sep = 0 ; \n while ( * p ) { \n if ( * p == ' ' ) { \n nr_sep ++ ; \n } \n p ++ ; \n } \n p = q ; \n if ( nr_sep >= 2 ) { \n host_spec = p ; \n p = strchr ( p , ' ' ) ; \n p ++ ; \n p = strchr ( p , ' ' ) ; \n * p ++ = ' \\0 ' ; \n } else { \n host_spec = \" \" ; \n } \n vdi_spec = p ; \n p = strchr ( vdi_spec , ' ' ) ; \n if ( p ) { \n * p ++ = ' ' ; \n } \n uri = g_strdup_printf ( \" \n ret = sd_parse_uri ( s , uri , vdi , snapid , tag )  ; \n g_free ( q ) ; \n g_free ( uri ) ; \n return ret ; \n }", "idx": 11288}
{"project": "qemu", "commit_id": "be1fea9bc286f64c6c995bb0d7145a0b738aeddb", "target": 0, "func": "static inline uint16_t vring_avail_idx ( VirtQueue * vq ) \n { \n hwaddr pa ; \n pa = vq -> vring . avail + offsetof ( VRingAvail , idx ) ; \n return virtio_lduw_phys ( vq -> vdev , pa ) ; \n }", "idx": 11309}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_update_cr0 ( CPUX86State * env ) \n { \n int pg_state , pe_state ; \n #if defined ( DEBUG_MMU )  \n  \n  printf ( \" \\n \" , env -> cr [ 0 ] ) ; \n #endif \n pg_state = env -> cr [ 0 ] & CR0_PG_MASK ; \n if ( pg_state != last_pg_state ) { \n tlb_flush ( env ) ; \n last_pg_state = pg_state ; \n } \n pe_state = ( env -> cr [ 0 ] & CR0_PE_MASK ) ; \n env -> hflags = ( env -> hflags & ~ HF_PE_MASK ) | ( pe_state << HF_PE_SHIFT ) ; \n env -> hflags |= ( ( pe_state ^ 1 ) << HF_ADDSEG_SHIFT ) ; \n }", "idx": 11313}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void branch ( DBDMA_channel * ch ) \n { \n dbdma_cmd * current = & ch -> current ; \n ch -> regs [ DBDMA_CMDPTR_LO ] = current -> cmd_dep ; \n ch -> regs [ DBDMA_STATUS ] |= cpu_to_be32 ( BT ) ; \n dbdma_cmdptr_load ( ch ) ; \n }", "idx": 11314}
{"project": "qemu", "commit_id": "7d99f4c1b5d12de7644a5bd8c3d46bff05c9ca7c", "target": 1, "func": "static int scsi_get_configuration ( SCSIDiskState * s , uint8_t * outbuf ) \n { \n int current ; \n if ( s -> qdev . type != TYPE_ROM ) { \n return -1 ; \n } \n current = media_is_dvd ( s ) ? MMC_PROFILE_DVD_ROM : MMC_PROFILE_CD_ROM ; \n memset ( outbuf , 0 , 40 ) ; \n stl_be_p ( & outbuf [ 0 ] , 36 ) ; \n stw_be_p ( & outbuf [ 6 ] , current ) ; \n outbuf [ 10 ] = 0x03 ; \n outbuf [ 11 ] = 8 ; \n stw_be_p ( & outbuf [ 12 ] , MMC_PROFILE_DVD_ROM ) ; \n outbuf [ 14 ] = ( current == MMC_PROFILE_DVD_ROM ) ; \n stw_be_p ( & outbuf [ 16 ] , MMC_PROFILE_CD_ROM ) ; \n outbuf [ 18 ] = ( current == MMC_PROFILE_CD_ROM ) ; \n stw_be_p ( & outbuf [ 20 ] , 1 ) ; \n outbuf [ 22 ] = 0x08 | 0x03 ; \n outbuf [ 23 ] = 8 ; \n stl_be_p ( & outbuf [ 24 ] , 1 ) ; \n outbuf [ 28 ] = 1 ; \n stw_be_p ( & outbuf [ 32 ] , 3 ) ; \n outbuf [ 34 ] = 0x08 | 0x03 ; \n outbuf [ 35 ] = 4 ; \n outbuf [ 36 ] = 0x39 ; \n return 40 ; \n }", "idx": 11343}
{"project": "qemu", "commit_id": "1ec3b71cde6997db866a76ff3311cb97c0b6741a", "target": 1, "func": "static void rx_stop_cont_test ( const QVirtioBus * bus , QVirtioDevice * dev , \n QGuestAllocator * alloc , QVirtQueue * vq , \n int socket ) \n { \n uint64_t req_addr ; \n uint32_t free_head ; \n char test [ ] = \" \" ; \n char buffer [ 64 ] ; \n int len = htonl ( sizeof ( test ) ) ; \n struct iovec iov [ ] = { \n { \n . iov_base = & len , \n . iov_len = sizeof ( len ) , \n } , { \n . iov_base = test , \n . iov_len = sizeof ( test ) , \n } , \n } ; \n int ret ; \n req_addr = guest_alloc ( alloc , 64 ) ; \n free_head = qvirtqueue_add ( vq , req_addr , 64 , true , false ) ; \n qvirtqueue_kick ( bus , dev , vq , free_head ) ; \n qmp ( \" \" ) ; \n ret = iov_send ( socket , iov , 2 , 0 , sizeof ( len ) + sizeof ( test ) ) ; \n g_assert_cmpint ( ret , == , sizeof ( test ) + sizeof ( len ) ) ; \n qmp ( \" \" ) ; \n qmp ( \" \" ) ; \n qvirtio_wait_queue_isr ( bus , dev , vq , QVIRTIO_NET_TIMEOUT_US ) ; \n memread ( req_addr + VNET_HDR_SIZE , buffer , sizeof ( test ) ) ; \n g_assert_cmpstr ( buffer , == , \" \" ) ; \n guest_free ( alloc , req_addr ) ; \n }", "idx": 11349}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void nbd_read ( void * opaque ) \n { \n NBDClient * client = opaque ; \n if ( client -> recv_coroutine ) { \n qemu_coroutine_enter ( client -> recv_coroutine , NULL ) ; \n } else { \n qemu_coroutine_enter ( qemu_coroutine_create ( nbd_trip ) , client ) ; \n } \n }", "idx": 11357}
{"project": "qemu", "commit_id": "27463101f15bee17d2f46642c48a7373bc6c595e", "target": 1, "func": "int qemu_eventfd ( int * fds ) \n { \n #if defined ( SYS_eventfd )  \n  \n  int ret ; \n ret = syscall ( SYS_eventfd , 0 ) ; \n if ( ret >= 0 ) { \n fds [ 0 ] = fds [ 1 ] = ret ; \n return 0 ; \n } else if ( ! ( ret == -1 && errno == ENOSYS ) ) \n return ret ; \n #endif \n return pipe ( fds ) ; \n }", "idx": 11373}
{"project": "qemu", "commit_id": "ce7f7cc2715145eadf1ac45a5dae63f535fc8bbf", "target": 1, "func": "int64_t ga_get_fd_handle ( GAState * s , Error * * errp ) \n { \n int64_t handle ; \n g_assert ( s -> pstate_filepath ) ; \n g_assert ( ! ga_is_frozen ( s ) ) ; \n handle = s -> pstate . fd_counter ++ ; \n if ( s -> pstate . fd_counter < 0 ) { \n s -> pstate . fd_counter = 0 ; \n } \n if ( ! write_persistent_state ( & s -> pstate , s -> pstate_filepath ) ) { \n error_setg ( errp , \" \" ) ; \n } \n return handle ; \n }", "idx": 11384}
{"project": "qemu", "commit_id": "7f6613cedc59fa849105668ae971dc31004bca1c", "target": 0, "func": "static void gen_load_fpr32h ( TCGv_i32 t , int reg ) \n { \n TCGv_i64 t64 = tcg_temp_new_i64 ( ) ; \n tcg_gen_shri_i64 ( t64 , fpu_f64 [ reg ] , 32 ) ; \n tcg_gen_trunc_i64_i32 ( t , t64 ) ; \n tcg_temp_free_i64 ( t64 ) ; \n }", "idx": 11402}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "void block_job_completed ( BlockJob * job , int ret ) \n { \n BlockDriverState * bs = job -> bs ; \n assert ( bs -> job == job ) ; \n job -> cb ( job -> opaque , ret ) ; \n bs -> job = NULL ; \n g_free ( job ) ; \n bdrv_set_in_use ( bs , 0 ) ; \n }", "idx": 11414}
{"project": "qemu", "commit_id": "b4176cb314995ad225d6c2b531568801feb04f3f", "target": 1, "func": "static int nbd_parse_offset_hole_payload ( NBDStructuredReplyChunk * chunk , \n uint8_t * payload , uint64_t orig_offset , \n QEMUIOVector * qiov , Error * * errp ) \n { \n uint64_t offset ; \n uint32_t hole_size ; \n if ( chunk -> length != sizeof ( offset ) + sizeof ( hole_size ) ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n return - EINVAL ; \n } \n offset = payload_advance64 ( & payload ) ; \n hole_size = payload_advance32 ( & payload ) ; \n if ( offset < orig_offset || hole_size > qiov -> size || \n offset > orig_offset + qiov -> size - hole_size ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n return - EINVAL ; \n } \n qemu_iovec_memset ( qiov , offset - orig_offset , 0 , hole_size ) ; \n return 0 ; \n }", "idx": 11457}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_post_send_control ( RDMAContext * rdma , uint8_t * buf , \n RDMAControlHeader * head ) \n { \n int ret = 0 ; \n RDMAWorkRequestData * wr = & rdma -> wr_data [ RDMA_WRID_CONTROL ] ; \n struct ibv_send_wr * bad_wr ; \n struct ibv_sge sge = { \n . addr = ( uint64_t ) ( wr -> control ) , \n . length = head -> len + sizeof ( RDMAControlHeader ) , \n . lkey = wr -> control_mr -> lkey , \n } ; \n struct ibv_send_wr send_wr = { \n . wr_id = RDMA_WRID_SEND_CONTROL , \n . opcode = IBV_WR_SEND , \n . send_flags = IBV_SEND_SIGNALED , \n . sg_list = & sge , \n . num_sge = 1 , \n } ; \n DDDPRINTF ( \" \\n \" , control_desc [ head -> type ] ) ; \n assert ( head -> len <= RDMA_CONTROL_MAX_BUFFER - sizeof ( * head ) ) ; \n memcpy ( wr -> control , head , sizeof ( RDMAControlHeader ) ) ; \n control_to_network ( ( void * ) wr -> control ) ; \n if ( buf ) { \n memcpy ( wr -> control + sizeof ( RDMAControlHeader ) , buf , head -> len ) ; \n } \n ret = ibv_post_send ( rdma -> qp , & send_wr , & bad_wr ) ; \n if ( ret > 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return - ret ; \n } \n ret = qemu_rdma_block_for_wrid ( rdma , RDMA_WRID_SEND_CONTROL , NULL ) ; \n if ( ret < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n } \n return ret ; \n }", "idx": 11497}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void pci_ich9_ahci_realize ( PCIDevice * dev , Error * * errp ) \n { \n struct AHCIPCIState * d ; \n int sata_cap_offset ; \n uint8_t * sata_cap ; \n d = ICH_AHCI ( dev ) ; \n ahci_realize ( & d -> ahci , DEVICE ( dev ) , pci_get_address_space ( dev ) , 6 ) ; \n pci_config_set_prog_interface ( dev -> config , AHCI_PROGMODE_MAJOR_REV_1 ) ; \n dev -> config [ PCI_CACHE_LINE_SIZE ] = 0x08 ; \n dev -> config [ PCI_LATENCY_TIMER ] = 0x00 ; \n pci_config_set_interrupt_pin ( dev -> config , 1 ) ; \n dev -> config [ 0x90 ] = 1 << 6 ; \n d -> ahci . irq = pci_allocate_irq ( dev ) ; \n pci_register_bar ( dev , ICH9_IDP_BAR , PCI_BASE_ADDRESS_SPACE_IO , \n & d -> ahci . idp ) ; \n pci_register_bar ( dev , ICH9_MEM_BAR , PCI_BASE_ADDRESS_SPACE_MEMORY , \n & d -> ahci . mem ) ; \n sata_cap_offset = pci_add_capability2 ( dev , PCI_CAP_ID_SATA , \n ICH9_SATA_CAP_OFFSET , SATA_CAP_SIZE , \n errp ) ; \n if ( sata_cap_offset < 0 ) { \n return ; \n } \n sata_cap = dev -> config + sata_cap_offset ; \n pci_set_word ( sata_cap + SATA_CAP_REV , 0x10 ) ; \n pci_set_long ( sata_cap + SATA_CAP_BAR , \n ( ICH9_IDP_BAR + 0x4 ) | ( ICH9_IDP_INDEX_LOG2 << 4 ) ) ; \n d -> ahci . idp_offset = ICH9_IDP_INDEX ; \n msi_init ( dev , ICH9_MSI_CAP_OFFSET , 1 , true , false ) ; \n }", "idx": 11498}
{"project": "qemu", "commit_id": "dcc70cdf0932172fc5cf27617a3b033ca58d0176", "target": 1, "func": "static void parse_cmdline ( const char * cmdline , \n int * pnb_args , char * * args ) \n { \n const char * p ; \n int nb_args , ret ; \n char buf [ 1024 ] ; \n p = cmdline ; \n nb_args = 0 ; \n for ( ; ; ) { \n while ( qemu_isspace ( * p ) ) { \n p ++ ; \n } \n if ( * p == ' \\0 ' ) { \n break ; \n } \n if ( nb_args >= MAX_ARGS ) { \n break ; \n } \n ret = get_str ( buf , sizeof ( buf ) , & p ) ; \n args [ nb_args ] = g_strdup ( buf ) ; \n nb_args ++ ; \n if ( ret < 0 ) { \n break ; \n } \n } \n * pnb_args = nb_args ; \n }", "idx": 11504}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_update_memory_access ( VGACommonState * s ) \n { \n hwaddr base , offset , size ; \n if ( s -> legacy_address_space == NULL ) { \n return ; \n } \n if ( s -> has_chain4_alias ) { \n memory_region_del_subregion ( s -> legacy_address_space , & s -> chain4_alias ) ; \n object_unparent ( OBJECT ( & s -> chain4_alias ) ) ; \n s -> has_chain4_alias = false ; \n s -> plane_updated = 0xf ; \n } \n if ( ( s -> sr [ VGA_SEQ_PLANE_WRITE ] & VGA_SR02_ALL_PLANES ) == \n VGA_SR02_ALL_PLANES && s -> sr [ VGA_SEQ_MEMORY_MODE ] & VGA_SR04_CHN_4M ) { \n offset = 0 ; \n switch ( ( s -> gr [ VGA_GFX_MISC ] >> 2 ) & 3 ) { \n case 0 : \n base = 0xa0000 ; \n size = 0x20000 ; \n break ; \n case 1 : \n base = 0xa0000 ; \n size = 0x10000 ; \n offset = s -> bank_offset ; \n break ; \n case 2 : \n base = 0xb0000 ; \n size = 0x8000 ; \n break ; \n case 3 : \n default : \n base = 0xb8000 ; \n size = 0x8000 ; \n break ; \n } \n assert ( offset + size <= s -> vram_size ) ; \n memory_region_init_alias ( & s -> chain4_alias , memory_region_owner ( & s -> vram ) , \n \" \" , & s -> vram , offset , size ) ; \n memory_region_add_subregion_overlap ( s -> legacy_address_space , base , \n & s -> chain4_alias , 2 ) ; \n s -> has_chain4_alias = true ; \n } \n }", "idx": 11549}
{"project": "qemu", "commit_id": "2436b61a6b386d712a1813b036921443bd1c5c39", "target": 0, "func": "void helper_sysexit ( void ) \n { \n int cpl ; \n cpl = env -> hflags & HF_CPL_MASK ; \n if ( env -> sysenter_cs == 0 || cpl != 0 ) { \n raise_exception_err ( EXCP0D_GPF , 0 ) ; \n } \n cpu_x86_set_cpl ( env , 3 ) ; \n cpu_x86_load_seg_cache ( env , R_CS , ( ( env -> sysenter_cs + 16 ) & 0xfffc ) | 3 , \n 0 , 0xffffffff , \n DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | \n DESC_S_MASK | ( 3 << DESC_DPL_SHIFT ) | \n DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK ) ; \n cpu_x86_load_seg_cache ( env , R_SS , ( ( env -> sysenter_cs + 24 ) & 0xfffc ) | 3 , \n 0 , 0xffffffff , \n DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | \n DESC_S_MASK | ( 3 << DESC_DPL_SHIFT ) | \n DESC_W_MASK | DESC_A_MASK ) ; \n ESP = ECX ; \n EIP = EDX ; \n #ifdef USE_KQEMU \n if ( kqemu_is_ok ( env ) ) { \n env -> exception_index = -1 ; \n cpu_loop_exit ( ) ; \n } \n #endif \n }", "idx": 11595}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efsnabs ( DisasContext * ctx ) \n { \n if ( unlikely ( ! ctx -> spe_enabled ) ) { \n gen_exception ( ctx , POWERPC_EXCP_APU ) ; \n return ; \n } \n tcg_gen_ori_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x80000000 ) ; \n }", "idx": 11597}
{"project": "qemu", "commit_id": "f95d7cc7fecbc0e320e83c864ce2d99fee3d9236", "target": 0, "func": "static int pte64_check ( struct mmu_ctx_hash64 * ctx , target_ulong pte0 , \n target_ulong pte1 , int h , int rwx ) \n { \n target_ulong mmask ; \n int access , ret , pp ; \n ret = -1 ; \n if ( ( pte0 & HPTE64_V_VALID ) && ( h == ! ! ( pte0 & HPTE64_V_SECONDARY ) ) ) { \n bool nx ; \n mmask = PTE64_CHECK_MASK ; \n pp = ( pte1 & HPTE64_R_PP ) | ( ( pte1 & HPTE64_R_PP0 ) >> 61 ) ; \n nx = ( pte1 & HPTE64_R_N ) || ( pte1 & HPTE64_R_G ) ; \n if ( HPTE64_V_COMPARE ( pte0 , ctx -> ptem ) ) { \n if ( ctx -> raddr != ( hwaddr ) - 1ULL ) { \n if ( ( ctx -> raddr & mmask ) != ( pte1 & mmask ) ) { \n qemu_log ( \" \\n \" ) ; \n return -3 ; \n } \n } \n access = ppc_hash64_pp_check ( ctx -> key , pp , nx ) ; \n ctx -> raddr = pte1 ; \n ctx -> prot = access ; \n ret = ppc_hash64_check_prot ( ctx -> prot , rwx ) ; \n if ( ret == 0 ) { \n LOG_MMU ( \" \\n \" ) ; \n } else { \n LOG_MMU ( \" \\n \" ) ; \n } \n } \n } \n return ret ; \n }", "idx": 11611}
{"project": "qemu", "commit_id": "552908fef5b67ad9d96b76d7cb8371ebc26c9bc8", "target": 0, "func": "static uint64_t bmdma_addr_read ( void * opaque , target_phys_addr_t addr , \n unsigned width ) \n { \n BMDMAState * bm = opaque ; \n uint32_t mask = ( 1ULL << ( width * 8 ) ) - 1 ; \n uint64_t data ; \n data = ( bm -> addr >> ( addr * 8 ) ) & mask ; \n #ifdef DEBUG_IDE \n printf ( \" \\n \" , __func__ , ( unsigned ) * data ) ; \n #endif \n return data ; \n }", "idx": 11612}
{"project": "qemu", "commit_id": "8b7968f7c4ac8c07cad6a1a0891d38cf239a2839", "target": 0, "func": "static void qerror_abort ( const QError * qerr , const char * fmt , ... ) \n { \n va_list ap ; \n fprintf ( stderr , \" \\n \" , qerr -> func ) ; \n fprintf ( stderr , \" \" ) ; \n va_start ( ap , fmt ) ; \n vfprintf ( stderr , fmt , ap ) ; \n va_end ( ap ) ; \n fprintf ( stderr , \" \\n \\n \" , qerr -> file , qerr -> linenr ) ; \n abort ( ) ; \n }", "idx": 11613}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_nabs ( DisasContext * ctx ) \n { \n int l1 = gen_new_label ( ) ; \n int l2 = gen_new_label ( ) ; \n tcg_gen_brcondi_tl ( TCG_COND_GT , cpu_gpr [ rA ( ctx -> opcode ) ] , 0 , l1 ) ; \n tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_neg_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n gen_set_label ( l2 ) ; \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx , cpu_gpr [ rD ( ctx -> opcode ) ] ) ; \n }", "idx": 11616}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_iotlb_page_invalidate ( IntelIOMMUState * s , uint16_t domain_id , \n hwaddr addr , uint8_t am ) \n { \n VTDIOTLBPageInvInfo info ; \n assert ( am <= VTD_MAMV ) ; \n info . domain_id = domain_id ; \n info . gfn = addr >> VTD_PAGE_SHIFT_4K ; \n info . mask = ~ ( ( 1 << am ) - 1 ) ; \n g_hash_table_foreach_remove ( s -> iotlb , vtd_hash_remove_by_page , & info ) ; \n }", "idx": 11628}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "void qmp_x_input_send_event ( bool has_console , int64_t console , \n InputEventList * events , Error * * errp ) \n { \n InputEventList * e ; \n QemuConsole * con ; \n con = NULL ; \n if ( has_console ) { \n con = qemu_console_lookup_by_index ( console ) ; \n if ( ! con ) { \n error_setg ( errp , \" \" PRId64 \" \" , console ) ; \n return ; \n } \n } \n if ( ! runstate_is_running ( ) && ! runstate_check ( RUN_STATE_SUSPENDED ) ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n for ( e = events ; e != NULL ; e = e -> next ) { \n InputEvent * event = e -> value ; \n if ( ! qemu_input_find_handler ( 1 << event -> kind , con ) ) { \n error_setg ( errp , \" \" \n \" \" , \n InputEventKind_lookup [ event -> kind ] ) ; \n return ; \n } \n } \n for ( e = events ; e != NULL ; e = e -> next ) { \n InputEvent * event = e -> value ; \n qemu_input_event_send ( con , event ) ; \n } \n qemu_input_event_sync ( ) ; \n }", "idx": 11683}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_event_status_media ( SCSIDiskState * s , uint8_t * outbuf ) \n { \n uint8_t event_code , media_status ; \n media_status = 0 ; \n if ( s -> tray_open ) { \n media_status = MS_TRAY_OPEN ; \n } else if ( bdrv_is_inserted ( s -> qdev . conf . bs ) ) { \n media_status = MS_MEDIA_PRESENT ; \n } \n event_code = MEC_NO_CHANGE ; \n if ( media_status != MS_TRAY_OPEN ) { \n if ( s -> media_event ) { \n event_code = MEC_NEW_MEDIA ; \n s -> media_event = false ; \n } else if ( s -> eject_request ) { \n event_code = MEC_EJECT_REQUESTED ; \n s -> eject_request = false ; \n } \n } \n outbuf [ 0 ] = event_code ; \n outbuf [ 1 ] = media_status ; \n outbuf [ 2 ] = 0 ; \n outbuf [ 3 ] = 0 ; \n return 4 ; \n }", "idx": 11687}
{"project": "qemu", "commit_id": "2c0ef9f411ae6081efa9eca5b3eab2dbeee45a6c", "target": 0, "func": "void qapi_dealloc_visitor_cleanup ( QapiDeallocVisitor * v ) \n { \n g_free ( v ) ; \n }", "idx": 11691}
{"project": "qemu", "commit_id": "ecce1929bcb0d8f4efde39df5ceb1aac42df75d4", "target": 0, "func": "static void gd_ungrab_pointer ( GtkDisplayState * s ) \n { \n #if GTK_CHECK_VERSION ( 3 , 0 , 0 )  \n  \n  GdkDisplay * display = gtk_widget_get_display ( s -> drawing_area ) ; \n GdkDeviceManager * mgr = gdk_display_get_device_manager ( display ) ; \n GList * devices = gdk_device_manager_list_devices ( mgr , \n GDK_DEVICE_TYPE_MASTER ) ; \n GList * tmp = devices ; \n while ( tmp ) { \n GdkDevice * dev = tmp -> data ; \n if ( gdk_device_get_source ( dev ) == GDK_SOURCE_MOUSE ) { \n gdk_device_ungrab ( dev , \n GDK_CURRENT_TIME ) ; \n } \n tmp = tmp -> next ; \n } \n g_list_free ( devices ) ; \n #else \n gdk_pointer_ungrab ( GDK_CURRENT_TIME ) ; \n #endif \n }", "idx": 11693}
{"project": "qemu", "commit_id": "adae837d40dea7100040136647e3de44898994df", "target": 1, "func": "void machine_register_compat_props ( MachineState * machine ) \n { \n MachineClass * mc = MACHINE_GET_CLASS ( machine ) ; \n int i ; \n GlobalProperty * p ; \n if ( ! mc -> compat_props ) { \n return ; \n } \n for ( i = 0 ; i < mc -> compat_props -> len ; i ++ ) { \n p = g_array_index ( mc -> compat_props , GlobalProperty * , i ) ; \n qdev_prop_register_global ( p ) ; \n } \n }", "idx": 11696}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_addo ( void ) \n { \n T2 = T0 ; \n T0 += T1 ; \n if ( likely ( ! ( ( T2 ^ T1 ^ ( -1 ) ) & ( T2 ^ T0 ) & ( 1 << 31 ) ) ) ) { \n xer_ov = 0 ; \n } else { \n xer_so = 1 ; \n xer_ov = 1 ; \n } \n }", "idx": 11731}
{"project": "qemu", "commit_id": "9bc9732faeff09828fe38c0ebe2401ee131a6fca", "target": 1, "func": "static void nbd_coroutine_start ( NbdClientSession * s , \n struct nbd_request * request ) \n { \n if ( s -> in_flight >= MAX_NBD_REQUESTS - 1 ) { \n qemu_co_mutex_lock ( & s -> free_sema ) ; \n assert ( s -> in_flight < MAX_NBD_REQUESTS ) ; \n } \n s -> in_flight ++ ; \n }", "idx": 11732}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_sector_start_dma ( IDEState * s , enum ide_dma_cmd dma_cmd ) \n { \n s -> status = READY_STAT | SEEK_STAT | DRQ_STAT | BUSY_STAT ; \n s -> io_buffer_index = 0 ; \n s -> io_buffer_size = 0 ; \n s -> dma_cmd = dma_cmd ; \n switch ( dma_cmd ) { \n case IDE_DMA_READ : \n block_acct_start ( bdrv_get_stats ( s -> bs ) , & s -> acct , \n s -> nsector * BDRV_SECTOR_SIZE , BLOCK_ACCT_READ ) ; \n break ; \n case IDE_DMA_WRITE : \n block_acct_start ( bdrv_get_stats ( s -> bs ) , & s -> acct , \n s -> nsector * BDRV_SECTOR_SIZE , BLOCK_ACCT_WRITE ) ; \n break ; \n default : \n break ; \n } \n ide_start_dma ( s , ide_dma_cb ) ; \n }", "idx": 11841}
{"project": "qemu", "commit_id": "8b3d6cb1fa6ae12e80ed8c266a637468b52835c7", "target": 0, "func": "void s390_feat_bitmap_to_ascii ( const S390FeatBitmap bitmap , void * opaque , \n void ( * fn ) ( const char * name , void * opaque ) ) \n { \n S390Feat feat ; \n feat = find_first_bit ( bitmap , S390_FEAT_MAX ) ; \n while ( feat < S390_FEAT_MAX ) { \n fn ( s390_feat_def ( feat ) -> name , opaque ) ; \n feat = find_next_bit ( bitmap , S390_FEAT_MAX , feat + 1 ) ; \n } ; \n }", "idx": 11847}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static uint64_t hpet_get_ticks ( void ) \n { \n uint64_t ticks ; \n ticks = ns_to_ticks ( qemu_get_clock ( vm_clock ) + hpet_statep -> hpet_offset ) ; \n return ticks ; \n }", "idx": 11863}
{"project": "qemu", "commit_id": "c07a9008ac6985cd5a15909c2b9977d982defc12", "target": 0, "func": "static BlockDriverAIOCB * bdrv_aio_rw_vector ( BlockDriverState * bs , \n int64_t sector_num , \n QEMUIOVector * iov , \n int nb_sectors , \n BlockDriverCompletionFunc * cb , \n void * opaque , \n int is_write ) \n { \n VectorTranslationState * s = qemu_mallocz ( sizeof ( * s ) ) ; \n BlockDriverAIOCB * aiocb = qemu_aio_get ( bs , cb , opaque ) ; \n s -> this_aiocb = aiocb ; \n s -> iov = iov ; \n s -> bounce = qemu_memalign ( 512 , nb_sectors * 512 ) ; \n s -> is_write = is_write ; \n if ( is_write ) { \n qemu_iovec_to_buffer ( s -> iov , s -> bounce ) ; \n s -> aiocb = bdrv_aio_write ( bs , sector_num , s -> bounce , nb_sectors , \n bdrv_aio_rw_vector_cb , s ) ; \n } else { \n s -> aiocb = bdrv_aio_read ( bs , sector_num , s -> bounce , nb_sectors , \n bdrv_aio_rw_vector_cb , s ) ; \n } \n return aiocb ; \n }", "idx": 11912}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void pc_machine_set_max_ram_below_4g ( Object * obj , Visitor * v , \n const char * name , void * opaque , \n Error * * errp ) \n { \n PCMachineState * pcms = PC_MACHINE ( obj ) ; \n Error * error = NULL ; \n uint64_t value ; \n visit_type_size ( v , name , & value , & error ) ; \n if ( error ) { \n error_propagate ( errp , error ) ; \n return ; \n } \n if ( value > ( 1ULL << 32 ) ) { \n error_setg ( & error , \n \" \" PRIu64 \n \" \" , value ) ; \n error_propagate ( errp , error ) ; \n return ; \n } \n if ( value < ( 1ULL << 20 ) ) { \n error_report ( \" \" PRIu64 \n \" \" , \n value ) ; \n } \n pcms -> max_ram_below_4g = value ; \n }", "idx": 11914}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int stdio_get_buffer ( void * opaque , uint8_t * buf , int64_t pos , int size ) \n { \n QEMUFileStdio * s = opaque ; \n FILE * fp = s -> stdio_file ; \n int bytes ; \n do { \n clearerr ( fp ) ; \n bytes = fread ( buf , 1 , size , fp ) ; \n } while ( ( bytes == 0 ) && ferror ( fp ) && ( errno == EINTR ) ) ; \n return bytes ; \n }", "idx": 11930}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static MemoryRegionSection * phys_page_find ( PhysPageEntry lp , hwaddr index , \n Node * nodes , MemoryRegionSection * sections ) \n { \n PhysPageEntry * p ; \n int i ; \n for ( i = P_L2_LEVELS - 1 ; i >= 0 && ! lp . is_leaf ; i -- ) { \n if ( lp . ptr == PHYS_MAP_NODE_NIL ) { \n return & sections [ PHYS_SECTION_UNASSIGNED ] ; \n } \n p = nodes [ lp . ptr ] ; \n lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ] ; \n } \n return & sections [ lp . ptr ] ; \n }", "idx": 11945}
{"project": "qemu", "commit_id": "7d175d29c9430fcba7a98f2c71925137b7870da4", "target": 0, "func": "static int os_host_main_loop_wait ( int64_t timeout ) \n { \n int ret ; \n static int spin_counter ; \n glib_pollfds_fill ( & timeout ) ; \n if ( ! timeout && ( spin_counter > MAX_MAIN_LOOP_SPIN ) ) { \n static bool notified ; \n if ( ! notified && ! qtest_driver ( ) ) { \n fprintf ( stderr , \n \" \\n \" , \n MAX_MAIN_LOOP_SPIN ) ; \n notified = true ; \n } \n timeout = SCALE_MS ; \n } \n if ( timeout ) { \n spin_counter = 0 ; \n qemu_mutex_unlock_iothread ( ) ; \n } else { \n spin_counter ++ ; \n } \n ret = qemu_poll_ns ( ( GPollFD * ) gpollfds -> data , gpollfds -> len , timeout ) ; \n if ( timeout ) { \n qemu_mutex_lock_iothread ( ) ; \n } \n glib_pollfds_poll ( ) ; \n return ret ; \n }", "idx": 11955}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static void qemu_kill_report ( void ) \n { \n if ( ! qtest_driver ( ) && shutdown_signal != -1 ) { \n fprintf ( stderr , \" \" , shutdown_signal ) ; \n if ( shutdown_pid == 0 ) { \n fputc ( ' \\n ' , stderr ) ; \n } else { \n fprintf ( stderr , \" \" FMT_pid \" \\n \" , shutdown_pid ) ; \n } \n shutdown_signal = -1 ; \n } \n }", "idx": 11963}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_bol ( void ) \n { \n term_cmd_buf_index = 0 ; \n }", "idx": 11965}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static int gen_set_psr_im ( DisasContext * s , uint32_t mask , int spsr , uint32_t val ) \n { \n TCGv tmp ; \n tmp = new_tmp ( ) ; \n tcg_gen_movi_i32 ( tmp , val ) ; \n return gen_set_psr ( s , mask , spsr , tmp ) ; \n }", "idx": 12004}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void vhost_ccw_scsi_realize ( VirtioCcwDevice * ccw_dev , Error * * errp ) \n { \n VHostSCSICcw * dev = VHOST_SCSI_CCW ( ccw_dev ) ; \n DeviceState * vdev = DEVICE ( & dev -> vdev ) ; \n Error * err = NULL ; \n qdev_set_parent_bus ( vdev , BUS ( & ccw_dev -> bus ) ) ; \n object_property_set_bool ( OBJECT ( vdev ) , true , \" \" , & err ) ; \n if ( err ) { \n error_propagate ( errp , err ) ; \n } \n }", "idx": 12030}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "ssize_t nbd_send_request ( int csock , struct nbd_request * request ) \n { \n uint8_t buf [ 4 + 4 + 8 + 8 + 4 ] ; \n cpu_to_be32w ( ( uint32_t * ) buf , NBD_REQUEST_MAGIC ) ; \n cpu_to_be32w ( ( uint32_t * ) ( buf + 4 ) , request -> type ) ; \n cpu_to_be64w ( ( uint64_t * ) ( buf + 8 ) , request -> handle ) ; \n cpu_to_be64w ( ( uint64_t * ) ( buf + 16 ) , request -> from ) ; \n cpu_to_be32w ( ( uint32_t * ) ( buf + 24 ) , request -> len ) ; \n TRACE ( \" \" \n \" \" PRIu64 \" \" PRIu64 \" \" , \n request -> from , request -> len , request -> handle , request -> type ) ; \n if ( write_sync ( csock , buf , sizeof ( buf ) ) != sizeof ( buf ) ) { \n LOG ( \" \" ) ; \n errno = EINVAL ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 12041}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static void dmg_close ( BlockDriverState * bs ) \n { \n BDRVDMGState * s = bs -> opaque ; \n close ( s -> fd ) ; \n if ( s -> n_chunks > 0 ) { \n free ( s -> types ) ; \n free ( s -> offsets ) ; \n free ( s -> lengths ) ; \n free ( s -> sectors ) ; \n free ( s -> sectorcounts ) ; \n } \n free ( s -> compressed_chunk ) ; \n free ( s -> uncompressed_chunk ) ; \n inflateEnd ( & s -> zstream ) ; \n }", "idx": 12049}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lance_mem_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n SysBusPCNetState * d = opaque ; \n trace_lance_mem_writew ( addr , val & 0xffff ) ; \n pcnet_ioport_writew ( & d -> state , addr , val & 0xffff ) ; \n }", "idx": 12053}
{"project": "qemu", "commit_id": "0745eb1e4336bf665a911754d18ddd63794b352d", "target": 1, "func": "device_init ( usb_host_register_devices ) \n USBDevice * usb_host_device_open ( const char * devname ) \n { \n struct USBAutoFilter filter = { 0 , 0 , 0 , 0 } ; \n USBDevice * dev ; \n USBHostDevice * s ; \n char * p ; \n dev = usb_create ( NULL \n , \" \" ) ; \n s = DO_UPCAST ( USBHostDevice , dev , dev ) ; \n if ( strstr ( devname , \" \" ) ) { \n if ( parse_filter ( devname + 5 , & filter ) < 0 ) \n goto fail ; \n } else { \n if ( ( p = strchr ( devname , ' ' ) ) ) { \n filter . bus_num = strtoul ( devname , NULL , 0 ) ; \n filter . addr = strtoul ( devname , NULL , 0 ) ; \n } else if ( ( p = strchr ( devname , ' ' ) ) ) { \n filter . vendor_id = strtoul ( devname , NULL , 16 ) ; \n filter . product_id = strtoul ( devname , NULL , 16 ) ; \n } else { \n goto fail ; \n } \n } \n qdev_prop_set_uint32 ( & dev -> qdev , \" \" , filter . bus_num ) ; \n qdev_prop_set_uint32 ( & dev -> qdev , \" \" , filter . addr ) ; \n qdev_prop_set_uint32 ( & dev -> qdev , \" \" , filter . vendor_id ) ; \n qdev_prop_set_uint32 ( & dev -> qdev , \" \" , filter . product_id ) ; \n qdev_init ( & dev -> qdev ) ; \n return dev ; \n fail : \n qdev_free ( & dev -> qdev ) ; \n return NULL ; \n }", "idx": 12093}
{"project": "qemu", "commit_id": "27a749fb733dc64b7a215998be7f228a09bb27a7", "target": 1, "func": "void qemu_error_internal ( const char * file , int linenr , const char * func , \n const char * fmt , ... ) \n { \n va_list va ; \n QError * qerror ; \n assert ( qemu_error_sink != NULL ) ; \n va_start ( va , fmt ) ; \n qerror = qerror_from_info ( file , linenr , func , fmt , & va ) ; \n va_end ( va ) ; \n switch ( qemu_error_sink -> dest ) { \n case ERR_SINK_FILE : \n qerror_print ( qerror ) ; \n QDECREF ( qerror ) ; \n break ; \n case ERR_SINK_MONITOR : \n assert ( qemu_error_sink -> mon -> error == NULL ) ; \n qemu_error_sink -> mon -> error = qerror ; \n break ; \n } \n }", "idx": 12094}
{"project": "qemu", "commit_id": "daa23699031693b434ec263b212f77ba505e353e", "target": 0, "func": "static void spapr_phb_placement ( sPAPRMachineState * spapr , uint32_t index , \n uint64_t * buid , hwaddr * pio , hwaddr * mmio , \n unsigned n_dma , uint32_t * liobns , Error * * errp ) \n { \n const uint64_t base_buid = 0x800000020000000ULL ; \n const hwaddr phb_spacing = 0x1000000000ULL ; \n const hwaddr mmio_offset = 0xa0000000 ; \n const hwaddr pio_offset = 0x80000000 ; \n const uint32_t max_index = 255 ; \n const hwaddr phb0_alignment = 0x10000000000ULL ; \n uint64_t ram_top = MACHINE ( spapr ) -> ram_size ; \n hwaddr phb0_base , phb_base ; \n int i ; \n if ( MACHINE ( spapr ) -> maxram_size > ram_top ) { \n ram_top = spapr -> hotplug_memory . base + \n memory_region_size ( & spapr -> hotplug_memory . mr ) ; \n } \n phb0_base = QEMU_ALIGN_UP ( ram_top , phb0_alignment ) ; \n if ( index > max_index ) { \n error_setg ( errp , \" \\\" \\\" \" , \n max_index ) ; \n return ; \n } \n * buid = base_buid + index ; \n for ( i = 0 ; i < n_dma ; ++ i ) { \n liobns [ i ] = SPAPR_PCI_LIOBN ( index , i ) ; \n } \n phb_base = phb0_base + index * phb_spacing ; \n * pio = phb_base + pio_offset ; \n * mmio = phb_base + mmio_offset ; \n }", "idx": 12105}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_save_vmstate ( BlockDriverState * bs , const uint8_t * buf , \n int64_t pos , int size ) \n { \n QEMUIOVector qiov ; \n struct iovec iov = { \n . iov_base = ( void * ) buf , \n . iov_len = size , \n } ; \n qemu_iovec_init_external ( & qiov , & iov , 1 ) ; \n return bdrv_writev_vmstate ( bs , & qiov , pos ) ; \n }", "idx": 12109}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "void helper_fcmpo ( uint64_t arg1 , uint64_t arg2 , uint32_t crfD ) \n { \n CPU_DoubleU farg1 , farg2 ; \n uint32_t ret = 0 ; \n farg1 . ll = arg1 ; \n farg2 . ll = arg2 ; \n if ( unlikely ( float64_is_nan ( farg1 . d ) || \n float64_is_nan ( farg2 . d ) ) ) { \n ret = 0x01UL ; \n } else if ( float64_lt ( farg1 . d , farg2 . d , & env -> fp_status ) ) { \n ret = 0x08UL ; \n } else if ( ! float64_le ( farg1 . d , farg2 . d , & env -> fp_status ) ) { \n ret = 0x04UL ; \n } else { \n ret = 0x02UL ; \n } \n env -> fpscr &= ~ ( 0x0F << FPSCR_FPRF ) ; \n env -> fpscr |= ret << FPSCR_FPRF ; \n env -> crf [ crfD ] = ret ; \n if ( unlikely ( ret == 0x01UL ) ) { \n if ( float64_is_signaling_nan ( farg1 . d ) || \n float64_is_signaling_nan ( farg2 . d ) ) { \n fload_invalid_op_excp ( POWERPC_EXCP_FP_VXSNAN | \n POWERPC_EXCP_FP_VXVC ) ; \n } else { \n fload_invalid_op_excp ( POWERPC_EXCP_FP_VXVC ) ; \n } \n } \n }", "idx": 12121}
{"project": "qemu", "commit_id": "882e9b89af7c1086d97cee11b2437337e756fa00", "target": 0, "func": "void qmp_x_blockdev_set_iothread ( const char * node_name , StrOrNull * iothread , \n Error * * errp ) \n { \n AioContext * old_context ; \n AioContext * new_context ; \n BlockDriverState * bs ; \n bs = bdrv_find_node ( node_name ) ; \n if ( ! bs ) { \n error_setg ( errp , \" \" , node_name ) ; \n return ; \n } \n if ( bdrv_has_blk ( bs ) ) { \n error_setg ( errp , \" \" , node_name ) ; \n return ; \n } \n if ( iothread -> type == QTYPE_QSTRING ) { \n IOThread * obj = iothread_by_id ( iothread -> u . s ) ; \n if ( ! obj ) { \n error_setg ( errp , \" \" , iothread -> u . s ) ; \n return ; \n } \n new_context = iothread_get_aio_context ( obj ) ; \n } else { \n new_context = qemu_get_aio_context ( ) ; \n } \n old_context = bdrv_get_aio_context ( bs ) ; \n aio_context_acquire ( old_context ) ; \n bdrv_set_aio_context ( bs , new_context ) ; \n aio_context_release ( old_context ) ; \n }", "idx": 12132}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "static void test_dealloc_partial ( void ) \n { \n static const char text [ ] = \" \" ; \n UserDefTwo * ud2 = NULL ; \n Error * err = NULL ; \n { \n QDict * ud2_dict ; \n QmpInputVisitor * qiv ; \n ud2_dict = qdict_new ( ) ; \n qdict_put_obj ( ud2_dict , \" \" , QOBJECT ( qstring_from_str ( text ) ) ) ; \n qiv = qmp_input_visitor_new ( QOBJECT ( ud2_dict ) , false ) ; \n visit_type_UserDefTwo ( qmp_input_get_visitor ( qiv ) , NULL , & ud2 , & err ) ; \n qmp_input_visitor_cleanup ( qiv ) ; \n QDECREF ( ud2_dict ) ; \n } \n assert ( ud2 != NULL ) ; \n assert ( ud2 -> string0 != NULL ) ; \n assert ( strcmp ( ud2 -> string0 , text ) == 0 ) ; \n assert ( ud2 -> dict1 == NULL ) ; \n error_free_or_abort ( & err ) ; \n qapi_free_UserDefTwo ( ud2 ) ; \n }", "idx": 12137}
{"project": "qemu", "commit_id": "3468b59e18b179bc63c7ce934de912dfa9596122", "target": 0, "func": "size_t tcg_code_size ( void ) \n { \n unsigned int i ; \n size_t total ; \n qemu_mutex_lock ( & region . lock ) ; \n total = region . agg_size_full ; \n for ( i = 0 ; i < n_tcg_ctxs ; i ++ ) { \n const TCGContext * s = tcg_ctxs [ i ] ; \n size_t size ; \n size = atomic_read ( & s -> code_gen_ptr ) - s -> code_gen_buffer ; \n g_assert ( size <= s -> code_gen_buffer_size ) ; \n total += size ; \n } \n qemu_mutex_unlock ( & region . lock ) ; \n return total ; \n }", "idx": 12139}
{"project": "qemu", "commit_id": "703e0e89c669a70bbd6bf33c5e75f910d8d8cca3", "target": 1, "func": "static abi_ulong setup_arg_pages ( abi_ulong p , struct linux_binprm * bprm , \n struct image_info * info ) \n { \n abi_ulong stack_base , size , error ; \n int i ; \n size = x86_stack_size ; \n if ( size < MAX_ARG_PAGES * TARGET_PAGE_SIZE ) \n size = MAX_ARG_PAGES * TARGET_PAGE_SIZE ; \n error = target_mmap ( 0 , \n size + qemu_host_page_size , \n PROT_READ | PROT_WRITE , \n MAP_PRIVATE | MAP_ANONYMOUS , \n -1 , 0 ) ; \n if ( error == -1 ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n target_mprotect ( error + size , qemu_host_page_size , PROT_NONE ) ; \n stack_base = error + size - MAX_ARG_PAGES * TARGET_PAGE_SIZE ; \n p += stack_base ; \n for ( i = 0 ; i < MAX_ARG_PAGES ; i ++ ) { \n if ( bprm -> page [ i ] ) { \n info -> rss ++ ; \n memcpy_to_target ( stack_base , bprm -> page [ i ] , TARGET_PAGE_SIZE ) ; \n free ( bprm -> page [ i ] ) ; \n } \n stack_base += TARGET_PAGE_SIZE ; \n } \n return p ; \n }", "idx": 12166}
{"project": "qemu", "commit_id": "56c119e52ca229869912b22a5bec283487b0cf9b", "target": 1, "func": "void xen_map_cache_init ( void ) \n { \n unsigned long size ; \n struct rlimit rlimit_as ; \n mapcache = g_malloc0 ( sizeof ( MapCache ) ) ; \n QTAILQ_INIT ( & mapcache -> locked_entries ) ; \n mapcache -> last_address_index = -1 ; \n getrlimit ( RLIMIT_AS , & rlimit_as ) ; \n if ( rlimit_as . rlim_max < MCACHE_MAX_SIZE ) { \n rlimit_as . rlim_cur = rlimit_as . rlim_max ; \n } else { \n rlimit_as . rlim_cur = MCACHE_MAX_SIZE ; \n } \n setrlimit ( RLIMIT_AS , & rlimit_as ) ; \n mapcache -> max_mcache_size = rlimit_as . rlim_cur ; \n mapcache -> nr_buckets = \n ( ( ( mapcache -> max_mcache_size >> XC_PAGE_SHIFT ) + \n ( 1UL << ( MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT ) ) - 1 ) >> \n ( MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT ) ) ; \n size = mapcache -> nr_buckets * sizeof ( MapCacheEntry ) ; \n size = ( size + XC_PAGE_SIZE - 1 ) & ~ ( XC_PAGE_SIZE - 1 ) ; \n DPRINTF ( \" \\n \" , __func__ , \n mapcache -> nr_buckets , size ) ; \n mapcache -> entry = g_malloc0 ( size ) ; \n }", "idx": 12194}
{"project": "qemu", "commit_id": "38f3ef574b48afc507c6f636ae4393fd36bda072", "target": 1, "func": "static BlockDriver * bdrv_probe_all ( const uint8_t * buf , int buf_size , \n const char * filename ) \n { \n int score_max = 0 , score ; \n BlockDriver * drv = NULL , * d ; \n QLIST_FOREACH ( d , & bdrv_drivers , list )  { \n if ( d -> bdrv_probe ) { \n score = d -> bdrv_probe ( buf , buf_size , filename ) ; \n if ( score > score_max ) { \n score_max = score ; \n drv = d ; \n } \n } \n } \n return drv ; \n }", "idx": 12203}
{"project": "qemu", "commit_id": "2ecea9b8de5cd74df314541b87f712ae77f862ec", "target": 1, "func": "static void do_change ( const char * device , const char * target ) \n { \n if ( strcmp ( device , \" \" ) == 0 ) { \n do_change_vnc ( target ) ; \n } else { \n do_change_block ( device , target ) ; \n } \n }", "idx": 12211}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_unrealize ( DeviceState * dev , Error * * errp ) \n { \n rc4030State * s = RC4030 ( dev ) ; \n int i ; \n timer_free ( s -> periodic_timer ) ; \n address_space_destroy ( & s -> dma_as ) ; \n object_unparent ( OBJECT ( & s -> dma_tt ) ) ; \n object_unparent ( OBJECT ( & s -> dma_tt_alias ) ) ; \n object_unparent ( OBJECT ( & s -> dma_mr ) ) ; \n for ( i = 0 ; i < MAX_TL_ENTRIES ; ++ i ) { \n memory_region_del_subregion ( & s -> dma_mr , & s -> dma_mrs [ i ] ) ; \n object_unparent ( OBJECT ( & s -> dma_mrs [ i ] ) ) ; \n } \n }", "idx": 12225}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dew_0e ( DisasContext * ctx , uint32_t insn , \n const DisasInsn * di ) \n { \n unsigned rt = extract32 ( insn , 0 , 5 ) ; \n unsigned ra = assemble_ra64 ( insn ) ; \n return do_fop_dew ( ctx , rt , ra , di -> f_dew ) ; \n }", "idx": 12259}
{"project": "qemu", "commit_id": "5a3165263ae6782a7fe712a0a0c29c17468b9b68", "target": 0, "func": "static void check_watchpoint ( int offset , int len_mask , int flags ) \n { \n CPUArchState * env = cpu_single_env ; \n target_ulong pc , cs_base ; \n TranslationBlock * tb ; \n target_ulong vaddr ; \n CPUWatchpoint * wp ; \n int cpu_flags ; \n if ( env -> watchpoint_hit ) { \n cpu_interrupt ( env , CPU_INTERRUPT_DEBUG ) ; \n return ; \n } \n vaddr = ( env -> mem_io_vaddr & TARGET_PAGE_MASK ) + offset ; \n QTAILQ_FOREACH ( wp , & env -> watchpoints , entry )  { \n if ( ( vaddr == ( wp -> vaddr & len_mask ) || \n ( vaddr & wp -> len_mask ) == wp -> vaddr ) && ( wp -> flags & flags ) ) { \n wp -> flags |= BP_WATCHPOINT_HIT ; \n if ( ! env -> watchpoint_hit ) { \n env -> watchpoint_hit = wp ; \n tb = tb_find_pc ( env -> mem_io_pc ) ; \n if ( ! tb ) { \n cpu_abort ( env , \" \" \n \" \" , ( void * ) env -> mem_io_pc ) ; \n } \n cpu_restore_state ( tb , env , env -> mem_io_pc ) ; \n tb_phys_invalidate ( tb , -1 ) ; \n if ( wp -> flags & BP_STOP_BEFORE_ACCESS ) { \n env -> exception_index = EXCP_DEBUG ; \n cpu_loop_exit ( env ) ; \n } else { \n cpu_get_tb_cpu_state ( env , & pc , & cs_base , & cpu_flags ) ; \n tb_gen_code ( env , pc , cs_base , cpu_flags , 1 ) ; \n cpu_resume_from_signal ( env , NULL ) ; \n } \n } \n } else { \n wp -> flags &= ~ BP_WATCHPOINT_HIT ; \n } \n } \n }", "idx": 12298}
{"project": "qemu", "commit_id": "6502a14734e71b2f6dd079b0a1e546e6aa2d2f8d", "target": 0, "func": "BalloonInfo * qmp_query_balloon ( Error * * errp ) \n { \n BalloonInfo * info ; \n if ( kvm_enabled ( ) && ! kvm_has_sync_mmu ( ) ) { \n error_set ( errp , QERR_KVM_MISSING_CAP , \" \" , \" \" ) ; \n return NULL ; \n } \n info = g_malloc0 ( sizeof ( * info ) ) ; \n if ( qemu_balloon_status ( info ) == 0 ) { \n error_set ( errp , QERR_DEVICE_NOT_ACTIVE , \" \" ) ; \n qapi_free_BalloonInfo ( info ) ; \n return NULL ; \n } \n return info ; \n }", "idx": 12308}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_correct ( void ) \n { \n const char * str = \" \" ; \n unsigned long res = 999 ; \n int err ; \n err = qemu_strtoul ( str , NULL , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 123 ) ; \n }", "idx": 12325}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void arm_cpu_register_types ( void ) \n { \n int i ; \n type_register_static ( & arm_cpu_type_info ) ; \n for ( i = 0 ; i < ARRAY_SIZE ( arm_cpus ) ; i ++ ) { \n cpu_register ( & arm_cpus [ i ] ) ; \n } \n }", "idx": 12373}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gpio_write ( void * opaque , target_phys_addr_t addr , uint64_t value , \n unsigned size ) \n { \n struct gpio_state_t * s = opaque ; \n D ( printf ( \" \\n \" , __func__ , addr , ( unsigned ) value ) ) ; \n addr >>= 2 ; \n switch ( addr ) \n { \n case RW_PA_DOUT : \n s -> nand -> ale = ! ! ( value & ( 1 << 6 ) ) ; \n s -> nand -> cle = ! ! ( value & ( 1 << 5 ) ) ; \n s -> nand -> ce = ! ! ( value & ( 1 << 4 ) ) ; \n s -> regs [ addr ] = value ; \n break ; \n case RW_PD_DOUT : \n if ( ( s -> regs [ addr ] ^ value ) & 2 ) \n tempsensor_clkedge ( & s -> tempsensor , ! ! ( value & 2 ) , \n ! ! ( value & 16 ) ) ; \n s -> regs [ addr ] = value ; \n break ; \n default : \n s -> regs [ addr ] = value ; \n break ; \n } \n }", "idx": 12375}
{"project": "qemu", "commit_id": "b8e9fc0625c49404d63b4391f6dc5cf27be8b45b", "target": 0, "func": "static int get_physical_address_code ( CPUState * env , \n target_phys_addr_t * physical , int * prot , \n target_ulong address , int mmu_idx ) \n { \n unsigned int i ; \n uint64_t context ; \n int is_user = ( mmu_idx == MMU_USER_IDX || \n mmu_idx == MMU_USER_SECONDARY_IDX ) ; \n if ( ( env -> lsu & IMMU_E ) == 0 || ( env -> pstate & PS_RED ) != 0 ) { \n * physical = ultrasparc_truncate_physical ( address ) ; \n * prot = PAGE_EXEC ; \n return 0 ; \n } \n if ( env -> tl == 0 ) { \n context = env -> dmmu . mmu_primary_context & 0x1fff ; \n } else { \n context = 0 ; \n } \n for ( i = 0 ; i < 64 ; i ++ ) { \n if ( ultrasparc_tag_match ( & env -> itlb [ i ] , \n address , context , physical ) ) { \n if ( ( env -> itlb [ i ] . tte & 0x4 ) && is_user ) { \n if ( env -> immu . sfsr ) \n env -> immu . sfsr = 2 ; \n env -> immu . sfsr |= ( is_user << 3 ) | 1 ; \n env -> exception_index = TT_TFAULT ; \n #ifdef DEBUG_MMU \n printf ( \" \" PRIx64 \" \\n \" , address ) ; \n #endif \n return 1 ; \n } \n * prot = PAGE_EXEC ; \n TTE_SET_USED ( env -> itlb [ i ] . tte ) ; \n return 0 ; \n } \n } \n #ifdef DEBUG_MMU \n printf ( \" \" PRIx64 \" \\n \" , address ) ; \n #endif \n env -> immu . tag_access = ( address & ~ 0x1fffULL ) | context ; \n env -> exception_index = TT_TMISS ; \n return 1 ; \n }", "idx": 12386}
{"project": "qemu", "commit_id": "3f66aa9c07d6392757f9d7b83849c7f791981725", "target": 1, "func": "ISADevice * isa_create_simple ( const char * name ) \n { \n ISADevice * dev ; \n dev = isa_create ( name ) ; \n if ( qdev_init ( & dev -> qdev ) != 0 ) { \n return NULL ; \n } \n return dev ; \n }", "idx": 12426}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_create ( void ) \n { \n envlist_t * envlist ; \n if ( ( envlist = malloc ( sizeof ( * envlist ) ) ) == NULL ) \n return ( NULL ) ; \n LIST_INIT ( & envlist -> el_entries ) ; \n envlist -> el_count = 0 ; \n return ( envlist ) ; \n }", "idx": 12440}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "void qemu_fopen_ops_buffered ( MigrationState * migration_state ) \n { \n QEMUFileBuffered * s ; \n s = g_malloc0 ( sizeof ( * s ) ) ; \n s -> migration_state = migration_state ; \n s -> xfer_limit = migration_state -> bandwidth_limit / 10 ; \n s -> migration_state -> complete = false ; \n s -> file = qemu_fopen_ops ( s , & buffered_file_ops ) ; \n migration_state -> file = s -> file ; \n qemu_thread_create ( & s -> thread , buffered_file_thread , s , \n QEMU_THREAD_DETACHED ) ; \n }", "idx": 12446}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_negotiate_handle_export_name ( NBDClient * client , uint32_t length ) \n { \n int rc = - EINVAL ; \n char name [ 256 ] ; \n TRACE ( \" \" ) ; \n if ( length > 255 ) { \n LOG ( \" \" ) ; \n goto fail ; \n } \n if ( nbd_negotiate_read ( client -> ioc , name , length ) != length ) { \n LOG ( \" \" ) ; \n goto fail ; \n } \n name [ length ] = ' \\0 ' ; \n TRACE ( \" \" , name ) ; \n client -> exp = nbd_export_find ( name ) ; \n if ( ! client -> exp ) { \n LOG ( \" \" ) ; \n goto fail ; \n } \n QTAILQ_INSERT_TAIL ( & client -> exp -> clients , client , next ) ; \n nbd_export_get ( client -> exp ) ; \n rc = 0 ; \n fail : \n return rc ; \n }", "idx": 12485}
{"project": "qemu", "commit_id": "78dbbbe4dff95369c63bf77ee0df23371e1d6602", "target": 1, "func": "static inline bool extended_addresses_enabled ( CPUARMState * env ) \n { \n return arm_feature ( env , ARM_FEATURE_LPAE ) \n && ( env -> cp15 . c2_control & ( 1 << 31 ) ) ; \n }", "idx": 12522}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "uint64_t migrate_max_downtime ( void ) \n { \n return max_downtime ; \n }", "idx": 12567}
{"project": "qemu", "commit_id": "80f5ce758ac277e76c016dd7c0b246e40d4fca2d", "target": 0, "func": "static void fill_note ( struct memelfnote * note , const char * name , int type , \n unsigned int sz , void * data ) \n { \n unsigned int namesz ; \n namesz = strlen ( name ) + 1 ; \n note -> name = name ; \n note -> namesz = namesz ; \n note -> namesz_rounded = roundup ( namesz , sizeof ( int32_t ) ) ; \n note -> type = type ; \n note -> datasz = roundup ( sz , sizeof ( int32_t ) ) ; ; \n note -> data = data ; \n note -> notesz = sizeof ( struct elf_note ) + \n note -> namesz_rounded + note -> datasz ; \n }", "idx": 12628}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_goto ( BlockDriverState * bs , \n const char * snapshot_id ) \n { \n BlockDriver * drv = bs -> drv ; \n int ret , open_ret ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( drv -> bdrv_snapshot_goto ) \n return drv -> bdrv_snapshot_goto ( bs , snapshot_id ) ; \n if ( bs -> file ) { \n drv -> bdrv_close ( bs ) ; \n ret = bdrv_snapshot_goto ( bs -> file , snapshot_id ) ; \n open_ret = drv -> bdrv_open ( bs , NULL , bs -> open_flags ) ; \n if ( open_ret < 0 ) { \n bdrv_delete ( bs -> file ) ; \n bs -> drv = NULL ; \n return open_ret ; \n } \n return ret ; \n } \n return - ENOTSUP ; \n }", "idx": 12648}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_update_cpuid ( CPUState * env ) \n { \n int critical_features_mask , features , ext_features , ext_features_mask ; \n uint32_t eax , ebx , ecx , edx ; \n critical_features_mask = \n CPUID_CMOV | CPUID_CX8 | \n CPUID_FXSR | CPUID_MMX | CPUID_SSE | \n CPUID_SSE2 | CPUID_SEP ; \n ext_features_mask = CPUID_EXT_SSE3 | CPUID_EXT_MONITOR ; \n if ( ! is_cpuid_supported ( ) ) { \n features = 0 ; \n ext_features = 0 ; \n } else { \n cpuid ( 1 , eax , ebx , ecx , edx ) ; \n features = edx ; \n ext_features = ecx ; \n } \n #ifdef __x86_64__ \n features &= ~ CPUID_SEP ; \n #endif \n env -> cpuid_features = ( env -> cpuid_features & ~ critical_features_mask ) | \n ( features & critical_features_mask ) ; \n env -> cpuid_ext_features = ( env -> cpuid_ext_features & ~ ext_features_mask ) | \n ( ext_features & ext_features_mask ) ; \n }", "idx": 12666}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static GenericList * qapi_dealloc_next_list ( Visitor * v , GenericList * * listp , \n size_t size ) \n { \n GenericList * list = * listp ; \n QapiDeallocVisitor * qov = to_qov ( v ) ; \n StackEntry * e = QTAILQ_FIRST ( & qov -> stack ) ; \n if ( e && e -> is_list_head ) { \n e -> is_list_head = false ; \n return list ; \n } \n if ( list ) { \n list = list -> next ; \n g_free ( * listp ) ; \n return list ; \n } \n return NULL ; \n }", "idx": 12671}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qbool_destroy_obj ( QObject * obj ) \n { \n assert ( obj != NULL ) ; \n g_free ( qobject_to_qbool ( obj ) ) ; \n }", "idx": 12674}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static QemuOpt * qemu_opt_find ( QemuOpts * opts , const char * name ) \n { \n QemuOpt * opt ; \n TAILQ_FOREACH ( opt , & opts -> head , next )  { \n if ( strcmp ( opt -> name , name ) != 0 ) \n continue ; \n return opt ; \n } \n return NULL ; \n }", "idx": 12685}
{"project": "qemu", "commit_id": "a4d2d1a063897b859b7f25e414b229370b679bc8", "target": 0, "func": "uint64_t helper_cmptun ( uint64_t a , uint64_t b ) \n { \n float64 fa , fb ; \n fa = t_to_float64 ( a ) ; \n fb = t_to_float64 ( b ) ; \n if ( float64_is_quiet_nan ( fa ) || float64_is_quiet_nan ( fb ) ) \n return 0x4000000000000000ULL ; \n else \n return 0 ; \n }", "idx": 12702}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "Aml * aml_arg ( int pos ) \n { \n Aml * var ; \n uint8_t op = 0x68 \n + pos ; \n assert ( pos <= 6 ) ; \n var = aml_opcode ( op ) ; \n return var ; \n }", "idx": 12727}
{"project": "qemu", "commit_id": "c7cacb3e7a2e9fdf929c993b98268e4179147cbb", "target": 0, "func": "static int qemu_rbd_set_conf ( rados_t cluster , const char * conf , \n bool only_read_conf_file , \n Error * * errp ) \n { \n char * p , * buf ; \n char * name ; \n char * value ; \n Error * local_err = NULL ; \n int ret = 0 ; \n buf = g_strdup ( conf ) ; \n p = buf ; \n while ( p ) { \n name = qemu_rbd_next_tok ( RBD_MAX_CONF_NAME_SIZE , p , \n ' ' , \" \" , & p , & local_err ) ; \n if ( local_err ) { \n break ; \n } \n qemu_rbd_unescape ( name ) ; \n if ( ! p ) { \n error_setg ( errp , \" \" , name ) ; \n ret = - EINVAL ; \n break ; \n } \n value = qemu_rbd_next_tok ( RBD_MAX_CONF_VAL_SIZE , p , \n ' ' , \" \" , & p , & local_err ) ; \n if ( local_err ) { \n break ; \n } \n qemu_rbd_unescape ( value ) ; \n if ( strcmp ( name , \" \" ) == 0 ) { \n if ( only_read_conf_file ) { \n ret = rados_conf_read_file ( cluster , value ) ; \n if ( ret < 0 ) { \n error_setg_errno ( errp , - ret , \" \" , \n value ) ; \n break ; \n } \n } \n } else if ( strcmp ( name , \" \" ) == 0 ) { \n } else if ( ! only_read_conf_file ) { \n ret = rados_conf_set ( cluster , name , value ) ; \n if ( ret < 0 ) { \n error_setg_errno ( errp , - ret , \" \" , name ) ; \n ret = - EINVAL ; \n break ; \n } \n } \n } \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n ret = - EINVAL ; \n } \n g_free ( buf ) ; \n return ret ; \n }", "idx": 12765}
{"project": "qemu", "commit_id": "e508a92b621c7160122e99d3754e568f2b8e255e", "target": 0, "func": "static int arm946_prbs_read ( CPUARMState * env , const ARMCPRegInfo * ri , \n uint64_t * value ) \n { \n if ( ri -> crm >= 8 ) { \n return EXCP_UDEF ; \n } \n * value = env -> cp15 . c6_region [ ri -> crm ] ; \n return 0 ; \n }", "idx": 12778}
{"project": "qemu", "commit_id": "eb7b5c35117bfb90dcfa881a0e3b23368c73fba6", "target": 1, "func": "static void iothread_instance_finalize ( Object * obj ) \n { \n IOThread * iothread = IOTHREAD ( obj ) ; \n iothread_stop ( obj , NULL ) ; \n qemu_cond_destroy ( & iothread -> init_done_cond ) ; \n qemu_mutex_destroy ( & iothread -> init_done_lock ) ; \n aio_context_unref ( iothread -> ctx ) ; ", "idx": 12801}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static void gen_isync ( DisasContext * ctx ) \n { \n if ( ! ctx -> pr ) { \n gen_check_tlb_flush ( ctx ) ; \n } \n gen_stop_exception ( ctx ) ; \n }", "idx": 12817}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static uint32_t taihu_cpld_readb ( void * opaque , hwaddr addr ) \n { \n taihu_cpld_t * cpld ; \n uint32_t ret ; \n cpld = opaque ; \n switch ( addr ) { \n case 0x0 : \n ret = cpld -> reg0 ; \n break ; \n case 0x1 : \n ret = cpld -> reg1 ; \n break ; \n default : \n ret = 0 ; \n break ; \n } \n return ret ; \n }", "idx": 12829}
{"project": "qemu", "commit_id": "6a2b3d89fa49ec060db646d196864a8fd15c10cf", "target": 0, "func": "static void spin_reset ( void * opaque ) \n { \n SpinState * s = opaque ; \n int i ; \n for ( i = 0 ; i < MAX_CPUS ; i ++ ) { \n SpinInfo * info = & s -> spin [ i ] ; \n info -> pir = i ; \n info -> r3 = i ; \n info -> addr = 1 ; \n } \n }", "idx": 12854}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject * parser_context_pop_token ( JSONParserContext * ctxt ) \n { \n qobject_decref ( ctxt -> current ) ; \n assert ( ! g_queue_is_empty ( ctxt -> buf ) ) ; \n ctxt -> current = g_queue_pop_head ( ctxt -> buf ) ; \n return ctxt -> current ; \n }", "idx": 12869}
{"project": "qemu", "commit_id": "d26d9e14c15837eba2b7447e8d15230bab8e0940", "target": 0, "func": "static void pc_fw_cfg_guest_info ( PcGuestInfo * guest_info ) \n { \n PcRomPciInfo * info ; \n if ( ! guest_info -> has_pci_info ) { \n return ; \n } \n info = g_malloc ( sizeof * info ) ; \n info -> w32_min = cpu_to_le64 ( guest_info -> pci_info . w32 . begin ) ; \n info -> w32_max = cpu_to_le64 ( guest_info -> pci_info . w32 . end ) ; \n info -> w64_min = cpu_to_le64 ( guest_info -> pci_info . w64 . begin ) ; \n info -> w64_max = cpu_to_le64 ( guest_info -> pci_info . w64 . end ) ; \n fw_cfg_add_file ( guest_info -> fw_cfg , \" \" , info , sizeof * info ) ; \n }", "idx": 12871}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "int spapr_rtas_register ( const char * name , spapr_rtas_fn fn ) \n { \n int i ; \n for ( i = 0 ; i < ( rtas_next - rtas_table ) ; i ++ ) { \n if ( strcmp ( name , rtas_table [ i ] . name ) == 0 ) { \n fprintf ( stderr , \" \\\" \\\" \\n \" , name ) ; \n exit ( 1 ) ; \n } \n } \n assert ( rtas_next < ( rtas_table + TOKEN_MAX ) ) ; \n rtas_next -> name = name ; \n rtas_next -> fn = fn ; \n return ( rtas_next ++ - rtas_table ) + TOKEN_BASE ; \n }", "idx": 12963}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_whitespace ( void ) \n { \n const char * str = \" \\t \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n long res = 999 ; \n int err ; \n err = qemu_strtol ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 0 ) ; \n g_assert ( endptr == str ) ; \n }", "idx": 12966}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t nvram_readw ( void * opaque , target_phys_addr_t addr ) \n { \n M48t59State * NVRAM = opaque ; \n uint32_t retval ; \n retval = m48t59_read ( NVRAM , addr ) << 8 ; \n retval |= m48t59_read ( NVRAM , addr + 1 ) ; \n return retval ; \n }", "idx": 12999}
{"project": "qemu", "commit_id": "412e0e81b17488e228b4f8451df6a4af26064bb4", "target": 0, "func": "static unsigned virtqueue_read_next_desc ( VirtIODevice * vdev , VRingDesc * desc , \n hwaddr desc_pa , unsigned int max ) \n { \n unsigned int next ; \n if ( ! ( desc -> flags & VRING_DESC_F_NEXT ) ) { \n return max ; \n } \n next = desc -> next ; \n smp_wmb ( ) ; \n if ( next >= max ) { \n error_report ( \" \" , next ) ; \n exit ( 1 ) ; \n } \n vring_desc_read ( vdev , desc , desc_pa , next ) ; \n return next ; \n }", "idx": 13046}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_POWER_abso ( void ) \n { \n if ( T0 == INT32_MIN ) { \n T0 = INT32_MAX ; \n xer_ov = 1 ; \n xer_so = 1 ; \n } else { \n T0 = - T0 ; \n xer_ov = 0 ; \n } \n }", "idx": 13091}
{"project": "qemu", "commit_id": "d3532a0db02296e687711b8cdc7791924efccea0", "target": 1, "func": "static int cirrus_bitblt_common_patterncopy ( CirrusVGAState * s , \n const uint8_t * src ) \n { \n uint8_t * dst ; \n dst = s -> vga . vram_ptr + ( s -> cirrus_blt_dstaddr & s -> cirrus_addr_mask ) ; \n if ( BLTUNSAFE ( s ) ) \n return 0 ; \n ( * s -> cirrus_rop ) ( s , dst , src , \n s -> cirrus_blt_dstpitch , 0 , \n s -> cirrus_blt_width , s -> cirrus_blt_height ) ; \n cirrus_invalidate_region ( s , s -> cirrus_blt_dstaddr , \n s -> cirrus_blt_dstpitch , s -> cirrus_blt_width , \n s -> cirrus_blt_height ) ; \n return 1 ; \n }", "idx": 13135}
{"project": "qemu", "commit_id": "225d4be7099f0cfdf5c85b4e4be1fa1e5169543c", "target": 0, "func": "void sparc_iommu_memory_rw ( void * opaque , target_phys_addr_t addr , \n uint8_t * buf , int len , int is_write ) \n { \n int l ; \n uint32_t flags ; \n target_phys_addr_t page , phys_addr ; \n while ( len > 0 ) { \n page = addr & TARGET_PAGE_MASK ; \n l = ( page + TARGET_PAGE_SIZE ) - addr ; \n if ( l > len ) \n l = len ; \n flags = iommu_page_get_flags ( opaque , page ) ; \n if ( ! ( flags & IOPTE_VALID ) ) \n return ; \n phys_addr = iommu_translate_pa ( opaque , addr , flags ) ; \n if ( is_write ) { \n if ( ! ( flags & IOPTE_WRITE ) ) \n return ; \n cpu_physical_memory_write ( phys_addr , buf , len ) ; \n } else { \n cpu_physical_memory_read ( phys_addr , buf , len ) ; \n } \n len -= l ; \n buf += l ; \n addr += l ; \n } \n }", "idx": 13176}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void * qemu_try_blockalign0 ( BlockDriverState * bs , size_t size ) \n { \n void * mem = qemu_try_blockalign ( bs , size ) ; \n if ( mem ) { \n memset ( mem , 0 , size ) ; \n } \n return mem ; \n }", "idx": 13180}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_underflow ( void ) \n { \n const char * str = \" \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n unsigned long res = 999 ; \n int err ; \n err = qemu_strtoul ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , - ERANGE ) ; \n g_assert_cmpint ( res , == , -1ul ) ; \n g_assert ( endptr == str + strlen ( str ) ) ; \n }", "idx": 13182}
{"project": "qemu", "commit_id": "675463d9b6b2c2b65a713a6d906aeebe9e6750ae", "target": 1, "func": "void isa_bus_irqs ( ISABus * bus , qemu_irq * irqs ) \n { \n if ( ! bus ) { \n hw_error ( \" \" ) ; \n } \n bus -> irqs = irqs ; \n }", "idx": 13248}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_buffer ( QEMUFile * f , const uint8_t * buf , int size ) \n { \n int l ; \n if ( f -> last_error ) { \n return ; \n } \n while ( size > 0 ) { \n l = IO_BUF_SIZE - f -> buf_index ; \n if ( l > size ) { \n l = size ; \n } \n memcpy ( f -> buf + f -> buf_index , buf , l ) ; \n f -> bytes_xfer += l ; \n if ( f -> ops -> writev_buffer ) { \n add_to_iovec ( f , f -> buf + f -> buf_index , l ) ; \n } \n f -> buf_index += l ; \n if ( f -> buf_index == IO_BUF_SIZE ) { \n qemu_fflush ( f ) ; \n } \n if ( qemu_file_get_error ( f ) ) { \n break ; \n } \n buf += l ; \n size -= l ; \n } \n }", "idx": 13270}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl190_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ; \n k -> init = pl190_init ; \n dc -> no_user = 1 ; \n dc -> reset = pl190_reset ; \n dc -> vmsd = & vmstate_pl190 ; \n }", "idx": 13293}
{"project": "qemu", "commit_id": "ab7a0f0b6dbe8836d490c736803abef6e3695e1f", "target": 1, "func": "static void pxa2xx_gpio_write ( void * opaque , hwaddr offset , \n uint64_t value , unsigned size ) \n { \n PXA2xxGPIOInfo * s = ( PXA2xxGPIOInfo * ) opaque ; \n int bank ; \n if ( offset >= 0x200 ) \n return ; \n bank = pxa2xx_gpio_regs [ offset ] . bank ; \n switch ( pxa2xx_gpio_regs [ offset ] . reg ) { \n case GPDR : \n s -> dir [ bank ] = value ; \n pxa2xx_gpio_handler_update ( s ) ; \n break ; \n case GPSR : \n s -> olevel [ bank ] |= value ; \n pxa2xx_gpio_handler_update ( s ) ; \n s -> gpsr [ bank ] = value ; \n break ; \n case GPCR : \n s -> olevel [ bank ] &= ~ value ; \n pxa2xx_gpio_handler_update ( s ) ; \n break ; \n case GRER : \n s -> rising [ bank ] = value ; \n break ; \n case GFER : \n s -> falling [ bank ] = value ; \n break ; \n case GAFR_L : \n s -> gafr [ bank * 2 ] = value ; \n break ; \n case GAFR_U : \n s -> gafr [ bank * 2 + 1 ] = value ; \n break ; \n case GEDR : \n s -> status [ bank ] &= ~ value ; \n pxa2xx_gpio_irq_update ( s ) ; \n break ; \n default : \n hw_error ( \" \" REG_FMT \" \\n \" , __FUNCTION__ , offset ) ; \n } \n }", "idx": 13324}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "opts_check_struct ( Visitor * v , Error * * errp )  \n { \n OptsVisitor * ov = to_ov ( v ) ; \n GHashTableIter iter ; \n GQueue * any ; \n if ( ov -> depth > 0 ) { \n return ; \n } \n g_hash_table_iter_init ( & iter , ov -> unprocessed_opts ) ; \n if ( g_hash_table_iter_next ( & iter , NULL , ( void * * ) & any ) ) { \n const QemuOpt * first ; \n first = g_queue_peek_head ( any ) ; \n error_setg ( errp , QERR_INVALID_PARAMETER , first -> name ) ; \n } \n }", "idx": 13337}
{"project": "qemu", "commit_id": "d5b27167e17e0d9393d6364703cc68e7f018023c", "target": 1, "func": "static int parse_chr ( DeviceState * dev , Property * prop , const char * str ) \n { \n CharDriverState * * ptr = qdev_get_prop_ptr ( dev , prop ) ; \n * ptr = qemu_chr_find ( str ) ; \n if ( * ptr == NULL ) { \n return - ENOENT ; \n } \n if ( ( * ptr ) -> assigned ) { \n return - EEXIST ; \n } \n ( * ptr ) -> assigned = 1 ; \n return 0 ; \n }", "idx": 13346}
{"project": "qemu", "commit_id": "bf26ae32a92a8446bd9db569f9cdb53cc272aaad", "target": 0, "func": "static void unrealize ( DeviceState * d , Error * * errp ) \n { \n sPAPRDRConnector * drc = SPAPR_DR_CONNECTOR ( d ) ; \n Object * root_container ; \n char name [ 256 ] ; \n Error * err = NULL ; \n trace_spapr_drc_unrealize ( spapr_drc_index ( drc ) ) ; \n root_container = container_get ( object_get_root ( ) , DRC_CONTAINER_PATH ) ; \n snprintf ( name , sizeof ( name ) , \" \" , spapr_drc_index ( drc ) ) ; \n object_property_del ( root_container , name , & err ) ; \n if ( err ) { \n error_report_err ( err ) ; \n object_unref ( OBJECT ( drc ) ) ; \n } \n }", "idx": 13375}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static void nbd_co_receive_reply ( NBDClientSession * s , \n NBDRequest * request , \n NBDReply * reply , \n QEMUIOVector * qiov ) \n { \n int ret ; \n qemu_coroutine_yield ( ) ; \n * reply = s -> reply ; \n if ( reply -> handle != request -> handle || \n ! s -> ioc ) { \n reply -> error = EIO ; \n } else { \n if ( qiov && reply -> error == 0 ) { \n ret = nbd_wr_syncv ( s -> ioc , qiov -> iov , qiov -> niov , request -> len , \n true , NULL ) ; \n if ( ret != request -> len ) { \n reply -> error = EIO ; \n } \n } \n s -> reply . handle = 0 ; \n } \n }", "idx": 13377}
{"project": "qemu", "commit_id": "554f802da3f8b09b16b9a84ad5847b2eb0e9ad2b", "target": 1, "func": "void pcie_cap_slot_hotplug_cb ( HotplugHandler * hotplug_dev , DeviceState * dev , \n Error * * errp ) \n { \n uint8_t * exp_cap ; \n PCIDevice * pci_dev = PCI_DEVICE ( dev ) ; \n pcie_cap_slot_hotplug_common ( PCI_DEVICE ( hotplug_dev ) , dev , & exp_cap , errp ) ; \n if ( ! dev -> hotplugged ) { \n pci_word_test_and_set_mask ( exp_cap + PCI_EXP_SLTSTA , \n PCI_EXP_SLTSTA_PDS ) ; \n return ; \n } \n assert ( PCI_FUNC ( pci_dev -> devfn ) == 0 ) ; \n pci_word_test_and_set_mask ( exp_cap + PCI_EXP_SLTSTA , \n PCI_EXP_SLTSTA_PDS ) ; \n pcie_cap_slot_event ( PCI_DEVICE ( hotplug_dev ) , PCI_EXP_HP_EV_PDC ) ; \n }", "idx": 13396}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void do_info_snapshots ( Monitor * mon ) \n { \n DriveInfo * dinfo ; \n BlockDriverState * bs , * bs1 ; \n QEMUSnapshotInfo * sn_tab , * sn ; \n int nb_sns , i ; \n char buf [ 256 ] ; \n bs = get_bs_snapshots ( ) ; \n if ( ! bs ) { \n monitor_printf ( mon , \" \\n \" ) ; \n return ; \n } \n monitor_printf ( mon , \" \" ) ; \n TAILQ_FOREACH ( dinfo , & drives , next )  { \n bs1 = dinfo -> bdrv ; \n if ( bdrv_has_snapshot ( bs1 ) ) { \n if ( bs == bs1 ) \n monitor_printf ( mon , \" \" , bdrv_get_device_name ( bs1 ) ) ; \n } \n } \n monitor_printf ( mon , \" \\n \" ) ; \n nb_sns = bdrv_snapshot_list ( bs , & sn_tab ) ; \n if ( nb_sns < 0 ) { \n monitor_printf ( mon , \" \\n \" , nb_sns ) ; \n return ; \n } \n monitor_printf ( mon , \" \\n \" , \n bdrv_get_device_name ( bs ) ) ; \n monitor_printf ( mon , \" \\n \" , bdrv_snapshot_dump ( buf , sizeof ( buf ) , NULL ) ) ; \n for ( i = 0 ; i < nb_sns ; i ++ ) { \n sn = & sn_tab [ i ] ; \n monitor_printf ( mon , \" \\n \" , bdrv_snapshot_dump ( buf , sizeof ( buf ) , sn ) ) ; \n } \n qemu_free ( sn_tab ) ; \n }", "idx": 13424}
{"project": "qemu", "commit_id": "b08d0ea0446aa91f373c9df4254ba3bc4ee84098", "target": 0, "func": "static SCSIRequest * scsi_block_new_request ( SCSIDevice * d , uint32_t tag , \n uint32_t lun , uint8_t * buf , \n void * hba_private ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; \n switch ( buf [ 0 ] ) { \n case READ_6 : \n case READ_10 : \n case READ_12 : \n case READ_16 : \n case VERIFY_10 : \n case VERIFY_12 : \n case VERIFY_16 : \n case WRITE_6 : \n case WRITE_10 : \n case WRITE_12 : \n case WRITE_16 : \n case WRITE_VERIFY_10 : \n case WRITE_VERIFY_12 : \n case WRITE_VERIFY_16 : \n if ( bdrv_get_flags ( s -> qdev . conf . bs ) & BDRV_O_NOCACHE ) { \n break ; \n } \n if ( s -> qdev . type == TYPE_ROM ) { \n break ; \n } \n return scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , \n hba_private ) ; \n } \n return scsi_req_alloc ( & scsi_generic_req_ops , & s -> qdev , tag , lun , \n hba_private ) ; \n }", "idx": 13427}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_4xx_softmmu ( CPUPPCState * env ) \n { \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  env -> excp_vectors [ POWERPC_EXCP_CRITICAL ] = 0x00000100 ; \n env -> excp_vectors [ POWERPC_EXCP_MCHECK ] = 0x00000200 ; \n env -> excp_vectors [ POWERPC_EXCP_DSI ] = 0x00000300 ; \n env -> excp_vectors [ POWERPC_EXCP_ISI ] = 0x00000400 ; \n env -> excp_vectors [ POWERPC_EXCP_EXTERNAL ] = 0x00000500 ; \n env -> excp_vectors [ POWERPC_EXCP_ALIGN ] = 0x00000600 ; \n env -> excp_vectors [ POWERPC_EXCP_PROGRAM ] = 0x00000700 ; \n env -> excp_vectors [ POWERPC_EXCP_SYSCALL ] = 0x00000C00 ; \n env -> excp_vectors [ POWERPC_EXCP_PIT ] = 0x00001000 ; \n env -> excp_vectors [ POWERPC_EXCP_FIT ] = 0x00001010 ; \n env -> excp_vectors [ POWERPC_EXCP_WDT ] = 0x00001020 ; \n env -> excp_vectors [ POWERPC_EXCP_DTLB ] = 0x00001100 ; \n env -> excp_vectors [ POWERPC_EXCP_ITLB ] = 0x00001200 ; \n env -> excp_vectors [ POWERPC_EXCP_DEBUG ] = 0x00002000 ; \n env -> excp_prefix = 0x00000000 ; \n env -> ivor_mask = 0x0000FFF0 ; \n env -> ivpr_mask = 0xFFFF0000 ; \n env -> hreset_vector = 0xFFFFFFFCUL ; \n #endif \n }", "idx": 13449}
{"project": "qemu", "commit_id": "56c4bfb3f07f3107894c00281276aea4f5e8834d", "target": 1, "func": "int cpu_get_dump_info ( ArchDumpInfo * info ) \n { \n return -1 ; \n }", "idx": 13459}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "void helper_st_asi ( CPUSPARCState * env , target_ulong addr , target_ulong val , \n int asi , int size ) \n { \n #ifdef DEBUG_ASI \n dump_asi ( \" \" , addr , asi , size , val ) ; \n #endif \n if ( asi < 0x80 ) { \n helper_raise_exception ( env , TT_PRIV_ACT ) ; \n } \n helper_check_align ( env , addr , size - 1 ) ; \n addr = asi_address_mask ( env , asi , addr ) ; \n switch ( asi ) { \n case 0x88 : \n case 0x89 : \n switch ( size ) { \n case 2 : \n val = bswap16 ( val ) ; \n break ; \n case 4 : \n val = bswap32 ( val ) ; \n break ; \n case 8 : \n val = bswap64 ( val ) ; \n break ; \n default : \n break ; \n } \n default : \n break ; \n } \n switch ( asi ) { \n case 0x80 : \n case 0x88 : \n { \n switch ( size ) { \n case 1 : \n stb_raw ( addr , val ) ; \n break ; \n case 2 : \n stw_raw ( addr , val ) ; \n break ; \n case 4 : \n stl_raw ( addr , val ) ; \n break ; \n case 8 : \n default : \n stq_raw ( addr , val ) ; \n break ; \n } \n } \n break ; \n case 0x81 : \n case 0x89 : \n return ; \n case 0x82 : \n case 0x83 : \n case 0x8a : \n case 0x8b : \n default : \n helper_raise_exception ( env , TT_DATA_ACCESS ) ; \n return ; \n } \n }", "idx": 13467}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf_intc_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n int offset ; \n mcf_intc_state * s = ( mcf_intc_state * ) opaque ; \n offset = addr & 0xff ; \n if ( offset >= 0x40 && offset < 0x80 ) { \n int n = offset - 0x40 ; \n s -> icr [ n ] = val ; \n if ( val == 0 ) \n s -> enabled &= ~ ( 1ull << n ) ; \n else \n s -> enabled |= ( 1ull << n ) ; \n mcf_intc_update ( s ) ; \n return ; \n } \n switch ( offset ) { \n case 0x00 : case 0x04 : \n return ; \n case 0x08 : \n s -> imr = ( s -> imr & 0xffffffff ) | ( ( uint64_t ) val << 32 ) ; \n break ; \n case 0x0c : \n s -> imr = ( s -> imr & 0xffffffff00000000ull ) | ( uint32_t ) val ; \n break ; \n default : \n hw_error ( \" \\n \" , offset ) ; \n break ; \n } \n mcf_intc_update ( s ) ; \n }", "idx": 13499}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_write ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors ) \n { \n BDRVCowState * s = bs -> opaque ; \n int ret ; \n ret = bdrv_pwrite ( bs -> file , s -> cow_sectors_offset + sector_num * 512 , \n buf , nb_sectors * 512 ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return cow_update_bitmap ( bs , sector_num , nb_sectors ) ; \n }", "idx": 13515}
{"project": "qemu", "commit_id": "afff2b15e89ac81c113f2ebfd729aaa02b40edb6", "target": 1, "func": "QemuConsole * qemu_console_lookup_by_device ( DeviceState * dev , uint32_t head ) \n { \n Error * local_err = NULL ; \n Object * obj ; \n uint32_t h ; \n int i ; \n for ( i = 0 ; i < nb_consoles ; i ++ ) { \n if ( ! consoles [ i ] ) { \n continue ; \n } \n obj = object_property_get_link ( OBJECT ( consoles [ i ] ) , \n \" \" , & local_err ) ; \n if ( DEVICE ( obj ) != dev ) { \n continue ; \n } \n h = object_property_get_int ( OBJECT ( consoles [ i ] ) , \n \" \" , & local_err ) ; \n if ( h != head ) { \n continue ; \n } \n return consoles [ i ] ; \n } \n return NULL ; \n }", "idx": 13529}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_file_get_error ( QEMUFile * f ) \n { \n return f -> last_error ; \n }", "idx": 13546}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_fixed_ioport_init ( PCIXenPlatformState * s ) \n { \n register_ioport_write ( XEN_PLATFORM_IOPORT , 16 , 4 , platform_fixed_ioport_writel , s ) ; \n register_ioport_write ( XEN_PLATFORM_IOPORT , 16 , 2 , platform_fixed_ioport_writew , s ) ; \n register_ioport_write ( XEN_PLATFORM_IOPORT , 16 , 1 , platform_fixed_ioport_writeb , s ) ; \n register_ioport_read ( XEN_PLATFORM_IOPORT , 16 , 2 , platform_fixed_ioport_readw , s ) ; \n register_ioport_read ( XEN_PLATFORM_IOPORT , 16 , 1 , platform_fixed_ioport_readb , s ) ; \n }", "idx": 13565}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fctidz ( CPUPPCState * env , uint64_t arg ) \n { \n CPU_DoubleU farg ; \n farg . ll = arg ; \n if ( unlikely ( float64_is_signaling_nan ( farg . d ) ) ) { \n farg . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN | \n POWERPC_EXCP_FP_VXCVI ) ; \n } else if ( unlikely ( float64_is_quiet_nan ( farg . d ) || \n float64_is_infinity ( farg . d ) ) ) { \n farg . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXCVI ) ; \n } else { \n farg . ll = float64_to_int64_round_to_zero ( farg . d , & env -> fp_status ) ; \n } \n return farg . ll ; \n }", "idx": 13569}
{"project": "qemu", "commit_id": "7ad4c7200111d20eb97eed4f46b6026e3f0b0eef", "target": 0, "func": "void g_free ( void * ptr ) \n { \n __coverity_free__ ( ptr ) ; \n __coverity_mark_as_afm_freed__ ( ptr , AFM_free ) ; \n }", "idx": 13592}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_buffer ( QEMUFile * f , void * pv , size_t size ) \n { \n uint8_t * v = pv ; \n qemu_get_buffer ( f , v , size ) ; \n return 0 ; \n }", "idx": 13660}
{"project": "qemu", "commit_id": "94d81ae896810beafa60c85b88e991daa986e1fc", "target": 1, "func": "static void quit_handler ( int sig ) \n { \n if ( ga_is_frozen ( ga_state ) ) { \n return ; \n g_debug ( \" \" , sig ) ; \n if ( g_main_loop_is_running ( ga_state -> main_loop ) ) { \n g_main_loop_quit ( ga_state -> main_loop ) ;", "idx": 13713}
{"project": "qemu", "commit_id": "61a5872fd66be718ad022102bf813d7e4e9324c5", "target": 1, "func": "static int tcp_close ( MigrationState * s ) \n { \n DPRINTF ( \" \\n \" ) ; \n if ( s -> fd != -1 ) { \n close ( s -> fd ) ; \n s -> fd = -1 ; \n } \n return 0 ; \n }", "idx": 13714}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_breakpoint_remove_by_ref ( CPUState * env , CPUBreakpoint * breakpoint ) \n { \n #if defined ( TARGET_HAS_ICE )  \n  \n  TAILQ_REMOVE ( & env -> breakpoints , breakpoint , entry ) ; \n breakpoint_invalidate ( env , breakpoint -> pc ) ; \n qemu_free ( breakpoint ) ; \n #endif \n }", "idx": 13753}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_store ( DisasContext * ctx , TCGv EA , \n int reg , int size ) \n { \n int l1 ; \n tcg_gen_trunc_tl_i32 ( cpu_crf [ 0 ] , cpu_so ) ; \n l1 = gen_new_label ( ) ; \n tcg_gen_brcond_tl ( TCG_COND_NE , EA , cpu_reserve , l1 ) ; \n tcg_gen_ori_i32 ( cpu_crf [ 0 ] , cpu_crf [ 0 ] , 1 << CRF_EQ ) ; \n #if defined ( TARGET_PPC64 )  \n  \n  if ( size == 8 ) { \n gen_qemu_st64 ( ctx , cpu_gpr [ reg ] , EA ) ; \n } else \n #endif \n if ( size == 4 ) { \n gen_qemu_st32 ( ctx , cpu_gpr [ reg ] , EA ) ; \n } else if ( size == 2 ) { \n gen_qemu_st16 ( ctx , cpu_gpr [ reg ] , EA ) ; \n #if defined ( TARGET_PPC64 )  \n  \n   } else if ( size == 16 ) { \n TCGv gpr1 , gpr2 , EA8 ; \n if ( unlikely ( ctx -> le_mode ) ) { \n gpr1 = cpu_gpr [ reg + 1 ] ; \n gpr2 = cpu_gpr [ reg ] ; \n } else { \n gpr1 = cpu_gpr [ reg ] ; \n gpr2 = cpu_gpr [ reg + 1 ] ; \n } \n gen_qemu_st64 ( ctx , gpr1 , EA ) ; \n EA8 = tcg_temp_local_new ( ) ; \n gen_addr_add ( ctx , EA8 , EA , 8 ) ; \n gen_qemu_st64 ( ctx , gpr2 , EA8 ) ; \n tcg_temp_free ( EA8 ) ; \n #endif  \n  \n  } else { \n gen_qemu_st8 ( ctx , cpu_gpr [ reg ] , EA ) ; \n } \n gen_set_label ( l1 ) ; \n tcg_gen_movi_tl ( cpu_reserve , -1 ) ; \n }", "idx": 13758}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cirrus_linear_bitblt_read ( void * opaque , \n target_phys_addr_t addr , \n unsigned size ) \n { \n CirrusVGAState * s = opaque ; \n uint32_t ret ; \n ( void ) s ; \n ret = 0xff ; \n return ret ; \n }", "idx": 13773}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "bochs_co_preadv ( BlockDriverState * bs , uint64_t offset , uint64_t bytes , \n QEMUIOVector * qiov , int flags )  \n { \n BDRVBochsState * s = bs -> opaque ; \n uint64_t sector_num = offset >> BDRV_SECTOR_BITS ; \n int nb_sectors = bytes >> BDRV_SECTOR_BITS ; \n uint64_t bytes_done = 0 ; \n QEMUIOVector local_qiov ; \n int ret ; \n assert ( ( offset & ( BDRV_SECTOR_SIZE - 1 ) ) == 0 ) ; \n assert ( ( bytes & ( BDRV_SECTOR_SIZE - 1 ) ) == 0 ) ; \n qemu_iovec_init ( & local_qiov , qiov -> niov ) ; \n qemu_co_mutex_lock ( & s -> lock ) ; \n while ( nb_sectors > 0 ) { \n int64_t block_offset = seek_to_sector ( bs , sector_num ) ; \n if ( block_offset < 0 ) { \n ret = block_offset ; \n goto fail ; \n } \n qemu_iovec_reset ( & local_qiov ) ; \n qemu_iovec_concat ( & local_qiov , qiov , bytes_done , 512 ) ; \n if ( block_offset > 0 ) { \n ret = bdrv_co_preadv ( bs -> file -> bs , block_offset , 512 , \n & local_qiov , 0 ) ; \n if ( ret < 0 ) { \n goto fail ; \n } \n } else { \n qemu_iovec_memset ( & local_qiov , 0 , 0 , 512 ) ; \n } \n nb_sectors -- ; \n sector_num ++ ; \n bytes_done += 512 ; \n } \n ret = 0 ; \n fail : \n qemu_co_mutex_unlock ( & s -> lock ) ; \n qemu_iovec_destroy ( & local_qiov ) ; \n return ret ; \n }", "idx": 13802}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void nested_struct_cleanup ( UserDefNested * udnp ) \n { \n qapi_free_UserDefNested ( udnp ) ; \n }", "idx": 13820}
{"project": "qemu", "commit_id": "f94b3f64e6572c8cec73a538588f7cd754bcfa88", "target": 1, "func": "static void test_qga_fsfreeze_and_thaw ( gconstpointer fix ) \n { \n const TestFixture * fixture = fix ; \n QDict * ret ; \n const gchar * status ; \n ret = qmp_fd ( fixture -> fd , \" \" ) ; \n g_assert_nonnull ( ret ) ; \n qmp_assert_no_error ( ret ) ; \n QDECREF ( ret ) ; \n ret = qmp_fd ( fixture -> fd , \" \" ) ; \n g_assert_nonnull ( ret ) ; \n qmp_assert_no_error ( ret ) ; \n status = qdict_get_try_str ( ret , \" \" ) ; \n g_assert_cmpstr ( status , == , \" \" ) ; \n QDECREF ( ret ) ; \n ret = qmp_fd ( fixture -> fd , \" \" ) ; \n g_assert_nonnull ( ret ) ; \n qmp_assert_no_error ( ret ) ; \n QDECREF ( ret ) ; \n }", "idx": 13886}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int stdio_pclose ( void * opaque ) \n { \n QEMUFileStdio * s = opaque ; \n int ret ; \n ret = pclose ( s -> stdio_file ) ; \n if ( ret == -1 ) { \n ret = - errno ; \n } else if ( ! WIFEXITED ( ret ) || WEXITSTATUS ( ret ) != 0 ) { \n ret = - EIO ; \n } \n g_free ( s ) ; \n return ret ; \n }", "idx": 14027}
{"project": "qemu", "commit_id": "bd16430777cc3d25930e479fdbe290d92cec0888", "target": 1, "func": "static void ahci_irq_lower ( AHCIState * s , AHCIDevice * dev ) \n { \n AHCIPCIState * d = container_of ( s , AHCIPCIState , ahci ) ; \n DPRINTF ( 0 , \" \\n \" ) ; \n if ( ! msi_enabled ( PCI_DEVICE ( d ) ) ) { \n qemu_irq_lower ( s -> irq ) ; \n } \n }", "idx": 14034}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_realizefn ( DeviceState * dev , Error * * errp ) \n { \n MouseState * s = ADB_MOUSE ( dev ) ; \n ADBMouseClass * amc = ADB_MOUSE_GET_CLASS ( dev ) ; \n amc -> parent_realize ( dev , errp ) ; \n qemu_add_mouse_event_handler ( adb_mouse_event , s , 0 , \" \" ) ; \n }", "idx": 14044}
{"project": "qemu", "commit_id": "c9f82d013be0d8d9c5d9f51bb76e337a0a5a5cac", "target": 1, "func": "static void gen_dcbz ( DisasContext * ctx ) \n { \n TCGv tcgv_addr ; \n TCGv_i32 tcgv_is_dcbzl ; \n int is_dcbzl = ctx -> opcode & 0x00200000 ? 1 : 0 ; \n gen_set_access_type ( ctx , ACCESS_CACHE ) ; \n tcgv_addr = tcg_temp_new ( ) ; \n tcgv_is_dcbzl = tcg_const_i32 ( is_dcbzl ) ; \n gen_addr_reg_index ( ctx , tcgv_addr ) ; \n gen_helper_dcbz ( cpu_env , tcgv_addr , tcgv_is_dcbzl ) ; \n tcg_temp_free ( tcgv_addr ) ; \n tcg_temp_free_i32 ( tcgv_is_dcbzl ) ; \n }", "idx": 14099}
{"project": "qemu", "commit_id": "a83000f5e3fac30a7f213af1ba6a8f827622854d", "target": 0, "func": "static void spapr_vio_quiesce_one ( VIOsPAPRDevice * dev ) \n { \n if ( dev -> tcet ) { \n spapr_tce_reset ( dev -> tcet ) ; \n } \n free_crq ( dev ) ; \n }", "idx": 14118}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "PXA2xxMMCIState * pxa2xx_mmci_init ( MemoryRegion * sysmem , \n hwaddr base , \n BlockDriverState * bd , qemu_irq irq , \n qemu_irq rx_dma , qemu_irq tx_dma ) \n { \n PXA2xxMMCIState * s ; \n s = ( PXA2xxMMCIState * ) g_malloc0 ( sizeof ( PXA2xxMMCIState ) ) ; \n s -> irq = irq ; \n s -> rx_dma = rx_dma ; \n s -> tx_dma = tx_dma ; \n memory_region_init_io ( & s -> iomem , NULL , & pxa2xx_mmci_ops , s , \n \" \" , 0x00100000 ) ; \n memory_region_add_subregion ( sysmem , base , & s -> iomem ) ; \n s -> card = sd_init ( bd , false ) ; \n if ( s -> card == NULL ) { \n exit ( 1 ) ; \n } \n register_savevm ( NULL , \" \" , 0 , 0 , \n pxa2xx_mmci_save , pxa2xx_mmci_load , s ) ; \n return s ; \n }", "idx": 14121}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "int64_t timerlist_deadline_ns ( QEMUTimerList * timer_list ) \n { \n int64_t delta ; \n if ( ! timer_list -> clock -> enabled || ! timer_list -> active_timers ) { \n return -1 ; \n } \n delta = timer_list -> active_timers -> expire_time - \n qemu_clock_get_ns ( timer_list -> clock -> type ) ; \n if ( delta <= 0 ) { \n return 0 ; \n } \n return delta ; \n }", "idx": 14130}
{"project": "qemu", "commit_id": "17e2377abf16c3951d7d34521ceade4d7dc31d01", "target": 0, "func": "void * qemu_mallocz ( size_t size ) \n { \n void * ptr ; \n ptr = qemu_malloc ( size ) ; \n if ( ! ptr ) \n return NULL ; \n memset ( ptr , 0 , size ) ; \n return ptr ; \n }", "idx": 14132}
{"project": "qemu", "commit_id": "0b466065eba289c437e3edc2e97144fc5cd6a889", "target": 0, "func": "sosendoob ( struct socket * so )  \n { \n struct sbuf * sb = & so -> so_rcv ; \n char buff [ 2048 ] ; \n int n , len ; \n DEBUG_CALL ( \" \" ) ; \n DEBUG_ARG ( \" \" , so ) ; \n DEBUG_ARG ( \" \" , sb -> sb_cc ) ; \n if ( so -> so_urgc > 2048 ) \n so -> so_urgc = 2048 ; \n if ( sb -> sb_rptr < sb -> sb_wptr ) { \n n = slirp_send ( so , sb -> sb_rptr , so -> so_urgc , ( MSG_OOB ) ) ; \n so -> so_urgc -= n ; \n DEBUG_MISC ( ( dfd , \" \\n \" , n , so -> so_urgc ) ) ; \n } else { \n len = ( sb -> sb_data + sb -> sb_datalen ) - sb -> sb_rptr ; \n if ( len > so -> so_urgc ) len = so -> so_urgc ; \n memcpy ( buff , sb -> sb_rptr , len ) ; \n so -> so_urgc -= len ; \n if ( so -> so_urgc ) { \n n = sb -> sb_wptr - sb -> sb_data ; \n if ( n > so -> so_urgc ) n = so -> so_urgc ; \n memcpy ( ( buff + len ) , sb -> sb_data , n ) ; \n so -> so_urgc -= n ; \n len += n ; \n } \n n = slirp_send ( so , buff , len , ( MSG_OOB ) ) ; \n #ifdef DEBUG \n if ( n != len ) \n DEBUG_ERROR ( ( dfd , \" \\n \" ) ) ; \n #endif \n DEBUG_MISC ( ( dfd , \" \\n \" , n , so -> so_urgc ) ) ; \n } \n sb -> sb_cc -= n ; \n sb -> sb_rptr += n ; \n if ( sb -> sb_rptr >= ( sb -> sb_data + sb -> sb_datalen ) ) \n sb -> sb_rptr -= sb -> sb_datalen ; \n return n ; \n }", "idx": 14133}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbiel ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n gen_helper_tlbie ( cpu_env , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n #endif \n }", "idx": 14147}
{"project": "qemu", "commit_id": "f9aef99b3e6df88036436b0d3dc3d504b9346c8c", "target": 1, "func": "static void local_mapped_file_attr ( FsContext * ctx , const char * path , \n struct stat * stbuf ) \n { \n FILE * fp ; \n char buf [ ATTR_MAX ] ; \n char * attr_path ; \n attr_path = local_mapped_attr_path ( ctx , path ) ; \n fp = local_fopen ( attr_path , \" \" ) ; \n g_free ( attr_path ) ; \n if ( ! fp ) { \n return ; \n } \n memset ( buf , 0 , ATTR_MAX ) ; \n while ( fgets ( buf , ATTR_MAX , fp ) ) { \n if ( ! strncmp ( buf , \" \" , 10 ) ) { \n stbuf -> st_uid = atoi ( buf + 11 ) ; \n } else if ( ! strncmp ( buf , \" \" , 10 ) ) { \n stbuf -> st_gid = atoi ( buf + 11 ) ; \n } else if ( ! strncmp ( buf , \" \" , 11 ) ) { \n stbuf -> st_mode = atoi ( buf + 12 ) ; \n } else if ( ! strncmp ( buf , \" \" , 11 ) ) { \n stbuf -> st_rdev = atoi ( buf + 12 ) ; \n } \n memset ( buf , 0 , ATTR_MAX ) ; \n } \n fclose ( fp ) ; \n }", "idx": 14176}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static QOSState * qvirtio_scsi_start ( const char * extra_opts ) \n { \n const char * cmd = \" \" \n \" \" \n \" \" ; \n return qtest_pc_boot ( cmd , extra_opts ?  : \" \" ) ; \n }", "idx": 14231}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int fread_targphys_ok ( target_phys_addr_t dst_addr , size_t nbytes , FILE * f ) \n { \n return fread_targphys ( dst_addr , nbytes , f ) == nbytes ; \n }", "idx": 14236}
{"project": "qemu", "commit_id": "71200fb9664c2967a1cdd22b68b0da3a8b2b3eb7", "target": 1, "func": "static CharDriverState * qemu_chr_open_stdio ( const char * id , \n ChardevBackend * backend , \n ChardevReturn * ret , \n Error * * errp ) \n { \n ChardevStdio * opts = backend -> u . stdio . data ; \n CharDriverState * chr ; \n struct sigaction act ; \n ChardevCommon * common = qapi_ChardevStdio_base ( opts ) ; \n if ( is_daemonized ( ) ) { \n error_setg ( errp , \" \" ) ; \n if ( stdio_in_use ) { \n error_setg ( errp , \" \" ) ; \n stdio_in_use = true ; \n old_fd0_flags = fcntl ( 0 , F_GETFL ) ; \n tcgetattr ( 0 , & oldtty ) ; \n qemu_set_nonblock ( 0 ) ; \n atexit ( term_exit ) ; \n memset ( & act , 0 , sizeof ( act ) ) ; \n act . sa_handler = term_stdio_handler ; \n sigaction ( SIGCONT , & act , NULL ) ; \n chr = qemu_chr_open_fd ( 0 , 1 , common , errp ) ; \n chr -> chr_close = qemu_chr_close_stdio ; \n chr -> chr_set_echo = qemu_chr_set_echo_stdio ; \n if ( opts -> has_signal ) { \n stdio_allow_signal = opts -> signal ; \n qemu_chr_fe_set_echo ( chr , false ) ; \n return chr ;", "idx": 14244}
{"project": "qemu", "commit_id": "cf7c0ff521b0710079aa28f21937fb7dbb3f5224", "target": 0, "func": "static GSList * nvdimm_get_plugged_device_list ( void ) \n { \n GSList * list = NULL ; \n object_child_foreach ( qdev_get_machine ( ) , nvdimm_plugged_device_list , \n & list ) ; \n return list ; \n }", "idx": 14267}
{"project": "qemu", "commit_id": "38d8dfa193e9a45f0f08b06aab2ba2a94f40a041", "target": 0, "func": "void ide_dma_cancel ( BMDMAState * bm ) \n { \n if ( bm -> status & BM_STATUS_DMAING ) { \n bm -> status &= ~ BM_STATUS_DMAING ; \n bm -> unit = -1 ; \n bm -> dma_cb = NULL ; \n if ( bm -> aiocb ) { \n #ifdef DEBUG_AIO \n printf ( \" \\n \" ) ; \n #endif \n bdrv_aio_cancel ( bm -> aiocb ) ; \n bm -> aiocb = NULL ; \n } \n } \n }", "idx": 14271}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fre ( CPUPPCState * env , uint64_t arg ) \n { \n CPU_DoubleU farg ; \n farg . ll = arg ; \n if ( unlikely ( float64_is_signaling_nan ( farg . d ) ) ) { \n fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN ) ; \n } \n farg . d = float64_div ( float64_one , farg . d , & env -> fp_status ) ; \n return farg . d ; \n }", "idx": 14272}
{"project": "qemu", "commit_id": "7bb6edb0e3dd78d74e0ac980cf6c0a07307f61bf", "target": 1, "func": "static int virtio_rng_device_exit ( DeviceState * qdev ) \n { \n VirtIORNG * vrng = VIRTIO_RNG ( qdev ) ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( qdev ) ; \n timer_del ( vrng -> rate_limit_timer ) ; \n timer_free ( vrng -> rate_limit_timer ) ; \n unregister_savevm ( qdev , \" \" , vrng ) ; \n virtio_cleanup ( vdev ) ; \n return 0 ; \n }", "idx": 14312}
{"project": "qemu", "commit_id": "bc5008a832f95aae86efce844382e64d54da2146", "target": 1, "func": "static struct pathelem * add_entry ( struct pathelem * root , const char * name , \n unsigned type ) \n { \n struct pathelem * * e ; \n root -> num_entries ++ ; \n root = realloc ( root , sizeof ( * root ) \n + sizeof ( root -> entries [ 0 ] ) * root -> num_entries ) ; \n e = & root -> entries [ root -> num_entries - 1 ] ; \n * e = new_entry ( root -> pathname , root , name ) ; \n if ( is_dir_maybe ( type ) ) { \n * e = add_dir_maybe ( * e ) ; \n } \n return root ; \n }", "idx": 14354}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n VirtioDeviceClass * vdc = VIRTIO_DEVICE_CLASS ( klass ) ; \n dc -> exit = virtio_balloon_device_exit ; \n dc -> props = virtio_balloon_properties ; \n set_bit ( DEVICE_CATEGORY_MISC , dc -> categories ) ; \n vdc -> init = virtio_balloon_device_init ; \n vdc -> get_config = virtio_balloon_get_config ; \n vdc -> set_config = virtio_balloon_set_config ; \n vdc -> get_features = virtio_balloon_get_features ; \n }", "idx": 14360}
{"project": "qemu", "commit_id": "1d5b8d770d1215b41ae32c881984b1d048b2f932", "target": 1, "func": "static KeyValue * copy_key_value ( KeyValue * src ) \n { \n KeyValue * dst = g_new ( KeyValue , 1 ) ; \n memcpy ( dst , src , sizeof ( * src ) ) ; \n return dst ; ", "idx": 14367}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_sub_suov ( CPUTriCoreState * env , target_ulong r1 , \n target_ulong r2 ) \n { \n int64_t t1 = extract64 ( r1 , 0 , 32 ) ; \n int64_t t2 = extract64 ( r2 , 0 , 32 ) ; \n int64_t result = t1 - t2 ; \n return suov32 ( env , result ) ; \n }", "idx": 14373}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t icp_pit_read ( void * opaque , target_phys_addr_t offset , \n unsigned size ) \n { \n icp_pit_state * s = ( icp_pit_state * ) opaque ; \n int n ; \n n = offset >> 8 ; \n if ( n > 2 ) { \n hw_error ( \" \\n \" , __func__ , n ) ; \n } \n return arm_timer_read ( s -> timer [ n ] , offset & 0xff ) ; \n }", "idx": 14386}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static void v9fs_synth_direntry ( V9fsSynthNode * node , \n struct dirent * entry , off_t off ) \n { \n strcpy ( entry -> d_name , node -> name ) ; \n entry -> d_ino = node -> attr -> inode ; \n entry -> d_off = off + 1 ; \n }", "idx": 14390}
{"project": "qemu", "commit_id": "2399d4e7cec22ecf1c51062d2ebfd45220dbaace", "target": 0, "func": "static void gen_nop_hint ( DisasContext * s , int val ) \n { \n switch ( val ) { \n case 1 : \n if ( ! parallel_cpus ) { \n gen_set_pc_im ( s , s -> pc ) ; \n s -> base . is_jmp = DISAS_YIELD ; \n } \n break ; \n case 3 : \n gen_set_pc_im ( s , s -> pc ) ; \n s -> base . is_jmp = DISAS_WFI ; \n break ; \n case 2 : \n if ( ! parallel_cpus ) { \n gen_set_pc_im ( s , s -> pc ) ; \n s -> base . is_jmp = DISAS_WFE ; \n } \n break ; \n case 4 : \n case 5 : \n default : \n break ; \n } \n }", "idx": 14396}
{"project": "qemu", "commit_id": "1d3323de5fe5656844ea57a16eb432f09a366140", "target": 0, "func": "static void vnc_dpy_setdata ( DisplayState * ds ) \n { \n }", "idx": 14402}
{"project": "qemu", "commit_id": "cf528b89580797050b8cf60fee6247f35531a675", "target": 0, "func": "struct vhost_net * vhost_net_init ( NetClientState * backend , int devfd , \n bool force ) \n { \n int r ; \n struct vhost_net * net = g_malloc ( sizeof * net ) ; \n if ( ! backend ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto fail ; \n } \n r = vhost_net_get_fd ( backend ) ; \n if ( r < 0 ) { \n goto fail ; \n } \n net -> nc = backend ; \n net -> dev . backend_features = tap_has_vnet_hdr ( backend ) ? 0 : \n ( 1 << VHOST_NET_F_VIRTIO_NET_HDR ) ; \n net -> backend = r ; \n net -> dev . nvqs = 2 ; \n net -> dev . vqs = net -> vqs ; \n r = vhost_dev_init ( & net -> dev , devfd , \" \" , force ) ; \n if ( r < 0 ) { \n goto fail ; \n } \n if ( ! tap_has_vnet_hdr_len ( backend , \n sizeof ( struct virtio_net_hdr_mrg_rxbuf ) ) ) { \n net -> dev . features &= ~ ( 1 << VIRTIO_NET_F_MRG_RXBUF ) ; \n } \n if ( ~ net -> dev . features & net -> dev . backend_features ) { \n fprintf ( stderr , \" \" PRIu64 \" \\n \" , \n ( uint64_t ) ( ~ net -> dev . features & net -> dev . backend_features ) ) ; \n vhost_dev_cleanup ( & net -> dev ) ; \n goto fail ; \n } \n vhost_net_ack_features ( net , 0 ) ; \n return net ; \n fail : \n g_free ( net ) ; \n return NULL ; \n }", "idx": 14410}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_read_data ( SCSIRequest * req ) \n { \n SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; \n uint32_t n ; \n if ( r -> sector_count == ( uint32_t ) -1 ) { \n DPRINTF ( \" \\n \" , r -> iov . iov_len ) ; \n r -> sector_count = 0 ; \n scsi_req_data ( & r -> req , r -> iov . iov_len ) ; \n return ; \n } \n DPRINTF ( \" \\n \" , r -> sector_count ) ; \n if ( r -> sector_count == 0 ) { \n scsi_command_complete ( r , GOOD , NO_SENSE ) ; \n return ; \n } \n assert ( r -> req . aiocb == NULL ) ; \n n = r -> sector_count ; \n if ( n > SCSI_DMA_BUF_SIZE / 512 ) \n n = SCSI_DMA_BUF_SIZE / 512 ; \n r -> iov . iov_len = n * 512 ; \n qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; \n r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , \n scsi_read_complete , r ) ; \n if ( r -> req . aiocb == NULL ) { \n scsi_read_complete ( r , - EIO ) ; \n } \n }", "idx": 14445}
{"project": "qemu", "commit_id": "1ecf47bf0a091700e45f1b7d1f5ad85abc0acd22", "target": 0, "func": "static void qemu_kvm_start_vcpu ( CPUState * env ) \n { \n env -> thread = g_malloc0 ( sizeof ( QemuThread ) ) ; \n env -> halt_cond = g_malloc0 ( sizeof ( QemuCond ) ) ; \n qemu_cond_init ( env -> halt_cond ) ; \n qemu_thread_create ( env -> thread , qemu_kvm_cpu_thread_fn , env , \n QEMU_THREAD_DETACHED ) ; \n while ( env -> created == 0 ) { \n qemu_cond_wait ( & qemu_cpu_cond , & qemu_global_mutex ) ; \n } \n }", "idx": 14472}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t timerblock_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n timerblock * tb = ( timerblock * ) opaque ; \n int64_t val ; \n switch ( addr ) { \n case 0 : \n return tb -> load ; \n case 4 : \n if ( ( ( tb -> control & 1 ) == 0 ) || ( tb -> count == 0 ) ) { \n return 0 ; \n } \n val = tb -> tick - qemu_get_clock_ns ( vm_clock ) ; \n val /= timerblock_scale ( tb ) ; \n if ( val < 0 ) { \n val = 0 ; \n } \n return val ; \n case 8 : \n return tb -> control ; \n case 12 : \n return tb -> status ; \n default : \n return 0 ; \n } \n }", "idx": 14532}
{"project": "qemu", "commit_id": "ae08792301c182bdec48656dee3dce38b3391a1a", "target": 0, "func": "setup_return ( CPUARMState * env , struct target_sigaction * ka , \n abi_ulong * rc , abi_ulong frame_addr , int usig , abi_ulong rc_addr )  \n { \n abi_ulong handler = ka -> _sa_handler ; \n abi_ulong retcode ; \n int thumb = handler & 1 ; \n uint32_t cpsr = cpsr_read ( env ) ; \n cpsr &= ~ CPSR_IT ; \n if ( thumb ) { \n cpsr |= CPSR_T ; \n } else { \n cpsr &= ~ CPSR_T ; \n } \n if ( ka -> sa_flags & TARGET_SA_RESTORER ) { \n retcode = ka -> sa_restorer ; \n } else { \n unsigned int idx = thumb ; \n if ( ka -> sa_flags & TARGET_SA_SIGINFO ) \n idx += 2 ; \n __put_user ( retcodes [ idx ] , rc ) ; \n retcode = rc_addr + thumb ; \n } \n env -> regs [ 0 ] = usig ; \n env -> regs [ 13 ] = frame_addr ; \n env -> regs [ 14 ] = retcode ; \n env -> regs [ 15 ] = handler & ( thumb ? ~ 1 : ~ 3 ) ; \n cpsr_write ( env , cpsr , 0xffffffff , CPSRWriteByInstr ) ; \n }", "idx": 14543}
{"project": "qemu", "commit_id": "e76d1798faa6d29f54c0930a034b67f3ecdb947d", "target": 0, "func": "static void tcg_exec_all ( void ) \n { \n int r ; \n qemu_clock_warp ( QEMU_CLOCK_VIRTUAL ) ; \n if ( next_cpu == NULL ) { \n next_cpu = first_cpu ; \n } \n for ( ; next_cpu != NULL && ! exit_request ; next_cpu = CPU_NEXT ( next_cpu ) ) { \n CPUState * cpu = next_cpu ; \n qemu_clock_enable ( QEMU_CLOCK_VIRTUAL , \n ( cpu -> singlestep_enabled & SSTEP_NOTIMER ) == 0 ) ; \n if ( cpu_can_run ( cpu ) ) { \n r = tcg_cpu_exec ( cpu ) ; \n if ( r == EXCP_DEBUG ) { \n cpu_handle_guest_debug ( cpu ) ; \n break ; \n } \n } else if ( cpu -> stop || cpu -> stopped ) { \n break ; \n } \n } \n atomic_mb_set ( & exit_request , 0 ) ; \n }", "idx": 14556}
{"project": "qemu", "commit_id": "1048c88f03545fa42bdebb077871a743a614d2ab", "target": 0, "func": "static int get_keycode ( const char * key ) \n { \n const KeyDef * p ; \n char * endp ; \n int ret ; \n for ( p = key_defs ; p -> name != NULL ; p ++ ) { \n if ( ! strcmp ( key , p -> name ) ) \n return p -> keycode ; \n } \n if ( strstart ( key , \" \" , NULL ) ) { \n ret = strtoul ( key , & endp , 0 ) ; \n if ( * endp == ' \\0 ' && ret >= 0x01 && ret <= 0xff ) \n return ret ; \n } \n return -1 ; \n }", "idx": 14563}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_cm_read ( void * opaque , hwaddr addr , \n unsigned size ) \n { \n PXA2xxState * s = ( PXA2xxState * ) opaque ; \n switch ( addr ) { \n case CCCR : \n case CKEN : \n case OSCC : \n return s -> cm_regs [ addr >> 2 ] ; \n case CCSR : \n return s -> cm_regs [ CCCR >> 2 ] | ( 3 << 28 ) ; \n default : \n printf ( \" \" REG_FMT \" \\n \" , __FUNCTION__ , addr ) ; \n break ; \n } \n return 0 ; \n }", "idx": 14587}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( test_ctrz_true ) \n { \n T0 = ( regs -> ctr == 0 && ( T0 & PARAM ( 1 ) ) != 0 ) ; \n RETURN ( ) ; \n }", "idx": 14634}
{"project": "qemu", "commit_id": "47116d1c90cdac94cb9da270320dcf0d5ce1cfe2", "target": 1, "func": "static void monitor_control_event ( void * opaque , int event ) \n { \n if ( event == CHR_EVENT_OPENED ) { \n QObject * data ; \n Monitor * mon = opaque ; \n mon -> mc -> command_mode = 0 ; \n json_message_parser_init ( & mon -> mc -> parser , handle_qmp_command ) ; \n data = get_qmp_greeting ( ) ; \n monitor_json_emitter ( mon , data ) ; \n qobject_decref ( data ) ; \n } \n }", "idx": 14643}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void cpu_ppc_reset ( void * opaque ) \n { \n CPUPPCState * env ; \n target_ulong msr ; \n env = opaque ; \n msr = ( target_ulong ) 0 ; \n #if defined ( TARGET_PPC64 )  \n  \n  msr |= ( target_ulong ) 0 << MSR_HV ; \n #endif \n msr |= ( target_ulong ) 0 << MSR_AP ; \n msr |= ( target_ulong ) 0 << MSR_SA ; \n msr |= ( target_ulong ) 1 << MSR_EP ; \n #if defined ( DO_SINGLE_STEP ) && 0  \n  \n  \n  \n  msr |= ( target_ulong ) 1 << MSR_SE ; \n msr |= ( target_ulong ) 1 << MSR_BE ; \n #endif \n #if defined ( CONFIG_USER_ONLY )  \n  \n  msr |= ( target_ulong ) 1 << MSR_FP ; \n msr |= ( target_ulong ) 1 << MSR_PR ; \n #else \n env -> nip = env -> hreset_vector | env -> excp_prefix ; \n if ( env -> mmu_model != POWERPC_MMU_REAL_4xx ) \n ppc_tlb_invalidate_all ( env ) ; \n #endif \n env -> msr = msr ; \n hreg_compute_hflags ( env ) ; \n env -> reserve = -1 ; \n env -> pending_interrupts = 0 ; \n env -> exception_index = POWERPC_EXCP_NONE ; \n env -> error_code = 0 ; \n tlb_flush ( env , 1 ) ; \n }", "idx": 14652}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_set_align ( VirtIODevice * vdev , int n , int align ) \n { \n BusState * qbus = qdev_get_parent_bus ( DEVICE ( vdev ) ) ; \n VirtioBusClass * k = VIRTIO_BUS_GET_CLASS ( qbus ) ; \n if ( virtio_vdev_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) { \n error_report ( \" \" ) ; \n return ; \n } \n assert ( k -> has_variable_vring_alignment ) ; \n vdev -> vq [ n ] . vring . align = align ; \n virtio_queue_update_rings ( vdev , n ) ; \n }", "idx": 14661}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void isa_mmio_writew ( void * opaque , target_phys_addr_t addr , \n uint32_t val ) \n { \n cpu_outw ( addr & IOPORTS_MASK , val ) ; \n }", "idx": 14713}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "int kvm_on_sigbus ( int code , void * addr ) \n { \n #if defined ( KVM_CAP_MCE )  \n  \n  if ( ( first_cpu -> mcg_cap & MCG_SER_P ) && addr && code == BUS_MCEERR_AO ) { \n uint64_t status ; \n void * vaddr ; \n ram_addr_t ram_addr ; \n target_phys_addr_t paddr ; \n vaddr = addr ; \n if ( qemu_ram_addr_from_host ( vaddr , & ram_addr ) || \n ! kvm_physical_memory_addr_from_ram ( first_cpu -> kvm_state , ram_addr , & paddr ) ) { \n fprintf ( stderr , \" \" \n \" \\n \" , addr ) ; \n return 0 ; \n } \n status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN \n | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S \n | 0xc0 ; \n kvm_inject_x86_mce ( first_cpu , 9 , status , \n MCG_STATUS_MCIP | MCG_STATUS_RIPV , paddr , \n ( MCM_ADDR_PHYS << 6 ) | 0xc , 1 ) ; \n kvm_mce_broadcast_rest ( first_cpu ) ; \n } else \n #endif \n { \n if ( code == BUS_MCEERR_AO ) { \n return 0 ; \n } else if ( code == BUS_MCEERR_AR ) { \n hardware_memory_error ( ) ; \n } else { \n return 1 ; \n } \n } \n return 0 ; \n }", "idx": 14770}
{"project": "qemu", "commit_id": "3d002df33eb034757d98e1ae529318f57df78f91", "target": 0, "func": "static size_t buffered_set_rate_limit ( void * opaque , size_t new_rate ) \n { \n QEMUFileBuffered * s = opaque ; \n if ( s -> has_error ) \n goto out ; \n s -> xfer_limit = new_rate / 10 ; \n out : \n return s -> xfer_limit ; \n }", "idx": 14781}
{"project": "qemu", "commit_id": "d2eae20790e825656b205dbe347826ff991fb3d8", "target": 0, "func": "static void ccw_init ( MachineState * machine ) \n { \n int ret ; \n VirtualCssBus * css_bus ; \n DeviceState * dev ; \n s390_sclp_init ( ) ; \n s390_memory_init ( machine -> ram_size ) ; \n css_bus = virtual_css_bus_init ( ) ; \n s390_init_ipl_dev ( machine -> kernel_filename , machine -> kernel_cmdline , \n machine -> initrd_filename , \" \" , true ) ; \n s390_flic_init ( ) ; \n dev = qdev_create ( NULL , TYPE_S390_PCI_HOST_BRIDGE ) ; \n object_property_add_child ( qdev_get_machine ( ) , TYPE_S390_PCI_HOST_BRIDGE , \n OBJECT ( dev ) , NULL ) ; \n qdev_init_nofail ( dev ) ; \n virtio_ccw_register_hcalls ( ) ; \n s390_init_cpus ( machine -> cpu_model ) ; \n if ( kvm_enabled ( ) ) { \n kvm_s390_enable_css_support ( s390_cpu_addr2state ( 0 ) ) ; \n } \n ret = css_create_css_image ( VIRTUAL_CSSID , true ) ; \n assert ( ret == 0 ) ; \n s390_create_virtio_net ( BUS ( css_bus ) , \" \" ) ; \n register_savevm ( NULL , \" \" , 0 , 1 , \n gtod_save , gtod_load , kvm_state ) ; \n }", "idx": 14788}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_load_vmstate ( BlockDriverState * bs , uint8_t * buf , \n int64_t pos , int size ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( drv -> bdrv_load_vmstate ) \n return drv -> bdrv_load_vmstate ( bs , buf , pos , size ) ; \n if ( bs -> file ) \n return bdrv_load_vmstate ( bs -> file , buf , pos , size ) ; \n return - ENOTSUP ; \n }", "idx": 14789}
{"project": "qemu", "commit_id": "47e8dd8fe9d83e8b51d40c2b87d7983bd0a78206", "target": 1, "func": "char * * breakline ( char * input , int * count ) \n { \n int c = 0 ; \n char * p ; \n char * * rval = calloc ( sizeof ( char * ) , 1 ) ; \n while ( rval && ( p = qemu_strsep ( & input , \" \" ) ) != NULL ) { \n if ( ! * p ) { \n continue ; \n } \n c ++ ; \n rval = realloc ( rval , sizeof ( * rval ) * ( c + 1 ) ) ; \n if ( ! rval ) { \n c = 0 ; \n break ; \n } \n rval [ c - 1 ] = p ; \n rval [ c ] = NULL ; \n } \n * count = c ; \n return rval ; \n }", "idx": 14818}
{"project": "qemu", "commit_id": "089f26bb735fb414b79f5fa3753910d5339d2a1d", "target": 1, "func": "static gsize calc_float_string_storage ( double value ) \n { \n int whole_value = value ; \n gsize i = 0 ; \n do { \n i ++ ; \n } while ( whole_value /= 10 ) ; \n return i + 2 + FLOAT_STRING_PRECISION ; \n }", "idx": 14829}
{"project": "qemu", "commit_id": "7f9744812291853425b614f68668f48d49882a1f", "target": 0, "func": "static void virtio_net_vmstate_change ( void * opaque , int running , int reason ) \n { \n VirtIONet * n = opaque ; \n if ( ! running ) { \n return ; \n } \n virtio_net_set_status ( & n -> vdev , n -> vdev . status ) ; \n }", "idx": 14850}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_pdiscard ( BlockDriverState * bs , \n int64_t offset , int count ) \n { \n BDRVRawState * s = bs -> opaque ; \n if ( offset > UINT64_MAX - s -> offset ) { \n return - EINVAL ; \n } \n offset += s -> offset ; \n return bdrv_co_pdiscard ( bs -> file -> bs , offset , count ) ; \n }", "idx": 14854}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static int scsi_write_data ( SCSIDevice * d , uint32_t tag ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; \n SCSIDiskReq * r ; \n DPRINTF ( \" \\n \" , tag ) ; \n r = scsi_find_request ( s , tag ) ; \n if ( ! r ) { \n BADF ( \" \\n \" , tag ) ; \n scsi_command_complete ( r , CHECK_CONDITION , HARDWARE_ERROR ) ; \n return 1 ; \n } \n assert ( r -> req . aiocb == NULL ) ; \n scsi_write_request ( r ) ; \n return 0 ; \n }", "idx": 14887}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_account_executed_instructions ( void ) \n { \n if ( replay_mode == REPLAY_MODE_PLAY ) { \n replay_mutex_lock ( ) ; \n if ( replay_state . instructions_count > 0 ) { \n int count = ( int ) ( replay_get_current_step ( ) \n - replay_state . current_step ) ; \n replay_state . instructions_count -= count ; \n replay_state . current_step += count ; \n if ( replay_state . instructions_count == 0 ) { \n assert ( replay_data_kind == EVENT_INSTRUCTION ) ; \n replay_finish_event ( ) ; \n qemu_notify_event ( ) ; \n } \n } \n replay_mutex_unlock ( ) ; \n } \n }", "idx": 14890}
{"project": "qemu", "commit_id": "e8ee5e4c476d5b0654d8f1271a2b7c065acc486e", "target": 0, "func": "void qemu_co_rwlock_unlock ( CoRwlock * lock ) \n { \n assert ( qemu_in_coroutine ( ) ) ; \n if ( lock -> writer ) { \n lock -> writer = false ; \n while ( ! qemu_co_queue_empty ( & lock -> queue ) ) { \n qemu_co_queue_next ( & lock -> queue ) ; \n } \n } else { \n lock -> reader -- ; \n assert ( lock -> reader >= 0 ) ; \n if ( ! lock -> reader ) { \n qemu_co_queue_next ( & lock -> queue ) ; \n } \n } \n }", "idx": 14902}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER ( ucf64_sf2si ) ( float32 x , CPUUniCore32State * env ) \n { \n return ucf64_itos ( float32_to_int32 ( x , & env -> ucf64 . fp_status ) ) ; \n }", "idx": 14918}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static int pl061_init ( SysBusDevice * dev , const unsigned char * id ) \n { \n int iomemtype ; \n pl061_state * s = FROM_SYSBUS ( pl061_state , dev ) ; \n s -> id = id ; \n iomemtype = cpu_register_io_memory ( pl061_readfn , \n pl061_writefn , s , \n DEVICE_NATIVE_ENDIAN ) ; \n sysbus_init_mmio ( dev , 0x1000 , iomemtype ) ; \n sysbus_init_irq ( dev , & s -> irq ) ; \n qdev_init_gpio_in ( & dev -> qdev , pl061_set_irq , 8 ) ; \n qdev_init_gpio_out ( & dev -> qdev , s -> out , 8 ) ; \n pl061_reset ( s ) ; \n register_savevm ( & dev -> qdev , \" \" , -1 , 1 , pl061_save , pl061_load , s ) ; \n return 0 ; \n }", "idx": 14933}
{"project": "qemu", "commit_id": "69795d6769910eaee4416470744e65ae066aeb54", "target": 0, "func": "void qemu_chr_reset ( CharDriverState * s ) \n { \n if ( s -> bh == NULL && initial_reset_issued ) { \n s -> bh = qemu_bh_new ( qemu_chr_reset_bh , s ) ; \n qemu_bh_schedule ( s -> bh ) ; \n } \n }", "idx": 14939}
{"project": "qemu", "commit_id": "d0bce760e04b1658a3b4ac95be2839ae20fd86db", "target": 1, "func": "static void omap_i2c_set_slave_addr ( OMAPI2C * s , uint8_t addr ) \n { \n uint16_t data = addr ; \n memwrite ( s -> addr + OMAP_I2C_SA , & data , 2 ) ; \n memread ( s -> addr + OMAP_I2C_SA , & data , 2 ) ; \n g_assert_cmphex ( data , == , addr ) ; \n }", "idx": 14943}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_cow ( QEDAIOCB * acb ) \n { \n BDRVQEDState * s = acb_to_s ( acb ) ; \n uint64_t start , len , offset ; \n int ret ; \n start = qed_start_of_cluster ( s , acb -> cur_pos ) ; \n len = qed_offset_into_cluster ( s , acb -> cur_pos ) ; \n trace_qed_aio_write_prefill ( s , acb , start , len , acb -> cur_cluster ) ; \n ret = qed_copy_from_backing_file ( s , start , len , acb -> cur_cluster ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n start = acb -> cur_pos + acb -> cur_qiov . size ; \n len = qed_start_of_cluster ( s , start + s -> header . cluster_size - 1 ) - start ; \n offset = acb -> cur_cluster + \n qed_offset_into_cluster ( s , acb -> cur_pos ) + \n acb -> cur_qiov . size ; \n trace_qed_aio_write_postfill ( s , acb , start , len , offset ) ; \n ret = qed_copy_from_backing_file ( s , start , len , offset ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n ret = qed_aio_write_main ( acb ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n if ( s -> bs -> backing ) { \n ret = bdrv_co_flush ( s -> bs -> file -> bs ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 14958}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void end_list ( Visitor * v ) \n { \n StringInputVisitor * siv = to_siv ( v ) ; \n siv -> head = true ; \n }", "idx": 14962}
{"project": "qemu", "commit_id": "c0f4ce7751f0b9a9a7815f931a09a6c3de127cee", "target": 0, "func": "static void do_cont ( void ) \n { \n vm_start ( ) ; \n }", "idx": 14965}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void AUD_remove_card ( QEMUSoundCard * card ) \n { \n LIST_REMOVE ( card , entries ) ; \n qemu_free ( card -> name ) ; \n }", "idx": 14968}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set_level ( PhysPageEntry * lp , target_phys_addr_t * index , \n target_phys_addr_t * nb , uint16_t leaf , \n int level ) \n { \n PhysPageEntry * p ; \n int i ; \n target_phys_addr_t step = ( target_phys_addr_t ) 1 << ( level * L2_BITS ) ; \n if ( ! lp -> is_leaf && lp -> ptr == PHYS_MAP_NODE_NIL ) { \n lp -> ptr = phys_map_node_alloc ( ) ; \n p = phys_map_nodes [ lp -> ptr ] ; \n if ( level == 0 ) { \n for ( i = 0 ; i < L2_SIZE ; i ++ ) { \n p [ i ] . is_leaf = 1 ; \n p [ i ] . ptr = phys_section_unassigned ; \n } \n } \n } else { \n p = phys_map_nodes [ lp -> ptr ] ; \n } \n lp = & p [ ( * index >> ( level * L2_BITS ) ) & ( L2_SIZE - 1 ) ] ; \n while ( * nb && lp < & p [ L2_SIZE ] ) { \n if ( ( * index & ( step - 1 ) ) == 0 && * nb >= step ) { \n lp -> is_leaf = true ; \n lp -> ptr = leaf ; \n * index += step ; \n * nb -= step ; \n } else { \n phys_page_set_level ( lp , index , nb , leaf , level - 1 ) ; \n } \n ++ lp ; \n } \n }", "idx": 14971}
{"project": "qemu", "commit_id": "82a41186941c419afde977f477f19c545b40c1c5", "target": 1, "func": "AioContext * aio_context_new ( Error * * errp ) \n { \n int ret ; \n AioContext * ctx ; \n ctx = ( AioContext * ) g_source_new ( & aio_source_funcs , sizeof ( AioContext ) ) ; \n aio_context_setup ( ctx ) ; \n ret = event_notifier_init ( & ctx -> notifier , false ) ; \n if ( ret < 0 ) { \n error_setg_errno ( errp , - ret , \" \" ) ; \n goto fail ; \n } \n g_source_set_can_recurse ( & ctx -> source , true ) ; \n aio_set_event_notifier ( ctx , & ctx -> notifier , \n false , \n ( EventNotifierHandler * ) \n event_notifier_dummy_cb , \n event_notifier_poll ) ; \n #ifdef CONFIG_LINUX_AIO \n ctx -> linux_aio = NULL ; \n #endif \n ctx -> thread_pool = NULL ; \n qemu_mutex_init ( & ctx -> bh_lock ) ; \n qemu_rec_mutex_init ( & ctx -> lock ) ; \n timerlistgroup_init ( & ctx -> tlg , aio_timerlist_notify , ctx ) ; \n ctx -> poll_max_ns = 0 ; \n return ctx ; \n fail : \n g_source_destroy ( & ctx -> source ) ; \n return NULL ; \n }", "idx": 15000}
{"project": "qemu", "commit_id": "17ec9921a7e40d47c05effcf2c254f162bd63aad", "target": 0, "func": "static void chr_event ( void * opaque , int event ) \n { \n Terminal3270 * t = opaque ; \n CcwDevice * ccw_dev = CCW_DEVICE ( t ) ; \n SubchDev * sch = ccw_dev -> sch ; \n t -> in_len = 0 ; \n t -> out_len = 0 ; \n t -> handshake_done = false ; \n if ( t -> timer_tag ) { \n g_source_remove ( t -> timer_tag ) ; \n t -> timer_tag = 0 ; \n } \n switch ( event ) { \n case CHR_EVENT_OPENED : \n t -> timer_tag = g_timeout_add_seconds ( 600 , send_timing_mark_cb , t ) ; \n break ; \n case CHR_EVENT_CLOSED : \n sch -> curr_status . scsw . dstat = SCSW_DSTAT_DEVICE_END ; \n css_conditional_io_interrupt ( sch ) ; \n break ; \n } \n }", "idx": 15023}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static void tgen_ext8u ( TCGContext * s , TCGType type , TCGReg dest , TCGReg src ) \n { \n if ( facilities & FACILITY_EXT_IMM ) { \n tcg_out_insn ( s , RRE , LLGCR , dest , src ) ; \n return ; \n } \n if ( dest == src ) { \n tcg_out_movi ( s , type , TCG_TMP0 , 0xff ) ; \n src = TCG_TMP0 ; \n } else { \n tcg_out_movi ( s , type , dest , 0xff ) ; \n } \n if ( type == TCG_TYPE_I32 ) { \n tcg_out_insn ( s , RR , NR , dest , src ) ; \n } else { \n tcg_out_insn ( s , RRE , NGR , dest , src ) ; \n } \n }", "idx": 15026}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool esp_mem_accepts ( void * opaque , target_phys_addr_t addr , \n unsigned size , bool is_write ) \n { \n return ( size == 1 ) || ( is_write && size == 4 ) ; \n }", "idx": 15027}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "SDState * sd_init ( BlockBackend * blk , bool is_spi ) \n { \n SDState * sd ; \n if ( blk && blk_is_read_only ( blk ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n return NULL ; \n } \n sd = ( SDState * ) g_malloc0 ( sizeof ( SDState ) ) ; \n sd -> buf = blk_blockalign ( blk , 512 ) ; \n sd -> spi = is_spi ; \n sd -> enable = true ; \n sd_reset ( sd , blk ) ; \n if ( sd -> blk ) { \n blk_attach_dev_nofail ( sd -> blk , sd ) ; \n blk_set_dev_ops ( sd -> blk , & sd_block_ops , sd ) ; \n } \n vmstate_register ( NULL , -1 , & sd_vmstate , sd ) ; \n return sd ; \n }", "idx": 15041}
{"project": "qemu", "commit_id": "f0d2a4d4d63dd2f0f3ecb2d591b979b0e7f24a22", "target": 0, "func": "iscsi_synccache10_cb ( struct iscsi_context *  iscsi , int  status , \n void * command_data , void * opaque ) \n { \n IscsiAIOCB * acb = opaque ; \n if ( acb -> canceled != 0 ) { \n return ; \n } \n acb -> status = 0 ; \n if ( status != 0 ) { \n if ( status == SCSI_STATUS_CHECK_CONDITION \n && acb -> task -> sense . key == SCSI_SENSE_UNIT_ATTENTION \n && acb -> retries -- > 0 ) { \n if ( acb -> task != NULL ) { \n scsi_free_scsi_task ( acb -> task ) ; \n acb -> task = NULL ; \n } \n if ( iscsi_aio_flush_acb ( acb ) == 0 ) { \n iscsi_set_events ( acb -> iscsilun ) ; \n return ; \n } \n } \n error_report ( \" \" , \n iscsi_get_error ( iscsi ) ) ; \n acb -> status = - EIO ; \n } \n iscsi_schedule_bh ( acb ) ; \n }", "idx": 15069}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_net_set_config ( VirtIODevice * vdev , const uint8_t * config ) \n { \n VirtIONet * n = VIRTIO_NET ( vdev ) ; \n struct virtio_net_config netcfg = { } ; \n memcpy ( & netcfg , config , n -> config_size ) ; \n if ( ! ( vdev -> guest_features >> VIRTIO_NET_F_CTRL_MAC_ADDR & 1 ) && \n memcmp ( netcfg . mac , n -> mac , ETH_ALEN ) ) { \n memcpy ( n -> mac , netcfg . mac , ETH_ALEN ) ; \n qemu_format_nic_info_str ( qemu_get_queue ( n -> nic ) , n -> mac ) ; \n } \n }", "idx": 15086}
{"project": "qemu", "commit_id": "2bfe11c8fac96db4f94abbe818fbc964a6744130", "target": 1, "func": "void trace_init_vcpu_events ( void ) \n { \n TraceEvent * ev = NULL ; \n while ( ( ev = trace_event_pattern ( \" \" , ev ) ) != NULL ) { \n if ( trace_event_is_vcpu ( ev ) && \n trace_event_get_state_static ( ev ) && \n trace_event_get_state_dynamic ( ev ) ) { \n TraceEventID id = trace_event_get_id ( ev ) ; \n assert ( trace_events_dstate [ id ] == 1 ) ; \n trace_events_dstate [ id ] = 0 ; \n trace_events_enabled_count -- ; \n trace_event_set_state_dynamic ( ev , true ) ; \n } \n } \n }", "idx": 15130}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "static int scsi_disk_initfn ( SCSIDevice * dev ) \n { \n SCSIDriveKind kind ; \n if ( ! dev -> conf . bs ) { \n kind = SCSI_HD ; \n } else { \n kind = bdrv_get_type_hint ( dev -> conf . bs ) == BDRV_TYPE_CDROM \n ? SCSI_CD : SCSI_HD ; \n } \n return scsi_initfn ( dev , kind ) ; \n }", "idx": 15172}
{"project": "qemu", "commit_id": "5cd230819ec26caf199bf73d38cf2407344e4443", "target": 0, "func": "static int cloop_read ( BlockDriverState * bs , int64_t sector_num , \n uint8_t * buf , int nb_sectors ) \n { \n BDRVCloopState * s = bs -> opaque ; \n int i ; \n for ( i = 0 ; i < nb_sectors ; i ++ ) { \n uint32_t sector_offset_in_block = \n ( ( sector_num + i ) % s -> sectors_per_block ) , \n block_num = ( sector_num + i ) / s -> sectors_per_block ; \n if ( cloop_read_block ( bs , block_num ) != 0 ) { \n return -1 ; \n } \n memcpy ( buf + i * 512 , \n s -> uncompressed_block + sector_offset_in_block * 512 , 512 ) ; \n } \n return 0 ; \n }", "idx": 15179}
{"project": "qemu", "commit_id": "b6dcbe086c77ec683f5ff0b693593cda1d61f3a1", "target": 0, "func": "ram_addr_t ppc4xx_sdram_adjust ( ram_addr_t ram_size , int nr_banks , \n target_phys_addr_t ram_bases [ ] , \n target_phys_addr_t ram_sizes [ ] , \n const unsigned int sdram_bank_sizes [ ] ) \n { \n ram_addr_t size_left = ram_size ; \n int i ; \n int j ; \n for ( i = 0 ; i < nr_banks ; i ++ ) { \n for ( j = 0 ; sdram_bank_sizes [ j ] != 0 ; j ++ ) { \n unsigned int bank_size = sdram_bank_sizes [ j ] ; \n if ( bank_size <= size_left ) { \n char name [ 32 ] ; \n snprintf ( name , sizeof ( name ) , \" \" , i ) ; \n ram_bases [ i ] = qemu_ram_alloc ( NULL , name , bank_size ) ; \n ram_sizes [ i ] = bank_size ; \n size_left -= bank_size ; \n break ; \n } \n } \n if ( ! size_left ) { \n break ; \n } \n } \n ram_size -= size_left ; \n if ( size_left ) \n printf ( \" \\n \" , \n ( int ) ( ram_size >> 20 ) ) ; \n return ram_size ; \n }", "idx": 15183}
{"project": "qemu", "commit_id": "57e49b40745ceb6c198cc58274b705afb5f20493", "target": 0, "func": "static inline int check_fit ( tcg_target_long val , unsigned int bits ) \n { \n return ( ( val << ( ( sizeof ( tcg_target_long ) * 8 - bits ) ) \n >> ( sizeof ( tcg_target_long ) * 8 - bits ) ) == val ) ; \n }", "idx": 15187}
{"project": "qemu", "commit_id": "d644f8beaa268a4e36b473f283f0b5a5ff66d8c2", "target": 0, "func": "void * qemu_memalign ( size_t alignment , size_t size ) \n { \n return VirtualAlloc ( NULL , size , MEM_COMMIT , PAGE_READWRITE ) ; \n }", "idx": 15191}
{"project": "qemu", "commit_id": "661e32fb3cb71c7e019daee375be4bb487b9917c", "target": 1, "func": "static void virtio_scsi_handle_ctrl_req ( VirtIOSCSI * s , VirtIOSCSIReq * req ) \n { \n VirtIODevice * vdev = ( VirtIODevice * ) s ; \n uint32_t type ; \n int r = 0 ; \n if ( iov_to_buf ( req -> elem . out_sg , req -> elem . out_num , 0 , \n & type , sizeof ( type ) ) < sizeof ( type ) ) { \n virtio_scsi_bad_req ( ) ; \n return ; \n } \n virtio_tswap32s ( vdev , & type ) ; \n if ( type == VIRTIO_SCSI_T_TMF ) { \n if ( virtio_scsi_parse_req ( req , sizeof ( VirtIOSCSICtrlTMFReq ) , \n sizeof ( VirtIOSCSICtrlTMFResp ) ) < 0 ) { \n virtio_scsi_bad_req ( ) ; \n } else { \n r = virtio_scsi_do_tmf ( s , req ) ; \n } \n } else if ( type == VIRTIO_SCSI_T_AN_QUERY || \n type == VIRTIO_SCSI_T_AN_SUBSCRIBE ) { \n if ( virtio_scsi_parse_req ( req , sizeof ( VirtIOSCSICtrlANReq ) , \n sizeof ( VirtIOSCSICtrlANResp ) ) < 0 ) { \n virtio_scsi_bad_req ( ) ; \n } else { \n req -> resp . an . event_actual = 0 ; \n req -> resp . an . response = VIRTIO_SCSI_S_OK ; \n } \n } \n if ( r == 0 ) { \n virtio_scsi_complete_req ( req ) ; \n } else { \n assert ( r == - EINPROGRESS ) ; \n } \n }", "idx": 15198}
{"project": "qemu", "commit_id": "20c334a797bf46a4ee59a6e42be6d5e7c3cda585", "target": 1, "func": "static inline uint32_t mipsdsp_sub32 ( int32_t a , int32_t b , CPUMIPSState * env ) \n { \n int32_t temp ; \n temp = a - b ; \n if ( MIPSDSP_OVERFLOW ( a , - b , temp , 0x80000000 ) ) { \n set_DSPControl_overflow_flag ( 1 , 20 , env ) ; \n } \n return temp ; \n }", "idx": 15204}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long host_to_target_timespec ( abi_ulong target_addr , \n struct timespec * host_ts ) \n { \n struct target_timespec * target_ts ; \n if ( ! lock_user_struct ( VERIFY_WRITE , target_ts , target_addr , 0 ) ) \n return - TARGET_EFAULT ; \n target_ts -> tv_sec = tswapal ( host_ts -> tv_sec ) ; \n target_ts -> tv_nsec = tswapal ( host_ts -> tv_nsec ) ; \n unlock_user_struct ( target_ts , target_addr , 1 ) ; \n return 0 ; \n }", "idx": 15217}
{"project": "qemu", "commit_id": "dac23a6c05e543590508b48b8ed31d89b0c99c61", "target": 1, "func": "static bool load_asl ( GArray * sdts , AcpiSdtTable * sdt ) \n { \n AcpiSdtTable * temp ; \n GError * error = NULL ; \n GString * command_line = g_string_new ( iasl ) ; \n gint fd ; \n gchar * out , * out_err ; \n gboolean ret ; \n int i ; \n fd = g_file_open_tmp ( \" \" , & sdt -> asl_file , & error ) ; \n g_assert_no_error ( error ) ; \n close ( fd ) ; \n g_string_append_printf ( command_line , \" \" , sdt -> asl_file ) ; \n if ( compare_signature ( sdt , \" \" ) || \n compare_signature ( sdt , \" \" ) ) { \n for ( i = 0 ; i < sdts -> len ; ++ i ) { \n temp = & g_array_index ( sdts , AcpiSdtTable , i ) ; \n if ( compare_signature ( temp , \" \" ) || \n compare_signature ( temp , \" \" ) ) { \n g_string_append_printf ( command_line , \" \" , temp -> aml_file ) ; \n } \n } \n } \n g_string_append_printf ( command_line , \" \" , sdt -> aml_file ) ; \n ret = g_spawn_command_line_sync ( command_line -> str , & out , & out_err , NULL , & error ) ; \n g_assert_no_error ( error ) ; \n if ( ret ) { \n ret = g_file_get_contents ( sdt -> asl_file , ( gchar * * ) & sdt -> asl , \n & sdt -> asl_len , & error ) ; \n g_assert ( ret ) ; \n g_assert_no_error ( error ) ; \n g_assert ( sdt -> asl_len ) ; \n } \n g_free ( out ) ; \n g_free ( out_err ) ; \n g_string_free ( command_line , true ) ; \n return ! ret ; \n }", "idx": 15226}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "MemoryRegionSection memory_region_find ( MemoryRegion * address_space , \n target_phys_addr_t addr , uint64_t size ) \n { \n AddressSpace * as = memory_region_to_address_space ( address_space ) ; \n AddrRange range = addrrange_make ( int128_make64 ( addr ) , \n int128_make64 ( size ) ) ; \n FlatRange * fr = address_space_lookup ( as , range ) ; \n MemoryRegionSection ret = { . mr = NULL , . size = 0 } ; \n if ( ! fr ) { \n return ret ; \n } \n while ( fr > as -> current_map . ranges \n && addrrange_intersects ( fr [ -1 ] . addr , range ) ) { \n -- fr ; \n } \n ret . mr = fr -> mr ; \n range = addrrange_intersection ( range , fr -> addr ) ; \n ret . offset_within_region = fr -> offset_in_region ; \n ret . offset_within_region += int128_get64 ( int128_sub ( range . start , \n fr -> addr . start ) ) ; \n ret . size = int128_get64 ( range . size ) ; \n ret . offset_within_address_space = int128_get64 ( range . start ) ; \n ret . readonly = fr -> readonly ; \n return ret ; \n }", "idx": 15245}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "uint64_t qpci_io_readq ( QPCIDevice * dev , void * data ) \n { \n uintptr_t addr = ( uintptr_t ) data ; \n if ( addr < QPCI_PIO_LIMIT ) { \n return dev -> bus -> pio_readq ( dev -> bus , addr ) ; \n } else { \n uint64_t val ; \n dev -> bus -> memread ( dev -> bus , addr , & val , sizeof ( val ) ) ; \n return le64_to_cpu ( val ) ; \n } \n }", "idx": 15264}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn_stop ( ESPState * s ) \n { \n if ( s -> dma && ! s -> dma_enabled ) { \n s -> dma_cb = handle_satn_stop ; \n return ; \n } \n s -> cmdlen = get_cmd ( s , s -> cmdbuf ) ; \n if ( s -> cmdlen ) { \n trace_esp_handle_satn_stop ( s -> cmdlen ) ; \n s -> do_cmd = 1 ; \n s -> rregs [ ESP_RSTAT ] = STAT_TC | STAT_CD ; \n s -> rregs [ ESP_RINTR ] = INTR_BS | INTR_FC ; \n s -> rregs [ ESP_RSEQ ] = SEQ_CD ; \n esp_raise_irq ( s ) ; \n } \n }", "idx": 15312}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static void vt82c686b_write_config ( PCIDevice * d , uint32_t address , \n uint32_t val , int len ) \n { \n VT82C686BState * vt686 = DO_UPCAST ( VT82C686BState , dev , d ) ; \n DPRINTF ( \" \\n \" , \n address , val , len ) ; \n pci_default_write_config ( d , address , val , len ) ; \n if ( address == 0x85 ) { \n if ( val & 0x2 ) { \n isa_unassign_ioport ( 0x3f0 , 2 ) ; \n register_ioport_read ( 0x3f0 , 2 , 1 , superio_ioport_readb , \n & vt686 -> superio_conf ) ; \n register_ioport_write ( 0x3f0 , 2 , 1 , superio_ioport_writeb , \n & vt686 -> superio_conf ) ; \n } else { \n isa_unassign_ioport ( 0x3f0 , 2 ) ; \n } \n } \n }", "idx": 15337}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_le_phys ( target_phys_addr_t addr , uint32_t val ) \n { \n stl_phys_internal ( addr , val , DEVICE_LITTLE_ENDIAN ) ; \n }", "idx": 15358}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "static void kvm_mce_broadcast_rest ( CPUState * env ) \n { \n CPUState * cenv ; \n int family , model , cpuver = env -> cpuid_version ; \n family = ( cpuver >> 8 ) & 0xf ; \n model = ( ( cpuver >> 12 ) & 0xf0 ) + ( ( cpuver >> 4 ) & 0xf ) ; \n if ( ( family == 6 && model >= 14 ) || family > 6 ) { \n for ( cenv = first_cpu ; cenv != NULL ; cenv = cenv -> next_cpu ) { \n if ( cenv == env ) { \n continue ; \n } \n kvm_inject_x86_mce ( cenv , 1 , MCI_STATUS_VAL | MCI_STATUS_UC , \n MCG_STATUS_MCIP | MCG_STATUS_RIPV , 0 , 0 , 1 ) ; \n } \n } \n }", "idx": 15397}
{"project": "qemu", "commit_id": "7b595f35d89d73bc69c35bf3980a89c420e8a44b", "target": 0, "func": "static void glib_pollfds_fill ( uint32_t * cur_timeout ) \n { \n GMainContext * context = g_main_context_default ( ) ; \n int timeout = 0 ; \n int n ; \n g_main_context_prepare ( context , & max_priority ) ; \n glib_pollfds_idx = gpollfds -> len ; \n n = glib_n_poll_fds ; \n do { \n GPollFD * pfds ; \n glib_n_poll_fds = n ; \n g_array_set_size ( gpollfds , glib_pollfds_idx + glib_n_poll_fds ) ; \n pfds = & g_array_index ( gpollfds , GPollFD , glib_pollfds_idx ) ; \n n = g_main_context_query ( context , max_priority , & timeout , pfds , \n glib_n_poll_fds ) ; \n } while ( n != glib_n_poll_fds ) ; \n if ( timeout >= 0 && timeout < * cur_timeout ) { \n * cur_timeout = timeout ; \n } \n }", "idx": 15445}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn ( CPUMBState * env ) \n { \n struct target_signal_frame * frame ; \n abi_ulong frame_addr ; \n target_sigset_t target_set ; \n sigset_t set ; \n int i ; \n frame_addr = env -> regs [ R_SP ] ; \n if ( ! lock_user_struct ( VERIFY_WRITE , frame , frame_addr , 1 ) ) \n goto badframe ; \n if ( __get_user ( target_set . sig [ 0 ] , & frame -> uc . tuc_mcontext . oldmask ) ) \n goto badframe ; \n for ( i = 1 ; i < TARGET_NSIG_WORDS ; i ++ ) { \n if ( __get_user ( target_set . sig [ i ] , & frame -> extramask [ i - 1 ] ) ) \n goto badframe ; \n } \n target_to_host_sigset_internal ( & set , & target_set ) ; \n sigprocmask ( SIG_SETMASK , & set , NULL ) ; \n restore_sigcontext ( & frame -> uc . tuc_mcontext , env ) ; \n env -> regs [ 14 ] = env -> sregs [ SR_PC ] ; \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n return env -> regs [ 10 ] ; \n badframe : \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n force_sig ( TARGET_SIGSEGV ) ; \n }", "idx": 15458}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_device_destroy ( SCSIDevice * s ) \n { \n SCSIDeviceClass * sc = SCSI_DEVICE_GET_CLASS ( s ) ; \n if ( sc -> destroy ) { \n sc -> destroy ( s ) ; \n } \n }", "idx": 15472}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_setup_vlan_header ( struct NetTxPkt * pkt , uint16_t vlan ) \n { \n bool is_new ; \n assert ( pkt ) ; \n eth_setup_vlan_headers ( pkt -> vec [ NET_TX_PKT_L2HDR_FRAG ] . iov_base , \n vlan , & is_new ) ; \n if ( is_new ) { \n pkt -> hdr_len += sizeof ( struct vlan_header ) ; \n pkt -> vec [ NET_TX_PKT_L2HDR_FRAG ] . iov_len += \n sizeof ( struct vlan_header ) ; \n } \n }", "idx": 15489}
{"project": "qemu", "commit_id": "4c3b22459d3589cf84d1ccadc6b09e586497820d", "target": 1, "func": "int pcnet_common_init ( DeviceState * dev , PCNetState * s , NetClientInfo * info ) \n { \n int i ; \n uint16_t checksum ; \n s -> poll_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , pcnet_poll_timer , s ) ; \n qemu_macaddr_default_if_unset ( & s -> conf . macaddr ) ; \n s -> nic = qemu_new_nic ( info , & s -> conf , object_get_typename ( OBJECT ( dev ) ) , dev -> id , s ) ; \n qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ; \n memcpy ( s -> prom , s -> conf . macaddr . a , 6 ) ; \n s -> prom [ 6 ] = s -> prom [ 7 ] = 0x00 ; \n s -> prom [ 8 ] = 0x00 ; \n s -> prom [ 9 ] = 0x11 ; \n s -> prom [ 10 ] = s -> prom [ 11 ] = 0x00 ; \n s -> prom [ 12 ] = s -> prom [ 13 ] = 0x00 ; \n s -> prom [ 14 ] = s -> prom [ 15 ] = 0x57 ; \n for ( i = 0 , checksum = 0 ; i < 16 ; i ++ ) { \n checksum += s -> prom [ i ] ; \n } \n * ( uint16_t * ) & s -> prom [ 12 ] = cpu_to_le16 ( checksum ) ; \n s -> lnkst = 0x40 ; \n return 0 ; \n }", "idx": 15499}
{"project": "qemu", "commit_id": "b0e90181e4d7244a9466447703acdb2cdd7abdaa", "target": 1, "func": "static int query_memdev ( Object * obj , void * opaque ) \n { \n MemdevList * * list = opaque ; \n Error * err = NULL ; \n if ( object_dynamic_cast ( obj , TYPE_MEMORY_BACKEND ) ) { \n MemdevList * m = g_malloc0 ( sizeof ( * m ) ) ; \n m -> value = g_malloc0 ( sizeof ( * m -> value ) ) ; \n m -> value -> size = object_property_get_int ( obj , \" \" , \n & err ) ; \n if ( err ) { \n goto error ; \n } \n m -> value -> merge = object_property_get_bool ( obj , \" \" , \n & err ) ; \n if ( err ) { \n goto error ; \n } \n m -> value -> dump = object_property_get_bool ( obj , \" \" , \n & err ) ; \n if ( err ) { \n goto error ; \n } \n m -> value -> prealloc = object_property_get_bool ( obj , \n \" \" , & err ) ; \n if ( err ) { \n goto error ; \n } \n m -> value -> policy = object_property_get_enum ( obj , \n \" \" , \n HostMemPolicy_lookup , \n & err ) ; \n if ( err ) { \n goto error ; \n } \n object_property_get_uint16List ( obj , \" \" , \n & m -> value -> host_nodes , & err ) ; \n if ( err ) { \n goto error ; \n } \n m -> next = * list ; \n * list = m ; \n } \n return 0 ; \n error : \n return -1 ; \n }", "idx": 15501}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fres ( CPUPPCState * env , uint64_t arg ) \n { \n CPU_DoubleU farg ; \n float32 f32 ; \n farg . ll = arg ; \n if ( unlikely ( float64_is_signaling_nan ( farg . d ) ) ) { \n fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN ) ; \n } \n farg . d = float64_div ( float64_one , farg . d , & env -> fp_status ) ; \n f32 = float64_to_float32 ( farg . d , & env -> fp_status ) ; \n farg . d = float32_to_float64 ( f32 , & env -> fp_status ) ; \n return farg . ll ; \n }", "idx": 15523}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER ( wsr_lend ) ( uint32_t v ) \n { \n if ( env -> sregs [ LEND ] != v ) { \n tb_invalidate_phys_page_range ( \n env -> sregs [ LEND ] - 1 , env -> sregs [ LEND ] , 0 ) ; \n env -> sregs [ LEND ] = v ; \n tb_invalidate_phys_page_range ( \n env -> sregs [ LEND ] - 1 , env -> sregs [ LEND ] , 0 ) ; \n } \n }", "idx": 15526}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int aio_epoll ( AioContext * ctx , GPollFD * pfds , \n unsigned npfd , int64_t timeout ) \n { \n assert ( false ) ; \n }", "idx": 15550}
{"project": "qemu", "commit_id": "413bfb7cfc4e7f886ad35d610056ad8da8deab8a", "target": 0, "func": "static void sdl_resize ( DisplayState * ds ) \n { \n int flags ; \n flags = SDL_HWSURFACE | SDL_ASYNCBLIT | SDL_HWACCEL ; \n if ( gui_fullscreen ) \n flags |= SDL_FULLSCREEN ; \n if ( gui_noframe ) \n flags |= SDL_NOFRAME ; \n again : \n real_screen = SDL_SetVideoMode ( ds_get_width ( ds ) , ds_get_height ( ds ) , 0 , flags ) ; \n if ( ! real_screen ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( ! real_screen -> pixels && ( flags & SDL_HWSURFACE ) && ( flags & SDL_FULLSCREEN ) ) { \n flags &= ~ SDL_HWSURFACE ; \n goto again ; \n } \n if ( ! real_screen -> pixels ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n sdl_setdata ( ds ) ; \n }", "idx": 15612}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_subfeo ( void ) \n { \n T2 = T0 ; \n T0 = T1 + ~ T0 + xer_ca ; \n if ( likely ( ! ( ( ~ T2 ^ T1 ^ ( -1 ) ) & ( ~ T2 ^ T0 ) & ( 1 << 31 ) ) ) ) { \n xer_ov = 0 ; \n } else { \n xer_so = 1 ; \n xer_ov = 1 ; \n } \n if ( likely ( T0 >= T1 && ( xer_ca == 0 || T0 != T1 ) ) ) { \n xer_ca = 0 ; \n } else { \n xer_ca = 1 ; \n } \n }", "idx": 15622}
{"project": "qemu", "commit_id": "acc4af3fec335bb0778456f72bfb2c3591c11da4", "target": 0, "func": "static bool object_is_type ( Object * obj , const char * typename ) \n { \n TypeImpl * target_type = type_get_by_name ( typename ) ; \n TypeImpl * type = obj -> class -> type ; \n GSList * i ; \n while ( type ) { \n if ( type == target_type ) { \n return true ; \n } \n type = type_get_parent ( type ) ; \n } \n for ( i = obj -> interfaces ; i ; i = i -> next ) { \n Interface * iface = i -> data ; \n if ( object_is_type ( OBJECT ( iface ) , typename ) ) { \n return true ; \n } \n } \n return false ; \n }", "idx": 15628}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t dchip_read ( void * opaque , target_phys_addr_t addr , unsigned size ) \n { \n return 0 ; \n }", "idx": 15660}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_755 ( CPUPPCState * env ) \n { \n gen_spr_ne_601 ( env ) ; \n gen_spr_7xx ( env ) ; \n gen_spr_G2_755 ( env ) ; \n gen_tbl ( env ) ; \n spr_register ( env , SPR_L2CR , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , NULL , \n 0x00000000 ) ; \n spr_register ( env , SPR_L2PMCR , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n gen_spr_thrm ( env ) ; \n spr_register ( env , SPR_HID0 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID1 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID2 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n gen_low_BATs ( env ) ; \n gen_high_BATs ( env ) ; \n gen_6xx_7xx_soft_tlb ( env , 64 , 2 ) ; \n init_excp_7x5 ( env ) ; \n env -> dcache_line_size = 32 ; \n env -> icache_line_size = 32 ; \n ppc6xx_irq_init ( env ) ; \n }", "idx": 15686}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "static int bdrv_prwv_co ( BdrvChild * child , int64_t offset , \n QEMUIOVector * qiov , bool is_write , \n BdrvRequestFlags flags ) \n { \n Coroutine * co ; \n RwCo rwco = { \n . child = child , \n . offset = offset , \n . qiov = qiov , \n . is_write = is_write , \n . ret = NOT_DONE , \n . flags = flags , \n } ; \n if ( qemu_in_coroutine ( ) ) { \n bdrv_rw_co_entry ( & rwco ) ; \n } else { \n AioContext * aio_context = bdrv_get_aio_context ( child -> bs ) ; \n co = qemu_coroutine_create ( bdrv_rw_co_entry , & rwco ) ; \n qemu_coroutine_enter ( co ) ; \n while ( rwco . ret == NOT_DONE ) { \n aio_poll ( aio_context , true ) ; \n } \n } \n return rwco . ret ; \n }", "idx": 15719}
{"project": "qemu", "commit_id": "a9859c90a5db200fd4f63ab2cdc973343348b9ef", "target": 1, "func": "static void xilinx_axidma_realize ( DeviceState * dev , Error * * errp ) \n { \n XilinxAXIDMA * s = XILINX_AXI_DMA ( dev ) ; \n XilinxAXIDMAStreamSlave * ds = XILINX_AXI_DMA_DATA_STREAM ( & s -> rx_data_dev ) ; \n XilinxAXIDMAStreamSlave * cs = XILINX_AXI_DMA_CONTROL_STREAM ( \n & s -> rx_control_dev ) ; \n Error * local_err = NULL ; \n object_property_add_link ( OBJECT ( ds ) , \" \" , TYPE_XILINX_AXI_DMA , \n ( Object * * ) & ds -> dma , \n object_property_allow_set_link , \n OBJ_PROP_LINK_UNREF_ON_RELEASE , \n & local_err ) ; \n object_property_add_link ( OBJECT ( cs ) , \" \" , TYPE_XILINX_AXI_DMA , \n ( Object * * ) & cs -> dma , \n object_property_allow_set_link , \n OBJ_PROP_LINK_UNREF_ON_RELEASE , \n & local_err ) ; \n if ( local_err ) { \n goto xilinx_axidma_realize_fail ; \n } \n object_property_set_link ( OBJECT ( ds ) , OBJECT ( s ) , \" \" , & local_err ) ; \n object_property_set_link ( OBJECT ( cs ) , OBJECT ( s ) , \" \" , & local_err ) ; \n if ( local_err ) { \n goto xilinx_axidma_realize_fail ; \n } \n int i ; \n for ( i = 0 ; i < 2 ; i ++ ) { \n struct Stream * st = & s -> streams [ i ] ; \n st -> nr = i ; \n st -> bh = qemu_bh_new ( timer_hit , st ) ; \n st -> ptimer = ptimer_init ( st -> bh , PTIMER_POLICY_DEFAULT ) ; \n ptimer_set_freq ( st -> ptimer , s -> freqhz ) ; \n } \n return ; \n xilinx_axidma_realize_fail : \n if ( ! * errp ) { \n * errp = local_err ; \n } \n }", "idx": 15768}
{"project": "qemu", "commit_id": "d5e6f437c5508614803d11e59ee16a758dde09ef", "target": 0, "func": "BdrvChild * bdrv_attach_child ( BlockDriverState * parent_bs , \n BlockDriverState * child_bs , \n const char * child_name , \n const BdrvChildRole * child_role , \n Error * * errp ) \n { \n BdrvChild * child = bdrv_root_attach_child ( child_bs , child_name , child_role , \n parent_bs ) ; \n QLIST_INSERT_HEAD ( & parent_bs -> children , child , next ) ; \n return child ; \n }", "idx": 15778}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_cleanup ( MigrationState * s ) \n { \n int ret = 0 ; \n if ( s -> file ) { \n DPRINTF ( \" \\n \" ) ; \n ret = qemu_fclose ( s -> file ) ; \n s -> file = NULL ; \n } \n assert ( s -> fd == -1 ) ; \n if ( ret < 0 && s -> state == MIG_STATE_ACTIVE ) { \n s -> state = MIG_STATE_ERROR ; \n } \n if ( s -> state != MIG_STATE_ACTIVE ) { \n qemu_savevm_state_cancel ( ) ; \n } \n }", "idx": 15835}
{"project": "qemu", "commit_id": "806d102141b99d4f1e55a97d68b7ea8c8ba3129f", "target": 1, "func": "unsigned long init_guest_space ( unsigned long host_start , \n unsigned long host_size , \n unsigned long guest_start , \n bool fixed ) \n { \n unsigned long current_start , real_start ; \n int flags ; \n assert ( host_start || host_size ) ; \n if ( host_start && ! host_size ) { \n if ( guest_validate_base ( host_start ) ) { \n return host_start ; \n } else { \n return ( unsigned long ) -1 ; \n } \n } \n current_start = host_start & qemu_host_page_mask ; \n flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE ; \n if ( fixed ) { \n flags |= MAP_FIXED ; \n } \n while ( 1 ) { \n real_start = ( unsigned long ) \n mmap ( ( void * ) current_start , host_size , PROT_NONE , flags , -1 , 0 ) ; \n if ( real_start == ( unsigned long ) -1 ) { \n return ( unsigned long ) -1 ; \n } \n if ( ( real_start == current_start ) \n && guest_validate_base ( real_start - guest_start ) ) { \n break ; \n } \n munmap ( ( void * ) real_start , host_size ) ; \n current_start += qemu_host_page_size ; \n if ( host_start == current_start ) { \n return ( unsigned long ) -1 ; \n } \n } \n return real_start ; \n }", "idx": 15844}
{"project": "qemu", "commit_id": "e58d695e6c3a5cfa0aa2fc91b87ade017ef28b05", "target": 1, "func": "static void qmp_input_start_struct ( Visitor * v , const char * name , void * * obj , \n size_t size , Error * * errp ) \n { \n QmpInputVisitor * qiv = to_qiv ( v ) ; \n QObject * qobj = qmp_input_get_object ( qiv , name , true ) ; \n Error * err = NULL ; \n if ( ! qobj || qobject_type ( qobj ) != QTYPE_QDICT ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : \" \" , \n \" \" ) ; \n return ; \n qmp_input_push ( qiv , qobj , & err ) ; \n if ( err ) { \n error_propagate ( errp , err ) ; \n return ; \n * obj = g_malloc0 ( size ) ;", "idx": 15852}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "int l4_register_io_memory ( CPUReadMemoryFunc * const * mem_read , \n CPUWriteMemoryFunc * const * mem_write , void * opaque ) \n { \n omap_l4_io_entry [ omap_l4_io_entries ] . mem_read = mem_read ; \n omap_l4_io_entry [ omap_l4_io_entries ] . mem_write = mem_write ; \n omap_l4_io_entry [ omap_l4_io_entries ] . opaque = opaque ; \n return omap_l4_io_entries ++ ; \n }", "idx": 15869}
{"project": "qemu", "commit_id": "db1e80ee2ed6fc9eb6b203873b39752144f5577f", "target": 0, "func": "static int vhdx_create_new_headers ( BlockDriverState * bs , uint64_t image_size , \n uint32_t log_size ) \n { \n int ret = 0 ; \n VHDXHeader * hdr = NULL ; \n hdr = g_new0 ( VHDXHeader , 1 ) ; \n hdr -> signature = VHDX_HEADER_SIGNATURE ; \n hdr -> sequence_number = g_random_int ( ) ; \n hdr -> log_version = 0 ; \n hdr -> version = 1 ; \n hdr -> log_length = log_size ; \n hdr -> log_offset = VHDX_HEADER_SECTION_END ; \n vhdx_guid_generate ( & hdr -> file_write_guid ) ; \n vhdx_guid_generate ( & hdr -> data_write_guid ) ; \n ret = vhdx_write_header ( bs , hdr , VHDX_HEADER1_OFFSET , false ) ; \n if ( ret < 0 ) { \n goto exit ; \n } \n hdr -> sequence_number ++ ; \n ret = vhdx_write_header ( bs , hdr , VHDX_HEADER2_OFFSET , false ) ; \n if ( ret < 0 ) { \n goto exit ; \n } \n exit : \n g_free ( hdr ) ; \n return ret ; \n }", "idx": 15877}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_net_handle_data ( USBDevice * dev , USBPacket * p ) \n { \n USBNetState * s = ( USBNetState * ) dev ; \n int ret = 0 ; \n switch ( p -> pid ) { \n case USB_TOKEN_IN : \n switch ( p -> devep ) { \n case 1 : \n ret = usb_net_handle_statusin ( s , p ) ; \n break ; \n case 2 : \n ret = usb_net_handle_datain ( s , p ) ; \n break ; \n default : \n goto fail ; \n } \n break ; \n case USB_TOKEN_OUT : \n switch ( p -> devep ) { \n case 2 : \n ret = usb_net_handle_dataout ( s , p ) ; \n break ; \n default : \n goto fail ; \n } \n break ; \n default : \n fail : \n ret = USB_RET_STALL ; \n break ; \n } \n if ( ret == USB_RET_STALL ) \n fprintf ( stderr , \" \" \n \" \\n \" , \n p -> pid , p -> devep , p -> iov . size ) ; \n return ret ; \n }", "idx": 15902}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "static void migrate_fd_monitor_suspend ( MigrationState * s , Monitor * mon ) \n { \n if ( monitor_suspend ( mon ) == 0 ) { \n DPRINTF ( \" \\n \" ) ; \n } else { \n monitor_printf ( mon , \" \" \n \" \\n \" ) ; \n } \n }", "idx": 15918}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect ( struct vmsvga_state_s * s , \n int x , int y , int w , int h ) \n { \n int line ; \n int bypl ; \n int width ; \n int start ; \n uint8_t * src ; \n uint8_t * dst ; \n if ( x + w > s -> width ) { \n fprintf ( stderr , \" \\n \" , \n __FUNCTION__ , x , w ) ; \n x = MIN ( x , s -> width ) ; \n w = s -> width - x ; \n } \n if ( y + h > s -> height ) { \n fprintf ( stderr , \" \\n \" , \n __FUNCTION__ , y , h ) ; \n y = MIN ( y , s -> height ) ; \n h = s -> height - y ; \n } \n line = h ; \n bypl = s -> bypp * s -> width ; \n width = s -> bypp * w ; \n start = s -> bypp * x + bypl * y ; \n src = s -> vga . vram_ptr + start ; \n dst = ds_get_data ( s -> vga . ds ) + start ; \n for ( ; line > 0 ; line -- , src += bypl , dst += bypl ) \n memcpy ( dst , src , width ) ; \n dpy_gfx_update ( s -> vga . ds , x , y , w , h ) ; \n }", "idx": 15922}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void qemu_tcg_init_vcpu ( void * _env ) \n { \n CPUState * env = _env ; \n if ( ! tcg_cpu_thread ) { \n env -> thread = qemu_mallocz ( sizeof ( QemuThread ) ) ; \n env -> halt_cond = qemu_mallocz ( sizeof ( QemuCond ) ) ; \n qemu_cond_init ( env -> halt_cond ) ; \n qemu_thread_create ( env -> thread , qemu_tcg_cpu_thread_fn , env ) ; \n while ( env -> created == 0 ) \n qemu_cond_timedwait ( & qemu_cpu_cond , & qemu_global_mutex , 100 ) ; \n tcg_cpu_thread = env -> thread ; \n tcg_halt_cond = env -> halt_cond ; \n } else { \n env -> thread = tcg_cpu_thread ; \n env -> halt_cond = tcg_halt_cond ; \n } \n }", "idx": 15928}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qdict_del ( QDict * qdict , const char * key ) \n { \n QDictEntry * entry ; \n entry = qdict_find ( qdict , key , tdb_hash ( key ) % QDICT_HASH_SIZE ) ; \n if ( entry ) { \n LIST_REMOVE ( entry , next ) ; \n qentry_destroy ( entry ) ; \n qdict -> size -- ; \n } \n }", "idx": 15952}
{"project": "qemu", "commit_id": "2ff64038a59e8de2baa485806be0838f49f70b79", "target": 0, "func": "static void migration_bitmap_sync_range ( ram_addr_t start , ram_addr_t length ) \n { \n migration_dirty_pages += \n cpu_physical_memory_sync_dirty_bitmap ( migration_bitmap , start , length ) ; \n }", "idx": 15954}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int pci_unin_map_irq ( PCIDevice * pci_dev , int irq_num ) \n { \n int retval ; \n int devfn = pci_dev -> devfn & 0x00FFFFFF ; \n retval = ( ( ( devfn >> 11 ) & 0x1F ) + irq_num ) & 3 ; \n return retval ; \n }", "idx": 15973}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "void tcp_start_outgoing_migration ( MigrationState * s , \n const char * host_port , \n Error * * errp ) \n { \n Error * err = NULL ; \n SocketAddress * saddr = tcp_build_address ( host_port , & err ) ; \n if ( ! err ) { \n socket_start_outgoing_migration ( s , saddr , & err ) ; \n } \n error_propagate ( errp , err ) ; \n }", "idx": 16032}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int ast2400_rambits ( AspeedSDMCState * s ) \n { \n switch ( s -> ram_size >> 20 ) { \n case 64 : \n return ASPEED_SDMC_DRAM_64MB ; \n case 128 : \n return ASPEED_SDMC_DRAM_128MB ; \n case 256 : \n return ASPEED_SDMC_DRAM_256MB ; \n case 512 : \n return ASPEED_SDMC_DRAM_512MB ; \n default : \n break ; \n } \n error_report ( \" \" PRIx64 \n \" \" , s -> ram_size ) ; \n s -> ram_size = 256 << 20 ; \n return ASPEED_SDMC_DRAM_256MB ; \n }", "idx": 16036}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t proxy_readlink ( FsContext * fs_ctx , V9fsPath * fs_path , \n char * buf , size_t bufsz ) \n { \n int retval ; \n retval = v9fs_request ( fs_ctx -> private , T_READLINK , buf , \" \" , \n fs_path , bufsz ) ; \n if ( retval < 0 ) { \n errno = - retval ; \n return -1 ; \n } \n return strlen ( buf ) ; \n }", "idx": 16076}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static void buffer_reset ( Buffer * buffer ) \n { \n buffer -> offset = 0 ; \n }", "idx": 16109}
{"project": "qemu", "commit_id": "8c0a6dc96cd14c48da4a61fe35431f36d6e6e467", "target": 1, "func": "static void test_hash_speed ( const void * opaque ) \n { \n size_t chunk_size = ( size_t ) opaque ; \n uint8_t * in = NULL , * out = NULL ; \n size_t out_len = 0 ; \n double total = 0.0 ; \n struct iovec iov ; \n int ret ; \n in = g_new0 ( uint8_t , chunk_size ) ; \n memset ( in , g_test_rand_int ( ) , chunk_size ) ; \n iov . iov_base = ( char * ) in ; \n iov . iov_len = chunk_size ; \n g_test_timer_start ( ) ; \n do { \n ret = qcrypto_hash_bytesv ( QCRYPTO_HASH_ALG_SHA256 , \n & iov , 1 , & out , & out_len , \n NULL ) ; \n g_assert ( ret == 0 ) ; \n total += chunk_size ; \n } while ( g_test_timer_elapsed ( ) < 5.0 ) ; \n total /= 1024 * 1024 ; \n g_print ( \" \" ) ; \n g_print ( \" \" , chunk_size ) ; \n g_print ( \" \" , total , g_test_timer_last ( ) ) ; \n g_print ( \" \\n \" , total / g_test_timer_last ( ) ) ; \n g_free ( out ) ; \n g_free ( in ) ; \n }", "idx": 16124}
{"project": "qemu", "commit_id": "08b9e0ba623c4468fe94026a9bdd086526ef62f0", "target": 1, "func": "static int vhost_kernel_memslots_limit ( struct vhost_dev * dev ) \n { \n int limit = 64 ; \n char * s ; \n if ( g_file_get_contents ( \" \" , \n & s , NULL , NULL ) ) { \n uint64_t val = g_ascii_strtoull ( s , NULL , 10 ) ; \n if ( ! ( ( val == G_MAXUINT64 || ! val ) && errno ) ) { \n return val ; \n } \n error_report ( \" \" \n \" \" , s ) ; \n } \n return limit ; \n }", "idx": 16126}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool coroutine_fn wait_serialising_requests ( BdrvTrackedRequest * self ) \n { \n BlockDriverState * bs = self -> bs ; \n BdrvTrackedRequest * req ; \n bool retry ; \n bool waited = false ; \n if ( ! bs -> serialising_in_flight ) { \n return false ; \n } \n do { \n retry = false ; \n QLIST_FOREACH ( req , & bs -> tracked_requests , list )  { \n if ( req == self || ( ! req -> serialising && ! self -> serialising ) ) { \n continue ; \n } \n if ( tracked_request_overlaps ( req , self -> overlap_offset , \n self -> overlap_bytes ) ) \n { \n assert ( qemu_coroutine_self ( ) != req -> co ) ; \n if ( ! req -> waiting_for ) { \n self -> waiting_for = req ; \n qemu_co_queue_wait ( & req -> wait_queue ) ; \n self -> waiting_for = NULL ; \n retry = true ; \n waited = true ; \n break ; \n } \n } \n } \n } while ( retry ) ; \n return waited ; \n }", "idx": 16140}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_device_init ( USBDevice * dev ) \n { \n USBDeviceClass * klass = USB_DEVICE_GET_CLASS ( dev ) ; \n if ( klass -> init ) { \n return klass -> init ( dev ) ; \n } \n return 0 ; \n }", "idx": 16168}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "int bdrv_ioctl ( BlockDriverState * bs , unsigned long int req , void * buf ) \n { \n BdrvIoctlCoData data = { \n . bs = bs , \n . req = req , \n . buf = buf , \n . ret = - EINPROGRESS , \n } ; \n if ( qemu_in_coroutine ( ) ) { \n bdrv_co_ioctl_entry ( & data ) ; \n } else { \n Coroutine * co = qemu_coroutine_create ( bdrv_co_ioctl_entry ) ; \n qemu_coroutine_enter ( co , & data ) ; \n while ( data . ret == - EINPROGRESS ) { \n aio_poll ( bdrv_get_aio_context ( bs ) , true ) ; \n } \n } \n return data . ret ; \n }", "idx": 16214}
{"project": "qemu", "commit_id": "98ee9bedc734e18287902f39e3a3a8adb399386a", "target": 0, "func": "void ioinst_handle_stcrw ( S390CPU * cpu , uint32_t ipb , uintptr_t ra ) \n { \n CRW crw ; \n uint64_t addr ; \n int cc ; \n CPUS390XState * env = & cpu -> env ; \n uint8_t ar ; \n addr = decode_basedisp_s ( env , ipb , & ar ) ; \n if ( addr & 3 ) { \n s390_program_interrupt ( env , PGM_SPECIFICATION , 4 , ra ) ; \n return ; \n } \n cc = css_do_stcrw ( & crw ) ; \n if ( s390_cpu_virt_mem_write ( cpu , addr , ar , & crw , sizeof ( crw ) ) == 0 ) { \n setcc ( cpu , cc ) ; \n } else if ( cc == 0 ) { \n css_undo_stcrw ( & crw ) ; \n } \n }", "idx": 16247}
{"project": "qemu", "commit_id": "ba14414174b72fa231997243a9650feaa520d054", "target": 0, "func": "static void migrate_put_status ( QDict * qdict , const char * name , \n uint64_t trans , uint64_t rem , uint64_t total ) \n { \n QObject * obj ; \n obj = qobject_from_jsonf ( \" \" PRId64 \" \" \n \" \" PRId64 \" \" \n \" \" PRId64 \" \" , trans , rem , total ) ; \n assert ( obj != NULL ) ; \n qdict_put_obj ( qdict , name , obj ) ; \n }", "idx": 16252}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_stack_object_free ( StackObject * tos ) \n { \n if ( tos -> h ) { \n g_hash_table_unref ( tos -> h ) ; \n } \n g_free ( tos ) ; \n }", "idx": 16277}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timer_expired ( QEMUTimer * timer_head , int64_t current_time ) \n { \n return timer_expired_ns ( timer_head , current_time * timer_head -> scale ) ; \n }", "idx": 16279}
{"project": "qemu", "commit_id": "ee25595f0126de0f83da86cc29ba2365be7a50d2", "target": 1, "func": "static void check_cmd ( AHCIState * s , int port ) \n { \n AHCIPortRegs * pr = & s -> dev [ port ] . port_regs ; \n int slot ; \n if ( ( pr -> cmd & PORT_CMD_START ) && pr -> cmd_issue ) { \n for ( slot = 0 ; ( slot < 32 ) && pr -> cmd_issue ; slot ++ ) { \n if ( ( pr -> cmd_issue & ( 1 << slot ) ) && \n ! handle_cmd ( s , port , slot ) ) { \n pr -> cmd_issue &= ~ ( 1 << slot ) ; \n } \n } \n } \n }", "idx": 16283}
{"project": "qemu", "commit_id": "b11e20fb6c658bc13b2e4dfc1b86c2eb8731e374", "target": 1, "func": "static void cleanup_infolist ( CommandLineParameterInfoList * head ) \n { \n CommandLineParameterInfoList * pre_entry , * cur , * del_entry ; \n cur = head ; \n while ( cur -> next ) { \n pre_entry = head ; \n while ( pre_entry != cur -> next ) { \n if ( ! strcmp ( pre_entry -> value -> name , cur -> next -> value -> name ) ) { \n del_entry = cur -> next ; \n cur -> next = cur -> next -> next ; \n g_free ( del_entry ) ; \n break ; \n } \n pre_entry = pre_entry -> next ; \n } \n cur = cur -> next ; \n } \n }", "idx": 16294}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_check_align ( DisasContext * ctx , TCGv EA , int mask ) \n { \n int l1 = gen_new_label ( ) ; \n TCGv t0 = tcg_temp_new ( ) ; \n TCGv_i32 t1 , t2 ; \n gen_update_nip ( ctx , ctx -> nip - 4 ) ; \n tcg_gen_andi_tl ( t0 , EA , mask ) ; \n tcg_gen_brcondi_tl ( TCG_COND_EQ , t0 , 0 , l1 ) ; \n t1 = tcg_const_i32 ( POWERPC_EXCP_ALIGN ) ; \n t2 = tcg_const_i32 ( 0 ) ; \n gen_helper_raise_exception_err ( cpu_env , t1 , t2 ) ; \n tcg_temp_free_i32 ( t1 ) ; \n tcg_temp_free_i32 ( t2 ) ; \n gen_set_label ( l1 ) ; \n tcg_temp_free ( t0 ) ; \n }", "idx": 16305}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int64_t bdrv_nb_sectors ( BlockDriverState * bs ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( drv -> has_variable_length ) { \n int ret = refresh_total_sectors ( bs , bs -> total_sectors ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n } \n return bs -> total_sectors ; \n }", "idx": 16319}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void udp_chr_update_read_handler ( CharDriverState * chr ) \n { \n NetCharDriver * s = chr -> opaque ; \n if ( s -> tag ) { \n g_source_remove ( s -> tag ) ; \n s -> tag = 0 ; \n } \n if ( s -> chan ) { \n s -> tag = io_add_watch_poll ( s -> chan , udp_chr_read_poll , udp_chr_read , chr ) ; \n } \n }", "idx": 16339}
{"project": "qemu", "commit_id": "f47291b7a7ffa8854300283d4773ed17d5d581c1", "target": 1, "func": "void qemu_system_guest_panicked ( GuestPanicInformation * info ) \n { \n if ( current_cpu ) { \n current_cpu -> crash_occurred = true ; \n } \n qapi_event_send_guest_panicked ( GUEST_PANIC_ACTION_PAUSE , \n ! ! info , info , & error_abort ) ; \n vm_stop ( RUN_STATE_GUEST_PANICKED ) ; \n if ( ! no_shutdown ) { \n qapi_event_send_guest_panicked ( GUEST_PANIC_ACTION_POWEROFF , \n ! ! info , info , & error_abort ) ; \n qemu_system_shutdown_request ( ) ; \n } \n if ( info ) { \n if ( info -> type == GUEST_PANIC_INFORMATION_KIND_HYPER_V ) { \n qemu_log_mask ( LOG_GUEST_ERROR , \" \" PRIx64 \n \" \" PRIx64 \" \" PRIx64 \" \" PRIx64 \" \" PRIx64 \" \\n \" , \n info -> u . hyper_v . data -> arg1 , \n info -> u . hyper_v . data -> arg2 , \n info -> u . hyper_v . data -> arg3 , \n info -> u . hyper_v . data -> arg4 , \n info -> u . hyper_v . data -> arg5 ) ; \n } \n qapi_free_GuestPanicInformation ( info ) ; \n } \n }", "idx": 16348}
{"project": "qemu", "commit_id": "7102fa7073b2cefb33ab4012a11f15fbf297a74b", "target": 0, "func": "static void pc_compat_0_13 ( MachineState * machine ) \n { \n pc_compat_1_2 ( machine ) ; \n kvmclock_enabled = false ; \n }", "idx": 16396}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_gdbserver ( int argc , const char * * argv ) \n { \n int port ; \n port = DEFAULT_GDBSTUB_PORT ; \n if ( argc >= 2 ) \n port = atoi ( argv [ 1 ] ) ; \n if ( gdbserver_start ( port ) < 0 ) { \n qemu_printf ( \" \\n \" , port ) ; \n } else { \n qemu_printf ( \" \\n \" , port ) ; \n } \n }", "idx": 16408}
{"project": "qemu", "commit_id": "8917c3bdba37d6fe4393db0fad3fabbde9530d6b", "target": 0, "func": "sofcantsendmore ( struct socket * so )  \n { \n if ( ( so -> so_state & SS_NOFDREF ) == 0 ) { \n shutdown ( so -> s , 1 ) ; \n if ( global_readfds ) { \n FD_CLR ( so -> s , global_readfds ) ; \n } \n if ( global_xfds ) { \n FD_CLR ( so -> s , global_xfds ) ; \n } \n } \n so -> so_state &= ~ ( SS_ISFCONNECTING ) ; \n if ( so -> so_state & SS_FCANTRCVMORE ) { \n so -> so_state &= SS_PERSISTENT_MASK ; \n so -> so_state |= SS_NOFDREF ; \n } else { \n so -> so_state |= SS_FCANTSENDMORE ; \n } \n }", "idx": 16409}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "static void thread_pool_init ( void ) \n { \n thread_pool_init_one ( & global_pool , NULL ) ; \n }", "idx": 16414}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static void handle_notify ( EventNotifier * e ) \n { \n VirtIOBlockDataPlane * s = container_of ( e , VirtIOBlockDataPlane , \n host_notifier ) ; \n VirtQueueElement * elem ; \n VirtIOBlockReq * req ; \n int ret ; \n MultiReqBuffer mrb = { \n . num_writes = 0 , \n } ; \n event_notifier_test_and_clear ( & s -> host_notifier ) ; \n bdrv_io_plug ( s -> blk -> conf . bs ) ; \n for ( ; ; ) { \n vring_disable_notification ( s -> vdev , & s -> vring ) ; \n for ( ; ; ) { \n ret = vring_pop ( s -> vdev , & s -> vring , & elem ) ; \n if ( ret < 0 ) { \n assert ( elem == NULL ) ; \n break ; \n } \n trace_virtio_blk_data_plane_process_request ( s , elem -> out_num , \n elem -> in_num , elem -> index ) ; \n req = g_slice_new ( VirtIOBlockReq ) ; \n req -> dev = VIRTIO_BLK ( s -> vdev ) ; \n req -> elem = elem ; \n virtio_blk_handle_request ( req , & mrb ) ; \n } \n virtio_submit_multiwrite ( s -> blk -> conf . bs , & mrb ) ; \n if ( likely ( ret == - EAGAIN ) ) { \n if ( vring_enable_notification ( s -> vdev , & s -> vring ) ) { \n break ; \n } \n } else { \n break ; \n } \n } \n bdrv_io_unplug ( s -> blk -> conf . bs ) ; \n }", "idx": 16425}
{"project": "qemu", "commit_id": "d2164ad35c411d97abd2aa5c6f160283d215e214", "target": 1, "func": "static int get_int32_equal ( QEMUFile * f , void * pv , size_t size , \n VMStateField * field ) \n { \n int32_t * v = pv ; \n int32_t v2 ; \n qemu_get_sbe32s ( f , & v2 ) ; \n if ( * v == v2 ) { \n return 0 ; \n error_report ( \" \" PRIx32 \" \" PRIx32 , * v , v2 ) ; \n return - EINVAL ;", "idx": 16427}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "static void cpu_sh4_reset ( CPUSH4State * env ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  env -> sr = 0 ; \n #else \n env -> sr = SR_MD | SR_RB | SR_BL | SR_I3 | SR_I2 | SR_I1 | SR_I0 ; \n #endif \n env -> vbr = 0 ; \n env -> pc = 0xA0000000 ; \n #if defined ( CONFIG_USER_ONLY )  \n  env -> fpscr = FPSCR_PR ; \n set_float_rounding_mode ( float_round_nearest_even , & env -> fp_status ) ; \n #else \n env -> fpscr = 0x00040001 ; \n set_float_rounding_mode ( float_round_to_zero , & env -> fp_status ) ; \n #endif \n env -> mmucr = 0 ; ", "idx": 16468}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void spapr_vlan_cleanup ( NetClientState * nc ) \n { \n VIOsPAPRVLANDevice * dev = qemu_get_nic_opaque ( nc ) ; \n dev -> nic = NULL ; \n }", "idx": 16484}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static int blkdebug_open ( BlockDriverState * bs , const char * filename , int flags ) \n { \n BDRVBlkdebugState * s = bs -> opaque ; \n int ret ; \n char * config , * c ; \n if ( strncmp ( filename , \" \" , strlen ( \" \" ) ) ) { \n return - EINVAL ; \n } \n filename += strlen ( \" \" ) ; \n c = strchr ( filename , ' ' ) ; \n if ( c == NULL ) { \n return - EINVAL ; \n } \n config = strdup ( filename ) ; \n config [ c - filename ] = ' \\0 ' ; \n ret = read_config ( s , config ) ; \n free ( config ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n filename = c + 1 ; \n s -> vars . state = 1 ; \n ret = bdrv_file_open ( & bs -> file , filename , flags ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return 0 ; \n }", "idx": 16500}
{"project": "qemu", "commit_id": "ecbe1576b3287e7907b524901063a8117f544e61", "target": 0, "func": "static inline int seek_to_sector ( BlockDriverState * bs , int64_t sector_num ) \n { \n BDRVBochsState * s = bs -> opaque ; \n int64_t offset = sector_num * 512 ; \n int64_t extent_index , extent_offset , bitmap_offset , block_offset ; \n char bitmap_entry ; \n extent_index = offset / s -> extent_size ; \n extent_offset = ( offset % s -> extent_size ) / 512 ; \n if ( s -> catalog_bitmap [ extent_index ] == 0xffffffff ) \n { \n return -1 ; \n } \n bitmap_offset = s -> data_offset + ( 512 * s -> catalog_bitmap [ extent_index ] * \n ( s -> extent_blocks + s -> bitmap_blocks ) ) ; \n block_offset = bitmap_offset + ( 512 * ( s -> bitmap_blocks + extent_offset ) ) ; \n lseek ( s -> fd , bitmap_offset + ( extent_offset / 8 ) , SEEK_SET ) ; \n if ( read ( s -> fd , & bitmap_entry , 1 ) != 1 ) \n return -1 ; \n if ( ! ( ( bitmap_entry >> ( extent_offset % 8 ) ) & 1 ) ) \n { \n return -1 ; \n } \n lseek ( s -> fd , block_offset , SEEK_SET ) ; \n return 0 ; \n }", "idx": 16510}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_handshake_io ( void * opaque ) { \n struct VncState * vs = ( struct VncState * ) opaque ; \n VNC_DEBUG ( \" \\n \" ) ; \n vnc_continue_handshake ( vs ) ; \n }", "idx": 16511}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_remove ( FsContext * ctx , const char * path ) \n { \n int err ; \n struct stat stbuf ; \n char buffer [ PATH_MAX ] ; \n if ( ctx -> export_flags & V9FS_SM_MAPPED_FILE ) { \n err = lstat ( rpath ( ctx , path , buffer ) , & stbuf ) ; \n if ( err ) { \n goto err_out ; \n } \n if ( S_ISDIR ( stbuf . st_mode ) ) { \n snprintf ( buffer , ARRAY_SIZE ( buffer ) , \" \" , \n ctx -> fs_root , path , VIRTFS_META_DIR ) ; \n err = remove ( buffer ) ; \n if ( err < 0 && errno != ENOENT ) { \n goto err_out ; \n } \n } \n err = remove ( local_mapped_attr_path ( ctx , path , buffer ) ) ; \n if ( err < 0 && errno != ENOENT ) { \n goto err_out ; \n } \n } \n return remove ( rpath ( ctx , path , buffer ) ) ; \n err_out : \n return err ; \n }", "idx": 16515}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void qed_unplug_allocating_write_reqs ( BDRVQEDState * s ) \n { \n assert ( s -> allocating_write_reqs_plugged ) ; \n s -> allocating_write_reqs_plugged = false ; \n qemu_co_enter_next ( & s -> allocating_write_reqs ) ; \n }", "idx": 16527}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static int xen_pt_bar_reg_init ( XenPCIPassthroughState * s , XenPTRegInfo * reg , \n uint32_t real_offset , uint32_t * data ) \n { \n uint32_t reg_field = 0 ; \n int index ; \n index = xen_pt_bar_offset_to_index ( reg -> offset ) ; \n if ( index < 0 || index >= PCI_NUM_REGIONS ) { \n XEN_PT_ERR ( & s -> dev , \" \\n \" , index ) ; \n return -1 ; \n } \n s -> bases [ index ] . bar_flag = xen_pt_bar_reg_parse ( s , reg ) ; \n if ( s -> bases [ index ] . bar_flag == XEN_PT_BAR_FLAG_UNUSED ) { \n reg_field = XEN_PT_INVALID_REG ; \n } \n * data = reg_field ; \n return 0 ; \n }", "idx": 16533}
{"project": "qemu", "commit_id": "a57d23e4f7e7e81c839a7b53a973ac71eefe91da", "target": 0, "func": "void cpu_physical_memory_reset_dirty ( ram_addr_t start , ram_addr_t end , \n int dirty_flags ) \n { \n CPUState * env ; \n unsigned long length , start1 ; \n int i ; \n start &= TARGET_PAGE_MASK ; \n end = TARGET_PAGE_ALIGN ( end ) ; \n length = end - start ; \n if ( length == 0 ) \n return ; \n cpu_physical_memory_mask_dirty_range ( start , length , dirty_flags ) ; \n start1 = ( unsigned long ) qemu_safe_ram_ptr ( start ) ; \n if ( ( unsigned long ) qemu_safe_ram_ptr ( end - 1 ) - start1 \n != ( end - 1 ) - start ) { \n abort ( ) ; \n } \n for ( env = first_cpu ; env != NULL ; env = env -> next_cpu ) { \n int mmu_idx ; \n for ( mmu_idx = 0 ; mmu_idx < NB_MMU_MODES ; mmu_idx ++ ) { \n for ( i = 0 ; i < CPU_TLB_SIZE ; i ++ ) \n tlb_reset_dirty_range ( & env -> tlb_table [ mmu_idx ] [ i ] , \n start1 , length ) ; \n } \n } \n }", "idx": 16558}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void phys_page_set ( target_phys_addr_t index , target_phys_addr_t nb , \n uint16_t leaf ) \n { \n phys_map_node_reserve ( 3 * P_L2_LEVELS ) ; \n phys_page_set_level ( & phys_map , & index , & nb , leaf , P_L2_LEVELS - 1 ) ; \n }", "idx": 16569}
{"project": "qemu", "commit_id": "90f998f5f4267a0c22e983f533d19b9de1849283", "target": 0, "func": "void qemu_chr_fe_printf ( CharDriverState * s , const char * fmt , ... ) \n { \n char buf [ READ_BUF_LEN ] ; \n va_list ap ; \n va_start ( ap , fmt ) ; \n vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ; \n qemu_chr_fe_write ( s , ( uint8_t * ) buf , strlen ( buf ) ) ; \n va_end ( ap ) ; \n }", "idx": 16570}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "timer_read ( void * opaque , target_phys_addr_t addr , unsigned int size )  \n { \n struct etrax_timer * t = opaque ; \n uint32_t r = 0 ; \n switch ( addr ) { \n case R_TMR0_DATA : \n r = ptimer_get_count ( t -> ptimer_t0 ) ; \n break ; \n case R_TMR1_DATA : \n r = ptimer_get_count ( t -> ptimer_t1 ) ; \n break ; \n case R_TIME : \n r = qemu_get_clock_ns ( vm_clock ) / 10 ; \n break ; \n case RW_INTR_MASK : \n r = t -> rw_intr_mask ; \n break ; \n case R_MASKED_INTR : \n r = t -> r_intr & t -> rw_intr_mask ; \n break ; \n default : \n D ( printf ( \" \\n \" , __func__ , addr ) ) ; \n break ; \n } \n return r ; \n }", "idx": 16582}
{"project": "qemu", "commit_id": "b92ad3949bc9cacd1652b4e07e7f6003b9e512af", "target": 0, "func": "static void virt_class_init ( ObjectClass * oc , void * data ) \n { \n MachineClass * mc = MACHINE_CLASS ( oc ) ; \n mc -> desc = \" \" , \n mc -> init = machvirt_init ; \n mc -> max_cpus = 8 ; \n mc -> has_dynamic_sysbus = true ; \n mc -> block_default_type = IF_VIRTIO ; \n mc -> no_cdrom = 1 ; \n }", "idx": 16584}
{"project": "qemu", "commit_id": "cf7c0ff521b0710079aa28f21937fb7dbb3f5224", "target": 0, "func": "static GArray * nvdimm_build_device_structure ( void ) \n { \n GSList * device_list = nvdimm_get_plugged_device_list ( ) ; \n GArray * structures = g_array_new ( false , true \n , 1 ) ; \n for ( ; device_list ; device_list = device_list -> next ) { \n DeviceState * dev = device_list -> data ; \n nvdimm_build_structure_spa ( structures , dev ) ; \n nvdimm_build_structure_memdev ( structures , dev ) ; \n nvdimm_build_structure_dcr ( structures , dev ) ; \n } \n g_slist_free ( device_list ) ; \n return structures ; \n }", "idx": 16596}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_timer ( void * opaque ) \n { \n pflash_t * pfl = opaque ; \n DPRINTF ( \" \\n \" , __func__ , pfl -> cmd ) ; \n pfl -> status ^= 0x80 ; \n if ( pfl -> bypass ) { \n pfl -> wcycle = 2 ; \n } else { \n memory_region_rom_device_set_readable ( & pfl -> mem , true ) ; \n pfl -> wcycle = 0 ; \n } \n pfl -> cmd = 0 ; \n }", "idx": 16597}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "func": "void helper_evaluate_flags_mcp ( void ) \n { \n uint32_t src ; \n uint32_t dst ; \n uint32_t res ; \n uint32_t flags = 0 ; \n src = env -> cc_src ; \n dst = env -> cc_dest ; \n res = env -> cc_result ; \n if ( ( res & 0x80000000L ) != 0L ) \n { \n flags |= N_FLAG ; \n if ( ( ( src & 0x80000000L ) == 0L ) \n && ( ( dst & 0x80000000L ) == 0L ) ) \n { \n flags |= V_FLAG ; \n } \n else if ( ( ( src & 0x80000000L ) != 0L ) && \n ( ( dst & 0x80000000L ) != 0L ) ) \n { \n flags |= R_FLAG ; \n } \n } \n else \n { \n if ( res == 0L ) \n flags |= Z_FLAG ; \n if ( ( ( src & 0x80000000L ) != 0L ) \n && ( ( dst & 0x80000000L ) != 0L ) ) \n flags |= V_FLAG ; \n if ( ( dst & 0x80000000L ) != 0L \n || ( src & 0x80000000L ) != 0L ) \n flags |= R_FLAG ; \n } \n evaluate_flags_writeback ( flags ) ; \n }", "idx": 16624}
{"project": "qemu", "commit_id": "2a74440547ea0a15195224fa2b7784b267cbfe15", "target": 0, "func": "QError * qerror_new ( void ) \n { \n QError * qerr ; \n qerr = g_malloc0 ( sizeof ( * qerr ) ) ; \n QOBJECT_INIT ( qerr , & qerror_type ) ; \n return qerr ; \n }", "idx": 16648}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_write ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! bs -> drv ) \n return - ENOMEDIUM ; \n if ( bs -> read_only ) \n return - EACCES ; \n if ( drv -> bdrv_pwrite ) { \n int ret , len , count = 0 ; \n len = nb_sectors * 512 ; \n do { \n ret = drv -> bdrv_pwrite ( bs , sector_num * 512 , buf , len - count ) ; \n if ( ret < 0 ) { \n printf ( \" \\n \" , ret ) ; \n return ret ; \n } \n count += ret ; \n buf += ret ; \n } while ( count != len ) ; \n bs -> wr_bytes += ( unsigned ) len ; \n bs -> wr_ops ++ ; \n return 0 ; \n } \n return drv -> bdrv_write ( bs , sector_num , buf , nb_sectors ) ; \n }", "idx": 16685}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power8nvl_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PnvChipClass * k = PNV_CHIP_CLASS ( klass ) ; \n k -> cpu_model = \" \" ; \n k -> chip_type = PNV_CHIP_POWER8NVL ; \n k -> chip_cfam_id = 0x120d304980000000ull ; \n k -> cores_mask = POWER8_CORE_MASK ; \n k -> core_pir = pnv_chip_core_pir_p8 ; \n dc -> desc = \" \" ; \n }", "idx": 16698}
{"project": "qemu", "commit_id": "1a01716a307387e5cf1336f61a96f772dddadc90", "target": 1, "func": "static void gd_menu_switch_vc ( GtkMenuItem * item , void * opaque ) \n { \n GtkDisplayState * s = opaque ; \n VirtualConsole * vc = gd_vc_find_by_menu ( s ) ; \n GtkNotebook * nb = GTK_NOTEBOOK ( s -> notebook ) ; \n gint page ; \n gtk_release_modifiers ( s ) ; \n if ( vc ) { \n page = gtk_notebook_page_num ( nb , vc -> tab_item ) ; \n gtk_notebook_set_current_page ( nb , page ) ; \n gtk_widget_grab_focus ( vc -> focus ) ; \n } \n }", "idx": 16721}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void blockdev_mark_auto_del ( BlockDriverState * bs ) \n { \n BlockBackend * blk = bs -> blk ; \n DriveInfo * dinfo = blk_legacy_dinfo ( blk ) ; \n if ( dinfo && ! dinfo -> enable_auto_del ) { \n return ; \n } \n if ( bs -> job ) { \n block_job_cancel ( bs -> job ) ; \n } \n if ( dinfo ) { \n dinfo -> auto_del = 1 ; \n } \n }", "idx": 16731}
{"project": "qemu", "commit_id": "ddcb73b7782cb6104479503faea04cc224f982b5", "target": 1, "func": "e1000_can_receive ( NetClientState * nc )  \n { \n E1000State * s = qemu_get_nic_opaque ( nc ) ; \n return ( s -> mac_reg [ RCTL ] & E1000_RCTL_EN ) && e1000_has_rxbufs ( s , 1 ) ; \n }", "idx": 16753}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void rtce_init ( VIOsPAPRDevice * dev ) \n { \n size_t size = ( dev -> rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT ) \n * sizeof ( VIOsPAPR_RTCE ) ; \n if ( size ) { \n dev -> rtce_table = kvmppc_create_spapr_tce ( dev -> reg , \n dev -> rtce_window_size , \n & dev -> kvmtce_fd ) ; \n if ( ! dev -> rtce_table ) { \n dev -> rtce_table = g_malloc0 ( size ) ; \n } \n } \n }", "idx": 16758}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void vnc_desktop_resize ( VncState * vs ) \n { \n DisplaySurface * ds = vs -> vd -> ds ; \n if ( vs -> csock == -1 || ! vnc_has_feature ( vs , VNC_FEATURE_RESIZE ) ) { \n return ; \n } \n if ( vs -> client_width == surface_width ( ds ) && \n vs -> client_height == surface_height ( ds ) ) { \n return ; \n } \n vs -> client_width = surface_width ( ds ) ; \n vs -> client_height = surface_height ( ds ) ; \n vnc_lock_output ( vs ) ; \n vnc_write_u8 ( vs , VNC_MSG_SERVER_FRAMEBUFFER_UPDATE ) ; \n vnc_write_u8 ( vs , 0 ) ; \n vnc_write_u16 ( vs , 1 ) ; \n vnc_framebuffer_update ( vs , 0 , 0 , vs -> client_width , vs -> client_height , \n VNC_ENCODING_DESKTOPRESIZE ) ; \n vnc_unlock_output ( vs ) ; \n vnc_flush ( vs ) ; \n }", "idx": 16759}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_be_phys ( target_phys_addr_t addr , uint32_t val ) \n { \n stl_phys_internal ( addr , val , DEVICE_BIG_ENDIAN ) ; \n }", "idx": 16776}
{"project": "qemu", "commit_id": "bf937a7965c1d1a6dce4f615d0ead2e2ab505004", "target": 0, "func": "static uint8_t * l2cap_bframe_out ( struct bt_l2cap_conn_params_s * parm , int len ) \n { \n struct l2cap_chan_s * chan = ( struct l2cap_chan_s * ) parm ; \n if ( len > chan -> params . remote_mtu ) { \n fprintf ( stderr , \" \\n \" , \n __func__ , \n chan -> remote_cid , chan -> params . remote_mtu ) ; \n exit ( -1 ) ; \n } \n return l2cap_pdu_out ( chan -> l2cap , chan -> remote_cid , len ) ; \n }", "idx": 16777}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "static int do_open_tray ( const char * device , bool force , Error * * errp ) \n { \n BlockBackend * blk ; \n bool locked ; \n blk = blk_by_name ( device ) ; \n if ( ! blk ) { \n error_set ( errp , ERROR_CLASS_DEVICE_NOT_FOUND , \n \" \" , device ) ; \n return - ENODEV ; \n } \n if ( ! blk_dev_has_removable_media ( blk ) ) { \n error_setg ( errp , \" \" , device ) ; \n return - ENOTSUP ; \n } \n if ( ! blk_dev_has_tray ( blk ) ) { \n return ENOSYS ; \n } \n if ( blk_dev_is_tray_open ( blk ) ) { \n return 0 ; \n } \n locked = blk_dev_is_medium_locked ( blk ) ; \n if ( locked ) { \n blk_dev_eject_request ( blk , force ) ; \n } \n if ( ! locked || force ) { \n blk_dev_change_media_cb ( blk , false ) ; \n } \n if ( locked && ! force ) { \n return EINPROGRESS ; \n } \n return 0 ; \n }", "idx": 16804}
{"project": "qemu", "commit_id": "e5766d6ec7524345f4c0fa284c065b68c5e93049", "target": 0, "func": "static int read_config ( BDRVBlkdebugState * s , const char * filename , \n QDict * options , Error * * errp ) \n { \n FILE * f = NULL ; \n int ret ; \n struct add_rule_data d ; \n Error * local_err = NULL ; \n if ( filename ) { \n f = fopen ( filename , \" \" ) ; \n if ( f == NULL ) { \n error_setg_errno ( errp , errno , \" \" ) ; \n return - errno ; \n } \n ret = qemu_config_parse ( f , config_groups , filename ) ; \n if ( ret < 0 ) { \n error_setg ( errp , \" \" ) ; \n ret = - EINVAL ; \n goto fail ; \n } \n } \n qemu_config_parse_qdict ( options , config_groups , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n ret = - EINVAL ; \n goto fail ; \n } \n d . s = s ; \n d . action = ACTION_INJECT_ERROR ; \n qemu_opts_foreach ( & inject_error_opts , add_rule , & d , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n ret = - EINVAL ; \n goto fail ; \n } \n d . action = ACTION_SET_STATE ; \n qemu_opts_foreach ( & set_state_opts , add_rule , & d , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n ret = - EINVAL ; \n goto fail ; \n } \n ret = 0 ; \n fail : \n qemu_opts_reset ( & inject_error_opts ) ; \n qemu_opts_reset ( & set_state_opts ) ; \n if ( f ) { \n fclose ( f ) ; \n } \n return ret ; \n }", "idx": 16816}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void kvm_log_start ( MemoryListener * listener , \n MemoryRegionSection * section ) \n { \n int r ; \n r = kvm_dirty_pages_log_change ( section -> offset_within_address_space , \n int128_get64 ( section -> size ) , true ) ; \n if ( r < 0 ) { \n abort ( ) ; \n } \n }", "idx": 16817}
{"project": "qemu", "commit_id": "02a08fef079469c005d48fe2d181f0e0eb5752ae", "target": 0, "func": "int tcp_socket_outgoing_spec ( const char * address_and_port ) \n { \n return inet_connect ( address_and_port , true , NULL ) ; \n }", "idx": 16821}
{"project": "qemu", "commit_id": "4837a1a51638ef1719bf8149591a57e7207db41a", "target": 1, "func": "static int blk_get_request ( struct XenBlkDev * blkdev , struct ioreq * ioreq , RING_IDX rc ) \n { \n switch ( blkdev -> protocol ) { \n case BLKIF_PROTOCOL_NATIVE : \n memcpy ( & ioreq -> req , RING_GET_REQUEST ( & blkdev -> rings . native , rc ) , \n sizeof ( ioreq -> req ) ) ; \n break ; \n case BLKIF_PROTOCOL_X86_32 : \n blkif_get_x86_32_req ( & ioreq -> req , \n RING_GET_REQUEST ( & blkdev -> rings . x86_32_part , rc ) ) ; \n break ; \n case BLKIF_PROTOCOL_X86_64 : \n blkif_get_x86_64_req ( & ioreq -> req , \n RING_GET_REQUEST ( & blkdev -> rings . x86_64_part , rc ) ) ; \n break ; \n } \n return 0 ; \n }", "idx": 16850}
{"project": "qemu", "commit_id": "1f0c461b82d5ec2664ca0cfc9548f80da87a8f8a", "target": 0, "func": "void blk_remove_bs ( BlockBackend * blk ) \n { \n assert ( blk -> root -> bs -> blk == blk ) ; \n notifier_list_notify ( & blk -> remove_bs_notifiers , blk ) ; \n if ( blk -> public . throttle_state ) { \n throttle_timers_detach_aio_context ( & blk -> public . throttle_timers ) ; \n } \n blk_update_root_state ( blk ) ; \n blk -> root -> bs -> blk = NULL ; \n bdrv_root_unref_child ( blk -> root ) ; \n blk -> root = NULL ; \n }", "idx": 16868}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_logicq_cc ( TCGv val ) \n { \n TCGv tmp = new_tmp ( ) ; \n gen_helper_logicq_cc ( tmp , val ) ; \n gen_logic_CC ( tmp ) ; \n dead_tmp ( tmp ) ; \n }", "idx": 16894}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB * dma_bdrv_io ( \n BlockDriverState * bs , QEMUSGList * sg , uint64_t sector_num , \n DMAIOFunc * io_func , BlockCompletionFunc * cb , \n void * opaque , DMADirection dir ) \n { \n DMAAIOCB * dbs = qemu_aio_get ( & dma_aiocb_info , bs , cb , opaque ) ; \n trace_dma_bdrv_io ( dbs , bs , sector_num , ( dir == DMA_DIRECTION_TO_DEVICE ) ) ; \n dbs -> acb = NULL ; \n dbs -> bs = bs ; \n dbs -> sg = sg ; \n dbs -> sector_num = sector_num ; \n dbs -> sg_cur_index = 0 ; \n dbs -> sg_cur_byte = 0 ; \n dbs -> dir = dir ; \n dbs -> io_func = io_func ; \n dbs -> bh = NULL ; \n qemu_iovec_init ( & dbs -> iov , sg -> nsg ) ; \n dma_bdrv_cb ( dbs , 0 ) ; \n return & dbs -> common ; \n }", "idx": 16898}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "void helper_ldl_l_raw ( uint64_t t0 , uint64_t t1 ) \n { \n env -> lock = t1 ; \n ldl_raw ( t1 , t0 ) ; \n }", "idx": 16909}
{"project": "qemu", "commit_id": "4500bc98a6aab1734d865afaeade3509eb65b560", "target": 0, "func": "static void dump_aml_files ( test_data * data ) \n { \n AcpiSdtTable * sdt ; \n GError * error = NULL ; \n gint fd ; \n ssize_t ret ; \n int i ; \n for ( i = 0 ; i < data -> ssdt_tables -> len ; ++ i ) { \n sdt = & g_array_index ( data -> ssdt_tables , AcpiSdtTable , i ) ; \n g_assert ( sdt -> aml ) ; \n fd = g_file_open_tmp ( \" \" , & sdt -> aml_file , & error ) ; \n g_assert_no_error ( error ) ; \n ret = qemu_write_full ( fd , sdt , sizeof ( AcpiTableHeader ) ) ; \n g_assert ( ret == sizeof ( AcpiTableHeader ) ) ; \n ret = qemu_write_full ( fd , sdt -> aml , sdt -> aml_len ) ; \n g_assert ( ret == sdt -> aml_len ) ; \n close ( fd ) ; \n } \n }", "idx": 16917}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_erase ( SDState * sd ) \n { \n int i , start , end ; \n if ( ! sd -> erase_start || ! sd -> erase_end ) { \n sd -> card_status |= ERASE_SEQ_ERROR ; \n return ; \n } \n start = sd -> erase_start >> \n ( HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT ) ; \n end = sd -> erase_end >> \n ( HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT ) ; \n sd -> erase_start = 0 ; \n sd -> erase_end = 0 ; \n sd -> csd [ 14 ] |= 0x40 ; \n for ( i = start ; i <= end ; i ++ ) \n if ( sd -> wp_groups [ i ] ) \n sd -> card_status |= WP_ERASE_SKIP ; \n }", "idx": 16947}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void tcg_init_vcpu ( void * _env ) \n { \n CPUState * env = _env ; \n if ( ! tcg_cpu_thread ) { \n env -> thread = qemu_mallocz ( sizeof ( QemuThread ) ) ; \n env -> halt_cond = qemu_mallocz ( sizeof ( QemuCond ) ) ; \n qemu_cond_init ( env -> halt_cond ) ; \n qemu_thread_create ( env -> thread , tcg_cpu_thread_fn , env ) ; \n while ( env -> created == 0 ) \n qemu_cond_timedwait ( & qemu_cpu_cond , & qemu_global_mutex , 100 ) ; \n tcg_cpu_thread = env -> thread ; \n tcg_halt_cond = env -> halt_cond ; \n } else { \n env -> thread = tcg_cpu_thread ; \n env -> halt_cond = tcg_halt_cond ; \n } \n }", "idx": 16948}
{"project": "qemu", "commit_id": "e68c35cfb8088a11300371751e3987f67cac15b1", "target": 0, "func": "static int nbd_negotiate_handle_list ( NBDClient * client , uint32_t length , \n Error * * errp ) \n { \n NBDExport * exp ; \n if ( length ) { \n if ( nbd_drop ( client -> ioc , length , errp ) < 0 ) { \n return - EIO ; \n } \n return nbd_negotiate_send_rep_err ( client -> ioc , \n NBD_REP_ERR_INVALID , NBD_OPT_LIST , \n errp , \n \" \" ) ; \n } \n QTAILQ_FOREACH ( exp , & exports , next )  { \n if ( nbd_negotiate_send_rep_list ( client -> ioc , exp , errp ) ) { \n return - EINVAL ; \n } \n } \n return nbd_negotiate_send_rep ( client -> ioc , NBD_REP_ACK , NBD_OPT_LIST , errp ) ; \n }", "idx": 16966}
{"project": "qemu", "commit_id": "082c6681b6c4af0035d9dad34a4a784be8c21dbe", "target": 0, "func": "static void init_excp_620 ( CPUPPCState * env ) \n { \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  env -> excp_vectors [ POWERPC_EXCP_RESET ] = 0x00000100 ; \n env -> excp_vectors [ POWERPC_EXCP_MCHECK ] = 0x00000200 ; \n env -> excp_vectors [ POWERPC_EXCP_DSI ] = 0x00000300 ; \n env -> excp_vectors [ POWERPC_EXCP_DSEG ] = 0x00000380 ; \n env -> excp_vectors [ POWERPC_EXCP_ISI ] = 0x00000400 ; \n env -> excp_vectors [ POWERPC_EXCP_ISEG ] = 0x00000480 ; \n env -> excp_vectors [ POWERPC_EXCP_EXTERNAL ] = 0x00000500 ; \n env -> excp_vectors [ POWERPC_EXCP_ALIGN ] = 0x00000600 ; \n env -> excp_vectors [ POWERPC_EXCP_PROGRAM ] = 0x00000700 ; \n env -> excp_vectors [ POWERPC_EXCP_FPU ] = 0x00000800 ; \n env -> excp_vectors [ POWERPC_EXCP_DECR ] = 0x00000900 ; \n env -> excp_vectors [ POWERPC_EXCP_SYSCALL ] = 0x00000C00 ; \n env -> excp_vectors [ POWERPC_EXCP_TRACE ] = 0x00000D00 ; \n env -> excp_vectors [ POWERPC_EXCP_FPA ] = 0x00000E00 ; \n env -> excp_vectors [ POWERPC_EXCP_PERFM ] = 0x00000F00 ; \n env -> excp_vectors [ POWERPC_EXCP_IABR ] = 0x00001300 ; \n env -> excp_vectors [ POWERPC_EXCP_SMI ] = 0x00001400 ; \n env -> excp_prefix = 0xFFF00000UL ; \n env -> hreset_vector = 0x0000000000000100ULL ; \n #endif \n }", "idx": 16967}
{"project": "qemu", "commit_id": "2bc22a58e16f0650e56dccfac9495e5aef58e2ef", "target": 1, "func": "void qemu_macaddr_default_if_unset ( MACAddr * macaddr ) \n { \n static int index = 0 ; \n static const MACAddr zero = { . a = { 0 , 0 , 0 , 0 , 0 , 0 } } ; \n if ( memcmp ( macaddr , & zero , sizeof ( zero ) ) != 0 ) \n return ; \n macaddr -> a [ 0 ] = 0x52 ; \n macaddr -> a [ 1 ] = 0x54 ; \n macaddr -> a [ 2 ] = 0x00 ; \n macaddr -> a [ 3 ] = 0x12 ; \n macaddr -> a [ 4 ] = 0x34 ; \n macaddr -> a [ 5 ] = 0x56 + index ++ ; \n }", "idx": 16977}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void axidma_write ( void * opaque , hwaddr addr , \n uint64_t value , unsigned size ) \n { \n XilinxAXIDMA * d = opaque ; \n struct Stream * s ; \n int sid ; \n sid = streamid_from_addr ( addr ) ; \n s = & d -> streams [ sid ] ; \n addr = addr % 0x30 ; \n addr >>= 2 ; \n switch ( addr ) { \n case R_DMACR : \n value |= DMACR_TAILPTR_MODE ; \n value |= ( s -> regs [ addr ] & DMACR_RESET ) ; \n s -> regs [ addr ] = value ; \n if ( value & DMACR_RESET ) { \n stream_reset ( s ) ; \n } \n if ( ( value & 1 ) && ! stream_resetting ( s ) ) { \n s -> regs [ R_DMASR ] &= ~ ( DMASR_HALTED | DMASR_IDLE ) ; \n } \n stream_reload_complete_cnt ( s ) ; \n break ; \n case R_DMASR : \n value &= ~ ( value & DMASR_IRQ_MASK ) ; \n s -> regs [ addr ] = value ; \n break ; \n case R_TAILDESC : \n s -> regs [ addr ] = value ; \n s -> regs [ R_DMASR ] &= ~ DMASR_IDLE ; \n if ( ! sid ) { \n stream_process_mem2s ( s , d -> tx_dev ) ; \n } \n break ; \n default : \n D ( qemu_log ( \" \" TARGET_FMT_plx \" \\n \" , \n __func__ , sid , addr * 4 , ( unsigned ) value ) ) ; \n s -> regs [ addr ] = value ; \n break ; \n } \n if ( sid == 1 && d -> notify ) { \n d -> notify ( d -> notify_opaque ) ; \n d -> notify = NULL ; \n } \n stream_update_irq ( s ) ; \n }", "idx": 17024}
{"project": "qemu", "commit_id": "70ae65f5d91462e1905a53236179fde21cda3a2f", "target": 0, "func": "static uint32_t bmdma_readb ( void * opaque , uint32_t addr ) \n { \n BMDMAState * bm = opaque ; \n PCIIDEState * pci_dev = pci_from_bm ( bm ) ; \n uint32_t val ; \n switch ( addr & 3 ) { \n case 0 : \n val = bm -> cmd ; \n break ; \n case 1 : \n val = pci_dev -> dev . config [ MRDMODE ] ; \n break ; \n case 2 : \n val = bm -> status ; \n break ; \n case 3 : \n if ( bm -> unit == 0 ) { \n val = pci_dev -> dev . config [ UDIDETCR0 ] ; \n } else { \n val = pci_dev -> dev . config [ UDIDETCR1 ] ; \n } \n break ; \n default : \n val = 0xff ; \n break ; \n } \n #ifdef DEBUG_IDE \n printf ( \" \\n \" , addr , val ) ; \n #endif \n return val ; \n }", "idx": 17028}
{"project": "qemu", "commit_id": "7f303adc4f0aaa71b196d9f983150f3ec3367b46", "target": 0, "func": "query_params_append ( struct QueryParams *  ps , \n const  char * name , const  char * value ) \n { \n if ( ps -> n >= ps -> alloc ) { \n ps -> p = g_renew ( QueryParam , ps -> p , ps -> alloc * 2 ) ; \n ps -> alloc *= 2 ; \n } \n ps -> p [ ps -> n ] . name = g_strdup ( name ) ; \n ps -> p [ ps -> n ] . value = value ? g_strdup ( value ) : NULL ; \n ps -> p [ ps -> n ] . ignore = 0 ; \n ps -> n ++ ; \n return 0 ; \n }", "idx": 17033}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static TCGv new_tmp ( void ) \n { \n TCGv tmp ; \n if ( num_temps == MAX_TEMPS ) \n abort ( ) ; \n if ( GET_TCGV ( temps [ num_temps ] ) ) \n return temps [ num_temps ++ ] ; \n tmp = tcg_temp_new ( TCG_TYPE_I32 ) ; \n temps [ num_temps ++ ] = tmp ; \n return tmp ; \n }", "idx": 17088}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void cpu_mips_store_status ( CPUMIPSState * env , target_ulong val ) \n { \n uint32_t mask = env -> CP0_Status_rw_bitmask ; \n target_ulong old = env -> CP0_Status ; \n if ( env -> insn_flags & ISA_MIPS32R6 ) { \n bool has_supervisor = extract32 ( mask , CP0St_KSU , 2 ) == 0x3 ; \n #if defined ( TARGET_MIPS64 )  \n  \n  uint32_t ksux = ( 1 << CP0St_KX ) & val ; \n ksux |= ( ksux >> 1 ) & val ; \n ksux |= ( ksux >> 1 ) & val ; \n val = ( val & ~ ( 7 << CP0St_UX ) ) | ksux ; \n #endif \n if ( has_supervisor && extract32 ( val , CP0St_KSU , 2 ) == 0x3 ) { \n mask &= ~ ( 3 << CP0St_KSU ) ; \n } \n mask &= ~ ( ( ( 1 << CP0St_SR ) | ( 1 << CP0St_NMI ) ) & val ) ; \n } \n env -> CP0_Status = ( old & ~ mask ) | ( val & mask ) ; \n #if defined ( TARGET_MIPS64 )  \n  \n  if ( ( env -> CP0_Status ^ old ) & ( old & ( 7 << CP0St_UX ) ) ) { \n cpu_mips_tlb_flush ( env ) ; \n } \n #endif \n if ( env -> CP0_Config3 & ( 1 << CP0C3_MT ) ) { \n sync_c0_status ( env , env , env -> current_tc ) ; \n } else { \n compute_hflags ( env ) ; \n } \n }", "idx": 17091}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void add_pollfd ( AioHandler * node ) \n { \n if ( npfd == nalloc ) { \n if ( nalloc == 0 ) { \n pollfds_cleanup_notifier . notify = pollfds_cleanup ; \n qemu_thread_atexit_add ( & pollfds_cleanup_notifier ) ; \n nalloc = 8 ; \n } else { \n g_assert ( nalloc <= INT_MAX ) ; \n nalloc *= 2 ; \n } \n pollfds = g_renew ( GPollFD , pollfds , nalloc ) ; \n nodes = g_renew ( AioHandler * , nodes , nalloc ) ; \n } \n nodes [ npfd ] = node ; \n pollfds [ npfd ] = ( GPollFD ) { \n . fd = node -> pfd . fd , \n . events = node -> pfd . events , \n } ; \n npfd ++ ; \n }", "idx": 17157}
{"project": "qemu", "commit_id": "6e9ea0c0629fe25723494a19498bedf4b781cbfa", "target": 0, "func": "static void calculate_geometry ( int64_t total_sectors , uint16_t * cyls , \n uint8_t * heads , uint8_t * secs_per_cyl ) \n { \n uint32_t cyls_times_heads ; \n if ( total_sectors > 65535 * 16 * 255 ) \n total_sectors = 65535 * 16 * 255 ; \n if ( total_sectors > 65535 * 16 * 63 ) { \n * secs_per_cyl = 255 ; \n * heads = 16 ; \n cyls_times_heads = total_sectors / * secs_per_cyl ; \n } else { \n * secs_per_cyl = 17 ; \n cyls_times_heads = total_sectors / * secs_per_cyl ; \n * heads = ( cyls_times_heads + 1023 ) / 1024 ; \n if ( * heads < 4 ) \n * heads = 4 ; \n if ( cyls_times_heads >= ( * heads * 1024 ) || * heads > 16 ) { \n * secs_per_cyl = 31 ; \n * heads = 16 ; \n cyls_times_heads = total_sectors / * secs_per_cyl ; \n } \n if ( cyls_times_heads >= ( * heads * 1024 ) ) { \n * secs_per_cyl = 63 ; \n * heads = 16 ; \n cyls_times_heads = total_sectors / * secs_per_cyl ; \n } \n } \n * cyls = ( cyls_times_heads + * heads - 1 ) / * heads ; \n }", "idx": 17245}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static int within_hwc_y_range ( SM501State * state , int y , int crt ) \n { \n int hwc_y = get_hwc_y ( state , crt ) ; \n return ( hwc_y <= y && y < hwc_y + SM501_HWC_HEIGHT ) ; \n }", "idx": 17249}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evmwumi ( DisasContext * ctx ) \n { \n TCGv_i64 t0 , t1 ; \n if ( unlikely ( ! ctx -> spe_enabled ) ) { \n gen_exception ( ctx , POWERPC_EXCP_APU ) ; \n return ; \n } \n t0 = tcg_temp_new_i64 ( ) ; \n t1 = tcg_temp_new_i64 ( ) ; \n #if defined ( TARGET_PPC64 )  \n  \n  tcg_gen_ext32u_tl ( t0 , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n tcg_gen_ext32u_tl ( t1 , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n #else \n tcg_gen_extu_tl_i64 ( t0 , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n tcg_gen_extu_tl_i64 ( t1 , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n #endif \n tcg_gen_mul_i64 ( t0 , t0 , t1 ) ; \n gen_store_gpr64 ( rD ( ctx -> opcode ) , t0 ) ; \n tcg_temp_free_i64 ( t0 ) ; \n tcg_temp_free_i64 ( t1 ) ; \n }", "idx": 17251}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static int v9fs_xattr_read ( V9fsState * s , V9fsPDU * pdu , V9fsFidState * fidp , \n uint64_t off , uint32_t max_count ) \n { \n ssize_t err ; \n size_t offset = 7 ; \n int read_count ; \n int64_t xattr_len ; \n V9fsVirtioState * v = container_of ( s , V9fsVirtioState , state ) ; \n VirtQueueElement * elem = & v -> elems [ pdu -> idx ] ; \n xattr_len = fidp -> fs . xattr . len ; \n read_count = xattr_len - off ; \n if ( read_count > max_count ) { \n read_count = max_count ; \n } else if ( read_count < 0 ) { \n read_count = 0 ; \n } \n err = pdu_marshal ( pdu , offset , \" \" , read_count ) ; \n if ( err < 0 ) { \n return err ; \n } \n offset += err ; \n err = v9fs_pack ( elem -> in_sg , elem -> in_num , offset , \n ( ( char * ) fidp -> fs . xattr . value ) + off , \n read_count ) ; \n if ( err < 0 ) { \n return err ; \n } \n offset += err ; \n return offset ; \n }", "idx": 17299}
{"project": "qemu", "commit_id": "213189ab65d83ecd9072f27c80a15dcb91b6bdbf", "target": 0, "func": "static void virtio_blk_dma_restart_cb ( void * opaque , int running , int reason ) \n { \n VirtIOBlock * s = opaque ; \n VirtIOBlockReq * req = s -> rq ; \n if ( ! running ) \n return ; \n s -> rq = NULL ; \n while ( req ) { \n virtio_blk_handle_write ( req ) ; \n req = req -> next ; \n } \n }", "idx": 17305}
{"project": "qemu", "commit_id": "c99a55d38dd5b5131f3fcbbaf41828a09ee62544", "target": 1, "func": "static void arm1026_initfn ( Object * obj ) \n { \n ARMCPU * cpu = ARM_CPU ( obj ) ; \n cpu -> dtb_compatible = \" \" ; \n set_feature ( & cpu -> env , ARM_FEATURE_V5 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_VFP ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_AUXCR ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_DUMMY_C15_REGS ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_CACHE_TEST_CLEAN ) ; \n cpu -> midr = 0x4106a262 ; \n cpu -> reset_fpsid = 0x410110a0 ; \n cpu -> ctr = 0x1dd20d2 ; \n cpu -> reset_sctlr = 0x00090078 ; \n cpu -> reset_auxcr = 1 ; \n { \n ARMCPRegInfo ifar = { \n . name = \" \" , . cp = 15 , . crn = 6 , . crm = 0 , . opc1 = 0 , . opc2 = 1 , \n . access = PL1_RW , \n . fieldoffset = offsetof ( CPUARMState , cp15 . ifar_ns ) , \n . resetvalue = 0 \n } ; \n define_one_arm_cp_reg ( cpu , & ifar ) ; \n } \n }", "idx": 17355}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "long do_rt_sigreturn ( CPUState * env ) \n { \n fprintf ( stderr , \" \\n \" ) ; \n return - TARGET_ENOSYS ; \n }", "idx": 17375}
{"project": "qemu", "commit_id": "f81bdefb63243e82d16ce49332f7cf74d10b8f27", "target": 1, "func": "void vga_hw_screen_dump ( const char * filename ) \n { \n TextConsole * previous_active_console ; \n previous_active_console = active_console ; \n active_console = consoles [ 0 ] ; \n if ( consoles [ 0 ] && consoles [ 0 ] -> hw_screen_dump ) \n consoles [ 0 ] -> hw_screen_dump ( consoles [ 0 ] -> hw , filename ) ; \n active_console = previous_active_console ; \n }", "idx": 17376}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_udp_init ( NetClientState * peer , \n const char * model , \n const char * name , \n const char * rhost , \n const char * lhost ) \n { \n NetSocketState * s ; \n int fd , ret ; \n struct sockaddr_in laddr , raddr ; \n if ( parse_host_port ( & laddr , lhost ) < 0 ) { \n return -1 ; \n } \n if ( parse_host_port ( & raddr , rhost ) < 0 ) { \n return -1 ; \n } \n fd = qemu_socket ( PF_INET , SOCK_DGRAM , 0 ) ; \n if ( fd < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n ret = socket_set_fast_reuse ( fd ) ; \n if ( ret < 0 ) { \n closesocket ( fd ) ; \n return -1 ; \n } \n ret = bind ( fd , ( struct sockaddr * ) & laddr , sizeof ( laddr ) ) ; \n if ( ret < 0 ) { \n perror ( \" \" ) ; \n closesocket ( fd ) ; \n return -1 ; \n } \n qemu_set_nonblock ( fd ) ; \n s = net_socket_fd_init ( peer , model , name , fd , 0 ) ; \n if ( ! s ) { \n return -1 ; \n } \n s -> dgram_dst = raddr ; \n snprintf ( s -> nc . info_str , sizeof ( s -> nc . info_str ) , \n \" \" , \n inet_ntoa ( raddr . sin_addr ) , ntohs ( raddr . sin_port ) ) ; \n return 0 ; \n }", "idx": 17378}
{"project": "qemu", "commit_id": "0d9acba8fddbf970c7353083e6a60b47017ce3e4", "target": 1, "func": "static void audio_init ( PCIBus * pci_bus ) \n { \n struct soundhw * c ; \n int audio_enabled = 0 ; \n for ( c = soundhw ; ! audio_enabled && c -> name ; ++ c ) { \n audio_enabled = c -> enabled ; \n } \n if ( audio_enabled ) { \n AudioState * s ; \n s = AUD_init ( ) ; \n if ( s ) { \n for ( c = soundhw ; c -> name ; ++ c ) { \n if ( c -> enabled ) \n c -> init . init_pci ( pci_bus , s ) ; \n } \n } \n } \n }", "idx": 17386}
{"project": "qemu", "commit_id": "9c554c1c0b01642c39232489cef8301a7858824d", "target": 1, "func": "void cuda_init ( int * cuda_mem_index , qemu_irq irq ) \n { \n struct tm tm ; \n CUDAState * s = & cuda_state ; \n s -> irq = irq ; \n s -> timers [ 0 ] . index = 0 ; \n s -> timers [ 0 ] . timer = qemu_new_timer ( vm_clock , cuda_timer1 , s ) ; \n s -> timers [ 1 ] . index = 1 ; \n qemu_get_timedate ( & tm , RTC_OFFSET ) ; \n s -> tick_offset = mktimegm ( & tm ) ; \n s -> adb_poll_timer = qemu_new_timer ( vm_clock , cuda_adb_poll , s ) ; \n * cuda_mem_index = cpu_register_io_memory ( 0 , cuda_read , cuda_write , s ) ; \n register_savevm ( \" \" , -1 , 1 , cuda_save , cuda_load , s ) ; \n qemu_register_reset ( cuda_reset , s ) ; \n cuda_reset ( s ) ; \n }", "idx": 17407}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_pcihost_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n set_bit ( DEVICE_CATEGORY_BRIDGE , dc -> categories ) ; \n dc -> realize = raven_pcihost_realizefn ; \n dc -> fw_name = \" \" ; \n dc -> no_user = 1 ; \n }", "idx": 17463}
{"project": "qemu", "commit_id": "760794f784f66e262a9ca32821ba202cdf3a3e4b", "target": 1, "func": "static int chr_can_read ( void * opaque ) \n { \n int can_read ; \n SCLPConsole * scon = opaque ; \n can_read = SIZE_BUFFER_VT220 - scon -> iov_data_len ; \n return can_read ; \n }", "idx": 17478}
{"project": "qemu", "commit_id": "6273d1136af913aaf4badc4545ccf942557c747b", "target": 1, "func": "static void qdict_do_flatten ( QDict * qdict , QDict * target , const char * prefix ) \n { \n QObject * value ; \n const QDictEntry * entry , * next ; \n const char * new_key ; \n bool delete ; \n entry = qdict_first ( qdict ) ; \n while ( entry != NULL ) { \n next = qdict_next ( qdict , entry ) ; \n value = qdict_entry_value ( entry ) ; \n new_key = NULL ; \n delete = false ; \n if ( prefix ) { \n qobject_incref ( value ) ; \n new_key = g_strdup_printf ( \" \" , prefix , entry -> key ) ; \n qdict_put_obj ( target , new_key , value ) ; \n delete = true ; \n } \n if ( qobject_type ( value ) == QTYPE_QDICT ) { \n qdict_do_flatten ( qobject_to_qdict ( value ) , target , \n new_key ? new_key : entry -> key ) ; \n delete = true ; \n } \n if ( delete ) { \n qdict_del ( qdict , entry -> key ) ; \n entry = qdict_first ( qdict ) ; \n continue ; \n } \n entry = next ; \n } \n }", "idx": 17558}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER ( ucf64_divd ) ( float64 a , float64 b , CPUUniCore32State * env ) \n { \n return float64_div ( a , b , & env -> ucf64 . fp_status ) ; \n }", "idx": 17571}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbuge ( TCGv dst , TCGv src , \n unsigned int fcc_offset ) \n { \n gen_mov_reg_FCC0 ( dst , src , fcc_offset ) ; \n gen_mov_reg_FCC1 ( cpu_tmp0 , src , fcc_offset ) ; \n tcg_gen_xori_tl ( cpu_tmp0 , cpu_tmp0 , 0x1 ) ; \n tcg_gen_and_tl ( dst , dst , cpu_tmp0 ) ; \n tcg_gen_xori_tl ( dst , dst , 0x1 ) ; \n }", "idx": 17588}
{"project": "qemu", "commit_id": "dbecebddfa4932d1c83915bcb9b5ba5984eb91be", "target": 0, "func": "int bdrv_open_backing_file ( BlockDriverState * bs , QDict * options , Error * * errp ) \n { \n char backing_filename [ PATH_MAX ] ; \n int back_flags , ret ; \n BlockDriver * back_drv = NULL ; \n Error * local_err = NULL ; \n if ( bs -> backing_hd != NULL ) { \n QDECREF ( options ) ; \n return 0 ; \n } \n if ( options == NULL ) { \n options = qdict_new ( ) ; \n } \n bs -> open_flags &= ~ BDRV_O_NO_BACKING ; \n if ( qdict_haskey ( options , \" \" ) ) { \n backing_filename [ 0 ] = ' \\0 ' ; \n } else if ( bs -> backing_file [ 0 ] == ' \\0 ' && qdict_size ( options ) == 0 ) { \n QDECREF ( options ) ; \n return 0 ; \n } \n bs -> backing_hd = bdrv_new ( \" \" ) ; \n bdrv_get_full_backing_filename ( bs , backing_filename , \n sizeof ( backing_filename ) ) ; \n if ( bs -> backing_format [ 0 ] != ' \\0 ' ) { \n back_drv = bdrv_find_format ( bs -> backing_format ) ; \n } \n back_flags = bs -> open_flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT ) ; \n ret = bdrv_open ( bs -> backing_hd , \n * backing_filename ? backing_filename : NULL , options , \n back_flags , back_drv , & local_err ) ; \n if ( ret < 0 ) { \n bdrv_unref ( bs -> backing_hd ) ; \n bs -> backing_hd = NULL ; \n bs -> open_flags |= BDRV_O_NO_BACKING ; \n error_propagate ( errp , local_err ) ; \n return ret ; \n } \n return 0 ; \n }", "idx": 17594}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void m68k_cpu_initfn ( Object * obj ) \n { \n CPUState * cs = CPU ( obj ) ; \n M68kCPU * cpu = M68K_CPU ( obj ) ; \n CPUM68KState * env = & cpu -> env ; \n static bool inited ; \n cs -> env_ptr = env ; \n cpu_exec_init ( cs , & error_abort ) ; \n if ( tcg_enabled ( ) && ! inited ) { \n inited = true ; \n m68k_tcg_init ( ) ; \n } \n }", "idx": 17604}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_drain_one ( BlockDriverState * bs ) \n { \n bool bs_busy ; \n bdrv_flush_io_queue ( bs ) ; \n bdrv_start_throttled_reqs ( bs ) ; \n bs_busy = bdrv_requests_pending ( bs ) ; \n bs_busy |= aio_poll ( bdrv_get_aio_context ( bs ) , bs_busy ) ; \n return bs_busy ; \n }", "idx": 17623}
{"project": "qemu", "commit_id": "2174f12bdeb3974141784e14bbb7ad8c53178cd9", "target": 0, "func": "static BlockAIOCB * raw_aio_readv ( BlockDriverState * bs , \n int64_t sector_num , QEMUIOVector * qiov , int nb_sectors , \n BlockCompletionFunc * cb , void * opaque ) \n { \n return raw_aio_submit ( bs , sector_num , qiov , nb_sectors , \n cb , opaque , QEMU_AIO_READ ) ; \n }", "idx": 17636}
{"project": "qemu", "commit_id": "f5bebbbb28dc7a149a891f0f1e112fb50bb72664", "target": 0, "func": "static bool bdrv_is_valid_name ( const char * name ) \n { \n return qemu_opts_id_wellformed ( name ) ; \n }", "idx": 17639}
{"project": "qemu", "commit_id": "494cb81741f867319f11ecfa0949168baf9f01d7", "target": 0, "func": "static void vnc_tls_handshake_io ( void * opaque ) { \n struct VncState * vs = ( struct VncState * ) opaque ; \n VNC_DEBUG ( \" \\n \" ) ; \n vnc_start_vencrypt_handshake ( vs ) ; \n }", "idx": 17647}
{"project": "qemu", "commit_id": "a0fa2cb8ccf0b73cfd3ac01d557401a2303c0de4", "target": 0, "func": "int sclp_service_call ( uint32_t sccb , uint64_t code ) \n { \n int r = 0 ; \n SCCB work_sccb ; \n hwaddr sccb_len = sizeof ( SCCB ) ; \n if ( cpu_physical_memory_is_io ( sccb ) ) { \n r = - PGM_ADDRESSING ; \n goto out ; \n } \n if ( sccb & ~ 0x7ffffff8ul ) { \n r = - PGM_SPECIFICATION ; \n goto out ; \n } \n cpu_physical_memory_read ( sccb , & work_sccb , sccb_len ) ; \n if ( be16_to_cpu ( work_sccb . h . length ) < sizeof ( SCCBHeader ) || \n be16_to_cpu ( work_sccb . h . length ) > SCCB_SIZE ) { \n r = - PGM_SPECIFICATION ; \n goto out ; \n } \n sclp_execute ( ( SCCB * ) & work_sccb , code ) ; \n cpu_physical_memory_write ( sccb , & work_sccb , \n be16_to_cpu ( work_sccb . h . length ) ) ; \n sclp_service_interrupt ( sccb ) ; \n out : \n return r ; \n }", "idx": 17654}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static void taihu_cpld_writeb ( void * opaque , \n hwaddr addr , uint32_t value ) \n { \n taihu_cpld_t * cpld ; \n cpld = opaque ; \n switch ( addr ) { \n case 0x0 : \n break ; \n case 0x1 : \n cpld -> reg1 = value ; \n break ; \n default : \n break ; \n } \n }", "idx": 17663}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void dp8393x_writeb ( void * opaque , target_phys_addr_t addr , uint32_t val ) \n { \n uint16_t old_val = dp8393x_readw ( opaque , addr & ~ 0x1 ) ; \n switch ( addr & 3 ) { \n case 0 : \n val = val | ( old_val & 0xff00 ) ; \n break ; \n case 1 : \n val = ( val << 8 ) | ( old_val & 0x00ff ) ; \n break ; \n } \n dp8393x_writew ( opaque , addr & ~ 0x1 , val ) ; \n }", "idx": 17688}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void eepro100_write ( void * opaque , target_phys_addr_t addr , \n uint64_t data , unsigned size ) \n { \n EEPRO100State * s = opaque ; \n switch ( size ) { \n case 1 : \n eepro100_write1 ( s , addr , data ) ; \n break ; \n case 2 : \n eepro100_write2 ( s , addr , data ) ; \n break ; \n case 4 : \n eepro100_write4 ( s , addr , data ) ; \n break ; \n default : \n abort ( ) ; \n } \n }", "idx": 17698}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv gen_ld8s ( TCGv addr , int index ) \n { \n TCGv tmp = new_tmp ( ) ; \n tcg_gen_qemu_ld8s ( tmp , addr , index ) ; \n return tmp ; \n }", "idx": 17739}
{"project": "qemu", "commit_id": "b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3", "target": 1, "func": "static void usbredir_handle_bulk_data ( USBRedirDevice * dev , USBPacket * p , \n uint8_t ep ) \n { \n struct usb_redir_bulk_packet_header bulk_packet ; \n size_t size = ( p -> combined ) ? p -> combined -> iov . size : p -> iov . size ; \n DPRINTF ( \" \" PRIu64 \" \\n \" , ep , size , p -> id ) ; \n if ( usbredir_already_in_flight ( dev , p -> id ) ) { \n p -> status = USB_RET_ASYNC ; \n return ; \n } \n bulk_packet . endpoint = ep ; \n bulk_packet . length = size ; \n bulk_packet . stream_id = 0 ; \n bulk_packet . length_high = size >> 16 ; \n assert ( bulk_packet . length_high == 0 || \n usbredirparser_peer_has_cap ( dev -> parser , \n usb_redir_cap_32bits_bulk_length ) ) ; \n if ( ep & USB_DIR_IN ) { \n usbredirparser_send_bulk_packet ( dev -> parser , p -> id , \n & bulk_packet , NULL , 0 ) ; \n } else { \n uint8_t buf [ size ] ; \n if ( p -> combined ) { \n iov_to_buf ( p -> combined -> iov . iov , p -> combined -> iov . niov , \n 0 , buf , size ) ; \n } else { \n usb_packet_copy ( p , buf , size ) ; \n } \n usbredir_log_data ( dev , \" \" , buf , size ) ; \n usbredirparser_send_bulk_packet ( dev -> parser , p -> id , \n & bulk_packet , buf , size ) ; \n } \n usbredirparser_do_write ( dev -> parser ) ; \n p -> status = USB_RET_ASYNC ; \n }", "idx": 17751}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dedd ( DisasContext * ctx , uint32_t insn , \n const DisasInsn * di ) \n { \n unsigned rt = extract32 ( insn , 0 , 5 ) ; \n unsigned rb = extract32 ( insn , 16 , 5 ) ; \n unsigned ra = extract32 ( insn , 21 , 5 ) ; \n return do_fop_dedd ( ctx , rt , ra , rb , di -> f_dedd ) ; \n }", "idx": 17767}
{"project": "qemu", "commit_id": "ad718d01ba0af531d10b0a8685cf5047edfd1891", "target": 1, "func": "int qemu_opt_set_bool ( QemuOpts * opts , const char * name , bool val ) \n { \n QemuOpt * opt ; \n const QemuOptDesc * desc = opts -> list -> desc ; \n int i ; \n for ( i = 0 ; desc [ i ] . name != NULL ; i ++ ) { \n if ( strcmp ( desc [ i ] . name , name ) == 0 ) { \n break ; \n } \n } \n if ( desc [ i ] . name == NULL ) { \n if ( i == 0 ) { \n ; \n } else { \n qerror_report ( QERR_INVALID_PARAMETER , name ) ; \n return -1 ; \n } \n } \n opt = g_malloc0 ( sizeof ( * opt ) ) ; \n opt -> name = g_strdup ( name ) ; \n opt -> opts = opts ; \n QTAILQ_INSERT_TAIL ( & opts -> head , opt , next ) ; \n if ( desc [ i ] . name != NULL ) { \n opt -> desc = desc + i ; \n } \n opt -> value . boolean = ! ! val ; \n return 0 ; \n }", "idx": 17783}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState * qemu_chr_open_pp_fd ( int fd ) \n { \n CharDriverState * chr ; \n ParallelCharDriver * drv ; \n if ( ioctl ( fd , PPCLAIM ) < 0 ) { \n close ( fd ) ; \n return NULL ; \n } \n drv = g_malloc0 ( sizeof ( ParallelCharDriver ) ) ; \n drv -> fd = fd ; \n drv -> mode = IEEE1284_MODE_COMPAT ; \n chr = qemu_chr_alloc ( ) ; \n chr -> chr_write = null_chr_write ; \n chr -> chr_ioctl = pp_ioctl ; \n chr -> chr_close = pp_close ; \n chr -> opaque = drv ; \n return chr ; \n }", "idx": 17818}
{"project": "qemu", "commit_id": "5eb6a3c50185e101f87382f41fb66eed5784e7ac", "target": 1, "func": "void qdev_prop_set_globals ( DeviceState * dev ) \n { \n ObjectClass * class = object_get_class ( OBJECT ( dev ) ) ; \n do { \n qdev_prop_set_globals_for_type ( dev , object_class_get_name ( class ) ) ; \n class = object_class_get_parent ( class ) ; \n } while ( class ) ; \n }", "idx": 17842}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "BlockDriverState * bdrv_new ( const char * device_name , Error * * errp ) \n { \n BlockDriverState * bs ; \n int i ; \n if ( bdrv_find ( device_name ) ) { \n error_setg ( errp , \" \" , \n device_name ) ; \n return NULL ; \n } \n if ( bdrv_find_node ( device_name ) ) { \n error_setg ( errp , \" \" , \n device_name ) ; \n return NULL ; \n } \n bs = g_malloc0 ( sizeof ( BlockDriverState ) ) ; \n QLIST_INIT ( & bs -> dirty_bitmaps ) ; \n pstrcpy ( bs -> device_name , sizeof ( bs -> device_name ) , device_name ) ; \n if ( device_name [ 0 ] != ' \\0 ' ) { \n QTAILQ_INSERT_TAIL ( & bdrv_states , bs , device_list ) ; \n } \n for ( i = 0 ; i < BLOCK_OP_TYPE_MAX ; i ++ ) { \n QLIST_INIT ( & bs -> op_blockers [ i ] ) ; \n } \n bdrv_iostatus_disable ( bs ) ; \n notifier_list_init ( & bs -> close_notifiers ) ; \n notifier_with_return_list_init ( & bs -> before_write_notifiers ) ; \n qemu_co_queue_init ( & bs -> throttled_reqs [ 0 ] ) ; \n qemu_co_queue_init ( & bs -> throttled_reqs [ 1 ] ) ; \n bs -> refcnt = 1 ; \n bs -> aio_context = qemu_get_aio_context ( ) ; \n return bs ; \n }", "idx": 17858}
{"project": "qemu", "commit_id": "651eb0f41b793021f7de672de78892def5819fb9", "target": 1, "func": "static int kvm_set_user_memory_region ( KVMState * s , KVMSlot * slot ) \n { \n struct kvm_userspace_memory_region mem ; \n mem . slot = slot -> slot ; \n mem . guest_phys_addr = slot -> start_addr ; \n mem . userspace_addr = ( unsigned long ) slot -> ram ; \n mem . flags = slot -> flags ; \n if ( s -> migration_log ) { \n mem . flags |= KVM_MEM_LOG_DIRTY_PAGES ; \n } \n if ( mem . flags & KVM_MEM_READONLY ) { \n mem . memory_size = 0 ; \n kvm_vm_ioctl ( s , KVM_SET_USER_MEMORY_REGION , & mem ) ; \n } \n mem . memory_size = slot -> memory_size ; \n return kvm_vm_ioctl ( s , KVM_SET_USER_MEMORY_REGION , & mem ) ; \n }", "idx": 17871}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "void cpu_exec_init ( CPUState * cpu , Error * * errp ) \n { \n CPUClass * cc ATTRIBUTE_UNUSED = CPU_GET_CLASS ( cpu ) ; \n cpu_list_add ( cpu ) ; \n #ifndef CONFIG_USER_ONLY \n if ( qdev_get_vmsd ( DEVICE ( cpu ) ) == NULL ) { \n vmstate_register ( NULL , cpu -> cpu_index , & vmstate_cpu_common , cpu ) ; \n } \n if ( cc -> vmsd != NULL ) { \n vmstate_register ( NULL , cpu -> cpu_index , cc -> vmsd , cpu ) ; \n } \n #endif \n }", "idx": 17889}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "static bool aio_dispatch ( AioContext * ctx ) \n { \n AioHandler * node ; \n bool progress = false ; \n node = QLIST_FIRST ( & ctx -> aio_handlers ) ; \n while ( node ) { \n AioHandler * tmp ; \n int revents ; \n ctx -> walking_handlers ++ ; \n revents = node -> pfd . revents & node -> pfd . events ; \n node -> pfd . revents = 0 ; \n if ( ! node -> deleted && \n ( revents & ( G_IO_IN | G_IO_HUP | G_IO_ERR ) ) && \n node -> io_read ) { \n node -> io_read ( node -> opaque ) ; \n progress = true ; \n } \n if ( ! node -> deleted && \n ( revents & ( G_IO_OUT | G_IO_ERR ) ) && \n node -> io_write ) { \n node -> io_write ( node -> opaque ) ; \n progress = true ; \n } \n tmp = node ; \n node = QLIST_NEXT ( node , node ) ; \n ctx -> walking_handlers -- ; \n if ( ! ctx -> walking_handlers && tmp -> deleted ) { \n QLIST_REMOVE ( tmp , node ) ; \n g_free ( tmp ) ; \n } \n } \n return progress ; \n }", "idx": 17933}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix4_ide_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ; \n k -> no_hotplug = 1 ; \n k -> init = pci_piix_ide_initfn ; \n k -> exit = pci_piix_ide_exitfn ; \n k -> vendor_id = PCI_VENDOR_ID_INTEL ; \n k -> device_id = PCI_DEVICE_ID_INTEL_82371AB ; \n k -> class_id = PCI_CLASS_STORAGE_IDE ; \n set_bit ( DEVICE_CATEGORY_STORAGE , dc -> categories ) ; \n dc -> no_user = 1 ; \n }", "idx": 17938}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qdict_add_key ( const char * key , QObject * obj , void * opaque ) \n { \n GHashTable * h = opaque ; \n g_hash_table_insert ( h , ( gpointer ) key , NULL ) ; \n }", "idx": 17958}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "static void eject_device ( BlockDriverState * bs , int force , Error * * errp ) \n { \n if ( bdrv_in_use ( bs ) ) { \n error_set ( errp , QERR_DEVICE_IN_USE , bdrv_get_device_name ( bs ) ) ; \n return ; \n } \n if ( ! bdrv_dev_has_removable_media ( bs ) ) { \n error_setg ( errp , \" \" , \n bdrv_get_device_name ( bs ) ) ; \n return ; \n } \n if ( bdrv_dev_is_medium_locked ( bs ) && ! bdrv_dev_is_tray_open ( bs ) ) { \n bdrv_dev_eject_request ( bs , force ) ; \n if ( ! force ) { \n error_setg ( errp , \" \" , \n bdrv_get_device_name ( bs ) ) ; \n return ; \n } \n } \n bdrv_close ( bs ) ; \n }", "idx": 17964}
{"project": "qemu", "commit_id": "b53ccc30c40df52d192e469a86c188a8649c6df3", "target": 1, "func": "void qmp_dump_guest_memory ( bool paging , const char * file , bool has_begin , \n int64_t begin , bool has_length , int64_t length , \n Error * * errp ) \n { \n const char * p ; \n int fd = -1 ; \n DumpState * s ; \n int ret ; \n if ( has_begin && ! has_length ) { \n error_set ( errp , QERR_MISSING_PARAMETER , \" \" ) ; \n return ; \n } \n if ( ! has_begin && has_length ) { \n error_set ( errp , QERR_MISSING_PARAMETER , \" \" ) ; \n return ; \n } \n #if ! defined ( WIN32 )  \n  \n  if ( strstart ( file , \" \" , & p ) ) { \n fd = monitor_get_fd ( cur_mon , p , errp ) ; \n if ( fd == -1 ) { \n return ; \n } \n } \n #endif \n if ( strstart ( file , \" \" , & p ) ) { \n fd = qemu_open ( p , O_WRONLY | O_CREAT | O_TRUNC | O_BINARY , S_IRUSR ) ; \n if ( fd < 0 ) { \n error_setg_file_open ( errp , errno , p ) ; \n return ; \n } \n } \n if ( fd == -1 ) { \n error_set ( errp , QERR_INVALID_PARAMETER , \" \" ) ; \n return ; \n } \n s = g_malloc0 ( sizeof ( DumpState ) ) ; \n ret = dump_init ( s , fd , paging , has_begin , begin , length , errp ) ; \n if ( ret < 0 ) { \n g_free ( s ) ; \n return ; \n } \n if ( create_vmcore ( s ) < 0 && ! error_is_set ( s -> errp ) ) { \n error_set ( errp , QERR_IO_ERROR ) ; \n } \n g_free ( s ) ; \n }", "idx": 17986}
{"project": "qemu", "commit_id": "10f12e6450407b18b4d5a6b50d3852dcfd7fff75", "target": 1, "func": "static bool spapr_drc_needed ( void * opaque ) \n { \n sPAPRDRConnector * drc = ( sPAPRDRConnector * ) opaque ; \n sPAPRDRConnectorClass * drck = SPAPR_DR_CONNECTOR_GET_CLASS ( drc ) ; \n if ( ! drc -> dev ) { \n return false ; \n } \n return ( drc -> state != drck -> ready_state ) ; \n }", "idx": 17989}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_mm_init ( MemoryRegion * sysmem , \n target_phys_addr_t base , \n qemu_irq irq , \n CharDriverState * chr ) \n { \n mcf_uart_state * s ; \n s = mcf_uart_init ( irq , chr ) ; \n memory_region_init_io ( & s -> iomem , & mcf_uart_ops , s , \" \" , 0x40 ) ; \n memory_region_add_subregion ( sysmem , base , & s -> iomem ) ; \n }", "idx": 18003}
{"project": "qemu", "commit_id": "277acfe8b38de35be8cb6e274678b5a7919c2d44", "target": 0, "func": "static void expr_error ( Monitor * mon , const char * msg ) \n { \n monitor_printf ( mon , \" \\n \" , msg ) ; \n siglongjmp ( expr_env , 1 ) ; \n }", "idx": 18005}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usb_msd_send_status ( MSDState * s , USBPacket * p ) \n { \n struct usb_msd_csw csw ; \n int len ; \n csw . sig = cpu_to_le32 ( 0x53425355 ) ; \n csw . tag = cpu_to_le32 ( s -> tag ) ; \n csw . residue = s -> residue ; \n csw . status = s -> result ; \n len = MIN ( sizeof ( csw ) , p -> len ) ; \n memcpy ( p -> data , & csw , len ) ; \n }", "idx": 18028}
{"project": "qemu", "commit_id": "acedcfbf7a9a29c772f613bafac9f3430faa6347", "target": 0, "func": "static NetSocketState * net_socket_fd_init ( VLANState * vlan , \n const char * model , const char * name , \n int fd , int is_connected ) \n { \n int so_type = -1 , optlen = sizeof ( so_type ) ; \n if ( getsockopt ( fd , SOL_SOCKET , SO_TYPE , ( char * ) & so_type , \n ( socklen_t * ) & optlen ) < 0 ) { \n fprintf ( stderr , \" \\n \" , fd ) ; \n return NULL ; \n } \n switch ( so_type ) { \n case SOCK_DGRAM : \n return net_socket_fd_init_dgram ( vlan , model , name , fd , is_connected ) ; \n case SOCK_STREAM : \n return net_socket_fd_init_stream ( vlan , model , name , fd , is_connected ) ; \n default : \n fprintf ( stderr , \" \\n \" , so_type , fd ) ; \n return net_socket_fd_init_stream ( vlan , model , name , fd , is_connected ) ; \n } \n return NULL ; \n }", "idx": 18045}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void ich_ahci_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ; \n k -> init = pci_ich9_ahci_init ; \n k -> exit = pci_ich9_uninit ; \n k -> config_write = pci_ich9_write_config ; \n k -> vendor_id = PCI_VENDOR_ID_INTEL ; \n k -> device_id = PCI_DEVICE_ID_INTEL_82801IR ; \n k -> revision = 0x02 ; \n k -> class_id = PCI_CLASS_STORAGE_SATA ; \n dc -> alias = \" \" ; \n dc -> vmsd = & vmstate_ahci ; \n }", "idx": 18061}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_psr ( const struct MonitorDef * md , int val ) \n { \n CPUState * env = mon_get_cpu ( ) ; \n if ( ! env ) \n return 0 ; \n return GET_PSR ( env ) ; \n }", "idx": 18078}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "opts_start_list ( Visitor * v , const char * name , Error * * errp )  \n { \n OptsVisitor * ov = to_ov ( v ) ; \n assert ( ov -> list_mode == LM_NONE ) ; \n ov -> repeated_opts = lookup_distinct ( ov , name , errp ) ; \n if ( ov -> repeated_opts != NULL ) { \n ov -> list_mode = LM_STARTED ; \n } \n }", "idx": 18102}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "static bool bdrv_drain_recurse ( BlockDriverState * bs ) \n { \n BdrvChild * child ; \n bool waited ; \n waited = bdrv_drain_poll ( bs ) ; \n if ( bs -> drv && bs -> drv -> bdrv_drain ) { \n bs -> drv -> bdrv_drain ( bs ) ; \n } \n QLIST_FOREACH ( child , & bs -> children , next )  { \n waited |= bdrv_drain_recurse ( child -> bs ) ; \n } \n return waited ; \n }", "idx": 18114}
{"project": "qemu", "commit_id": "9e41bade85ef338afd983c109368d1bbbe931f80", "target": 0, "func": "static void pxa2xx_i2c_slave_class_init ( ObjectClass * klass , void * data ) \n { \n I2CSlaveClass * k = I2C_SLAVE_CLASS ( klass ) ; \n k -> init = pxa2xx_i2c_slave_init ; \n k -> event = pxa2xx_i2c_event ; \n k -> recv = pxa2xx_i2c_rx ; \n k -> send = pxa2xx_i2c_tx ; \n }", "idx": 18127}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "static inline int32_t efsctsi ( uint32_t val ) \n { \n CPU_FloatU u ; \n u . l = val ; \n if ( unlikely ( float32_is_nan ( u . f ) ) ) \n return 0 ; \n return float32_to_int32 ( u . f , & env -> vec_status ) ; \n }", "idx": 18129}
{"project": "qemu", "commit_id": "03d843ddf271e96b6f8b2cd8a58f7a2004fcfaf9", "target": 0, "func": "static inline int handle_cpu_signal ( unsigned long pc , \n unsigned long address , \n int is_write , \n sigset_t * old_set ) \n { \n #if defined ( DEBUG_SIGNAL )  \n  \n  printf ( \" \\n \" , \n pc , address , is_write , * ( unsigned long * ) old_set ) ; \n #endif \n if ( is_write && page_unprotect ( address ) ) { \n sigprocmask ( SIG_SETMASK , old_set , NULL ) ; \n return 1 ; \n } \n if ( pc >= ( unsigned long ) code_gen_buffer && \n pc < ( unsigned long ) code_gen_buffer + CODE_GEN_BUFFER_SIZE ) { \n sigprocmask ( SIG_SETMASK , old_set , NULL ) ; \n env -> cr2 = address ; \n raise_exception_err ( EXCP0E_PAGE , 4 | ( is_write << 1 ) ) ; \n return 1 ; \n } else { \n return 0 ; \n } \n }", "idx": 18130}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void DBDMA_schedule ( void ) \n { \n CPUState * env = cpu_single_env ; \n if ( env ) \n cpu_interrupt ( env , CPU_INTERRUPT_EXIT ) ; \n }", "idx": 18133}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fdmulq ( CPUSPARCState * env , float64 src1 , float64 src2 ) \n { \n clear_float_exceptions ( env ) ; \n QT0 = float128_mul ( float64_to_float128 ( src1 , & env -> fp_status ) , \n float64_to_float128 ( src2 , & env -> fp_status ) , \n & env -> fp_status ) ; \n check_ieee_exceptions ( env ) ; \n }", "idx": 18146}
{"project": "qemu", "commit_id": "3b22c4707decb706b10ce023534f8b79413ff9fe", "target": 0, "func": "void helper_iret_real ( int shift ) \n { \n uint32_t sp , new_cs , new_eip , new_eflags , new_esp ; \n uint8_t * ssp ; \n int eflags_mask ; \n sp = env -> regs [ R_ESP ] & 0xffff ; \n ssp = env -> segs [ R_SS ] . base + sp ; \n if ( shift == 1 ) { \n new_eflags = ldl ( ssp + 8 ) ; \n new_cs = ldl ( ssp + 4 ) & 0xffff ; \n new_eip = ldl ( ssp ) & 0xffff ; \n } else { \n new_eflags = lduw ( ssp + 4 ) ; \n new_cs = lduw ( ssp + 2 ) ; \n new_eip = lduw ( ssp ) ; \n } \n new_esp = sp + ( 6 << shift ) ; \n env -> regs [ R_ESP ] = ( env -> regs [ R_ESP ] & 0xffff0000 ) | \n ( new_esp & 0xffff ) ; \n load_seg_vm ( R_CS , new_cs ) ; \n env -> eip = new_eip ; \n eflags_mask = FL_UPDATE_CPL0_MASK ; \n if ( shift == 0 ) \n eflags_mask &= 0xffff ; \n load_eflags ( new_eflags , eflags_mask ) ; \n }", "idx": 18149}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "USBDevice * usb_msd_init ( const char * filename ) \n { \n static int nr = 0 ; \n char id [ 8 ] ; \n QemuOpts * opts ; \n DriveInfo * dinfo ; \n USBDevice * dev ; \n int fatal_error ; \n const char * p1 ; \n char fmt [ 32 ] ; \n snprintf ( id , sizeof ( id ) , \" \" , nr ++ ) ; \n opts = qemu_opts_create ( & qemu_drive_opts , id , 0 ) ; \n p1 = strchr ( filename , ' ' ) ; \n if ( p1 ++ ) { \n const char * p2 ; \n if ( strstart ( filename , \" \" , & p2 ) ) { \n int len = MIN ( p1 - p2 , sizeof ( fmt ) ) ; \n pstrcpy ( fmt , len , p2 ) ; \n qemu_opt_set ( opts , \" \" , fmt ) ; \n } else if ( * filename != ' ' ) { \n printf ( \" \\n \" , filename ) ; \n return NULL ; \n } \n filename = p1 ; \n } \n if ( ! * filename ) { \n printf ( \" \\n \" ) ; \n return NULL ; \n } \n qemu_opt_set ( opts , \" \" , filename ) ; \n qemu_opt_set ( opts , \" \" , \" \" ) ; \n dinfo = drive_init ( opts , NULL , & fatal_error ) ; \n if ( ! dinfo ) { \n qemu_opts_del ( opts ) ; \n return NULL ; \n } \n dev = usb_create ( NULL \n , \" \" ) ; \n qdev_prop_set_drive ( & dev -> qdev , \" \" , dinfo ) ; \n qdev_init ( & dev -> qdev ) ; \n return dev ; \n }", "idx": 18179}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "static void rtc_get_date ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n Error * err = NULL ; \n RTCState * s = MC146818_RTC ( obj ) ; \n struct tm current_tm ; \n rtc_update_time ( s ) ; \n rtc_get_time ( s , & current_tm ) ; \n visit_start_struct ( v , NULL , \" \" , name , 0 , & err ) ; \n if ( err ) { \n goto out ; \n } \n visit_type_int32 ( v , & current_tm . tm_year , \" \" , & err ) ; \n visit_type_int32 ( v , & current_tm . tm_mon , \" \" , & err ) ; \n visit_type_int32 ( v , & current_tm . tm_mday , \" \" , & err ) ; \n visit_type_int32 ( v , & current_tm . tm_hour , \" \" , & err ) ; \n visit_type_int32 ( v , & current_tm . tm_min , \" \" , & err ) ; \n visit_type_int32 ( v , & current_tm . tm_sec , \" \" , & err ) ; \n visit_end_struct ( v , & err ) ; \n out : \n error_propagate ( errp , err ) ; \n }", "idx": 18191}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "func": "static uint16_t phys_section_add ( MemoryRegionSection * section ) \n { \n assert ( next_map . sections_nb < TARGET_PAGE_SIZE ) ; \n if ( next_map . sections_nb == next_map . sections_nb_alloc ) { \n next_map . sections_nb_alloc = MAX ( next_map . sections_nb_alloc * 2 , \n 16 ) ; \n next_map . sections = g_renew ( MemoryRegionSection , next_map . sections , \n next_map . sections_nb_alloc ) ; \n } \n next_map . sections [ next_map . sections_nb ] = * section ; \n memory_region_ref ( section -> mr ) ; \n return next_map . sections_nb ++ ; \n }", "idx": 18221}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readb ( void * opaque , target_phys_addr_t addr ) \n { \n IntelHDAState * d = opaque ; \n const IntelHDAReg * reg = intel_hda_reg_find ( d , addr ) ; \n return intel_hda_reg_read ( d , reg , 0xff ) ; \n }", "idx": 18232}
{"project": "qemu", "commit_id": "3182664220571d11d4fe03ecdc10fcc1e842ed32", "target": 0, "func": "static bool is_zero ( BlockDriverState * bs , int64_t offset , int64_t bytes ) \n { \n int nr ; \n int64_t res ; \n int64_t start ; \n start = QEMU_ALIGN_DOWN ( offset , BDRV_SECTOR_SIZE ) ; \n bytes = QEMU_ALIGN_UP ( offset + bytes , BDRV_SECTOR_SIZE ) - start ; \n if ( start + bytes > bs -> total_sectors * BDRV_SECTOR_SIZE ) { \n bytes = bs -> total_sectors * BDRV_SECTOR_SIZE - start ; \n } \n if ( ! bytes ) { \n return true ; \n } \n res = bdrv_get_block_status_above ( bs , NULL , start >> BDRV_SECTOR_BITS , \n bytes >> BDRV_SECTOR_BITS , & nr , NULL ) ; \n return res >= 0 && ( res & BDRV_BLOCK_ZERO ) && \n nr * BDRV_SECTOR_SIZE == bytes ; \n }", "idx": 18238}
{"project": "qemu", "commit_id": "fc1c4a5d32e15a4c40c47945da85ef9c1e0c1b54", "target": 0, "func": "void ram_handle_compressed ( void * host , uint8_t ch , uint64_t size ) \n { \n if ( ch != 0 || ! is_zero_range ( host , size ) ) { \n memset ( host , ch , size ) ; \n #ifndef _WIN32 \n if ( ch == 0 && ( ! kvm_enabled ( ) || kvm_has_sync_mmu ( ) ) ) { \n size = size & ~ ( getpagesize ( ) - 1 ) ; \n if ( size > 0 ) { \n qemu_madvise ( host , size , QEMU_MADV_DONTNEED ) ; \n } \n } \n #endif \n } \n }", "idx": 18278}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "static QEMUMachine * machine_parse ( const char * name ) \n { \n QEMUMachine * m , * machine = NULL ; \n if ( name ) { \n machine = find_machine ( name ) ; \n } \n if ( machine ) { \n return machine ; \n } \n printf ( \" \\n \" ) ; \n for ( m = first_machine ; m != NULL ; m = m -> next ) { \n if ( m -> alias ) { \n printf ( \" \\n \" , m -> alias , m -> desc , m -> name ) ; \n } \n printf ( \" \\n \" , m -> name , m -> desc , \n m -> is_default ? \" \" : \" \" ) ; \n } \n exit ( ! name || * name != ' ' ) ; \n }", "idx": 18283}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int do_getfd ( Monitor * mon , const QDict * qdict , QObject * * ret_data ) \n { \n const char * fdname = qdict_get_str ( qdict , \" \" ) ; \n mon_fd_t * monfd ; \n int fd ; \n fd = qemu_chr_get_msgfd ( mon -> chr ) ; \n if ( fd == -1 ) { \n qerror_report ( QERR_FD_NOT_SUPPLIED ) ; \n return -1 ; \n } \n if ( qemu_isdigit ( fdname [ 0 ] ) ) { \n qerror_report ( QERR_INVALID_PARAMETER_VALUE , \" \" , \n \" \" ) ; \n return -1 ; \n } \n fd = dup ( fd ) ; \n if ( fd == -1 ) { \n if ( errno == EMFILE ) \n qerror_report ( QERR_TOO_MANY_FILES ) ; \n else \n qerror_report ( QERR_UNDEFINED_ERROR ) ; \n return -1 ; \n } \n QLIST_FOREACH ( monfd , & mon -> fds , next )  { \n if ( strcmp ( monfd -> name , fdname ) != 0 ) { \n continue ; \n } \n close ( monfd -> fd ) ; \n monfd -> fd = fd ; \n return 0 ; \n } \n monfd = qemu_mallocz ( sizeof ( mon_fd_t ) ) ; \n monfd -> name = qemu_strdup ( fdname ) ; \n monfd -> fd = fd ; \n QLIST_INSERT_HEAD ( & mon -> fds , monfd , next ) ; \n return 0 ; \n }", "idx": 18290}
{"project": "qemu", "commit_id": "8139626643cbe8dc07bd9acc88057effeedf8064", "target": 1, "func": "uint32_t lm4549_write_samples ( lm4549_state * s , uint32_t left , uint32_t right ) \n { \n if ( s -> buffer_level >= LM4549_BUFFER_SIZE ) { \n DPRINTF ( \" \\n \" ) ; \n return 0 ; \n } \n s -> buffer [ s -> buffer_level ++ ] = ( left >> 4 ) ; \n s -> buffer [ s -> buffer_level ++ ] = ( right >> 4 ) ; \n if ( s -> buffer_level == LM4549_BUFFER_SIZE ) { \n lm4549_audio_transfer ( s ) ; \n } \n return 1 ; \n }", "idx": 18300}
{"project": "qemu", "commit_id": "f293709c6af7a65a9bcec09cdba7a60183657a3e", "target": 1, "func": "static inline void code_gen_alloc ( size_t tb_size ) \n { \n tcg_ctx . code_gen_buffer_size = size_code_gen_buffer ( tb_size ) ; \n tcg_ctx . code_gen_buffer = alloc_code_gen_buffer ( ) ; \n if ( tcg_ctx . code_gen_buffer == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n qemu_madvise ( tcg_ctx . code_gen_buffer , tcg_ctx . code_gen_buffer_size , \n QEMU_MADV_HUGEPAGE ) ; \n tcg_ctx . code_gen_max_blocks \n = tcg_ctx . code_gen_buffer_size / CODE_GEN_AVG_BLOCK_SIZE ; \n tcg_ctx . tb_ctx . tbs = g_new ( TranslationBlock , tcg_ctx . code_gen_max_blocks ) ; \n qemu_mutex_init ( & tcg_ctx . tb_ctx . tb_lock ) ; \n }", "idx": 18320}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUTimerList * qemu_clock_get_main_loop_timerlist ( QEMUClockType type ) \n { \n return main_loop_tlg . tl [ type ] ; \n }", "idx": 18342}
{"project": "qemu", "commit_id": "1945dbc15f0f1ffdc9a10526448e9eba7c599d98", "target": 0, "func": "static void openpic_update_irq ( openpic_t * opp , int n_IRQ ) \n { \n IRQ_src_t * src ; \n int i ; \n src = & opp -> src [ n_IRQ ] ; \n if ( ! src -> pending ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( test_bit ( & src -> ipvp , IPVP_MASK ) ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( IPVP_PRIORITY ( src -> ipvp ) == 0 ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( test_bit ( & src -> ipvp , IPVP_ACTIVITY ) ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( src -> ide == 0x00000000 ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( src -> ide == ( 1 << src -> last_cpu ) ) { \n IRQ_local_pipe ( opp , src -> last_cpu , n_IRQ ) ; \n } else if ( ! test_bit ( & src -> ipvp , IPVP_MODE ) ) { \n for ( i = 0 ; i < opp -> nb_cpus ; i ++ ) { \n if ( test_bit ( & src -> ide , i ) ) \n IRQ_local_pipe ( opp , i , n_IRQ ) ; \n } \n } else { \n for ( i = src -> last_cpu + 1 ; i != src -> last_cpu ; i ++ ) { \n if ( i == opp -> nb_cpus ) \n i = 0 ; \n if ( test_bit ( & src -> ide , i ) ) { \n IRQ_local_pipe ( opp , i , n_IRQ ) ; \n src -> last_cpu = i ; \n break ; \n } \n } \n } \n }", "idx": 18347}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_reset_modified_ram_pages ( void ) \n { \n int i ; \n unsigned long page_index ; \n for ( i = 0 ; i < nb_modified_ram_pages ; i ++ ) { \n page_index = modified_ram_pages [ i ] >> TARGET_PAGE_BITS ; \n modified_ram_pages_table [ page_index ] = 0 ; \n } \n nb_modified_ram_pages = 0 ; \n }", "idx": 18349}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cirrus_mmio_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n CirrusVGAState * s = opaque ; \n if ( addr >= 0x100 ) { \n cirrus_mmio_blt_write ( s , addr - 0x100 , val ) ; \n } else { \n cirrus_vga_ioport_write ( s , addr + 0x3c0 , val ) ; \n } \n }", "idx": 18353}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void tcp_chr_close ( CharDriverState * chr ) \n { \n TCPCharDriver * s = chr -> opaque ; \n if ( s -> fd >= 0 ) { \n if ( s -> tag ) { \n g_source_remove ( s -> tag ) ; \n s -> tag = 0 ; \n } \n if ( s -> chan ) { \n g_io_channel_unref ( s -> chan ) ; \n } \n closesocket ( s -> fd ) ; \n } \n if ( s -> listen_fd >= 0 ) { \n if ( s -> listen_tag ) { \n g_source_remove ( s -> listen_tag ) ; \n s -> listen_tag = 0 ; \n } \n if ( s -> listen_chan ) { \n g_io_channel_unref ( s -> listen_chan ) ; \n } \n closesocket ( s -> listen_fd ) ; \n } \n g_free ( s ) ; \n qemu_chr_be_event ( chr , CHR_EVENT_CLOSED ) ; \n }", "idx": 18390}
{"project": "qemu", "commit_id": "7e680753cfa2986e0a8b3b222b6bf0b003c5eb69", "target": 1, "func": "static int kvm_put_vcpu_events ( CPUState * env , int level ) \n { \n struct kvm_vcpu_events events ; \n if ( ! kvm_has_vcpu_events ( ) ) { \n return 0 ; \n } \n events . exception . injected = ( env -> exception_injected >= 0 ) ; \n events . exception . nr = env -> exception_injected ; \n events . exception . has_error_code = env -> has_error_code ; \n events . exception . error_code = env -> error_code ; \n events . interrupt . injected = ( env -> interrupt_injected >= 0 ) ; \n events . interrupt . nr = env -> interrupt_injected ; \n events . interrupt . soft = env -> soft_interrupt ; \n events . nmi . injected = env -> nmi_injected ; \n events . nmi . pending = env -> nmi_pending ; \n events . nmi . masked = ! ! ( env -> hflags2 & HF2_NMI_MASK ) ; \n events . nmi . pad = 0 ; \n events . sipi_vector = env -> sipi_vector ; \n events . flags = 0 ; \n if ( level >= KVM_PUT_RESET_STATE ) { \n events . flags |= \n KVM_VCPUEVENT_VALID_NMI_PENDING | KVM_VCPUEVENT_VALID_SIPI_VECTOR ; \n } \n return kvm_vcpu_ioctl ( env , KVM_SET_VCPU_EVENTS , & events ) ; \n }", "idx": 18402}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_signal ( QemuCond * cond ) \n { \n DWORD result ; \n if ( cond -> waiters == 0 ) { \n return ; \n } \n cond -> target = cond -> waiters - 1 ; \n result = SignalObjectAndWait ( cond -> sema , cond -> continue_event , \n INFINITE , FALSE ) ; \n if ( result == WAIT_ABANDONED || result == WAIT_FAILED ) { \n error_exit ( GetLastError ( ) , __func__ ) ; \n } \n }", "idx": 18413}
{"project": "qemu", "commit_id": "fd8cec932c2ddc687e2da954978954b46a926f90", "target": 1, "func": "int64_t xbzrle_cache_resize ( int64_t new_size ) \n { \n if ( new_size < TARGET_PAGE_SIZE ) { \n return -1 ; \n } \n if ( XBZRLE . cache != NULL ) { \n return cache_resize ( XBZRLE . cache , new_size / TARGET_PAGE_SIZE ) * \n TARGET_PAGE_SIZE ; \n } \n return pow2floor ( new_size ) ; \n }", "idx": 18425}
{"project": "qemu", "commit_id": "848696bf353750899832c51005f1bd3540da5c29", "target": 1, "func": "static void i82374_isa_realize ( DeviceState * dev , Error * * errp ) \n { \n ISAi82374State * isa = I82374 ( dev ) ; \n I82374State * s = & isa -> state ; \n PortioList * port_list = g_new ( PortioList , 1 ) ; \n portio_list_init ( port_list , OBJECT ( isa ) , i82374_portio_list , s , \" \" ) ; \n portio_list_add ( port_list , isa_address_space_io ( & isa -> parent_obj ) , \n isa -> iobase ) ; \n i82374_realize ( s , errp ) ; \n qdev_init_gpio_out ( dev , & s -> out , 1 ) ; \n }", "idx": 18481}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "floatx80 floatx80_scalbn ( floatx80 a , int n STATUS_PARAM ) \n { \n flag aSign ; \n int16 aExp ; \n uint64_t aSig ; \n aSig = extractFloatx80Frac ( a ) ; \n aExp = extractFloatx80Exp ( a ) ; \n aSign = extractFloatx80Sign ( a ) ; \n if ( aExp == 0x7FF ) { \n return a ; \n } \n if ( aExp == 0 && aSig == 0 ) \n return a ; \n aExp += n ; \n return normalizeRoundAndPackFloatx80 ( STATUS ( floatx80_rounding_precision ) , \n aSign , aExp , aSig , 0 STATUS_VAR ) ; \n }", "idx": 18497}
{"project": "qemu", "commit_id": "8827b0fb66cab9f7978c4e66dad4cf3c0989a72e", "target": 1, "func": "static void pl181_send_command ( pl181_state * s ) \n { \n SDRequest request ; \n uint8_t response [ 16 ] ; \n int rlen ; \n request . cmd = s -> cmd & PL181_CMD_INDEX ; \n request . arg = s -> cmdarg ; \n DPRINTF ( \" \\n \" , request . cmd , request . arg ) ; \n rlen = sd_do_command ( s -> card , & request , response ) ; \n if ( rlen < 0 ) \n goto error ; \n if ( s -> cmd & PL181_CMD_RESPONSE ) { \n #define RWORD ( n )  ((response[n] << 24) | (response[n + 1] << 16) \\ \n   \n  | ( response [ n + 2 ] << 8 ) | response [ n + 3 ] ) \n if ( rlen == 0 || ( rlen == 4 && ( s -> cmd & PL181_CMD_LONGRESP ) ) ) \n goto error ; \n if ( rlen != 4 && rlen != 16 ) \n goto error ; \n s -> response [ 0 ] = RWORD ( 0 ) ; \n if ( rlen == 4 ) { \n s -> response [ 1 ] = s -> response [ 2 ] = s -> response [ 3 ] = 0 ; \n } else { \n s -> response [ 1 ] = RWORD ( 4 ) ; \n s -> response [ 2 ] = RWORD ( 8 ) ; \n s -> response [ 3 ] = RWORD ( 12 ) & ~ 1 ; \n } \n DPRINTF ( \" \\n \" ) ; \n s -> status |= PL181_STATUS_CMDRESPEND ; \n #undef  RWORD  \n  \n  } else { \n DPRINTF ( \" \\n \" ) ; \n s -> status |= PL181_STATUS_CMDSENT ; \n } \n return ; \n error : \n DPRINTF ( \" \\n \" ) ; \n s -> status |= PL181_STATUS_CMDTIMEOUT ; \n }", "idx": 18528}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void ram_control_load_hook ( QEMUFile * f , uint64_t flags ) \n { \n int ret = - EINVAL ; \n if ( f -> ops -> hook_ram_load ) { \n ret = f -> ops -> hook_ram_load ( f , f -> opaque , flags ) ; \n if ( ret < 0 ) { \n qemu_file_set_error ( f , ret ) ; \n } \n } else { \n qemu_file_set_error ( f , ret ) ; \n } \n }", "idx": 18557}
{"project": "qemu", "commit_id": "97e89ee914411384dcda771d38bf89f13726d71e", "target": 1, "func": "static void gen_window_check3 ( DisasContext * dc , unsigned r1 , unsigned r2 , \n unsigned r3 ) \n { \n gen_window_check2 ( dc , r1 , r2 > r3 ? r2 : r3 ) ; \n }", "idx": 18571}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_handle_control ( USBDevice * dev , int request , int value , \n int index , int length , uint8_t * data ) \n { \n const USBDesc * desc = dev -> info -> usb_desc ; \n int ret = -1 ; \n assert ( desc != NULL ) ; \n switch ( request ) { \n case DeviceOutRequest | USB_REQ_SET_ADDRESS : \n dev -> addr = value ; \n trace_usb_set_addr ( dev -> addr ) ; \n ret = 0 ; \n break ; \n case DeviceRequest | USB_REQ_GET_DESCRIPTOR : \n ret = usb_desc_get_descriptor ( dev , value , data , length ) ; \n break ; \n } \n return ret ; \n }", "idx": 18603}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "static void trigger_prot_fault ( CPUS390XState * env , target_ulong vaddr , \n uint64_t mode ) \n { \n CPUState * cs = CPU ( s390_env_get_cpu ( env ) ) ; \n int ilen = ILEN_LATER_INC ; \n int bits = trans_bits ( env , mode ) | 4 ; \n DPRINTF ( \" \" PRIx64 \" \\n \" , __func__ , vaddr , bits ) ; \n stq_phys ( cs -> as , \n env -> psa + offsetof ( LowCore , trans_exc_code ) , vaddr | bits ) ; \n trigger_pgm_exception ( env , PGM_PROTECTION , ilen ) ; \n }", "idx": 18613}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "void string_output_visitor_cleanup ( StringOutputVisitor * sov ) \n { \n if ( sov -> string ) { \n g_string_free ( sov -> string , true ) ; \n } \n g_list_foreach ( sov -> ranges , free_range , NULL ) ; \n g_list_free ( sov -> ranges ) ; \n g_free ( sov ) ; \n }", "idx": 18621}
{"project": "qemu", "commit_id": "0462faee67eb9ee39e51f764891fb6b767602eed", "target": 1, "func": "void memory_region_allocate_system_memory ( MemoryRegion * mr , Object * owner , \n const char * name , \n uint64_t ram_size ) \n { \n uint64_t addr = 0 ; \n int i ; \n if ( nb_numa_nodes == 0 || ! have_memdevs ) { \n allocate_system_memory_nonnuma ( mr , owner , name , ram_size ) ; \n return ; \n memory_region_init ( mr , owner , name , ram_size ) ; \n for ( i = 0 ; i < MAX_NODES ; i ++ ) { \n Error * local_err = NULL ; \n uint64_t size = numa_info [ i ] . node_mem ; \n HostMemoryBackend * backend = numa_info [ i ] . node_memdev ; \n if ( ! backend ) { \n continue ; \n MemoryRegion * seg = host_memory_backend_get_memory ( backend , & local_err ) ; \n if ( local_err ) { \n qerror_report_err ( local_err ) ; \n memory_region_add_subregion ( mr , addr , seg ) ; \n vmstate_register_ram_global ( seg ) ; \n addr += size ;", "idx": 18627}
{"project": "qemu", "commit_id": "ccfcdd09bf91aabe039d2dae0b5ec3a05f083e59", "target": 0, "func": "static inline void gen_jcc ( DisasContext * s , int b , \n target_ulong val , target_ulong next_eip ) \n { \n int l1 , l2 ; \n gen_update_cc_op ( s ) ; \n if ( s -> jmp_opt ) { \n l1 = gen_new_label ( ) ; \n gen_jcc1 ( s , b , l1 ) ; \n set_cc_op ( s , CC_OP_DYNAMIC ) ; \n gen_goto_tb ( s , 0 , next_eip ) ; \n gen_set_label ( l1 ) ; \n gen_goto_tb ( s , 1 , val ) ; \n s -> is_jmp = DISAS_TB_JUMP ; \n } else { \n l1 = gen_new_label ( ) ; \n l2 = gen_new_label ( ) ; \n gen_jcc1 ( s , b , l1 ) ; \n set_cc_op ( s , CC_OP_DYNAMIC ) ; \n gen_jmp_im ( next_eip ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n gen_jmp_im ( val ) ; \n gen_set_label ( l2 ) ; \n gen_eob ( s ) ; \n } \n }", "idx": 18660}
{"project": "qemu", "commit_id": "5edbdbcdf882e4220adc7dbf433351077cd1fbbc", "target": 1, "func": "static int check_shm_size ( IVShmemState * s , int fd ) { \n struct stat buf ; \n fstat ( fd , & buf ) ; \n if ( s -> ivshmem_size > buf . st_size ) { \n fprintf ( stderr , \n \" \" \n \" \" PRIu64 \" \" PRIu64 \" \\n \" , \n s -> ivshmem_size , ( uint64_t ) buf . st_size ) ; \n return -1 ; \n } else { \n return 0 ; \n } \n }", "idx": 18702}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static inline uint32_t lduw_phys_internal ( target_phys_addr_t addr , \n enum device_endian endian ) \n { \n uint8_t * ptr ; \n uint64_t val ; \n MemoryRegionSection * section ; \n section = phys_page_find ( addr >> TARGET_PAGE_BITS ) ; \n if ( ! ( memory_region_is_ram ( section -> mr ) || \n memory_region_is_romd ( section -> mr ) ) ) { \n addr = memory_region_section_addr ( section , addr ) ; \n val = io_mem_read ( section -> mr , addr , 2 ) ; \n #if defined ( TARGET_WORDS_BIGENDIAN )  \n  \n  if ( endian == DEVICE_LITTLE_ENDIAN ) { \n val = bswap16 ( val ) ; \n } \n #else \n if ( endian == DEVICE_BIG_ENDIAN ) { \n val = bswap16 ( val ) ; \n } \n #endif \n } else { \n ptr = qemu_get_ram_ptr ( ( memory_region_get_ram_addr ( section -> mr ) \n & TARGET_PAGE_MASK ) \n + memory_region_section_addr ( section , addr ) ) ; \n switch ( endian ) { \n case DEVICE_LITTLE_ENDIAN : \n val = lduw_le_p ( ptr ) ; \n break ; \n case DEVICE_BIG_ENDIAN : \n val = lduw_be_p ( ptr ) ; \n break ; \n default : \n val = lduw_p ( ptr ) ; \n break ; \n } \n } \n return val ; \n }", "idx": 18736}
{"project": "qemu", "commit_id": "0e8b3cdfbc167f4bb7790ef744eaa1ac0e6959f9", "target": 1, "func": "void * postcopy_get_tmp_page ( MigrationIncomingState * mis ) \n { \n if ( ! mis -> postcopy_tmp_page ) { \n mis -> postcopy_tmp_page = mmap ( NULL , getpagesize ( ) , \n PROT_READ | PROT_WRITE , MAP_PRIVATE | \n MAP_ANONYMOUS , -1 , 0 ) ; \n if ( ! mis -> postcopy_tmp_page ) { \n error_report ( \" \" , __func__ , strerror ( errno ) ) ; \n return NULL ; \n } \n } \n return mis -> postcopy_tmp_page ; \n }", "idx": 18776}
{"project": "qemu", "commit_id": "ab431c283e7055bcd6fb622f212bb29e84a6a134", "target": 0, "func": "static int pci_slot_get_pirq ( PCIDevice * pci_dev , int irq_num ) \n { \n int slot_addend ; \n slot_addend = ( pci_dev -> devfn >> 3 ) - 1 ; \n return ( irq_num + slot_addend ) & 3 ; \n }", "idx": 18795}
{"project": "qemu", "commit_id": "b7fcff01790d25f48d81ef6c8c3399577096a555", "target": 1, "func": "static void test_bmdma_setup ( void ) \n { \n ide_test_start ( \n \" \" \n \" \" \n \" \" , \n tmp_path , \" \" , \" \" ) ; \n }", "idx": 18834}
{"project": "qemu", "commit_id": "336c1c12551ff0a6e1a2af226d6cbdbadd2e02b5", "target": 0, "func": "int bdrv_has_zero_init ( BlockDriverState * bs ) \n { \n assert ( bs -> drv ) ; \n if ( bs -> drv -> no_zero_init ) { \n return 0 ; \n } else if ( bs -> file ) { \n return bdrv_has_zero_init ( bs -> file ) ; \n } \n return 1 ; \n }", "idx": 18872}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static int pci_vpb_map_irq ( PCIDevice * d , int irq_num ) \n { \n PCIVPBState * s = container_of ( d -> bus , PCIVPBState , pci_bus ) ; \n if ( s -> irq_mapping == PCI_VPB_IRQMAP_BROKEN ) { \n return irq_num ; \n } \n return pci_swizzle_map_irq_fn ( d , irq_num + 2 ) ; \n }", "idx": 18916}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static uint32_t omap_l4_io_readh ( void * opaque , target_phys_addr_t addr ) \n { \n unsigned int i = ( addr - OMAP2_L4_BASE ) >> TARGET_PAGE_BITS ; \n return omap_l4_io_readh_fn [ i ] ( omap_l4_io_opaque [ i ] , addr ) ; \n }", "idx": 18930}
{"project": "qemu", "commit_id": "ba4906a9b64e165a958e12f6208ca834dc7a36dc", "target": 1, "func": "static int ds1338_recv ( I2CSlave * i2c ) \n { \n DS1338State * s = FROM_I2C_SLAVE ( DS1338State , i2c ) ; \n uint8_t res ; \n res = s -> nvram [ s -> ptr ] ; \n s -> ptr = ( s -> ptr + 1 ) & 0xff ; \n return res ; \n }", "idx": 18946}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "size_t qsb_get_length ( const QEMUSizedBuffer * qsb ) \n { \n return qsb -> used ; \n }", "idx": 18955}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float64 helper_fsmuld ( CPUSPARCState * env , float32 src1 , float32 src2 ) \n { \n float64 ret ; \n clear_float_exceptions ( env ) ; \n ret = float64_mul ( float32_to_float64 ( src1 , & env -> fp_status ) , \n float32_to_float64 ( src2 , & env -> fp_status ) , \n & env -> fp_status ) ; \n check_ieee_exceptions ( env ) ; \n return ret ; \n }", "idx": 18999}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "target_phys_addr_t omap_l4_attach ( struct omap_target_agent_s * ta , int region , \n int iotype ) \n { \n target_phys_addr_t base ; \n ssize_t size ; \n #ifdef L4_MUX_HACK \n int i ; \n #endif \n if ( region < 0 || region >= ta -> regions ) { \n fprintf ( stderr , \" \\n \" , __FUNCTION__ , region ) ; \n exit ( -1 ) ; \n } \n base = ta -> bus -> base + ta -> start [ region ] . offset ; \n size = ta -> start [ region ] . size ; \n if ( iotype ) { \n #ifndef L4_MUX_HACK \n cpu_register_physical_memory ( base , size , iotype ) ; \n #else \n cpu_register_physical_memory ( base , size , omap_cpu_io_entry ) ; \n i = ( base - ta -> bus -> base ) / TARGET_PAGE_SIZE ; \n for ( ; size > 0 ; size -= TARGET_PAGE_SIZE , i ++ ) { \n omap_l4_io_readb_fn [ i ] = omap_l4_io_entry [ iotype ] . mem_read [ 0 ] ; \n omap_l4_io_readh_fn [ i ] = omap_l4_io_entry [ iotype ] . mem_read [ 1 ] ; \n omap_l4_io_readw_fn [ i ] = omap_l4_io_entry [ iotype ] . mem_read [ 2 ] ; \n omap_l4_io_writeb_fn [ i ] = omap_l4_io_entry [ iotype ] . mem_write [ 0 ] ; \n omap_l4_io_writeh_fn [ i ] = omap_l4_io_entry [ iotype ] . mem_write [ 1 ] ; \n omap_l4_io_writew_fn [ i ] = omap_l4_io_entry [ iotype ] . mem_write [ 2 ] ; \n omap_l4_io_opaque [ i ] = omap_l4_io_entry [ iotype ] . opaque ; \n } \n #endif \n } \n return base ; \n }", "idx": 19002}
{"project": "qemu", "commit_id": "0188fadb7fe460d8c4c743372b1f7b25773e183e", "target": 1, "func": "static void setup_frame ( int sig , struct target_sigaction * ka , \n target_sigset_t * set , CPUMIPSState * regs ) \n { \n struct sigframe * frame ; \n abi_ulong frame_addr ; \n int i ; \n frame_addr = get_sigframe ( ka , regs , sizeof ( * frame ) ) ; \n if ( ! lock_user_struct ( VERIFY_WRITE , frame , frame_addr , 0 ) ) \n goto give_sigsegv ; \n install_sigtramp ( frame -> sf_code , TARGET_NR_sigreturn ) ; \n setup_sigcontext ( regs , & frame -> sf_sc ) ; \n for ( i = 0 ; i < TARGET_NSIG_WORDS ; i ++ ) { \n if ( __put_user ( set -> sig [ i ] , & frame -> sf_mask . sig [ i ] ) ) \n goto give_sigsegv ; \n } \n regs -> active_tc . gpr [ 4 ] = sig ; \n regs -> active_tc . gpr [ 5 ] = 0 ; \n regs -> active_tc . gpr [ 6 ] = frame_addr + offsetof ( struct sigframe , sf_sc ) ; \n regs -> active_tc . gpr [ 29 ] = frame_addr ; \n regs -> active_tc . gpr [ 31 ] = frame_addr + offsetof ( struct sigframe , sf_code ) ; \n regs -> active_tc . PC = regs -> active_tc . gpr [ 25 ] = ka -> _sa_handler ; \n mips_set_hflags_isa_mode_from_pc ( regs ) ; \n unlock_user_struct ( frame , frame_addr , 1 ) ; \n return ; \n give_sigsegv : \n unlock_user_struct ( frame , frame_addr , 1 ) ; \n force_sig ( TARGET_SIGSEGV \n ) ; \n }", "idx": 19006}
{"project": "qemu", "commit_id": "b38ec5ee7a581776bbce0bdaecb397632c3c4791", "target": 1, "func": "static void pci_msix_write ( void * opaque , hwaddr addr , \n uint64_t val , unsigned size ) \n { \n XenPCIPassthroughState * s = opaque ; \n XenPTMSIX * msix = s -> msix ; \n XenPTMSIXEntry * entry ; \n int entry_nr , offset ; \n entry_nr = addr / PCI_MSIX_ENTRY_SIZE ; \n if ( entry_nr < 0 || entry_nr >= msix -> total_entries ) { \n XEN_PT_ERR ( & s -> dev , \" \\n \" , entry_nr ) ; \n return ; \n } \n entry = & msix -> msix_entry [ entry_nr ] ; \n offset = addr % PCI_MSIX_ENTRY_SIZE ; \n if ( offset != PCI_MSIX_ENTRY_VECTOR_CTRL ) { \n const volatile uint32_t * vec_ctrl ; \n if ( get_entry_value ( entry , offset ) == val \n && entry -> pirq != XEN_PT_UNASSIGNED_PIRQ ) { \n return ; \n } \n vec_ctrl = s -> msix -> phys_iomem_base + entry_nr * PCI_MSIX_ENTRY_SIZE \n + PCI_MSIX_ENTRY_VECTOR_CTRL ; \n if ( msix -> enabled && ! ( * vec_ctrl & PCI_MSIX_ENTRY_CTRL_MASKBIT ) ) { \n XEN_PT_ERR ( & s -> dev , \" \" \n \" \\n \" , entry_nr ) ; \n return ; \n } \n entry -> updated = true ; \n } \n set_entry_value ( entry , offset , val ) ; \n if ( offset == PCI_MSIX_ENTRY_VECTOR_CTRL ) { \n if ( msix -> enabled && ! ( val & PCI_MSIX_ENTRY_CTRL_MASKBIT ) ) { \n xen_pt_msix_update_one ( s , entry_nr ) ; \n } \n } \n }", "idx": 19014}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void tap_set_sndbuf ( TAPState * s , const char * sndbuf_str , Monitor * mon ) \n { \n if ( sndbuf_str ) { \n config_error ( mon , \" \\n \" ) ; \n } \n }", "idx": 19062}
{"project": "qemu", "commit_id": "bf8d5166395612b4e856fad57606eb0cff97ae2e", "target": 1, "func": "static uint64_t error_mem_read ( void * opaque , hwaddr addr , \n unsigned size ) \n { \n abort ( ) ; \n }", "idx": 19065}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "static void timer_del_locked ( QEMUTimerList * timer_list , QEMUTimer * ts ) \n { \n QEMUTimer * * pt , * t ; \n ts -> expire_time = -1 ; \n pt = & timer_list -> active_timers ; \n for ( ; ; ) { \n t = * pt ; \n if ( ! t ) \n break ; \n if ( t == ts ) { \n * pt = t -> next ; \n break ; \n } \n pt = & t -> next ; \n } \n }", "idx": 19099}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_sys ( DisasContext * s , uint32_t insn , unsigned int l , \n unsigned int op1 , unsigned int op2 , \n unsigned int crn , unsigned int crm , unsigned int rt ) \n { \n unsupported_encoding ( s , insn ) ; \n }", "idx": 19120}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "func": "static CharDriverState * qemu_chr_open_pp_fd ( int fd ) \n { \n CharDriverState * chr ; \n ParallelCharDriver * drv ; \n if ( ioctl ( fd , PPCLAIM ) < 0 ) { \n close ( fd ) ; \n return NULL ; \n } \n drv = g_malloc0 ( sizeof ( ParallelCharDriver ) ) ; \n drv -> fd = fd ; \n drv -> mode = IEEE1284_MODE_COMPAT ; \n chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n chr -> chr_write = null_chr_write ; \n chr -> chr_ioctl = pp_ioctl ; \n chr -> chr_close = pp_close ; \n chr -> opaque = drv ; \n return chr ; \n }", "idx": 19130}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char * bdrv_get_device_or_node_name ( const BlockDriverState * bs ) \n { \n return bs -> blk ? blk_name ( bs -> blk ) : bs -> node_name ; \n }", "idx": 19137}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static QObject * qmp_output_pop ( QmpOutputVisitor * qov , void * qapi ) \n { \n QStackEntry * e = QSLIST_FIRST ( & qov -> stack ) ; \n QObject * value ; \n assert ( e ) ; \n assert ( e -> qapi == qapi ) ; \n QSLIST_REMOVE_HEAD ( & qov -> stack , node ) ; \n value = e -> value ; \n assert ( value ) ; \n g_free ( e ) ; \n return value ; \n }", "idx": 19142}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "int coroutine_fn bdrv_is_allocated ( BlockDriverState * bs , int64_t offset , \n int64_t bytes , int64_t * pnum ) \n { \n BlockDriverState * file ; \n int64_t sector_num = offset >> BDRV_SECTOR_BITS ; \n int nb_sectors = bytes >> BDRV_SECTOR_BITS ; \n int64_t ret ; \n int psectors ; \n assert ( QEMU_IS_ALIGNED ( offset , BDRV_SECTOR_SIZE ) ) ; \n assert ( QEMU_IS_ALIGNED ( bytes , BDRV_SECTOR_SIZE ) && bytes < INT_MAX ) ; \n ret = bdrv_get_block_status ( bs , sector_num , nb_sectors , & psectors , \n & file ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n if ( pnum ) { \n * pnum = psectors * BDRV_SECTOR_SIZE ; \n } \n return ! ! ( ret & BDRV_BLOCK_ALLOCATED ) ; \n }", "idx": 19165}
{"project": "qemu", "commit_id": "fe40e627c51e38922b64b02b6163aea4b6aad896", "target": 0, "func": "static void object_set_link_property ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n Object * * child = opaque ; \n bool ambiguous = false ; \n const char * type ; \n char * path ; \n type = object_property_get_type ( obj , name , NULL ) ; \n visit_type_str ( v , & path , name , errp ) ; \n if ( * child ) { \n object_unref ( * child ) ; \n } \n if ( strcmp ( path , \" \" ) != 0 ) { \n Object * target ; \n target = object_resolve_path ( path , & ambiguous ) ; \n if ( target ) { \n gchar * target_type ; \n target_type = g_strdup_printf ( \" \" , \n object_get_typename ( OBJECT ( target ) ) ) ; \n if ( strcmp ( target_type , type ) == 0 ) { \n * child = target ; \n object_ref ( target ) ; \n } else { \n error_set ( errp , QERR_INVALID_PARAMETER_TYPE , name , type ) ; \n } \n g_free ( target_type ) ; \n } else { \n error_set ( errp , QERR_DEVICE_NOT_FOUND , path ) ; \n } \n } else { \n * child = NULL ; \n } \n g_free ( path ) ; \n }", "idx": 19181}
{"project": "qemu", "commit_id": "88affa1c77c9019f3450f851495997897bd14e40", "target": 1, "func": "static void do_info_trace ( Monitor * mon ) \n { \n st_print_trace ( ( FILE * ) mon , & monitor_fprintf ) ; \n }", "idx": 19213}
{"project": "qemu", "commit_id": "444bc908611ccaf4512dc37c33ac3b54d873a62b", "target": 1, "func": "static void scsi_unmap_complete ( void * opaque , int ret ) \n { \n UnmapCBData * data = opaque ; \n SCSIDiskReq * r = data -> r ; \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; \n uint64_t sector_num ; \n uint32_t nb_sectors ; \n r -> req . aiocb = NULL ; \n if ( ret < 0 ) { \n if ( scsi_handle_rw_error ( r , - ret ) ) { \n goto done ; \n } \n } \n if ( data -> count > 0 && ! r -> req . io_canceled ) { \n sector_num = ldq_be_p ( & data -> inbuf [ 0 ] ) ; \n nb_sectors = ldl_be_p ( & data -> inbuf [ 8 ] ) & 0xffffffffULL ; \n if ( sector_num > sector_num + nb_sectors || \n sector_num + nb_sectors - 1 > s -> qdev . max_lba ) { \n scsi_check_condition ( r , SENSE_CODE ( LBA_OUT_OF_RANGE ) ) ; \n goto done ; \n } \n r -> req . aiocb = bdrv_aio_discard ( s -> qdev . conf . bs , \n sector_num * ( s -> qdev . blocksize / 512 ) , \n nb_sectors * ( s -> qdev . blocksize / 512 ) , \n scsi_unmap_complete , data ) ; \n data -> count -- ; \n data -> inbuf += 16 ; \n return ; \n } \n done : \n if ( data -> count == 0 ) { \n scsi_req_complete ( & r -> req , GOOD ) ; \n } \n if ( ! r -> req . io_canceled ) { \n scsi_req_unref ( & r -> req ) ; \n } \n g_free ( data ) ; \n }", "idx": 19227}
{"project": "qemu", "commit_id": "f1710638edb2e98008c2a733ffda63ef32b50411", "target": 1, "func": "int qcrypto_hash_bytesv ( QCryptoHashAlgorithm alg , \n const struct iovec * iov , \n size_t niov , \n uint8_t * * result , \n size_t * resultlen , \n Error * * errp ) \n { \n #ifdef CONFIG_AF_ALG \n int ret ; \n ret = qcrypto_hash_afalg_driver . hash_bytesv ( alg , iov , niov , \n result , resultlen , \n errp ) ; \n if ( ret == 0 ) { \n return ret ; \n } \n error_free ( * errp ) ; \n #endif \n return qcrypto_hash_lib_driver . hash_bytesv ( alg , iov , niov , \n result , resultlen , \n errp ) ; \n }", "idx": 19233}
{"project": "qemu", "commit_id": "b0ba0b9b6b402d738f11f27eea6c94d97bf84cbf", "target": 0, "func": "int pcnet_can_receive ( NetClientState * nc ) \n { \n PCNetState * s = qemu_get_nic_opaque ( nc ) ; \n if ( CSR_STOP ( s ) || CSR_SPND ( s ) ) \n return 0 ; \n return sizeof ( s -> buffer ) - 16 ; \n }", "idx": 19252}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "void * kvmppc_create_spapr_tce ( uint32_t liobn , uint32_t window_size , int * pfd , \n bool vfio_accel ) \n { \n struct kvm_create_spapr_tce args = { \n . liobn = liobn , \n . window_size = window_size , \n } ; \n long len ; \n int fd ; \n void * table ; \n * pfd = -1 ; \n if ( ! cap_spapr_tce || ( vfio_accel && ! cap_spapr_vfio ) ) { \n return NULL ; \n } \n fd = kvm_vm_ioctl ( kvm_state , KVM_CREATE_SPAPR_TCE , & args ) ; \n if ( fd < 0 ) { \n fprintf ( stderr , \" \\n \" , \n liobn ) ; \n return NULL ; \n } \n len = ( window_size / SPAPR_TCE_PAGE_SIZE ) * sizeof ( uint64_t ) ; \n table = mmap ( NULL , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0 ) ; \n if ( table == MAP_FAILED ) { \n fprintf ( stderr , \" \\n \" , \n liobn ) ; \n close ( fd ) ; \n return NULL ; \n } \n * pfd = fd ; \n return table ; \n }", "idx": 19264}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_pmu_write ( void * opaque , target_phys_addr_t offset , \n uint64_t val , unsigned size ) \n { \n Exynos4210PmuState * s = ( Exynos4210PmuState * ) opaque ; \n unsigned i ; \n const Exynos4210PmuReg * reg_p = exynos4210_pmu_regs ; \n for ( i = 0 ; i < PMU_NUM_OF_REGISTERS ; i ++ ) { \n if ( reg_p -> offset == offset ) { \n PRINT_DEBUG_EXTEND ( \" \\n \" , reg_p -> name , \n ( uint32_t ) offset , ( uint32_t ) val ) ; \n s -> reg [ i ] = val ; \n return ; \n } \n reg_p ++ ; \n } \n PRINT_DEBUG ( \" \\n \" , ( uint32_t ) offset ) ; \n }", "idx": 19278}
{"project": "qemu", "commit_id": "45416789e8ccced568a4984af61974adfbfa0f62", "target": 0, "func": "static int omap_validate_emiff_addr ( struct omap_mpu_state_s * s , \n target_phys_addr_t addr ) \n { \n return addr >= OMAP_EMIFF_BASE && addr < OMAP_EMIFF_BASE + s -> sdram_size ; \n }", "idx": 19281}
{"project": "qemu", "commit_id": "c96a1c0ba6b88fb47ca734013ae9b9248f78fbb4", "target": 0, "func": "static const CPUArchIdList * pc_possible_cpu_arch_ids ( MachineState * machine ) \n { \n assert ( machine -> possible_cpus ) ; \n return machine -> possible_cpus ; \n }", "idx": 19294}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_update ( void ) \n { \n int i , delta ; \n if ( term_cmd_buf_size != term_last_cmd_buf_size || \n memcmp ( term_cmd_buf , term_last_cmd_buf , term_cmd_buf_size ) != 0 ) { \n for ( i = 0 ; i < term_last_cmd_buf_index ; i ++ ) { \n term_printf ( \" \\033 \" ) ; \n } \n term_cmd_buf [ term_cmd_buf_size ] = ' \\0 ' ; \n term_printf ( \" \" , term_cmd_buf ) ; \n term_printf ( \" \\033 \" ) ; \n memcpy ( term_last_cmd_buf , term_cmd_buf , term_cmd_buf_size ) ; \n term_last_cmd_buf_size = term_cmd_buf_size ; \n term_last_cmd_buf_index = term_cmd_buf_size ; \n } \n if ( term_cmd_buf_index != term_last_cmd_buf_index ) { \n delta = term_cmd_buf_index - term_last_cmd_buf_index ; \n if ( delta > 0 ) { \n for ( i = 0 ; i < delta ; i ++ ) { \n term_printf ( \" \\033 \" ) ; \n } \n } else { \n delta = - delta ; \n for ( i = 0 ; i < delta ; i ++ ) { \n term_printf ( \" \\033 \" ) ; \n } \n } \n term_last_cmd_buf_index = term_cmd_buf_index ; \n } \n term_flush ( ) ; \n }", "idx": 19325}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint32_t qvirtio_pci_config_readl ( QVirtioDevice * d , uint64_t off ) \n { \n QVirtioPCIDevice * dev = ( QVirtioPCIDevice * ) d ; \n uint32_t value ; \n value = qpci_io_readl ( dev -> pdev , CONFIG_BASE ( dev ) + off ) ; \n if ( qvirtio_is_big_endian ( d ) ) { \n value = bswap32 ( value ) ; \n } \n return value ; \n }", "idx": 19357}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int blk_mig_active ( void ) \n { \n return ! QSIMPLEQ_EMPTY ( & block_mig_state . bmds_list ) ; \n }", "idx": 19366}
{"project": "qemu", "commit_id": "41742767bfa8127954b6f57b39b590adcde3ac6c", "target": 0, "func": "static void isapc_machine_options ( MachineClass * m ) \n { \n pc_common_machine_options ( m ) ; \n m -> desc = \" \" ; \n m -> max_cpus = 1 ; \n }", "idx": 19372}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static inline AIOReq * alloc_aio_req ( BDRVSheepdogState * s , SheepdogAIOCB * acb , \n uint64_t oid , unsigned int data_len , \n uint64_t offset , uint8_t flags , \n uint64_t base_oid , unsigned int iov_offset ) \n { \n AIOReq * aio_req ; \n aio_req = g_malloc ( sizeof ( * aio_req ) ) ; \n aio_req -> aiocb = acb ; \n aio_req -> iov_offset = iov_offset ; \n aio_req -> oid = oid ; \n aio_req -> base_oid = base_oid ; \n aio_req -> offset = offset ; \n aio_req -> data_len = data_len ; \n aio_req -> flags = flags ; \n aio_req -> id = s -> aioreq_seq_num ++ ; \n acb -> nr_pending ++ ; \n return aio_req ; \n }", "idx": 19423}
{"project": "qemu", "commit_id": "ded6ddc5a7b95217557fa360913d1213e12d4a6d", "target": 0, "func": "static int32_t scsi_target_send_command ( SCSIRequest * req , uint8_t * buf ) \n { \n SCSITargetReq * r = DO_UPCAST ( SCSITargetReq , req , req ) ; \n switch ( buf [ 0 ] ) { \n case REPORT_LUNS : \n if ( ! scsi_target_emulate_report_luns ( r ) ) { \n goto illegal_request ; \n } \n break ; \n case INQUIRY : \n if ( ! scsi_target_emulate_inquiry ( r ) ) { \n goto illegal_request ; \n } \n break ; \n case REQUEST_SENSE : \n scsi_target_alloc_buf ( & r -> req , scsi_sense_len ( req ) ) ; \n r -> len = scsi_device_get_sense ( r -> req . dev , r -> buf , \n MIN ( req -> cmd . xfer , r -> buf_len ) , \n ( req -> cmd . buf [ 1 ] & 1 ) == 0 ) ; \n if ( r -> req . dev -> sense_is_ua ) { \n scsi_device_unit_attention_reported ( req -> dev ) ; \n r -> req . dev -> sense_len = 0 ; \n r -> req . dev -> sense_is_ua = false ; \n } \n break ; \n case TEST_UNIT_READY : \n break ; \n default : \n scsi_req_build_sense ( req , SENSE_CODE ( LUN_NOT_SUPPORTED ) ) ; \n scsi_req_complete ( req , CHECK_CONDITION ) ; \n return 0 ; \n illegal_request : \n scsi_req_build_sense ( req , SENSE_CODE ( INVALID_FIELD ) ) ; \n scsi_req_complete ( req , CHECK_CONDITION ) ; \n return 0 ; \n } \n if ( ! r -> len ) { \n scsi_req_complete ( req , GOOD ) ; \n } \n return r -> len ; \n }", "idx": 19476}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_spare ( OneNANDState * s , int sec , int secn , \n void * dest ) \n { \n uint8_t buf [ 512 ] ; \n if ( s -> bdrv_cur ) { \n if ( bdrv_read ( s -> bdrv_cur , s -> secs_cur + ( sec >> 5 ) , buf , 1 ) < 0 ) \n return 1 ; \n memcpy ( dest , buf + ( ( sec & 31 ) << 4 ) , secn << 4 ) ; \n } else if ( sec + secn > s -> secs_cur ) \n return 1 ; \n else \n memcpy ( dest , s -> current + ( s -> secs_cur << 9 ) + ( sec << 4 ) , secn << 4 ) ; \n return 0 ; \n }", "idx": 19479}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps ( int fccno , TCGv_i32 r_rs1 , TCGv_i32 r_rs2 ) \n { \n switch ( fccno ) { \n case 0 : \n gen_helper_fcmps ( cpu_env , r_rs1 , r_rs2 ) ; \n break ; \n case 1 : \n gen_helper_fcmps_fcc1 ( cpu_env , r_rs1 , r_rs2 ) ; \n break ; \n case 2 : \n gen_helper_fcmps_fcc2 ( cpu_env , r_rs1 , r_rs2 ) ; \n break ; \n case 3 : \n gen_helper_fcmps_fcc3 ( cpu_env , r_rs1 , r_rs2 ) ; \n break ; \n } \n }", "idx": 19480}
{"project": "qemu", "commit_id": "fd859081453f94c3cbd6527289e41b7fddbf645f", "target": 0, "func": "static void tpm_tis_receive_cb ( TPMState * s , uint8_t locty ) \n { \n TPMTISEmuState * tis = & s -> s . tis ; \n assert ( s -> locty_number == locty ) ; \n qemu_bh_schedule ( tis -> bh ) ; \n }", "idx": 19489}
{"project": "qemu", "commit_id": "f7c11b535040df31cc8bc3b1f0c33f546073ee62", "target": 0, "func": "void cpu_physical_memory_unmap ( void * buffer , target_phys_addr_t len , \n int is_write , target_phys_addr_t access_len ) \n { \n if ( buffer != bounce . buffer ) { \n if ( is_write ) { \n ram_addr_t addr1 = qemu_ram_addr_from_host ( buffer ) ; \n while ( access_len ) { \n unsigned l ; \n l = TARGET_PAGE_SIZE ; \n if ( l > access_len ) \n l = access_len ; \n if ( ! cpu_physical_memory_is_dirty ( addr1 ) ) { \n tb_invalidate_phys_page_range ( addr1 , addr1 + l , 0 ) ; \n phys_ram_dirty [ addr1 >> TARGET_PAGE_BITS ] |= \n ( 0xff & ~ CODE_DIRTY_FLAG ) ; \n } \n addr1 += l ; \n access_len -= l ; \n } \n } \n return ; \n } \n if ( is_write ) { \n cpu_physical_memory_write ( bounce . addr , bounce . buffer , access_len ) ; \n } \n qemu_vfree ( bounce . buffer ) ; \n bounce . buffer = NULL ; \n cpu_notify_map_clients ( ) ; \n }", "idx": 19504}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_prop_set_defaults ( DeviceState * dev , Property * props ) \n { \n if ( ! props ) \n return ; \n while ( props -> name ) { \n if ( props -> defval ) { \n qdev_prop_cpy ( dev , props , props -> defval ) ; \n } \n props ++ ; \n } \n }", "idx": 19520}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_op_evabs ( TCGv_i32 ret , TCGv_i32 arg1 ) \n { \n int l1 = gen_new_label ( ) ; \n int l2 = gen_new_label ( ) ; \n tcg_gen_brcondi_i32 ( TCG_COND_GE , arg1 , 0 , l1 ) ; \n tcg_gen_neg_i32 ( ret , arg1 ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_mov_i32 ( ret , arg1 ) ; \n gen_set_label ( l2 ) ; \n }", "idx": 19523}
{"project": "qemu", "commit_id": "d85fa9eb87ba736d2d5ce342fc35f507c8fe29f2", "target": 1, "func": "static coroutine_fn int qemu_gluster_co_flush_to_disk ( BlockDriverState * bs ) \n { \n int ret ; \n GlusterAIOCB acb ; \n BDRVGlusterState * s = bs -> opaque ; \n acb . size = 0 ; \n acb . ret = 0 ; \n acb . coroutine = qemu_coroutine_self ( ) ; \n acb . aio_context = bdrv_get_aio_context ( bs ) ; \n ret = glfs_fsync_async ( s -> fd , gluster_finish_aiocb , & acb ) ; \n if ( ret < 0 ) { \n return - errno ; \n } \n qemu_coroutine_yield ( ) ; \n return acb . ret ; \n }", "idx": 19530}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline uint32_t reloc_26_val ( tcg_insn_unit * pc , tcg_insn_unit * target ) \n { \n assert ( ( ( ( uintptr_t ) pc ^ ( uintptr_t ) target ) & 0xf0000000 ) == 0 ) ; \n return ( ( uintptr_t ) target >> 2 ) & 0x3ffffff ; \n }", "idx": 19571}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static uint32_t openpic_iack ( OpenPICState * opp , IRQDest * dst , int cpu ) \n { \n IRQSource * src ; \n int retval , irq ; \n DPRINTF ( \" \\n \" ) ; \n qemu_irq_lower ( dst -> irqs [ OPENPIC_OUTPUT_INT ] ) ; \n irq = IRQ_get_next ( opp , & dst -> raised ) ; \n DPRINTF ( \" \\n \" , irq ) ; \n if ( irq == -1 ) { \n return opp -> spve ; \n } \n src = & opp -> src [ irq ] ; \n if ( ! ( src -> ivpr & IVPR_ACTIVITY_MASK ) || \n ! ( IVPR_PRIORITY ( src -> ivpr ) > dst -> ctpr ) ) { \n src -> ivpr &= ~ IVPR_ACTIVITY_MASK ; \n retval = opp -> spve ; \n } else { \n IRQ_setbit ( & dst -> servicing , irq ) ; \n retval = IVPR_VECTOR ( opp , src -> ivpr ) ; \n } \n IRQ_resetbit ( & dst -> raised , irq ) ; \n if ( ! src -> level ) { \n src -> ivpr &= ~ IVPR_ACTIVITY_MASK ; \n src -> pending = 0 ; \n } \n if ( ( irq >= opp -> irq_ipi0 ) && ( irq < ( opp -> irq_ipi0 + MAX_IPI ) ) ) { \n src -> idr &= ~ ( 1 << cpu ) ; \n if ( src -> idr && ! src -> level ) { \n openpic_set_irq ( opp , irq , 1 ) ; \n openpic_set_irq ( opp , irq , 0 ) ; \n src -> ivpr |= IVPR_ACTIVITY_MASK ; \n } \n } \n return retval ; \n }", "idx": 19573}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbie ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n if ( unlikely ( ctx -> pr || ! ctx -> hv ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n if ( NARROW_MODE ( ctx ) ) { \n TCGv t0 = tcg_temp_new ( ) ; \n tcg_gen_ext32u_tl ( t0 , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n gen_helper_tlbie ( cpu_env , t0 ) ; \n tcg_temp_free ( t0 ) ; \n } else { \n gen_helper_tlbie ( cpu_env , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n } \n #endif \n }", "idx": 19615}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void qga_vss_fsfreeze ( int * nr_volume , Error * * errp , bool freeze ) \n { \n const char * func_name = freeze ? \" \" : \" \" ; \n QGAVSSRequesterFunc func ; \n ErrorSet errset = { \n . error_setg_win32 = error_setg_win32 , \n . errp = errp , \n } ; \n g_assert ( errp ) ; \n func = ( QGAVSSRequesterFunc ) GetProcAddress ( provider_lib , func_name ) ; \n if ( ! func ) { \n error_setg_win32 ( errp , GetLastError ( ) , \" \" , \n func_name , QGA_VSS_DLL ) ; \n return ; \n } \n func ( nr_volume , & errset ) ; \n }", "idx": 19648}
{"project": "qemu", "commit_id": "2ecea9b8de5cd74df314541b87f712ae77f862ec", "target": 1, "func": "static void do_change_block ( const char * device , const char * filename ) \n { \n BlockDriverState * bs ; \n bs = bdrv_find ( device ) ; \n if ( ! bs ) { \n term_printf ( \" \\n \" ) ; \n return ; \n } \n if ( eject_device ( bs , 0 ) < 0 ) \n return ; \n bdrv_open ( bs , filename , 0 ) ; \n qemu_key_check ( bs , filename ) ; \n }", "idx": 19659}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static NFSServer * nfs_config ( QDict * options , Error * * errp ) \n { \n NFSServer * server = NULL ; \n QDict * addr = NULL ; \n QObject * crumpled_addr = NULL ; \n Visitor * iv = NULL ; \n Error * local_error = NULL ; \n qdict_extract_subqdict ( options , & addr , \" \" ) ; \n if ( ! qdict_size ( addr ) ) { \n error_setg ( errp , \" \" ) ; \n goto out ; \n } \n crumpled_addr = qdict_crumple ( addr , errp ) ; \n if ( ! crumpled_addr ) { \n goto out ; \n } \n iv = qobject_input_visitor_new ( crumpled_addr ) ; \n visit_type_NFSServer ( iv , NULL , & server , & local_error ) ; \n if ( local_error ) { \n error_propagate ( errp , local_error ) ; \n goto out ; \n } \n out : \n QDECREF ( addr ) ; \n qobject_decref ( crumpled_addr ) ; \n visit_free ( iv ) ; \n return server ; \n }", "idx": 19666}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfmci ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n gen_helper_rfmci ( cpu_env ) ; \n gen_sync_exception ( ctx ) ; \n #endif \n }", "idx": 19674}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void memory_region_transaction_commit ( void ) \n { \n AddressSpace * as ; \n assert ( memory_region_transaction_depth ) ; \n -- memory_region_transaction_depth ; \n if ( ! memory_region_transaction_depth ) { \n if ( memory_region_update_pending ) { \n MEMORY_LISTENER_CALL_GLOBAL ( begin , Forward ) ; \n QTAILQ_FOREACH ( as , & address_spaces , address_spaces_link )  { \n address_space_update_topology ( as ) ; \n } \n MEMORY_LISTENER_CALL_GLOBAL ( commit , Forward ) ; \n } else if ( ioeventfd_update_pending ) { \n QTAILQ_FOREACH ( as , & address_spaces , address_spaces_link )  { \n address_space_update_ioeventfds ( as ) ; \n } \n } \n memory_region_clear_pending ( ) ; \n } \n }", "idx": 19689}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t block_save_pending ( QEMUFile * f , void * opaque , uint64_t max_size ) \n { \n uint64_t pending ; \n qemu_mutex_lock_iothread ( ) ; \n blk_mig_lock ( ) ; \n pending = get_remaining_dirty ( ) + \n block_mig_state . submitted * BLOCK_SIZE + \n block_mig_state . read_done * BLOCK_SIZE ; \n if ( pending == 0 && ! block_mig_state . bulk_completed ) { \n pending = BLOCK_SIZE ; \n } \n blk_mig_unlock ( ) ; \n qemu_mutex_unlock_iothread ( ) ; \n DPRINTF ( \" \" PRIu64 \" \\n \" , pending ) ; \n return pending ; \n }", "idx": 19707}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( cmpli ) \n { \n if ( T0 < PARAM ( 1 ) ) { \n T0 = 0x08 ; \n } else if ( T0 > PARAM ( 1 ) ) { \n T0 = 0x04 ; \n } else { \n T0 = 0x02 ; \n } \n RETURN ( ) ; \n }", "idx": 19712}
{"project": "qemu", "commit_id": "14b6160099f0caf5dc9d62e637b007bc5d719a96", "target": 1, "func": "bool qdict_get_try_bool ( const QDict * qdict , const char * key , bool def_value ) \n { \n QObject * obj ; \n obj = qdict_get ( qdict , key ) ; \n if ( ! obj || qobject_type ( obj ) != QTYPE_QBOOL ) \n return def_value ; \n return qbool_get_bool ( qobject_to_qbool ( obj ) ) ; \n }", "idx": 19734}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void qemu_rdma_dump_id ( const char * who , struct ibv_context * verbs ) \n { \n struct ibv_port_attr port ; \n if ( ibv_query_port ( verbs , 1 , & port ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n return ; \n } \n printf ( \" \" \n \" \" \n \" \" \n \" \" \n \" \\n \" , \n who , \n verbs -> device -> name , \n verbs -> device -> dev_name , \n verbs -> device -> dev_path , \n verbs -> device -> ibdev_path , \n port . link_layer , \n ( port . link_layer == IBV_LINK_LAYER_INFINIBAND ) ? \" \" : \n ( ( port . link_layer == IBV_LINK_LAYER_ETHERNET ) \n ? \" \" : \" \" ) ) ; \n }", "idx": 19748}
{"project": "qemu", "commit_id": "5f758366c0710d23e43f4d0f83816b98616a13d0", "target": 1, "func": "static CharDriverState * qmp_chardev_open_serial ( ChardevHostdev * serial , \n Error * * errp ) \n { \n #ifdef HAVE_CHARDEV_TTY \n int fd ; \n fd = qmp_chardev_open_file_source ( serial -> device , O_RDWR , errp ) ; \n if ( error_is_set ( errp ) ) { \n return NULL ; \n } \n qemu_set_nonblock ( fd ) ; \n return qemu_chr_open_tty_fd ( fd ) ; \n #else \n error_setg ( errp , \" \" ) ; \n return NULL ; \n #endif \n }", "idx": 19766}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mul ( DisasContext * dc , TCGv dest , TCGv srca , TCGv srcb ) \n { \n TCGv sr_ov = tcg_temp_new ( ) ; \n TCGv t0 = tcg_temp_new ( ) ; \n tcg_gen_muls2_tl ( dest , sr_ov , srca , srcb ) ; \n tcg_gen_sari_tl ( t0 , dest , TARGET_LONG_BITS - 1 ) ; \n tcg_gen_setcond_tl ( TCG_COND_NE , sr_ov , sr_ov , t0 ) ; \n tcg_temp_free ( t0 ) ; \n tcg_gen_deposit_tl ( cpu_sr , cpu_sr , sr_ov , ctz32 ( SR_OV ) , 1 ) ; \n gen_ove_ov ( dc , sr_ov ) ; \n tcg_temp_free ( sr_ov ) ; \n }", "idx": 19785}
{"project": "qemu", "commit_id": "9a94ee5bb15793ef69692998ef57794a33074134", "target": 1, "func": "static void rtas_start_cpu ( PowerPCCPU * cpu_ , sPAPRMachineState * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n target_ulong id , start , r3 ; \n PowerPCCPU * cpu ; \n if ( nargs != 3 || nret != 1 ) { \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n return ; \n } \n id = rtas_ld ( args , 0 ) ; \n start = rtas_ld ( args , 1 ) ; \n r3 = rtas_ld ( args , 2 ) ; \n cpu = spapr_find_cpu ( id ) ; \n if ( cpu != NULL ) { \n CPUState * cs = CPU ( cpu ) ; \n CPUPPCState * env = & cpu -> env ; \n PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; \n if ( ! cs -> halted ) { \n rtas_st ( rets , 0 , RTAS_OUT_HW_ERROR ) ; \n return ; \n } \n kvm_cpu_synchronize_state ( cs ) ; \n env -> msr = ( 1ULL << MSR_SF ) | ( 1ULL << MSR_ME ) ; \n env -> nip = start ; \n env -> gpr [ 3 ] = r3 ; \n cs -> halted = 0 ; \n spapr_cpu_set_endianness ( cpu ) ; \n spapr_cpu_update_tb_offset ( cpu ) ; \n qemu_cpu_kick ( cs ) ; \n rtas_st ( rets , 0 , RTAS_OUT_SUCCESS ) ; \n return ; \n } \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n }", "idx": 19791}
{"project": "qemu", "commit_id": "f68ec8379e88502b4841a110c070e9b118d3151c", "target": 1, "func": "void ide_flush_cache ( IDEState * s ) \n { \n if ( s -> bs == NULL ) { \n ide_flush_cb ( s , 0 ) ; \n return ; \n } \n bdrv_acct_start ( s -> bs , & s -> acct , 0 , BDRV_ACCT_FLUSH ) ; \n bdrv_aio_flush ( s -> bs , ide_flush_cb , s ) ; \n }", "idx": 19823}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_unplug_child ( HotplugHandler * plug_handler , \n DeviceState * plugged_dev , Error * * errp ) \n { \n sPAPRPHBState * phb = SPAPR_PCI_HOST_BRIDGE ( DEVICE ( plug_handler ) ) ; \n PCIDevice * pdev = PCI_DEVICE ( plugged_dev ) ; \n sPAPRDRConnectorClass * drck ; \n sPAPRDRConnector * drc = spapr_phb_get_pci_drc ( phb , pdev ) ; \n Error * local_err = NULL ; \n if ( ! phb -> dr_enabled ) { \n error_setg ( errp , QERR_BUS_NO_HOTPLUG , \n object_get_typename ( OBJECT ( phb ) ) ) ; \n return ; \n } \n g_assert ( drc ) ; \n drck = SPAPR_DR_CONNECTOR_GET_CLASS ( drc ) ; \n if ( ! drck -> release_pending ( drc ) ) { \n spapr_phb_remove_pci_device ( drc , phb , pdev , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n spapr_hotplug_req_remove_by_index ( drc ) ; \n } \n }", "idx": 19825}
{"project": "qemu", "commit_id": "908bcd540f489f7adf2d804347905b0025d808d3", "target": 1, "func": "int bdrv_check ( BlockDriverState * bs , BdrvCheckResult * res , BdrvCheckMode fix ) \n { \n if ( bs -> drv -> bdrv_check == NULL ) { \n return - ENOTSUP ; \n memset ( res , 0 , sizeof ( * res ) ) ; \n return bs -> drv -> bdrv_check ( bs , res , fix ) ;", "idx": 19833}
{"project": "qemu", "commit_id": "8a93e519f32c40ebc41503fd18607dcaef1ddf7a", "target": 1, "func": "static void map_linear_vram ( CirrusVGAState * s ) \n { \n if ( ! s -> map_addr && s -> lfb_addr && s -> lfb_end ) { \n s -> map_addr = s -> lfb_addr ; \n s -> map_end = s -> lfb_end ; \n cpu_register_physical_memory ( s -> map_addr , s -> map_end - s -> map_addr , s -> vram_offset ) ; \n } \n if ( ! s -> map_addr ) \n return ; \n s -> lfb_vram_mapped = 0 ; \n if ( ! ( s -> cirrus_srcptr != s -> cirrus_srcptr_end ) \n && ! ( ( s -> sr [ 0x07 ] & 0x01 ) == 0 ) \n && ! ( ( s -> gr [ 0x0B ] & 0x14 ) == 0x14 ) \n && ! ( s -> gr [ 0x0B ] & 0x02 ) ) { \n ( s -> vram_offset + s -> cirrus_bank_base [ 0 ] ) | IO_MEM_RAM ) ; \n ( s -> vram_offset + s -> cirrus_bank_base [ 1 ] ) | IO_MEM_RAM ) ; \n s -> lfb_vram_mapped = 1 ; \n } \n else { \n cpu_register_physical_memory ( isa_mem_base + 0xa0000 , 0x20000 , \n s -> vga_io_memory ) ; \n } \n vga_dirty_log_start ( ( VGAState * ) s ) ; \n }", "idx": 19835}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_request ( ADBDevice * d , uint8_t * obuf , \n const uint8_t * buf , int len ) \n { \n KBDState * s = ADB_KEYBOARD ( d ) ; \n int cmd , reg , olen ; \n if ( ( buf [ 0 ] & 0x0f ) == ADB_FLUSH ) { \n s -> wptr = s -> rptr = s -> count = 0 ; \n return 0 ; \n } \n cmd = buf [ 0 ] & 0xc ; \n reg = buf [ 0 ] & 0x3 ; \n olen = 0 ; \n switch ( cmd ) { \n case ADB_WRITEREG : \n switch ( reg ) { \n case 2 : \n break ; \n case 3 : \n switch ( buf [ 2 ] ) { \n case ADB_CMD_SELF_TEST : \n break ; \n case ADB_CMD_CHANGE_ID : \n case ADB_CMD_CHANGE_ID_AND_ACT : \n case ADB_CMD_CHANGE_ID_AND_ENABLE : \n d -> devaddr = buf [ 1 ] & 0xf ; \n break ; \n default : \n d -> devaddr = buf [ 1 ] & 0xf ; \n if ( buf [ 2 ] == 1 || buf [ 2 ] == 2 || buf [ 2 ] == 3 ) { \n d -> handler = buf [ 2 ] ; \n } \n break ; \n } \n } \n break ; \n case ADB_READREG : \n switch ( reg ) { \n case 0 : \n olen = adb_kbd_poll ( d , obuf ) ; \n break ; \n case 1 : \n break ; \n case 2 : \n obuf [ 0 ] = 0x00 ; \n obuf [ 1 ] = 0x07 ; \n olen = 2 ; \n break ; \n case 3 : \n obuf [ 0 ] = d -> handler ; \n obuf [ 1 ] = d -> devaddr ; \n olen = 2 ; \n break ; \n } \n break ; \n } \n return olen ; \n }", "idx": 19907}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int cdrom_open ( BlockDriverState * bs , QDict * options , int flags , \n Error * * errp ) \n { \n BDRVRawState * s = bs -> opaque ; \n int ret ; \n s -> type = FTYPE_CD ; \n ret = raw_open_common ( bs , options , flags , O_NONBLOCK , errp ) ; \n return ret ; \n }", "idx": 19932}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void imx_serial_create ( int uart , const target_phys_addr_t addr , qemu_irq irq ) \n { \n DeviceState * dev ; \n SysBusDevice * bus ; \n CharDriverState * chr ; \n const char chr_name [ ] = \" \" ; \n char label [ ARRAY_SIZE ( chr_name ) + 1 ] ; \n dev = qdev_create ( NULL , \" \" ) ; \n if ( uart >= MAX_SERIAL_PORTS ) { \n hw_error ( \" \\n \" , \n uart , MAX_SERIAL_PORTS ) ; \n } \n chr = serial_hds [ uart ] ; \n if ( ! chr ) { \n snprintf ( label , ARRAY_SIZE ( label ) , \" \" , chr_name , uart ) ; \n chr = qemu_chr_new ( label , \" \" , NULL ) ; \n if ( ! ( chr ) ) { \n hw_error ( \" \\n \" , uart ) ; \n } \n } \n qdev_prop_set_chr ( dev , \" \" , chr ) ; \n bus = sysbus_from_qdev ( dev ) ; \n qdev_init_nofail ( dev ) ; \n if ( addr != ( target_phys_addr_t ) - 1 ) { \n sysbus_mmio_map ( bus , 0 , addr ) ; \n } \n sysbus_connect_irq ( bus , 0 , irq ) ; \n }", "idx": 19933}
{"project": "qemu", "commit_id": "d07cc1f12d8e15c167857852c39190d770763824", "target": 0, "func": "static KVMMSIRoute * kvm_lookup_msi_route ( KVMState * s , MSIMessage msg ) \n { \n unsigned int hash = kvm_hash_msi ( msg . data ) ; \n KVMMSIRoute * route ; \n QTAILQ_FOREACH ( route , & s -> msi_hashtab [ hash ] , entry )  { \n if ( route -> kroute . u . msi . address_lo == ( uint32_t ) msg . address && \n route -> kroute . u . msi . address_hi == ( msg . address >> 32 ) && \n route -> kroute . u . msi . data == msg . data ) { \n return route ; \n } \n } \n return NULL ; \n }", "idx": 19935}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static int pxb_bus_num ( PCIBus * bus ) \n { \n PXBDev * pxb = PXB_DEV ( bus -> parent_dev ) ; \n return pxb -> bus_nr ; \n }", "idx": 19949}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_user ( DisasContext * dc ) \n { \n LOG_DIS ( \" \" ) ; \n cpu_abort ( dc -> env , \" \\n \" ) ; \n }", "idx": 19963}
{"project": "qemu", "commit_id": "4cc2cc085586cdb787a24d78a7ba032fa657275a", "target": 1, "func": "target_ulong helper_load_slb_esid ( CPUPPCState * env , target_ulong rb ) \n { \n target_ulong rt ; \n if ( ppc_load_slb_esid ( env , rb , & rt ) < 0 ) { \n helper_raise_exception_err ( env , POWERPC_EXCP_PROGRAM , \n POWERPC_EXCP_INVAL ) ; \n } \n return rt ; \n }", "idx": 19970}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "void hmp_pci_del ( Monitor * mon , const QDict * qdict ) \n { \n pci_device_hot_remove ( mon , qdict_get_str ( qdict , \" \" ) ) ; \n }", "idx": 19991}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "QEMUPutMouseEntry * qemu_add_mouse_event_handler ( QEMUPutMouseEvent * func , \n void * opaque , int absolute , \n const char * name ) \n { \n QEMUPutMouseEntry * s ; \n s = g_malloc0 ( sizeof ( QEMUPutMouseEntry ) ) ; \n s -> qemu_put_mouse_event = func ; \n s -> qemu_put_mouse_event_opaque = opaque ; \n s -> qemu_put_mouse_event_absolute = absolute ; \n s -> h . name = name ; \n s -> h . mask = INPUT_EVENT_MASK_BTN | \n ( absolute ? INPUT_EVENT_MASK_ABS : INPUT_EVENT_MASK_REL ) ; \n s -> h . event = legacy_mouse_event ; \n s -> h . sync = legacy_mouse_sync ; \n s -> s = qemu_input_handler_register ( ( DeviceState * ) s , \n & s -> h ) ; \n return s ; \n }", "idx": 19993}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_add ( DisasContext * dc , TCGv dest , TCGv srca , TCGv srcb ) \n { \n TCGv t0 = tcg_const_tl ( 0 ) ; \n TCGv res = tcg_temp_new ( ) ; \n TCGv sr_cy = tcg_temp_new ( ) ; \n TCGv sr_ov = tcg_temp_new ( ) ; \n tcg_gen_add2_tl ( res , sr_cy , srca , t0 , srcb , t0 ) ; \n tcg_gen_xor_tl ( sr_ov , srca , srcb ) ; \n tcg_gen_xor_tl ( t0 , res , srcb ) ; \n tcg_gen_andc_tl ( sr_ov , t0 , sr_ov ) ; \n tcg_temp_free ( t0 ) ; \n tcg_gen_mov_tl ( dest , res ) ; \n tcg_temp_free ( res ) ; \n tcg_gen_shri_tl ( sr_ov , sr_ov , TARGET_LONG_BITS - 1 ) ; \n tcg_gen_deposit_tl ( cpu_sr , cpu_sr , sr_cy , ctz32 ( SR_CY ) , 1 ) ; \n tcg_gen_deposit_tl ( cpu_sr , cpu_sr , sr_ov , ctz32 ( SR_OV ) , 1 ) ; \n gen_ove_cyov ( dc , sr_ov , sr_cy ) ; \n tcg_temp_free ( sr_ov ) ; \n tcg_temp_free ( sr_cy ) ; \n }", "idx": 20009}
{"project": "qemu", "commit_id": "576c6eb6700d241c9d4a6883d25720c7bbaaeccd", "target": 1, "func": "int tap_open ( char * ifname , int ifname_size , int * vnet_hdr , \n int vnet_hdr_required , int mq_required , Error * * errp ) \n { \n char dev [ 10 ] = \" \" ; \n int fd ; \n if ( ( fd = tap_alloc ( dev , sizeof ( dev ) ) ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n pstrcpy ( ifname , ifname_size , dev ) ; \n if ( * vnet_hdr ) { \n * vnet_hdr = 0 ; \n if ( vnet_hdr_required && ! * vnet_hdr ) { \n error_report ( \" \" \n \" \" ) ; \n close ( fd ) ; \n return -1 ; \n } \n } \n fcntl ( fd , F_SETFL , O_NONBLOCK ) ; \n return fd ; \n }", "idx": 20036}
{"project": "qemu", "commit_id": "16a9e8a5bcc1fb0796828eb654a4f926734e59af", "target": 0, "func": "static void pc_dimm_plug ( HotplugHandler * hotplug_dev , \n DeviceState * dev , Error * * errp ) \n { \n HotplugHandlerClass * hhc ; \n Error * local_err = NULL ; \n PCMachineState * pcms = PC_MACHINE ( hotplug_dev ) ; \n PCDIMMDevice * dimm = PC_DIMM ( dev ) ; \n PCDIMMDeviceClass * ddc = PC_DIMM_GET_CLASS ( dimm ) ; \n MemoryRegion * mr = ddc -> get_memory_region ( dimm ) ; \n uint64_t align = TARGET_PAGE_SIZE ; \n if ( memory_region_get_alignment ( mr ) && pcms -> enforce_aligned_dimm ) { \n align = memory_region_get_alignment ( mr ) ; \n } \n if ( ! pcms -> acpi_dev ) { \n error_setg ( & local_err , \n \" \" ) ; \n goto out ; \n } \n pc_dimm_memory_plug ( dev , & pcms -> hotplug_memory , mr , align , & local_err ) ; \n if ( local_err ) { \n goto out ; \n } \n hhc = HOTPLUG_HANDLER_GET_CLASS ( pcms -> acpi_dev ) ; \n hhc -> plug ( HOTPLUG_HANDLER ( pcms -> acpi_dev ) , dev , & error_abort ) ; \n out : \n error_propagate ( errp , local_err ) ; \n }", "idx": 20060}
{"project": "qemu", "commit_id": "7a2c4b82340d621bff462672b29c88d2020d68c1", "target": 0, "func": "static void cmd_test_unit_ready ( IDEState * s , uint8_t * buf ) \n { \n if ( bdrv_is_inserted ( s -> bs ) ) { \n ide_atapi_cmd_ok ( s ) ; \n } else { \n ide_atapi_cmd_error ( s , SENSE_NOT_READY , ASC_MEDIUM_NOT_PRESENT ) ; \n } \n }", "idx": 20064}
{"project": "qemu", "commit_id": "2b147555f78c3c20080b201fd1506467fa0ddf43", "target": 0, "func": "static int kvm_s390_check_enable_cmma ( KVMState * s ) \n { \n struct kvm_device_attr attr = { \n . group = KVM_S390_VM_MEM_CTRL , \n . attr = KVM_S390_VM_MEM_ENABLE_CMMA , \n } ; \n return kvm_vm_ioctl ( s , KVM_HAS_DEVICE_ATTR , & attr ) ; \n }", "idx": 20068}
{"project": "qemu", "commit_id": "84007e81814bd1b523eb36b027ef8a84d7f00206", "target": 0, "func": "static int net_host_check_device ( const char * device ) \n { \n int i ; \n const char * valid_param_list [ ] = { \" \" , \" \" , \" \" \n #ifdef CONFIG_NET_BRIDGE \n , \" \" \n #endif \n #ifdef CONFIG_SLIRP \n , \" \" \n #endif \n #ifdef CONFIG_VDE \n , \" \" \n #endif \n } ; \n for ( i = 0 ; i < ARRAY_SIZE ( valid_param_list ) ; i ++ ) { \n if ( ! strncmp ( valid_param_list [ i ] , device , \n strlen ( valid_param_list [ i ] ) ) ) \n return 1 ; \n } \n return 0 ; \n }", "idx": 20098}
{"project": "qemu", "commit_id": "5029fe12dccbe261d5bd5bc840110ae48aa112c9", "target": 0, "func": "uint32_t pci_default_read_config ( PCIDevice * d , \n uint32_t address , int len ) \n { \n uint32_t val ; \n switch ( len ) { \n default : \n case 4 : \n if ( address <= 0xfc ) { \n val = pci_get_long ( d -> config + address ) ; \n break ; \n } \n case 2 : \n if ( address <= 0xfe ) { \n val = pci_get_word ( d -> config + address ) ; \n break ; \n } \n case 1 : \n val = pci_get_byte ( d -> config + address ) ; \n break ; \n } \n return val ; \n }", "idx": 20106}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void l2x0_class_init ( ObjectClass * klass , void * data ) \n { \n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ; \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n k -> init = l2x0_priv_init ; \n dc -> vmsd = & vmstate_l2x0 ; \n dc -> no_user = 1 ; \n dc -> props = l2x0_properties ; \n dc -> reset = l2x0_priv_reset ; \n }", "idx": 20130}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char * bdrv_get_format_name ( BlockDriverState * bs ) \n { \n return bs -> drv ? bs -> drv -> format_name : NULL ; \n }", "idx": 20144}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_migration_done ( struct vhost_dev * dev , char * mac_addr ) \n { \n VhostUserMsg msg = { 0 } ; \n int err ; \n assert ( dev -> vhost_ops -> backend_type == VHOST_BACKEND_TYPE_USER ) ; \n if ( virtio_has_feature ( dev -> acked_features , VIRTIO_NET_F_GUEST_ANNOUNCE ) ) { \n return 0 ; \n } \n if ( virtio_has_feature ( dev -> protocol_features , \n VHOST_USER_PROTOCOL_F_RARP ) ) { \n msg . request = VHOST_USER_SEND_RARP ; \n msg . flags = VHOST_USER_VERSION ; \n memcpy ( ( char * ) & msg . u64 , mac_addr , 6 ) ; \n msg . size = sizeof ( m . u64 ) ; \n err = vhost_user_write ( dev , & msg , NULL , 0 ) ; \n return err ; \n } \n return -1 ; \n }", "idx": 20183}
{"project": "qemu", "commit_id": "2ee4aed86ff2ba38a0e1846de18a9aec38d73015", "target": 0, "func": "void do_tlbwr ( void ) \n { \n int r = cpu_mips_get_random ( env ) ; \n invalidate_tlb ( r , 1 ) ; \n fill_tlb ( r ) ; \n }", "idx": 20204}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static void raw_close ( BlockDriverState * bs ) \n { \n }", "idx": 20214}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_interrupt ( DisasContext * s , int intno , \n target_ulong cur_eip , target_ulong next_eip ) \n { \n gen_update_cc_op ( s ) ; \n gen_jmp_im ( cur_eip ) ; \n gen_helper_raise_interrupt ( cpu_env , tcg_const_i32 ( intno ) , \n tcg_const_i32 ( next_eip - cur_eip ) ) ; \n s -> is_jmp = DISAS_TB_JUMP ; \n }", "idx": 20222}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static uint32_t platform_mmio_read ( ReadWriteHandler * handler , pcibus_t addr , int len ) \n { \n DPRINTF ( \" \" \n \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n return 0 ; \n }", "idx": 20240}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sparc_handle_mmu_fault ( CPUState * env , target_ulong address , int rw , \n int mmu_idx , int is_softmmu ) \n { \n target_ulong virt_addr , vaddr ; \n target_phys_addr_t paddr ; \n int error_code = 0 , prot , ret = 0 , access_index ; \n error_code = get_physical_address ( env , & paddr , & prot , & access_index , \n address , rw , mmu_idx ) ; \n if ( error_code == 0 ) { \n virt_addr = address & TARGET_PAGE_MASK ; \n vaddr = virt_addr + ( ( address & TARGET_PAGE_MASK ) & \n ( TARGET_PAGE_SIZE - 1 ) ) ; \n #ifdef DEBUG_MMU \n printf ( \" \" PRIx64 \" \" PRIx64 \" \" PRIx64 \n \" \\n \" , address , paddr , vaddr ) ; \n #endif \n ret = tlb_set_page_exec ( env , vaddr , paddr , prot , mmu_idx , is_softmmu ) ; \n return ret ; \n } \n return 1 ; \n }", "idx": 20241}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static int htab_save_setup ( QEMUFile * f , void * opaque ) \n { \n sPAPRMachineState * spapr = opaque ; \n qemu_put_be32 ( f , spapr -> htab_shift ) ; \n if ( spapr -> htab ) { \n spapr -> htab_save_index = 0 ; \n spapr -> htab_first_pass = true ; \n } else { \n assert ( kvm_enabled ( ) ) ; \n spapr -> htab_fd = kvmppc_get_htab_fd ( false ) ; \n spapr -> htab_fd_stale = false ; \n if ( spapr -> htab_fd < 0 ) { \n fprintf ( stderr , \" \\n \" , \n strerror ( errno ) ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 20366}
{"project": "qemu", "commit_id": "79ca616f291124d166ca173e512c4ace1c2fe8b2", "target": 0, "func": "int pci_drive_hot_add ( Monitor * mon , const QDict * qdict , DriveInfo * dinfo ) \n { \n int dom , pci_bus ; \n unsigned slot ; \n PCIDevice * dev ; \n const char * pci_addr = qdict_get_str ( qdict , \" \" ) ; \n switch ( dinfo -> type ) { \n case IF_SCSI : \n if ( pci_read_devaddr ( mon , pci_addr , & dom , & pci_bus , & slot ) ) { \n goto err ; \n } \n dev = pci_find_device ( pci_find_root_bus ( dom ) , pci_bus , \n PCI_DEVFN ( slot , 0 ) ) ; \n if ( ! dev ) { \n monitor_printf ( mon , \" \\n \" , pci_addr ) ; \n goto err ; \n } \n if ( scsi_hot_add ( mon , & dev -> qdev , dinfo , 1 ) != 0 ) { \n goto err ; \n } \n break ; \n default : \n monitor_printf ( mon , \" \\n \" , dinfo -> type ) ; \n goto err ; \n } \n return 0 ; \n err : \n return -1 ; \n }", "idx": 20367}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "void cpu_loop ( CPUSH4State * env ) \n { \n CPUState * cs = CPU ( sh_env_get_cpu ( env ) ) ; \n int trapnr , ret ; \n target_siginfo_t info ; \n while ( 1 ) { \n cpu_exec_start ( cs ) ; \n trapnr = cpu_sh4_exec ( cs ) ; \n cpu_exec_end ( cs ) ; \n switch ( trapnr ) { \n case 0x160 : \n env -> pc += 2 ; \n ret = do_syscall ( env , \n env -> gregs [ 3 ] , \n env -> gregs [ 4 ] , \n env -> gregs [ 5 ] , \n env -> gregs [ 6 ] , \n env -> gregs [ 7 ] , \n env -> gregs [ 0 ] , \n env -> gregs [ 1 ] , \n 0 , 0 ) ; \n env -> gregs [ 0 ] = ret ; \n break ; \n case EXCP_INTERRUPT : \n break ; \n case EXCP_DEBUG : \n { \n int sig ; \n sig = gdb_handlesig ( cs , TARGET_SIGTRAP ) ; \n if ( sig ) \n { \n info . si_signo = sig ; \n info . si_errno = 0 ; \n info . si_code = TARGET_TRAP_BRKPT ; \n queue_signal ( env , info . si_signo , & info ) ; \n } \n } \n break ; \n case 0xa0 : \n case 0xc0 : \n info . si_signo = TARGET_SIGSEGV ; \n info . si_errno = 0 ; \n info . si_code = TARGET_SEGV_MAPERR ; \n info . _sifields . _sigfault . _addr = env -> tea ; \n queue_signal ( env , info . si_signo , & info ) ; \n break ; \n default : \n printf ( \" \\n \" , trapnr ) ; \n cpu_dump_state ( cs , stderr , fprintf , 0 ) ; \n exit ( EXIT_FAILURE ) ; \n } \n process_pending_signals ( env ) ; \n } \n }", "idx": 20395}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps ( int fccno , TCGv r_rs1 , TCGv r_rs2 ) \n { \n gen_helper_fcmps ( cpu_env , r_rs1 , r_rs2 ) ; \n }", "idx": 20402}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void set_sigp_status ( SigpInfo * si , uint64_t status ) \n { \n * si -> status_reg &= 0xffffffff00000000ULL ; \n * si -> status_reg |= status ; \n si -> cc = SIGP_CC_STATUS_STORED ; \n }", "idx": 20403}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static VirtIOSCSIReq * virtio_scsi_pop_req ( VirtIOSCSI * s , VirtQueue * vq ) \n { \n VirtIOSCSIReq * req ; \n req = g_malloc ( sizeof ( * req ) ) ; \n if ( ! virtqueue_pop ( vq , & req -> elem ) ) { \n g_free ( req ) ; \n return NULL ; \n } \n virtio_scsi_parse_req ( s , vq , req ) ; \n return req ; \n }", "idx": 20407}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void OPPROTO op_divb_AL_T0 ( void ) \n { \n unsigned int num , den , q , r ; \n num = ( EAX & 0xffff ) ; \n den = ( T0 & 0xff ) ; \n if ( den == 0 ) { \n raise_exception ( EXCP00_DIVZ ) ; \n } \n q = ( num / den ) & 0xff ; \n r = ( num % den ) & 0xff ; \n EAX = ( EAX & ~ 0xffff ) | ( r << 8 ) | q ; \n }", "idx": 20417}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bgu ( TCGv dst , TCGv_i32 src ) \n { \n gen_mov_reg_Z ( cpu_tmp0 , src ) ; \n gen_mov_reg_C ( dst , src ) ; \n tcg_gen_or_tl ( dst , dst , cpu_tmp0 ) ; \n tcg_gen_xori_tl ( dst , dst , 0x1 ) ; \n }", "idx": 20436}
{"project": "qemu", "commit_id": "ab06ec43577177a442e8e5ca28d0154efe4ff60f", "target": 0, "func": "static void test_pxe_virtio_pci ( void ) \n { \n test_pxe_one ( \" \" NETNAME , false ) ; \n }", "idx": 20444}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_add_data_offset ( DisasContext * s , unsigned int insn , \n TCGv var ) \n { \n int val , rm , shift , shiftop ; \n TCGv offset ; \n if ( ! ( insn & ( 1 << 25 ) ) ) { \n val = insn & 0xfff ; \n if ( ! ( insn & ( 1 << 23 ) ) ) \n val = - val ; \n if ( val != 0 ) \n tcg_gen_addi_i32 ( var , var , val ) ; \n } else { \n rm = ( insn ) & 0xf ; \n shift = ( insn >> 7 ) & 0x1f ; \n shiftop = ( insn >> 5 ) & 3 ; \n offset = load_reg ( s , rm ) ; \n gen_arm_shift_im ( offset , shiftop , shift , 0 ) ; \n if ( ! ( insn & ( 1 << 23 ) ) ) \n tcg_gen_sub_i32 ( var , var , offset ) ; \n else \n tcg_gen_add_i32 ( var , var , offset ) ; \n dead_tmp ( offset ) ; \n } \n }", "idx": 20478}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int count_contiguous_clusters ( int nb_clusters , int cluster_size , \n uint64_t * l2_table , uint64_t stop_flags ) \n { \n int i ; \n QCow2ClusterType first_cluster_type ; \n uint64_t mask = stop_flags | L2E_OFFSET_MASK | QCOW_OFLAG_COMPRESSED ; \n uint64_t first_entry = be64_to_cpu ( l2_table [ 0 ] ) ; \n uint64_t offset = first_entry & mask ; \n if ( ! offset ) { \n return 0 ; \n } \n first_cluster_type = qcow2_get_cluster_type ( first_entry ) ; \n assert ( first_cluster_type == QCOW2_CLUSTER_NORMAL || \n ( first_cluster_type == QCOW2_CLUSTER_ZERO && \n ( first_entry & L2E_OFFSET_MASK ) != 0 ) ) ; \n for ( i = 0 ; i < nb_clusters ; i ++ ) { \n uint64_t l2_entry = be64_to_cpu ( l2_table [ i ] ) & mask ; \n if ( offset + ( uint64_t ) i * cluster_size != l2_entry ) { \n break ; \n } \n } \n return i ; \n }", "idx": 20497}
{"project": "qemu", "commit_id": "d20423788e3a3d5f6a2aad8315779bf3f952ca36", "target": 0, "func": "static inline int name_to_handle ( int dirfd , const char * name , \n struct file_handle * fh , int * mnt_id , int flags ) \n { \n return syscall ( __NR_name_to_handle_at , dirfd , name , fh , mnt_id , flags ) ; \n }", "idx": 20530}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "static void generate_bootsect ( uint32_t gpr [ 8 ] , uint16_t segs [ 6 ] , uint16_t ip ) \n { \n uint8_t bootsect [ 512 ] , * p ; \n int i ; \n int hda ; \n hda = drive_get_index ( IF_IDE , 0 , 0 ) ; \n if ( hda == -1 ) { \n fprintf ( stderr , \" \" \n \" \\n \\n \" ) ; \n exit ( 1 ) ; \n } \n memset ( bootsect , 0 , sizeof ( bootsect ) ) ; \n bdrv_read ( drives_table [ hda ] . bdrv , 0 , bootsect , 1 ) ; \n bootsect [ 510 ] = 0x55 ; \n bootsect [ 511 ] = 0xaa ; \n p = bootsect ; \n * p ++ = 0xfa ; \n * p ++ = 0xfc ; \n for ( i = 0 ; i < 6 ; i ++ ) { \n if ( i == 1 ) \n continue ; \n * p ++ = 0xb8 ; \n * p ++ = segs [ i ] ; \n * p ++ = segs [ i ] >> 8 ; \n * p ++ = 0x8e ; \n * p ++ = 0xc0 + ( i << 3 ) ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n * p ++ = 0x66 ; \n * p ++ = 0xb8 + i ; \n * p ++ = gpr [ i ] ; \n * p ++ = gpr [ i ] >> 8 ; \n * p ++ = gpr [ i ] >> 16 ; \n * p ++ = gpr [ i ] >> 24 ; \n } \n * p ++ = 0xea ; \n * p ++ = ip ; \n * p ++ = ip >> 8 ; \n * p ++ = segs [ 1 ] ; \n * p ++ = segs [ 1 ] >> 8 ; \n bdrv_set_boot_sector ( drives_table [ hda ] . bdrv , bootsect , sizeof ( bootsect ) ) ; \n }", "idx": 20532}
{"project": "qemu", "commit_id": "e04fb07fd1676e9facd7f3f878c1bbe03bccd26b", "target": 1, "func": "static void qemu_rbd_aio_event_reader ( void * opaque ) \n { \n BDRVRBDState * s = opaque ; \n ssize_t ret ; \n do { \n char * p = ( char * ) & s -> event_rcb ; \n ret = read ( s -> fds [ RBD_FD_READ ] , p + s -> event_reader_pos , \n sizeof ( s -> event_rcb ) - s -> event_reader_pos ) ; \n if ( ret > 0 ) { \n s -> event_reader_pos += ret ; \n if ( s -> event_reader_pos == sizeof ( s -> event_rcb ) ) { \n s -> event_reader_pos = 0 ; \n qemu_rbd_complete_aio ( s -> event_rcb ) ; \n } \n } \n } while ( ret < 0 && errno == EINTR ) ; \n }", "idx": 20657}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_wsr_windowbase ( DisasContext * dc , uint32_t sr , TCGv_i32 v ) \n { \n gen_helper_wsr_windowbase ( cpu_env , v ) ; \n reset_used_window ( dc ) ; \n }", "idx": 20676}
{"project": "qemu", "commit_id": "06a1307379fcd6c551185ad87679cd7ed896b9ea", "target": 1, "func": "static void virtio_pci_exit ( PCIDevice * pci_dev ) \n { \n VirtIOPCIProxy * proxy = VIRTIO_PCI ( pci_dev ) ; \n virtio_pci_stop_ioeventfd ( proxy ) ; \n memory_region_destroy ( & proxy -> bar ) ; \n msix_uninit_exclusive_bar ( pci_dev ) ; \n }", "idx": 20692}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_stf_asi ( DisasContext * dc , TCGv addr , \n int insn , int size , int rd ) \n { \n TCGv_i32 r_asi , r_size , r_rd ; \n r_asi = gen_get_asi ( dc , insn ) ; \n r_size = tcg_const_i32 ( size ) ; \n r_rd = tcg_const_i32 ( rd ) ; \n gen_helper_stf_asi ( cpu_env , addr , r_asi , r_size , r_rd ) ; \n tcg_temp_free_i32 ( r_rd ) ; \n tcg_temp_free_i32 ( r_size ) ; \n tcg_temp_free_i32 ( r_asi ) ; \n }", "idx": 20726}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int kvm_arch_set_tsc_khz ( CPUState * cs ) \n { \n X86CPU * cpu = X86_CPU ( cs ) ; \n CPUX86State * env = & cpu -> env ; \n int r ; \n if ( ! env -> tsc_khz ) { \n return 0 ; \n } \n r = kvm_check_extension ( cs -> kvm_state , KVM_CAP_TSC_CONTROL ) ? \n kvm_vcpu_ioctl ( cs , KVM_SET_TSC_KHZ , env -> tsc_khz ) : \n - ENOTSUP ; \n if ( r < 0 ) { \n int cur_freq = kvm_check_extension ( cs -> kvm_state , KVM_CAP_GET_TSC_KHZ ) ? \n kvm_vcpu_ioctl ( cs , KVM_GET_TSC_KHZ ) : \n - ENOTSUP ; \n if ( cur_freq <= 0 || cur_freq != env -> tsc_khz ) { \n error_report ( \" \" \n \" \" PRId64 \" \" \n \" \" , \n env -> tsc_khz , cur_freq ) ; \n return r ; \n } \n } \n return 0 ; \n }", "idx": 20744}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "pvscsi_realizefn ( PCIDevice * pci_dev , Error * * errp )  \n { \n PVSCSIState * s = PVSCSI ( pci_dev ) ; \n trace_pvscsi_state ( \" \" ) ; \n if ( PVSCSI_USE_OLD_PCI_CONFIGURATION ( s ) ) { \n pci_set_word ( pci_dev -> config + PCI_SUBSYSTEM_ID , 0x1000 ) ; \n } else { \n pci_set_word ( pci_dev -> config + PCI_SUBSYSTEM_VENDOR_ID , \n PCI_VENDOR_ID_VMWARE ) ; \n pci_set_word ( pci_dev -> config + PCI_SUBSYSTEM_ID , \n PCI_DEVICE_ID_VMWARE_PVSCSI ) ; \n pci_config_set_revision ( pci_dev -> config , 0x2 ) ; \n } \n pci_dev -> config [ PCI_LATENCY_TIMER ] = 0xff ; \n pci_config_set_interrupt_pin ( pci_dev -> config , 1 ) ; \n memory_region_init_io ( & s -> io_space , OBJECT ( s ) , & pvscsi_ops , s , \n \" \" , PVSCSI_MEM_SPACE_SIZE ) ; \n pci_register_bar ( pci_dev , 0 , PCI_BASE_ADDRESS_SPACE_MEMORY , & s -> io_space ) ; \n pvscsi_init_msi ( s ) ; \n if ( pci_is_express ( pci_dev ) && pci_bus_is_express ( pci_dev -> bus ) ) { \n pcie_endpoint_cap_init ( pci_dev , PVSCSI_EXP_EP_OFFSET ) ; \n } \n s -> completion_worker = qemu_bh_new ( pvscsi_process_completion_queue , s ) ; \n scsi_bus_new ( & s -> bus , sizeof ( s -> bus ) , DEVICE ( pci_dev ) , \n & pvscsi_scsi_info , NULL ) ; \n qbus_set_hotplug_handler ( BUS ( & s -> bus ) , DEVICE ( s ) , & error_abort ) ; \n pvscsi_reset_state ( s ) ; \n }", "idx": 20823}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void vde_from_qemu ( void * opaque , const uint8_t * buf , int size ) \n { \n VDEState * s = opaque ; \n int ret ; \n for ( ; ; ) { \n ret = vde_send ( s -> vde , ( const char * ) buf , size , 0 ) ; \n if ( ret < 0 && errno == EINTR ) { \n } else { \n break ; \n } \n } \n }", "idx": 20826}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mipsnet_ioport_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned int size ) \n { \n MIPSnetState * s = opaque ; \n addr &= 0x3f ; \n trace_mipsnet_write ( addr , val ) ; \n switch ( addr ) { \n case MIPSNET_TX_DATA_COUNT : \n s -> tx_count = ( val <= MAX_ETH_FRAME_SIZE ) ? val : 0 ; \n s -> tx_written = 0 ; \n break ; \n case MIPSNET_INT_CTL : \n if ( val & MIPSNET_INTCTL_TXDONE ) { \n s -> intctl &= ~ MIPSNET_INTCTL_TXDONE ; \n } else if ( val & MIPSNET_INTCTL_RXDONE ) { \n s -> intctl &= ~ MIPSNET_INTCTL_RXDONE ; \n } else if ( val & MIPSNET_INTCTL_TESTBIT ) { \n mipsnet_reset ( s ) ; \n s -> intctl |= MIPSNET_INTCTL_TESTBIT ; \n } else if ( ! val ) { \n } \n s -> busy = ! ! s -> intctl ; \n mipsnet_update_irq ( s ) ; \n break ; \n case MIPSNET_TX_DATA_BUFFER : \n s -> tx_buffer [ s -> tx_written ++ ] = val ; \n if ( s -> tx_written == s -> tx_count ) { \n trace_mipsnet_send ( s -> tx_count ) ; \n qemu_send_packet ( & s -> nic -> nc , s -> tx_buffer , s -> tx_count ) ; \n s -> tx_count = s -> tx_written = 0 ; \n s -> intctl |= MIPSNET_INTCTL_TXDONE ; \n s -> busy = 1 ; \n mipsnet_update_irq ( s ) ; \n } \n break ; \n case MIPSNET_DEV_ID : \n case MIPSNET_BUSY : \n case MIPSNET_RX_DATA_COUNT : \n case MIPSNET_INTERRUPT_INFO : \n case MIPSNET_RX_DATA_BUFFER : \n default : \n break ; \n } \n }", "idx": 20895}
{"project": "qemu", "commit_id": "90d131fb6504ed12a37dc8433375cc683c30e9da", "target": 0, "func": "mac_writereg ( E1000State * s , int index , uint32_t val )  \n { \n uint32_t macaddr [ 2 ] ; \n s -> mac_reg [ index ] = val ; \n if ( index == RA || index == RA + 1 ) { \n macaddr [ 0 ] = cpu_to_le32 ( s -> mac_reg [ RA ] ) ; \n macaddr [ 1 ] = cpu_to_le32 ( s -> mac_reg [ RA + 1 ] ) ; \n qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , ( uint8_t * ) macaddr ) ; \n } \n }", "idx": 20898}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_pmcsr_reg_write ( XenPCIPassthroughState * s , \n XenPTReg * cfg_entry , uint16_t * val , \n uint16_t dev_value , uint16_t valid_mask ) \n { \n XenPTRegInfo * reg = cfg_entry -> reg ; \n uint16_t writable_mask = 0 ; \n uint16_t throughable_mask = get_throughable_mask ( s , reg , valid_mask ) ; \n writable_mask = reg -> emu_mask & ~ reg -> ro_mask & valid_mask ; \n cfg_entry -> data = XEN_PT_MERGE_VALUE ( * val , cfg_entry -> data , writable_mask ) ; \n * val = XEN_PT_MERGE_VALUE ( * val , dev_value & ~ PCI_PM_CTRL_PME_STATUS , \n throughable_mask ) ; \n return 0 ; \n }", "idx": 20899}
{"project": "qemu", "commit_id": "c7eb1f02edba91e3eec4682fa1adca877696d11d", "target": 0, "func": "static int net_socket_connect_init ( VLANState * vlan , \n const char * model , \n const char * name , \n const char * host_str ) \n { \n NetSocketState * s ; \n int fd , connected , ret , err ; \n struct sockaddr_in saddr ; \n if ( parse_host_port ( & saddr , host_str ) < 0 ) \n return -1 ; \n fd = qemu_socket ( PF_INET , SOCK_STREAM , 0 ) ; \n if ( fd < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n socket_set_nonblock ( fd ) ; \n connected = 0 ; \n for ( ; ; ) { \n ret = connect ( fd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ; \n if ( ret < 0 ) { \n err = socket_error ( ) ; \n if ( err == EINTR || err == EWOULDBLOCK ) { \n } else if ( err == EINPROGRESS ) { \n break ; \n #ifdef _WIN32  \n } else if ( err == WSAEALREADY ) { \n break ; \n #endif  \n  \n  } else { \n perror ( \" \" ) ; \n closesocket ( fd ) ; \n return -1 ; \n } \n } else { \n connected = 1 ; \n break ; \n } \n } \n s = net_socket_fd_init ( vlan , model , name , fd , connected ) ; \n if ( ! s ) \n return -1 ; \n snprintf ( s -> nc . info_str , sizeof ( s -> nc . info_str ) , \n \" \" , \n inet_ntoa ( saddr . sin_addr ) , ntohs ( saddr . sin_port ) ) ; \n return 0 ; \n }", "idx": 20906}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "static int usb_device_del ( const char * devname ) \n { \n USBPort * port ; \n USBPort * * lastp ; \n USBDevice * dev ; \n int bus_num , addr ; \n const char * p ; \n if ( ! used_usb_ports ) \n return -1 ; \n p = strchr ( devname , ' ' ) ; \n if ( ! p ) \n return -1 ; \n bus_num = strtoul ( devname , NULL , 0 ) ; \n addr = strtoul ( p + 1 , NULL , 0 ) ; \n if ( bus_num != 0 ) \n return -1 ; \n lastp = & used_usb_ports ; \n port = used_usb_ports ; \n while ( port && port -> dev -> addr != addr ) { \n lastp = & port -> next ; \n port = port -> next ; \n } \n if ( ! port ) \n return -1 ; \n dev = port -> dev ; \n * lastp = port -> next ; \n usb_attach ( port , NULL ) ; \n dev -> handle_destroy ( dev ) ; \n port -> next = free_usb_ports ; \n free_usb_ports = port ; \n return 0 ; \n }", "idx": 20910}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int drop_sync ( QIOChannel * ioc , size_t size , Error * * errp ) \n { \n ssize_t ret = 0 ; \n char small [ 1024 ] ; \n char * buffer ; \n buffer = sizeof ( small ) >= size ? small : g_malloc ( MIN ( 65536 , size ) ) ; \n while ( size > 0 ) { \n ssize_t count = MIN ( 65536 , size ) ; \n ret = read_sync ( ioc , buffer , MIN ( 65536 , size ) , errp ) ; \n if ( ret < 0 ) { \n goto cleanup ; \n } \n size -= count ; \n } \n cleanup : \n if ( buffer != small ) { \n g_free ( buffer ) ; \n } \n return ret ; \n }", "idx": 20929}
{"project": "qemu", "commit_id": "b78c2b3aad2b42084265c89f93a92733d68e9003", "target": 0, "func": "static void pl061_update ( pl061_state * s ) \n { \n uint8_t changed ; \n uint8_t mask ; \n uint8_t out ; \n int i ; \n out = ( s -> data & s -> dir ) | ~ s -> dir ; \n changed = s -> old_data ^ out ; \n if ( ! changed ) \n return ; \n s -> old_data = out ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n mask = 1 << i ; \n if ( ( changed & mask ) && s -> out ) { \n DPRINTF ( \" \\n \" , i , ( out & mask ) != 0 ) ; \n qemu_set_irq ( s -> out [ i ] , ( out & mask ) != 0 ) ; \n } \n } \n }", "idx": 20963}
{"project": "qemu", "commit_id": "8d999995e45c1002aa11f269c98f2e93e6f8c42a", "target": 0, "func": "void gic_set_pending_private ( GICState * s , int cpu , int irq ) \n { \n int cm = 1 << cpu ; \n if ( GIC_TEST_PENDING ( irq , cm ) ) \n return ; \n DPRINTF ( \" \\n \" , irq , cpu ) ; \n GIC_SET_PENDING ( irq , cm ) ; \n gic_update ( s ) ; \n }", "idx": 20981}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static uint32_t pxa2xx_pm_read ( void * opaque , target_phys_addr_t addr ) \n { \n struct pxa2xx_state_s * s = ( struct pxa2xx_state_s * ) opaque ; \n if ( addr > s -> pm_base + PCMD31 ) { \n return pxa2xx_i2c_read ( s -> i2c [ 1 ] , addr ) ; \n } \n addr -= s -> pm_base ; \n switch ( addr ) { \n case PMCR . . . PCMD31 : \n if ( addr & 3 ) \n goto fail ; \n return s -> pm_regs [ addr >> 2 ] ; \n default : \n fail : \n printf ( \" \" REG_FMT \" \\n \" , __FUNCTION__ , addr ) ; \n break ; \n } \n return 0 ; \n }", "idx": 20987}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "static void ivshmem_check_memdev_is_busy ( Object * obj , const char * name , \n Object * val , Error * * errp ) \n { \n MemoryRegion * mr ; \n mr = host_memory_backend_get_memory ( MEMORY_BACKEND ( val ) , & error_abort ) ; \n if ( memory_region_is_mapped ( mr ) ) { \n char * path = object_get_canonical_path_component ( val ) ; \n error_setg ( errp , \" \" , path ) ; \n g_free ( path ) ; \n } else { \n qdev_prop_allow_set_link_before_realize ( obj , name , val , errp ) ; \n } \n }", "idx": 20997}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_close ( struct CharDriverState * chr ) \n { \n FDCharDriver * s = chr -> opaque ; \n if ( s -> fd_in_tag ) { \n g_source_remove ( s -> fd_in_tag ) ; \n s -> fd_in_tag = 0 ; \n } \n if ( s -> fd_in ) { \n g_io_channel_unref ( s -> fd_in ) ; \n } \n if ( s -> fd_out ) { \n g_io_channel_unref ( s -> fd_out ) ; \n } \n g_free ( s ) ; \n qemu_chr_be_event ( chr , CHR_EVENT_CLOSED ) ; \n }", "idx": 21008}
{"project": "qemu", "commit_id": "413d463f43fbc4dd3a601e80a5724aa384a265a0", "target": 1, "func": "static void dhcp_decode ( const struct bootp_t * bp , int * pmsg_type , \n struct in_addr * preq_addr ) \n { \n const uint8_t * p , * p_end ; \n int len , tag ; \n * pmsg_type = 0 ; \n preq_addr -> s_addr = htonl ( 0L ) ; \n p = bp -> bp_vend ; \n p_end = p + DHCP_OPT_LEN ; \n if ( memcmp ( p , rfc1533_cookie , 4 ) != 0 ) \n return ; \n p += 4 ; \n while ( p < p_end ) { \n tag = p [ 0 ] ; \n if ( tag == RFC1533_PAD ) { \n p ++ ; \n } else if ( tag == RFC1533_END ) { \n } else { \n p ++ ; \n if ( p >= p_end ) \n len = * p ++ ; \n DPRINTF ( \" \\n \" , tag , len ) ; \n switch ( tag ) { \n case RFC2132_MSG_TYPE : \n if ( len >= 1 ) \n * pmsg_type = p [ 0 ] ; \n case RFC2132_REQ_ADDR : \n if ( len >= 4 ) { \n memcpy ( & ( preq_addr -> s_addr ) , p , 4 ) ; \n default : \n p += len ; \n if ( * pmsg_type == DHCPREQUEST && preq_addr -> s_addr == htonl ( 0L ) && \n bp -> bp_ciaddr . s_addr ) { \n memcpy ( & ( preq_addr -> s_addr ) , & bp -> bp_ciaddr , 4 ) ;", "idx": 21020}
{"project": "qemu", "commit_id": "fc34059f080680b560b3f656988fdd9a75cd0eab", "target": 1, "func": "static void GCC_FMT_ATTR ( 2 , 3 ) qtest_sendf ( CharBackend * chr , \n const char * fmt , ... ) \n { \n va_list ap ; \n gchar * buffer ; \n va_start ( ap , fmt ) ; \n buffer = g_strdup_vprintf ( fmt , ap ) ; \n qtest_send ( chr , buffer ) ; \n va_end ( ap ) ; \n }", "idx": 21026}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static int virtio_blk_load_device ( VirtIODevice * vdev , QEMUFile * f , \n int version_id ) \n { \n VirtIOBlock * s = VIRTIO_BLK ( vdev ) ; \n while ( qemu_get_sbyte ( f ) ) { \n VirtIOBlockReq * req = virtio_blk_alloc_request ( s ) ; \n qemu_get_buffer ( f , ( unsigned char * ) req -> elem , \n sizeof ( VirtQueueElement ) ) ; \n req -> next = s -> rq ; \n s -> rq = req ; \n virtqueue_map_sg ( req -> elem -> in_sg , req -> elem -> in_addr , \n req -> elem -> in_num , 1 ) ; \n virtqueue_map_sg ( req -> elem -> out_sg , req -> elem -> out_addr , \n req -> elem -> out_num , 0 ) ; \n } \n return 0 ; \n }", "idx": 21033}
{"project": "qemu", "commit_id": "3ac216270a62418519c08e88c17005a8f1539cf2", "target": 1, "func": "static int hdev_has_zero_init ( BlockDriverState * bs ) \n { \n return 0 ; \n }", "idx": 21124}
{"project": "qemu", "commit_id": "a15fcc3cf69ee3d408f60d6cc316488d2b0249b4", "target": 1, "func": "void visit_start_struct ( Visitor * v , const char * name , void * * obj , \n size_t size , Error * * errp ) \n { \n Error * err = NULL ; \n if ( obj ) { \n assert ( size ) ; \n assert ( v -> type != VISITOR_OUTPUT || * obj ) ; \n } \n v -> start_struct ( v , name , obj , size , & err ) ; \n if ( obj && v -> type == VISITOR_INPUT ) { \n assert ( ! err != ! * obj ) ; \n } \n error_propagate ( errp , err ) ; \n }", "idx": 21160}
{"project": "qemu", "commit_id": "42e4126b793d15ec40f3a84017e1d8afecda1b6d", "target": 1, "func": "void pci_default_write_config ( PCIDevice * d , uint32_t addr , uint32_t val , int l ) \n { \n int i , was_irq_disabled = pci_irq_disabled ( d ) ; \n uint32_t config_size = pci_config_size ( d ) ; \n for ( i = 0 ; i < l && addr + i < config_size ; val >>= 8 , ++ i ) { \n uint8_t wmask = d -> wmask [ addr + i ] ; \n uint8_t w1cmask = d -> w1cmask [ addr + i ] ; \n assert ( ! ( wmask & w1cmask ) ) ; \n d -> config [ addr + i ] = ( d -> config [ addr + i ] & ~ wmask ) | ( val & wmask ) ; \n d -> config [ addr + i ] &= ~ ( val & w1cmask ) ; \n } \n if ( ranges_overlap ( addr , l , PCI_BASE_ADDRESS_0 , 24 ) || \n ranges_overlap ( addr , l , PCI_ROM_ADDRESS , 4 ) || \n ranges_overlap ( addr , l , PCI_ROM_ADDRESS1 , 4 ) || \n range_covers_byte ( addr , l , PCI_COMMAND ) ) \n pci_update_mappings ( d ) ; \n if ( range_covers_byte ( addr , l , PCI_COMMAND ) ) \n pci_update_irq_disabled ( d , was_irq_disabled ) ; \n }", "idx": 21189}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline int check_fit_i32 ( uint32_t val , unsigned int bits ) \n { \n return ( ( val << ( 32 - bits ) ) >> ( 32 - bits ) ) == val ; \n }", "idx": 21196}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_getattr ( void * opaque ) \n { \n int32_t fid ; \n size_t offset = 7 ; \n ssize_t retval = 0 ; \n struct stat stbuf ; \n V9fsFidState * fidp ; \n uint64_t request_mask ; \n V9fsStatDotl v9stat_dotl ; \n V9fsPDU * pdu = opaque ; \n V9fsState * s = pdu -> s ; \n pdu_unmarshal ( pdu , offset , \" \" , & fid , & request_mask ) ; \n trace_v9fs_getattr ( pdu -> tag , pdu -> id , fid , request_mask ) ; \n fidp = get_fid ( pdu , fid ) ; \n if ( fidp == NULL ) { \n retval = - ENOENT ; \n goto out_nofid ; \n } \n retval = v9fs_co_lstat ( pdu , & fidp -> path , & stbuf ) ; \n if ( retval < 0 ) { \n goto out ; \n } \n stat_to_v9stat_dotl ( s , & stbuf , & v9stat_dotl ) ; \n if ( request_mask & P9_STATS_GEN ) { \n retval = v9fs_co_st_gen ( pdu , & fidp -> path , stbuf . st_mode , & v9stat_dotl ) ; \n if ( retval < 0 ) { \n goto out ; \n } \n v9stat_dotl . st_result_mask |= P9_STATS_GEN ; \n } \n retval = offset ; \n retval += pdu_marshal ( pdu , offset , \" \" , & v9stat_dotl ) ; \n trace_v9fs_getattr_return ( pdu -> tag , pdu -> id , v9stat_dotl . st_result_mask , \n v9stat_dotl . st_mode , v9stat_dotl . st_uid , \n v9stat_dotl . st_gid ) ; \n out : \n put_fid ( pdu , fidp ) ; \n out_nofid : \n complete_pdu ( s , pdu , retval ) ; \n }", "idx": 21200}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int qemu_timeout_ns_to_ms ( int64_t ns ) \n { \n int64_t ms ; \n if ( ns < 0 ) { \n return -1 ; \n } \n if ( ! ns ) { \n return 0 ; \n } \n ms = DIV_ROUND_UP ( ns , SCALE_MS ) ; \n if ( ms > ( int64_t ) INT32_MAX ) { \n ms = INT32_MAX ; \n } \n return ( int ) ms ; \n }", "idx": 21215}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static void qxl_init_ramsize ( PCIQXLDevice * qxl , uint32_t ram_min_mb ) \n { \n if ( qxl -> ram_size_mb != -1 ) { \n qxl -> vga . vram_size = qxl -> ram_size_mb * 1024 * 1024 ; \n } \n if ( qxl -> vga . vram_size < ram_min_mb * 1024 * 1024 ) { \n qxl -> vga . vram_size = ram_min_mb * 1024 * 1024 ; \n } \n if ( qxl -> vram32_size_mb != -1 ) { \n qxl -> vram32_size = qxl -> vram32_size_mb * 1024 * 1024 ; \n } \n if ( qxl -> vram32_size < 4096 ) { \n qxl -> vram32_size = 4096 ; \n } \n if ( qxl -> vram_size_mb != -1 ) { \n qxl -> vram_size = qxl -> vram_size_mb * 1024 * 1024 ; \n } \n if ( qxl -> vram_size < qxl -> vram32_size ) { \n qxl -> vram_size = qxl -> vram32_size ; \n } \n if ( qxl -> revision == 1 ) { \n qxl -> vram32_size = 4096 ; \n qxl -> vram_size = 4096 ; \n } \n qxl -> vga . vram_size = msb_mask ( qxl -> vga . vram_size * 2 - 1 ) ; \n qxl -> vram32_size = msb_mask ( qxl -> vram32_size * 2 - 1 ) ; \n qxl -> vram_size = msb_mask ( qxl -> vram_size * 2 - 1 ) ; \n }", "idx": 21230}
{"project": "qemu", "commit_id": "fc5d642fcae392bbc9fed9ac6bc78ac29ed48372", "target": 1, "func": "static void on_vcpu ( CPUState * env , void ( * func ) ( void * data ) , void * data ) \n { \n if ( env == cpu_single_env ) { \n func ( data ) ; \n return ; \n } \n abort ( ) ; \n }", "idx": 21282}
{"project": "qemu", "commit_id": "d42cf28837801cd1f835089fe9db2a42a1af55cd", "target": 0, "func": "static void bdrv_drain_recurse ( BlockDriverState * bs ) \n { \n BdrvChild * child ; \n if ( bs -> drv && bs -> drv -> bdrv_drain ) { \n bs -> drv -> bdrv_drain ( bs ) ; \n } \n QLIST_FOREACH ( child , & bs -> children , next )  { \n bdrv_drain_recurse ( child -> bs ) ; \n } \n }", "idx": 21313}
{"project": "qemu", "commit_id": "a7c31816288a8f20fc387d69d441413e7a8c9ff1", "target": 0, "func": "static void dump_qobject ( fprintf_function func_fprintf , void * f , \n int comp_indent , QObject * obj ) \n { \n switch ( qobject_type ( obj ) ) { \n case QTYPE_QINT : { \n QInt * value = qobject_to_qint ( obj ) ; \n func_fprintf ( f , \" \" PRId64 , qint_get_int ( value ) ) ; \n break ; \n } \n case QTYPE_QSTRING : { \n QString * value = qobject_to_qstring ( obj ) ; \n func_fprintf ( f , \" \" , qstring_get_str ( value ) ) ; \n break ; \n } \n case QTYPE_QDICT : { \n QDict * value = qobject_to_qdict ( obj ) ; \n dump_qdict ( func_fprintf , f , comp_indent , value ) ; \n break ; \n } \n case QTYPE_QLIST : { \n QList * value = qobject_to_qlist ( obj ) ; \n dump_qlist ( func_fprintf , f , comp_indent , value ) ; \n break ; \n } \n case QTYPE_QFLOAT : { \n QFloat * value = qobject_to_qfloat ( obj ) ; \n func_fprintf ( f , \" \" , qfloat_get_double ( value ) ) ; \n break ; \n } \n case QTYPE_QBOOL : { \n QBool * value = qobject_to_qbool ( obj ) ; \n func_fprintf ( f , \" \" , qbool_get_int ( value ) ? \" \" : \" \" ) ; \n break ; \n } \n case QTYPE_QERROR : { \n QString * value = qerror_human ( ( QError * ) obj ) ; \n func_fprintf ( f , \" \" , qstring_get_str ( value ) ) ; \n QDECREF ( value ) ; \n break ; \n } \n case QTYPE_NONE : \n break ; \n case QTYPE_MAX : \n default : \n abort ( ) ; \n } \n }", "idx": 21319}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_tx_descr ( struct Vmxnet3_TxDesc * descr )  \n { \n VMW_PKPRN ( \" \" \n \" \" PRIx64 \" \" \n \" \" \n \" \" , \n le64_to_cpu ( descr -> addr ) , descr -> len , descr -> gen , descr -> rsvd , \n descr -> dtype , descr -> ext1 , descr -> msscof , descr -> hlen , descr -> om , \n descr -> eop , descr -> cq , descr -> ext2 , descr -> ti , descr -> tci ) ; \n }", "idx": 21334}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE bits64 extractFloat64Frac ( float64 a ) \n { \n return a & LIT64 ( 0x000FFFFFFFFFFFFF ) ; \n }", "idx": 21369}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void esp_command_complete ( SCSIBus * bus , int reason , uint32_t tag , \n uint32_t arg ) \n { \n ESPState * s = DO_UPCAST ( ESPState , busdev . qdev , bus -> qbus . parent ) ; \n if ( reason == SCSI_REASON_DONE ) { \n DPRINTF ( \" \\n \" ) ; \n if ( s -> ti_size != 0 ) \n DPRINTF ( \" \\n \" ) ; \n s -> ti_size = 0 ; \n s -> dma_left = 0 ; \n s -> async_len = 0 ; \n if ( arg ) \n DPRINTF ( \" \\n \" ) ; \n s -> sense = arg ; \n s -> rregs [ ESP_RSTAT ] = STAT_ST ; \n esp_dma_done ( s ) ; \n s -> current_dev = NULL ; \n } else { \n DPRINTF ( \" \\n \" , s -> dma_left , s -> ti_size ) ; \n s -> async_len = arg ; \n s -> async_buf = s -> current_dev -> info -> get_buf ( s -> current_dev , 0 ) ; \n if ( s -> dma_left ) { \n esp_do_dma ( s ) ; \n } else if ( s -> dma_counter != 0 && s -> ti_size <= 0 ) { \n esp_dma_done ( s ) ; \n } \n } \n }", "idx": 21389}
{"project": "qemu", "commit_id": "6c2d1c32d084320081b0cd047f8cacd6e722d03a", "target": 1, "func": "static void ehci_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ; \n EHCIPCIInfo * i = data ; \n k -> init = usb_ehci_pci_initfn ; \n k -> vendor_id = i -> vendor_id ; \n k -> device_id = i -> device_id ; \n k -> revision = i -> revision ; \n k -> class_id = PCI_CLASS_SERIAL_USB ; \n k -> config_write = usb_ehci_pci_write_config ; \n dc -> vmsd = & vmstate_ehci_pci ; \n dc -> props = ehci_pci_properties ; \n }", "idx": 21407}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t proxy_lgetxattr ( FsContext * ctx , V9fsPath * fs_path , \n const char * name , void * value , size_t size ) \n { \n int retval ; \n V9fsString xname ; \n v9fs_string_init ( & xname ) ; \n v9fs_string_sprintf ( & xname , \" \" , name ) ; \n retval = v9fs_request ( ctx -> private , T_LGETXATTR , value , \" \" , size , \n fs_path , & xname ) ; \n v9fs_string_free ( & xname ) ; \n if ( retval < 0 ) { \n errno = - retval ; \n } \n return retval ; \n }", "idx": 21434}
{"project": "qemu", "commit_id": "a7ffaf5c96e26820edffa94eeac766fe60bfdd31", "target": 0, "func": "static void cadence_timer_sync ( CadenceTimerState * s ) \n { \n int i ; \n int64_t r , x ; \n int64_t interval = ( ( s -> reg_count & COUNTER_CTRL_INT ) ? \n ( int64_t ) s -> reg_interval + 1 : 0x10000ULL ) << 16 ; \n uint64_t old_time = s -> cpu_time ; \n s -> cpu_time = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) ; \n DB_PRINT ( \" \\n \" , ( long long ) old_time ) ; \n if ( ! s -> cpu_time_valid || old_time == s -> cpu_time ) { \n s -> cpu_time_valid = 1 ; \n return ; \n } \n r = ( int64_t ) cadence_timer_get_steps ( s , s -> cpu_time - old_time ) ; \n x = ( int64_t ) s -> reg_value + ( ( s -> reg_count & COUNTER_CTRL_DEC ) ? - r : r ) ; \n for ( i = 0 ; i < 3 ; ++ i ) { \n int64_t m = ( int64_t ) s -> reg_match [ i ] << 16 ; \n if ( m > interval ) { \n continue ; \n } \n if ( is_between ( m , s -> reg_value , x ) || \n is_between ( m + interval , s -> reg_value , x ) || \n is_between ( m - interval , s -> reg_value , x ) ) { \n s -> reg_intr |= ( 2 << i ) ; \n } \n } \n while ( x < 0 ) { \n x += interval ; \n } \n s -> reg_value = ( uint32_t ) ( x % interval ) ; \n if ( s -> reg_value != x ) { \n s -> reg_intr |= ( s -> reg_count & COUNTER_CTRL_INT ) ? \n COUNTER_INTR_IV : COUNTER_INTR_OV ; \n } \n cadence_timer_update ( s ) ; \n }", "idx": 21436}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond_i64 ( TCGContext * s , TCGCond cond , TCGReg arg1 , \n int32_t arg2 , int const_arg2 , int label ) \n { \n if ( arg2 == 0 && ! is_unsigned_cond ( cond ) ) { \n TCGLabel * l = & s -> labels [ label ] ; \n int off16 ; \n if ( l -> has_value ) { \n off16 = INSN_OFF16 ( tcg_pcrel_diff ( s , l -> u . value_ptr ) ) ; \n } else { \n off16 = * s -> code_ptr & INSN_OFF16 ( -1 ) ; \n tcg_out_reloc ( s , s -> code_ptr , R_SPARC_WDISP16 , label , 0 ) ; \n } \n tcg_out32 ( s , INSN_OP ( 0 ) | INSN_OP2 ( 3 ) | BPR_PT | INSN_RS1 ( arg1 ) \n | INSN_COND ( tcg_cond_to_rcond [ cond ] ) | off16 ) ; \n } else { \n tcg_out_cmp ( s , arg1 , arg2 , const_arg2 ) ; \n tcg_out_bpcc ( s , tcg_cond_to_bcond [ cond ] , BPCC_XCC | BPCC_PT , label ) ; \n } \n tcg_out_nop ( s ) ; \n }", "idx": 21440}
{"project": "qemu", "commit_id": "95be1196030c003a65052fc7b8a3394fdac690a8", "target": 0, "func": "int pci_bridge_initfn ( PCIDevice * dev ) \n { \n PCIBus * parent = dev -> bus ; \n PCIBridge * br = DO_UPCAST ( PCIBridge , dev , dev ) ; \n PCIBus * sec_bus = & br -> sec_bus ; \n pci_set_word ( dev -> config + PCI_STATUS , \n PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK ) ; \n pci_config_set_class ( dev -> config , PCI_CLASS_BRIDGE_PCI ) ; \n dev -> config [ PCI_HEADER_TYPE ] = \n ( dev -> config [ PCI_HEADER_TYPE ] & PCI_HEADER_TYPE_MULTI_FUNCTION ) | \n PCI_HEADER_TYPE_BRIDGE ; \n pci_set_word ( dev -> config + PCI_SEC_STATUS , \n PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK ) ; \n qbus_create_inplace ( & sec_bus -> qbus , & pci_bus_info , & dev -> qdev , \n br -> bus_name ) ; \n sec_bus -> parent_dev = dev ; \n sec_bus -> map_irq = br -> map_irq ; \n sec_bus -> address_space_mem = & br -> address_space_mem ; \n memory_region_init ( & br -> address_space_mem , \" \" , INT64_MAX ) ; \n sec_bus -> address_space_io = & br -> address_space_io ; \n memory_region_init ( & br -> address_space_io , \" \" , 65536 ) ; \n pci_bridge_region_init ( br ) ; \n QLIST_INIT ( & sec_bus -> child ) ; \n QLIST_INSERT_HEAD ( & parent -> child , sec_bus , sibling ) ; \n return 0 ; \n }", "idx": 21453}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void clear_sdr_rep ( IPMIBmcSim * ibs , \n uint8_t * cmd , unsigned int cmd_len , \n uint8_t * rsp , unsigned int * rsp_len , \n unsigned int max_rsp_len ) \n { \n IPMI_CHECK_CMD_LEN ( 8 ) ; \n IPMI_CHECK_RESERVATION ( 2 , ibs -> sdr . reservation ) ; \n if ( cmd [ 4 ] != ' ' || cmd [ 5 ] != ' ' || cmd [ 6 ] != ' ' ) { \n rsp [ 2 ] = IPMI_CC_INVALID_DATA_FIELD ; \n return ; \n } \n if ( cmd [ 7 ] == 0xaa ) { \n ibs -> sdr . next_free = 0 ; \n ibs -> sdr . overflow = 0 ; \n set_timestamp ( ibs , ibs -> sdr . last_clear ) ; \n IPMI_ADD_RSP_DATA ( 1 ) ; \n sdr_inc_reservation ( & ibs -> sdr ) ; \n } else if ( cmd [ 7 ] == 0 ) { \n IPMI_ADD_RSP_DATA ( 1 ) ; \n } else { \n rsp [ 2 ] = IPMI_CC_INVALID_DATA_FIELD ; \n return ; \n } \n }", "idx": 21468}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState * qmp_chardev_open_file ( const char * id , \n ChardevBackend * backend , \n ChardevReturn * ret , \n Error * * errp ) \n { \n ChardevFile * file = backend -> u . file ; \n ChardevCommon * common = qapi_ChardevFile_base ( file ) ; \n HANDLE out ; \n if ( file -> has_in ) { \n error_setg ( errp , \" \" ) ; \n return NULL ; \n } \n out = CreateFile ( file -> out , GENERIC_WRITE , FILE_SHARE_READ , NULL , \n OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ) ; \n if ( out == INVALID_HANDLE_VALUE ) { \n error_setg ( errp , \" \" , file -> out ) ; \n return NULL ; \n } \n return qemu_chr_open_win_file ( out , common , errp ) ; \n }", "idx": 21483}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_debug_event ( BlockDriverState * bs , BlkDebugEvent event ) \n { \n if ( ! bs || ! bs -> drv || ! bs -> drv -> bdrv_debug_event ) { \n return ; \n } \n bs -> drv -> bdrv_debug_event ( bs , event ) ; \n }", "idx": 21531}
{"project": "qemu", "commit_id": "16a9e8a5bcc1fb0796828eb654a4f926734e59af", "target": 0, "func": "static bool pc_machine_get_aligned_dimm ( Object * obj , Error * * errp ) \n { \n PCMachineState * pcms = PC_MACHINE ( obj ) ; \n return pcms -> enforce_aligned_dimm ; \n }", "idx": 21555}
{"project": "qemu", "commit_id": "b192af8acc597a6e8068873434e56e0c7de1b7d3", "target": 0, "func": "static int refresh_total_sectors ( BlockDriverState * bs , int64_t hint ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( bs -> sg ) \n return 0 ; \n if ( drv -> bdrv_getlength ) { \n int64_t length = drv -> bdrv_getlength ( bs ) ; \n if ( length < 0 ) { \n return length ; \n } \n hint = DIV_ROUND_UP ( length , BDRV_SECTOR_SIZE ) ; \n } \n bs -> total_sectors = hint ; \n return 0 ; \n }", "idx": 21561}
{"project": "qemu", "commit_id": "13344f3a17e0a785c0eb8e36f69518f21aa8a91a", "target": 1, "func": "BlockStatsList * qmp_query_blockstats ( Error * * errp ) \n { \n BlockStatsList * head = NULL , * * p_next = & head ; \n BlockDriverState * bs = NULL ; \n while ( ( bs = bdrv_next ( bs ) ) ) { \n BlockStatsList * info = g_malloc0 ( sizeof ( * info ) ) ; \n info -> value = bdrv_query_stats ( bs ) ; \n * p_next = info ; \n p_next = & info -> next ; \n } \n return head ; \n }", "idx": 21564}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void gen_spr_74xx ( CPUPPCState * env ) \n { \n spr_register ( env , SPR_PIR , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_pir , \n 0x00000000 ) ; \n spr_register ( env , SPR_MMCR2 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_UMMCR2 , \" \" , \n & spr_read_ureg , SPR_NOACCESS , \n & spr_read_ureg , SPR_NOACCESS , \n 0x00000000 ) ; \n spr_register ( env , SPR_BAMR , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_MSSCR0 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID0 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID1 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_VRSAVE , \" \" , \n & spr_read_generic , & spr_write_generic , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_L2CR , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , NULL , \n 0x00000000 ) ; \n vscr_init ( env , 0x00010000 ) ; \n }", "idx": 21587}
{"project": "qemu", "commit_id": "903585dec63ee83bd8149006e31f92ea789b38e3", "target": 0, "func": "static void ppce500_reset_device_tree ( void * opaque ) \n { \n DeviceTreeParams * p = opaque ; \n ppce500_load_device_tree ( p -> machine , & p -> params , p -> addr , p -> initrd_base , \n p -> initrd_size , false ) ; \n }", "idx": 21627}
{"project": "qemu", "commit_id": "1bd075f29ea6d11853475c7c42734595720c3ac6", "target": 1, "func": "iscsi_aio_write16_cb ( struct iscsi_context *  iscsi , int  status , \n void * command_data , void * opaque ) \n { \n IscsiAIOCB * acb = opaque ; \n trace_iscsi_aio_write16_cb ( iscsi , status , acb , acb -> canceled ) ; \n g_free ( acb -> buf ) ; \n if ( acb -> canceled != 0 ) { \n qemu_aio_release ( acb ) ; \n scsi_free_scsi_task ( acb -> task ) ; \n acb -> task = NULL ; \n return ; \n } \n acb -> status = 0 ; \n if ( status < 0 ) { \n error_report ( \" \" , \n iscsi_get_error ( iscsi ) ) ; \n acb -> status = - EIO ; \n } \n iscsi_schedule_bh ( acb ) ; \n scsi_free_scsi_task ( acb -> task ) ; \n acb -> task = NULL ; \n }", "idx": 21633}
{"project": "qemu", "commit_id": "7ea2d269cb84ca7a2f4b7c3735634176f7c1dc35", "target": 1, "func": "NBDExport * nbd_export_new ( BlockDriverState * bs , off_t dev_offset , \n off_t size , uint32_t nbdflags , \n void ( * close ) ( NBDExport * ) ) \n { \n NBDExport * exp = g_malloc0 ( sizeof ( NBDExport ) ) ; \n exp -> refcount = 1 ; \n QTAILQ_INIT ( & exp -> clients ) ; \n exp -> bs = bs ; \n exp -> dev_offset = dev_offset ; \n exp -> nbdflags = nbdflags ; \n exp -> size = size == -1 ? bdrv_getlength ( bs ) : size ; \n exp -> close = close ; \n exp -> ctx = bdrv_get_aio_context ( bs ) ; \n bdrv_ref ( bs ) ; \n bdrv_add_aio_context_notifier ( bs , bs_aio_attached , bs_aio_detach , exp ) ; \n return exp ; \n }", "idx": 21691}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static int qemu_reset_requested ( void ) \n { \n int r = reset_requested ; \n if ( r && replay_checkpoint ( CHECKPOINT_RESET_REQUESTED ) ) { \n reset_requested = 0 ; \n return r ; \n } \n return false ; \n }", "idx": 21704}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_pwt_s * omap_pwt_init ( MemoryRegion * system_memory , \n target_phys_addr_t base , \n omap_clk clk ) \n { \n struct omap_pwt_s * s = g_malloc0 ( sizeof ( * s ) ) ; \n s -> clk = clk ; \n omap_pwt_reset ( s ) ; \n memory_region_init_io ( & s -> iomem , & omap_pwt_ops , s , \n \" \" , 0x800 ) ; \n memory_region_add_subregion ( system_memory , base , & s -> iomem ) ; \n return s ; \n }", "idx": 21746}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_tbl ( const struct MonitorDef * md , int val ) \n { \n CPUState * env = mon_get_cpu ( ) ; \n if ( ! env ) \n return 0 ; \n return cpu_ppc_load_tbl ( env ) ; \n }", "idx": 21823}
{"project": "qemu", "commit_id": "08a2d4c4ffde60e48819449f461274c43ad6e2d3", "target": 0, "func": "static void sdl_grab_start ( void ) \n { \n if ( guest_cursor ) { \n SDL_SetCursor ( guest_sprite ) ; \n SDL_WarpMouse ( guest_x , guest_y ) ; \n } else \n sdl_hide_cursor ( ) ; \n if ( SDL_WM_GrabInput ( SDL_GRAB_ON ) == SDL_GRAB_ON ) { \n gui_grab = 1 ; \n sdl_update_caption ( ) ; \n } else \n sdl_show_cursor ( ) ; \n }", "idx": 21858}
{"project": "qemu", "commit_id": "872dd82c83745a603d2e07a03d34313eb6467ae4", "target": 0, "func": "VirtQueue * virtio_add_queue ( VirtIODevice * vdev , int queue_size , \n VirtIOHandleOutput handle_output ) \n { \n int i ; \n for ( i = 0 ; i < VIRTIO_QUEUE_MAX ; i ++ ) { \n if ( vdev -> vq [ i ] . vring . num == 0 ) \n break ; \n } \n if ( i == VIRTIO_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE ) \n abort ( ) ; \n vdev -> vq [ i ] . vring . num = queue_size ; \n vdev -> vq [ i ] . vring . num_default = queue_size ; \n vdev -> vq [ i ] . vring . align = VIRTIO_PCI_VRING_ALIGN ; \n vdev -> vq [ i ] . handle_output = handle_output ; \n vdev -> vq [ i ] . handle_aio_output = NULL ; \n return & vdev -> vq [ i ] ; \n }", "idx": 21860}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void discard_vq_data ( VirtQueue * vq , VirtIODevice * vdev ) \n { \n VirtQueueElement elem ; \n if ( ! virtio_queue_ready ( vq ) ) { \n return ; \n } \n while ( virtqueue_pop ( vq , & elem ) ) { \n virtqueue_push ( vq , & elem , 0 ) ; \n } \n virtio_notify ( vdev , vq ) ; \n }", "idx": 21864}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "void migrate_compress_threads_create ( void ) \n { \n int i , thread_count ; \n if ( ! migrate_use_compression ( ) ) { \n return ; \n } \n quit_comp_thread = false ; \n compression_switch = true ; \n thread_count = migrate_compress_threads ( ) ; \n compress_threads = g_new0 ( QemuThread , thread_count ) ; \n comp_param = g_new0 ( CompressParam , thread_count ) ; \n comp_done_cond = g_new0 ( QemuCond , 1 ) ; \n comp_done_lock = g_new0 ( QemuMutex , 1 ) ; \n qemu_cond_init ( comp_done_cond ) ; \n qemu_mutex_init ( comp_done_lock ) ; \n for ( i = 0 ; i < thread_count ; i ++ ) { \n comp_param [ i ] . file = qemu_fopen_ops ( NULL , & empty_ops ) ; \n comp_param [ i ] . done = true ; \n qemu_mutex_init ( & comp_param [ i ] . mutex ) ; \n qemu_cond_init ( & comp_param [ i ] . cond ) ; \n qemu_thread_create ( compress_threads + i , \" \" , \n do_data_compress , comp_param + i , \n QEMU_THREAD_JOINABLE ) ; \n } \n }", "idx": 21875}
{"project": "qemu", "commit_id": "703008e81a6ace40f227aae16d630014e5016af1", "target": 0, "func": "void validate_bootdevices ( const char * devices ) \n { \n const char * p ; \n int bitmap = 0 ; \n for ( p = devices ; * p != ' \\0 ' ; p ++ ) { \n if ( * p < ' ' || * p > ' ' ) { \n fprintf ( stderr , \" \\n \" , * p ) ; \n exit ( 1 ) ; \n } \n if ( bitmap & ( 1 << ( * p - ' ' ) ) ) { \n fprintf ( stderr , \" \\n \" , * p ) ; \n exit ( 1 ) ; \n } \n bitmap |= 1 << ( * p - ' ' ) ; \n } \n }", "idx": 21876}
{"project": "qemu", "commit_id": "cfb2d02be9413d45b30ed6d8e38800250b6b4b48", "target": 0, "func": "static inline void cpu_loop_exec_tb ( CPUState * cpu , TranslationBlock * tb , \n TranslationBlock * * last_tb , int * tb_exit , \n SyncClocks * sc ) \n { \n uintptr_t ret ; \n int32_t insns_left ; \n if ( unlikely ( atomic_read ( & cpu -> exit_request ) ) ) { \n return ; \n } \n trace_exec_tb ( tb , tb -> pc ) ; \n ret = cpu_tb_exec ( cpu , tb ) ; \n tb = ( TranslationBlock * ) ( ret & ~ TB_EXIT_MASK ) ; \n * tb_exit = ret & TB_EXIT_MASK ; \n if ( * tb_exit != TB_EXIT_REQUESTED ) { \n * last_tb = tb ; \n return ; \n } \n * last_tb = NULL ; \n insns_left = atomic_read ( & cpu -> icount_decr . u32 ) ; \n atomic_set ( & cpu -> icount_decr . u16 . high , 0 ) ; \n if ( insns_left < 0 ) { \n smp_mb ( ) ; \n return ; \n } \n assert ( use_icount ) ; \n #ifndef CONFIG_USER_ONLY \n if ( cpu -> icount_extra ) { \n cpu -> icount_extra += insns_left ; \n insns_left = MIN ( 0xffff , cpu -> icount_extra ) ; \n cpu -> icount_extra -= insns_left ; \n cpu -> icount_decr . u16 . low = insns_left ; \n } else { \n if ( insns_left > 0 ) { \n cpu_exec_nocache ( cpu , insns_left , tb , false ) ; \n align_clocks ( sc , cpu ) ; \n } \n cpu -> exception_index = EXCP_INTERRUPT ; \n cpu_loop_exit ( cpu ) ; \n } \n #endif \n }", "idx": 21880}
{"project": "qemu", "commit_id": "32532f215c49f005aaef942adfae34cbcc5fa678", "target": 1, "func": "static void pc_dimm_realize ( DeviceState * dev , Error * * errp ) \n { \n PCDIMMDevice * dimm = PC_DIMM ( dev ) ; \n if ( ! dimm -> hostmem ) { \n error_setg ( errp , \" \" PC_DIMM_MEMDEV_PROP \" \" ) ; \n return ; \n } \n if ( ( nb_numa_nodes > 0 ) && ( dimm -> node >= nb_numa_nodes ) ) { \n error_setg ( errp , \" \" PC_DIMM_NODE_PROP \" \" \n PRIu32 \" \" , \n dimm -> node , nb_numa_nodes ) ; \n return ; \n } \n }", "idx": 21901}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "void cpu_write_xer ( CPUPPCState * env , target_ulong xer ) \n { \n env -> so = ( xer >> XER_SO ) & 1 ; \n env -> ov = ( xer >> XER_OV ) & 1 ; \n env -> ca = ( xer >> XER_CA ) & 1 ; \n env -> xer = xer & ~ ( ( 1u << XER_SO ) | ( 1u << XER_OV ) | ( 1u << XER_CA ) ) ; \n }", "idx": 21918}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_divq_EAX_T0 ( void ) \n { \n uint64_t r0 , r1 ; \n if ( T0 == 0 ) { \n raise_exception ( EXCP00_DIVZ ) ; \n } \n r0 = EAX ; \n r1 = EDX ; \n div64 ( & r0 , & r1 , T0 ) ; \n EAX = r0 ; \n EDX = r1 ; \n }", "idx": 21921}
{"project": "qemu", "commit_id": "640601c7cb1b6b41d3e1a435b986266c2b71e9bc", "target": 1, "func": "vu_queue_flush ( VuDev * dev , VuVirtq * vq , unsigned int count )  \n { \n uint16_t old , new ; \n if ( unlikely ( dev -> broken ) ) { \n return ; \n } \n smp_wmb ( ) ; \n old = vq -> used_idx ; \n new = old + count ; \n vring_used_idx_set ( dev , vq , new ) ; \n vq -> inuse -= count ; \n if ( unlikely ( ( int16_t ) ( new - vq -> signalled_used ) < ( uint16_t ) ( new - old ) ) ) { \n vq -> signalled_used_valid = false ; \n } \n }", "idx": 21980}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static int ioh3420_initfn ( PCIDevice * d ) \n { \n PCIEPort * p = PCIE_PORT ( d ) ; \n PCIESlot * s = PCIE_SLOT ( d ) ; \n int rc ; \n pci_bridge_initfn ( d , TYPE_PCIE_BUS ) ; \n pcie_port_init_reg ( d ) ; \n rc = pci_bridge_ssvid_init ( d , IOH_EP_SSVID_OFFSET , \n IOH_EP_SSVID_SVID , IOH_EP_SSVID_SSID ) ; \n if ( rc < 0 ) { \n goto err_bridge ; \n } \n rc = msi_init ( d , IOH_EP_MSI_OFFSET , IOH_EP_MSI_NR_VECTOR , \n IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_64BIT , \n IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_MASKBIT ) ; \n if ( rc < 0 ) { \n goto err_bridge ; \n } \n rc = pcie_cap_init ( d , IOH_EP_EXP_OFFSET , PCI_EXP_TYPE_ROOT_PORT , p -> port ) ; \n if ( rc < 0 ) { \n goto err_msi ; \n } \n pcie_cap_arifwd_init ( d ) ; \n pcie_cap_deverr_init ( d ) ; \n pcie_cap_slot_init ( d , s -> slot ) ; \n pcie_cap_root_init ( d ) ; \n pcie_chassis_create ( s -> chassis ) ; \n rc = pcie_chassis_add_slot ( s ) ; \n if ( rc < 0 ) { \n goto err_pcie_cap ; \n } \n rc = pcie_aer_init ( d , IOH_EP_AER_OFFSET , PCI_ERR_SIZEOF ) ; \n if ( rc < 0 ) { \n goto err ; \n } \n pcie_aer_root_init ( d ) ; \n ioh3420_aer_vector_update ( d ) ; \n return 0 ; \n err : \n pcie_chassis_del_slot ( s ) ; \n err_pcie_cap : \n pcie_cap_exit ( d ) ; \n err_msi : \n msi_uninit ( d ) ; \n err_bridge : \n pci_bridge_exitfn ( d ) ; \n return rc ; \n }", "idx": 22002}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void do_busid_cmd ( ESPState * s , uint8_t * buf , uint8_t busid ) \n { \n int32_t datalen ; \n int lun ; \n DPRINTF ( \" \\n \" , busid ) ; \n lun = busid & 7 ; \n datalen = s -> current_dev -> info -> send_command ( s -> current_dev , 0 , buf , lun ) ; \n s -> ti_size = datalen ; \n if ( datalen != 0 ) { \n s -> rregs [ ESP_RSTAT ] = STAT_TC ; \n s -> dma_left = 0 ; \n s -> dma_counter = 0 ; \n if ( datalen > 0 ) { \n s -> rregs [ ESP_RSTAT ] |= STAT_DI ; \n s -> current_dev -> info -> read_data ( s -> current_dev , 0 ) ; \n } else { \n s -> rregs [ ESP_RSTAT ] |= STAT_DO ; \n s -> current_dev -> info -> write_data ( s -> current_dev , 0 ) ; \n } \n } \n s -> rregs [ ESP_RINTR ] = INTR_BS | INTR_FC ; \n s -> rregs [ ESP_RSEQ ] = SEQ_CD ; \n esp_raise_irq ( s ) ; \n }", "idx": 22029}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv neon_load_scratch ( int scratch ) \n { \n TCGv tmp = new_tmp ( ) ; \n tcg_gen_ld_i32 ( tmp , cpu_env , offsetof ( CPUARMState , vfp . scratch [ scratch ] ) ) ; \n return tmp ; \n }", "idx": 22045}
{"project": "qemu", "commit_id": "234ac1a9025bcfcc532449f72a97b3d4754d466c", "target": 0, "func": "void bdrv_append ( BlockDriverState * bs_new , BlockDriverState * bs_top , \n Error * * errp ) \n { \n Error * local_err = NULL ; \n assert ( ! atomic_read ( & bs_top -> in_flight ) ) ; \n assert ( ! atomic_read ( & bs_new -> in_flight ) ) ; \n bdrv_set_backing_hd ( bs_new , bs_top , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n goto out ; \n } \n change_parent_backing_link ( bs_top , bs_new ) ; \n out : \n bdrv_unref ( bs_new ) ; \n }", "idx": 22080}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_sendto ( int fd , abi_ulong msg , size_t len , int flags , \n abi_ulong target_addr , socklen_t addrlen ) \n { \n void * addr ; \n void * host_msg ; \n abi_long ret ; \n if ( addrlen < 0 || addrlen > MAX_SOCK_ADDR ) \n return - TARGET_EINVAL ; \n host_msg = lock_user ( VERIFY_READ , msg , len , 1 ) ; \n if ( ! host_msg ) \n return - TARGET_EFAULT ; \n if ( target_addr ) { \n addr = alloca ( addrlen ) ; \n target_to_host_sockaddr ( addr , target_addr , addrlen ) ; \n ret = get_errno ( sendto ( fd , host_msg , len , flags , addr , addrlen ) ) ; \n } else { \n ret = get_errno ( send ( fd , host_msg , len , flags ) ) ; \n } \n unlock_user ( host_msg , msg , 0 ) ; \n return ret ; \n }", "idx": 22081}
{"project": "qemu", "commit_id": "0e2487bd6f56445b43307536a465ee2ba810aed9", "target": 0, "func": "void qxl_render_resize ( PCIQXLDevice * qxl ) \n { \n QXLSurfaceCreate * sc = & qxl -> guest_primary . surface ; \n qxl -> guest_primary . stride = sc -> stride ; \n qxl -> guest_primary . resized ++ ; \n switch ( sc -> format ) { \n case SPICE_SURFACE_FMT_16_555 : \n qxl -> guest_primary . bytes_pp = 2 ; \n qxl -> guest_primary . bits_pp = 15 ; \n break ; \n case SPICE_SURFACE_FMT_16_565 : \n qxl -> guest_primary . bytes_pp = 2 ; \n qxl -> guest_primary . bits_pp = 16 ; \n break ; \n case SPICE_SURFACE_FMT_32_xRGB : \n case SPICE_SURFACE_FMT_32_ARGB : \n qxl -> guest_primary . bytes_pp = 4 ; \n qxl -> guest_primary . bits_pp = 32 ; \n break ; \n default : \n fprintf ( stderr , \" \\n \" , __FUNCTION__ , \n qxl -> guest_primary . surface . format ) ; \n qxl -> guest_primary . bytes_pp = 4 ; \n qxl -> guest_primary . bits_pp = 32 ; \n break ; \n } \n }", "idx": 22083}
{"project": "qemu", "commit_id": "5b8d7289e9e92a0d7bcecb93cd189e245fef10cd", "target": 0, "func": "static bool insn_crosses_page ( CPUARMState * env , DisasContext * s ) \n { \n uint16_t insn ; \n if ( ( s -> pc & 3 ) == 0 ) { \n return false ; \n } \n insn = arm_lduw_code ( env , s -> pc , s -> sctlr_b ) ; \n if ( ( insn >> 11 ) >= 0x1d ) { \n return true ; \n } \n return false ; \n }", "idx": 22097}
{"project": "qemu", "commit_id": "c338b6ad609699cf352c8dd6338360b7e3895ad0", "target": 0, "func": "static int vmdk_is_cid_valid ( BlockDriverState * bs ) \n { \n #ifdef CHECK_CID \n BDRVVmdkState * s = bs -> opaque ; \n BlockDriverState * p_bs = bs -> backing_hd ; \n uint32_t cur_pcid ; \n if ( p_bs ) { \n cur_pcid = vmdk_read_cid ( p_bs , 0 ) ; \n if ( s -> parent_cid != cur_pcid ) { \n return 0 ; \n } \n } \n #endif \n return 1 ; \n }", "idx": 22104}
{"project": "qemu", "commit_id": "a702b35388c307ce2364691e2edc14094701c81e", "target": 0, "func": "static uint32_t slavio_timer_mem_readl ( void * opaque , target_phys_addr_t addr ) \n { \n SLAVIO_TIMERState * s = opaque ; \n uint32_t saddr , ret ; \n saddr = ( addr & TIMER_MAXADDR ) >> 2 ; \n switch ( saddr ) { \n case 0 : \n if ( slavio_timer_is_user ( s ) ) { \n slavio_timer_get_out ( s ) ; \n ret = s -> counthigh ; \n } else { \n qemu_irq_lower ( s -> irq ) ; \n s -> reached = 0 ; \n ret = s -> limit & 0x7fffffff ; \n } \n break ; \n case 1 : \n slavio_timer_get_out ( s ) ; \n if ( slavio_timer_is_user ( s ) ) \n ret = s -> count & 0xffffffe00 ; \n else \n ret = ( s -> count & 0x7ffffe00 ) | s -> reached ; \n break ; \n case 3 : \n ret = s -> running ; \n break ; \n case 4 : \n ret = s -> slave_mode ; \n break ; \n default : \n DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n ret = 0 ; \n break ; \n } \n DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr , ret ) ; \n return ret ; \n }", "idx": 22105}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_suspend_request ( void ) \n { \n if ( is_suspended ) { \n return ; \n } \n suspend_requested = 1 ; \n cpu_stop_current ( ) ; \n qemu_notify_event ( ) ; \n }", "idx": 22109}
{"project": "qemu", "commit_id": "89dbe18089127cf90993359096b659ea6f819848", "target": 0, "func": "static void ssh_parse_filename ( const char * filename , QDict * options , \n Error * * errp ) \n { \n if ( qdict_haskey ( options , \" \" ) || \n qdict_haskey ( options , \" \" ) || \n qdict_haskey ( options , \" \" ) || \n qdict_haskey ( options , \" \" ) || \n qdict_haskey ( options , \" \" ) ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n parse_uri ( filename , options , errp ) ; \n }", "idx": 22119}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void do_acl_show ( Monitor * mon , const QDict * qdict ) \n { \n const char * aclname = qdict_get_str ( qdict , \" \" ) ; \n qemu_acl * acl = find_acl ( mon , aclname ) ; \n qemu_acl_entry * entry ; \n int i = 0 ; \n if ( acl ) { \n monitor_printf ( mon , \" \\n \" , \n acl -> defaultDeny ? \" \" : \" \" ) ; \n TAILQ_FOREACH ( entry , & acl -> entries , next )  { \n i ++ ; \n monitor_printf ( mon , \" \\n \" , i , \n entry -> deny ? \" \" : \" \" , entry -> match ) ; \n } \n } \n }", "idx": 22142}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegionSection * phys_page_find ( AddressSpaceDispatch * d , target_phys_addr_t index ) \n { \n PhysPageEntry lp = d -> phys_map ; \n PhysPageEntry * p ; \n int i ; \n uint16_t s_index = phys_section_unassigned ; \n for ( i = P_L2_LEVELS - 1 ; i >= 0 && ! lp . is_leaf ; i -- ) { \n if ( lp . ptr == PHYS_MAP_NODE_NIL ) { \n goto not_found ; \n } \n p = phys_map_nodes [ lp . ptr ] ; \n lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ] ; \n } \n s_index = lp . ptr ; \n not_found : \n return & phys_sections [ s_index ] ; \n }", "idx": 22143}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int drive_get_max_bus ( BlockInterfaceType type ) \n { \n int max_bus ; \n DriveInfo * dinfo ; \n max_bus = -1 ; \n TAILQ_FOREACH ( dinfo , & drives , next )  { \n if ( dinfo -> type == type && \n dinfo -> bus > max_bus ) \n max_bus = dinfo -> bus ; \n } \n return max_bus ; \n }", "idx": 22184}
{"project": "qemu", "commit_id": "c021f8e65f5009a5ab5711d9d5326fcab553ef1c", "target": 0, "func": "PCIBus * pci_find_bus ( PCIBus * bus , int bus_num ) \n { \n PCIBus * sec ; \n if ( ! bus ) \n return NULL ; \n if ( pci_bus_num ( bus ) == bus_num ) { \n return bus ; \n } \n QLIST_FOREACH ( sec , & bus -> child , sibling )  { \n if ( ! bus -> parent_dev \n || ( pci_bus_num ( sec ) <= bus_num && \n bus -> parent_dev -> config [ PCI_SUBORDINATE_BUS ] ) ) { \n return pci_find_bus ( sec , bus_num ) ; \n } \n } \n return NULL ; \n }", "idx": 22187}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "ser_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val64 , unsigned int size )  \n { \n struct etrax_serial * s = opaque ; \n uint32_t value = val64 ; \n unsigned char ch = val64 ; \n D ( CPUCRISState * env = s -> env ) ; \n D ( qemu_log ( \" \" TARGET_FMT_plx \" \\n \" , __func__ , addr , value ) ) ; \n addr >>= 2 ; \n switch ( addr ) \n { \n case RW_DOUT : \n qemu_chr_fe_write ( s -> chr , & ch , 1 ) ; \n s -> regs [ R_INTR ] |= 3 ; \n s -> pending_tx = 1 ; \n s -> regs [ addr ] = value ; \n break ; \n case RW_ACK_INTR : \n if ( s -> pending_tx ) { \n value &= ~ 1 ; \n s -> pending_tx = 0 ; \n D ( qemu_log ( \" \\n \" , \n value , s -> regs [ R_INTR ] ) ) ; \n } \n s -> regs [ addr ] = value ; \n s -> regs [ R_INTR ] &= ~ value ; \n D ( printf ( \" \\n \" , s -> regs [ R_INTR ] ) ) ; \n break ; \n default : \n s -> regs [ addr ] = value ; \n break ; \n } \n ser_update_irq ( s ) ; \n }", "idx": 22189}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_addq_lo ( DisasContext * s , TCGv val , int rlow ) \n { \n TCGv tmp ; \n TCGv tmp2 ; \n tmp = tcg_temp_new ( TCG_TYPE_I64 ) ; \n tmp2 = load_reg ( s , rlow ) ; \n tcg_gen_extu_i32_i64 ( tmp , tmp2 ) ; \n dead_tmp ( tmp2 ) ; \n tcg_gen_add_i64 ( val , val , tmp ) ; \n }", "idx": 22213}
{"project": "qemu", "commit_id": "d2d979c628e4b2c4a3cb71a31841875795c79043", "target": 1, "func": "static void nbd_close ( BlockDriverState * bs ) \n { \n nbd_teardown_connection ( bs ) ; \n }", "idx": 22223}
{"project": "qemu", "commit_id": "5cbab1bfdeab274e5d4e3353fa626ba8697eed10", "target": 1, "func": "static void kvm_s390_flic_realize ( DeviceState * dev , Error * * errp ) \n { \n KVMS390FLICState * flic_state = KVM_S390_FLIC ( dev ) ; \n struct kvm_create_device cd = { 0 } ; \n struct kvm_device_attr test_attr = { 0 } ; \n int ret ; \n Error * errp_local = NULL ; \n flic_state -> fd = -1 ; \n if ( ! kvm_check_extension ( kvm_state , KVM_CAP_DEVICE_CTRL ) ) { \n error_setg_errno ( & errp_local , errno , \" \" \n \" \" ) ; \n trace_flic_no_device_api ( errno ) ; \n cd . type = KVM_DEV_TYPE_FLIC ; \n ret = kvm_vm_ioctl ( kvm_state , KVM_CREATE_DEVICE , & cd ) ; \n if ( ret < 0 ) { \n error_setg_errno ( & errp_local , errno , \" \" ) ; \n trace_flic_create_device ( errno ) ; \n flic_state -> fd = cd . fd ; \n test_attr . group = KVM_DEV_FLIC_CLEAR_IO_IRQ ; \n flic_state -> clear_io_supported = ! ioctl ( flic_state -> fd , \n KVM_HAS_DEVICE_ATTR , test_attr ) ; \n return ; \n fail : \n error_propagate ( errp , errp_local ) ;", "idx": 22236}
{"project": "qemu", "commit_id": "a86156401559cb4401cf9ecc704faeab6fc8bb19", "target": 1, "func": "static void test_visitor_out_empty ( TestOutputVisitorData * data , \n const void * unused ) \n { \n QObject * arg ; \n arg = qmp_output_get_qobject ( data -> qov ) ; \n g_assert ( qobject_type ( arg ) == QTYPE_QNULL ) ; \n qobject_decref ( arg ) ; \n }", "idx": 22244}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "uint32_t gic_acknowledge_irq ( GICState * s , int cpu , MemTxAttrs attrs ) \n { \n int ret , irq , src ; \n int cm = 1 << cpu ; \n irq = gic_get_current_pending_irq ( s , cpu , attrs ) ; \n if ( irq >= GIC_MAXIRQ ) { \n DPRINTF ( \" \\n \" , irq ) ; \n return irq ; \n } \n if ( GIC_GET_PRIORITY ( irq , cpu ) >= s -> running_priority [ cpu ] ) { \n DPRINTF ( \" \\n \" , irq ) ; \n return 1023 ; \n } \n if ( s -> revision == REV_11MPCORE || s -> revision == REV_NVIC ) { \n GIC_CLEAR_PENDING ( irq , GIC_TEST_MODEL ( irq ) ? ALL_CPU_MASK : cm ) ; \n ret = irq ; \n } else { \n if ( irq < GIC_NR_SGIS ) { \n assert ( s -> sgi_pending [ irq ] [ cpu ] != 0 ) ; \n src = ctz32 ( s -> sgi_pending [ irq ] [ cpu ] ) ; \n s -> sgi_pending [ irq ] [ cpu ] &= ~ ( 1 << src ) ; \n if ( s -> sgi_pending [ irq ] [ cpu ] == 0 ) { \n GIC_CLEAR_PENDING ( irq , GIC_TEST_MODEL ( irq ) ? ALL_CPU_MASK : cm ) ; \n } \n ret = irq | ( ( src & 0x7 ) << 10 ) ; \n } else { \n GIC_CLEAR_PENDING ( irq , GIC_TEST_MODEL ( irq ) ? ALL_CPU_MASK : cm ) ; \n ret = irq ; \n } \n } \n gic_activate_irq ( s , cpu , irq ) ; \n gic_update ( s ) ; \n DPRINTF ( \" \\n \" , irq ) ; \n return ret ; \n }", "idx": 22261}
{"project": "qemu", "commit_id": "0e7b176ae01d5a664d4cbf619a7315819494e6cb", "target": 0, "func": "static void aarch64_any_initfn ( Object * obj ) \n { \n ARMCPU * cpu = ARM_CPU ( obj ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_V8 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_VFP4 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_NEON ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_AARCH64 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_V8_AES ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_V8_SHA1 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_V8_SHA256 ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_V8_PMULL ) ; \n set_feature ( & cpu -> env , ARM_FEATURE_CRC ) ; \n cpu -> ctr = 0x80030003 ; \n cpu -> dcz_blocksize = 7 ; \n }", "idx": 22291}
{"project": "qemu", "commit_id": "82342e91b60a4a078811df4e1a545e57abffa11d", "target": 1, "func": "e1000e_set_icr ( E1000ECore * core , int index , uint32_t val )  \n { \n if ( ( core -> mac [ ICR ] & E1000_ICR_ASSERTED ) && \n ( core -> mac [ CTRL_EXT ] & E1000_CTRL_EXT_IAME ) ) { \n trace_e1000e_irq_icr_process_iame ( ) ; \n e1000e_clear_ims_bits ( core , core -> mac [ IAM ] ) ; \n } \n trace_e1000e_irq_icr_write ( val , core -> mac [ ICR ] , core -> mac [ ICR ] & ~ val ) ; \n core -> mac [ ICR ] &= ~ val ; \n e1000e_update_interrupt_state ( core ) ; \n }", "idx": 22315}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "MemoryRegionSection * phys_page_find ( target_phys_addr_t index ) \n { \n PhysPageEntry lp = phys_map ; \n PhysPageEntry * p ; \n int i ; \n uint16_t s_index = phys_section_unassigned ; \n for ( i = P_L2_LEVELS - 1 ; i >= 0 && ! lp . is_leaf ; i -- ) { \n if ( lp . ptr == PHYS_MAP_NODE_NIL ) { \n goto not_found ; \n } \n p = phys_map_nodes [ lp . ptr ] ; \n lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ] ; \n } \n s_index = lp . ptr ; \n not_found : \n return & phys_sections [ s_index ] ; \n }", "idx": 22331}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST ( float_number ) \n { \n int i ; \n struct { \n const char * encoded ; \n double decoded ; \n int skip ; \n } test_cases [ ] = { \n { \" \" , 32.43 } , \n { \" \" , 0.222 } , \n { \" \" , -32.12313 } , \n { \" \" , -32.20e-10 , . skip = 1 } , \n { } , \n } ; \n for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { \n QObject * obj ; \n QFloat * qfloat ; \n obj = qobject_from_json ( test_cases [ i ] . encoded ) ; \n fail_unless ( obj != NULL ) ; \n fail_unless ( qobject_type ( obj ) == QTYPE_QFLOAT ) ; \n qfloat = qobject_to_qfloat ( obj ) ; \n fail_unless ( qfloat_get_double ( qfloat ) == test_cases [ i ] . decoded ) ; \n if ( test_cases [ i ] . skip == 0 ) { \n QString * str ; \n str = qobject_to_json ( obj ) ; \n fail_unless ( strcmp ( qstring_get_str ( str ) , test_cases [ i ] . encoded ) == 0 ) ; \n QDECREF ( str ) ; \n } \n QDECREF ( qfloat ) ; \n } \n }", "idx": 22334}
{"project": "qemu", "commit_id": "488d65772ce94aa439f26d7136db384aec460bcb", "target": 1, "func": "static void check_watchpoint ( int offset , int len_mask , int flags ) \n { \n CPUState * env = cpu_single_env ; \n target_ulong pc , cs_base ; \n TranslationBlock * tb ; \n target_ulong vaddr ; \n CPUWatchpoint * wp ; \n int cpu_flags ; \n if ( env -> watchpoint_hit ) { \n cpu_interrupt ( env , CPU_INTERRUPT_DEBUG ) ; \n return ; \n } \n vaddr = ( env -> mem_io_vaddr & TARGET_PAGE_MASK ) + offset ; \n QTAILQ_FOREACH ( wp , & env -> watchpoints , entry )  { \n if ( ( vaddr == ( wp -> vaddr & len_mask ) || \n ( vaddr & wp -> len_mask ) == wp -> vaddr ) && ( wp -> flags & flags ) ) { \n wp -> flags |= BP_WATCHPOINT_HIT ; \n if ( ! env -> watchpoint_hit ) { \n env -> watchpoint_hit = wp ; \n tb = tb_find_pc ( env -> mem_io_pc ) ; \n if ( ! tb ) { \n cpu_abort ( env , \" \" \n \" \" , ( void * ) env -> mem_io_pc ) ; \n } \n cpu_restore_state ( tb , env , env -> mem_io_pc ) ; \n tb_phys_invalidate ( tb , -1 ) ; \n if ( wp -> flags & BP_STOP_BEFORE_ACCESS ) { \n env -> exception_index = EXCP_DEBUG ; \n } else { \n cpu_get_tb_cpu_state ( env , & pc , & cs_base , & cpu_flags ) ; \n tb_gen_code ( env , pc , cs_base , cpu_flags , 1 ) ; \n } \n cpu_resume_from_signal ( env , NULL ) ; \n } \n } else { \n wp -> flags &= ~ BP_WATCHPOINT_HIT ; \n } \n } \n }", "idx": 22350}
{"project": "qemu", "commit_id": "d4370741402a97b8b6d0c38fef18ab38bf25ab22", "target": 1, "func": "static gboolean gd_vc_in ( GIOChannel * chan , GIOCondition cond , void * opaque ) \n { \n VirtualConsole * vc = opaque ; \n uint8_t buffer [ 1024 ] ; \n ssize_t len ; \n len = read ( vc -> fd , buffer , sizeof ( buffer ) ) ; \n if ( len <= 0 ) { \n return FALSE ; \n } \n qemu_chr_be_write ( vc -> chr , buffer , len ) ; \n return TRUE ; \n }", "idx": 22368}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_write_s32 ( VncState * vs , int32_t value ) \n { \n vnc_write_u32 ( vs , * ( uint32_t * ) & value ) ; \n }", "idx": 22415}
{"project": "qemu", "commit_id": "4828b10bda6a74a22a7695303e0648157d0e3ea4", "target": 0, "func": "void acpi_memory_plug_cb ( ACPIREGS * ar , qemu_irq irq , MemHotplugState * mem_st , \n DeviceState * dev , Error * * errp ) \n { \n MemStatus * mdev ; \n mdev = acpi_memory_slot_status ( mem_st , dev , errp ) ; \n if ( ! mdev ) { \n return ; \n } \n mdev -> dimm = dev ; \n mdev -> is_enabled = true ; \n mdev -> is_inserting = true ; \n acpi_send_gpe_event ( ar , irq , ACPI_MEMORY_HOTPLUG_STATUS ) ; \n return ; \n }", "idx": 22477}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static int vtd_page_walk ( VTDContextEntry * ce , uint64_t start , uint64_t end , \n vtd_page_walk_hook hook_fn , void * private ) \n { \n dma_addr_t addr = vtd_get_slpt_base_from_context ( ce ) ; \n uint32_t level = vtd_get_level_from_context_entry ( ce ) ; \n if ( ! vtd_iova_range_check ( start , ce ) ) { \n return - VTD_FR_ADDR_BEYOND_MGAW ; \n } \n if ( ! vtd_iova_range_check ( end , ce ) ) { \n end = vtd_iova_limit ( ce ) ; \n } \n return vtd_page_walk_level ( addr , start , end , hook_fn , private , \n level , true , true , false ) ; \n }", "idx": 22482}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "static int coroutine_fn bdrv_co_readv_em ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors , \n QEMUIOVector * iov ) \n { \n return bdrv_co_io_em ( bs , sector_num , nb_sectors , iov , false ) ; \n }", "idx": 22483}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_cc_jmp ( TCGv pc_true , TCGv pc_false ) \n { \n TCGv btaken ; \n int l1 ; \n l1 = gen_new_label ( ) ; \n btaken = tcg_temp_new ( TCG_TYPE_TL ) ; \n tcg_gen_mov_tl ( btaken , env_btaken ) ; \n tcg_gen_mov_tl ( env_pc , pc_false ) ; \n tcg_gen_brcondi_tl ( TCG_COND_EQ , btaken , 0 , l1 ) ; \n tcg_gen_mov_tl ( env_pc , pc_true ) ; \n gen_set_label ( l1 ) ; \n tcg_temp_free ( btaken ) ; \n }", "idx": 22546}
{"project": "qemu", "commit_id": "958c717df97ea9ca47a2253b8371130fe5f22980", "target": 0, "func": "NBDClient * nbd_client_new ( NBDExport * exp , int csock , \n void ( * close ) ( NBDClient * ) ) \n { \n NBDClient * client ; \n client = g_malloc0 ( sizeof ( NBDClient ) ) ; \n client -> refcount = 1 ; \n client -> exp = exp ; \n client -> sock = csock ; \n if ( nbd_send_negotiate ( client ) ) { \n g_free ( client ) ; \n return NULL ; \n } \n client -> close = close ; \n qemu_co_mutex_init ( & client -> send_lock ) ; \n qemu_set_fd_handler2 ( csock , nbd_can_read , nbd_read , NULL , client ) ; \n if ( exp ) { \n QTAILQ_INSERT_TAIL ( & exp -> clients , client , next ) ; \n nbd_export_get ( exp ) ; \n } \n return client ; \n }", "idx": 22547}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_ljmp_protected_T0_T1 ( void ) \n { \n int new_cs , new_eip ; \n uint32_t e1 , e2 , cpl , dpl , rpl , limit ; \n new_cs = T0 ; \n new_eip = T1 ; \n if ( ( new_cs & 0xfffc ) == 0 ) \n raise_exception_err ( EXCP0D_GPF , 0 ) ; \n if ( load_segment ( & e1 , & e2 , new_cs ) != 0 ) \n raise_exception_err ( EXCP0D_GPF , new_cs & 0xfffc ) ; \n cpl = env -> hflags & HF_CPL_MASK ; \n if ( e2 & DESC_S_MASK ) { \n if ( ! ( e2 & DESC_CS_MASK ) ) \n raise_exception_err ( EXCP0D_GPF , new_cs & 0xfffc ) ; \n dpl = ( e2 >> DESC_DPL_SHIFT ) & 3 ; \n if ( e2 & DESC_CS_MASK ) { \n if ( dpl > cpl ) \n raise_exception_err ( EXCP0D_GPF , new_cs & 0xfffc ) ; \n } else { \n rpl = new_cs & 3 ; \n if ( rpl > cpl ) \n raise_exception_err ( EXCP0D_GPF , new_cs & 0xfffc ) ; \n if ( dpl != cpl ) \n raise_exception_err ( EXCP0D_GPF , new_cs & 0xfffc ) ; \n } \n if ( ! ( e2 & DESC_P_MASK ) ) \n raise_exception_err ( EXCP0B_NOSEG , new_cs & 0xfffc ) ; \n limit = get_seg_limit ( e1 , e2 ) ; \n if ( new_eip > limit ) \n raise_exception_err ( EXCP0D_GPF , new_cs & 0xfffc ) ; \n cpu_x86_load_seg_cache ( env , R_CS , ( new_cs & 0xfffc ) | cpl , \n get_seg_base ( e1 , e2 ) , limit , e2 ) ; \n EIP = new_eip ; \n } else { \n cpu_abort ( env , \" \" , \n new_cs , new_eip ) ; \n } \n }", "idx": 22553}
{"project": "qemu", "commit_id": "b53dd4495ced2432a0b652ea895e651d07336f7e", "target": 1, "func": "static void usb_xhci_exit ( PCIDevice * dev ) \n { \n int i ; \n XHCIState * xhci = XHCI ( dev ) ; \n trace_usb_xhci_exit ( ) ; \n for ( i = 0 ; i < xhci -> numslots ; i ++ ) { \n xhci_disable_slot ( xhci , i + 1 ) ; \n } \n if ( xhci -> mfwrap_timer ) { \n timer_del ( xhci -> mfwrap_timer ) ; \n timer_free ( xhci -> mfwrap_timer ) ; \n xhci -> mfwrap_timer = NULL ; \n } \n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_cap ) ; \n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_oper ) ; \n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_runtime ) ; \n memory_region_del_subregion ( & xhci -> mem , & xhci -> mem_doorbell ) ; \n for ( i = 0 ; i < xhci -> numports ; i ++ ) { \n XHCIPort * port = & xhci -> ports [ i ] ; \n memory_region_del_subregion ( & xhci -> mem , & port -> mem ) ; \n } \n if ( dev -> msix_table && dev -> msix_pba \n && dev -> msix_entry_used ) { \n memory_region_del_subregion ( & xhci -> mem , & dev -> msix_table_mmio ) ; \n memory_region_del_subregion ( & xhci -> mem , & dev -> msix_pba_mmio ) ; \n } \n usb_bus_release ( & xhci -> bus ) ; \n }", "idx": 22619}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int socket_get_fd ( void * opaque ) \n { \n QEMUFileSocket * s = opaque ; \n return s -> fd ; \n }", "idx": 22666}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_addmeo_64 ( void ) \n { \n T1 = T0 ; \n T0 += xer_ca + ( -1 ) ; \n if ( likely ( ! ( ( uint64_t ) T1 & \n ( ( uint64_t ) T1 ^ ( uint64_t ) T0 ) & ( 1ULL << 63 ) ) ) ) { \n xer_ov = 0 ; \n } else { \n xer_so = 1 ; \n xer_ov = 1 ; \n } \n if ( likely ( T1 != 0 ) ) \n xer_ca = 1 ; \n }", "idx": 22688}
{"project": "qemu", "commit_id": "32c813e6c2a857b93b897901b7e20281397528a3", "target": 0, "func": "size_t qcrypto_cipher_get_key_len ( QCryptoCipherAlgorithm alg ) \n { \n if ( alg >= G_N_ELEMENTS ( alg_key_len ) ) { \n return 0 ; \n } \n return alg_key_len [ alg ] ; \n }", "idx": 22724}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_load_g ( struct fs_dma_ctrl * ctrl , int c ) \n { \n target_phys_addr_t addr = channel_reg ( ctrl , c , RW_GROUP ) ; \n cpu_physical_memory_read ( addr , \n ( void * ) & ctrl -> channels [ c ] . current_g , \n sizeof ctrl -> channels [ c ] . current_g ) ; \n }", "idx": 22753}
{"project": "qemu", "commit_id": "2c5b1d2a479273cec4c1be491745f48b0808b508", "target": 0, "func": "uint32_t HELPER ( rer ) ( CPUXtensaState * env , uint32_t addr ) \n { \n return address_space_ldl ( env -> address_space_er , addr , \n ( MemTxAttrs ) { 0 } , NULL ) ; \n }", "idx": 22774}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void fw_cfg_data_mem_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned size ) \n { \n fw_cfg_write ( opaque , ( uint8_t ) value ) ; \n }", "idx": 22787}
{"project": "qemu", "commit_id": "4d9ebf751a5a98e5dc2e26baf2344e744f4fa7b9", "target": 0, "func": "static void do_cpu_reset ( void * opaque ) \n { \n ARMCPU * cpu = opaque ; \n CPUARMState * env = & cpu -> env ; \n const struct arm_boot_info * info = env -> boot_info ; \n cpu_reset ( CPU ( cpu ) ) ; \n if ( info ) { \n if ( ! info -> is_linux ) { \n env -> regs [ 15 ] = info -> entry & 0xfffffffe ; \n env -> thumb = info -> entry & 1 ; \n } else { \n if ( CPU ( cpu ) == first_cpu ) { \n env -> regs [ 15 ] = info -> loader_start ; \n if ( ! info -> dtb_filename ) { \n if ( old_param ) { \n set_kernel_args_old ( info ) ; \n } else { \n set_kernel_args ( info ) ; \n } \n } \n } else { \n info -> secondary_cpu_reset_hook ( cpu , info ) ; \n } \n } \n } \n }", "idx": 22794}
{"project": "qemu", "commit_id": "cb5ef3fa1871522a0886627033459e94bd537fb7", "target": 1, "func": "static int tmp105_tx ( I2CSlave * i2c , uint8_t data ) \n { \n TMP105State * s = ( TMP105State * ) i2c ; \n if ( ! s -> len ++ ) \n s -> pointer = data ; \n else { \n if ( s -> len <= 2 ) \n s -> buf [ s -> len - 1 ] = data ; \n tmp105_write ( s ) ; \n } \n return 0 ; \n }", "idx": 22837}
{"project": "qemu", "commit_id": "215e79c01c4e6f766eb9add56c56453e9ea1d948", "target": 0, "func": "static bool cpu_thread_is_idle ( CPUState * cpu ) \n { \n if ( cpu -> stop || cpu -> queued_work_first ) { \n return false ; \n } \n if ( cpu -> stopped || ! runstate_is_running ( ) ) { \n return true ; \n } \n if ( ! cpu -> halted || qemu_cpu_has_work ( cpu ) || \n kvm_async_interrupts_enabled ( ) ) { \n return false ; \n } \n return true ; \n }", "idx": 22855}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static inline QEMUClock * qemu_clock_ptr ( QEMUClockType type ) \n { \n return & qemu_clocks [ type ] ; \n }", "idx": 22867}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static VncJobQueue * vnc_queue_init ( void ) \n { \n VncJobQueue * queue = g_malloc0 ( sizeof ( VncJobQueue ) ) ; \n qemu_cond_init ( & queue -> cond ) ; \n qemu_mutex_init ( & queue -> mutex ) ; \n QTAILQ_INIT ( & queue -> jobs ) ; \n return queue ; \n }", "idx": 22954}
{"project": "qemu", "commit_id": "7b35030eedc26eff82210caa2b0fff2f9d0df453", "target": 1, "func": "void test_tls_write_cert_chain ( const char * filename , \n gnutls_x509_crt_t * certs , \n size_t ncerts ) \n { \n size_t i ; \n size_t capacity = 1024 , offset = 0 ; \n char * buffer = g_new0 ( char , capacity ) ; \n int err ; \n for ( i = 0 ; i < ncerts ; i ++ ) { \n size_t len = capacity - offset ; \n retry : \n err = gnutls_x509_crt_export ( certs [ i ] , GNUTLS_X509_FMT_PEM , \n buffer + offset , & len ) ; \n if ( err < 0 ) { \n if ( err == GNUTLS_E_SHORT_MEMORY_BUFFER ) { \n buffer = g_renew ( char , buffer , offset + len ) ; \n capacity = offset + len ; \n goto retry ; \n } \n g_critical ( \" \" , \n gnutls_strerror ( err ) , err ) ; \n abort ( ) ; \n } \n offset += len ; \n } \n if ( ! g_file_set_contents ( filename , buffer , offset , NULL ) ) { \n abort ( ) ; \n } \n }", "idx": 22957}
{"project": "qemu", "commit_id": "eba90e4efc80bc30c7d952ee6ea442207517a0da", "target": 0, "func": "int64_t strtosz_suffix_unit ( const char * nptr , char * * end , \n const char default_suffix , int64_t unit ) \n { \n int64_t retval = -1 ; \n char * endptr ; \n unsigned char c , d ; \n int mul_required = 0 ; \n double val , mul , integral , fraction ; \n errno = 0 ; \n val = strtod ( nptr , & endptr ) ; \n if ( isnan ( val ) || endptr == nptr || errno != 0 ) { \n goto fail ; \n } \n fraction = modf ( val , & integral ) ; \n if ( fraction != 0 ) { \n mul_required = 1 ; \n } \n c = * endptr ; \n d = c ; \n if ( qemu_isspace ( c ) || c == ' \\0 ' || c == ' ' ) { \n c = 0 ; \n d = default_suffix ; \n } \n switch ( qemu_toupper ( d ) ) { \n case STRTOSZ_DEFSUFFIX_B : \n mul = 1 ; \n if ( mul_required ) { \n goto fail ; \n } \n break ; \n case STRTOSZ_DEFSUFFIX_KB : \n mul = unit ; \n break ; \n case STRTOSZ_DEFSUFFIX_MB : \n mul = unit * unit ; \n break ; \n case STRTOSZ_DEFSUFFIX_GB : \n mul = unit * unit * unit ; \n break ; \n case STRTOSZ_DEFSUFFIX_TB : \n mul = unit * unit * unit * unit ; \n break ; \n default : \n goto fail ; \n } \n if ( c != 0 ) { \n endptr ++ ; \n if ( ! qemu_isspace ( * endptr ) && * endptr != ' ' && * endptr != 0 ) { \n goto fail ; \n } \n } \n if ( ( val * mul >= INT64_MAX ) || val < 0 ) { \n goto fail ; \n } \n retval = val * mul ; \n fail : \n if ( end ) { \n * end = endptr ; \n } \n return retval ; \n }", "idx": 23011}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_push_obj ( QmpOutputVisitor * qov , QObject * value , \n void * qapi ) \n { \n QStackEntry * e = g_malloc0 ( sizeof ( * e ) ) ; \n assert ( qov -> root ) ; \n assert ( value ) ; \n e -> value = value ; \n e -> qapi = qapi ; \n QSLIST_INSERT_HEAD ( & qov -> stack , e , node ) ; \n }", "idx": 23015}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int qemu_global_option ( const char * str ) \n { \n char driver [ 64 ] , property [ 64 ] ; \n QemuOpts * opts ; \n int rc , offset ; \n rc = sscanf ( str , \" \" , driver , property , & offset ) ; \n if ( rc < 2 || str [ offset ] != ' ' ) { \n error_report ( \" \\\" \\\" \" , str ) ; \n return -1 ; \n } \n opts = qemu_opts_create ( & qemu_global_opts , NULL , 0 ) ; \n qemu_opt_set ( opts , \" \" , driver ) ; \n qemu_opt_set ( opts , \" \" , property ) ; \n qemu_opt_set ( opts , \" \" , str + offset + 1 ) ; \n return 0 ; \n }", "idx": 23033}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile * qemu_fdopen ( int fd , const char * mode ) \n { \n QEMUFileSocket * s ; \n if ( mode == NULL || \n ( mode [ 0 ] != ' ' && mode [ 0 ] != ' ' ) || \n mode [ 1 ] != ' ' || mode [ 2 ] != 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return NULL ; \n } \n s = g_malloc0 ( sizeof ( QEMUFileSocket ) ) ; \n s -> fd = fd ; \n if ( mode [ 0 ] == ' ' ) { \n s -> file = qemu_fopen_ops ( s , & unix_read_ops ) ; \n } else { \n s -> file = qemu_fopen_ops ( s , & unix_write_ops ) ; \n } \n return s -> file ; \n }", "idx": 23034}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static bool cmd_read_pio ( IDEState * s , uint8_t cmd ) \n { \n bool lba48 = ( cmd == WIN_READ_EXT ) ; \n if ( s -> drive_kind == IDE_CD ) { \n ide_set_signature ( s ) ; \n ide_abort_command ( s ) ; \n return true ; \n } \n if ( ! s -> bs ) { \n ide_abort_command ( s ) ; \n return true ; \n } \n ide_cmd_lba48_transform ( s , lba48 ) ; \n s -> req_nb_sectors = 1 ; \n ide_sector_read ( s ) ; \n return false ; \n }", "idx": 23075}
{"project": "qemu", "commit_id": "25cec2b896a977565ca04e5c649aab8c6e48bda8", "target": 1, "func": "void os_setup_post ( void ) \n { \n int fd = 0 ; \n if ( daemonize ) { \n uint8_t status = 0 ; \n ssize_t len ; \n do { \n len = write ( daemon_pipe , & status , 1 ) ; \n } while ( len < 0 && errno == EINTR ) ; \n if ( len != 1 ) { \n exit ( 1 ) ; \n } \n if ( chdir ( \" \" ) ) { \n perror ( \" \" ) ; \n exit ( 1 ) ; \n } \n TFR ( fd = qemu_open ( \" \" , O_RDWR ) ) ; \n if ( fd == -1 ) { \n exit ( 1 ) ; \n } \n } \n change_root ( ) ; \n change_process_uid ( ) ; \n if ( daemonize ) { \n dup2 ( fd , 0 ) ; \n dup2 ( fd , 1 ) ; \n dup2 ( fd , 2 ) ; \n close ( fd ) ; \n } \n }", "idx": 23093}
{"project": "qemu", "commit_id": "7c08db30e6a43f7083a881eb07bfbc878e001e08", "target": 0, "func": "static int cpu_x86_find_by_name ( X86CPU * cpu , x86_def_t * x86_cpu_def , \n const char * name ) \n { \n x86_def_t * def ; \n int i ; \n if ( name == NULL ) { \n return -1 ; \n } \n if ( kvm_enabled ( ) && strcmp ( name , \" \" ) == 0 ) { \n kvm_cpu_fill_host ( x86_cpu_def ) ; \n object_property_set_bool ( OBJECT ( cpu ) , true , \" \" , & error_abort ) ; \n return 0 ; \n } \n for ( i = 0 ; i < ARRAY_SIZE ( builtin_x86_defs ) ; i ++ ) { \n def = & builtin_x86_defs [ i ] ; \n if ( strcmp ( name , def -> name ) == 0 ) { \n memcpy ( x86_cpu_def , def , sizeof ( * def ) ) ; \n if ( kvm_enabled ( ) ) { \n uint32_t ebx = 0 , ecx = 0 , edx = 0 ; \n host_cpuid ( 0 , 0 , NULL , & ebx , & ecx , & edx ) ; \n x86_cpu_vendor_words2str ( x86_cpu_def -> vendor , ebx , edx , ecx ) ; \n } \n return 0 ; \n } \n } \n return -1 ; \n }", "idx": 23109}
{"project": "qemu", "commit_id": "9005b2a7589540a3733b3abdcfbccfe7746cd1a1", "target": 0, "func": "static int pty_chr_write ( CharDriverState * chr , const uint8_t * buf , int len ) \n { \n PtyCharDriver * s = chr -> opaque ; \n if ( ! s -> connected ) { \n pty_chr_update_read_handler ( chr ) ; \n return 0 ; \n } \n return io_channel_send ( s -> fd , buf , len ) ; \n }", "idx": 23135}
{"project": "qemu", "commit_id": "63ae0915f8ec9746d17a25c27f64cf65550627ab", "target": 0, "func": "static void gen_rlwimi ( DisasContext * ctx ) \n { \n uint32_t mb , me , sh ; \n mb = MB ( ctx -> opcode ) ; \n me = ME ( ctx -> opcode ) ; \n sh = SH ( ctx -> opcode ) ; \n if ( likely ( sh == ( 31 - me ) && mb <= me ) ) { \n tcg_gen_deposit_tl ( cpu_gpr [ rA ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , \n cpu_gpr [ rS ( ctx -> opcode ) ] , sh , me - mb + 1 ) ; \n } else { \n target_ulong mask ; \n TCGv t1 ; \n TCGv t0 = tcg_temp_new ( ) ; \n #if defined ( TARGET_PPC64 )  \n  \n  tcg_gen_deposit_i64 ( t0 , cpu_gpr [ rS ( ctx -> opcode ) ] , \n cpu_gpr [ rS ( ctx -> opcode ) ] , 32 , 32 ) ; \n tcg_gen_rotli_i64 ( t0 , t0 , sh ) ; \n #else \n tcg_gen_rotli_i32 ( t0 , cpu_gpr [ rS ( ctx -> opcode ) ] , sh ) ; \n #endif \n #if defined ( TARGET_PPC64 )  \n  \n  mb += 32 ; \n me += 32 ; \n #endif \n mask = MASK ( mb , me ) ; \n t1 = tcg_temp_new ( ) ; \n tcg_gen_andi_tl ( t0 , t0 , mask ) ; \n tcg_gen_andi_tl ( t1 , cpu_gpr [ rA ( ctx -> opcode ) ] , ~ mask ) ; \n tcg_gen_or_tl ( cpu_gpr [ rA ( ctx -> opcode ) ] , t0 , t1 ) ; \n tcg_temp_free ( t0 ) ; \n tcg_temp_free ( t1 ) ; \n } \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n }", "idx": 23146}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t test_block_write_func ( QCryptoBlock * block , \n void * opaque , \n size_t offset , \n const uint8_t * buf , \n size_t buflen , \n Error * * errp ) \n { \n Buffer * header = opaque ; \n g_assert_cmpint ( buflen + offset , <= , header -> capacity ) ; \n memcpy ( header -> buffer + offset , buf , buflen ) ; \n header -> offset = offset + buflen ; \n return buflen ; \n }", "idx": 23167}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "static ssize_t block_crypto_read_func ( QCryptoBlock * block , \n size_t offset , \n uint8_t * buf , \n size_t buflen , \n Error * * errp , \n void * opaque ) \n { \n BlockDriverState * bs = opaque ; \n ssize_t ret ; \n ret = bdrv_pread ( bs -> file , offset , buf , buflen ) ; \n if ( ret < 0 ) { \n error_setg_errno ( errp , - ret , \" \" ) ; \n return ret ; \n } \n return ret ; \n }", "idx": 23173}
{"project": "qemu", "commit_id": "a5b0f6d5c0f6678c078354c432a1f0943374f087", "target": 0, "func": "static void lm32_cpu_reset ( CPUState * s ) \n { \n LM32CPU * cpu = LM32_CPU ( s ) ; \n LM32CPUClass * lcc = LM32_CPU_GET_CLASS ( cpu ) ; \n CPULM32State * env = & cpu -> env ; \n if ( qemu_loglevel_mask ( CPU_LOG_RESET ) ) { \n qemu_log ( \" \\n \" , s -> cpu_index ) ; \n log_cpu_state ( env , 0 ) ; \n } \n lcc -> parent_reset ( s ) ; \n tlb_flush ( env , 1 ) ; \n memset ( env , 0 , offsetof ( CPULM32State , breakpoints ) ) ; \n }", "idx": 23227}
{"project": "qemu", "commit_id": "b5e85329026115b5a679849f45e7c19c2714e4fd", "target": 1, "func": "uint32_t HELPER ( tprot ) ( CPUS390XState * env , uint64_t a1 , uint64_t a2 ) \n { \n S390CPU * cpu = s390_env_get_cpu ( env ) ; \n CPUState * cs = CPU ( cpu ) ; \n if ( ! s390_cpu_virt_mem_check_write ( cpu , a1 , 0 , 1 ) ) { \n return 0 ; \n } \n switch ( env -> int_pgm_code ) { \n case PGM_PROTECTION : \n cs -> exception_index = 0 ; \n return 1 ; \n case PGM_ADDRESSING : \n cs -> exception_index = 0 ; \n return 2 ; \n case PGM_ASCE_TYPE : \n case PGM_REG_FIRST_TRANS : \n case PGM_REG_SEC_TRANS : \n case PGM_REG_THIRD_TRANS : \n case PGM_SEGMENT_TRANS : \n case PGM_PAGE_TRANS : \n case PGM_ALET_SPEC : \n case PGM_ALEN_SPEC : \n case PGM_ALE_SEQ : \n case PGM_ASTE_VALID : \n case PGM_ASTE_SEQ : \n case PGM_EXT_AUTH : \n cs -> exception_index = 0 ; \n return 3 ; \n } \n s390_cpu_virt_mem_handle_exc ( cpu , GETPC ( ) ) ; \n return 0 ; \n }", "idx": 23292}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_poll ( ADBDevice * d , uint8_t * obuf ) \n { \n KBDState * s = ADB_KEYBOARD ( d ) ; \n int keycode ; \n int olen ; \n olen = 0 ; \n if ( s -> count == 0 ) { \n return 0 ; \n } \n keycode = s -> data [ s -> rptr ] ; \n s -> rptr ++ ; \n if ( s -> rptr == sizeof ( s -> data ) ) { \n s -> rptr = 0 ; \n } \n s -> count -- ; \n if ( keycode == 0x7f ) { \n obuf [ 0 ] = 0x7f ; \n obuf [ 1 ] = 0x7f ; \n olen = 2 ; \n } else { \n obuf [ 0 ] = keycode ; \n obuf [ 1 ] = 0xff ; \n olen = 2 ; \n } \n return olen ; \n }", "idx": 23298}
{"project": "qemu", "commit_id": "1bc04a8880374407c4b12d82ceb8752e12ff5336", "target": 0, "func": "static void pmsav7_write ( CPUARMState * env , const ARMCPRegInfo * ri , \n uint64_t value ) \n { \n ARMCPU * cpu = arm_env_get_cpu ( env ) ; \n uint32_t * u32p = * ( uint32_t * * ) raw_ptr ( env , ri ) ; \n if ( ! u32p ) { \n return ; \n } \n u32p += env -> pmsav7 . rnr ; \n tlb_flush ( CPU ( cpu ) ) ; \n * u32p = value ; \n }", "idx": 23365}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_opts_del ( QemuOpts * opts ) \n { \n QemuOpt * opt ; \n for ( ; ; ) { \n opt = TAILQ_FIRST ( & opts -> head ) ; \n if ( opt == NULL ) \n break ; \n qemu_opt_del ( opt ) ; \n } \n TAILQ_REMOVE ( & opts -> list -> head , opts , next ) ; \n qemu_free ( opts ) ; \n }", "idx": 23366}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "void acpi_pcihp_device_unplug_cb ( HotplugHandler * hotplug_dev , AcpiPciHpState * s , \n DeviceState * dev , Error * * errp ) \n { \n PCIDevice * pdev = PCI_DEVICE ( dev ) ; \n int slot = PCI_SLOT ( pdev -> devfn ) ; \n int bsel = acpi_pcihp_get_bsel ( pdev -> bus ) ; \n if ( bsel < 0 ) { \n error_setg ( errp , \" \" \n ACPI_PCIHP_PROP_BSEL \" \" ) ; \n return ; \n } \n s -> acpi_pcihp_pci_status [ bsel ] . down |= ( 1U << slot ) ; \n acpi_send_event ( DEVICE ( hotplug_dev ) , ACPI_PCI_HOTPLUG_STATUS ) ; \n }", "idx": 23373}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_debug_resume ( BlockDriverState * bs , const char * tag ) \n { \n while ( bs && ( ! bs -> drv || ! bs -> drv -> bdrv_debug_resume ) ) { \n bs = bs -> file ; \n } \n if ( bs && bs -> drv && bs -> drv -> bdrv_debug_resume ) { \n return bs -> drv -> bdrv_debug_resume ( bs , tag ) ; \n } \n return - ENOTSUP ; \n }", "idx": 23379}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mpc8544_guts_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n uint32_t value = 0 ; \n CPUPPCState * env = cpu_single_env ; \n addr &= MPC8544_GUTS_MMIO_SIZE - 1 ; \n switch ( addr ) { \n case MPC8544_GUTS_ADDR_PVR : \n value = env -> spr [ SPR_PVR ] ; \n break ; \n case MPC8544_GUTS_ADDR_SVR : \n value = env -> spr [ SPR_E500_SVR ] ; \n break ; \n default : \n fprintf ( stderr , \" \\n \" , ( int ) addr ) ; \n break ; \n } \n return value ; \n }", "idx": 23394}
{"project": "qemu", "commit_id": "45803a039670cbee914dcb54cf3952f9b2d64d1f", "target": 0, "func": "int bdrv_set_read_only ( BlockDriverState * bs , bool read_only , Error * * errp ) \n { \n if ( bs -> copy_on_read && read_only ) { \n error_setg ( errp , \" \" , \n bdrv_get_device_or_node_name ( bs ) ) ; \n return - EINVAL ; \n } \n if ( ! read_only && ! ( bs -> open_flags & BDRV_O_ALLOW_RDWR ) ) { \n error_setg ( errp , \" \" , \n bdrv_get_device_or_node_name ( bs ) ) ; \n return - EPERM ; \n } \n bs -> read_only = read_only ; \n return 0 ; \n }", "idx": 23396}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "int qemu_savevm_state_begin ( Monitor * mon , QEMUFile * f , int blk_enable , \n int shared ) \n { \n SaveStateEntry * se ; \n int ret ; \n QTAILQ_FOREACH ( se , & savevm_handlers , entry )  { \n if ( se -> set_params == NULL ) { \n continue ; \n } \n se -> set_params ( blk_enable , shared , se -> opaque ) ; \n } \n qemu_put_be32 ( f , QEMU_VM_FILE_MAGIC ) ; \n qemu_put_be32 ( f , QEMU_VM_FILE_VERSION ) ; \n QTAILQ_FOREACH ( se , & savevm_handlers , entry )  { \n int len ; \n if ( se -> save_live_state == NULL ) \n continue ; \n qemu_put_byte ( f , QEMU_VM_SECTION_START ) ; \n qemu_put_be32 ( f , se -> section_id ) ; \n len = strlen ( se -> idstr ) ; \n qemu_put_byte ( f , len ) ; \n qemu_put_buffer ( f , ( uint8_t * ) se -> idstr , len ) ; \n qemu_put_be32 ( f , se -> instance_id ) ; \n qemu_put_be32 ( f , se -> version_id ) ; \n ret = se -> save_live_state ( mon , f , QEMU_VM_SECTION_START , se -> opaque ) ; \n if ( ret < 0 ) { \n qemu_savevm_state_cancel ( mon , f ) ; \n return ret ; \n } \n } \n ret = qemu_file_get_error ( f ) ; \n if ( ret != 0 ) { \n qemu_savevm_state_cancel ( mon , f ) ; \n } \n return ret ; \n }", "idx": 23404}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_jump ( DisasContext * ctx , \n target_ulong ift , target_ulong ifnott ) \n { \n int l1 ; \n TCGv sr ; \n l1 = gen_new_label ( ) ; \n sr = tcg_temp_new ( ) ; \n tcg_gen_andi_i32 ( sr , cpu_sr , SR_T ) ; \n tcg_gen_brcondi_i32 ( TCG_COND_NE , sr , 0 , l1 ) ; \n gen_goto_tb ( ctx , 0 , ifnott ) ; \n gen_set_label ( l1 ) ; \n gen_goto_tb ( ctx , 1 , ift ) ; \n }", "idx": 23409}
{"project": "qemu", "commit_id": "57d84cf35302fe51789c18354bf09a521bb603df", "target": 1, "func": "static void remove_port ( VirtIOSerial * vser , uint32_t port_id ) \n { \n VirtIOSerialPort * port ; \n unsigned int i ; \n i = port_id / 32 ; \n vser -> ports_map [ i ] &= ~ ( 1U << ( port_id % 32 ) ) ; \n port = find_port_by_id ( vser , port_id ) ; \n assert ( port ) ; \n discard_vq_data ( port -> ovq , VIRTIO_DEVICE ( port -> vser ) ) ; \n send_control_event ( vser , port -> id , VIRTIO_CONSOLE_PORT_REMOVE , 1 ) ; \n }", "idx": 23430}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "void bdrv_setup_io_funcs ( BlockDriver * bdrv ) \n { \n if ( ! bdrv -> bdrv_co_readv ) { \n bdrv -> bdrv_co_readv = bdrv_co_readv_em ; \n bdrv -> bdrv_co_writev = bdrv_co_writev_em ; \n if ( ! bdrv -> bdrv_aio_readv ) { \n bdrv -> bdrv_aio_readv = bdrv_aio_readv_em ; \n bdrv -> bdrv_aio_writev = bdrv_aio_writev_em ; \n } \n } \n }", "idx": 23483}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "size_t virtio_serial_guest_ready ( VirtIOSerialPort * port ) \n { \n VirtQueue * vq = port -> ivq ; \n unsigned int bytes ; \n if ( ! virtio_queue_ready ( vq ) || \n ! ( port -> vser -> vdev . status & VIRTIO_CONFIG_S_DRIVER_OK ) || \n virtio_queue_empty ( vq ) ) { \n return 0 ; \n } \n if ( use_multiport ( port -> vser ) && ! port -> guest_connected ) { \n return 0 ; \n } \n virtqueue_get_avail_bytes ( vq , & bytes , NULL ) ; \n return bytes ; \n }", "idx": 23511}
{"project": "qemu", "commit_id": "2d0d2837dcf786da415cf4165d37f4ddd684ff57", "target": 0, "func": "DriveInfo * add_init_drive ( const char * optstr ) \n { \n DriveInfo * dinfo ; \n QemuOpts * opts ; \n opts = drive_def ( optstr ) ; \n if ( ! opts ) \n return NULL ; \n dinfo = drive_init ( opts , current_machine -> use_scsi ) ; \n if ( ! dinfo ) { \n qemu_opts_del ( opts ) ; \n return NULL ; \n } \n return dinfo ; \n }", "idx": 23520}
{"project": "qemu", "commit_id": "e912c96f7d2e5ccd8a6352ee74f5beee2a7d9976", "target": 0, "func": "static BusState * qbus_find_recursive ( BusState * bus , const char * name , \n const char * bus_typename ) \n { \n BusChild * kid ; \n BusState * child , * ret ; \n int match = 1 ; \n if ( name && ( strcmp ( bus -> name , name ) != 0 ) ) { \n match = 0 ; \n } \n if ( bus_typename && \n ( strcmp ( object_get_typename ( OBJECT ( bus ) ) , bus_typename ) != 0 ) ) { \n match = 0 ; \n } \n if ( match ) { \n return bus ; \n } \n QTAILQ_FOREACH ( kid , & bus -> children , sibling )  { \n DeviceState * dev = kid -> child ; \n QLIST_FOREACH ( child , & dev -> child_bus , sibling )  { \n ret = qbus_find_recursive ( child , name , bus_typename ) ; \n if ( ret ) { \n return ret ; \n } \n } \n } \n return NULL ; \n }", "idx": 23523}
{"project": "qemu", "commit_id": "ee312992a323530ea2cda8680f3a34746c72db8f", "target": 0, "func": "void qemu_input_event_sync ( void ) \n { \n QemuInputHandlerState * s ; \n if ( ! runstate_is_running ( ) && ! runstate_check ( RUN_STATE_SUSPENDED ) ) { \n return ; \n } \n trace_input_event_sync ( ) ; \n QTAILQ_FOREACH ( s , & handlers , node )  { \n if ( ! s -> events ) { \n continue ; \n } \n if ( s -> handler -> sync ) { \n s -> handler -> sync ( s -> dev ) ; \n } \n s -> events = 0 ; \n } \n }", "idx": 23545}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int64 ( TestInputVisitorData * data , \n const void * unused ) \n { \n test_native_list_integer_helper ( data , unused , \n USER_DEF_NATIVE_LIST_UNION_KIND_S64 ) ; \n }", "idx": 23589}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qint_destroy_obj ( QObject * obj ) \n { \n assert ( obj != NULL ) ; \n g_free ( qobject_to_qint ( obj ) ) ; \n }", "idx": 23590}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "int ioinst_handle_tsch ( S390CPU * cpu , uint64_t reg1 , uint32_t ipb ) \n { \n CPUS390XState * env = & cpu -> env ; \n int cssid , ssid , schid , m ; \n SubchDev * sch ; \n IRB irb ; \n uint64_t addr ; \n int cc , irb_len ; \n uint8_t ar ; \n if ( ioinst_disassemble_sch_ident ( reg1 , & m , & cssid , & ssid , & schid ) ) { \n program_interrupt ( env , PGM_OPERAND , 2 ) ; \n return - EIO ; \n } \n trace_ioinst_sch_id ( \" \" , cssid , ssid , schid ) ; \n addr = decode_basedisp_s ( env , ipb , & ar ) ; \n if ( addr & 3 ) { \n program_interrupt ( env , PGM_SPECIFICATION , 2 ) ; \n return - EIO ; \n } \n sch = css_find_subch ( m , cssid , ssid , schid ) ; \n if ( sch && css_subch_visible ( sch ) ) { \n cc = css_do_tsch_get_irb ( sch , & irb , & irb_len ) ; \n } else { \n cc = 3 ; \n } \n if ( cc != 3 ) { \n if ( s390_cpu_virt_mem_write ( cpu , addr , ar , & irb , irb_len ) != 0 ) { \n return - EFAULT ; \n } \n css_do_tsch_update_subch ( sch ) ; \n } else { \n irb_len = sizeof ( irb ) - sizeof ( irb . emw ) ; \n if ( s390_cpu_virt_mem_check_write ( cpu , addr , ar , irb_len ) != 0 ) { \n return - EFAULT ; \n } \n } \n setcc ( cpu , cc ) ; \n return 0 ; \n }", "idx": 23594}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static ssize_t v9fs_synth_pwritev ( FsContext * ctx , V9fsFidOpenState * fs , \n const struct iovec * iov , \n int iovcnt , off_t offset ) \n { \n int i , count = 0 , wcount ; \n V9fsSynthOpenState * synth_open = fs -> private ; \n V9fsSynthNode * node = synth_open -> node ; \n if ( ! node -> attr -> write ) { \n errno = EPERM ; \n return -1 ; \n } \n for ( i = 0 ; i < iovcnt ; i ++ ) { \n wcount = node -> attr -> write ( iov [ i ] . iov_base , iov [ i ] . iov_len , \n offset , node -> private ) ; \n offset += wcount ; \n count += wcount ; \n if ( wcount < iov [ i ] . iov_len ) { \n break ; \n } \n } \n return count ; \n }", "idx": 23616}
{"project": "qemu", "commit_id": "153eba4726dfa1bdfc31d1fe973b2a61b9035492", "target": 0, "func": "static void piix4_device_unplug_request_cb ( HotplugHandler * hotplug_dev , \n DeviceState * dev , Error * * errp ) \n { \n PIIX4PMState * s = PIIX4_PM ( hotplug_dev ) ; \n if ( s -> acpi_memory_hotplug . is_enabled && \n object_dynamic_cast ( OBJECT ( dev ) , TYPE_PC_DIMM ) ) { \n acpi_memory_unplug_request_cb ( hotplug_dev , & s -> acpi_memory_hotplug , \n dev , errp ) ; \n } else if ( object_dynamic_cast ( OBJECT ( dev ) , TYPE_PCI_DEVICE ) ) { \n acpi_pcihp_device_unplug_cb ( hotplug_dev , & s -> acpi_pci_hotplug , dev , \n errp ) ; \n } else if ( object_dynamic_cast ( OBJECT ( dev ) , TYPE_CPU ) && \n ! s -> cpu_hotplug_legacy ) { \n acpi_cpu_unplug_request_cb ( hotplug_dev , & s -> cpuhp_state , dev , errp ) ; \n } else { \n error_setg ( errp , \" \" \n \" \" , object_get_typename ( OBJECT ( dev ) ) ) ; \n } \n }", "idx": 23621}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static void ohci_td_pkt ( const char * msg , const uint8_t * buf , size_t len ) \n { \n bool print16 = ! ! trace_event_get_state ( TRACE_USB_OHCI_TD_PKT_SHORT ) ; \n bool printall = ! ! trace_event_get_state ( TRACE_USB_OHCI_TD_PKT_FULL ) ; \n const int width = 16 ; \n int i ; \n char tmp [ 3 * width + 1 ] ; \n char * p = tmp ; \n if ( ! printall && ! print16 ) { \n return ; \n } \n for ( i = 0 ; ; i ++ ) { \n if ( i && ( ! ( i % width ) || ( i == len ) ) ) { \n if ( ! printall ) { \n trace_usb_ohci_td_pkt_short ( msg , tmp ) ; \n break ; \n } \n trace_usb_ohci_td_pkt_full ( msg , tmp ) ; \n p = tmp ; \n * p = 0 ; \n } \n if ( i == len ) { \n break ; \n } \n p += sprintf ( p , \" \" , buf [ i ] ) ; \n } \n }", "idx": 23663}
{"project": "qemu", "commit_id": "9ea63c05d90ba85d819f9b2472ce6dfba7a403b4", "target": 0, "func": "int do_subchannel_work_virtual ( SubchDev * sch ) \n { \n SCSW * s = & sch -> curr_status . scsw ; \n if ( s -> ctrl & SCSW_FCTL_CLEAR_FUNC ) { \n sch_handle_clear_func ( sch ) ; \n } else if ( s -> ctrl & SCSW_FCTL_HALT_FUNC ) { \n sch_handle_halt_func ( sch ) ; \n } else if ( s -> ctrl & SCSW_FCTL_START_FUNC ) { \n sch_handle_start_func_virtual ( sch ) ; \n } else { \n return 0 ; \n } \n css_inject_io_interrupt ( sch ) ; \n return 0 ; \n }", "idx": 23682}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static inline uint64_t ldq_phys_internal ( target_phys_addr_t addr , \n enum device_endian endian ) \n { \n uint8_t * ptr ; \n uint64_t val ; \n MemoryRegionSection * section ; \n section = phys_page_find ( address_space_memory . dispatch , addr >> TARGET_PAGE_BITS ) ; \n if ( ! ( memory_region_is_ram ( section -> mr ) || \n memory_region_is_romd ( section -> mr ) ) ) { \n addr = memory_region_section_addr ( section , addr ) ; \n #ifdef TARGET_WORDS_BIGENDIAN \n val = io_mem_read ( section -> mr , addr , 4 ) << 32 ; \n val |= io_mem_read ( section -> mr , addr + 4 , 4 ) ; \n #else \n val = io_mem_read ( section -> mr , addr , 4 ) ; \n val |= io_mem_read ( section -> mr , addr + 4 , 4 ) << 32 ; \n #endif \n } else { \n ptr = qemu_get_ram_ptr ( ( memory_region_get_ram_addr ( section -> mr ) \n & TARGET_PAGE_MASK ) \n + memory_region_section_addr ( section , addr ) ) ; \n switch ( endian ) { \n case DEVICE_LITTLE_ENDIAN : \n val = ldq_le_p ( ptr ) ; \n break ; \n case DEVICE_BIG_ENDIAN : \n val = ldq_be_p ( ptr ) ; \n break ; \n default : \n val = ldq_p ( ptr ) ; \n break ; \n } \n } \n return val ; \n }", "idx": 23686}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_reopen_prepare ( BDRVReopenState * reopen_state , \n BlockReopenQueue * queue , Error * * errp ) \n { \n assert ( reopen_state != NULL ) ; \n assert ( reopen_state -> bs != NULL ) ; \n reopen_state -> opaque = g_new0 ( BDRVRawState , 1 ) ; \n return raw_read_options ( \n reopen_state -> options , \n reopen_state -> bs , \n reopen_state -> opaque , \n errp ) ; \n }", "idx": 23689}
{"project": "qemu", "commit_id": "e829b0bb054ed3389e5b22dad61875e51674e629", "target": 1, "func": "iscsi_readcapacity16_cb ( struct iscsi_context *  iscsi , int  status , \n void * command_data , void * opaque ) \n { \n struct IscsiTask * itask = opaque ; \n struct scsi_readcapacity16 * rc16 ; \n struct scsi_task * task = command_data ; \n if ( status != 0 ) { \n error_report ( \" \" , \n iscsi_get_error ( iscsi ) ) ; \n itask -> status = 1 ; \n itask -> complete = 1 ; \n scsi_free_scsi_task ( task ) ; \n return ; \n } \n rc16 = scsi_datain_unmarshall ( task ) ; \n if ( rc16 == NULL ) { \n error_report ( \" \" ) ; \n itask -> status = 1 ; \n itask -> complete = 1 ; \n scsi_free_scsi_task ( task ) ; \n return ; \n } \n itask -> iscsilun -> block_size = rc16 -> block_length ; \n itask -> iscsilun -> num_blocks = rc16 -> returned_lba + 1 ; \n itask -> bs -> total_sectors = itask -> iscsilun -> num_blocks * \n itask -> iscsilun -> block_size / BDRV_SECTOR_SIZE ; \n itask -> status = 0 ; \n itask -> complete = 1 ; \n scsi_free_scsi_task ( task ) ; \n }", "idx": 23727}
{"project": "qemu", "commit_id": "765a707000e838c30b18d712fe6cb3dd8e0435f3", "target": 1, "func": "static int megasas_map_dcmd ( MegasasState * s , MegasasCmd * cmd ) \n { \n dma_addr_t iov_pa , iov_size ; \n cmd -> flags = le16_to_cpu ( cmd -> frame -> header . flags ) ; \n if ( ! cmd -> frame -> header . sge_count ) { \n trace_megasas_dcmd_zero_sge ( cmd -> index ) ; \n cmd -> iov_size = 0 ; \n return 0 ; \n } else if ( cmd -> frame -> header . sge_count > 1 ) { \n trace_megasas_dcmd_invalid_sge ( cmd -> index , \n cmd -> frame -> header . sge_count ) ; \n cmd -> iov_size = 0 ; \n return -1 ; \n } \n iov_pa = megasas_sgl_get_addr ( cmd , & cmd -> frame -> dcmd . sgl ) ; \n iov_size = megasas_sgl_get_len ( cmd , & cmd -> frame -> dcmd . sgl ) ; \n pci_dma_sglist_init ( & cmd -> qsg , PCI_DEVICE ( s ) , 1 ) ; \n qemu_sglist_add ( & cmd -> qsg , iov_pa , iov_size ) ; \n cmd -> iov_size = iov_size ; \n return cmd -> iov_size ; \n }", "idx": 23761}
{"project": "qemu", "commit_id": "4b9b7092b4cbef084138a446b8247ba89fd474f4", "target": 1, "func": "static void cdrom_change_cb ( void * opaque , int reason ) \n { \n IDEState * s = opaque ; \n uint64_t nb_sectors ; \n if ( ! ( reason & CHANGE_MEDIA ) ) { \n return ; \n } \n bdrv_get_geometry ( s -> bs , & nb_sectors ) ; \n s -> nb_sectors = nb_sectors ; \n s -> sense_key = SENSE_UNIT_ATTENTION ; \n s -> asc = ASC_MEDIUM_MAY_HAVE_CHANGED ; \n s -> cdrom_changed = 1 ; \n s -> events . new_media = true ; \n ide_set_irq ( s -> bus ) ; \n }", "idx": 23772}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "func": "static int xen_host_pci_sysfs_path ( const XenHostPCIDevice * d , \n const char * name , char * buf , ssize_t size ) \n { \n int rc ; \n rc = snprintf ( buf , size , \" \" , \n d -> domain , d -> bus , d -> dev , d -> func , name ) ; \n if ( rc >= size || rc < 0 ) { \n return - ENODEV ; \n } \n return 0 ; \n }", "idx": 23806}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_union_native_list ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefNativeListUnion * tmp = NULL ; \n Error * err = NULL ; \n Visitor * v ; \n v = validate_test_init ( data , \n \" \" ) ; \n visit_type_UserDefNativeListUnion ( v , NULL , & tmp , & err ) ; \n error_free_or_abort ( & err ) ; \n g_assert ( ! tmp ) ; \n }", "idx": 23822}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_msix_disable ( QPCIDevice * dev ) \n { \n uint8_t addr ; \n uint16_t val ; \n g_assert ( dev -> msix_enabled ) ; \n addr = qpci_find_capability ( dev , PCI_CAP_ID_MSIX ) ; \n g_assert_cmphex ( addr , ! = , 0 ) ; \n val = qpci_config_readw ( dev , addr + PCI_MSIX_FLAGS ) ; \n qpci_config_writew ( dev , addr + PCI_MSIX_FLAGS , \n val & ~ PCI_MSIX_FLAGS_ENABLE ) ; \n qpci_iounmap ( dev , dev -> msix_table ) ; \n qpci_iounmap ( dev , dev -> msix_pba ) ; \n dev -> msix_enabled = 0 ; \n dev -> msix_table = NULL ; \n dev -> msix_pba = NULL ; \n }", "idx": 23841}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_rtc_s * omap_rtc_init ( MemoryRegion * system_memory , \n target_phys_addr_t base , \n qemu_irq timerirq , qemu_irq alarmirq , \n omap_clk clk ) \n { \n struct omap_rtc_s * s = ( struct omap_rtc_s * ) \n g_malloc0 ( sizeof ( struct omap_rtc_s ) ) ; \n s -> irq = timerirq ; \n s -> alarm = alarmirq ; \n s -> clk = qemu_new_timer_ms ( rtc_clock , omap_rtc_tick , s ) ; \n omap_rtc_reset ( s ) ; \n memory_region_init_io ( & s -> iomem , & omap_rtc_ops , s , \n \" \" , 0x800 ) ; \n memory_region_add_subregion ( system_memory , base , & s -> iomem ) ; \n return s ; \n }", "idx": 23847}
{"project": "qemu", "commit_id": "ccf1e2dcd6091eea1fc2341c63201aa1a6094978", "target": 0, "func": "static ssize_t qio_channel_socket_writev ( QIOChannel * ioc , \n const struct iovec * iov , \n size_t niov , \n int * fds , \n size_t nfds , \n Error * * errp ) \n { \n QIOChannelSocket * sioc = QIO_CHANNEL_SOCKET ( ioc ) ; \n ssize_t ret ; \n struct msghdr msg = { NULL , } ; \n char control [ CMSG_SPACE ( sizeof ( int ) * SOCKET_MAX_FDS ) ] = { 0 } ; \n size_t fdsize = sizeof ( int ) * nfds ; \n struct cmsghdr * cmsg ; \n msg . msg_iov = ( struct iovec * ) iov ; \n msg . msg_iovlen = niov ; \n if ( nfds ) { \n if ( nfds > SOCKET_MAX_FDS ) { \n error_setg_errno ( errp , EINVAL , \n \" \" , \n SOCKET_MAX_FDS , nfds ) ; \n return -1 ; \n } \n msg . msg_control = control ; \n msg . msg_controllen = CMSG_SPACE ( sizeof ( int ) * nfds ) ; \n cmsg = CMSG_FIRSTHDR ( & msg ) ; \n cmsg -> cmsg_len = CMSG_LEN ( fdsize ) ; \n cmsg -> cmsg_level = SOL_SOCKET ; \n cmsg -> cmsg_type = SCM_RIGHTS ; \n memcpy ( CMSG_DATA ( cmsg ) , fds , fdsize ) ; \n } \n retry : \n ret = sendmsg ( sioc -> fd , & msg , 0 ) ; \n if ( ret <= 0 ) { \n if ( socket_error ( ) == EAGAIN || \n socket_error ( ) == EWOULDBLOCK ) { \n return QIO_CHANNEL_ERR_BLOCK ; \n } \n if ( socket_error ( ) == EINTR ) { \n goto retry ; \n } \n error_setg_errno ( errp , socket_error ( ) , \n \" \" ) ; \n return -1 ; \n } \n return ret ; \n }", "idx": 23849}
{"project": "qemu", "commit_id": "9167a69a816b8956d62da628b5b4dc87674647d6", "target": 0, "func": "void * lsi_scsi_init ( PCIBus * bus , int devfn ) \n { \n LSIState * s ; \n s = ( LSIState * ) pci_register_device ( bus , \" \" , \n sizeof ( * s ) , devfn , NULL , NULL ) ; \n if ( s == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n return NULL ; \n } \n s -> pci_dev . config [ 0x00 ] = 0x00 ; \n s -> pci_dev . config [ 0x01 ] = 0x10 ; \n s -> pci_dev . config [ 0x02 ] = 0x12 ; \n s -> pci_dev . config [ 0x03 ] = 0x00 ; \n s -> pci_dev . config [ 0x0b ] = 0x01 ; \n s -> pci_dev . config [ 0x3d ] = 0x01 ; \n s -> mmio_io_addr = cpu_register_io_memory ( 0 , lsi_mmio_readfn , \n lsi_mmio_writefn , s ) ; \n s -> ram_io_addr = cpu_register_io_memory ( 0 , lsi_ram_readfn , \n lsi_ram_writefn , s ) ; \n pci_register_io_region ( ( struct PCIDevice * ) s , 0 , 256 , \n PCI_ADDRESS_SPACE_IO , lsi_io_mapfunc ) ; \n pci_register_io_region ( ( struct PCIDevice * ) s , 1 , 0x400 , \n PCI_ADDRESS_SPACE_MEM , lsi_mmio_mapfunc ) ; \n pci_register_io_region ( ( struct PCIDevice * ) s , 2 , 0x2000 , \n PCI_ADDRESS_SPACE_MEM , lsi_ram_mapfunc ) ; \n s -> queue = qemu_malloc ( sizeof ( lsi_queue ) ) ; \n s -> queue_len = 1 ; \n s -> active_commands = 0 ; \n lsi_soft_reset ( s ) ; \n return s ; \n }", "idx": 23861}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static void vnc_refresh ( DisplayChangeListener * dcl ) \n { \n VncDisplay * vd = container_of ( dcl , VncDisplay , dcl ) ; \n VncState * vs , * vn ; \n int has_dirty , rects = 0 ; \n graphic_hw_update ( NULL ) ; \n if ( vnc_trylock_display ( vd ) ) { \n update_displaychangelistener ( & vd -> dcl , VNC_REFRESH_INTERVAL_BASE ) ; \n return ; \n } \n has_dirty = vnc_refresh_server_surface ( vd ) ; \n vnc_unlock_display ( vd ) ; \n QTAILQ_FOREACH_SAFE ( vs , & vd -> clients , next , vn )  { \n rects += vnc_update_client ( vs , has_dirty ) ; \n } \n if ( QTAILQ_EMPTY ( & vd -> clients ) ) { \n update_displaychangelistener ( & vd -> dcl , VNC_REFRESH_INTERVAL_MAX ) ; \n return ; \n } \n if ( has_dirty && rects ) { \n vd -> dcl . update_interval /= 2 ; \n if ( vd -> dcl . update_interval < VNC_REFRESH_INTERVAL_BASE ) { \n vd -> dcl . update_interval = VNC_REFRESH_INTERVAL_BASE ; \n } \n } else { \n vd -> dcl . update_interval += VNC_REFRESH_INTERVAL_INC ; \n if ( vd -> dcl . update_interval > VNC_REFRESH_INTERVAL_MAX ) { \n vd -> dcl . update_interval = VNC_REFRESH_INTERVAL_MAX ; \n } \n } \n }", "idx": 23894}
{"project": "qemu", "commit_id": "751f8cfe2a556b3ef49f6af2860e2d1d2a1ec66a", "target": 1, "func": "int monitor_set_cpu ( int cpu_index ) \n { \n CPUState * cpu ; \n cpu = qemu_get_cpu ( cpu_index ) ; \n if ( cpu == NULL ) { \n return -1 ; \n } \n cur_mon -> mon_cpu = cpu ; \n return 0 ; \n }", "idx": 23911}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "uint32_t HELPER ( mul32 ) ( CPUOpenRISCState * env , \n uint32_t ra , uint32_t rb ) \n { \n uint64_t result ; \n uint32_t high , cy ; \n OpenRISCCPU * cpu = openrisc_env_get_cpu ( env ) ; \n result = ( uint64_t ) ra * rb ; \n high = result >> 32 ; \n cy = result >> ( 32 - 1 ) ; \n if ( ( cy & 0x1 ) == 0x0 ) { \n if ( high == 0x0 ) { \n return result ; \n } \n } \n if ( ( cy & 0x1 ) == 0x1 ) { \n if ( high == 0xffffffff ) { \n return result ; \n } \n } \n cpu -> env . sr |= ( SR_OV | SR_CY ) ; \n if ( cpu -> env . sr & SR_OVE ) { \n raise_exception ( cpu , EXCP_RANGE ) ; \n } \n return result ; \n }", "idx": 23949}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER ( ucf64_sf2df ) ( float32 x , CPUUniCore32State * env ) \n { \n return float32_to_float64 ( x , & env -> ucf64 . fp_status ) ; \n }", "idx": 24042}
{"project": "qemu", "commit_id": "30656b097e9dd7978d3fe9416cb9f5a421a9e63e", "target": 0, "func": "static ssize_t colo_rewriter_receive_iov ( NetFilterState * nf , \n NetClientState * sender , \n unsigned flags , \n const struct iovec * iov , \n int iovcnt , \n NetPacketSent * sent_cb ) \n { \n RewriterState * s = FILTER_COLO_REWRITER ( nf ) ; \n Connection * conn ; \n ConnectionKey key ; \n Packet * pkt ; \n ssize_t size = iov_size ( iov , iovcnt ) ; \n char * buf = g_malloc0 ( size ) ; \n iov_to_buf ( iov , iovcnt , 0 , buf , size ) ; \n pkt = packet_new ( buf , size ) ; \n if ( pkt && is_tcp_packet ( pkt ) ) { \n fill_connection_key ( pkt , & key ) ; \n if ( sender == nf -> netdev ) { \n reverse_connection_key ( & key ) ; \n } \n conn = connection_get ( s -> connection_track_table , \n & key , \n NULL ) ; \n if ( sender == nf -> netdev ) { \n } else { \n } \n } \n packet_destroy ( pkt , NULL ) ; \n pkt = NULL ; \n return 0 ; \n }", "idx": 24046}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_out ( HWVoiceOut * hw , struct audsettings * as ) \n { \n ALSAVoiceOut * alsa = ( ALSAVoiceOut * ) hw ; \n struct alsa_params_req req ; \n struct alsa_params_obt obt ; \n snd_pcm_t * handle ; \n struct audsettings obt_as ; \n req . fmt = aud_to_alsafmt ( as -> fmt , as -> endianness ) ; \n req . freq = as -> freq ; \n req . nchannels = as -> nchannels ; \n req . period_size = conf . period_size_out ; \n req . buffer_size = conf . buffer_size_out ; \n req . size_in_usec = conf . size_in_usec_out ; \n req . override_mask = \n ( conf . period_size_out_overridden ? 1 : 0 ) | \n ( conf . buffer_size_out_overridden ? 2 : 0 ) ; \n if ( alsa_open ( 0 , & req , & obt , & handle ) ) { \n return -1 ; \n } \n obt_as . freq = obt . freq ; \n obt_as . nchannels = obt . nchannels ; \n obt_as . fmt = obt . fmt ; \n obt_as . endianness = obt . endianness ; \n audio_pcm_init_info ( & hw -> info , & obt_as ) ; \n hw -> samples = obt . samples ; \n alsa -> pcm_buf = audio_calloc ( AUDIO_FUNC , obt . samples , 1 << hw -> info . shift ) ; \n if ( ! alsa -> pcm_buf ) { \n dolog ( \" \\n \" , \n hw -> samples , 1 << hw -> info . shift ) ; \n alsa_anal_close1 ( & handle ) ; \n return -1 ; \n } \n alsa -> handle = handle ; \n return 0 ; \n }", "idx": 24066}
{"project": "qemu", "commit_id": "60dcbcb5b1a0d185be607b03fc7a15bf1bab4bec", "target": 0, "func": "static abi_ulong setup_arg_pages ( abi_ulong p , struct linux_binprm * bprm , \n struct image_info * info ) \n { \n abi_ulong stack_base , size , error ; \n int i ; \n size = guest_stack_size ; \n if ( size < MAX_ARG_PAGES * TARGET_PAGE_SIZE ) \n size = MAX_ARG_PAGES * TARGET_PAGE_SIZE ; \n error = target_mmap ( 0 , \n size + qemu_host_page_size , \n PROT_READ | PROT_WRITE , \n MAP_PRIVATE | MAP_ANONYMOUS , \n -1 , 0 ) ; \n if ( error == -1 ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n target_mprotect ( error + size , qemu_host_page_size , PROT_NONE ) ; \n info -> stack_limit = error ; \n stack_base = error + size - MAX_ARG_PAGES * TARGET_PAGE_SIZE ; \n p += stack_base ; \n for ( i = 0 ; i < MAX_ARG_PAGES ; i ++ ) { \n if ( bprm -> page [ i ] ) { \n info -> rss ++ ; \n memcpy_to_target ( stack_base , bprm -> page [ i ] , TARGET_PAGE_SIZE ) ; \n free ( bprm -> page [ i ] ) ; \n } \n stack_base += TARGET_PAGE_SIZE ; \n } \n return p ; \n }", "idx": 24089}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static size_t handle_aiocb_rw_vector ( struct qemu_paiocb * aiocb ) \n { \n size_t offset = 0 ; \n ssize_t len ; \n do { \n if ( aiocb -> aio_type == QEMU_PAIO_WRITE ) \n len = qemu_pwritev ( aiocb -> aio_fildes , \n aiocb -> aio_iov , \n aiocb -> aio_niov , \n aiocb -> aio_offset + offset ) ; \n else \n len = qemu_preadv ( aiocb -> aio_fildes , \n aiocb -> aio_iov , \n aiocb -> aio_niov , \n aiocb -> aio_offset + offset ) ; \n } while ( len == -1 && errno == EINTR ) ; \n if ( len == -1 ) \n return - errno ; \n return len ; \n }", "idx": 24095}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static VncClientInfo * qmp_query_vnc_client ( const VncState * client ) \n { \n struct sockaddr_storage sa ; \n socklen_t salen = sizeof ( sa ) ; \n char host [ NI_MAXHOST ] ; \n char serv [ NI_MAXSERV ] ; \n VncClientInfo * info ; \n if ( getpeername ( client -> csock , ( struct sockaddr * ) & sa , & salen ) < 0 ) { \n return NULL ; \n } \n if ( getnameinfo ( ( struct sockaddr * ) & sa , salen , \n host , sizeof ( host ) , \n serv , sizeof ( serv ) , \n NI_NUMERICHOST | NI_NUMERICSERV ) < 0 ) { \n return NULL ; \n } \n info = g_malloc0 ( sizeof ( * info ) ) ; \n info -> base = g_malloc0 ( sizeof ( * info -> base ) ) ; \n info -> base -> host = g_strdup ( host ) ; \n info -> base -> service = g_strdup ( serv ) ; \n info -> base -> family = inet_netfamily ( sa . ss_family ) ; \n info -> base -> websocket = client -> websocket ; \n #ifdef CONFIG_VNC_TLS \n if ( client -> tls . session && client -> tls . dname ) { \n info -> has_x509_dname = true ; \n info -> x509_dname = g_strdup ( client -> tls . dname ) ; \n } \n #endif \n #ifdef CONFIG_VNC_SASL \n if ( client -> sasl . conn && client -> sasl . username ) { \n info -> has_sasl_username = true ; \n info -> sasl_username = g_strdup ( client -> sasl . username ) ; \n } \n #endif \n return info ; \n }", "idx": 24114}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "int kvm_arch_put_registers ( CPUState * env ) \n { \n struct kvm_regs regs ; \n int ret ; \n int i ; \n ret = kvm_vcpu_ioctl ( env , KVM_GET_REGS , & regs ) ; \n if ( ret < 0 ) \n return ret ; \n regs . ctr = env -> ctr ; \n regs . lr = env -> lr ; \n regs . xer = env -> xer ; \n regs . msr = env -> msr ; \n regs . pc = env -> nip ; \n regs . srr0 = env -> spr [ SPR_SRR0 ] ; \n regs . srr1 = env -> spr [ SPR_SRR1 ] ; \n regs . sprg0 = env -> spr [ SPR_SPRG0 ] ; \n regs . sprg1 = env -> spr [ SPR_SPRG1 ] ; \n regs . sprg2 = env -> spr [ SPR_SPRG2 ] ; \n regs . sprg3 = env -> spr [ SPR_SPRG3 ] ; \n regs . sprg4 = env -> spr [ SPR_SPRG4 ] ; \n regs . sprg5 = env -> spr [ SPR_SPRG5 ] ; \n regs . sprg6 = env -> spr [ SPR_SPRG6 ] ; \n regs . sprg7 = env -> spr [ SPR_SPRG7 ] ; \n for ( i = 0 ; i < 32 ; i ++ ) \n regs . gpr [ i ] = env -> gpr [ i ] ; \n ret = kvm_vcpu_ioctl ( env , KVM_SET_REGS , & regs ) ; \n if ( ret < 0 ) \n return ret ; \n return ret ; \n }", "idx": 24117}
{"project": "qemu", "commit_id": "5b5cb08683b6715a2aca5314168e68ff0665912b", "target": 0, "func": "static void msix_mmio_writel ( void * opaque , target_phys_addr_t addr , \n uint32_t val ) \n { \n PCIDevice * dev = opaque ; \n unsigned int offset = addr & ( MSIX_PAGE_SIZE - 1 ) & ~ 0x3 ; \n int vector = offset / MSIX_ENTRY_SIZE ; \n pci_set_long ( dev -> msix_table_page + offset , val ) ; \n if ( ! msix_is_masked ( dev , vector ) && msix_is_pending ( dev , vector ) ) { \n msix_clr_pending ( dev , vector ) ; \n msix_notify ( dev , vector ) ; \n } \n }", "idx": 24156}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vhost_iommu_region_del ( MemoryListener * listener , \n MemoryRegionSection * section ) \n { \n struct vhost_dev * dev = container_of ( listener , struct vhost_dev , \n iommu_listener ) ; \n struct vhost_iommu * iommu ; \n if ( ! memory_region_is_iommu ( section -> mr ) ) { \n return ; \n } \n QLIST_FOREACH ( iommu , & dev -> iommu_list , iommu_next )  { \n if ( iommu -> mr == section -> mr ) { \n memory_region_unregister_iommu_notifier ( iommu -> mr , \n & iommu -> n ) ; \n QLIST_REMOVE ( iommu , iommu_next ) ; \n g_free ( iommu ) ; \n break ; \n } \n } \n }", "idx": 24160}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_vga_quirk_teardown ( VFIOPCIDevice * vdev ) \n { \n int i ; \n for ( i = 0 ; i < ARRAY_SIZE ( vdev -> vga . region ) ; i ++ ) { \n while ( ! QLIST_EMPTY ( & vdev -> vga . region [ i ] . quirks ) ) { \n VFIOQuirk * quirk = QLIST_FIRST ( & vdev -> vga . region [ i ] . quirks ) ; \n memory_region_del_subregion ( & vdev -> vga . region [ i ] . mem , & quirk -> mem ) ; \n object_unparent ( OBJECT ( & quirk -> mem ) ) ; \n QLIST_REMOVE ( quirk , next ) ; \n g_free ( quirk ) ; \n } \n } \n }", "idx": 24161}
{"project": "qemu", "commit_id": "6dc06f08b3d6c0347df00ac68d9f30e2b233a749", "target": 0, "func": "int scsi_req_get_sense ( SCSIRequest * req , uint8_t * buf , int len ) \n { \n assert ( len >= 14 ) ; \n if ( ! req -> sense_len ) { \n return 0 ; \n } \n return scsi_build_sense ( req -> sense , req -> sense_len , buf , len , true ) ; \n }", "idx": 24168}
{"project": "qemu", "commit_id": "250a87d5561a7212fe43357b084f69992eced75a", "target": 0, "func": "uint64_t HELPER ( popcnt ) ( uint64_t r2 ) \n { \n uint64_t ret = 0 ; \n int i ; \n for ( i = 0 ; i < 64 ; i += 8 ) { \n uint64_t t = ctpop32 ( ( r2 >> i ) & 0xff ) ; \n ret |= t << i ; \n } \n return ret ; \n }", "idx": 24199}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_backspace ( void ) \n { \n if ( term_cmd_buf_index > 0 ) { \n term_backward_char ( ) ; \n term_delete_char ( ) ; \n } \n }", "idx": 24219}
{"project": "qemu", "commit_id": "b3a62939561e07bc34493444fa926b6137cba4e8", "target": 0, "func": "TCGv_i64 tcg_global_reg_new_i64 ( int reg , const char * name ) \n { \n int idx ; \n idx = tcg_global_reg_new_internal ( TCG_TYPE_I64 , reg , name ) ; \n return MAKE_TCGV_I64 ( idx ) ; \n }", "idx": 24308}
{"project": "qemu", "commit_id": "908c67fca4b2c12a9b2336aa9c188f84468b60b7", "target": 0, "func": "static void gen_window_check1 ( DisasContext * dc , unsigned r1 ) \n { \n if ( dc -> tb -> flags & XTENSA_TBFLAG_EXCM ) { \n return ; \n } \n if ( option_enabled ( dc , XTENSA_OPTION_WINDOWED_REGISTER ) && \n r1 / 4 > dc -> used_window ) { \n TCGv_i32 pc = tcg_const_i32 ( dc -> pc ) ; \n TCGv_i32 w = tcg_const_i32 ( r1 / 4 ) ; \n dc -> used_window = r1 / 4 ; \n gen_advance_ccount ( dc ) ; \n gen_helper_window_check ( cpu_env , pc , w ) ; \n tcg_temp_free ( w ) ; \n tcg_temp_free ( pc ) ; \n } \n }", "idx": 24309}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_notify ( AioContext * ctx ) \n { \n smp_mb ( ) ; \n if ( ctx -> notify_me ) { \n event_notifier_set ( & ctx -> notifier ) ; \n atomic_mb_set ( & ctx -> notified , true ) ; \n } \n }", "idx": 24318}
{"project": "qemu", "commit_id": "d3c348b6e3af3598bfcb755d59f8f4de80a2228a", "target": 0, "func": "static void xlnx_zynqmp_qspips_reset ( DeviceState * d ) \n { \n XlnxZynqMPQSPIPS * s = XLNX_ZYNQMP_QSPIPS ( d ) ; \n int i ; \n xilinx_spips_reset ( d ) ; \n for ( i = 0 ; i < XLNX_ZYNQMP_SPIPS_R_MAX ; i ++ ) { \n s -> regs [ i ] = 0 ; \n } \n fifo8_reset ( & s -> rx_fifo_g ) ; \n fifo8_reset ( & s -> rx_fifo_g ) ; \n fifo32_reset ( & s -> fifo_g ) ; \n s -> regs [ R_INTR_STATUS ] = R_INTR_STATUS_RESET ; \n s -> regs [ R_GPIO ] = 1 ; \n s -> regs [ R_LPBK_DLY_ADJ ] = R_LPBK_DLY_ADJ_RESET ; \n s -> regs [ R_GQSPI_GFIFO_THRESH ] = 0x10 ; \n s -> regs [ R_MOD_ID ] = 0x01090101 ; \n s -> regs [ R_GQSPI_IMR ] = R_GQSPI_IMR_RESET ; \n s -> regs [ R_GQSPI_TX_THRESH ] = 1 ; \n s -> regs [ R_GQSPI_RX_THRESH ] = 1 ; \n s -> regs [ R_GQSPI_GPIO ] = 1 ; \n s -> regs [ R_GQSPI_LPBK_DLY_ADJ ] = R_GQSPI_LPBK_DLY_ADJ_RESET ; \n s -> regs [ R_GQSPI_MOD_ID ] = R_GQSPI_MOD_ID_RESET ; \n s -> regs [ R_QSPIDMA_DST_CTRL ] = R_QSPIDMA_DST_CTRL_RESET ; \n s -> regs [ R_QSPIDMA_DST_I_MASK ] = R_QSPIDMA_DST_I_MASK_RESET ; \n s -> regs [ R_QSPIDMA_DST_CTRL2 ] = R_QSPIDMA_DST_CTRL2_RESET ; \n s -> man_start_com_g = false ; \n s -> gqspi_irqline = 0 ; \n xlnx_zynqmp_qspips_update_ixr ( s ) ; \n }", "idx": 24320}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static void spapr_reset_htab ( sPAPRMachineState * spapr ) \n { \n long shift ; \n int index ; \n shift = kvmppc_reset_htab ( spapr -> htab_shift ) ; \n if ( shift < 0 ) { \n error_setg ( & error_abort , \" \" ) ; \n } else if ( shift > 0 ) { \n if ( shift != spapr -> htab_shift ) { \n error_setg ( & error_abort , \" \" ) ; \n } \n if ( spapr -> htab_fd >= 0 ) { \n spapr -> htab_fd_stale = true ; \n } \n } else { \n memset ( spapr -> htab , 0 , HTAB_SIZE ( spapr ) ) ; \n for ( index = 0 ; index < HTAB_SIZE ( spapr ) / HASH_PTE_SIZE_64 ; index ++ ) { \n DIRTY_HPTE ( HPTE ( spapr -> htab , index ) ) ; \n } \n } \n if ( spapr -> vrma_adjust ) { \n spapr -> rma_size = kvmppc_rma_size ( spapr_node0_size ( ) , \n spapr -> htab_shift ) ; \n } \n }", "idx": 24326}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void load_tco ( const TestData * d ) \n { \n qpci_io_writew ( d -> dev , d -> tco_io_base + TCO_RLD , 4 ) ; \n }", "idx": 24334}
{"project": "qemu", "commit_id": "4bc02e230d1e0fd41d2a892d81dcad56e3b3702d", "target": 1, "func": "target_ulong helper_srad ( CPUPPCState * env , target_ulong value , \n target_ulong shift ) \n { \n int64_t ret ; \n if ( likely ( ! ( shift & 0x40 ) ) ) { \n if ( likely ( ( uint64_t ) shift != 0 ) ) { \n shift &= 0x3f ; \n ret = ( int64_t ) value >> shift ; \n if ( likely ( ret >= 0 || ( value & ( ( 1 << shift ) - 1 ) ) == 0 ) ) { \n env -> ca = 0 ; \n } else { \n env -> ca = 1 ; \n } \n } else { \n ret = ( int64_t ) value ; \n env -> ca = 0 ; \n } \n } else { \n ret = ( int64_t ) value >> 63 ; \n env -> ca = ( ret != 0 ) ; \n } \n return ret ; \n }", "idx": 24336}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static target_ulong h_remove ( PowerPCCPU * cpu , sPAPRMachineState * spapr , \n target_ulong opcode , target_ulong * args ) \n { \n CPUPPCState * env = & cpu -> env ; \n target_ulong flags = args [ 0 ] ; \n target_ulong pte_index = args [ 1 ] ; \n target_ulong avpn = args [ 2 ] ; \n RemoveResult ret ; \n ret = remove_hpte ( cpu , pte_index , avpn , flags , \n & args [ 0 ] , & args [ 1 ] ) ; \n switch ( ret ) { \n case REMOVE_SUCCESS : \n check_tlb_flush ( env ) ; \n return H_SUCCESS ; \n case REMOVE_NOT_FOUND : \n return H_NOT_FOUND ; \n case REMOVE_PARM : \n return H_PARAMETER ; \n case REMOVE_HW : \n return H_HARDWARE ; \n } \n g_assert_not_reached ( ) ; \n }", "idx": 24339}
{"project": "qemu", "commit_id": "4154c7e03fa55b4cf52509a83d50d6c09d743b77", "target": 1, "func": "e1000e_ring_empty ( E1000ECore * core , const E1000E_RingInfo * r )  \n { \n return core -> mac [ r -> dh ] == core -> mac [ r -> dt ] ; \n }", "idx": 24384}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_full_empty ( void ) \n { \n const char * str = \" \" ; \n long res = 999L ; \n int err ; \n err = qemu_strtol ( str , NULL , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 0 ) ; \n }", "idx": 24410}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_readv ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , QEMUIOVector * qiov ) \n { \n BDRVNBDState * s = bs -> opaque ; \n return nbd_client_session_co_readv ( & s -> client , sector_num , \n nb_sectors , qiov ) ; \n }", "idx": 24448}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_list ( BlockDriverState * bs , \n QEMUSnapshotInfo * * psn_info ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( drv -> bdrv_snapshot_list ) \n return drv -> bdrv_snapshot_list ( bs , psn_info ) ; \n if ( bs -> file ) \n return bdrv_snapshot_list ( bs -> file , psn_info ) ; \n return - ENOTSUP ; \n }", "idx": 24502}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "static void dec_store ( DisasContext * dc ) \n { \n TCGv t , * addr ; \n unsigned int size ; \n size = 1 << ( dc -> opcode & 3 ) ; \n if ( size > 4 && ( dc -> tb_flags & MSR_EE_FLAG ) \n && ! ( dc -> env -> pvr . regs [ 2 ] & PVR2_ILL_OPCODE_EXC_MASK ) ) { \n tcg_gen_movi_tl ( cpu_SR [ SR_ESR ] , ESR_EC_ILLEGAL_OP ) ; \n t_gen_raise_exception ( dc , EXCP_HW_EXCP ) ; \n return ; \n } \n LOG_DIS ( \" \\n \" , size , dc -> type_b ? \" \" : \" \" ) ; \n t_sync_flags ( dc ) ; \n sync_jmpstate ( dc ) ; \n addr = compute_ldst_addr ( dc , & t ) ; \n if ( ( dc -> env -> pvr . regs [ 2 ] & PVR2_UNALIGNED_EXC_MASK ) && size > 1 ) { \n gen_helper_memalign ( * addr , tcg_const_tl ( dc -> rd ) , \n tcg_const_tl ( 1 ) , tcg_const_tl ( size - 1 ) ) ; \n } \n gen_store ( dc , * addr , cpu_R [ dc -> rd ] , size ) ; \n if ( addr == & t ) \n tcg_temp_free ( t ) ; \n }", "idx": 24511}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static void qpci_spapr_io_writew ( QPCIBus * bus , void * addr , uint16_t value ) \n { \n QPCIBusSPAPR * s = container_of ( bus , QPCIBusSPAPR , bus ) ; \n uint64_t port = ( uintptr_t ) addr ; \n value = bswap16 ( value ) ; \n if ( port < s -> pio . size ) { \n writew ( s -> pio_cpu_base + port , value ) ; \n } else { \n writew ( s -> mmio_cpu_base + port , value ) ; \n } \n }", "idx": 24514}
{"project": "qemu", "commit_id": "3baf720e6b920d583ce2834d05e5a4e9603a1d56", "target": 1, "func": "static int cdrom_probe_device ( const char * filename ) \n { \n if ( strstart ( filename , \" \" , NULL ) ) \n return 100 ; \n return 0 ; \n }", "idx": 24543}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static int qio_channel_socket_listen_worker ( QIOTask * task , \n Error * * errp , \n gpointer opaque ) \n { \n QIOChannelSocket * ioc = QIO_CHANNEL_SOCKET ( qio_task_get_source ( task ) ) ; \n SocketAddress * addr = opaque ; \n int ret ; \n ret = qio_channel_socket_listen_sync ( ioc , \n addr , \n errp ) ; \n object_unref ( OBJECT ( ioc ) ) ; \n return ret ; \n }", "idx": 24544}
{"project": "qemu", "commit_id": "f2ad97ff81da51c064b9e87720ff48a0874f45d4", "target": 1, "func": "static USBPort * xhci_lookup_uport ( XHCIState * xhci , uint32_t * slot_ctx ) \n { \n USBPort * uport ; \n char path [ 32 ] ; \n int i , pos , port ; \n port = ( slot_ctx [ 1 ] >> 16 ) & 0xFF ; \n port = xhci -> ports [ port - 1 ] . uport -> index + 1 ; \n pos = snprintf ( path , sizeof ( path ) , \" \" , port ) ; \n for ( i = 0 ; i < 5 ; i ++ ) { \n port = ( slot_ctx [ 0 ] >> 4 * i ) & 0x0f ; \n if ( ! port ) { \n break ; \n pos += snprintf ( path + pos , sizeof ( path ) - pos , \" \" , port ) ; \n QTAILQ_FOREACH ( uport , & xhci -> bus . used , next )  { \n if ( strcmp ( uport -> path , path ) == 0 ) { \n return uport ;", "idx": 24547}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void io_watch_poll_finalize ( GSource * source ) \n { \n IOWatchPoll * iwp = io_watch_poll_from_source ( source ) ; \n if ( iwp -> src ) { \n g_source_destroy ( iwp -> src ) ; \n g_source_unref ( iwp -> src ) ; \n iwp -> src = NULL ; \n } \n }", "idx": 24548}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bmdma_addr_write ( void * opaque , target_phys_addr_t addr , \n uint64_t data , unsigned width ) \n { \n BMDMAState * bm = opaque ; \n int shift = addr * 8 ; \n uint32_t mask = ( 1ULL << ( width * 8 ) ) - 1 ; \n #ifdef DEBUG_IDE \n printf ( \" \\n \" , __func__ , ( unsigned ) data ) ; \n #endif \n bm -> addr &= ~ ( mask << shift ) ; \n bm -> addr |= ( ( data & mask ) << shift ) & ~ 3 ; \n }", "idx": 24597}
{"project": "qemu", "commit_id": "6f1de6b70d857d5e316ae6fd908f52818b827b08", "target": 0, "func": "int qemu_chr_fe_add_watch ( CharDriverState * s , GIOCondition cond , \n GIOFunc func , void * user_data ) \n { \n GSource * src ; \n guint tag ; \n if ( s -> chr_add_watch == NULL ) { \n return - ENOSYS ; \n } \n src = s -> chr_add_watch ( s , cond ) ; \n if ( ! src ) { \n return - EINVAL ; \n } \n g_source_set_callback ( src , ( GSourceFunc ) func , user_data , NULL ) ; \n tag = g_source_attach ( src , NULL ) ; \n g_source_unref ( src ) ; \n return tag ; \n }", "idx": 24600}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint64_t ldq_phys ( target_phys_addr_t addr ) \n { \n return ldq_phys_internal ( addr , DEVICE_NATIVE_ENDIAN ) ; \n }", "idx": 24602}
{"project": "qemu", "commit_id": "56ad3e54dad6cdcee8668d170df161d89581846f", "target": 1, "func": "static ssize_t mp_dacl_getxattr ( FsContext * ctx , const char * path , \n const char * name , void * value , size_t size ) \n { \n char * buffer ; \n ssize_t ret ; \n buffer = rpath ( ctx , path ) ; \n ret = lgetxattr ( buffer , MAP_ACL_DEFAULT , value , size ) ; \n g_free ( buffer ) ; \n return ret ; \n }", "idx": 24611}
{"project": "qemu", "commit_id": "5712db6ae5101db645f71edc393368cd59bfd314", "target": 1, "func": "static void fw_cfg_realize ( DeviceState * dev , Error * * errp ) \n { \n FWCfgState * s = FW_CFG ( dev ) ; \n SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ; \n if ( s -> ctl_iobase + 1 == s -> data_iobase ) { \n sysbus_add_io ( sbd , s -> ctl_iobase , & s -> comb_iomem ) ; \n } else { \n if ( s -> ctl_iobase ) { \n sysbus_add_io ( sbd , s -> ctl_iobase , & s -> ctl_iomem ) ; \n } \n if ( s -> data_iobase ) { \n sysbus_add_io ( sbd , s -> data_iobase , & s -> data_iomem ) ; \n } \n } \n }", "idx": 24615}
{"project": "qemu", "commit_id": "a4d8e8daee324e230b0155915f562743f4fff5d8", "target": 1, "func": "static void vscsi_got_payload ( VSCSIState * s , vscsi_crq * crq ) \n { \n vscsi_req * req ; \n int done ; \n req = vscsi_get_req ( s ) ; \n if ( req == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n return ; \n } \n if ( crq -> s . IU_length > sizeof ( union viosrp_iu ) ) { \n fprintf ( stderr , \" \\n \" , \n crq -> s . IU_length ) ; \n return ; \n } \n if ( spapr_tce_dma_read ( & s -> vdev , crq -> s . IU_data_ptr , & req -> iu , \n crq -> s . IU_length ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n g_free ( req ) ; \n } \n memcpy ( & req -> crq , crq , sizeof ( vscsi_crq ) ) ; \n if ( crq -> s . format == VIOSRP_MAD_FORMAT ) { \n done = vscsi_handle_mad_req ( s , req ) ; \n } else { \n done = vscsi_handle_srp_req ( s , req ) ; \n } \n if ( done ) { \n vscsi_put_req ( req ) ; \n } \n }", "idx": 24620}
{"project": "qemu", "commit_id": "8a5865f331028e66b4ed233129d7a914c2d5bfc7", "target": 1, "func": "static MTPData * usb_mtp_get_object_info ( MTPState * s , MTPControl * c , \n MTPObject * o ) \n { \n MTPData * d = usb_mtp_data_alloc ( c ) ; \n trace_usb_mtp_op_get_object_info ( s -> dev . addr , o -> handle , o -> path ) ; \n usb_mtp_add_u32 ( d , QEMU_STORAGE_ID ) ; \n usb_mtp_add_u16 ( d , o -> format ) ; \n usb_mtp_add_u16 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , o -> stat . st_size ) ; \n usb_mtp_add_u16 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n if ( o -> parent ) { \n usb_mtp_add_u32 ( d , o -> parent -> handle ) ; \n } else { \n usb_mtp_add_u32 ( d , 0 ) ; \n } \n if ( o -> format == FMT_ASSOCIATION ) { \n usb_mtp_add_u16 ( d , 0x0001 ) ; \n usb_mtp_add_u32 ( d , 0x00000001 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n } else { \n usb_mtp_add_u16 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n usb_mtp_add_u32 ( d , 0 ) ; \n } \n usb_mtp_add_str ( d , o -> name ) ; \n usb_mtp_add_time ( d , o -> stat . st_ctime ) ; \n usb_mtp_add_time ( d , o -> stat . st_mtime ) ; \n usb_mtp_add_wstr ( d , L\" \" ) ; \n return d ; \n }", "idx": 24632}
{"project": "qemu", "commit_id": "1b57bd4f2f4993104a5cb48912435396faa10d58", "target": 1, "func": "static inline bool rom_order_compare ( Rom * rom , Rom * item ) \n { \n return ( rom -> as > item -> as ) || \n ( rom -> as == item -> as && rom -> addr >= item -> addr ) ; \n }", "idx": 24635}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int slb_lookup ( CPUState * env , target_ulong eaddr , \n target_ulong * vsid , target_ulong * page_mask , int * attr ) \n { \n target_phys_addr_t sr_base ; \n target_ulong mask ; \n uint64_t tmp64 ; \n uint32_t tmp ; \n int n , ret ; \n int slb_nr ; \n ret = -5 ; \n sr_base = env -> spr [ SPR_ASR ] ; \n mask = 0x0000000000000000ULL ; \n #if 0  \n  \n  \n  slb_nr = env -> slb_nr ; \n #else \n slb_nr = 32 ; \n #endif \n for ( n = 0 ; n < slb_nr ; n ++ ) { \n tmp64 = ldq_phys ( sr_base ) ; \n if ( tmp64 & 0x0000000008000000ULL ) { \n switch ( tmp64 & 0x0000000006000000ULL ) { \n case 0x0000000000000000ULL : \n mask = 0xFFFFFFFFF0000000ULL ; \n break ; \n case 0x0000000002000000ULL : \n mask = 0xFFFF000000000000ULL ; \n break ; \n case 0x0000000004000000ULL : \n case 0x0000000006000000ULL : \n continue ; \n } \n if ( ( eaddr & mask ) == ( tmp64 & mask ) ) { \n tmp = ldl_phys ( sr_base + 8 ) ; \n * vsid = ( ( tmp64 << 24 ) | ( tmp >> 8 ) ) & 0x0003FFFFFFFFFFFFULL ; \n * page_mask = ~ mask ; \n * attr = tmp & 0xFF ; \n ret = 0 ; \n break ; \n } \n } \n sr_base += 12 ; \n } \n return ret ; \n }", "idx": 24644}
{"project": "qemu", "commit_id": "6c8d56a2e95712a6206a2671d2b04b2e59cabc0b", "target": 1, "func": "static uint8_t fw_cfg_read ( FWCfgState * s ) \n { \n int arch = ! ! ( s -> cur_entry & FW_CFG_ARCH_LOCAL ) ; \n FWCfgEntry * e = ( s -> cur_entry == FW_CFG_INVALID ) ? NULL : \n & s -> entries [ arch ] [ s -> cur_entry & FW_CFG_ENTRY_MASK ] ; \n uint8_t ret ; \n if ( s -> cur_entry == FW_CFG_INVALID || ! e -> data || s -> cur_offset >= e -> len ) \n ret = 0 ; \n else { \n ret = e -> data [ s -> cur_offset ++ ] ; \n } \n trace_fw_cfg_read ( s , ret ) ; \n return ret ; \n }", "idx": 24649}
{"project": "qemu", "commit_id": "698bdfa07d66b5ec218a60229e58eae1dcde00e5", "target": 1, "func": "void qmp_block_resize ( bool has_device , const char * device , \n bool has_node_name , const char * node_name , \n int64_t size , Error * * errp ) \n { \n Error * local_err = NULL ; \n BlockBackend * blk = NULL ; \n BlockDriverState * bs ; \n AioContext * aio_context ; \n int ret ; \n bs = bdrv_lookup_bs ( has_device ? device : NULL , \n has_node_name ? node_name : NULL , \n & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n aio_context = bdrv_get_aio_context ( bs ) ; \n aio_context_acquire ( aio_context ) ; \n if ( ! bdrv_is_first_non_filter ( bs ) ) { \n error_setg ( errp , QERR_FEATURE_DISABLED , \" \" ) ; \n goto out ; \n } \n if ( size < 0 ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_VALUE , \" \" , \" \" ) ; \n goto out ; \n } \n if ( bdrv_op_is_blocked ( bs , BLOCK_OP_TYPE_RESIZE , NULL ) ) { \n error_setg ( errp , QERR_DEVICE_IN_USE , device ) ; \n goto out ; \n } \n blk = blk_new ( BLK_PERM_RESIZE , BLK_PERM_ALL ) ; \n ret = blk_insert_bs ( blk , bs , errp ) ; \n if ( ret < 0 ) { \n goto out ; \n } \n bdrv_drain_all ( ) ; \n ret = blk_truncate ( blk , size , errp ) ; \n out : \n blk_unref ( blk ) ; \n aio_context_release ( aio_context ) ; \n }", "idx": 24650}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_update_bitmap ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors ) \n { \n int64_t bitnum = sector_num + sizeof ( struct cow_header_v2 ) * 8 ; \n uint64_t offset = ( bitnum / 8 ) & - BDRV_SECTOR_SIZE ; \n bool first = true ; \n int sector_bits ; \n for ( ; nb_sectors ; \n bitnum += sector_bits , \n nb_sectors -= sector_bits , \n offset += BDRV_SECTOR_SIZE ) { \n int ret , set ; \n uint8_t bitmap [ BDRV_SECTOR_SIZE ] ; \n bitnum &= BITS_PER_BITMAP_SECTOR - 1 ; \n sector_bits = MIN ( nb_sectors , BITS_PER_BITMAP_SECTOR - bitnum ) ; \n ret = bdrv_pread ( bs -> file , offset , & bitmap , sizeof ( bitmap ) ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n set = cow_find_streak ( bitmap , 1 , bitnum , sector_bits ) ; \n bitnum += set ; \n sector_bits -= set ; \n nb_sectors -= set ; \n if ( ! sector_bits ) { \n continue ; \n } \n if ( first ) { \n ret = bdrv_flush ( bs -> file ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n first = false ; \n } \n cow_set_bits ( bitmap , bitnum , sector_bits ) ; \n ret = bdrv_pwrite ( bs -> file , offset , & bitmap , sizeof ( bitmap ) ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n } \n return 0 ; \n }", "idx": 24682}
{"project": "qemu", "commit_id": "b29a0341d7ed7e7df4bf77a41db8e614f1ddb645", "target": 0, "func": "void op_mtc0_ebase ( void ) \n { \n env -> CP0_EBase = ( int32_t ) 0x80000000 | ( T0 & 0x3FFFF000 ) ; \n RETURN ( ) ; \n }", "idx": 24695}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "bool replay_checkpoint ( ReplayCheckpoint checkpoint ) \n { \n bool res = false ; \n assert ( EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST ) ; \n replay_save_instructions ( ) ; \n if ( ! replay_file ) { \n return true ; \n } \n replay_mutex_lock ( ) ; \n if ( replay_mode == REPLAY_MODE_PLAY ) { \n if ( replay_next_event_is ( EVENT_CHECKPOINT + checkpoint ) ) { \n replay_finish_event ( ) ; \n } else if ( replay_data_kind != EVENT_ASYNC ) { \n res = false ; \n goto out ; \n } \n replay_read_events ( checkpoint ) ; \n res = replay_data_kind != EVENT_ASYNC ; \n } else if ( replay_mode == REPLAY_MODE_RECORD ) { \n replay_put_event ( EVENT_CHECKPOINT + checkpoint ) ; \n replay_save_events ( checkpoint ) ; \n res = true ; \n } \n out : \n replay_mutex_unlock ( ) ; \n return res ; \n }", "idx": 24711}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_machine_init ( MachineClass * mc ) \n { \n mc -> desc = \" \" ; \n mc -> init = openrisc_sim_init ; \n mc -> max_cpus = 1 ; \n mc -> is_default = 1 ; \n }", "idx": 24716}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_inplace ( QEDAIOCB * acb , uint64_t offset , \n size_t len ) \n { \n if ( acb -> flags & QED_AIOCB_ZERO ) { \n struct iovec * iov = acb -> qiov -> iov ; \n if ( ! iov -> iov_base ) { \n iov -> iov_base = qemu_try_blockalign ( acb -> bs , iov -> iov_len ) ; \n if ( iov -> iov_base == NULL ) { \n return - ENOMEM ; \n } \n memset ( iov -> iov_base , 0 , iov -> iov_len ) ; \n } \n } \n acb -> cur_cluster = offset ; \n qemu_iovec_concat ( & acb -> cur_qiov , acb -> qiov , acb -> qiov_offset , len ) ; \n return qed_aio_write_main ( acb ) ; \n }", "idx": 24726}
{"project": "qemu", "commit_id": "439e2a6e10ed7f5da819bf7dcaa54b8cfdbeab0d", "target": 0, "func": "Aml * aml_add ( Aml * arg1 , Aml * arg2 ) \n { \n Aml * var = aml_opcode ( 0x72 \n ) ; \n aml_append ( var , arg1 ) ; \n aml_append ( var , arg2 ) ; \n build_append_byte ( var -> buf , 0x00 \n ) ; \n return var ; \n }", "idx": 24727}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int pci_cirrus_vga_initfn ( PCIDevice * dev ) \n { \n PCICirrusVGAState * d = DO_UPCAST ( PCICirrusVGAState , dev , dev ) ; \n CirrusVGAState * s = & d -> cirrus_vga ; \n PCIDeviceClass * pc = PCI_DEVICE_GET_CLASS ( dev ) ; \n int16_t device_id = pc -> device_id ; \n vga_common_init ( & s -> vga ) ; \n cirrus_init_common ( s , device_id , 1 , pci_address_space ( dev ) , \n pci_address_space_io ( dev ) ) ; \n s -> vga . con = graphic_console_init ( s -> vga . update , s -> vga . invalidate , \n s -> vga . screen_dump , s -> vga . text_update , \n & s -> vga ) ; \n memory_region_init ( & s -> pci_bar , \" \" , 0x2000000 ) ; \n memory_region_add_subregion ( & s -> pci_bar , 0 , & s -> cirrus_linear_io ) ; \n memory_region_add_subregion ( & s -> pci_bar , 0x1000000 , \n & s -> cirrus_linear_bitblt_io ) ; \n pci_register_bar ( & d -> dev , 0 , PCI_BASE_ADDRESS_MEM_PREFETCH , & s -> pci_bar ) ; \n if ( device_id == CIRRUS_ID_CLGD5446 ) { \n pci_register_bar ( & d -> dev , 1 , 0 , & s -> cirrus_mmio_io ) ; \n } \n return 0 ; \n }", "idx": 24758}
{"project": "qemu", "commit_id": "7c38ecd09763107513bacc791856fdbb582a107c", "target": 1, "func": "static int acpi_pcihp_get_bsel ( PCIBus * bus ) \n { \n QObject * o = object_property_get_qobject ( OBJECT ( bus ) , \n ACPI_PCIHP_PROP_BSEL , NULL ) ; \n int64_t bsel = -1 ; \n if ( o ) { \n bsel = qint_get_int ( qobject_to_qint ( o ) ) ; \n } \n if ( bsel < 0 ) { \n return -1 ; \n } \n return bsel ; \n }", "idx": 24763}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "void vnc_client_write ( void * opaque ) \n { \n long ret ; \n VncState * vs = opaque ; \n #ifdef CONFIG_VNC_TLS \n if ( vs -> tls . session ) { \n ret = gnutls_write ( vs -> tls . session , vs -> output . buffer , vs -> output . offset ) ; \n if ( ret < 0 ) { \n if ( ret == GNUTLS_E_AGAIN ) \n errno = EAGAIN ; \n else \n errno = EIO ; \n ret = -1 ; \n } \n } else \n #endif \n ret = send ( vs -> csock , vs -> output . buffer , vs -> output . offset , 0 ) ; \n ret = vnc_client_io_error ( vs , ret , socket_error ( ) ) ; \n if ( ! ret ) \n return ; \n memmove ( vs -> output . buffer , vs -> output . buffer + ret , ( vs -> output . offset - ret ) ) ; \n vs -> output . offset -= ret ; \n if ( vs -> output . offset == 0 ) { \n qemu_set_fd_handler2 ( vs -> csock , NULL , vnc_client_read , NULL , vs ) ; \n } \n }", "idx": 24764}
{"project": "qemu", "commit_id": "08942ac17922d923a7cc5cf9854e9cc4b150b942", "target": 1, "func": "int spapr_tce_dma_write ( VIOsPAPRDevice * dev , uint64_t taddr , const void * buf , \n uint32_t size ) \n { \n #ifdef DEBUG_TCE \n fprintf ( stderr , \" \\n \" , \n ( unsigned long long ) taddr , size ) ; \n #endif \n while ( size ) { \n uint64_t tce ; \n uint32_t lsize ; \n uint64_t txaddr ; \n if ( taddr >= dev -> rtce_window_size ) { \n #ifdef DEBUG_TCE \n fprintf ( stderr , \" \\n \" ) ; \n #endif \n return H_DEST_PARM ; \n tce = dev -> rtce_table [ taddr >> SPAPR_VIO_TCE_PAGE_SHIFT ] . tce ; \n lsize = MIN ( size , ( ( ~ taddr ) & SPAPR_VIO_TCE_PAGE_MASK ) + 1 ) ; \n if ( ! ( tce & 2 ) ) { \n return H_DEST_PARM ; \n txaddr = ( tce & ~ SPAPR_VIO_TCE_PAGE_MASK ) | \n ( taddr & SPAPR_VIO_TCE_PAGE_MASK ) ; \n #ifdef DEBUG_TCE \n fprintf ( stderr , \" \\n \" , \n ( unsigned long long ) txaddr , lsize ) ; \n #endif \n cpu_physical_memory_write ( txaddr , buf , lsize ) ; \n buf += lsize ; \n taddr += lsize ; \n size -= lsize ;", "idx": 24813}
{"project": "qemu", "commit_id": "5bf81c8d63db0216a4d29dc87f9ce530bb791dd1", "target": 1, "func": "void vmstate_save_state ( QEMUFile * f , const VMStateDescription * vmsd , \n void * opaque ) \n { \n VMStateField * field = vmsd -> fields ; \n if ( vmsd -> pre_save ) { \n vmsd -> pre_save ( opaque ) ; \n while ( field -> name ) { \n if ( ! field -> field_exists || \n field -> field_exists ( opaque , vmsd -> version_id ) ) { \n void * base_addr = vmstate_base_addr ( opaque , field ) ; \n int i , n_elems = vmstate_n_elems ( opaque , field ) ; \n int size = vmstate_size ( opaque , field ) ; \n for ( i = 0 ; i < n_elems ; i ++ ) { \n void * addr = base_addr + size * i ; \n if ( field -> flags & VMS_ARRAY_OF_POINTER ) { \n addr = * ( void * * ) addr ; \n if ( field -> flags & VMS_STRUCT ) { \n vmstate_save_state ( f , field -> vmsd , addr ) ; \n field -> info -> put ( f , addr , size ) ; \n field ++ ; \n vmstate_subsection_save ( f , vmsd , opaque ) ;", "idx": 24830}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_closedir ( FsContext * ctx , V9fsFidOpenState * fs ) \n { \n V9fsSynthOpenState * synth_open = fs -> private ; \n V9fsSynthNode * node = synth_open -> node ; \n node -> open_count -- ; \n g_free ( synth_open ) ; \n fs -> private = NULL ; \n return 0 ; \n }", "idx": 24842}
{"project": "qemu", "commit_id": "c16de8f59a2bcbe2dc037524cc648de896f581a4", "target": 0, "func": "static int blk_root_inactivate ( BdrvChild * child ) \n { \n BlockBackend * blk = child -> opaque ; \n if ( blk -> disable_perm ) { \n return 0 ; \n } \n if ( ! blk -> dev && ! blk_name ( blk ) [ 0 ] ) { \n return - EPERM ; \n } \n blk -> disable_perm = true ; \n if ( blk -> root ) { \n bdrv_child_try_set_perm ( blk -> root , 0 , BLK_PERM_ALL , & error_abort ) ; \n } \n return 0 ; \n }", "idx": 24863}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_flush ( struct vmsvga_state_s * s ) \n { \n struct vmsvga_rect_s * rect ; \n if ( s -> invalidated ) { \n s -> redraw_fifo_first = s -> redraw_fifo_last ; \n return ; \n } \n while ( s -> redraw_fifo_first != s -> redraw_fifo_last ) { \n rect = & s -> redraw_fifo [ s -> redraw_fifo_first ++ ] ; \n s -> redraw_fifo_first &= REDRAW_FIFO_LEN - 1 ; \n vmsvga_update_rect ( s , rect -> x , rect -> y , rect -> w , rect -> h ) ; \n } \n }", "idx": 24865}
{"project": "qemu", "commit_id": "0923c577f993d61eeaf41f66db1e1010fa113976", "target": 0, "func": "length_f ( int  argc , char * * argv ) \n { \n int64_t size ; \n char s1 [ 64 ] ; \n size = bdrv_getlength ( bs ) ; \n if ( size < 0 ) { \n printf ( \" \" , strerror ( size ) ) ; \n return 0 ; \n } \n cvtstr ( size , s1 , sizeof ( s1 ) ) ; \n printf ( \" \\n \" , s1 ) ; \n return 0 ; \n }", "idx": 24872}
{"project": "qemu", "commit_id": "855011be05fad72e17e0280d0bab87a4bc840695", "target": 0, "func": "static void kvm_arm_gic_get ( GICState * s ) \n { \n }", "idx": 24885}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_proc_601 ( CPUPPCState * env ) \n { \n gen_spr_ne_601 ( env ) ; \n gen_spr_601 ( env ) ; \n spr_register ( env , SPR_HID0 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID1 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_601_HID2 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_601_HID5 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_601_HID15 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  env -> nb_tlb = 64 ; \n env -> nb_ways = 2 ; \n env -> id_tlbs = 0 ; \n #endif \n init_excp_601 ( env ) ; \n env -> dcache_line_size = 64 ; \n env -> icache_line_size = 64 ; \n }", "idx": 24918}
{"project": "qemu", "commit_id": "24b856ca63f1c72b5043af6b291e7cc35900f4d6", "target": 0, "func": "static int i6300esb_init ( PCIDevice * dev ) \n { \n I6300State * d = DO_UPCAST ( I6300State , dev , dev ) ; \n uint8_t * pci_conf ; \n int io_mem ; \n static CPUReadMemoryFunc * const mem_read [ 3 ] = { \n i6300esb_mem_readb , \n i6300esb_mem_readw , \n i6300esb_mem_readl , \n } ; \n static CPUWriteMemoryFunc * const mem_write [ 3 ] = { \n i6300esb_mem_writeb , \n i6300esb_mem_writew , \n i6300esb_mem_writel , \n } ; \n i6300esb_debug ( \" \\n \" , d ) ; \n d -> timer = qemu_new_timer_ns ( vm_clock , i6300esb_timer_expired , d ) ; \n d -> previous_reboot_flag = 0 ; \n pci_conf = d -> dev . config ; \n pci_config_set_vendor_id ( pci_conf , PCI_VENDOR_ID_INTEL ) ; \n pci_config_set_device_id ( pci_conf , PCI_DEVICE_ID_INTEL_ESB_9 ) ; \n pci_config_set_class ( pci_conf , PCI_CLASS_SYSTEM_OTHER ) ; \n io_mem = cpu_register_io_memory ( mem_read , mem_write , d , \n DEVICE_NATIVE_ENDIAN ) ; \n pci_register_bar_simple ( & d -> dev , 0 , 0x10 , 0 , io_mem ) ; \n return 0 ; \n }", "idx": 24935}
{"project": "qemu", "commit_id": "0ddf08db22a9ef6b122d8c4cfe5b25d2c2c51962", "target": 0, "func": "NBDExport * nbd_export_new ( BlockDriverState * bs , off_t dev_offset , \n off_t size , uint32_t nbdflags ) \n { \n NBDExport * exp = g_malloc0 ( sizeof ( NBDExport ) ) ; \n QSIMPLEQ_INIT ( & exp -> requests ) ; \n exp -> refcount = 1 ; \n QTAILQ_INIT ( & exp -> clients ) ; \n exp -> bs = bs ; \n exp -> dev_offset = dev_offset ; \n exp -> nbdflags = nbdflags ; \n exp -> size = size == -1 ? bdrv_getlength ( bs ) : size ; \n return exp ; \n }", "idx": 24937}
{"project": "qemu", "commit_id": "2572b37a4751cc967582d7d04f21d9bf97187ae5", "target": 0, "func": "static BlockDriverAIOCB * bdrv_aio_rw_vector ( BlockDriverState * bs , \n int64_t sector_num , \n QEMUIOVector * qiov , \n int nb_sectors , \n BlockDriverCompletionFunc * cb , \n void * opaque , \n int is_write ) \n { \n BlockDriverAIOCBSync * acb ; \n acb = qemu_aio_get ( & bdrv_em_aiocb_info , bs , cb , opaque ) ; \n acb -> is_write = is_write ; \n acb -> qiov = qiov ; \n acb -> bounce = qemu_blockalign ( bs , qiov -> size ) ; \n acb -> bh = qemu_bh_new ( bdrv_aio_bh_cb , acb ) ; \n if ( is_write ) { \n qemu_iovec_to_buf ( acb -> qiov , 0 , acb -> bounce , qiov -> size ) ; \n acb -> ret = bs -> drv -> bdrv_write ( bs , sector_num , acb -> bounce , nb_sectors ) ; \n } else { \n acb -> ret = bs -> drv -> bdrv_read ( bs , sector_num , acb -> bounce , nb_sectors ) ; \n } \n qemu_bh_schedule ( acb -> bh ) ; \n return & acb -> common ; \n }", "idx": 24938}
{"project": "qemu", "commit_id": "49fb65c7f985baa56d2964e0a85c1f098e3e2a9d", "target": 1, "func": "static void virtio_scsi_push_event ( VirtIOSCSI * s , SCSIDevice * dev , \n uint32_t event , uint32_t reason ) \n { \n VirtIOSCSICommon * vs = VIRTIO_SCSI_COMMON ( s ) ; \n VirtIOSCSIReq * req = virtio_scsi_pop_req ( s , vs -> event_vq ) ; \n VirtIOSCSIEvent * evt ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( s ) ; \n int in_size ; \n if ( ! ( vdev -> status & VIRTIO_CONFIG_S_DRIVER_OK ) ) { \n return ; \n } \n if ( ! req ) { \n s -> events_dropped = true ; \n return ; \n } \n if ( req -> elem . out_num || req -> elem . in_num != 1 ) { \n virtio_scsi_bad_req ( ) ; \n } \n if ( s -> events_dropped ) { \n event |= VIRTIO_SCSI_T_EVENTS_MISSED ; \n s -> events_dropped = false ; \n } \n in_size = req -> elem . in_sg [ 0 ] . iov_len ; \n if ( in_size < sizeof ( VirtIOSCSIEvent ) ) { \n virtio_scsi_bad_req ( ) ; \n } \n evt = req -> resp . event ; \n memset ( evt , 0 , sizeof ( VirtIOSCSIEvent ) ) ; \n evt -> event = event ; \n evt -> reason = reason ; \n if ( ! dev ) { \n assert ( event == VIRTIO_SCSI_T_NO_EVENT ) ; \n } else { \n evt -> lun [ 0 ] = 1 ; \n evt -> lun [ 1 ] = dev -> id ; \n if ( dev -> lun >= 256 ) { \n evt -> lun [ 2 ] = ( dev -> lun >> 8 ) | 0x40 ; \n } \n evt -> lun [ 3 ] = dev -> lun & 0xFF ; \n } \n virtio_scsi_complete_req ( req ) ; \n }", "idx": 24950}
{"project": "qemu", "commit_id": "bb639f829f139ddc83325b3b6825f93096ee44f1", "target": 1, "func": "static void ahci_irq_raise ( AHCIState * s , AHCIDevice * dev ) \n { \n AHCIPCIState * d = container_of ( s , AHCIPCIState , ahci ) ; \n PCIDevice * pci_dev = \n ( PCIDevice * ) object_dynamic_cast ( OBJECT ( d ) , TYPE_PCI_DEVICE ) ; \n DPRINTF ( 0 , \" \\n \" ) ; \n if ( pci_dev && msi_enabled ( pci_dev ) ) { \n msi_notify ( pci_dev , 0 ) ; \n } else { \n qemu_irq_raise ( s -> irq ) ; \n } \n }", "idx": 24965}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void run_on_cpu ( CPUState * env , void ( * func ) ( void * data ) , void * data ) \n { \n struct qemu_work_item wi ; \n if ( qemu_cpu_self ( env ) ) { \n func ( data ) ; \n return ; \n } \n wi . func = func ; \n wi . data = data ; \n if ( ! env -> queued_work_first ) \n env -> queued_work_first = & wi ; \n else \n env -> queued_work_last -> next = & wi ; \n env -> queued_work_last = & wi ; \n wi . next = NULL ; \n wi . done = false ; \n qemu_cpu_kick ( env ) ; \n while ( ! wi . done ) { \n CPUState * self_env = cpu_single_env ; \n qemu_cond_wait ( & qemu_work_cond , & qemu_global_mutex ) ; \n cpu_single_env = self_env ; \n } \n }", "idx": 25007}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint8_equal ( QEMUFile * f , void * pv , size_t size ) \n { \n uint8_t * v = pv ; \n uint8_t v2 ; \n qemu_get_8s ( f , & v2 ) ; \n if ( * v == v2 ) { \n return 0 ; \n } \n return - EINVAL ; \n }", "idx": 25123}
{"project": "qemu", "commit_id": "74f24cb6306d065045d0e2215a7d10533fa59c57", "target": 1, "func": "static void test_visitor_in_intList ( TestInputVisitorData * data , \n const void * unused ) \n { \n int64_t value [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 20 } ; \n int16List * res = NULL , * tmp ; \n Error * err = NULL ; \n Visitor * v ; \n int i = 0 ; \n v = visitor_input_test_init ( data , \" \" ) ; \n visit_type_int16List ( v , NULL , & res , & error_abort ) ; \n tmp = res ; \n while ( i < sizeof ( value ) / sizeof ( value [ 0 ] ) ) { \n g_assert ( tmp ) ; \n g_assert_cmpint ( tmp -> value , == , value [ i ++ ] ) ; \n tmp = tmp -> next ; \n } \n g_assert ( ! tmp ) ; \n tmp = res ; \n while ( tmp ) { \n res = res -> next ; \n g_free ( tmp ) ; \n tmp = res ; \n } \n visitor_input_teardown ( data , unused ) ; \n v = visitor_input_test_init ( data , \" \" ) ; \n visit_type_int16List ( v , NULL , & res , & err ) ; \n }", "idx": 25146}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_io_limits_disable ( BlockDriverState * bs ) \n { \n bs -> io_limits_enabled = false ; \n bdrv_start_throttled_reqs ( bs ) ; \n throttle_destroy ( & bs -> throttle_state ) ; \n }", "idx": 25206}
{"project": "qemu", "commit_id": "1ec26c757d5996468afcc0dced4fad04139574b3", "target": 0, "func": "void kvmppc_update_sdr1 ( target_ulong sdr1 ) \n { \n CPUState * cs ; \n CPU_FOREACH ( cs ) { \n run_on_cpu ( cs , kvmppc_pivot_hpt_cpu , RUN_ON_CPU_TARGET_PTR ( sdr1 ) ) ; \n } \n }", "idx": 25232}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_start_irqfd_injection ( SysBusDevice * sbdev , qemu_irq irq ) \n { \n VFIOPlatformDevice * vdev = VFIO_PLATFORM_DEVICE ( sbdev ) ; \n VFIOINTp * intp ; \n if ( ! kvm_irqfds_enabled ( ) || ! kvm_resamplefds_enabled ( ) || \n ! vdev -> irqfd_allowed ) { \n goto fail_irqfd ; \n } \n QLIST_FOREACH ( intp , & vdev -> intp_list , next )  { \n if ( intp -> qemuirq == irq ) { \n break ; \n } \n } \n assert ( intp ) ; \n if ( kvm_irqchip_add_irqfd_notifier ( kvm_state , & intp -> interrupt , \n & intp -> unmask , irq ) < 0 ) { \n goto fail_irqfd ; \n } \n if ( vfio_set_trigger_eventfd ( intp , NULL ) < 0 ) { \n goto fail_vfio ; \n } \n if ( vfio_set_resample_eventfd ( intp ) < 0 ) { \n goto fail_vfio ; \n } \n intp -> kvm_accel = true ; \n trace_vfio_platform_start_irqfd_injection ( intp -> pin , \n event_notifier_get_fd ( & intp -> interrupt ) , \n event_notifier_get_fd ( & intp -> unmask ) ) ; \n return ; \n fail_vfio : \n kvm_irqchip_remove_irqfd_notifier ( kvm_state , & intp -> interrupt , irq ) ; \n error_report ( \" \" , \n intp -> pin ) ; \n abort ( ) ; \n fail_irqfd : \n vfio_start_eventfd_injection ( sbdev , irq ) ; \n return ; \n }", "idx": 25234}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static void proxy_rewinddir ( FsContext * ctx , V9fsFidOpenState * fs ) \n { \n rewinddir ( fs -> dir ) ; \n }", "idx": 25278}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_struct ( gconstpointer opaque ) \n { \n TestArgs * args = ( TestArgs * ) opaque ; \n const SerializeOps * ops = args -> ops ; \n TestStruct * ts = struct_create ( ) ; \n TestStruct * ts_copy = NULL ; \n Error * err = NULL ; \n void * serialize_data ; \n ops -> serialize ( ts , & serialize_data , visit_struct , & err ) ; \n ops -> deserialize ( ( void * * ) & ts_copy , serialize_data , visit_struct , & err ) ; \n g_assert ( err == NULL ) ; \n struct_compare ( ts , ts_copy ) ; \n struct_cleanup ( ts ) ; \n struct_cleanup ( ts_copy ) ; \n ops -> cleanup ( serialize_data ) ; \n g_free ( args ) ; \n }", "idx": 25325}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void set_irq_level ( void * opaque , int n , int level ) \n { \n NVICState * s = opaque ; \n VecInfo * vec ; \n n += NVIC_FIRST_IRQ ; \n assert ( n >= NVIC_FIRST_IRQ && n < s -> num_irq ) ; \n trace_nvic_set_irq_level ( n , level ) ; \n vec = & s -> vectors [ n ] ; \n if ( level != vec -> level ) { \n vec -> level = level ; \n if ( level ) { \n armv7m_nvic_set_pending ( s , n ) ; \n } \n } \n }", "idx": 25363}
{"project": "qemu", "commit_id": "93b91c59dbccde6e4d25661150c1529bd5ee4a06", "target": 1, "func": "QObject * qmp_dispatch ( QObject * request ) \n { \n Error * err = NULL ; \n QObject * ret ; \n QDict * rsp ; \n ret = do_qmp_dispatch ( request , & err ) ; \n rsp = qdict_new ( ) ; \n if ( err ) { \n qdict_put_obj ( rsp , \" \" , error_get_qobject ( err ) ) ; \n error_free ( err ) ; \n } else if ( ret ) { \n qdict_put_obj ( rsp , \" \" , ret ) ; \n } else { \n QDECREF ( rsp ) ; \n return NULL ; \n } \n return QOBJECT ( rsp ) ; \n }", "idx": 25388}
{"project": "qemu", "commit_id": "e05ca8200216149008fa1b1d1d847bf16691f6b4", "target": 1, "func": "int vhost_dev_start ( struct vhost_dev * hdev , VirtIODevice * vdev ) \n { \n int i , r ; \n hdev -> started = true ; \n r = vhost_dev_set_features ( hdev , hdev -> log_enabled ) ; \n if ( r < 0 ) { \n goto fail_features ; \n } \n r = hdev -> vhost_ops -> vhost_call ( hdev , VHOST_SET_MEM_TABLE , hdev -> mem ) ; \n if ( r < 0 ) { \n r = - errno ; \n goto fail_mem ; \n } \n for ( i = 0 ; i < hdev -> nvqs ; ++ i ) { \n r = vhost_virtqueue_start ( hdev , \n vdev , \n hdev -> vqs + i , \n hdev -> vq_index + i ) ; \n if ( r < 0 ) { \n goto fail_vq ; \n } \n } \n if ( hdev -> log_enabled ) { \n hdev -> log_size = vhost_get_log_size ( hdev ) ; \n hdev -> log = hdev -> log_size ? \n g_malloc0 ( hdev -> log_size * sizeof * hdev -> log ) : NULL ; \n r = hdev -> vhost_ops -> vhost_call ( hdev , VHOST_SET_LOG_BASE , hdev -> log ) ; \n if ( r < 0 ) { \n r = - errno ; \n goto fail_log ; \n } \n } \n return 0 ; \n fail_log : \n fail_vq : \n while ( -- i >= 0 ) { \n vhost_virtqueue_stop ( hdev , \n vdev , \n hdev -> vqs + i , \n hdev -> vq_index + i ) ; \n } \n i = hdev -> nvqs ; \n fail_mem : \n fail_features : \n hdev -> started = false ; \n return r ; \n }", "idx": 25414}
{"project": "qemu", "commit_id": "21b2f13ae21974e0fd7f8da99d84628a8000d1d7", "target": 1, "func": "static void mmubooke_dump_mmu ( FILE * f , fprintf_function cpu_fprintf , \n CPUPPCState * env ) \n { \n ppcemb_tlb_t * entry ; \n int i ; \n if ( kvm_enabled ( ) && ! env -> kvm_sw_tlb ) { \n cpu_fprintf ( f , \" \\n \" ) ; \n return ; \n } \n cpu_fprintf ( f , \" \\n \\n \" ) ; \n cpu_fprintf ( f , \" \" \n \" \\n \" ) ; \n entry = & env -> tlb . tlbe [ 0 ] ; \n for ( i = 0 ; i < env -> nb_tlb ; i ++ , entry ++ ) { \n hwaddr ea , pa ; \n target_ulong mask ; \n uint64_t size = ( uint64_t ) entry -> size ; \n char size_buf [ 20 ] ; \n if ( ! ( entry -> prot & PAGE_VALID ) ) { \n continue ; \n } \n mask = ~ ( entry -> size - 1 ) ; \n ea = entry -> EPN & mask ; \n pa = entry -> RPN & mask ; \n #if ( TARGET_PHYS_ADDR_SPACE_BITS >= 36 )  \n  \n  \n  \n  pa |= ( hwaddr ) ( entry -> RPN & 0xF ) << 32 ; \n #endif \n size /= 1024 ; \n if ( size >= 1024 ) { \n snprintf ( size_buf , sizeof ( size_buf ) , \" \" PRId64 \" \" , size / 1024 ) ; \n } else { \n snprintf ( size_buf , sizeof ( size_buf ) , \" \" PRId64 \" \" , size ) ; \n } \n cpu_fprintf ( f , \" \" PRIx64 \" \" PRIx64 \" \\n \" , \n ( uint64_t ) ea , ( uint64_t ) pa , size_buf , ( uint32_t ) entry -> PID , \n entry -> prot , entry -> attr ) ; \n } \n }", "idx": 25468}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power9_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PnvChipClass * k = PNV_CHIP_CLASS ( klass ) ; \n k -> cpu_model = \" \" ; \n k -> chip_type = PNV_CHIP_POWER9 ; \n k -> chip_cfam_id = 0x100d104980000000ull ; \n k -> cores_mask = POWER9_CORE_MASK ; \n k -> core_pir = pnv_chip_core_pir_p9 ; \n dc -> desc = \" \" ; \n }", "idx": 25498}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll ( AioContext * ctx , GPollFD * pfds , \n unsigned npfd , int64_t timeout ) \n { \n return false ; \n }", "idx": 25519}
{"project": "qemu", "commit_id": "53724ee565565f69560dbe17553bede8c0169379", "target": 0, "func": "void spapr_tce_reset ( DMAContext * dma ) \n { \n if ( dma ) { \n sPAPRTCETable * tcet = DO_UPCAST ( sPAPRTCETable , dma , dma ) ; \n size_t table_size = ( tcet -> window_size >> SPAPR_TCE_PAGE_SHIFT ) \n * sizeof ( sPAPRTCE ) ; \n memset ( tcet -> table , 0 , table_size ) ; \n } \n }", "idx": 25551}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_hi_offset ( int regno ) \n { \n return offsetof ( CPUARMState , vfp . regs [ regno * 2 + 1 ] ) ; \n }", "idx": 25570}
{"project": "qemu", "commit_id": "7466bc49107fbd84336ba680f860d5eadd6def13", "target": 0, "func": "void qemu_spice_display_init ( DisplayState * ds ) \n { \n assert ( sdpy . ds == NULL ) ; \n sdpy . ds = ds ; \n sdpy . bufsize = ( 16 * 1024 * 1024 ) ; \n sdpy . buf = qemu_malloc ( sdpy . bufsize ) ; \n pthread_mutex_init ( & sdpy . lock , NULL ) ; \n register_displaychangelistener ( ds , & display_listener ) ; \n sdpy . qxl . base . sif = & dpy_interface . base ; \n qemu_spice_add_interface ( & sdpy . qxl . base ) ; \n assert ( sdpy . worker ) ; \n qemu_add_vm_change_state_handler ( qemu_spice_vm_change_state_handler , & sdpy ) ; \n qemu_spice_create_host_memslot ( & sdpy ) ; \n qemu_spice_create_host_primary ( & sdpy ) ; \n }", "idx": 25576}
{"project": "qemu", "commit_id": "b7bad50ae81efeb180609eeecdb086ebc7536ed7", "target": 0, "func": "static void cryptodev_builtin_cleanup ( \n CryptoDevBackend * backend , \n Error * * errp ) \n { \n CryptoDevBackendBuiltin * builtin = \n CRYPTODEV_BACKEND_BUILTIN ( backend ) ; \n size_t i ; \n int queues = backend -> conf . peers . queues ; \n CryptoDevBackendClient * cc ; \n for ( i = 0 ; i < MAX_NUM_SESSIONS ; i ++ ) { \n if ( builtin -> sessions [ i ] != NULL ) { \n cryptodev_builtin_sym_close_session ( \n backend , i , 0 , errp ) ; \n } \n } \n assert ( queues == 1 ) ; \n for ( i = 0 ; i < queues ; i ++ ) { \n cc = backend -> conf . peers . ccs [ i ] ; \n if ( cc ) { \n cryptodev_backend_free_client ( cc ) ; \n backend -> conf . peers . ccs [ i ] = NULL ; \n } \n } \n cryptodev_backend_set_ready ( backend , false ) ; \n }", "idx": 25585}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void clear_commits ( BDRVVVFATState * s ) \n { \n int i ; \n DLOG ( fprintf ( stderr , \" \\n \" , s -> commits . next ) ) ; \n for ( i = 0 ; i < s -> commits . next ; i ++ ) { \n commit_t * commit = array_get ( & ( s -> commits ) , i ) ; \n assert ( commit -> path || commit -> action == ACTION_WRITEOUT ) ; \n if ( commit -> action != ACTION_WRITEOUT ) { \n assert ( commit -> path ) ; \n free ( commit -> path ) ; \n } else \n assert ( commit -> path == NULL ) ; \n } \n s -> commits . next = 0 ; \n }", "idx": 25586}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_rx_descr ( struct Vmxnet3_RxDesc * descr )  \n { \n VMW_PKPRN ( \" \" PRIx64 \" \" \n \" \" , \n le64_to_cpu ( descr -> addr ) , descr -> len , descr -> gen , \n descr -> rsvd , descr -> dtype , descr -> ext1 , descr -> btype ) ; \n }", "idx": 25600}
{"project": "qemu", "commit_id": "2ffcb18de0bc02ad8a836ec955584c02b70e0e24", "target": 0, "func": "int do_netdev_del ( Monitor * mon , const QDict * qdict , QObject * * ret_data ) \n { \n const char * id = qdict_get_str ( qdict , \" \" ) ; \n VLANClientState * vc ; \n vc = qemu_find_netdev ( id ) ; \n if ( ! vc || vc -> info -> type == NET_CLIENT_TYPE_NIC ) { \n qerror_report ( QERR_DEVICE_NOT_FOUND , id ) ; \n return -1 ; \n } \n if ( vc -> peer ) { \n qerror_report ( QERR_DEVICE_IN_USE , id ) ; \n return -1 ; \n } \n qemu_del_vlan_client ( vc ) ; \n qemu_opts_del ( qemu_opts_find ( & qemu_netdev_opts , id ) ) ; \n return 0 ; \n }", "idx": 25622}
{"project": "qemu", "commit_id": "59b060be184aff59cfa101c937c8139e66f452f2", "target": 0, "func": "int qcrypto_pbkdf2 ( QCryptoHashAlgorithm hash G_GNUC_UNUSED , \n const uint8_t * key G_GNUC_UNUSED , \n size_t nkey G_GNUC_UNUSED , \n const uint8_t * salt G_GNUC_UNUSED , \n size_t nsalt G_GNUC_UNUSED , \n unsigned int iterations G_GNUC_UNUSED , \n uint8_t * out G_GNUC_UNUSED , \n size_t nout G_GNUC_UNUSED , \n Error * * errp ) \n { \n error_setg_errno ( errp , ENOSYS , \n \" \" ) ; \n return -1 ; \n }", "idx": 25624}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static inline void vmxnet3_ring_read_curr_cell ( Vmxnet3Ring * ring , void * buff ) \n { \n vmw_shmem_read ( vmxnet3_ring_curr_cell_pa ( ring ) , buff , ring -> cell_size ) ; \n }", "idx": 25676}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static CharDriverState * create_eventfd_chr_device ( void * opaque , EventNotifier * n , \n int vector ) \n { \n IVShmemState * s = opaque ; \n CharDriverState * chr ; \n int eventfd = event_notifier_get_fd ( n ) ; \n chr = qemu_chr_open_eventfd ( eventfd ) ; \n if ( chr == NULL ) { \n fprintf ( stderr , \" \\n \" , eventfd ) ; \n exit ( -1 ) ; \n } \n if ( ivshmem_has_feature ( s , IVSHMEM_MSI ) ) { \n s -> eventfd_table [ vector ] . pdev = & s -> dev ; \n s -> eventfd_table [ vector ] . vector = vector ; \n qemu_chr_add_handlers ( chr , ivshmem_can_receive , fake_irqfd , \n ivshmem_event , & s -> eventfd_table [ vector ] ) ; \n } else { \n qemu_chr_add_handlers ( chr , ivshmem_can_receive , ivshmem_receive , \n ivshmem_event , s ) ; \n } \n return chr ; \n }", "idx": 25682}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "static void xics_realize ( DeviceState * dev , Error * * errp ) \n { \n XICSState * icp = XICS ( dev ) ; \n Error * error = NULL ; \n int i ; \n if ( ! icp -> nr_servers ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n spapr_rtas_register ( \" \" , rtas_set_xive ) ; \n spapr_rtas_register ( \" \" , rtas_get_xive ) ; \n spapr_rtas_register ( \" \" , rtas_int_off ) ; \n spapr_rtas_register ( \" \" , rtas_int_on ) ; \n spapr_register_hypercall ( H_CPPR , h_cppr ) ; \n spapr_register_hypercall ( H_IPI , h_ipi ) ; \n spapr_register_hypercall ( H_XIRR , h_xirr ) ; \n spapr_register_hypercall ( H_XIRR_X , h_xirr_x ) ; \n spapr_register_hypercall ( H_EOI , h_eoi ) ; \n spapr_register_hypercall ( H_IPOLL , h_ipoll ) ; \n object_property_set_bool ( OBJECT ( icp -> ics ) , true , \" \" , & error ) ; \n if ( error ) { \n error_propagate ( errp , error ) ; \n return ; \n } \n for ( i = 0 ; i < icp -> nr_servers ; i ++ ) { \n object_property_set_bool ( OBJECT ( & icp -> ss [ i ] ) , true , \" \" , & error ) ; \n if ( error ) { \n error_propagate ( errp , error ) ; \n return ; \n } \n } \n }", "idx": 25686}
{"project": "qemu", "commit_id": "428c3ece97179557f2753071fb0ca97a03437267", "target": 0, "func": "static bool msi_is_masked ( const PCIDevice * dev , unsigned int vector ) \n { \n uint16_t flags = pci_get_word ( dev -> config + msi_flags_off ( dev ) ) ; \n uint32_t mask ; \n assert ( vector < PCI_MSI_VECTORS_MAX ) ; \n if ( ! ( flags & PCI_MSI_FLAGS_MASKBIT ) ) { \n return false ; \n } \n mask = pci_get_long ( dev -> config + \n msi_mask_off ( dev , flags & PCI_MSI_FLAGS_64BIT ) ) ; \n return mask & ( 1U << vector ) ; \n }", "idx": 25706}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_bar_quirk_teardown ( VFIOPCIDevice * vdev , int nr ) \n { \n VFIOBAR * bar = & vdev -> bars [ nr ] ; \n while ( ! QLIST_EMPTY ( & bar -> quirks ) ) { \n VFIOQuirk * quirk = QLIST_FIRST ( & bar -> quirks ) ; \n memory_region_del_subregion ( & bar -> region . mem , & quirk -> mem ) ; \n object_unparent ( OBJECT ( & quirk -> mem ) ) ; \n QLIST_REMOVE ( quirk , next ) ; \n g_free ( quirk ) ; \n } \n }", "idx": 25713}
{"project": "qemu", "commit_id": "eaf944a43835399f12808aebd0d0a1db6249ed07", "target": 1, "func": "static int blkdebug_open ( BlockDriverState * bs , QDict * options , int flags , \n Error * * errp ) \n { \n BDRVBlkdebugState * s = bs -> opaque ; \n QemuOpts * opts ; \n Error * local_err = NULL ; \n const char * config ; \n uint64_t align ; \n int ret ; \n opts = qemu_opts_create ( & runtime_opts , NULL , 0 , & error_abort ) ; \n qemu_opts_absorb_qdict ( opts , options , & local_err ) ; \n if ( error_is_set ( & local_err ) ) { \n error_propagate ( errp , local_err ) ; \n ret = - EINVAL ; \n goto fail ; \n } \n config = qemu_opt_get ( opts , \" \" ) ; \n ret = read_config ( s , config , options , errp ) ; \n if ( ret ) { \n goto fail ; \n } \n s -> state = 1 ; \n ret = bdrv_open_image ( & bs -> file , qemu_opt_get ( opts , \" \" ) , options , \" \" , \n flags , true , false , & local_err ) ; \n if ( ret < 0 ) { \n error_propagate ( errp , local_err ) ; \n goto fail ; \n } \n align = qemu_opt_get_size ( opts , \" \" , bs -> request_alignment ) ; \n if ( align > 0 && align < INT_MAX && ! ( align & ( align - 1 ) ) ) { \n bs -> request_alignment = align ; \n } else { \n error_setg ( errp , \" \" ) ; \n ret = - EINVAL ; \n goto fail ; \n } \n ret = 0 ; \n fail : \n qemu_opts_del ( opts ) ; \n return ret ; \n }", "idx": 25714}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_init ( void ) \n { \n struct sigaction act ; \n aio_initialized = 1 ; \n sigfillset ( & act . sa_mask ) ; \n act . sa_flags = 0 ; \n act . sa_handler = aio_signal_handler ; \n sigaction ( aio_sig_num , & act , NULL ) ; \n #if defined ( __GLIBC__ ) && defined ( __linux__ )  \n  \n  { \n struct aioinit ai ; \n memset ( & ai , 0 , sizeof ( ai ) ) ; \n ai . aio_threads = 1 ; \n ai . aio_num = 1 ; \n ai . aio_idle_time = 365 * 100000 ; \n aio_init ( & ai ) ; \n } \n #endif \n }", "idx": 25717}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_type_any ( Visitor * v , const char * name , QObject * * obj , \n Error * * errp ) \n { \n QmpInputVisitor * qiv = to_qiv ( v ) ; \n QObject * qobj = qmp_input_get_object ( qiv , name , true , errp ) ; \n * obj = NULL ; \n if ( ! qobj ) { \n return ; \n } \n qobject_incref ( qobj ) ; \n * obj = qobj ; \n }", "idx": 25769}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "void * g_try_malloc ( size_t n_bytes ) \n { \n __coverity_negative_sink__ ( n_bytes ) ; \n return malloc ( n_bytes == 0 ? 1 : n_bytes ) ; \n }", "idx": 25775}
{"project": "qemu", "commit_id": "17eb587aeb492fe68f8130b027154ff0921fc0b4", "target": 1, "func": "static int tftp_session_allocate ( Slirp * slirp , struct sockaddr_storage * srcsas , \n struct tftp_t * tp ) \n { \n struct tftp_session * spt ; \n int k ; \n for ( k = 0 ; k < TFTP_SESSIONS_MAX ; k ++ ) { \n spt = & slirp -> tftp_sessions [ k ] ; \n if ( ! tftp_session_in_use ( spt ) ) \n goto found ; \n if ( ( int ) ( curtime - spt -> timestamp ) > 5000 ) { \n tftp_session_terminate ( spt ) ; \n goto found ; \n } \n } \n return -1 ; \n found : \n memset ( spt , 0 , sizeof ( * spt ) ) ; \n spt -> client_addr = * srcsas ; \n spt -> fd = -1 ; \n spt -> block_size = 512 ; \n spt -> client_port = tp -> udp . uh_sport ; \n spt -> slirp = slirp ; \n tftp_session_update ( spt ) ; \n return k ; \n }", "idx": 25785}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int tcp_get_msgfd ( CharDriverState * chr ) \n { \n TCPCharDriver * s = chr -> opaque ; \n return s -> msgfd ; \n }", "idx": 25839}
{"project": "qemu", "commit_id": "0e3b800e71cb7759d099eabbd8ad4c4fe848e381", "target": 1, "func": "static void lan9118_eeprom_cmd ( lan9118_state * s , int cmd , int addr ) \n { \n s -> e2p_cmd = ( s -> e2p_cmd & 0x10 ) | ( cmd << 28 ) | addr ; \n switch ( cmd ) { \n case 0 : \n s -> e2p_data = s -> eeprom [ addr ] ; \n DPRINTF ( \" \\n \" , addr , s -> e2p_data ) ; \n case 1 : \n s -> eeprom_writable = 0 ; \n DPRINTF ( \" \\n \" ) ; \n case 2 : \n s -> eeprom_writable = 1 ; \n DPRINTF ( \" \\n \" ) ; \n case 3 : \n if ( s -> eeprom_writable ) { \n s -> eeprom [ addr ] &= s -> e2p_data ; \n DPRINTF ( \" \\n \" , addr , s -> e2p_data ) ; \n } else { \n DPRINTF ( \" \\n \" , addr ) ; \n } \n case 4 : \n if ( s -> eeprom_writable ) { \n for ( addr = 0 ; addr < 128 ; addr ++ ) { \n s -> eeprom [ addr ] &= s -> e2p_data ; \n } \n DPRINTF ( \" \\n \" , s -> e2p_data ) ; \n } else { \n DPRINTF ( \" \\n \" ) ; \n } \n case 5 : \n if ( s -> eeprom_writable ) { \n s -> eeprom [ addr ] = 0xff ; \n DPRINTF ( \" \\n \" , addr ) ; \n } else { \n DPRINTF ( \" \\n \" , addr ) ; \n } \n case 6 : \n if ( s -> eeprom_writable ) { \n memset ( s -> eeprom , 0xff , 128 ) ; \n DPRINTF ( \" \\n \" ) ; \n } else { \n DPRINTF ( \" \\n \" ) ; \n } \n case 7 : \n lan9118_reload_eeprom ( s ) ; \n } \n }", "idx": 25913}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_store_status_at_address ( CPUState * cs , run_on_cpu_data arg ) \n { \n S390CPU * cpu = S390_CPU ( cs ) ; \n SigpInfo * si = arg . host_ptr ; \n uint32_t address = si -> param & 0x7ffffe00u ; \n if ( s390_cpu_get_state ( cpu ) != CPU_STATE_STOPPED ) { \n set_sigp_status ( si , SIGP_STAT_INCORRECT_STATE ) ; \n return ; \n } \n cpu_synchronize_state ( cs ) ; \n if ( s390_store_status ( cpu , address , false ) ) { \n set_sigp_status ( si , SIGP_STAT_INVALID_PARAMETER ) ; \n return ; \n } \n si -> cc = SIGP_CC_ORDER_CODE_ACCEPTED ; \n }", "idx": 25921}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_spice_port ( QemuOpts * opts , ChardevBackend * backend , \n Error * * errp ) \n { \n const char * name = qemu_opt_get ( opts , \" \" ) ; \n ChardevSpicePort * spiceport ; \n if ( name == NULL ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n spiceport = backend -> u . spiceport = g_new0 ( ChardevSpicePort , 1 ) ; \n qemu_chr_parse_common ( opts , qapi_ChardevSpicePort_base ( spiceport ) ) ; \n spiceport -> fqdn = g_strdup ( name ) ; \n }", "idx": 25962}
{"project": "qemu", "commit_id": "4c8d0d27676778febad3802a95218d5ceaca171e", "target": 0, "func": "void qemu_fd_register ( int fd ) \n { \n WSAEventSelect ( fd , qemu_event_handle , FD_READ | FD_ACCEPT | FD_CLOSE | \n FD_CONNECT | FD_WRITE | FD_OOB ) ; \n }", "idx": 25975}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static struct pxa2xx_i2s_s * pxa2xx_i2s_init ( target_phys_addr_t base , \n qemu_irq irq , struct pxa2xx_dma_state_s * dma ) \n { \n int iomemtype ; \n struct pxa2xx_i2s_s * s = ( struct pxa2xx_i2s_s * ) \n qemu_mallocz ( sizeof ( struct pxa2xx_i2s_s ) ) ; \n s -> base = base ; \n s -> irq = irq ; \n s -> dma = dma ; \n s -> data_req = pxa2xx_i2s_data_req ; \n pxa2xx_i2s_reset ( s ) ; \n iomemtype = cpu_register_io_memory ( 0 , pxa2xx_i2s_readfn , \n pxa2xx_i2s_writefn , s ) ; \n cpu_register_physical_memory ( s -> base & 0xfff00000 , 0xfffff , iomemtype ) ; \n register_savevm ( \" \" , base , 0 , \n pxa2xx_i2s_save , pxa2xx_i2s_load , s ) ; \n return s ; \n }", "idx": 25980}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_nesting ( void ) \n { \n unsigned int i , maxcycles , maxnesting ; \n double duration ; \n maxcycles = 10000 ; \n maxnesting = 1000 ; \n Coroutine * root ; \n g_test_timer_start ( ) ; \n for ( i = 0 ; i < maxcycles ; i ++ ) { \n NestData nd = { \n . n_enter = 0 , \n . n_return = 0 , \n . max = maxnesting , \n } ; \n root = qemu_coroutine_create ( nest ) ; \n qemu_coroutine_enter ( root , & nd ) ; \n } \n duration = g_test_timer_elapsed ( ) ; \n g_test_message ( \" \\n \" , \n maxcycles , maxnesting , duration ) ; \n }", "idx": 25982}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "void hpet_init ( qemu_irq * irq ) { \n int i , iomemtype ; \n HPETState * s ; \n DPRINTF ( \" \\n \" ) ; \n s = qemu_mallocz ( sizeof ( HPETState ) ) ; \n hpet_statep = s ; \n s -> irqs = irq ; \n for ( i = 0 ; i < HPET_NUM_TIMERS ; i ++ ) { \n HPETTimer * timer = & s -> timer [ i ] ; \n timer -> qemu_timer = qemu_new_timer ( vm_clock , hpet_timer , timer ) ; \n } \n vmstate_register ( -1 , & vmstate_hpet , s ) ; \n qemu_register_reset ( hpet_reset , s ) ; \n iomemtype = cpu_register_io_memory ( hpet_ram_read , \n hpet_ram_write , s ) ; \n cpu_register_physical_memory ( HPET_BASE , 0x400 , iomemtype ) ; \n }", "idx": 25986}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void slavio_serial_ms_kbd_init ( target_phys_addr_t base , qemu_irq irq , \n int disabled , int clock , int it_shift ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_prop_set_uint32 ( dev , \" \" , disabled ) ; \n qdev_prop_set_uint32 ( dev , \" \" , clock ) ; \n qdev_prop_set_uint32 ( dev , \" \" , it_shift ) ; \n qdev_prop_set_chr ( dev , \" \" , NULL ) ; \n qdev_prop_set_chr ( dev , \" \" , NULL ) ; \n qdev_prop_set_uint32 ( dev , \" \" , mouse ) ; \n qdev_prop_set_uint32 ( dev , \" \" , kbd ) ; \n qdev_init_nofail ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n sysbus_connect_irq ( s , 0 , irq ) ; \n sysbus_connect_irq ( s , 1 , irq ) ; \n sysbus_mmio_map ( s , 0 , base ) ; \n }", "idx": 26007}
{"project": "qemu", "commit_id": "a1abf40d6be2fc4b40d90ae3b46442f4a671776b", "target": 1, "func": "void laio_cleanup ( void * s_ ) \n { \n struct qemu_laio_state * s = s_ ; \n event_notifier_cleanup ( & s -> e ) ; \n g_free ( s ) ; ", "idx": 26049}
{"project": "qemu", "commit_id": "7bb5d6ade6d8afbcad72a871f712370ffae457c6", "target": 0, "func": "static void pc_dimm_init ( Object * obj ) \n { \n PCDIMMDevice * dimm = PC_DIMM ( obj ) ; \n object_property_add ( obj , PC_DIMM_SIZE_PROP , \" \" , pc_dimm_get_size , \n NULL , NULL , NULL , & error_abort ) ; \n object_property_add_link ( obj , PC_DIMM_MEMDEV_PROP , TYPE_MEMORY_BACKEND , \n ( Object * * ) & dimm -> hostmem , \n qdev_prop_allow_set_link_before_realize , \n OBJ_PROP_LINK_UNREF_ON_RELEASE , \n & error_abort ) ; \n }", "idx": 26118}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static always_inline int find_pte ( CPUState * env , mmu_ctx_t * ctx , \n int h , int rw ) \n { \n #if defined ( TARGET_PPC64 )  \n  \n  if ( env -> mmu_model == POWERPC_MMU_64B ) \n return find_pte64 ( ctx , h , rw ) ; \n #endif \n return find_pte32 ( ctx , h , rw ) ; \n }", "idx": 26122}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static void tcp_chr_accept ( void * opaque ) \n { \n CharDriverState * chr = opaque ; \n TCPCharDriver * s = chr -> opaque ; \n struct sockaddr_in saddr ; \n #ifndef _WIN32 \n struct sockaddr_un uaddr ; \n #endif \n struct sockaddr * addr ; \n socklen_t len ; \n int fd ; \n for ( ; ; ) { \n #ifndef _WIN32 \n if ( s -> is_unix ) { \n len = sizeof ( uaddr ) ; \n addr = ( struct sockaddr * ) & uaddr ; \n } else \n #endif \n { \n len = sizeof ( saddr ) ; \n addr = ( struct sockaddr * ) & saddr ; \n } \n fd = accept ( s -> listen_fd , addr , & len ) ; \n if ( fd < 0 && errno != EINTR ) { \n return ; \n } else if ( fd >= 0 ) { \n if ( s -> do_telnetopt ) \n tcp_chr_telnet_init ( fd ) ; \n break ; \n } \n } \n socket_set_nonblock ( fd ) ; \n if ( s -> do_nodelay ) \n socket_set_nodelay ( fd ) ; \n s -> fd = fd ; \n qemu_set_fd_handler ( s -> listen_fd , NULL , NULL , NULL ) ; \n tcp_chr_connect ( chr ) ; \n }", "idx": 26141}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_int8 ( TestOutputVisitorData * data , \n const void * unused ) \n { \n test_native_list ( data , unused , USER_DEF_NATIVE_LIST_UNION_KIND_S8 ) ; \n }", "idx": 26149}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_finish_event ( void ) \n { \n replay_has_unread_data = 0 ; \n replay_fetch_data_kind ( ) ; \n }", "idx": 26199}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static int64_t coroutine_fn qcow2_co_get_block_status ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors , int * pnum , BlockDriverState * * file ) \n { \n BDRVQcow2State * s = bs -> opaque ; \n uint64_t cluster_offset ; \n int index_in_cluster , ret ; \n unsigned int bytes ; \n int64_t status = 0 ; \n bytes = MIN ( INT_MAX , nb_sectors * BDRV_SECTOR_SIZE ) ; \n qemu_co_mutex_lock ( & s -> lock ) ; \n ret = qcow2_get_cluster_offset ( bs , sector_num << 9 , & bytes , \n & cluster_offset ) ; \n qemu_co_mutex_unlock ( & s -> lock ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n * pnum = bytes >> BDRV_SECTOR_BITS ; \n if ( cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED && \n ! s -> cipher ) { \n index_in_cluster = sector_num & ( s -> cluster_sectors - 1 ) ; \n cluster_offset |= ( index_in_cluster << BDRV_SECTOR_BITS ) ; \n * file = bs -> file -> bs ; \n status |= BDRV_BLOCK_OFFSET_VALID | cluster_offset ; \n } \n if ( ret == QCOW2_CLUSTER_ZERO_PLAIN || ret == QCOW2_CLUSTER_ZERO_ALLOC ) { \n status |= BDRV_BLOCK_ZERO ; \n } else if ( ret != QCOW2_CLUSTER_UNALLOCATED ) { \n status |= BDRV_BLOCK_DATA ; \n } \n return status ; \n }", "idx": 26202}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_truncate ( FsContext * ctx , V9fsPath * fs_path , off_t size ) \n { \n char buffer [ PATH_MAX ] ; \n char * path = fs_path -> data ; \n return truncate ( rpath ( ctx , path , buffer ) , size ) ; \n }", "idx": 26223}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "static bool is_zero_sectors ( BlockDriverState * bs , int64_t start , \n uint32_t count ) \n { \n int nr ; \n BlockDriverState * file ; \n int64_t res ; \n if ( start + count > bs -> total_sectors ) { \n count = bs -> total_sectors - start ; \n } \n if ( ! count ) { \n return true ; \n } \n res = bdrv_get_block_status_above ( bs , NULL , start , count , \n & nr , & file ) ; \n return res >= 0 && ( res & BDRV_BLOCK_ZERO ) && nr == count ; \n }", "idx": 26227}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "static void iscsi_nop_timed_event ( void * opaque ) \n { \n IscsiLun * iscsilun = opaque ; \n if ( iscsi_get_nops_in_flight ( iscsilun -> iscsi ) > MAX_NOP_FAILURES ) { \n error_report ( \" \" ) ; \n iscsi_reconnect ( iscsilun -> iscsi ) ; \n } \n if ( iscsi_nop_out_async ( iscsilun -> iscsi , NULL , NULL , 0 , NULL ) != 0 ) { \n error_report ( \" \" ) ; \n return ; \n } \n timer_mod ( iscsilun -> nop_timer , qemu_clock_get_ms ( QEMU_CLOCK_REALTIME ) + NOP_INTERVAL ) ; \n iscsi_set_events ( iscsilun ) ; \n }", "idx": 26237}
{"project": "qemu", "commit_id": "1a28cac3161f8a85ee0256776068eaed2da025e5", "target": 0, "func": "void qemu_mutex_lock_iothread ( void ) \n { \n if ( kvm_enabled ( ) ) { \n qemu_mutex_lock ( & qemu_fair_mutex ) ; \n qemu_mutex_lock ( & qemu_global_mutex ) ; \n qemu_mutex_unlock ( & qemu_fair_mutex ) ; \n } else \n qemu_signal_lock ( 100 ) ; \n }", "idx": 26275}
{"project": "qemu", "commit_id": "83f7f32901c630f4fc01acd0d9082da466b17102", "target": 1, "func": "static bool is_special_wait_psw ( CPUState * cs ) \n { \n return cs -> kvm_run -> psw_addr == 0xfffUL ; \n }", "idx": 26296}
{"project": "qemu", "commit_id": "af60314291af3cabda18d27f928b0e0ff899cc76", "target": 1, "func": "static void vhost_commit ( MemoryListener * listener ) \n { \n }", "idx": 26331}
{"project": "qemu", "commit_id": "7a95434e0ca8a037fd8aa1a2e2461f92585eb77b", "target": 1, "func": "static struct dirent * local_readdir ( FsContext * ctx , V9fsFidOpenState * fs ) \n { \n struct dirent * entry ; \n again : \n entry = readdir ( fs -> dir . stream ) ; \n if ( ! entry ) { \n return NULL ; \n } \n if ( ctx -> export_flags & V9FS_SM_MAPPED ) { \n entry -> d_type = DT_UNKNOWN ; \n } else if ( ctx -> export_flags & V9FS_SM_MAPPED_FILE ) { \n if ( ! strcmp ( entry -> d_name , VIRTFS_META_DIR ) ) { \n goto again ; \n } \n entry -> d_type = DT_UNKNOWN ; \n } \n return entry ; \n }", "idx": 26346}
{"project": "qemu", "commit_id": "14cec170ea4724e6881ba2febb20e88a942e52d3", "target": 1, "func": "static int xen_pt_bar_reg_read ( XenPCIPassthroughState * s , XenPTReg * cfg_entry , \n uint32_t * value , uint32_t valid_mask ) \n { \n XenPTRegInfo * reg = cfg_entry -> reg ; \n uint32_t valid_emu_mask = 0 ; \n uint32_t bar_emu_mask = 0 ; \n int index ; \n index = xen_pt_bar_offset_to_index ( reg -> offset ) ; \n if ( index < 0 || index >= PCI_NUM_REGIONS ) { \n XEN_PT_ERR ( & s -> dev , \" \\n \" , index ) ; \n return -1 ; \n } \n * value = base_address_with_flags ( & s -> real_device . io_regions [ index ] ) ; \n switch ( s -> bases [ index ] . bar_flag ) { \n case XEN_PT_BAR_FLAG_MEM : \n bar_emu_mask = XEN_PT_BAR_MEM_EMU_MASK ; \n break ; \n case XEN_PT_BAR_FLAG_IO : \n bar_emu_mask = XEN_PT_BAR_IO_EMU_MASK ; \n break ; \n case XEN_PT_BAR_FLAG_UPPER : \n bar_emu_mask = XEN_PT_BAR_ALLF ; \n break ; \n default : \n break ; \n } \n valid_emu_mask = bar_emu_mask & valid_mask ; \n * value = XEN_PT_MERGE_VALUE ( * value , cfg_entry -> data , ~ valid_emu_mask ) ; \n return 0 ; \n }", "idx": 26372}
{"project": "qemu", "commit_id": "cdd5cc12ba8cf0c068da319370bdd3ba45eaf7ac", "target": 0, "func": "static int virtio_net_can_receive ( VLANClientState * vc ) \n { \n VirtIONet * n = vc -> opaque ; \n return do_virtio_net_can_receive ( n , VIRTIO_NET_MAX_BUFSIZE ) ; \n }", "idx": 26394}
{"project": "qemu", "commit_id": "544a3731591f5d53e15f22de00ce5ac758d490b3", "target": 1, "func": "bool visit_start_union ( Visitor * v , bool data_present , Error * * errp ) \n { \n if ( v -> start_union ) { \n return v -> start_union ( v , data_present , errp ) ; \n } \n return true ; \n }", "idx": 26426}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "static bool arm_cpu_has_work ( CPUState * cs ) \n { \n ARMCPU * cpu = ARM_CPU ( cs ) ; \n return ! cpu -> powered_off \n && cs -> interrupt_request & \n ( CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD \n | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ \n | CPU_INTERRUPT_EXITTB ) ; \n }", "idx": 26445}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_movcf_d ( DisasContext * ctx , int fs , int fd , int cc , int tf ) \n { \n int cond ; \n TCGv_i32 t0 = tcg_temp_new_i32 ( ) ; \n TCGv_i64 fp0 ; \n int l1 = gen_new_label ( ) ; \n if ( tf ) \n cond = TCG_COND_EQ ; \n else \n cond = TCG_COND_NE ; \n tcg_gen_andi_i32 ( t0 , fpu_fcr31 , 1 << get_fp_bit ( cc ) ) ; \n tcg_gen_brcondi_i32 ( cond , t0 , 0 , l1 ) ; \n tcg_temp_free_i32 ( t0 ) ; \n fp0 = tcg_temp_new_i64 ( ) ; \n gen_load_fpr64 ( ctx , fp0 , fs ) ; \n gen_store_fpr64 ( ctx , fp0 , fd ) ; \n tcg_temp_free_i64 ( fp0 ) ; \n gen_set_label ( l1 ) ; \n }", "idx": 26463}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_remove_irqfd ( KVMState * s , int fd , int virq ) \n { \n return - ENOSYS ; \n }", "idx": 26464}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void noop_conv ( st_sample_t * dst , const void * src , \n int samples , volume_t * vol ) \n { \n ( void ) src ; \n ( void ) dst ; \n ( void ) samples ; \n ( void ) vol ; \n }", "idx": 26465}
{"project": "qemu", "commit_id": "81b23ef82cd1be29ca3d69ab7e98b5b5e55926ce", "target": 1, "func": "static int xen_pt_cmd_reg_read ( XenPCIPassthroughState * s , XenPTReg * cfg_entry , \n uint16_t * value , uint16_t valid_mask ) \n { \n XenPTRegInfo * reg = cfg_entry -> reg ; \n uint16_t valid_emu_mask = 0 ; \n uint16_t emu_mask = reg -> emu_mask ; \n if ( s -> is_virtfn ) { \n emu_mask |= PCI_COMMAND_MEMORY ; \n } \n valid_emu_mask = emu_mask & valid_mask ; \n * value = XEN_PT_MERGE_VALUE ( * value , cfg_entry -> data , ~ valid_emu_mask ) ; \n return 0 ; \n }", "idx": 26509}
{"project": "qemu", "commit_id": "06b1297017415ae6a07a0e97ad7d8e90b2d95823", "target": 1, "func": "static int virtio_net_has_buffers ( VirtIONet * n , int bufsize ) \n { \n if ( virtio_queue_empty ( n -> rx_vq ) || \n ( n -> mergeable_rx_bufs && \n ! virtqueue_avail_bytes ( n -> rx_vq , bufsize , 0 ) ) ) { \n virtio_queue_set_notification ( n -> rx_vq , 1 ) ; \n return 0 ; \n } \n virtio_queue_set_notification ( n -> rx_vq , 0 ) ; \n return 1 ; \n }", "idx": 26516}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void qbus_initfn ( Object * obj ) \n { \n BusState * bus = BUS ( obj ) ; \n QTAILQ_INIT ( & bus -> children ) ; \n object_property_add_link ( obj , QDEV_HOTPLUG_HANDLER_PROPERTY , \n TYPE_HOTPLUG_HANDLER , \n ( Object * * ) & bus -> hotplug_handler , NULL ) ; \n object_property_add_bool ( obj , \" \" , \n bus_get_realized , bus_set_realized , NULL ) ; \n }", "idx": 26522}
{"project": "qemu", "commit_id": "3af9187fc6caaf415ab9c0c6d92c9678f65cb17f", "target": 1, "func": "static ssize_t mipsnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size ) \n { \n MIPSnetState * s = qemu_get_nic_opaque ( nc ) ; \n trace_mipsnet_receive ( size ) ; \n if ( ! mipsnet_can_receive ( nc ) ) \n s -> busy = 1 ; \n memcpy ( s -> rx_buffer , buf , size ) ; \n s -> rx_count = size ; \n s -> rx_read = 0 ; \n s -> intctl |= MIPSNET_INTCTL_RXDONE ; \n mipsnet_update_irq ( s ) ; \n return size ; ", "idx": 26527}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_tipb_bridge_s * omap_tipb_bridge_init ( \n MemoryRegion * memory , target_phys_addr_t base , \n qemu_irq abort_irq , omap_clk clk ) \n { \n struct omap_tipb_bridge_s * s = ( struct omap_tipb_bridge_s * ) \n g_malloc0 ( sizeof ( struct omap_tipb_bridge_s ) ) ; \n s -> abort = abort_irq ; \n omap_tipb_bridge_reset ( s ) ; \n memory_region_init_io ( & s -> iomem , & omap_tipb_bridge_ops , s , \n \" \" , 0x100 ) ; \n memory_region_add_subregion ( memory , base , & s -> iomem ) ; \n return s ; \n }", "idx": 26566}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void thread_pool_submit ( ThreadPool * pool , ThreadPoolFunc * func , void * arg ) \n { \n thread_pool_submit_aio ( pool , func , arg , NULL , NULL ) ; \n }", "idx": 26569}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_writev_vmstate ( BlockDriverState * bs , QEMUIOVector * qiov , int64_t pos ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) { \n return - ENOMEDIUM ; \n } else if ( drv -> bdrv_save_vmstate ) { \n return drv -> bdrv_save_vmstate ( bs , qiov , pos ) ; \n } else if ( bs -> file ) { \n return bdrv_writev_vmstate ( bs -> file , qiov , pos ) ; \n } \n return - ENOTSUP ; \n }", "idx": 26573}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_statfs ( FsContext * s , V9fsPath * fs_path , struct statfs * stbuf ) \n { \n char buffer [ PATH_MAX ] ; \n char * path = fs_path -> data ; \n return statfs ( rpath ( s , path , buffer ) , stbuf ) ; \n }", "idx": 26576}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_get_msr ( CPUState * env , struct kvm_msr_entry * msrs , int n ) \n { \n struct kvm_msrs * kmsrs = qemu_malloc ( sizeof * kmsrs + n * sizeof * msrs ) ; \n int r ; \n kmsrs -> nmsrs = n ; \n memcpy ( kmsrs -> entries , msrs , n * sizeof * msrs ) ; \n r = kvm_vcpu_ioctl ( env , KVM_GET_MSRS , kmsrs ) ; \n memcpy ( msrs , kmsrs -> entries , n * sizeof * msrs ) ; \n free ( kmsrs ) ; \n return r ; \n }", "idx": 26600}
{"project": "qemu", "commit_id": "cfdf2c40577ed99bb19cdc05d0537e2808d77a78", "target": 0, "func": "static void do_balloon ( Monitor * mon , const QDict * qdict , QObject * * ret_data ) \n { \n int value = qdict_get_int ( qdict , \" \" ) ; \n ram_addr_t target = value ; \n qemu_balloon ( target << 20 ) ; \n }", "idx": 26606}
{"project": "qemu", "commit_id": "1d2acc3162d9c7772510c973f446353fbdd1f9a8", "target": 1, "func": "static void migrate_fd_cancel ( MigrationState * s ) \n { \n int old_state ; \n QEMUFile * f = migrate_get_current ( ) -> to_dst_file ; \n trace_migrate_fd_cancel ( ) ; \n if ( s -> rp_state . from_dst_file ) { \n qemu_file_shutdown ( s -> rp_state . from_dst_file ) ; \n do { \n old_state = s -> state ; \n if ( ! migration_is_setup_or_active ( old_state ) ) { \n break ; \n migrate_set_state ( & s -> state , old_state , MIGRATION_STATUS_CANCELLING ) ; \n } while ( s -> state != MIGRATION_STATUS_CANCELLING ) ; \n if ( s -> state == MIGRATION_STATUS_CANCELLING && f ) { \n qemu_file_shutdown ( f ) ;", "idx": 26619}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static IOMMUTLBEntry vtd_iommu_translate ( MemoryRegion * iommu , hwaddr addr , \n bool is_write ) \n { \n VTDAddressSpace * vtd_as = container_of ( iommu , VTDAddressSpace , iommu ) ; \n IntelIOMMUState * s = vtd_as -> iommu_state ; \n IOMMUTLBEntry ret = { \n . target_as = & address_space_memory , \n . iova = addr , \n . translated_addr = 0 , \n . addr_mask = ~ ( hwaddr ) 0 , \n . perm = IOMMU_NONE , \n } ; \n if ( ! s -> dmar_enabled ) { \n ret . iova = addr & VTD_PAGE_MASK_4K ; \n ret . translated_addr = addr & VTD_PAGE_MASK_4K ; \n ret . addr_mask = ~ VTD_PAGE_MASK_4K ; \n ret . perm = IOMMU_RW ; \n return ret ; \n } \n vtd_do_iommu_translate ( vtd_as , vtd_as -> bus , vtd_as -> devfn , addr , \n is_write , & ret ) ; \n VTD_DPRINTF ( MMU , \n \" \" PRIu8 \" \" PRIu8 \" \" PRIu8 \" \" PRIu8 \n \" \" PRIx64 \" \" PRIx64 , pci_bus_num ( vtd_as -> bus ) , \n VTD_PCI_SLOT ( vtd_as -> devfn ) , VTD_PCI_FUNC ( vtd_as -> devfn ) , \n vtd_as -> devfn , addr , ret . translated_addr ) ; \n return ret ; \n }", "idx": 26646}
{"project": "qemu", "commit_id": "d185c094b404b4ff392b77d1244c0233da7d53bd", "target": 0, "func": "static gboolean io_watch_poll_check ( GSource * source ) \n { \n IOWatchPoll * iwp = io_watch_poll_from_source ( source ) ; \n if ( iwp -> max_size == 0 ) { \n return FALSE ; \n } \n return g_io_watch_funcs . check ( source ) ; \n }", "idx": 26647}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "void qmp_object_add ( const char * type , const char * id , \n bool has_props , QObject * props , Error * * errp ) \n { \n const QDict * pdict = NULL ; \n QmpInputVisitor * qiv ; \n Object * obj ; \n if ( props ) { \n pdict = qobject_to_qdict ( props ) ; \n if ( ! pdict ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , \" \" , \" \" ) ; \n return ; \n } \n } \n qiv = qmp_input_visitor_new ( props , false ) ; \n obj = user_creatable_add_type ( type , id , pdict , \n qmp_input_get_visitor ( qiv ) , errp ) ; \n qmp_input_visitor_cleanup ( qiv ) ; \n if ( obj ) { \n object_unref ( obj ) ; \n } \n }", "idx": 26676}
{"project": "qemu", "commit_id": "f6bb84d53110398f4899c19dab4e0fe9908ec060", "target": 1, "func": "static inline TranslationBlock * tb_find ( CPUState * cpu , \n TranslationBlock * last_tb , \n int tb_exit ) \n { \n CPUArchState * env = ( CPUArchState * ) cpu -> env_ptr ; \n TranslationBlock * tb ; \n target_ulong cs_base , pc ; \n uint32_t flags ; \n bool acquired_tb_lock = false ; \n cpu_get_tb_cpu_state ( env , & pc , & cs_base , & flags ) ; \n tb = atomic_rcu_read ( & cpu -> tb_jmp_cache [ tb_jmp_cache_hash_func ( pc ) ] ) ; \n if ( unlikely ( ! tb || tb -> pc != pc || tb -> cs_base != cs_base || \n tb -> flags != flags || \n tb -> trace_vcpu_dstate != * cpu -> trace_dstate ) ) { \n tb = tb_htable_lookup ( cpu , pc , cs_base , flags ) ; \n if ( ! tb ) { \n mmap_lock ( ) ; \n tb_lock ( ) ; \n acquired_tb_lock = true ; \n tb = tb_htable_lookup ( cpu , pc , cs_base , flags ) ; \n if ( ! tb ) { \n tb = tb_gen_code ( cpu , pc , cs_base , flags , 0 ) ; \n } \n mmap_unlock ( ) ; \n } \n atomic_set ( & cpu -> tb_jmp_cache [ tb_jmp_cache_hash_func ( pc ) ] , tb ) ; \n } \n #ifndef CONFIG_USER_ONLY \n if ( tb -> page_addr [ 1 ] != -1 ) { \n last_tb = NULL ; \n } \n #endif \n if ( last_tb && ! qemu_loglevel_mask ( CPU_LOG_TB_NOCHAIN ) ) { \n if ( ! acquired_tb_lock ) { \n tb_lock ( ) ; \n acquired_tb_lock = true ; \n } \n if ( ! tb -> invalid ) { \n tb_add_jump ( last_tb , tb_exit , tb ) ; \n } \n } \n if ( acquired_tb_lock ) { \n tb_unlock ( ) ; \n } \n return tb ; \n }", "idx": 26715}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_size ( Visitor * v , const char * name , uint64_t * obj , \n Error * * errp ) \n { \n StringInputVisitor * siv = to_siv ( v ) ; \n Error * err = NULL ; \n uint64_t val ; \n if ( siv -> string ) { \n parse_option_size ( name , siv -> string , & val , & err ) ; \n } else { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : \" \" , \n \" \" ) ; \n return ; \n } \n if ( err ) { \n error_propagate ( errp , err ) ; \n return ; \n } \n * obj = val ; \n }", "idx": 26754}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_init ( ACPIREGS * ar , qemu_irq cmos_s3 ) \n { \n ar -> pm1 . cnt . cmos_s3 = cmos_s3 ; \n }", "idx": 26791}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_refresh ( QemuConsole * s ) \n { \n DisplaySurface * surface = qemu_console_surface ( s ) ; \n TextCell * c ; \n int x , y , y1 ; \n if ( s -> ds -> have_text ) { \n s -> text_x [ 0 ] = 0 ; \n s -> text_y [ 0 ] = 0 ; \n s -> text_x [ 1 ] = s -> width - 1 ; \n s -> text_y [ 1 ] = s -> height - 1 ; \n s -> cursor_invalidate = 1 ; \n } \n vga_fill_rect ( s , 0 , 0 , surface_width ( surface ) , surface_height ( surface ) , \n color_table_rgb [ 0 ] [ COLOR_BLACK ] ) ; \n y1 = s -> y_displayed ; \n for ( y = 0 ; y < s -> height ; y ++ ) { \n c = s -> cells + y1 * s -> width ; \n for ( x = 0 ; x < s -> width ; x ++ ) { \n vga_putcharxy ( s , x , y , c -> ch , \n & ( c -> t_attrib ) ) ; \n c ++ ; \n } \n if ( ++ y1 == s -> total_height ) { \n y1 = 0 ; \n } \n } \n console_show_cursor ( s , 1 ) ; \n dpy_gfx_update ( s , 0 , 0 , \n surface_width ( surface ) , surface_height ( surface ) ) ; \n }", "idx": 26807}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_init_child_watch ( void ) \n { \n struct sigaction act ; \n sigchld_bh = qemu_bh_new ( sigchld_bh_handler , NULL ) ; \n memset ( & act , 0 , sizeof ( act ) ) ; \n act . sa_handler = sigchld_handler ; \n act . sa_flags = SA_NOCLDSTOP ; \n sigaction ( SIGCHLD , & act , NULL ) ; \n }", "idx": 26808}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static inline void bt_hci_lmp_acl_data ( struct bt_hci_s * hci , uint16_t handle , \n const uint8_t * data , int start , int len ) \n { \n struct hci_acl_hdr * pkt = ( void * ) hci -> acl_buf ; \n if ( len + HCI_ACL_HDR_SIZE > sizeof ( hci -> acl_buf ) ) { \n fprintf ( stderr , \" \\n \" , \n __FUNCTION__ , len ) ; \n return ; \n } \n memcpy ( hci -> acl_buf + HCI_ACL_HDR_SIZE , data , len ) ; \n pkt -> handle = cpu_to_le16 ( \n acl_handle_pack ( handle , start ? ACL_START : ACL_CONT ) ) ; \n pkt -> dlen = cpu_to_le16 ( len ) ; \n hci -> info . acl_recv ( hci -> info . opaque , \n hci -> acl_buf , len + HCI_ACL_HDR_SIZE ) ; \n }", "idx": 26875}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void xilinx_enet_init ( Object * obj ) \n { \n XilinxAXIEnet * s = XILINX_AXI_ENET ( obj ) ; \n SysBusDevice * sbd = SYS_BUS_DEVICE ( obj ) ; \n Error * errp = NULL ; \n object_property_add_link ( obj , \" \" , TYPE_STREAM_SLAVE , \n ( Object * * ) & s -> tx_dev , & errp ) ; \n assert_no_error ( errp ) ; \n object_initialize ( & s -> rx_data_dev , TYPE_XILINX_AXI_ENET_DATA_STREAM ) ; \n object_property_add_child ( OBJECT ( s ) , \" \" , \n ( Object * ) & s -> rx_data_dev , & errp ) ; \n assert_no_error ( errp ) ; \n sysbus_init_irq ( sbd , & s -> irq ) ; \n memory_region_init_io ( & s -> iomem , & enet_ops , s , \" \" , 0x40000 ) ; \n sysbus_init_mmio ( sbd , & s -> iomem ) ; \n }", "idx": 26892}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static int create_ppc_opcodes ( CPUPPCState * env , const ppc_def_t * def ) \n { \n opcode_t * opc , * start , * end ; \n fill_new_table ( env -> opcodes , 0x40 ) ; \n if ( & opc_start < & opc_end ) { \n start = & opc_start ; \n end = & opc_end ; \n } else { \n start = & opc_end ; \n end = & opc_start ; \n } \n for ( opc = start + 1 ; opc != end ; opc ++ ) { \n if ( ( opc -> handler . type & def -> insns_flags ) != 0 ) { \n if ( register_insn ( env -> opcodes , opc ) < 0 ) { \n printf ( \" \" \n \" \\n \" , opc -> opc1 , opc -> opc2 , \n opc -> opc3 ) ; \n return -1 ; \n } \n } \n } \n fix_opcode_tables ( env -> opcodes ) ; \n fflush ( stdout ) ; \n fflush ( stderr ) ; \n return 0 ; \n }", "idx": 26906}
{"project": "qemu", "commit_id": "b7f43fe46029d8fd0594cd599fa2599dcce0f553", "target": 1, "func": "Object * object_dynamic_cast_assert ( Object * obj , const char * typename ) \n { \n Object * inst ; \n inst = object_dynamic_cast ( obj , typename ) ; \n if ( ! inst ) { \n fprintf ( stderr , \" \\n \" , \n obj , typename ) ; \n abort ( ) ; \n } \n return inst ; \n }", "idx": 26933}
{"project": "qemu", "commit_id": "d8754f40acb2d30e4735cdcd21a16e7ac29264a3", "target": 0, "func": "opts_end_list ( Visitor * v , Error * * errp )  \n { \n OptsVisitor * ov = DO_UPCAST ( OptsVisitor , visitor , v ) ; \n assert ( ov -> list_mode == LM_STARTED || ov -> list_mode == LM_IN_PROGRESS ) ; \n ov -> repeated_opts = NULL ; \n ov -> list_mode = LM_NONE ; \n }", "idx": 26965}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static CaptureVoiceOut * audio_pcm_capture_find_specific ( \n AudioState * s , \n audsettings_t * as \n ) \n { \n CaptureVoiceOut * cap ; \n for ( cap = s -> cap_head . lh_first ; cap ; cap = cap -> entries . le_next ) { \n if ( audio_pcm_info_eq ( & cap -> hw . info , as ) ) { \n return cap ; \n } \n } \n return NULL ; \n }", "idx": 26969}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "static void QEMU_NORETURN force_sig ( int target_sig ) \n { \n CPUState * cpu = thread_cpu ; \n CPUArchState * env = cpu -> env_ptr ; \n TaskState * ts = ( TaskState * ) cpu -> opaque ; \n int host_sig , core_dumped = 0 ; \n struct sigaction act ; \n host_sig = target_to_host_signal ( target_sig ) ; \n trace_user_force_sig ( env , target_sig , host_sig ) ; \n gdb_signalled ( env , target_sig ) ; \n if ( core_dump_signal ( target_sig ) && ( ts -> bprm -> core_dump != NULL ) ) { \n stop_all_tasks ( ) ; \n core_dumped = \n ( ( * ts -> bprm -> core_dump ) ( target_sig , env ) == 0 ) ; \n } \n if ( core_dumped ) { \n struct rlimit nodump ; \n getrlimit ( RLIMIT_CORE , & nodump ) ; \n nodump . rlim_cur = 0 ; \n setrlimit ( RLIMIT_CORE , & nodump ) ; \n ( void ) fprintf ( stderr , \" \\n \" , \n target_sig , strsignal ( host_sig ) , \" \" ) ; \n } \n sigfillset ( & act . sa_mask ) ; \n act . sa_handler = SIG_DFL ; \n act . sa_flags = 0 ; \n sigaction ( host_sig , & act , NULL ) ; \n kill ( getpid ( ) , host_sig ) ; \n sigdelset ( & act . sa_mask , host_sig ) ; \n sigsuspend ( & act . sa_mask ) ; \n abort ( ) ; \n }", "idx": 26984}
{"project": "qemu", "commit_id": "8dfbaa6ac450c4ec2646b1ca08a4017052a90c1d", "target": 0, "func": "static int virtio_ccw_hcall_notify ( const uint64_t * args ) \n { \n uint64_t subch_id = args [ 0 ] ; \n uint64_t queue = args [ 1 ] ; \n SubchDev * sch ; \n int cssid , ssid , schid , m ; \n if ( ioinst_disassemble_sch_ident ( subch_id , & m , & cssid , & ssid , & schid ) ) { \n return - EINVAL ; \n } \n sch = css_find_subch ( m , cssid , ssid , schid ) ; \n if ( ! sch || ! css_subch_visible ( sch ) ) { \n return - EINVAL ; \n } \n if ( queue >= VIRTIO_PCI_QUEUE_MAX ) { \n return - EINVAL ; \n } \n virtio_queue_notify ( virtio_ccw_get_vdev ( sch ) , queue ) ; \n return 0 ; \n }", "idx": 27008}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline void cris_fidx_i ( unsigned int x ) \n { \n register unsigned int v  asm ( \" \" ) = x ; \n asm ( \" \\t \\n \" : : \" \" ( v ) ) ; \n }", "idx": 27036}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void test_nested_struct_list ( gconstpointer opaque ) \n { \n TestArgs * args = ( TestArgs * ) opaque ; \n const SerializeOps * ops = args -> ops ; \n UserDefNestedList * listp = NULL , * tmp , * tmp_copy , * listp_copy = NULL ; \n Error * err = NULL ; \n void * serialize_data ; \n int i = 0 ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n tmp = g_malloc0 ( sizeof ( UserDefNestedList ) ) ; \n tmp -> value = nested_struct_create ( ) ; \n tmp -> next = listp ; \n listp = tmp ; \n } \n ops -> serialize ( listp , & serialize_data , visit_nested_struct_list , & err ) ; \n ops -> deserialize ( ( void * * ) & listp_copy , serialize_data , \n visit_nested_struct_list , & err ) ; \n g_assert ( err == NULL ) ; \n tmp = listp ; \n tmp_copy = listp_copy ; \n while ( listp_copy ) { \n g_assert ( listp ) ; \n nested_struct_compare ( listp -> value , listp_copy -> value ) ; \n listp = listp -> next ; \n listp_copy = listp_copy -> next ; \n } \n qapi_free_UserDefNestedList ( tmp ) ; \n qapi_free_UserDefNestedList ( tmp_copy ) ; \n ops -> cleanup ( serialize_data ) ; \n g_free ( args ) ; \n }", "idx": 27060}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_cpu_is_self ( void * env ) \n { \n return 1 ; \n }", "idx": 27069}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "BlockDriverAIOCB * bdrv_aio_writev ( BlockDriverState * bs , int64_t sector_num , \n QEMUIOVector * iov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n return bdrv_aio_rw_vector ( bs , sector_num , iov , nb_sectors , \n cb , opaque , 1 ) ; \n }", "idx": 27072}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "static inline int load_segment ( uint32_t * e1_ptr , uint32_t * e2_ptr , \n int selector ) \n { \n SegmentCache * dt ; \n int index ; \n uint8_t * ptr ; \n if ( selector & 0x4 ) \n dt = & env -> ldt ; \n else \n dt = & env -> gdt ; \n index = selector & ~ 7 ; \n if ( ( index + 7 ) > dt -> limit ) \n return -1 ; \n ptr = dt -> base + index ; \n * e1_ptr = ldl_kernel ( ptr ) ; \n * e2_ptr = ldl_kernel ( ptr + 4 ) ; \n return 0 ; \n }", "idx": 27187}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_bh_schedule_oneshot ( AioContext * ctx , QEMUBHFunc * cb , void * opaque ) \n { \n QEMUBH * bh ; \n bh = g_new ( QEMUBH , 1 ) ; \n * bh = ( QEMUBH ) { \n . ctx = ctx , \n . cb = cb , \n . opaque = opaque , \n } ; \n qemu_lockcnt_lock ( & ctx -> list_lock ) ; \n bh -> next = ctx -> first_bh ; \n bh -> scheduled = 1 ; \n bh -> deleted = 1 ; \n smp_wmb ( ) ; \n ctx -> first_bh = bh ; \n qemu_lockcnt_unlock ( & ctx -> list_lock ) ; \n aio_notify ( ctx ) ; \n }", "idx": 27242}
{"project": "qemu", "commit_id": "9012a53f067a78022947e18050b145c34a3dc599", "target": 0, "func": "static void rtas_start_cpu ( PowerPCCPU * cpu_ , sPAPRMachineState * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n target_ulong id , start , r3 ; \n PowerPCCPU * cpu ; \n if ( nargs != 3 || nret != 1 ) { \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n return ; \n } \n id = rtas_ld ( args , 0 ) ; \n start = rtas_ld ( args , 1 ) ; \n r3 = rtas_ld ( args , 2 ) ; \n cpu = spapr_find_cpu ( id ) ; \n if ( cpu != NULL ) { \n CPUState * cs = CPU ( cpu ) ; \n CPUPPCState * env = & cpu -> env ; \n PowerPCCPUClass * pcc = POWERPC_CPU_GET_CLASS ( cpu ) ; \n Error * local_err = NULL ; \n if ( ! cs -> halted ) { \n rtas_st ( rets , 0 , RTAS_OUT_HW_ERROR ) ; \n return ; \n } \n kvm_cpu_synchronize_state ( cs ) ; \n ppc_set_compat ( cpu , POWERPC_CPU ( first_cpu ) -> compat_pvr , & local_err ) ; \n if ( local_err ) { \n error_report_err ( local_err ) ; \n rtas_st ( rets , 0 , RTAS_OUT_HW_ERROR ) ; \n return ; \n } \n env -> msr = ( 1ULL << MSR_SF ) | ( 1ULL << MSR_ME ) ; \n env -> spr [ SPR_LPCR ] |= pcc -> lpcr_pm ; \n env -> nip = start ; \n env -> gpr [ 3 ] = r3 ; \n cs -> halted = 0 ; \n spapr_cpu_set_endianness ( cpu ) ; \n spapr_cpu_update_tb_offset ( cpu ) ; \n qemu_cpu_kick ( cs ) ; \n rtas_st ( rets , 0 , RTAS_OUT_SUCCESS ) ; \n return ; \n } \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n }", "idx": 27269}
{"project": "qemu", "commit_id": "ad196a9d0c14f681f010bb4b979030ec125ba976", "target": 0, "func": "void net_slirp_redir ( Monitor * mon , const char * redir_str , const char * redir_opt2 ) \n { \n struct slirp_config_str * config ; \n if ( ! slirp_inited ) { \n if ( mon ) { \n monitor_printf ( mon , \" \\n \" ) ; \n } else { \n config = qemu_malloc ( sizeof ( * config ) ) ; \n config -> str = redir_str ; \n config -> next = slirp_redirs ; \n slirp_redirs = config ; \n } \n return ; \n } \n if ( ! strcmp ( redir_str , \" \" ) ) { \n net_slirp_redir_rm ( mon , redir_opt2 ) ; \n return ; \n } \n slirp_redirection ( mon , redir_str ) ; \n }", "idx": 27275}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void qxl_reset_surfaces ( PCIQXLDevice * d ) \n { \n dprint ( d , 1 , \" \\n \" , __FUNCTION__ ) ; \n d -> mode = QXL_MODE_UNDEFINED ; \n qemu_mutex_unlock_iothread ( ) ; \n d -> ssd . worker -> destroy_surfaces ( d -> ssd . worker ) ; \n qemu_mutex_lock_iothread ( ) ; \n memset ( & d -> guest_surfaces . cmds , 0 , sizeof ( d -> guest_surfaces . cmds ) ) ; \n }", "idx": 27290}
