{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable ( sPAPRDRConnector * drc ) \n { \n drc -> allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE ; \n if ( drc -> awaiting_release ) { \n uint32_t drc_index = spapr_drc_index ( drc ) ; \n trace_spapr_drc_set_allocation_state_finalizing ( drc_index ) ; \n spapr_drc_detach ( drc ) ; \n } \n return RTAS_OUT_SUCCESS ; \n }", "idx": 70}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request ( SCSIDiskReq * r ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; \n uint32_t n ; \n if ( r -> sector_count == ( uint32_t ) -1 ) { \n DPRINTF ( \" \\n \" , r -> iov . iov_len ) ; \n r -> sector_count = 0 ; \n scsi_req_data ( & r -> req , r -> iov . iov_len ) ; \n return ; \n } \n DPRINTF ( \" \\n \" , r -> sector_count ) ; \n if ( r -> sector_count == 0 ) { \n scsi_command_complete ( r , GOOD , NO_SENSE ) ; \n return ; \n } \n assert ( r -> req . aiocb == NULL ) ; \n n = r -> sector_count ; \n if ( n > SCSI_DMA_BUF_SIZE / 512 ) \n n = SCSI_DMA_BUF_SIZE / 512 ; \n r -> iov . iov_len = n * 512 ; \n qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; \n r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , \n scsi_read_complete , r ) ; \n if ( r -> req . aiocb == NULL ) { \n scsi_read_complete ( r , - EIO ) ; \n } \n }", "idx": 83}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0 ( void ) \n { \n uint64_t x0 ; \n uint32_t x1 ; \n x0 = T0 | ( ( uint64_t ) ( env -> y ) << 32 ) ; \n x1 = T1 ; \n x0 = x0 / x1 ; \n if ( x0 > 0xffffffff ) { \n T0 = 0xffffffff ; \n T1 = 1 ; \n } else { \n T0 = x0 ; \n T1 = 0 ; \n FORCE_RET ( ) ;", "idx": 164}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu ( CPUX86State * env ) \n { \n a20_enabled = 1 ; \n a20_mask = 0xffffffff ; \n last_pg_state = -1 ; \n cpu_x86_update_cr0 ( env ) ; \n }", "idx": 176}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self ( void * env ) \n { \n return 1 ; \n }", "idx": 178}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down ( VhostUserState * s , bool link_down ) \n { \n s -> nc . link_down = link_down ; \n if ( s -> nc . peer ) { \n s -> nc . peer -> link_down = link_down ; \n } \n if ( s -> nc . info -> link_status_changed ) { \n s -> nc . info -> link_status_changed ( & s -> nc ) ; \n } \n if ( s -> nc . peer && s -> nc . peer -> info -> link_status_changed ) { \n s -> nc . peer -> info -> link_status_changed ( s -> nc . peer ) ; \n } \n }", "idx": 179}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST ( qint_get_int_test ) \n { \n QInt * qi ; \n const int value = 123456 ; \n qi = qint_from_int ( value ) ; \n fail_unless ( qint_get_int ( qi ) == value ) ; \n QDECREF ( qi ) ; \n }", "idx": 218}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini ( void * opaque ) \n { \n ( void ) opaque ; \n }", "idx": 246}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet ( void * priv , uint32_t id , \n struct usb_redir_bulk_packet_header * bulk_packet , \n uint8_t * data , int data_len ) \n { \n USBRedirDevice * dev = priv ; \n uint8_t ep = bulk_packet -> endpoint ; \n int len = bulk_packet -> length ; \n AsyncURB * aurb ; \n DPRINTF ( \" \\n \" , bulk_packet -> status , \n ep , len , id ) ; \n aurb = async_find ( dev , id ) ; \n if ( ! aurb ) { \n free ( data ) ; \n return ; \n } \n if ( aurb -> bulk_packet . endpoint != bulk_packet -> endpoint || \n aurb -> bulk_packet . stream_id != bulk_packet -> stream_id ) { \n ERROR ( \" \\n \" ) ; \n len = USB_RET_NAK ; \n } \n if ( aurb -> packet ) { \n len = usbredir_handle_status ( dev , bulk_packet -> status , len ) ; \n if ( len > 0 ) { \n usbredir_log_data ( dev , \" \" , data , data_len ) ; \n if ( data_len <= aurb -> packet -> len ) { \n memcpy ( aurb -> packet -> data , data , data_len ) ; \n } else { \n ERROR ( \" \\n \" , data_len , \n aurb -> packet -> len ) ; \n len = USB_RET_STALL ; \n } \n } \n aurb -> packet -> len = len ; \n usb_packet_complete ( & dev -> dev , aurb -> packet ) ; \n } \n async_free ( dev , aurb ) ; \n free ( data ) ; \n }", "idx": 248}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write ( void * opaque , hwaddr addr , \n uint64_t value , unsigned size , \n MemTxAttrs attrs ) \n { \n int ret = 0 ; \n MSIMessage from = { 0 } , to = { 0 } ; \n from . address = ( uint64_t ) addr + VTD_INTERRUPT_ADDR_FIRST ; \n from . data = ( uint32_t ) value ; \n ret = vtd_interrupt_remap_msi ( opaque , & from , & to ) ; \n if ( ret ) { \n VTD_DPRINTF ( GENERAL , \" \" PRIx64 \n \" \" PRIx32 , from . address , from . data ) ; \n return MEMTX_ERROR ; \n } \n VTD_DPRINTF ( IR , \" \" PRIx64 \" \" PRIx32 \n \" \" , \n to . address , to . data , sid ) ; \n if ( dma_memory_write ( & address_space_memory , to . address , \n & to . data , size ) ) { \n VTD_DPRINTF ( GENERAL , \" \" PRIx64 \n \" \" PRIx32 , to . address , to . data ) ; \n } \n return MEMTX_OK ; \n }", "idx": 272}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer ( void ) \n { \n if ( trace_file_enabled ) { \n flush_trace_file ( ) ; \n } \n trace_idx = 0 ; \n }", "idx": 280}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add ( char * buf , uint32_t magic , const void * s , \n size_t len , size_t buflen ) \n { \n QCowExtension * ext_backing_fmt = ( QCowExtension * ) buf ; \n size_t ext_len = sizeof ( QCowExtension ) + ( ( len + 7 ) & ~ 7 ) ; \n if ( buflen < ext_len ) { \n return - ENOSPC ; \n } \n * ext_backing_fmt = ( QCowExtension ) { \n . magic = cpu_to_be32 ( magic ) , \n . len = cpu_to_be32 ( len ) , \n } ; \n memcpy ( buf + sizeof ( QCowExtension ) , s , len ) ; \n return ext_len ; \n }", "idx": 304}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin ( MemoryListener * listener ) \n { \n AddressSpaceDispatch * d = container_of ( listener , AddressSpaceDispatch , listener ) ; \n d -> phys_map . ptr = PHYS_MAP_NODE_NIL ; \n }", "idx": 321}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb ( int bpp , const uint8_t * buf ) \n { \n uint32_t rgb = 0 ; \n if ( bpp == 32 ) { \n rgb |= ( ( buf [ 0 ] & ~ 1 ) | ! ( ( buf [ 4 ] >> 3 ) & 1 ) ) << 24 ; \n rgb |= ( ( buf [ 1 ] & ~ 1 ) | ! ( ( buf [ 4 ] >> 2 ) & 1 ) ) << 16 ; \n rgb |= ( ( buf [ 2 ] & ~ 1 ) | ! ( ( buf [ 4 ] >> 1 ) & 1 ) ) << 8 ; \n rgb |= ( ( buf [ 3 ] & ~ 1 ) | ! ( ( buf [ 4 ] >> 0 ) & 1 ) ) << 0 ; \n } \n if ( bpp == 16 ) { \n rgb |= ( ( buf [ 0 ] & ~ 1 ) | ! ( ( buf [ 2 ] >> 1 ) & 1 ) ) << 8 ; \n rgb |= ( ( buf [ 1 ] & ~ 1 ) | ! ( ( buf [ 2 ] >> 0 ) & 1 ) ) << 0 ; \n } \n return rgb ; \n }", "idx": 325}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start ( const char * job_id , BlockDriverState * bs , \n BlockDriverState * base , const char * backing_file_str , \n int64_t speed , BlockdevOnError on_error , \n BlockCompletionFunc * cb , void * opaque , Error * * errp ) \n { \n StreamBlockJob * s ; \n s = block_job_create ( job_id , & stream_job_driver , bs , speed , \n cb , opaque , errp ) ; \n if ( ! s ) { \n return ; \n } \n s -> base = base ; \n s -> backing_file_str = g_strdup ( backing_file_str ) ; \n s -> on_error = on_error ; \n s -> common . co = qemu_coroutine_create ( stream_run ) ; \n trace_stream_start ( bs , base , s , s -> common . co , opaque ) ; \n qemu_coroutine_enter ( s -> common . co , s ) ; \n }", "idx": 369}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init ( SysBusDevice * sbd ) \n { \n DeviceState * dev = DEVICE ( sbd ) ; \n struct omap_gpif_s * s = OMAP1_GPIO ( dev ) ; \n if ( ! s -> clk ) { \n hw_error ( \" \\n \" ) ; \n } \n qdev_init_gpio_in ( dev , omap_gpio_set , 16 ) ; \n qdev_init_gpio_out ( dev , s -> omap1 . handler , 16 ) ; \n sysbus_init_irq ( sbd , & s -> omap1 . irq ) ; \n memory_region_init_io ( & s -> iomem , OBJECT ( s ) , & omap_gpio_ops , & s -> omap1 , \n \" \" , 0x1000 ) ; \n sysbus_init_mmio ( sbd , & s -> iomem ) ; \n return 0 ; \n }", "idx": 373}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach ( struct omap_mcbsp_s * s , I2SCodec * slave ) \n { \n s -> codec = slave ; \n slave -> rx_swallow = qemu_allocate_irqs ( omap_mcbsp_i2s_swallow , s , 1 ) [ 0 ] ; \n slave -> tx_start = qemu_allocate_irqs ( omap_mcbsp_i2s_start , s , 1 ) [ 0 ] ; \n }", "idx": 391}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq ( floatx80 a , floatx80 b , float_status * status ) \n { \n if ( ( ( extractFloatx80Exp ( a ) == 0x7FFF ) \n && ( uint64_t ) ( extractFloatx80Frac ( a ) << 1 ) ) \n || ( ( extractFloatx80Exp ( b ) == 0x7FFF ) \n && ( uint64_t ) ( extractFloatx80Frac ( b ) << 1 ) ) \n ) { \n float_raise ( float_flag_invalid , status ) ; \n return 0 ; \n } \n return \n ( a . low == b . low ) \n && ( ( a . high == b . high ) \n || ( ( a . low == 0 ) \n && ( ( uint16_t ) ( ( a . high | b . high ) << 1 ) == 0 ) ) \n ) ; \n }", "idx": 399}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init ( JSONLexer * lexer , JSONLexerEmitter func ) \n { \n lexer -> emit = func ; \n lexer -> state = IN_START ; \n lexer -> token = qstring_new ( ) ; \n lexer -> x = lexer -> y = 0 ; \n }", "idx": 402}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB * paio_submit ( BlockDriverState * bs , int fd , \n int64_t sector_num , QEMUIOVector * qiov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque , int type ) \n { \n struct qemu_paiocb * acb ; \n acb = qemu_aio_get ( & raw_aio_pool , bs , cb , opaque ) ; \n if ( ! acb ) \n return NULL ; \n acb -> aio_type = type ; \n acb -> aio_fildes = fd ; \n acb -> ev_signo = SIGUSR2 ; \n acb -> async_context_id = get_async_context_id ( ) ; \n if ( qiov ) { \n acb -> aio_iov = qiov -> iov ; \n acb -> aio_niov = qiov -> niov ; \n } \n acb -> aio_nbytes = nb_sectors * 512 ; \n acb -> aio_offset = sector_num * 512 ; \n acb -> next = posix_aio_state -> first_aio ; \n posix_aio_state -> first_aio = acb ; \n trace_paio_submit ( acb , opaque , sector_num , nb_sectors , type ) ; \n qemu_paio_submit ( acb ) ; \n return & acb -> common ; \n }", "idx": 404}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device ( const char * filename ) \n { \n int fd , ret ; \n int prio = 0 ; \n struct floppy_struct fdparam ; \n struct stat st ; \n if ( strstart ( filename , \" \" , NULL ) && \n ! strstart ( filename , \" \" , NULL ) ) { \n prio = 50 ; \n } \n fd = qemu_open ( filename , O_RDONLY | O_NONBLOCK ) ; \n if ( fd < 0 ) { \n goto out ; \n } \n ret = fstat ( fd , & st ) ; \n if ( ret == -1 || ! S_ISBLK ( st . st_mode ) ) { \n goto outc ; \n } \n ret = ioctl ( fd , FDGETPRM , & fdparam ) ; \n if ( ret >= 0 ) \n prio = 100 ; \n outc : \n qemu_close ( fd ) ; \n out : \n return prio ; \n }", "idx": 444}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init ( CPUMIPSState * env , const mips_def_t * def ) \n { \n int i ; \n for ( i = 0 ; i < MIPS_FPU_MAX ; i ++ ) \n env -> fpus [ i ] . fcr0 = def -> CP1_fcr0 ; \n memcpy ( & env -> active_fpu , & env -> fpus [ 0 ] , sizeof ( env -> active_fpu ) ) ; \n if ( env -> user_mode_only ) { \n if ( env -> CP0_Config1 & ( 1 << CP0C1_FP ) ) \n env -> hflags |= MIPS_HFLAG_FPU ; \n #ifdef TARGET_MIPS64 \n if ( env -> active_fpu . fcr0 & ( 1 << FCR0_F64 ) ) \n env -> hflags |= MIPS_HFLAG_F64 ; \n #endif \n } \n }", "idx": 474}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit ( ThreadPoolFunc * func , void * arg ) \n { \n thread_pool_submit_aio ( func , arg , NULL , NULL ) ; \n }", "idx": 501}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices ( void ) \n { \n sysbus_register_dev ( \" \" , sizeof ( pl061_state ) , \n pl061_init_arm ) ; \n sysbus_register_dev ( \" \" , sizeof ( pl061_state ) , \n pl061_init_luminary ) ; \n }", "idx": 510}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec ( CPUState * cpu ) \n { \n CPUClass * cc = CPU_GET_CLASS ( cpu ) ; \n int ret ; \n SyncClocks sc ; \n current_cpu = cpu ; \n if ( cpu_handle_halt ( cpu ) ) { \n return EXCP_HALTED ; \n } \n rcu_read_lock ( ) ; \n cc -> cpu_exec_enter ( cpu ) ; \n init_delay_params ( & sc , cpu ) ; \n if ( sigsetjmp ( cpu -> jmp_env , 0 ) != 0 ) { \n #if defined ( __clang__ ) || ! QEMU_GNUC_PREREQ ( 4 , 6 )  \n  \n  \n  cpu = current_cpu ; \n cc = CPU_GET_CLASS ( cpu ) ; \n #else \n g_assert ( cpu == current_cpu ) ; \n g_assert ( cc == CPU_GET_CLASS ( cpu ) ) ; \n #endif \n cpu -> can_do_io = 1 ; \n tb_lock_reset ( ) ; \n if ( qemu_mutex_iothread_locked ( ) ) { \n qemu_mutex_unlock_iothread ( ) ; \n } \n } \n while ( ! cpu_handle_exception ( cpu , & ret ) ) { \n TranslationBlock * last_tb = NULL ; \n int tb_exit = 0 ; \n while ( ! cpu_handle_interrupt ( cpu , & last_tb ) ) { \n TranslationBlock * tb = tb_find ( cpu , last_tb , tb_exit ) ; \n cpu_loop_exec_tb ( cpu , tb , & last_tb , & tb_exit , & sc ) ; \n align_clocks ( & sc , cpu ) ; \n } \n } \n cc -> cpu_exec_exit ( cpu ) ; \n rcu_read_unlock ( ) ; \n current_cpu = NULL ; \n return ret ; \n }", "idx": 539}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest ( IRB * dest , const IRB * src , PMCW * pmcw ) \n { \n int i ; \n uint16_t stctl = src -> scsw . ctrl & SCSW_CTRL_MASK_STCTL ; \n uint16_t actl = src -> scsw . ctrl & SCSW_CTRL_MASK_ACTL ; \n copy_scsw_to_guest ( & dest -> scsw , & src -> scsw ) ; \n for ( i = 0 ; i < ARRAY_SIZE ( dest -> esw ) ; i ++ ) { \n dest -> esw [ i ] = cpu_to_be32 ( src -> esw [ i ] ) ; \n } \n for ( i = 0 ; i < ARRAY_SIZE ( dest -> ecw ) ; i ++ ) { \n dest -> ecw [ i ] = cpu_to_be32 ( src -> ecw [ i ] ) ; \n } \n if ( ( src -> scsw . flags & SCSW_FLAGS_MASK_ESWF ) || \n ! ( pmcw -> flags & PMCW_FLAGS_MASK_TF ) || \n ! ( pmcw -> chars & PMCW_CHARS_MASK_XMWME ) ) { \n return ; \n } \n if ( ! ( stctl & SCSW_STCTL_STATUS_PEND ) ) { \n return ; \n } \n if ( ( stctl & SCSW_STCTL_PRIMARY ) || \n ( stctl == SCSW_STCTL_SECONDARY ) || \n ( ( stctl & SCSW_STCTL_INTERMEDIATE ) && ( actl & SCSW_ACTL_SUSP ) ) ) { \n for ( i = 0 ; i < ARRAY_SIZE ( dest -> emw ) ; i ++ ) { \n dest -> emw [ i ] = cpu_to_be32 ( src -> emw [ i ] ) ; \n } \n } \n }", "idx": 547}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate ( struct VmxnetRxPkt * pkt , \n const void * pkt_data , \n size_t pkt_len ) \n { \n struct virtio_net_hdr * vhdr ; \n bool isip4 , isip6 , istcp , isudp ; \n uint8_t * data ; \n int len ; \n if ( ! vmxnet_rx_pkt_has_virt_hdr ( pkt ) ) { \n return ; \n } \n vhdr = vmxnet_rx_pkt_get_vhdr ( pkt ) ; \n if ( ! VMXNET_FLAG_IS_SET ( vhdr -> flags , VIRTIO_NET_HDR_F_NEEDS_CSUM ) ) { \n return ; \n } \n vmxnet_rx_pkt_get_protocols ( pkt , & isip4 , & isip6 , & isudp , & istcp ) ; \n if ( ! ( isip4 || isip6 ) || ! ( istcp || isudp ) ) { \n return ; \n } \n vmxnet3_dump_virt_hdr ( vhdr ) ; \n if ( pkt_len < ( vhdr -> csum_start + vhdr -> csum_offset + 2 ) ) { \n VMW_PKPRN ( \" \" \n \" \" , \n len , vhdr -> csum_start , vhdr -> csum_offset ) ; \n return ; \n } \n data = ( uint8_t * ) pkt_data + vhdr -> csum_start ; \n len = pkt_len - vhdr -> csum_start ; \n stw_be_p ( data + vhdr -> csum_offset , net_raw_checksum ( data , len ) ) ; \n vhdr -> flags &= ~ VIRTIO_NET_HDR_F_NEEDS_CSUM ; \n vhdr -> flags |= VIRTIO_NET_HDR_F_DATA_VALID ; \n }", "idx": 573}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList * qmp_query_commands ( Error * * errp ) \n { \n CommandInfoList * list = NULL ; \n qmp_for_each_command ( & qmp_commands , query_commands_cb , & list ) ; \n return list ; \n }", "idx": 574}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg ( void ) \n { \n uint32_t ret ; \n if ( ( uint32_t ) T0 == ( uint32_t ) ( T1 + 1 ) ) { \n ret = -1 ; \n } else { \n ret = ( ( ( uint32_t ) ( -1 ) ) >> ( ( uint32_t ) T0 ) ) ^ \n ( ( ( uint32_t ) ( -1 ) >> ( ( uint32_t ) T1 ) ) >> 1 ) ; \n if ( ( uint32_t ) T0 > ( uint32_t ) T1 ) \n ret = ~ ret ; \n } \n T0 = ret ; \n }", "idx": 686}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data ( void * opaque , int ret , \n uint64_t offset , size_t len ) \n { \n QEDAIOCB * acb = opaque ; \n BDRVQEDState * s = acb_to_s ( acb ) ; \n BlockDriverState * bs = acb -> common . bs ; \n offset += qed_offset_into_cluster ( s , acb -> cur_pos ) ; \n trace_qed_aio_read_data ( s , acb , ret , offset , len ) ; \n if ( ret < 0 ) { \n goto err ; \n } \n qemu_iovec_concat ( & acb -> cur_qiov , acb -> qiov , acb -> qiov_offset , len ) ; \n if ( ret == QED_CLUSTER_ZERO ) { \n qemu_iovec_memset ( & acb -> cur_qiov , 0 , 0 , acb -> cur_qiov . size ) ; \n qed_aio_next_io ( acb , 0 ) ; \n return ; \n } else if ( ret != QED_CLUSTER_FOUND ) { \n qed_read_backing_file ( s , acb -> cur_pos , & acb -> cur_qiov , \n qed_aio_next_io , acb ) ; \n return ; \n } \n BLKDBG_EVENT ( bs -> file , BLKDBG_READ_AIO ) ; \n bdrv_aio_readv ( bs -> file , offset / BDRV_SECTOR_SIZE , \n & acb -> cur_qiov , acb -> cur_qiov . size / BDRV_SECTOR_SIZE , \n qed_aio_next_io , acb ) ; \n return ; \n err : \n qed_aio_complete ( acb , ret ) ; \n }", "idx": 707}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration ( const char * host_port , Error * * errp ) \n { \n int s ; \n s = inet_listen ( host_port , NULL , 256 , SOCK_STREAM , 0 , errp ) ; \n if ( s < 0 ) { \n return ; \n } \n qemu_set_fd_handler2 ( s , NULL , tcp_accept_incoming_migration , NULL , \n ( void * ) ( intptr_t ) s ) ; \n }", "idx": 729}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , QEMUIOVector * qiov ) \n { \n SheepdogAIOCB * acb ; \n int ret ; \n if ( bs -> growable && sector_num + nb_sectors > bs -> total_sectors ) { \n ret = sd_truncate ( bs , ( sector_num + nb_sectors ) * BDRV_SECTOR_SIZE ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n bs -> total_sectors = sector_num + nb_sectors ; \n } \n acb = sd_aio_setup ( bs , qiov , sector_num , nb_sectors ) ; \n acb -> aio_done_func = sd_write_done ; \n acb -> aiocb_type = AIOCB_WRITE_UDATA ; \n ret = sd_co_rw_vector ( acb ) ; \n if ( ret <= 0 ) { \n qemu_aio_release ( acb ) ; \n return ret ; \n } \n qemu_coroutine_yield ( ) ; \n return acb -> ret ; \n }", "idx": 781}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event ( int dx , int dy , int x , int y , int state ) \n { \n static uint32_t bmap [ INPUT_BUTTON__MAX ] = { \n [ INPUT_BUTTON_LEFT ] = SDL_BUTTON ( SDL_BUTTON_LEFT ) , \n [ INPUT_BUTTON_MIDDLE ] = SDL_BUTTON ( SDL_BUTTON_MIDDLE ) , \n [ INPUT_BUTTON_RIGHT ] = SDL_BUTTON ( SDL_BUTTON_RIGHT ) , \n [ INPUT_BUTTON_WHEEL_UP ] = SDL_BUTTON ( SDL_BUTTON_WHEELUP ) , \n [ INPUT_BUTTON_WHEEL_DOWN ] = SDL_BUTTON ( SDL_BUTTON_WHEELDOWN ) , \n } ; \n static uint32_t prev_state ; \n if ( prev_state != state ) { \n qemu_input_update_buttons ( dcl -> con , bmap , prev_state , state ) ; \n prev_state = state ; \n } \n if ( qemu_input_is_absolute ( ) ) { \n qemu_input_queue_abs ( dcl -> con , INPUT_AXIS_X , x , \n real_screen -> w ) ; \n qemu_input_queue_abs ( dcl -> con , INPUT_AXIS_Y , y , \n real_screen -> h ) ; \n } else { \n if ( guest_cursor ) { \n x -= guest_x ; \n y -= guest_y ; \n guest_x += x ; \n guest_y += y ; \n dx = x ; \n dy = y ; \n } \n qemu_input_queue_rel ( dcl -> con , INPUT_AXIS_X , dx ) ; \n qemu_input_queue_rel ( dcl -> con , INPUT_AXIS_Y , dy ) ; \n } \n qemu_input_event_sync ( ) ; \n }", "idx": 794}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn ( Object * obj ) \n { \n DeviceState * dev = DEVICE ( obj ) ; \n Property * prop ; \n if ( qdev_hotplug ) { \n dev -> hotplugged = 1 ; \n qdev_hot_added = true ; \n } \n dev -> instance_id_alias = -1 ; \n dev -> state = DEV_STATE_CREATED ; \n qdev_prop_set_defaults ( dev , qdev_get_props ( dev ) ) ; \n for ( prop = qdev_get_props ( dev ) ; prop && prop -> name ; prop ++ ) { \n qdev_property_add_legacy ( dev , prop , NULL ) ; \n qdev_property_add_static ( dev , prop , NULL ) ; \n } \n object_property_add_str ( OBJECT ( dev ) , \" \" , qdev_get_type , NULL , NULL ) ; \n }", "idx": 797}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data ( SCSIRequest * req ) \n { \n SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; \n uint32_t n ; \n assert ( r -> req . aiocb == NULL ) ; \n scsi_req_ref ( & r -> req ) ; \n if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { \n DPRINTF ( \" \\n \" ) ; \n scsi_write_complete ( r , - EINVAL ) ; \n return ; \n } \n if ( ! r -> req . sg && ! r -> qiov . size ) { \n r -> started = true ; \n scsi_write_complete ( r , 0 ) ; \n return ; \n } \n if ( s -> tray_open ) { \n scsi_write_complete ( r , - ENOMEDIUM ) ; \n return ; \n } \n if ( r -> req . cmd . buf [ 0 ] == VERIFY_10 || r -> req . cmd . buf [ 0 ] == VERIFY_12 || \n r -> req . cmd . buf [ 0 ] == VERIFY_16 ) { \n if ( r -> req . sg ) { \n scsi_dma_complete ( r , 0 ) ; \n } else { \n scsi_write_complete ( r , 0 ) ; \n } \n return ; \n } \n if ( r -> req . sg ) { \n dma_acct_start ( s -> qdev . conf . bs , & r -> acct , r -> req . sg , BDRV_ACCT_WRITE ) ; \n r -> req . resid -= r -> req . sg -> size ; \n r -> req . aiocb = dma_bdrv_write ( s -> qdev . conf . bs , r -> req . sg , r -> sector , \n scsi_dma_complete , r ) ; \n } else { \n n = r -> qiov . size / 512 ; \n bdrv_acct_start ( s -> qdev . conf . bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; \n r -> req . aiocb = bdrv_aio_writev ( s -> qdev . conf . bs , r -> sector , & r -> qiov , n , \n scsi_write_complete , r ) ; \n } \n }", "idx": 837}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64 ( uint64_t * plow , uint64_t * phigh , int64_t b ) \n { \n int sa , sb ; \n sa = ( ( int64_t ) * phigh < 0 ) ; \n if ( sa ) \n neg128 ( plow , phigh ) ; \n sb = ( b < 0 ) ; \n if ( sb ) \n b = - b ; \n div64 ( plow , phigh , b ) ; \n if ( sa ^ sb ) \n * plow = - * plow ; \n if ( sa ) \n * phigh = - * phigh ; \n }", "idx": 848}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc ( GArray * linker , \n const char * file , \n uint32_t alloc_align , \n bool alloc_fseg ) \n { \n BiosLinkerLoaderEntry entry ; \n assert ( ! ( alloc_align & ( alloc_align - 1 ) ) ) ; \n memset ( & entry , 0 , sizeof entry ) ; \n strncpy ( entry . alloc . file , file , sizeof entry . alloc . file - 1 ) ; \n entry . command = cpu_to_le32 ( BIOS_LINKER_LOADER_COMMAND_ALLOCATE ) ; \n entry . alloc . align = cpu_to_le32 ( alloc_align ) ; \n entry . alloc . zone = cpu_to_le32 ( alloc_fseg ? \n BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG : \n BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH ) ; \n g_array_prepend_vals ( linker , & entry , sizeof entry ) ; \n }", "idx": 855}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive ( void * opaque , const uint8_t * buf , size_t size ) \n { \n TAPState * s = opaque ; \n int ret ; \n for ( ; ; ) { \n ret = write ( s -> fd , buf , size ) ; \n if ( ret < 0 && ( errno == EINTR || errno == EAGAIN ) ) { \n } else { \n break ; \n } \n } \n }", "idx": 883}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize ( SCSIDevice * dev , Error * * errp ) \n { \n DriveInfo * dinfo ; \n Error * local_err = NULL ; \n if ( ! dev -> conf . bs ) { \n scsi_realize ( dev , & local_err ) ; \n assert ( local_err ) ; \n error_propagate ( errp , local_err ) ; \n return ; \n } \n dinfo = drive_get_by_blockdev ( dev -> conf . bs ) ; \n if ( dinfo -> media_cd ) { \n scsi_cd_realize ( dev , errp ) ; \n } else { \n scsi_hd_realize ( dev , errp ) ; \n } \n }", "idx": 886}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen ( VncDisplay * vd , \n SocketAddress * * saddr , \n size_t nsaddr , \n SocketAddress * * wsaddr , \n size_t nwsaddr , \n Error * * errp ) \n { \n size_t i ; \n for ( i = 0 ; i < nsaddr ; i ++ ) { \n if ( vnc_display_listen_addr ( vd , saddr [ i ] , \n \" \" , \n & vd -> lsock , \n & vd -> lsock_tag , \n & vd -> nlsock , \n errp ) < 0 ) { \n return -1 ; \n } \n } \n for ( i = 0 ; i < nwsaddr ; i ++ ) { \n if ( vnc_display_listen_addr ( vd , wsaddr [ i ] , \n \" \" , \n & vd -> lwebsock , \n & vd -> lwebsock_tag , \n & vd -> nlwebsock , \n errp ) < 0 ) { \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 906}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char * enumerate_cpus ( unsigned long * cpus , int max_cpus ) \n { \n int cpu ; \n bool first = true ; \n GString * s = g_string_new ( NULL ) ; \n for ( cpu = find_first_bit ( cpus , max_cpus ) ; \n cpu < max_cpus ; \n cpu = find_next_bit ( cpus , max_cpus , cpu + 1 ) ) { \n g_string_append_printf ( s , \" \" , first ? \" \" : \" \" , cpu ) ; \n first = false ; \n } \n return g_string_free ( s , FALSE ) ; \n }", "idx": 913}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas ( void ) \n { \n spapr_rtas_register ( \" \" , rtas_display_character ) ; \n spapr_rtas_register ( \" \" , rtas_get_time_of_day ) ; \n spapr_rtas_register ( \" \" , rtas_power_off ) ; \n }", "idx": 924}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce ( CPUPPCState * env , sPAPREnvironment * spapr , \n target_ulong opcode , target_ulong * args ) \n { \n target_ulong liobn = args [ 0 ] ; \n target_ulong ioba = args [ 1 ] ; \n target_ulong tce = args [ 2 ] ; \n VIOsPAPRDevice * dev = spapr_vio_find_by_reg ( spapr -> vio_bus , liobn ) ; \n VIOsPAPR_RTCE * rtce ; \n if ( ! dev ) { \n hcall_dprintf ( \" \" TARGET_FMT_lx \" \\n \" , liobn ) ; \n return H_PARAMETER ; \n } \n ioba &= ~ ( SPAPR_VIO_TCE_PAGE_SIZE - 1 ) ; \n #ifdef DEBUG_TCE \n fprintf ( stderr , \" \" TARGET_FMT_lx \n \" \" TARGET_FMT_lx \" \\n \" , dev -> qdev . id , ioba , tce ) ; \n #endif \n if ( ioba >= dev -> rtce_window_size ) { \n hcall_dprintf ( \" \" TARGET_FMT_lx \" \\n \" , ioba ) ; \n return H_PARAMETER ; \n } \n rtce = dev -> rtce_table + ( ioba >> SPAPR_VIO_TCE_PAGE_SHIFT ) ; \n rtce -> tce = tce ; \n return H_SUCCESS ; \n }", "idx": 937}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n NvmeCtrl * s = NVME ( obj ) ; \n visit_type_int32 ( v , & s -> conf . bootindex , name , errp ) ; \n }", "idx": 941}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object * object_resolve_path_component ( Object * parent , const gchar * part ) \n { \n ObjectProperty * prop = object_property_find ( parent , part , NULL ) ; \n if ( prop == NULL ) { \n return NULL ; \n } \n if ( object_property_is_link ( prop ) ) { \n return * ( Object * * ) prop -> opaque ; \n } else if ( object_property_is_child ( prop ) ) { \n return prop -> opaque ; \n } else { \n return NULL ; \n } \n }", "idx": 946}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login ( VSCSIState * s , vscsi_req * req ) \n { \n union viosrp_iu * iu = & req -> iu ; \n struct srp_login_rsp * rsp = & iu -> srp . login_rsp ; \n uint64_t tag = iu -> srp . rsp . tag ; \n trace_spapr_vscsi__process_login ( ) ; \n memset ( iu , 0 , sizeof ( struct srp_login_rsp ) ) ; \n rsp -> opcode = SRP_LOGIN_RSP ; \n rsp -> req_lim_delta = cpu_to_be32 ( VSCSI_REQ_LIMIT - 2 ) ; \n rsp -> tag = tag ; \n rsp -> max_it_iu_len = cpu_to_be32 ( sizeof ( union srp_iu ) ) ; \n rsp -> max_ti_iu_len = cpu_to_be32 ( sizeof ( union srp_iu ) ) ; \n rsp -> buf_fmt = cpu_to_be16 ( SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT ) ; \n vscsi_send_iu ( s , req , sizeof ( * rsp ) , VIOSRP_SRP_FORMAT ) ; \n }", "idx": 961}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count ( CPUTimer * timer , uint64_t count ) \n { \n uint64_t real_count = count & ~ timer -> disabled_mask ; \n uint64_t disabled_bit = count & timer -> disabled_mask ; \n int64_t vm_clock_offset = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) - \n cpu_to_timer_ticks ( real_count , timer -> frequency ) ; \n TIMER_DPRINTF ( \" \\n \" , \n timer -> name , real_count , \n timer -> disabled ? \" \" : \" \" , timer ) ; \n timer -> disabled = disabled_bit ? 1 : 0 ; \n timer -> clock_offset = vm_clock_offset ; \n }", "idx": 963}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable ( BlockDriverState * bs ) \n { \n return bs -> removable ; \n }", "idx": 982}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add ( BlockdevOptions * options , Error * * errp ) \n { \n QmpOutputVisitor * ov = qmp_output_visitor_new ( ) ; \n QObject * obj ; \n QDict * qdict ; \n Error * local_err = NULL ; \n if ( ! options -> has_id ) { \n error_setg ( errp , \" \" ) ; \n goto fail ; \n } \n if ( options -> has_aio && options -> aio == BLOCKDEV_AIO_OPTIONS_NATIVE ) { \n bool direct = options -> cache -> has_direct && options -> cache -> direct ; \n if ( ! options -> has_cache && ! direct ) { \n error_setg ( errp , \" \" ) ; \n goto fail ; \n } \n } \n visit_type_BlockdevOptions ( qmp_output_get_visitor ( ov ) , \n & options , NULL , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n goto fail ; \n } \n obj = qmp_output_get_qobject ( ov ) ; \n qdict = qobject_to_qdict ( obj ) ; \n qdict_flatten ( qdict ) ; \n blockdev_init ( NULL , qdict , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n goto fail ; \n } \n fail : \n qmp_output_visitor_cleanup ( ov ) ; \n }", "idx": 1038}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo ( void ) \n { \n if ( likely ( ( uint32_t ) T1 != 0 ) ) { \n xer_ov = 0 ; \n T0 = ( uint32_t ) T0 / ( uint32_t ) T1 ; \n } else { \n xer_so = 1 ; \n xer_ov = 1 ; \n T0 = 0 ; \n } \n }", "idx": 1040}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save ( void * opaque ) \n { \n KVMClockState * s = opaque ; \n struct kvm_clock_data data ; \n int ret ; \n if ( s -> clock_valid ) { \n return ; \n } \n ret = kvm_vm_ioctl ( kvm_state , KVM_GET_CLOCK , & data ) ; \n if ( ret < 0 ) { \n fprintf ( stderr , \" \\n \" , strerror ( ret ) ) ; \n data . clock = 0 ; \n } \n s -> clock = data . clock ; \n s -> clock_valid = ! runstate_is_running ( ) ; \n }", "idx": 1046}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn ( ESPState * s ) \n { \n uint8_t buf [ 32 ] ; \n int len ; \n if ( s -> dma && ! s -> dma_enabled ) { \n s -> dma_cb = handle_satn ; \n return ; \n } \n len = get_cmd ( s , buf ) ; \n if ( len ) \n do_cmd ( s , buf ) ; \n }", "idx": 1056}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb ( struct vhost_dev * dev , \n uint64_t iova , uint64_t len ) \n { \n struct vhost_iotlb_msg imsg ; \n imsg . iova = iova ; \n imsg . size = len ; \n imsg . type = VHOST_IOTLB_INVALIDATE ; \n return dev -> vhost_ops -> vhost_send_device_iotlb_msg ( dev , & imsg ) ; \n }", "idx": 1089}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readw ( void * opaque , target_phys_addr_t offset ) \n { \n uint32_t val ; \n val = gic_dist_readb ( opaque , offset ) ; \n val |= gic_dist_readb ( opaque , offset + 1 ) << 8 ; \n return val ; \n }", "idx": 1107}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow ( void ) \n { \n const char * str = \" \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n uint64_t res = 999 ; \n int err ; \n err = qemu_strtoull ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , - ERANGE ) ; \n g_assert_cmpint ( res , == , ULLONG_MAX ) ; \n g_assert ( endptr == str + strlen ( str ) ) ; \n }", "idx": 1108}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr ( int busnr , int addr ) \n { \n USBBus * bus ; \n USBPort * port ; \n USBDevice * dev ; \n bus = usb_bus_find ( busnr ) ; \n if ( ! bus ) \n return -1 ; \n TAILQ_FOREACH ( port , & bus -> used , next )  { \n if ( port -> dev -> addr == addr ) \n break ; \n } \n if ( ! port ) \n return -1 ; \n dev = port -> dev ; \n TAILQ_REMOVE ( & bus -> used , port , next ) ; \n bus -> nused -- ; \n usb_attach ( port , NULL ) ; \n dev -> info -> handle_destroy ( dev ) ; \n TAILQ_INSERT_TAIL ( & bus -> free , port , next ) ; \n bus -> nfree ++ ; \n return 0 ; \n }", "idx": 1121}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_number ( Visitor * v , const char * name , double * obj , \n Error * * errp ) \n { \n QmpOutputVisitor * qov = to_qov ( v ) ; \n qmp_output_add ( qov , name , qfloat_from_double ( * obj ) ) ; \n }", "idx": 1122}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick ( void * env ) \n { \n return ; \n }", "idx": 1194}
{"project": "qemu", "commit_id": "b591dc59bc98ee558db4ca512aa117748ebfdeef", "target": 0, "func": "static void temp_allocate_frame ( TCGContext * s , int temp ) \n { \n TCGTemp * ts ; \n ts = & s -> temps [ temp ] ; \n s -> current_frame_offset = ( s -> current_frame_offset + sizeof ( tcg_target_long ) - 1 ) & ~ ( sizeof ( tcg_target_long ) - 1 ) ; \n if ( s -> current_frame_offset + sizeof ( tcg_target_long ) > s -> frame_end ) \n tcg_abort ( ) ; \n ts -> mem_offset = s -> current_frame_offset ; \n ts -> mem_reg = s -> frame_reg ; \n ts -> mem_allocated = 1 ; \n s -> current_frame_offset += sizeof ( tcg_target_long ) ; \n }", "idx": 1215}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream ( const char * device , bool has_base , \n const char * base , Error * * errp ) \n { \n BlockDriverState * bs ; \n BlockDriverState * base_bs = NULL ; \n Error * local_err = NULL ; \n bs = bdrv_find ( device ) ; \n if ( ! bs ) { \n error_set ( errp , QERR_DEVICE_NOT_FOUND , device ) ; \n return ; \n } \n if ( base ) { \n base_bs = bdrv_find_backing_image ( bs , base ) ; \n if ( base_bs == NULL ) { \n error_set ( errp , QERR_BASE_NOT_FOUND , base ) ; \n return ; \n } \n } \n stream_start ( bs , base_bs , base , block_stream_cb , bs , & local_err ) ; \n if ( error_is_set ( & local_err ) ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n drive_get_ref ( drive_get_by_blockdev ( bs ) ) ; \n trace_qmp_block_stream ( bs , bs -> job ) ; \n }", "idx": 1227}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses ( XilinxSPIPS * s ) \n { \n return ( s -> regs [ R_LQSPI_STS ] & LQSPI_CFG_SEP_BUS && \n s -> regs [ R_LQSPI_STS ] & LQSPI_CFG_TWO_MEM ) ? s -> num_busses : 1 ; \n }", "idx": 1290}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_set_CF_bit31 ( TCGv var ) \n { \n TCGv tmp = new_tmp ( ) ; \n tcg_gen_shri_i32 ( tmp , var , 31 ) ; \n gen_set_CF ( tmp ) ; \n dead_tmp ( tmp ) ; \n }", "idx": 1308}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed ( BlockJob * job , int64_t speed , Error * * errp ) \n { \n CommitBlockJob * s = container_of ( job , CommitBlockJob , common ) ; \n if ( speed < 0 ) { \n error_setg ( errp , QERR_INVALID_PARAMETER , \" \" ) ; \n return ; \n } \n ratelimit_set_speed ( & s -> limit , speed / BDRV_SECTOR_SIZE , SLICE_TIME ) ; \n }", "idx": 1335}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid ( Error * * errp ) \n { \n uint32_t fid = 0 ; \n while ( fid <= ZPCI_MAX_FID ) { \n if ( ! s390_pci_find_dev_by_fid ( fid ) ) { \n return fid ; \n } \n if ( fid == ZPCI_MAX_FID ) { \n break ; \n } \n fid ++ ; \n } \n error_setg ( errp , \" \" ) ; \n return 0 ; \n }", "idx": 1351}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_unrealize ( DeviceState * dev , Error * * errp ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( dev ) ; \n V9fsVirtioState * v = VIRTIO_9P ( dev ) ; \n V9fsState * s = & v -> state ; \n virtio_cleanup ( vdev ) ; \n v9fs_device_unrealize_common ( s , errp ) ; \n }", "idx": 1360}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next ( CoQueue * queue ) \n { \n Coroutine * next ; \n next = QSIMPLEQ_FIRST ( & queue -> entries ) ; \n if ( ! next ) { \n return false ; \n } \n QSIMPLEQ_REMOVE_HEAD ( & queue -> entries , co_queue_next ) ; \n qemu_coroutine_enter ( next , NULL ) ; \n return true ; \n }", "idx": 1381}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_reg ( const struct MonitorDef * md , int val ) \n { \n CPUState * env = mon_get_cpu ( ) ; \n if ( ! env ) \n return 0 ; \n return env -> regwptr [ val ] ; \n }", "idx": 1420}
{"project": "qemu", "commit_id": "30c367ed446b6ea53245589a5cf373578ac075d7", "target": 1, "func": "static void set_vlan ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n DeviceState * dev = DEVICE ( obj ) ; \n Property * prop = opaque ; \n NICPeers * peers_ptr = qdev_get_prop_ptr ( dev , prop ) ; \n NetClientState * * ptr = & peers_ptr -> ncs [ 0 ] ; \n Error * local_err = NULL ; \n int32_t id ; \n NetClientState * hubport ; \n if ( dev -> realized ) { \n qdev_prop_set_after_realize ( dev , name , errp ) ; \n visit_type_int32 ( v , & id , name , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n if ( id == -1 ) { \n * ptr = NULL ; \n hubport = net_hub_port_find ( id ) ; \n if ( ! hubport ) { \n error_set ( errp , QERR_INVALID_PARAMETER_VALUE , \n name , prop -> info -> name ) ; \n * ptr = hubport ;", "idx": 1435}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_update_read_handler ( CharDriverState * chr ) \n { \n FDCharDriver * s = chr -> opaque ; \n if ( s -> fd_in_tag ) { \n g_source_remove ( s -> fd_in_tag ) ; \n s -> fd_in_tag = 0 ; \n } \n if ( s -> fd_in ) { \n s -> fd_in_tag = io_add_watch_poll ( s -> fd_in , fd_chr_read_poll , fd_chr_read , chr ) ; \n } \n }", "idx": 1457}
{"project": "qemu", "commit_id": "51b0c6065aa6e47a47094d73e24be298a4a7f3a1", "target": 1, "func": "static int kvm_physical_sync_dirty_bitmap ( target_phys_addr_t start_addr , \n target_phys_addr_t end_addr ) \n { \n KVMState * s = kvm_state ; \n unsigned long size , allocated_size = 0 ; \n KVMDirtyLog d ; \n KVMSlot * mem ; \n int ret = 0 ; \n d . dirty_bitmap = NULL ; \n while ( start_addr < end_addr ) { \n mem = kvm_lookup_overlapping_slot ( s , start_addr , end_addr ) ; \n if ( mem == NULL ) { \n break ; \n } \n size = ALIGN ( ( ( mem -> memory_size ) >> TARGET_PAGE_BITS ) , HOST_LONG_BITS ) / 8 ; \n if ( ! d . dirty_bitmap ) { \n d . dirty_bitmap = qemu_malloc ( size ) ; \n } else if ( size > allocated_size ) { \n d . dirty_bitmap = qemu_realloc ( d . dirty_bitmap , size ) ; \n } \n allocated_size = size ; \n memset ( d . dirty_bitmap , 0 , allocated_size ) ; \n d . slot = mem -> slot ; \n if ( kvm_vm_ioctl ( s , KVM_GET_DIRTY_LOG , & d ) == -1 ) { \n DPRINTF ( \" \\n \" , errno ) ; \n ret = -1 ; \n break ; \n } \n kvm_get_dirty_pages_log_range ( mem -> start_addr , d . dirty_bitmap , \n mem -> start_addr , mem -> memory_size ) ; \n start_addr = mem -> start_addr + mem -> memory_size ; \n } \n qemu_free ( d . dirty_bitmap ) ; \n return ret ; \n }", "idx": 1473}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "int main ( void ) \n { \n int nf ; \n Suite * s ; \n SRunner * sr ; \n s = qfloat_suite ( ) ; \n sr = srunner_create ( s ) ; \n srunner_run_all ( sr , CK_NORMAL ) ; \n nf = srunner_ntests_failed ( sr ) ; \n srunner_free ( sr ) ; \n return ( nf == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ; \n }", "idx": 1487}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu ( sPAPRTCETable * tcet , target_ulong ioba , \n target_ulong tce ) \n { \n IOMMUTLBEntry entry ; \n hwaddr page_mask = IOMMU_PAGE_MASK ( tcet -> page_shift ) ; \n unsigned long index = ( ioba - tcet -> bus_offset ) >> tcet -> page_shift ; \n if ( index >= tcet -> nb_table ) { \n hcall_dprintf ( \" \" \n TARGET_FMT_lx \" \\n \" , ioba ) ; \n return H_PARAMETER ; \n } \n tcet -> table [ index ] = tce ; \n entry . target_as = & address_space_memory , \n entry . iova = ioba & page_mask ; \n entry . translated_addr = tce & page_mask ; \n entry . addr_mask = ~ page_mask ; \n entry . perm = spapr_tce_iommu_access_flags ( tce ) ; \n memory_region_notify_iommu ( & tcet -> iommu , entry ) ; \n return H_SUCCESS ; \n }", "idx": 1497}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_add ( DisasContext * ctx , TCGv ret , TCGv arg1 , \n TCGv arg2 , int add_ca , int compute_ca , \n int compute_ov ) \n { \n TCGv t0 , t1 ; \n if ( ( ! compute_ca && ! compute_ov ) || \n ( ! TCGV_EQUAL ( ret , arg1 ) && ! TCGV_EQUAL ( ret , arg2 ) ) ) { \n t0 = ret ; \n } else { \n t0 = tcg_temp_local_new ( ) ; \n } \n if ( add_ca ) { \n t1 = tcg_temp_local_new ( ) ; \n tcg_gen_mov_tl ( t1 , cpu_ca ) ; \n } else { \n TCGV_UNUSED ( t1 ) ; \n } \n if ( compute_ca ) { \n tcg_gen_movi_tl ( cpu_ca , 0 ) ; \n } \n if ( compute_ov ) { \n tcg_gen_movi_tl ( cpu_ov , 0 ) ; \n } \n tcg_gen_add_tl ( t0 , arg1 , arg2 ) ; \n if ( compute_ca ) { \n gen_op_arith_compute_ca ( ctx , t0 , arg1 , 0 ) ; \n } \n if ( add_ca ) { \n tcg_gen_add_tl ( t0 , t0 , t1 ) ; \n gen_op_arith_compute_ca ( ctx , t0 , t1 , 0 ) ; \n tcg_temp_free ( t1 ) ; \n } \n if ( compute_ov ) { \n gen_op_arith_compute_ov ( ctx , t0 , arg1 , arg2 , 0 ) ; \n } \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx , t0 ) ; \n if ( ! TCGV_EQUAL ( t0 , ret ) ) { \n tcg_gen_mov_tl ( ret , t0 ) ; \n tcg_temp_free ( t0 ) ; \n } \n }", "idx": 1507}
{"project": "qemu", "commit_id": "e40a67beeda6aa6e735546e9f08f3db41e23592a", "target": 0, "func": "void cpu_sh4_invalidate_tlb ( CPUSH4State * s ) \n { \n int i ; \n for ( i = 0 ; i < UTLB_SIZE ; i ++ ) { \n tlb_t * entry = & s -> utlb [ i ] ; \n entry -> v = 0 ; \n } \n for ( i = 0 ; i < UTLB_SIZE ; i ++ ) { \n tlb_t * entry = & s -> utlb [ i ] ; \n entry -> v = 0 ; \n } \n tlb_flush ( s , 1 ) ; \n }", "idx": 1557}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_finish ( uint32_t sum ) \n { \n while ( sum >> 16 ) \n sum = ( sum & 0xFFFF ) + ( sum >> 16 ) ; \n return ~ sum ; \n }", "idx": 1573}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock * tb_alloc ( target_ulong pc ) \n { \n TranslationBlock * tb ; \n TBContext * ctx ; \n assert_tb_locked ( ) ; \n tb = tcg_tb_alloc ( & tcg_ctx ) ; \n if ( unlikely ( tb == NULL ) ) { \n return NULL ; \n } \n ctx = & tcg_ctx . tb_ctx ; \n if ( unlikely ( ctx -> nb_tbs == ctx -> tbs_size ) ) { \n ctx -> tbs_size *= 2 ; \n ctx -> tbs = g_renew ( TranslationBlock * , ctx -> tbs , ctx -> tbs_size ) ; \n } \n ctx -> tbs [ ctx -> nb_tbs ++ ] = tb ; \n tb -> pc = pc ; \n tb -> cflags = 0 ; \n tb -> invalid = false ; \n return tb ; \n }", "idx": 1621}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select ( void ) \n { \n int fd ; \n for ( fd = 0 ; fd <= nfds ; fd ++ ) { \n int events = 0 ; \n if ( FD_ISSET ( fd , & rfds ) ) { \n events |= G_IO_IN | G_IO_HUP | G_IO_ERR ; \n } \n if ( FD_ISSET ( fd , & wfds ) ) { \n events |= G_IO_OUT | G_IO_ERR ; \n } \n if ( FD_ISSET ( fd , & xfds ) ) { \n events |= G_IO_PRI ; \n } \n if ( events ) { \n GPollFD pfd = { \n . fd = fd , \n . events = events , \n } ; \n g_array_append_val ( gpollfds , pfd ) ; \n } \n } \n }", "idx": 1626}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_isel ( DisasContext * ctx ) \n { \n int l1 , l2 ; \n uint32_t bi = rC ( ctx -> opcode ) ; \n uint32_t mask ; \n TCGv_i32 t0 ; \n l1 = gen_new_label ( ) ; \n l2 = gen_new_label ( ) ; \n mask = 0x08 >> ( bi & 0x03 ) ; \n t0 = tcg_temp_new_i32 ( ) ; \n tcg_gen_andi_i32 ( t0 , cpu_crf [ bi >> 2 ] , mask ) ; \n tcg_gen_brcondi_i32 ( TCG_COND_EQ , t0 , 0 , l1 ) ; \n if ( rA ( ctx -> opcode ) == 0 ) \n tcg_gen_movi_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , 0 ) ; \n else \n tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; \n gen_set_label ( l2 ) ; \n tcg_temp_free_i32 ( t0 ) ; \n }", "idx": 1710}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_process_mem2s ( struct Stream * s , \n StreamSlave * tx_dev ) \n { \n uint32_t prev_d ; \n unsigned char txbuf [ 16 * 1024 ] ; \n unsigned int txlen ; \n uint32_t app [ 6 ] ; \n if ( ! stream_running ( s ) || stream_idle ( s ) ) { \n return ; \n } \n while ( 1 ) { \n stream_desc_load ( s , s -> regs [ R_CURDESC ] ) ; \n if ( s -> desc . status & SDESC_STATUS_COMPLETE ) { \n s -> regs [ R_DMASR ] |= DMASR_HALTED ; \n break ; \n } \n if ( stream_desc_sof ( & s -> desc ) ) { \n s -> pos = 0 ; \n memcpy ( app , s -> desc . app , sizeof app ) ; \n } \n txlen = s -> desc . control & SDESC_CTRL_LEN_MASK ; \n if ( ( txlen + s -> pos ) > sizeof txbuf ) { \n hw_error ( \" \\n \" , __func__ , \n txlen + s -> pos ) ; \n } \n cpu_physical_memory_read ( s -> desc . buffer_address , \n txbuf + s -> pos , txlen ) ; \n s -> pos += txlen ; \n if ( stream_desc_eof ( & s -> desc ) ) { \n stream_push ( tx_dev , txbuf , s -> pos , app ) ; \n s -> pos = 0 ; \n stream_complete ( s ) ; \n } \n s -> desc . status = txlen | SDESC_STATUS_COMPLETE ; \n stream_desc_store ( s , s -> regs [ R_CURDESC ] ) ; \n prev_d = s -> regs [ R_CURDESC ] ; \n s -> regs [ R_CURDESC ] = s -> desc . nxtdesc ; \n if ( prev_d == s -> regs [ R_TAILDESC ] ) { \n s -> regs [ R_DMASR ] |= DMASR_IDLE ; \n break ; \n } \n } \n }", "idx": 1712}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static inline void bt_hci_event_complete_read_local_name ( struct bt_hci_s * hci ) \n { \n read_local_name_rp params ; \n params . status = HCI_SUCCESS ; \n memset ( params . name , 0 , sizeof ( params . name ) ) ; \n if ( hci -> device . lmp_name ) \n strncpy ( params . name , hci -> device . lmp_name , sizeof ( params . name ) ) ; \n bt_hci_event_complete ( hci , & params , READ_LOCAL_NAME_RP_SIZE ) ; \n }", "idx": 1721}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static bool vnc_should_update ( VncState * vs ) \n { \n switch ( vs -> update ) { \n case VNC_STATE_UPDATE_NONE : \n break ; \n case VNC_STATE_UPDATE_INCREMENTAL : \n if ( ! vs -> output . offset || vs -> audio_cap ) { \n return true ; \n } \n break ; \n case VNC_STATE_UPDATE_FORCE : \n return true ; \n } \n return false ; \n }", "idx": 1726}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_whitespace ( void ) \n { \n const char * str = \" \\t \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n int64_t res = 999 ; \n int err ; \n err = qemu_strtoll ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 0 ) ; \n g_assert ( endptr == str ) ; \n }", "idx": 1736}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static uint8_t net_tx_pkt_get_gso_type ( struct NetTxPkt * pkt , \n bool tso_enable ) \n { \n uint8_t rc = VIRTIO_NET_HDR_GSO_NONE ; \n uint16_t l3_proto ; \n l3_proto = eth_get_l3_proto ( pkt -> vec [ NET_TX_PKT_L2HDR_FRAG ] . iov_base , \n pkt -> vec [ NET_TX_PKT_L2HDR_FRAG ] . iov_len ) ; \n if ( ! tso_enable ) { \n goto func_exit ; \n } \n rc = eth_get_gso_type ( l3_proto , pkt -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_base , \n pkt -> l4proto ) ; \n func_exit : \n return rc ; \n }", "idx": 1770}
{"project": "qemu", "commit_id": "6977afda16c1e09dfbce4bdd877459a287269b72", "target": 1, "func": "int kvmppc_reset_htab ( int shift_hint ) \n { \n uint32_t shift = shift_hint ; \n if ( ! kvm_enabled ( ) ) { \n return 0 ; \n } \n if ( kvm_check_extension ( kvm_state , KVM_CAP_PPC_ALLOC_HTAB ) ) { \n int ret ; \n ret = kvm_vm_ioctl ( kvm_state , KVM_PPC_ALLOCATE_HTAB , & shift ) ; \n if ( ret == - ENOTTY ) { \n return 0 ; \n } else if ( ret < 0 ) { \n return ret ; \n } \n return shift ; \n } \n if ( kvmppc_is_pr ( kvm_state ) ) { \n return 0 ; \n } else { \n return 24 ; \n } \n }", "idx": 1802}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close ( BlockDriverState * bs ) \n { \n BDRVVPCState * s = bs -> opaque ; \n g_free ( s -> pagetable ) ; \n #ifdef CACHE \n g_free ( s -> pageentry_u8 ) ; \n #endif \n migrate_del_blocker ( s -> migration_blocker ) ; \n error_free ( s -> migration_blocker ) ; \n }", "idx": 1817}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static int xen_platform_initfn ( PCIDevice * dev ) \n { \n PCIXenPlatformState * d = DO_UPCAST ( PCIXenPlatformState , pci_dev , dev ) ; \n uint8_t * pci_conf ; \n pci_conf = d -> pci_dev . config ; \n pci_set_word ( pci_conf + PCI_COMMAND , PCI_COMMAND_IO | PCI_COMMAND_MEMORY ) ; \n pci_config_set_prog_interface ( pci_conf , 0 ) ; \n pci_conf [ PCI_INTERRUPT_PIN ] = 1 ; \n pci_register_bar ( & d -> pci_dev , 0 , 0x100 , \n PCI_BASE_ADDRESS_SPACE_IO , platform_ioport_map ) ; \n pci_register_bar ( & d -> pci_dev , 1 , 0x1000000 , \n PCI_BASE_ADDRESS_MEM_PREFETCH , platform_mmio_map ) ; \n platform_fixed_ioport_init ( d ) ; \n return 0 ; \n }", "idx": 1894}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink ( FsContext * fs_ctx , const char * oldpath , \n V9fsPath * dir_path , const char * name , FsCred * credp ) \n { \n int retval ; \n V9fsString fullname , target ; \n v9fs_string_init ( & fullname ) ; \n v9fs_string_init ( & target ) ; \n v9fs_string_sprintf ( & fullname , \" \" , dir_path -> data , name ) ; \n v9fs_string_sprintf ( & target , \" \" , oldpath ) ; \n retval = v9fs_request ( fs_ctx -> private , T_SYMLINK , NULL , \" \" , \n & target , & fullname , credp -> fc_uid , credp -> fc_gid ) ; \n v9fs_string_free ( & fullname ) ; \n v9fs_string_free ( & target ) ; \n if ( retval < 0 ) { \n errno = - retval ; \n retval = -1 ; \n } \n return retval ; \n }", "idx": 1896}
{"project": "qemu", "commit_id": "ea486926b07d2ebd73ef67315ebb1eecf39faf5a", "target": 0, "func": "static int vfio_enable_intx ( VFIODevice * vdev ) \n { \n VFIOIRQSetFD irq_set_fd = { \n . irq_set = { \n . argsz = sizeof ( irq_set_fd ) , \n . flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER , \n . index = VFIO_PCI_INTX_IRQ_INDEX , \n . start = 0 , \n . count = 1 , \n } , \n } ; \n uint8_t pin = vfio_pci_read_config ( & vdev -> pdev , PCI_INTERRUPT_PIN , 1 ) ; \n int ret ; \n if ( vdev -> intx . disabled || ! pin ) { \n return 0 ; \n } \n vfio_disable_interrupts ( vdev ) ; \n vdev -> intx . pin = pin - 1 ; \n ret = event_notifier_init ( & vdev -> intx . interrupt , 0 ) ; \n if ( ret ) { \n error_report ( \" \\n \" ) ; \n return ret ; \n } \n irq_set_fd . fd = event_notifier_get_fd ( & vdev -> intx . interrupt ) ; \n qemu_set_fd_handler ( irq_set_fd . fd , vfio_intx_interrupt , NULL , vdev ) ; \n if ( ioctl ( vdev -> fd , VFIO_DEVICE_SET_IRQS , & irq_set_fd ) ) { \n error_report ( \" \\n \" ) ; \n return - errno ; \n } \n vfio_mmap_set_enabled ( vdev , false ) ; \n vdev -> interrupt = VFIO_INT_INTx ; \n DPRINTF ( \" \\n \" , __func__ , vdev -> host . domain , \n vdev -> host . bus , vdev -> host . slot , vdev -> host . function ) ; \n return 0 ; \n }", "idx": 1900}
{"project": "qemu", "commit_id": "fc89efe693278c79273f3bbf6b581e8a749c85b0", "target": 0, "func": "void HELPER ( mvc ) ( CPUS390XState * env , uint32_t l , uint64_t dest , uint64_t src ) \n { \n int i = 0 ; \n int x = 0 ; \n uint32_t l_64 = ( l + 1 ) / 8 ; \n HELPER_LOG ( \" \" PRIx64 \" \" PRIx64 \" \\n \" , \n __func__ , l , dest , src ) ; \n #ifndef CONFIG_USER_ONLY \n if ( ( l > 32 ) && \n ( src & TARGET_PAGE_MASK ) == ( ( src + l ) & TARGET_PAGE_MASK ) && \n ( dest & TARGET_PAGE_MASK ) == ( ( dest + l ) & TARGET_PAGE_MASK ) ) { \n if ( dest == ( src + 1 ) ) { \n mvc_fast_memset ( env , l + 1 , dest , cpu_ldub_data ( env , src ) ) ; \n return ; \n } else if ( ( src & TARGET_PAGE_MASK ) != ( dest & TARGET_PAGE_MASK ) ) { \n mvc_fast_memmove ( env , l + 1 , dest , src ) ; \n return ; \n } \n } \n #else \n if ( dest == ( src + 1 ) ) { \n memset ( g2h ( dest ) , cpu_ldub_data ( env , src ) , l + 1 ) ; \n return ; \n } else if ( ( dest < src ) || ( src + l < dest ) ) { \n memmove ( g2h ( dest ) , g2h ( src ) , l + 1 ) ; \n return ; \n } \n #endif \n if ( ( dest + 8 <= src ) || ( src + 8 <= dest ) ) { \n for ( i = 0 ; i < l_64 ; i ++ ) { \n cpu_stq_data ( env , dest + x , cpu_ldq_data ( env , src + x ) ) ; \n x += 8 ; \n } \n } \n for ( i = x ; i <= l ; i ++ ) { \n cpu_stb_data ( env , dest + i , cpu_ldub_data ( env , src + i ) ) ; \n } \n }", "idx": 1902}
{"project": "qemu", "commit_id": "ba0e276db4b51bd2255a5d5ff8902c70d32ade40", "target": 0, "func": "void helper_store_fpcr ( uint64_t val ) \n { \n #ifdef CONFIG_SOFTFLOAT \n set_float_exception_flags ( ( val >> 52 ) & 0x3F , & FP_STATUS ) ; \n #endif \n switch ( ( val >> 58 ) & 3 ) { \n case 0 : \n set_float_rounding_mode ( float_round_to_zero , & FP_STATUS ) ; \n break ; \n case 1 : \n set_float_rounding_mode ( float_round_down , & FP_STATUS ) ; \n break ; \n case 2 : \n set_float_rounding_mode ( float_round_nearest_even , & FP_STATUS ) ; \n break ; \n case 3 : \n set_float_rounding_mode ( float_round_up , & FP_STATUS ) ; \n break ; \n } \n }", "idx": 1905}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass ( sPAPRTCETable * tcet , bool bypass ) \n { \n tcet -> bypass = bypass ; \n }", "idx": 1909}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_wakeup_request ( WakeupReason reason ) \n { \n if ( ! is_suspended ) { \n return ; \n } \n if ( ! ( wakeup_reason_mask & ( 1 << reason ) ) ) { \n return ; \n } \n runstate_set ( RUN_STATE_RUNNING ) ; \n monitor_protocol_event ( QEVENT_WAKEUP , NULL ) ; \n notifier_list_notify ( & wakeup_notifiers , & reason ) ; \n reset_requested = 1 ; \n qemu_notify_event ( ) ; \n is_suspended = false ; \n }", "idx": 1917}
{"project": "qemu", "commit_id": "6b9b8758c15f3bc2875dbd6e2d03c5362b8d6902", "target": 0, "func": "static int virtio_net_device_exit ( DeviceState * qdev ) \n { \n VirtIONet * n = VIRTIO_NET ( qdev ) ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( qdev ) ; \n int i ; \n virtio_net_set_status ( vdev , 0 ) ; \n unregister_savevm ( qdev , \" \" , n ) ; \n if ( n -> netclient_name ) { \n g_free ( n -> netclient_name ) ; \n n -> netclient_name = NULL ; \n } \n if ( n -> netclient_type ) { \n g_free ( n -> netclient_type ) ; \n n -> netclient_type = NULL ; \n } \n g_free ( n -> mac_table . macs ) ; \n g_free ( n -> vlans ) ; \n for ( i = 0 ; i < n -> max_queues ; i ++ ) { \n VirtIONetQueue * q = & n -> vqs [ i ] ; \n NetClientState * nc = qemu_get_subqueue ( n -> nic , i ) ; \n qemu_purge_queued_packets ( nc ) ; \n if ( q -> tx_timer ) { \n timer_del ( q -> tx_timer ) ; \n timer_free ( q -> tx_timer ) ; \n } else { \n qemu_bh_delete ( q -> tx_bh ) ; \n } \n } \n g_free ( n -> vqs ) ; \n qemu_del_nic ( n -> nic ) ; \n virtio_cleanup ( vdev ) ; \n return 0 ; \n }", "idx": 1981}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_widen ( TCGv dest , TCGv src , int size , int u ) \n { \n if ( u ) { \n switch ( size ) { \n case 0 : gen_helper_neon_widen_u8 ( dest , src ) ; break ; \n case 1 : gen_helper_neon_widen_u16 ( dest , src ) ; break ; \n case 2 : tcg_gen_extu_i32_i64 ( dest , src ) ; break ; \n default : abort ( ) ; \n } \n } else { \n switch ( size ) { \n case 0 : gen_helper_neon_widen_s8 ( dest , src ) ; break ; \n case 1 : gen_helper_neon_widen_s16 ( dest , src ) ; break ; \n case 2 : tcg_gen_ext_i32_i64 ( dest , src ) ; break ; \n default : abort ( ) ; \n } \n } \n dead_tmp ( src ) ; \n }", "idx": 1983}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_create_branch ( BDRVSheepdogState * s ) \n { \n int ret , fd ; \n uint32_t vid ; \n char * buf ; \n dprintf ( \" \" PRIx32 \" \\n \" , s -> inode . vdi_id ) ; \n buf = g_malloc ( SD_INODE_SIZE ) ; \n ret = do_sd_create ( s -> name , s -> inode . vdi_size , s -> inode . vdi_id , & vid , 1 , \n s -> addr , s -> port ) ; \n if ( ret ) { \n goto out ; \n } \n dprintf ( \" \" PRIx32 \" \\n \" , vid ) ; \n fd = connect_to_sdog ( s -> addr , s -> port ) ; \n if ( fd < 0 ) { \n error_report ( \" \" ) ; \n ret = fd ; \n goto out ; \n } \n ret = read_object ( fd , buf , vid_to_vdi_oid ( vid ) , s -> inode . nr_copies , \n SD_INODE_SIZE , 0 , s -> cache_enabled ) ; \n closesocket ( fd ) ; \n if ( ret < 0 ) { \n goto out ; \n } \n memcpy ( & s -> inode , buf , sizeof ( s -> inode ) ) ; \n s -> is_snapshot = false ; \n ret = 0 ; \n dprintf ( \" \" PRIx32 \" \\n \" , s -> inode . vdi_id ) ; \n out : \n g_free ( buf ) ; \n return ret ; \n }", "idx": 1990}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8 ( DeviceState * dev , Property * prop , const char * str ) \n { \n uint8_t * ptr = qdev_get_prop_ptr ( dev , prop ) ; \n const char * fmt ; \n fmt = strncasecmp ( str , \" \" , 2 ) == 0 ? \" \" PRIx8 : \" \" PRIu8 ; \n if ( sscanf ( str , fmt , ptr ) != 1 ) \n return - EINVAL ; \n return 0 ; \n }", "idx": 1994}
{"project": "qemu", "commit_id": "1a0e4c8b02ea510508970c333ee610a90b921cbb", "target": 1, "func": "void s390_machine_reset ( void ) \n { \n S390CPU * ipl_cpu = S390_CPU ( qemu_get_cpu ( 0 ) ) ; \n qemu_devices_reset ( ) ; \n s390_cmma_reset ( ) ; \n s390_crypto_reset ( ) ; \n s390_ipl_prepare_cpu ( ipl_cpu ) ; \n s390_cpu_set_state ( CPU_STATE_OPERATING , ipl_cpu ) ; \n }", "idx": 2009}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in ( USBDevice * s , USBPacket * p ) \n { \n int request , value , index ; \n assert ( p -> ep -> nr == 0 ) ; \n request = ( s -> setup_buf [ 0 ] << 8 ) | s -> setup_buf [ 1 ] ; \n value = ( s -> setup_buf [ 3 ] << 8 ) | s -> setup_buf [ 2 ] ; \n index = ( s -> setup_buf [ 5 ] << 8 ) | s -> setup_buf [ 4 ] ; \n switch ( s -> setup_state ) { \n case SETUP_STATE_ACK : \n if ( ! ( s -> setup_buf [ 0 ] & USB_DIR_IN ) ) { \n usb_device_handle_control ( s , p , request , value , index , \n s -> setup_len , s -> data_buf ) ; \n if ( p -> status == USB_RET_ASYNC ) { \n return ; \n } \n s -> setup_state = SETUP_STATE_IDLE ; \n p -> actual_length = 0 ; \n } \n break ; \n case SETUP_STATE_DATA : \n if ( s -> setup_buf [ 0 ] & USB_DIR_IN ) { \n int len = s -> setup_len - s -> setup_index ; \n if ( len > p -> iov . size ) { \n len = p -> iov . size ; \n } \n usb_packet_copy ( p , s -> data_buf + s -> setup_index , len ) ; \n s -> setup_index += len ; \n if ( s -> setup_index >= s -> setup_len ) { \n s -> setup_state = SETUP_STATE_ACK ; \n } \n return ; \n } \n s -> setup_state = SETUP_STATE_IDLE ; \n p -> status = USB_RET_STALL ; \n break ; \n default : \n p -> status = USB_RET_STALL ; \n } \n }", "idx": 2047}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted ( UserCreatable * uc , Error * * errp )  \n { \n MemoryRegion * mr ; \n mr = host_memory_backend_get_memory ( MEMORY_BACKEND ( uc ) , errp ) ; \n if ( memory_region_is_mapped ( mr ) ) { \n return false ; \n } else { \n return true ; \n } \n }", "idx": 2063}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned size ) \n { \n struct omap_pwt_s * s = ( struct omap_pwt_s * ) opaque ; \n int offset = addr & OMAP_MPUI_REG_MASK ; \n if ( size != 1 ) { \n return omap_badwidth_write8 ( opaque , addr , value ) ; \n } \n switch ( offset ) { \n case 0x00 : \n s -> frc = value & 0x3f ; \n break ; \n case 0x04 : \n if ( ( value ^ s -> vrc ) & 1 ) { \n if ( value & 1 ) \n printf ( \" \\n \" , __FUNCTION__ , ( int ) \n ( ( omap_clk_getrate ( s -> clk ) >> 3 ) / \n ( ( s -> gcr & 2 ) ? 1 : 154 ) / \n ( 2 << ( value & 3 ) ) * \n ( ( value & ( 1 << 2 ) ) ? 101 : 107 ) * \n ( ( value & ( 1 << 3 ) ) ? 49 : 55 ) * \n ( ( value & ( 1 << 4 ) ) ? 50 : 63 ) * \n ( ( value & ( 1 << 5 ) ) ? 80 : 127 ) / \n ( 107 * 55 * 63 * 127 ) ) ) ; \n else \n printf ( \" \\n \" , __FUNCTION__ ) ; \n } \n s -> vrc = value & 0x7f ; \n break ; \n case 0x08 : \n s -> gcr = value & 3 ; \n break ; \n default : \n OMAP_BAD_REG ( addr ) ; \n return ; \n } \n }", "idx": 2084}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static inline int cpu_gdb_index ( CPUState * cpu ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  return cpu -> host_tid ; \n #else \n return cpu -> cpu_index + 1 ; \n #endif \n }", "idx": 2133}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs ( Monitor * mon , const QDict * qdict ) \n { \n BlockJobInfoList * list ; \n Error * err = NULL ; \n list = qmp_query_block_jobs ( & err ) ; \n assert ( ! err ) ; \n if ( ! list ) { \n monitor_printf ( mon , \" \\n \" ) ; \n return ; \n } \n while ( list ) { \n if ( strcmp ( list -> value -> type , \" \" ) == 0 ) { \n monitor_printf ( mon , \" \" PRId64 \n \" \" PRId64 \" \" PRId64 \n \" \\n \" , \n list -> value -> device , \n list -> value -> offset , \n list -> value -> len , \n list -> value -> speed ) ; \n } else { \n monitor_printf ( mon , \" \" PRId64 \n \" \" PRId64 \" \" PRId64 \n \" \\n \" , \n list -> value -> type , \n list -> value -> device , \n list -> value -> offset , \n list -> value -> len , \n list -> value -> speed ) ; \n } \n list = list -> next ; \n } \n }", "idx": 2148}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static void curl_multi_do ( void * arg ) \n { \n BDRVCURLState * s = ( BDRVCURLState * ) arg ; \n int running ; \n int r ; \n if ( ! s -> multi ) { \n return ; \n } \n do { \n r = curl_multi_socket_all ( s -> multi , & running ) ; \n } while ( r == CURLM_CALL_MULTI_PERFORM ) ; \n curl_multi_read ( s ) ; \n }", "idx": 2187}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc ( TCGContext * s , int opc , int r , int rm , int x ) \n { \n int rex ; \n if ( opc & P_GS ) { \n tcg_out8 ( s , 0x65 ) ; \n } \n if ( opc & P_DATA16 ) { \n assert ( ( opc & P_REXW ) == 0 ) ; \n tcg_out8 ( s , 0x66 ) ; \n } \n if ( opc & P_ADDR32 ) { \n tcg_out8 ( s , 0x67 ) ; \n } \n rex = 0 ; \n rex |= ( opc & P_REXW ) ? 0x8 : 0x0 ; \n rex |= ( r & 8 ) >> 1 ; \n rex |= ( x & 8 ) >> 2 ; \n rex |= ( rm & 8 ) >> 3 ; \n rex |= opc & ( r >= 4 ? P_REXB_R : 0 ) ; \n rex |= opc & ( rm >= 4 ? P_REXB_RM : 0 ) ; \n if ( rex ) { \n tcg_out8 ( s , ( uint8_t ) ( rex | 0x40 ) ) ; \n } \n if ( opc & ( P_EXT | P_EXT38 ) ) { \n tcg_out8 ( s , 0x0f ) ; \n if ( opc & P_EXT38 ) { \n tcg_out8 ( s , 0x38 ) ; \n } \n } \n tcg_out8 ( s , opc ) ; \n }", "idx": 2195}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n gen_helper_602_mfrom ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n #endif \n }", "idx": 2229}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block ( QEMUFile * f ) \n { \n RAMBlock * block = last_block ; \n ram_addr_t offset = last_offset ; \n int bytes_sent = -1 ; \n MemoryRegion * mr ; \n if ( ! block ) \n block = QLIST_FIRST ( & ram_list . blocks ) ; \n do { \n mr = block -> mr ; \n if ( memory_region_get_dirty ( mr , offset , TARGET_PAGE_SIZE , \n DIRTY_MEMORY_MIGRATION ) ) { \n uint8_t * p ; \n int cont = ( block == last_block ) ? RAM_SAVE_FLAG_CONTINUE : 0 ; \n memory_region_reset_dirty ( mr , offset , TARGET_PAGE_SIZE , \n DIRTY_MEMORY_MIGRATION ) ; \n p = memory_region_get_ram_ptr ( mr ) + offset ; \n if ( is_dup_page ( p ) ) { \n save_block_hdr ( f , block , offset , cont , RAM_SAVE_FLAG_COMPRESS ) ; \n qemu_put_byte ( f , * p ) ; \n bytes_sent = 1 ; \n } else { \n save_block_hdr ( f , block , offset , cont , RAM_SAVE_FLAG_PAGE ) ; \n qemu_put_buffer ( f , p , TARGET_PAGE_SIZE ) ; \n bytes_sent = TARGET_PAGE_SIZE ; \n } \n break ; \n } \n offset += TARGET_PAGE_SIZE ; \n if ( offset >= block -> length ) { \n offset = 0 ; \n block = QLIST_NEXT ( block , next ) ; \n if ( ! block ) \n block = QLIST_FIRST ( & ram_list . blocks ) ; \n } \n } while ( block != last_block || offset != last_offset ) ; \n last_block = block ; \n last_offset = offset ; \n return bytes_sent ; \n }", "idx": 2280}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_add_raw_fragment ( struct NetTxPkt * pkt , hwaddr pa , \n size_t len ) \n { \n hwaddr mapped_len = 0 ; \n struct iovec * ventry ; \n assert ( pkt ) ; \n assert ( pkt -> max_raw_frags > pkt -> raw_frags ) ; \n if ( ! len ) { \n return true ; \n } \n ventry = & pkt -> raw [ pkt -> raw_frags ] ; \n mapped_len = len ; \n ventry -> iov_base = cpu_physical_memory_map ( pa , & mapped_len , false ) ; \n ventry -> iov_len = mapped_len ; \n pkt -> raw_frags += ! ! ventry -> iov_base ; \n if ( ( ventry -> iov_base == NULL ) || ( len != mapped_len ) ) { \n return false ; \n } \n return true ; \n }", "idx": 2297}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init ( CPUState * env ) \n { \n CPUState * * penv ; \n int cpu_index ; \n if ( ! code_gen_ptr ) { \n code_gen_ptr = code_gen_buffer ; \n page_init ( ) ; \n io_mem_init ( ) ; \n } \n env -> next_cpu = NULL ; \n penv = & first_cpu ; \n cpu_index = 0 ; \n while ( * penv != NULL ) { \n penv = ( CPUState * * ) & ( * penv ) -> next_cpu ; \n cpu_index ++ ; \n } \n env -> cpu_index = cpu_index ; \n * penv = env ; \n }", "idx": 2334}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async ( const mon_cmd_t * cmd ) \n { \n return cmd -> flags & MONITOR_CMD_ASYNC ; \n }", "idx": 2349}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask ( uint64_t * result , unsigned int immn , \n unsigned int imms , unsigned int immr ) \n { \n uint64_t mask ; \n unsigned e , levels , s , r ; \n int len ; \n assert ( immn < 2 && imms < 64 && immr < 64 ) ; \n len = 31 - clz32 ( ( immn << 6 ) | ( ~ imms & 0x3f ) ) ; \n if ( len < 1 ) { \n return false ; \n } \n e = 1 << len ; \n levels = e - 1 ; \n s = imms & levels ; \n r = immr & levels ; \n if ( s == levels ) { \n return false ; \n } \n mask = bitmask64 ( s + 1 ) ; \n mask = ( mask >> r ) | ( mask << ( e - r ) ) ; \n mask = bitfield_replicate ( mask , e ) ; \n * result = mask ; \n return true ; \n }", "idx": 2395}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN ( DisasContext * dc , int r , TCGv tn ) \n { \n if ( r < 0 || r > 15 ) { \n fprintf ( stderr , \" \\n \" , r ) ; \n } \n if ( r == PR_BZ || r == PR_WZ || r == PR_DZ ) { \n return ; \n } else if ( r == PR_SRS ) { \n tcg_gen_andi_tl ( cpu_PR [ r ] , tn , 3 ) ; \n } else { \n if ( r == PR_PID ) { \n gen_helper_tlb_flush_pid ( cpu_env , tn ) ; \n } \n if ( dc -> tb_flags & S_FLAG && r == PR_SPC ) { \n gen_helper_spc_write ( cpu_env , tn ) ; \n } else if ( r == PR_CCS ) { \n dc -> cpustate_changed = 1 ; \n } \n tcg_gen_mov_tl ( cpu_PR [ r ] , tn ) ; \n } \n }", "idx": 2415}
{"project": "qemu", "commit_id": "c1bf3531aecf4a0ba25bb150dd5fe21edf406c88", "target": 1, "func": "static int net_vhost_user_init ( NetClientState * peer , const char * device , \n const char * name , CharDriverState * chr , \n int queues ) \n { \n NetClientState * nc ; \n VhostUserState * s ; \n int i ; \n for ( i = 0 ; i < queues ; i ++ ) { \n nc = qemu_new_net_client ( & net_vhost_user_info , peer , device , name ) ; \n snprintf ( nc -> info_str , sizeof ( nc -> info_str ) , \" \" , \n i , chr -> label ) ; \n nc -> queue_index = i ; \n s = DO_UPCAST ( VhostUserState , nc , nc ) ; \n s -> chr = chr ; \n } \n qemu_chr_add_handlers ( chr , NULL , NULL , net_vhost_user_event , ( void * ) name ) ; \n return 0 ; \n }", "idx": 2451}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static void scsi_read_data ( SCSIDevice * d , uint32_t tag ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; \n SCSIDiskReq * r ; \n r = scsi_find_request ( s , tag ) ; \n if ( ! r ) { \n BADF ( \" \\n \" , tag ) ; \n scsi_command_complete ( r , CHECK_CONDITION , HARDWARE_ERROR ) ; \n return ; \n } \n assert ( r -> req . aiocb == NULL ) ; \n scsi_read_request ( r ) ; \n }", "idx": 2471}
{"project": "qemu", "commit_id": "8653c0158c23ec592f0041ab48b83d6cc6d152fe", "target": 0, "func": "static int spawn_thread ( void ) \n { \n pthread_attr_t attr ; \n int ret ; \n cur_threads ++ ; \n idle_threads ++ ; \n pthread_attr_init ( & attr ) ; \n pthread_attr_setdetachstate ( & attr , PTHREAD_CREATE_DETACHED ) ; \n ret = pthread_create ( & thread_id , & attr , aio_thread , NULL ) ; \n pthread_attr_destroy ( & attr ) ; \n return ret ; \n }", "idx": 2523}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu ( MachineState * machine ) \n { \n return machine -> iommu ; \n }", "idx": 2535}
{"project": "qemu", "commit_id": "cc68890166c2c1c5003e3eeb8535e1872e239a95", "target": 0, "func": "static int disas_cp15_insn ( CPUState * env , DisasContext * s , uint32_t insn ) \n { \n uint32_t rd ; \n TCGv tmp , tmp2 ; \n if ( arm_feature ( env , ARM_FEATURE_M ) ) \n return 1 ; \n if ( ( insn & ( 1 << 25 ) ) == 0 ) { \n if ( insn & ( 1 << 20 ) ) { \n return 1 ; \n } \n return 0 ; \n } \n if ( ( insn & ( 1 << 4 ) ) == 0 ) { \n return 1 ; \n } \n if ( IS_USER ( s ) && ! cp15_user_ok ( insn ) ) { \n return 1 ; \n } \n if ( ( insn & 0x0fff0fff ) == 0x0e070f90 \n || ( insn & 0x0fff0fff ) == 0x0e070f58 ) { \n gen_set_pc_im ( s -> pc ) ; \n s -> is_jmp = DISAS_WFI ; \n return 0 ; \n } \n rd = ( insn >> 12 ) & 0xf ; \n if ( cp15_tls_load_store ( env , s , insn , rd ) ) \n return 0 ; \n tmp2 = tcg_const_i32 ( insn ) ; \n if ( insn & ARM_CP_RW_BIT ) { \n tmp = new_tmp ( ) ; \n gen_helper_get_cp15 ( tmp , cpu_env , tmp2 ) ; \n if ( rd != 15 ) \n store_reg ( s , rd , tmp ) ; \n else \n dead_tmp ( tmp ) ; \n } else { \n tmp = load_reg ( s , rd ) ; \n gen_helper_set_cp15 ( cpu_env , tmp2 , tmp ) ; \n dead_tmp ( tmp ) ; \n if ( ! arm_feature ( env , ARM_FEATURE_XSCALE ) || \n ( insn & 0x0fff0fff ) != 0x0e010f10 ) \n gen_lookup_tb ( s ) ; \n } \n tcg_temp_free_i32 ( tmp2 ) ; \n return 0 ; \n }", "idx": 2538}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState * vc_init ( const char * id , ChardevBackend * backend , \n ChardevReturn * ret , Error * * errp ) \n { \n return vc_handler ( backend -> u . vc , errp ) ; \n }", "idx": 2564}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp ( CPUPPCState * env , uint64_t arg ) \n { \n CPU_DoubleU farg ; \n float32 f32 ; \n farg . ll = arg ; \n if ( unlikely ( float64_is_signaling_nan ( farg . d ) ) ) { \n fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN ) ; \n } \n f32 = float64_to_float32 ( farg . d , & env -> fp_status ) ; \n farg . d = float32_to_float64 ( f32 , & env -> fp_status ) ; \n return farg . ll ; \n }", "idx": 2594}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "int gen_new_label ( void ) \n { \n TCGContext * s = & tcg_ctx ; \n int idx ; \n TCGLabel * l ; \n if ( s -> nb_labels >= TCG_MAX_LABELS ) \n tcg_abort ( ) ; \n idx = s -> nb_labels ++ ; \n l = & s -> labels [ idx ] ; \n l -> has_value = 0 ; \n l -> u . first_reloc = NULL ; \n return idx ; \n }", "idx": 2602}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_round_to_clusters ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors , \n int64_t * cluster_sector_num , \n int * cluster_nb_sectors ) \n { \n BlockDriverInfo bdi ; \n if ( bdrv_get_info ( bs , & bdi ) < 0 || bdi . cluster_size == 0 ) { \n * cluster_sector_num = sector_num ; \n * cluster_nb_sectors = nb_sectors ; \n } else { \n int64_t c = bdi . cluster_size / BDRV_SECTOR_SIZE ; \n * cluster_sector_num = QEMU_ALIGN_DOWN ( sector_num , c ) ; \n * cluster_nb_sectors = QEMU_ALIGN_UP ( sector_num - * cluster_sector_num + \n nb_sectors , c ) ; \n } \n }", "idx": 2604}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty ( CPUState * cpu , ram_addr_t start1 , ram_addr_t length ) \n { \n CPUArchState * env ; \n int mmu_idx ; \n assert_cpu_is_self ( cpu ) ; \n env = cpu -> env_ptr ; \n for ( mmu_idx = 0 ; mmu_idx < NB_MMU_MODES ; mmu_idx ++ ) { \n unsigned int i ; \n for ( i = 0 ; i < CPU_TLB_SIZE ; i ++ ) { \n tlb_reset_dirty_range ( & env -> tlb_table [ mmu_idx ] [ i ] , \n start1 , length ) ; \n } \n for ( i = 0 ; i < CPU_VTLB_SIZE ; i ++ ) { \n tlb_reset_dirty_range ( & env -> tlb_v_table [ mmu_idx ] [ i ] , \n start1 , length ) ; \n } \n } \n }", "idx": 2620}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv ( BlockDriverState * bs , uint64_t offset , uint64_t bytes , \n QEMUIOVector * qiov , int flags )  \n { \n BDRVBlkdebugState * s = bs -> opaque ; \n BlkdebugRule * rule = NULL ; \n QSIMPLEQ_FOREACH ( rule , & s -> active_rules , active_next )  { \n uint64_t inject_offset = rule -> options . inject . offset ; \n if ( inject_offset == -1 || \n ( inject_offset >= offset && inject_offset < offset + bytes ) ) \n { \n break ; \n if ( rule && rule -> options . inject . error ) { \n return inject_error ( bs , rule ) ; \n return bdrv_co_preadv ( bs -> file , offset , bytes , qiov , flags ) ;", "idx": 2622}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1 ( SysBusDevice * dev ) \n { \n IDRegState * s = MACIO_ID_REGISTER ( dev ) ; \n memory_region_init_ram ( & s -> mem , OBJECT ( s ) , \n \" \" , sizeof ( idreg_data ) , & error_abort ) ; \n vmstate_register_ram_global ( & s -> mem ) ; \n memory_region_set_readonly ( & s -> mem , true ) ; \n sysbus_init_mmio ( dev , & s -> mem ) ; \n return 0 ; \n }", "idx": 2624}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_ld_ptr ( TCGContext * s , int ret , \n tcg_target_long arg ) \n { \n #if defined ( __sparc_v9__ ) && ! defined ( __sparc_v8plus__ )  \n  \n  if ( arg != ( arg & 0xffffffff ) ) \n fprintf ( stderr , \" \\n \" , __func__ , arg ) ; \n if ( arg != ( arg & 0xfff ) ) \n tcg_out32 ( s , SETHI | INSN_RD ( ret ) | ( ( ( uint32_t ) arg & 0xfffffc00 ) >> 10 ) ) ; \n tcg_out32 ( s , LDX | INSN_RD ( ret ) | INSN_RS1 ( ret ) | \n INSN_IMM13 ( arg & 0x3ff ) ) ; \n #else \n tcg_out_ld_raw ( s , ret , arg ) ; \n #endif \n }", "idx": 2628}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "int xen_config_dev_blk ( DriveInfo * disk ) \n { \n char fe [ 256 ] , be [ 256 ] ; \n int vdev = 202 * 256 + 16 * disk -> unit ; \n int cdrom = disk -> bdrv -> type == BDRV_TYPE_CDROM ; \n const char * devtype = cdrom ? \" \" : \" \" ; \n const char * mode = cdrom ? \" \" : \" \" ; \n snprintf ( disk -> bdrv -> device_name , sizeof ( disk -> bdrv -> device_name ) , \n \" \" , ' ' + disk -> unit ) ; \n xen_be_printf ( NULL , 1 , \" \\n \" , \n disk -> unit , disk -> bdrv -> device_name , disk -> bdrv -> filename ) ; \n xen_config_dev_dirs ( \" \" , \" \" , vdev , fe , be , sizeof ( fe ) ) ; \n xenstore_write_int ( fe , \" \" , vdev ) ; \n xenstore_write_str ( fe , \" \" , devtype ) ; \n xenstore_write_str ( be , \" \" , disk -> bdrv -> device_name ) ; \n xenstore_write_str ( be , \" \" , \" \" ) ; \n xenstore_write_str ( be , \" \" , disk -> bdrv -> filename ) ; \n xenstore_write_str ( be , \" \" , mode ) ; \n return xen_config_dev_all ( fe , be ) ; \n }", "idx": 2632}
{"project": "qemu", "commit_id": "615220ddaf23db4c5686053257c568b46967e4b5", "target": 1, "func": "static void curses_setup ( void ) \n { \n int i , colour_default [ 8 ] = { \n COLOR_BLACK , COLOR_BLUE , COLOR_GREEN , COLOR_CYAN , \n COLOR_RED , COLOR_MAGENTA , COLOR_YELLOW , COLOR_WHITE , \n } ; \n initscr ( ) ; noecho ( ) ; intrflush ( stdscr , FALSE ) ; \n nodelay ( stdscr , TRUE ) ; nonl ( ) ; keypad ( stdscr , TRUE ) ; \n start_color ( ) ; raw ( ) ; scrollok ( stdscr , FALSE ) ; \n for ( i = 0 ; i < 64 ; i ++ ) \n init_pair ( i , colour_default [ i & 7 ] , colour_default [ i >> 3 ] ) ; \n }", "idx": 2673}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16_equal ( QEMUFile * f , void * pv , size_t size ) \n { \n uint16_t * v = pv ; \n uint16_t v2 ; \n qemu_get_be16s ( f , & v2 ) ; \n if ( * v == v2 ) { \n return 0 ; \n } \n return - EINVAL ; \n }", "idx": 2680}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "static inline bool cpu_handle_exception ( CPUState * cpu , int * ret ) \n { \n if ( cpu -> exception_index >= 0 ) { \n if ( cpu -> exception_index >= EXCP_INTERRUPT ) { \n * ret = cpu -> exception_index ; \n if ( * ret == EXCP_DEBUG ) { \n cpu_handle_debug_exception ( cpu ) ; \n } \n cpu -> exception_index = -1 ; \n return true ; \n } else { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  \n  #if defined ( TARGET_I386 )  \n  \n  CPUClass * cc = CPU_GET_CLASS ( cpu ) ; \n cc -> do_interrupt ( cpu ) ; \n #endif \n * ret = cpu -> exception_index ; \n cpu -> exception_index = -1 ; \n return true ; \n #else \n if ( replay_exception ( ) ) { \n CPUClass * cc = CPU_GET_CLASS ( cpu ) ; \n qemu_mutex_lock_iothread ( ) ; \n cc -> do_interrupt ( cpu ) ; \n qemu_mutex_unlock_iothread ( ) ; \n cpu -> exception_index = -1 ; \n } else if ( ! replay_has_interrupt ( ) ) { \n * ret = EXCP_INTERRUPT ; \n return true ; \n } \n #endif \n } \n #ifndef CONFIG_USER_ONLY  \n } else if ( replay_has_exception ( ) \n && cpu -> icount_decr . u16 . low + cpu -> icount_extra == 0 ) { \n cpu_exec_nocache ( cpu , 1 , tb_find ( cpu , NULL , 0 ) , true ) ; \n * ret = -1 ; \n return true ; \n #endif  \n  \n  } \n return false ; \n }", "idx": 2762}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv ( CPUPPCState * env , uint64_t arg1 , uint64_t arg2 ) \n { \n CPU_DoubleU farg1 , farg2 ; \n farg1 . ll = arg1 ; \n farg2 . ll = arg2 ; \n if ( unlikely ( float64_is_infinity ( farg1 . d ) && \n float64_is_infinity ( farg2 . d ) ) ) { \n farg1 . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXIDI ) ; \n } else if ( unlikely ( float64_is_zero ( farg1 . d ) && float64_is_zero ( farg2 . d ) ) ) { \n farg1 . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXZDZ ) ; \n } else { \n if ( unlikely ( float64_is_signaling_nan ( farg1 . d ) || \n float64_is_signaling_nan ( farg2 . d ) ) ) { \n fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN ) ; \n } \n farg1 . d = float64_div ( farg1 . d , farg2 . d , & env -> fp_status ) ; \n } \n return farg1 . ll ; \n }", "idx": 2806}
{"project": "qemu", "commit_id": "e4d2edc9d0c58de421eb349871e90b67edec0b9c", "target": 0, "func": "static void test_io_channel_ipv4 ( bool async ) \n { \n SocketAddress * listen_addr = g_new0 ( SocketAddress , 1 ) ; \n SocketAddress * connect_addr = g_new0 ( SocketAddress , 1 ) ; \n listen_addr -> type = SOCKET_ADDRESS_KIND_INET ; \n listen_addr -> u . inet = g_new0 ( InetSocketAddress , 1 ) ; \n listen_addr -> u . inet -> host = g_strdup ( \" \" ) ; \n listen_addr -> u . inet -> port = NULL ; \n connect_addr -> type = SOCKET_ADDRESS_KIND_INET ; \n connect_addr -> u . inet = g_new0 ( InetSocketAddress , 1 ) ; \n connect_addr -> u . inet -> host = g_strdup ( \" \" ) ; \n connect_addr -> u . inet -> port = NULL ; \n test_io_channel ( async , listen_addr , connect_addr ) ; \n qapi_free_SocketAddress ( listen_addr ) ; \n qapi_free_SocketAddress ( connect_addr ) ; \n }", "idx": 2817}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat ( void * opaque ) \n { \n int32_t fid ; \n V9fsStat v9stat ; \n ssize_t err = 0 ; \n size_t offset = 7 ; \n struct stat stbuf ; \n V9fsFidState * fidp ; \n V9fsPDU * pdu = opaque ; \n V9fsState * s = pdu -> s ; \n pdu_unmarshal ( pdu , offset , \" \" , & fid ) ; \n trace_v9fs_stat ( pdu -> tag , pdu -> id , fid ) ; \n fidp = get_fid ( pdu , fid ) ; \n if ( fidp == NULL ) { \n err = - ENOENT ; \n goto out_nofid ; \n } \n err = v9fs_co_lstat ( pdu , & fidp -> path , & stbuf ) ; \n if ( err < 0 ) { \n goto out ; \n } \n err = stat_to_v9stat ( pdu , & fidp -> path , & stbuf , & v9stat ) ; \n if ( err < 0 ) { \n goto out ; \n } \n offset += pdu_marshal ( pdu , offset , \" \" , 0 , & v9stat ) ; \n err = offset ; \n trace_v9fs_stat_return ( pdu -> tag , pdu -> id , v9stat . mode , \n v9stat . atime , v9stat . mtime , v9stat . length ) ; \n v9fs_stat_free ( & v9stat ) ; \n out : \n put_fid ( pdu , fidp ) ; \n out_nofid : \n complete_pdu ( s , pdu , err ) ; \n }", "idx": 2820}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addlv ( uint64_t op1 , uint64_t op2 ) \n { \n uint64_t tmp = op1 ; \n op1 = ( uint32_t ) ( op1 + op2 ) ; \n if ( unlikely ( ( tmp ^ op2 ^ ( -1UL ) ) & ( tmp ^ op1 ) & ( 1UL << 31 ) ) ) { \n arith_excp ( env , GETPC ( ) , EXC_M_IOV , 0 ) ; \n } \n return op1 ; \n }", "idx": 2832}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode ( void ) \n { \n if ( ! ( env -> CP0_Status & ( 1 << CP0St_FR ) ) ) { \n CALL_FROM_TB1 ( do_raise_exception , EXCP_RI ) ; \n } \n RETURN ( ) ; \n }", "idx": 2880}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "void disas_a64_insn ( CPUARMState * env , DisasContext * s ) \n { \n uint32_t insn ; \n insn = arm_ldl_code ( env , s -> pc , s -> bswap_code ) ; \n s -> insn = insn ; \n s -> pc += 4 ; \n switch ( ( insn >> 24 ) & 0x1f ) { \n default : \n unallocated_encoding ( s ) ; \n break ; \n } \n if ( unlikely ( s -> singlestep_enabled ) && ( s -> is_jmp == DISAS_TB_JUMP ) ) { \n s -> is_jmp = DISAS_JUMP ; \n } \n }", "idx": 2884}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_v_reg ( int ot , TCGv t0 , int reg ) \n { \n switch ( ot ) { \n case OT_BYTE : \n if ( reg < 4 X86_64_DEF (  || reg >= 8 || x86_64_hregs ) ) { \n goto std_case ; \n } else { \n tcg_gen_shri_tl ( t0 , cpu_regs [ reg - 4 ] , 8 ) ; \n tcg_gen_ext8u_tl ( t0 , t0 ) ; \n } \n break ; \n default : \n std_case : \n tcg_gen_mov_tl ( t0 , cpu_regs [ reg ] ) ; \n break ; \n } \n }", "idx": 2895}
{"project": "qemu", "commit_id": "54421cb17bc744bad15f2b1adb4adefdaea83c10", "target": 0, "func": "static int hdev_open ( BlockDriverState * bs , const char * filename , int flags ) \n { \n BDRVRawState * s = bs -> opaque ; \n int access_flags , create_flags ; \n DWORD overlapped ; \n char device_name [ 64 ] ; \n if ( strstart ( filename , \" \" , NULL ) ) { \n if ( find_cdrom ( device_name , sizeof ( device_name ) ) < 0 ) \n return - ENOENT ; \n filename = device_name ; \n } else { \n if ( ( ( filename [ 0 ] >= ' ' && filename [ 0 ] <= ' ' ) || \n ( filename [ 0 ] >= ' ' && filename [ 0 ] <= ' ' ) ) && \n filename [ 1 ] == ' ' && filename [ 2 ] == ' \\0 ' ) { \n snprintf ( device_name , sizeof ( device_name ) , \" \\\\ \\\\ \\\\ \" , filename [ 0 ] ) ; \n filename = device_name ; \n } \n } \n s -> type = find_device_type ( bs , filename ) ; \n if ( ( flags & BDRV_O_ACCESS ) == O_RDWR ) { \n access_flags = GENERIC_READ | GENERIC_WRITE ; \n } else { \n access_flags = GENERIC_READ ; \n } \n create_flags = OPEN_EXISTING ; \n #ifdef QEMU_TOOL \n overlapped = FILE_ATTRIBUTE_NORMAL ; \n #else \n overlapped = FILE_FLAG_OVERLAPPED ; \n #endif \n s -> hfile = CreateFile ( filename , access_flags , \n FILE_SHARE_READ , NULL , \n create_flags , overlapped , NULL ) ; \n if ( s -> hfile == INVALID_HANDLE_VALUE ) \n return -1 ; \n return 0 ; \n }", "idx": 2903}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static void sigp_store_adtl_status ( CPUState * cs , run_on_cpu_data arg ) \n { \n S390CPU * cpu = S390_CPU ( cs ) ; \n SigpInfo * si = arg . host_ptr ; \n if ( ! s390_has_feat ( S390_FEAT_VECTOR ) ) { \n set_sigp_status ( si , SIGP_STAT_INVALID_ORDER ) ; \n return ; \n } \n if ( s390_cpu_get_state ( cpu ) != CPU_STATE_STOPPED ) { \n set_sigp_status ( si , SIGP_STAT_INCORRECT_STATE ) ; \n return ; \n } \n if ( si -> param & 0x3ff ) { \n set_sigp_status ( si , SIGP_STAT_INVALID_PARAMETER ) ; \n return ; \n } \n cpu_synchronize_state ( cs ) ; \n if ( kvm_s390_store_adtl_status ( cpu , si -> param ) ) { \n set_sigp_status ( si , SIGP_STAT_INVALID_PARAMETER ) ; \n return ; \n } \n si -> cc = SIGP_CC_ORDER_CODE_ACCEPTED ; \n }", "idx": 2911}
{"project": "qemu", "commit_id": "ff1d1977ffe1c276f5937a6ad4b6a5b6d2b1c6ae", "target": 0, "func": "static int cpu_gdb_write_register ( CPUState * env , uint8_t * mem_buf , int n ) \n { \n target_ulong tmp ; \n tmp = ldtul_p ( mem_buf ) ; \n if ( n < 32 ) { \n env -> active_tc . gpr [ n ] = tmp ; \n return sizeof ( target_ulong ) ; \n } \n if ( env -> CP0_Config1 & ( 1 << CP0C1_FP ) \n && n >= 38 && n < 73 ) { \n if ( n < 70 ) { \n if ( env -> CP0_Status & ( 1 << CP0St_FR ) ) \n env -> active_fpu . fpr [ n - 38 ] . d = tmp ; \n else \n env -> active_fpu . fpr [ n - 38 ] . w [ FP_ENDIAN_IDX ] = tmp ; \n } \n switch ( n ) { \n case 70 : \n env -> active_fpu . fcr31 = tmp & 0xFF83FFFF ; \n RESTORE_ROUNDING_MODE ; \n #ifndef CONFIG_SOFTFLOAT \n SET_FP_ENABLE ( env -> active_fpu . fcr31 , 0 ) ; \n #endif \n break ; \n case 71 : env -> active_fpu . fcr0 = tmp ; break ; \n } \n return sizeof ( target_ulong ) ; \n } \n switch ( n ) { \n case 32 : env -> CP0_Status = tmp ; break ; \n case 33 : env -> active_tc . LO [ 0 ] = tmp ; break ; \n case 34 : env -> active_tc . HI [ 0 ] = tmp ; break ; \n case 35 : env -> CP0_BadVAddr = tmp ; break ; \n case 36 : env -> CP0_Cause = tmp ; break ; \n case 37 : env -> active_tc . PC = tmp ; break ; \n case 72 : \n break ; \n default : \n if ( n > 89 ) \n return 0 ; \n break ; \n } \n return sizeof ( target_ulong ) ; \n }", "idx": 2913}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "QEMUBH * aio_bh_new ( AioContext * ctx , QEMUBHFunc * cb , void * opaque ) \n { \n QEMUBH * bh ; \n bh = g_malloc0 ( sizeof ( QEMUBH ) ) ; \n bh -> ctx = ctx ; \n bh -> cb = cb ; \n bh -> opaque = opaque ; \n qemu_mutex_lock ( & ctx -> bh_lock ) ; \n bh -> next = ctx -> first_bh ; \n smp_wmb ( ) ; \n ctx -> first_bh = bh ; \n qemu_mutex_unlock ( & ctx -> bh_lock ) ; \n return bh ; \n }", "idx": 2914}
{"project": "qemu", "commit_id": "d22b2f41c470067758b3636a01b452dfeda7069f", "target": 1, "func": "void bdrv_delete ( BlockDriverState * bs ) \n { \n assert ( ! bs -> peer ) ; \n if ( bs -> device_name [ 0 ] != ' \\0 ' ) { \n QTAILQ_REMOVE ( & bdrv_states , bs , list ) ; \n } \n bdrv_close ( bs ) ; \n if ( bs -> file != NULL ) { \n bdrv_delete ( bs -> file ) ; \n } \n assert ( bs != bs_snapshots ) ; \n qemu_free ( bs ) ; \n }", "idx": 2958}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb ( void * opaque ) \n { \n MigrationStatus * status = opaque ; \n MigrationInfo * info ; \n info = qmp_query_migrate ( NULL ) ; \n if ( ! info -> has_status || strcmp ( info -> status , \" \" ) == 0 ) { \n if ( info -> has_disk ) { \n int progress ; \n if ( info -> disk -> remaining ) { \n progress = info -> disk -> transferred * 100 / info -> disk -> total ; \n } else { \n progress = 100 ; \n } \n monitor_printf ( status -> mon , \" \\r \" , progress ) ; \n monitor_flush ( status -> mon ) ; \n } \n timer_mod ( status -> timer , qemu_clock_get_ms ( QEMU_CLOCK_REALTIME ) + 1000 ) ; \n } else { \n if ( status -> is_block_migration ) { \n monitor_printf ( status -> mon , \" \\n \" ) ; \n } \n monitor_resume ( status -> mon ) ; \n timer_del ( status -> timer ) ; \n g_free ( status ) ; \n } \n qapi_free_MigrationInfo ( info ) ; \n }", "idx": 2967}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus ( int code , void * addr ) \n { \n #ifdef KVM_CAP_MCE \n if ( ( first_cpu -> mcg_cap & MCG_SER_P ) && addr && code == BUS_MCEERR_AO ) { \n void * vaddr ; \n ram_addr_t ram_addr ; \n target_phys_addr_t paddr ; \n vaddr = addr ; \n if ( qemu_ram_addr_from_host ( vaddr , & ram_addr ) || \n ! kvm_physical_memory_addr_from_ram ( first_cpu -> kvm_state , ram_addr , \n & paddr ) ) { \n fprintf ( stderr , \" \" \n \" \\n \" , addr ) ; \n return 0 ; \n } \n kvm_mce_inj_srao_memscrub2 ( first_cpu , paddr ) ; \n } else \n #endif \n { \n if ( code == BUS_MCEERR_AO ) { \n return 0 ; \n } else if ( code == BUS_MCEERR_AR ) { \n hardware_memory_error ( ) ; \n } else { \n return 1 ; \n } \n } \n return 0 ; \n }", "idx": 2996}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault ( CPUState * cs , vaddr address , int rw , \n int mmu_idx ) \n { \n MIPSCPU * cpu = MIPS_CPU ( cs ) ; \n CPUMIPSState * env = & cpu -> env ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  hwaddr physical ; \n int prot ; \n int access_type ; \n #endif \n int ret = 0 ; \n #if 0  \n  \n  log_cpu_state ( cs , 0 ) ; \n #endif \n qemu_log_mask ( CPU_LOG_MMU , \n \" \" TARGET_FMT_lx \" \" VADDR_PRIx \" \\n \" , \n __func__ , env -> active_tc . PC , address , rw , mmu_idx ) ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  \n  access_type = ACCESS_INT ; \n ret = get_physical_address ( env , & physical , & prot , \n address , rw , access_type ) ; \n qemu_log_mask ( CPU_LOG_MMU , \n \" \" VADDR_PRIx \" \" TARGET_FMT_plx \n \" \\n \" , \n __func__ , address , ret , physical , prot ) ; \n if ( ret == TLBRET_MATCH ) { \n tlb_set_page ( cs , address & TARGET_PAGE_MASK , \n physical & TARGET_PAGE_MASK , prot | PAGE_EXEC , \n mmu_idx , TARGET_PAGE_SIZE ) ; \n ret = 0 ; \n } else if ( ret < 0 )  \n #endif \n { \n raise_mmu_exception ( env , address , rw , ret ) ; \n ret = 1 ; \n } \n return ret ; \n }", "idx": 3003}
{"project": "qemu", "commit_id": "e26110cfc67d48331a76e9b1e6f7fed7569e1ab3", "target": 0, "func": "static ModuleTypeList * find_type ( module_init_type type ) \n { \n ModuleTypeList * l ; \n init_types ( ) ; \n l = & init_type_list [ type ] ; \n return l ; \n }", "idx": 3020}
{"project": "qemu", "commit_id": "8bd7f71d794b93ce027b856f5b79a98f4f82e44c", "target": 0, "func": "static int qemu_suspend_requested ( void ) \n { \n int r = suspend_requested ; \n suspend_requested = 0 ; \n return r ; \n }", "idx": 3040}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done ( void * opaque ) \n { \n SerialState * s = opaque ; \n if ( s -> tx_burst < 0 ) { \n uint16_t divider ; \n if ( s -> divider ) \n divider = s -> divider ; \n else \n divider = 1 ; \n s -> tx_burst = THROTTLE_TX_INTERVAL * 1000 / \n ( 1000000 * 10 / ( s -> baudbase / divider ) ) ; \n } \n s -> thr_ipending = 1 ; \n s -> lsr |= UART_LSR_THRE ; \n s -> lsr |= UART_LSR_TEMT ; \n serial_update_irq ( s ) ; \n }", "idx": 3070}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary ( SimpleSpiceDisplay * ssd ) \n { \n QXLDevSurfaceCreate surface ; \n memset ( & surface , 0 , sizeof ( surface ) ) ; \n dprint ( 1 , \" \\n \" , __func__ , ssd -> qxl . id , \n surface_width ( ssd -> ds ) , surface_height ( ssd -> ds ) ) ; \n surface . format = SPICE_SURFACE_FMT_32_xRGB ; \n surface . width = surface_width ( ssd -> ds ) ; \n surface . height = surface_height ( ssd -> ds ) ; \n surface . stride = - surface . width * 4 ; \n surface . mouse_mode = true ; \n surface . flags = 0 ; \n surface . type = 0 ; \n surface . mem = ( uintptr_t ) ssd -> buf ; \n surface . group_id = MEMSLOT_GROUP_HOST ; \n qemu_spice_create_primary_surface ( ssd , 0 , & surface , QXL_SYNC ) ; \n }", "idx": 3076}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750fx ( CPUPPCState * env ) \n { \n gen_spr_ne_601 ( env ) ; \n gen_spr_7xx ( env ) ; \n spr_register ( env , SPR_L2CR , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , NULL , \n 0x00000000 ) ; \n gen_tbl ( env ) ; \n gen_spr_thrm ( env ) ; \n spr_register ( env , SPR_750_THRM4 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID0 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_HID1 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n spr_register ( env , SPR_750FX_HID2 , \" \" , \n SPR_NOACCESS , SPR_NOACCESS , \n & spr_read_generic , & spr_write_generic , \n 0x00000000 ) ; \n gen_low_BATs ( env ) ; \n gen_high_BATs ( env ) ; \n init_excp_7x0 ( env ) ; \n env -> dcache_line_size = 32 ; \n env -> icache_line_size = 32 ; \n ppc6xx_irq_init ( env ) ; \n }", "idx": 3082}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_print_trace_file_status ( FILE * stream , int ( * stream_printf ) ( FILE * stream , const char * fmt , ... ) ) \n { \n stream_printf ( stream , \" \\\" \\\" \\n \" , \n trace_file_name , trace_file_enabled ? \" \" : \" \" ) ; \n }", "idx": 3098}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive ( void * opaque )  \n { \n E1000State * s = opaque ; \n return ( ! ( s -> mac_reg [ RCTL ] & E1000_RCTL_EN ) || \n s -> mac_reg [ RDH ] != s -> mac_reg [ RDT ] ) ; \n }", "idx": 3130}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32 ( uint32_t * q_ptr , uint64_t num , uint32_t den ) \n { \n * q_ptr = num / den ; \n return num % den ; \n }", "idx": 3162}
{"project": "qemu", "commit_id": "0857a06ef784783887e756d4b7b5f874512c506c", "target": 1, "func": "static void gen_check_sr ( DisasContext * dc , uint32_t sr , unsigned access ) \n { \n if ( ! xtensa_option_bits_enabled ( dc -> config , sregnames [ sr ] . opt_bits ) ) { \n if ( sregnames [ sr ] . name ) { \n qemu_log ( \" \\n \" , sregnames [ sr ] . name ) ; \n } else { \n qemu_log ( \" \\n \" , sr ) ; \n } \n gen_exception_cause ( dc , ILLEGAL_INSTRUCTION_CAUSE ) ; \n } else if ( ! ( sregnames [ sr ] . access & access ) ) { \n static const char * const access_text [ ] = { \n [ SR_R ] = \" \" , \n [ SR_W ] = \" \" , \n [ SR_X ] = \" \" , \n } ; \n assert ( access < ARRAY_SIZE ( access_text ) && access_text [ access ] ) ; \n qemu_log ( \" \\n \" , sregnames [ sr ] . name , \n access_text [ access ] ) ; \n gen_exception_cause ( dc , ILLEGAL_INSTRUCTION_CAUSE ) ; \n } \n }", "idx": 3180}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_lswi ( DisasContext * ctx ) \n { \n TCGv t0 ; \n TCGv_i32 t1 , t2 ; \n int nb = NB ( ctx -> opcode ) ; \n int start = rD ( ctx -> opcode ) ; \n int ra = rA ( ctx -> opcode ) ; \n int nr ; \n if ( nb == 0 ) \n nb = 32 ; \n nr = ( nb + 3 ) / 4 ; \n if ( unlikely ( lsw_reg_in_range ( start , nr , ra ) ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_INVAL_LSWX ) ; \n return ; \n } \n gen_set_access_type ( ctx , ACCESS_INT ) ; \n gen_update_nip ( ctx , ctx -> nip - 4 ) ; \n t0 = tcg_temp_new ( ) ; \n gen_addr_register ( ctx , t0 ) ; \n t1 = tcg_const_i32 ( nb ) ; \n t2 = tcg_const_i32 ( start ) ; \n gen_helper_lsw ( cpu_env , t0 , t1 , t2 ) ; \n tcg_temp_free ( t0 ) ; \n tcg_temp_free_i32 ( t1 ) ; \n tcg_temp_free_i32 ( t2 ) ; \n }", "idx": 3182}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER ( shr_cc ) ( CPUM68KState * env , uint32_t val , uint32_t shift ) \n { \n uint64_t temp ; \n uint32_t result ; \n shift &= 63 ; \n temp = ( uint64_t ) val << 32 >> shift ; \n result = temp >> 32 ; \n env -> cc_c = ( temp >> 31 ) & 1 ; \n env -> cc_n = result ; \n env -> cc_z = result ; \n env -> cc_v = 0 ; \n env -> cc_x = shift ? env -> cc_c : env -> cc_x ; \n return result ; \n }", "idx": 3184}
{"project": "qemu", "commit_id": "95ce326e5b47b4b841849f8a2ac7b96d6e204dfb", "target": 1, "func": "static void term_down_char ( void ) \n { \n if ( term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1 ) \n return ; \n if ( term_history [ ++ term_hist_entry ] != NULL ) { \n strcpy ( term_cmd_buf , term_history [ term_hist_entry ] ) ; \n } else { \n term_hist_entry = -1 ; \n } \n term_printf ( \" \\n \" ) ; \n term_print_cmdline ( term_cmd_buf ) ; \n term_cmd_buf_index = term_cmd_buf_size = strlen ( term_cmd_buf ) ; \n }", "idx": 3205}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv ( target_ulong a , target_ulong b ) \n { \n int64_t x0 ; \n int32_t x1 ; \n x0 = ( a & 0xffffffff ) | ( ( int64_t ) ( env -> y ) << 32 ) ; \n x1 = ( b & 0xffffffff ) ; \n if ( x1 == 0 ) { \n raise_exception ( TT_DIV_ZERO ) ; \n } \n x0 = x0 / x1 ; \n if ( ( int32_t ) x0 != x0 ) { \n env -> cc_src2 = 1 ; \n return x0 < 0 ? 0x80000000 : 0x7fffffff ; \n } else { \n env -> cc_src2 = 0 ; \n return x0 ; \n } \n }", "idx": 3228}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_reset ( DeviceState * dev ) \n { \n XHCIState * xhci = XHCI ( dev ) ; \n int i ; \n trace_usb_xhci_reset ( ) ; \n if ( ! ( xhci -> usbsts & USBSTS_HCH ) ) { \n DPRINTF ( \" \\n \" ) ; \n } \n xhci -> usbcmd = 0 ; \n xhci -> usbsts = USBSTS_HCH ; \n xhci -> dnctrl = 0 ; \n xhci -> crcr_low = 0 ; \n xhci -> crcr_high = 0 ; \n xhci -> dcbaap_low = 0 ; \n xhci -> dcbaap_high = 0 ; \n xhci -> config = 0 ; \n for ( i = 0 ; i < xhci -> numslots ; i ++ ) { \n xhci_disable_slot ( xhci , i + 1 ) ; \n } \n for ( i = 0 ; i < xhci -> numports ; i ++ ) { \n xhci_port_update ( xhci -> ports + i , 0 ) ; \n } \n for ( i = 0 ; i < xhci -> numintrs ; i ++ ) { \n xhci -> intr [ i ] . iman = 0 ; \n xhci -> intr [ i ] . imod = 0 ; \n xhci -> intr [ i ] . erstsz = 0 ; \n xhci -> intr [ i ] . erstba_low = 0 ; \n xhci -> intr [ i ] . erstba_high = 0 ; \n xhci -> intr [ i ] . erdp_low = 0 ; \n xhci -> intr [ i ] . erdp_high = 0 ; \n xhci -> intr [ i ] . msix_used = 0 ; \n xhci -> intr [ i ] . er_ep_idx = 0 ; \n xhci -> intr [ i ] . er_pcs = 1 ; \n xhci -> intr [ i ] . er_full = 0 ; \n xhci -> intr [ i ] . ev_buffer_put = 0 ; \n xhci -> intr [ i ] . ev_buffer_get = 0 ; \n } \n xhci -> mfindex_start = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) ; \n xhci_mfwrap_update ( xhci ) ; \n }", "idx": 3236}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr ( uint32_t pvr , ppc_def_t * * def ) \n { \n int i , ret ; \n ret = -1 ; \n * def = NULL ; \n for ( i = 0 ; ppc_defs [ i ] . name != NULL ; i ++ ) { \n if ( ( pvr & ppc_defs [ i ] . pvr_mask ) == \n ( ppc_defs [ i ] . pvr & ppc_defs [ i ] . pvr_mask ) ) { \n * def = & ppc_defs [ i ] ; \n ret = 0 ; \n break ; \n } \n } \n return ret ; \n }", "idx": 3237}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update ( uint32_t T0 ) \n { \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  uint32_t vaddr ; \n uint32_t srs = env -> pregs [ PR_SRS ] ; \n if ( srs != 1 && srs != 2 ) \n return ; \n vaddr = cris_mmu_tlb_latest_update ( env , T0 ) ; \n D ( printf ( \" \\n \" , vaddr , \n env -> sregs [ SFR_R_MM_CAUSE ] & TARGET_PAGE_MASK , T0 ) ) ; \n tlb_flush_page ( env , vaddr ) ; \n #endif \n }", "idx": 3256}
{"project": "qemu", "commit_id": "99fd437dee468609de8218f0eb3b16621fb6a9c9", "target": 0, "func": "static void patch_pcihp ( int slot , uint8_t * ssdt_ptr , uint32_t eject ) \n { \n ssdt_ptr [ ACPI_PCIHP_OFFSET_HEX ] = acpi_get_hex ( slot >> 4 ) ; \n ssdt_ptr [ ACPI_PCIHP_OFFSET_HEX + 1 ] = acpi_get_hex ( slot ) ; \n ssdt_ptr [ ACPI_PCIHP_OFFSET_ID ] = slot ; \n ssdt_ptr [ ACPI_PCIHP_OFFSET_ADR + 2 ] = slot ; \n assert ( ! memcmp ( ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0 , \" \" , 4 ) ) ; \n if ( ! eject ) { \n memcpy ( ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0 , \" \" , 4 ) ; \n } \n }", "idx": 3266}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_instance_init ( Object * obj ) \n { \n object_property_add ( obj , \" \" , \" \" , \n nvme_get_bootindex , \n nvme_set_bootindex , NULL , NULL , NULL ) ; \n object_property_set_int ( obj , -1 , \" \" , NULL ) ; \n }", "idx": 3278}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open ( BlockDriverState * bs , QDict * options , int flags , \n Error * * errp ) \n { \n BDRVBlkverifyState * s = bs -> opaque ; \n QemuOpts * opts ; \n Error * local_err = NULL ; \n int ret ; \n opts = qemu_opts_create ( & runtime_opts , NULL , 0 , & error_abort ) ; \n qemu_opts_absorb_qdict ( opts , options , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n ret = - EINVAL ; \n goto fail ; \n bs -> file = bdrv_open_child ( qemu_opt_get ( opts , \" \" ) , options , \" \" , \n bs , & child_file , false , & local_err ) ; \n if ( local_err ) { \n ret = - EINVAL ; \n error_propagate ( errp , local_err ) ; \n goto fail ; \n s -> test_file = bdrv_open_child ( qemu_opt_get ( opts , \" \" ) , options , \n \" \" , bs , & child_format , false , \n & local_err ) ; \n if ( local_err ) { \n ret = - EINVAL ; \n error_propagate ( errp , local_err ) ; \n goto fail ; \n ret = 0 ; \n fail : \n qemu_opts_del ( opts ) ; \n return ret ;", "idx": 3279}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationState * migrate_get_current ( void ) \n { \n static MigrationState current_migration = { \n . state = MIG_STATE_NONE , \n . bandwidth_limit = MAX_THROTTLE , \n . xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE , \n . mbps = -1 , \n } ; \n return & current_migration ; \n }", "idx": 3320}
{"project": "qemu", "commit_id": "25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0", "target": 1, "func": "qemu_co_sendv_recvv ( int  sockfd , struct  iovec * iov , unsigned iov_cnt , \n size_t offset , size_t bytes , bool do_send ) \n { \n size_t done = 0 ; \n ssize_t ret ; \n while ( done < bytes ) { \n ret = iov_send_recv ( sockfd , iov , \n offset + done , bytes - done , do_send ) ; \n if ( ret > 0 ) { \n done += ret ; \n } else if ( ret < 0 ) { \n if ( errno == EAGAIN ) { \n qemu_coroutine_yield ( ) ; \n } else if ( done == 0 ) { \n return -1 ; \n } else { \n break ; \n } \n } else if ( ret == 0 && ! do_send ) { \n break ; \n } \n } \n return done ; \n }", "idx": 3322}
{"project": "qemu", "commit_id": "e24e49e6194626e4ec9f1aecce6d6a6847320bce", "target": 1, "func": "static int qcow2_change_backing_file ( BlockDriverState * bs , \n const char * backing_file , const char * backing_fmt ) \n { \n return qcow2_update_ext_header ( bs , backing_file , backing_fmt ) ; \n }", "idx": 3327}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read ( void * opaque ) \n { \n CharDriverState * chr = opaque ; \n MuxDriver * d = chr -> opaque ; \n if ( ( d -> prod - d -> cons ) < MUX_BUFFER_SIZE ) \n return 1 ; \n if ( d -> chr_can_read [ chr -> focus ] ) \n return d -> chr_can_read [ chr -> focus ] ( d -> ext_opaque [ chr -> focus ] ) ; \n return 0 ; \n }", "idx": 3392}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check ( IntelIOMMUState * s ) \n { \n return s -> iq_tail == 0 ; \n }", "idx": 3394}
{"project": "qemu", "commit_id": "2cbe2de5454cf9af44b620b2b40d56361a12a45f", "target": 1, "func": "static void virtio_scsi_device_unrealize ( DeviceState * dev , Error * * errp ) \n { \n virtio_scsi_common_unrealize ( dev , errp ) ; \n }", "idx": 3399}
{"project": "qemu", "commit_id": "a27365265cc2fed1178bf25a205e8ee02a9c0caf", "target": 0, "func": "static BlockDriverAIOCB * raw_aio_readv ( BlockDriverState * bs , \n int64_t sector_num , QEMUIOVector * qiov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n BDRVRawState * s = bs -> opaque ; \n return paio_submit ( bs , s -> hfile , sector_num , qiov , nb_sectors , \n cb , opaque , QEMU_AIO_READ ) ; \n }", "idx": 3440}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel ( void * opaque , hwaddr addr , \n uint64_t val , unsigned size ) \n { \n TCXState * s = opaque ; \n uint32_t adsr , len ; \n int i ; \n if ( ! ( addr & 4 ) ) { \n s -> tmpblit = val ; \n } else { \n addr = ( addr >> 3 ) & 0xfffff ; \n adsr = val & 0xffffff ; \n len = ( ( val >> 24 ) & 0x1f ) + 1 ; \n if ( adsr == 0xffffff ) { \n memset ( & s -> vram [ addr ] , s -> tmpblit , len ) ; \n if ( s -> depth == 24 ) { \n val = s -> tmpblit & 0xffffff ; \n val = cpu_to_be32 ( val ) ; \n for ( i = 0 ; i < len ; i ++ ) { \n s -> vram24 [ addr + i ] = val ; \n } \n } \n } else { \n memcpy ( & s -> vram [ addr ] , & s -> vram [ adsr ] , len ) ; \n if ( s -> depth == 24 ) { \n memcpy ( & s -> vram24 [ addr ] , & s -> vram24 [ adsr ] , len * 4 ) ; \n } \n } \n memory_region_set_dirty ( & s -> vram_mem , addr , len ) ; \n } \n }", "idx": 3449}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static uint64_t icp_pit_read ( void * opaque , target_phys_addr_t offset , \n unsigned size ) \n { \n icp_pit_state * s = ( icp_pit_state * ) opaque ; \n int n ; \n n = offset >> 8 ; \n if ( n > 3 ) { \n hw_error ( \" \\n \" , n ) ; \n } \n return arm_timer_read ( s -> timer [ n ] , offset & 0xff ) ; \n }", "idx": 3484}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_o ( DisasContext * s , TCGv reg ) \n { \n gen_compute_eflags ( s ) ; \n tcg_gen_shri_tl ( reg , cpu_cc_src , 11 ) ; \n tcg_gen_andi_tl ( reg , reg , 1 ) ; \n }", "idx": 3513}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static void bonito_ldma_writel ( void * opaque , hwaddr addr , \n uint64_t val , unsigned size ) \n { \n PCIBonitoState * s = opaque ; \n ( ( uint32_t * ) ( & s -> bonldma ) ) [ addr / sizeof ( uint32_t ) ] = val & 0xffffffff ; ", "idx": 3555}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init ( ObjectClass * klass , void * data ) \n { \n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ; \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n k -> init = raven_init ; \n k -> vendor_id = PCI_VENDOR_ID_MOTOROLA ; \n k -> device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN ; \n k -> revision = 0x00 ; \n k -> class_id = PCI_CLASS_BRIDGE_HOST ; \n dc -> desc = \" \" ; \n dc -> vmsd = & vmstate_raven ; \n dc -> no_user = 1 ; \n }", "idx": 3598}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char * spapr_phb_vfio_get_loc_code ( sPAPRPHBState * sphb , PCIDevice * pdev ) \n { \n char * path = NULL , * buf = NULL , * host = NULL ; \n host = object_property_get_str ( OBJECT ( pdev ) , \" \" , NULL ) ; \n if ( ! host ) { \n goto err_out ; \n } \n path = g_strdup_printf ( \" \" , host ) ; \n g_free ( host ) ; \n if ( ! path || ! g_file_get_contents ( path , & buf , NULL , NULL ) ) { \n goto err_out ; \n } \n g_free ( path ) ; \n path = g_strdup_printf ( \" \" , buf ) ; \n g_free ( buf ) ; \n if ( ! path || ! g_file_get_contents ( path , & buf , NULL , NULL ) ) { \n goto err_out ; \n } \n return buf ; \n err_out : \n g_free ( path ) ; \n return NULL ; \n }", "idx": 3611}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static void nvme_process_db ( NvmeCtrl * n , hwaddr addr , int val ) \n { \n uint32_t qid ; \n if ( addr & ( ( 1 << 2 ) - 1 ) ) { \n return ; \n } \n if ( ( ( addr - 0x1000 ) >> 2 ) & 1 ) { \n uint16_t new_head = val & 0xffff ; \n int start_sqs ; \n NvmeCQueue * cq ; \n qid = ( addr - ( 0x1000 + ( 1 << 2 ) ) ) >> 3 ; \n if ( nvme_check_cqid ( n , qid ) ) { \n return ; \n } \n cq = n -> cq [ qid ] ; \n if ( new_head >= cq -> size ) { \n return ; \n } \n start_sqs = nvme_cq_full ( cq ) ? 1 : 0 ; \n cq -> head = new_head ; \n if ( start_sqs ) { \n NvmeSQueue * sq ; \n QTAILQ_FOREACH ( sq , & cq -> sq_list , entry )  { \n timer_mod ( sq -> timer , qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) + 500 ) ; \n } \n timer_mod ( cq -> timer , qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) + 500 ) ; \n } \n if ( cq -> tail != cq -> head ) { \n nvme_isr_notify ( n , cq ) ; \n } \n } else { \n uint16_t new_tail = val & 0xffff ; \n NvmeSQueue * sq ; \n qid = ( addr - 0x1000 ) >> 3 ; \n if ( nvme_check_sqid ( n , qid ) ) { \n return ; \n } \n sq = n -> sq [ qid ] ; \n if ( new_tail >= sq -> size ) { \n return ; \n } \n sq -> tail = new_tail ; \n timer_mod ( sq -> timer , qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) + 500 ) ; \n } \n }", "idx": 3634}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg ( DisasContext * s , int rlow , int rhigh , TCGv_i64 val ) \n { \n TCGv tmp ; \n tmp = new_tmp ( ) ; \n tcg_gen_trunc_i64_i32 ( tmp , val ) ; \n store_reg ( s , rlow , tmp ) ; \n tmp = new_tmp ( ) ; \n tcg_gen_shri_i64 ( val , val , 32 ) ; \n tcg_gen_trunc_i64_i32 ( tmp , val ) ; \n store_reg ( s , rhigh , tmp ) ; \n }", "idx": 3681}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_bulk_in_copy_to_guest ( USBCCIDState * s , uint8_t * data , int len ) \n { \n int ret = 0 ; \n assert ( len > 0 ) ; \n ccid_bulk_in_get ( s ) ; \n if ( s -> current_bulk_in != NULL ) { \n ret = MIN ( s -> current_bulk_in -> len - s -> current_bulk_in -> pos , len ) ; \n memcpy ( data , s -> current_bulk_in -> data + s -> current_bulk_in -> pos , ret ) ; \n s -> current_bulk_in -> pos += ret ; \n if ( s -> current_bulk_in -> pos == s -> current_bulk_in -> len ) { \n ccid_bulk_in_release ( s ) ; \n } \n } else { \n ret = USB_RET_NAK ; \n } \n if ( ret > 0 ) { \n DPRINTF ( s , D_MORE_INFO , \n \" \\n \" , __func__ , len , ret ) ; \n } \n if ( ret != USB_RET_NAK && ret < len ) { \n DPRINTF ( s , 1 , \n \" \\n \" , __func__ , ret , len ) ; \n } \n return ret ; \n }", "idx": 3691}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info ( struct audio_pcm_info * info , audsettings_t * as ) \n { \n int bits = 8 , sign = 0 , shift = 0 ; \n switch ( as -> fmt ) { \n case AUD_FMT_S8 : \n sign = 1 ; \n case AUD_FMT_U8 : \n break ; \n case AUD_FMT_S16 : \n sign = 1 ; \n case AUD_FMT_U16 : \n bits = 16 ; \n shift = 1 ; \n break ; \n case AUD_FMT_S32 : \n sign = 1 ; \n case AUD_FMT_U32 : \n bits = 32 ; \n shift = 2 ; \n break ; \n } \n info -> freq = as -> freq ; \n info -> bits = bits ; \n info -> sign = sign ; \n info -> nchannels = as -> nchannels ; \n info -> shift = ( as -> nchannels == 2 ) + shift ; \n info -> align = ( 1 << info -> shift ) - 1 ; \n info -> bytes_per_second = info -> freq << info -> shift ; \n info -> swap_endianness = ( as -> endianness != AUDIO_HOST_ENDIANNESS ) ; \n }", "idx": 3755}
{"project": "qemu", "commit_id": "4fb588e95bacb770746cc794ef165fd71a4d27ea", "target": 0, "func": "static void block_job_completed_txn_abort ( BlockJob * job ) \n { \n AioContext * ctx ; \n BlockJobTxn * txn = job -> txn ; \n BlockJob * other_job , * next ; \n if ( txn -> aborting ) { \n return ; \n } \n txn -> aborting = true ; \n QLIST_FOREACH ( other_job , & txn -> jobs , txn_list )  { \n ctx = blk_get_aio_context ( other_job -> blk ) ; \n aio_context_acquire ( ctx ) ; \n } \n QLIST_FOREACH ( other_job , & txn -> jobs , txn_list )  { \n if ( other_job == job || other_job -> completed ) { \n if ( other_job != job ) { \n block_job_cancel_async ( other_job ) ; \n } \n continue ; \n } \n block_job_cancel_sync ( other_job ) ; \n assert ( other_job -> completed ) ; \n } \n QLIST_FOREACH_SAFE ( other_job , & txn -> jobs , txn_list , next )  { \n ctx = blk_get_aio_context ( other_job -> blk ) ; \n block_job_completed_single ( other_job ) ; \n aio_context_release ( ctx ) ; \n } \n }", "idx": 3763}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup ( MemoryRegion * mr , target_phys_addr_t size ) \n { \n memory_region_init_io ( mr , & isa_mmio_ops , NULL , \" \" , size ) ; \n }", "idx": 3766}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync ( QIOChannelSocket * ioc , \n SocketAddressLegacy * localAddr , \n SocketAddressLegacy * remoteAddr , \n Error * * errp ) \n { \n int fd ; \n trace_qio_channel_socket_dgram_sync ( ioc , localAddr , remoteAddr ) ; \n fd = socket_dgram ( remoteAddr , localAddr , errp ) ; \n if ( fd < 0 ) { \n trace_qio_channel_socket_dgram_fail ( ioc ) ; \n return -1 ; \n } \n trace_qio_channel_socket_dgram_complete ( ioc , fd ) ; \n if ( qio_channel_socket_set_fd ( ioc , fd , errp ) < 0 ) { \n close ( fd ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 3770}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "int memory_region_get_fd ( MemoryRegion * mr ) \n { \n if ( mr -> alias ) { \n return memory_region_get_fd ( mr -> alias ) ; \n } \n assert ( mr -> terminates ) ; \n return qemu_get_ram_fd ( mr -> ram_addr & TARGET_PAGE_MASK ) ; \n }", "idx": 3795}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3314 ( TCGContext * s , AArch64Insn insn , \n TCGReg r1 , TCGReg r2 , TCGReg rn , \n tcg_target_long ofs , bool pre , bool w ) \n { \n insn |= 1u << 31 ; \n insn |= pre << 24 ; \n insn |= w << 23 ; \n assert ( ofs >= -0x200 && ofs < 0x200 && ( ofs & 7 ) == 0 ) ; \n insn |= ( ofs & ( 0x7f << 3 ) ) << ( 15 - 3 ) ; \n tcg_out32 ( s , insn | r2 << 10 | rn << 5 | r1 ) ; \n }", "idx": 3811}
{"project": "qemu", "commit_id": "2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590", "target": 0, "func": "static void x86_cpuid_set_tsc_freq ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n X86CPU * cpu = X86_CPU ( obj ) ; \n const int64_t min = 0 ; \n const int64_t max = INT_MAX ; \n int64_t value ; \n visit_type_int ( v , & value , name , errp ) ; \n if ( error_is_set ( errp ) ) { \n return ; \n } \n if ( value < min || value > max ) { \n error_set ( errp , QERR_PROPERTY_VALUE_OUT_OF_RANGE , \" \" , \n name ? name : \" \" , value , min , max ) ; \n return ; \n } \n cpu -> env . tsc_khz = value / 1000 ; \n }", "idx": 3815}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_mr ( DisasContext * dc ) \n { \n int memsize = memsize_zz ( dc ) ; \n int insn_len ; \n DIS ( fprintf ( logfile , \" \\n \" , \n memsize_char ( memsize ) , \n dc -> op1 , dc -> postinc ? \" \" : \" \" , \n dc -> op2 ) ) ; \n if ( memsize == 4 ) { \n insn_len = dec_prep_move_m ( dc , 0 , 4 , cpu_R [ dc -> op2 ] ) ; \n cris_cc_mask ( dc , CC_MASK_NZ ) ; \n cris_update_cc_op ( dc , CC_OP_MOVE , 4 ) ; \n cris_update_cc_x ( dc ) ; \n cris_update_result ( dc , cpu_R [ dc -> op2 ] ) ; \n } \n else { \n TCGv t0 ; \n t0 = tcg_temp_new ( TCG_TYPE_TL ) ; \n insn_len = dec_prep_move_m ( dc , 0 , memsize , t0 ) ; \n cris_cc_mask ( dc , CC_MASK_NZ ) ; \n cris_alu ( dc , CC_OP_MOVE , \n cpu_R [ dc -> op2 ] , cpu_R [ dc -> op2 ] , t0 , memsize ) ; \n tcg_temp_free ( t0 ) ; \n } \n do_postinc ( dc , memsize ) ; \n return insn_len ; \n }", "idx": 3834}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn ( ISADevice * dev ) \n { \n RTCState * s = DO_UPCAST ( RTCState , dev , dev ) ; \n int base = 0x70 ; \n int isairq = 8 ; \n isa_init_irq ( dev , & s -> irq , isairq ) ; \n s -> cmos_data [ RTC_REG_A ] = 0x26 ; \n s -> cmos_data [ RTC_REG_B ] = 0x02 ; \n s -> cmos_data [ RTC_REG_C ] = 0x00 ; \n s -> cmos_data [ RTC_REG_D ] = 0x80 ; \n rtc_set_date_from_host ( s ) ; \n s -> periodic_timer = qemu_new_timer ( rtc_clock , rtc_periodic_timer , s ) ; \n #ifdef TARGET_I386 \n if ( rtc_td_hack ) \n s -> coalesced_timer = \n qemu_new_timer ( rtc_clock , rtc_coalesced_timer , s ) ; \n #endif \n s -> second_timer = qemu_new_timer ( rtc_clock , rtc_update_second , s ) ; \n s -> second_timer2 = qemu_new_timer ( rtc_clock , rtc_update_second2 , s ) ; \n s -> next_second_time = \n qemu_get_clock ( rtc_clock ) + ( get_ticks_per_sec ( ) * 99 ) / 100 ; \n qemu_mod_timer ( s -> second_timer2 , s -> next_second_time ) ; \n register_ioport_write ( base , 2 , 1 , cmos_ioport_write , s ) ; \n register_ioport_read ( base , 2 , 1 , cmos_ioport_read , s ) ; \n register_savevm ( \" \" , base , 1 , rtc_save , rtc_load , s ) ; \n #ifdef TARGET_I386 \n if ( rtc_td_hack ) \n register_savevm ( \" \" , base , 1 , rtc_save_td , rtc_load_td , s ) ; \n #endif \n qemu_register_reset ( rtc_reset , s ) ; \n return 0 ; \n }", "idx": 3838}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load ( QEMUFile * f , void * opaque , int version_id ) \n { \n VirtIONet * n = opaque ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( n ) ; \n if ( version_id < 2 || version_id > VIRTIO_NET_VM_VERSION ) \n return - EINVAL ; \n return virtio_load ( vdev , f , version_id ) ; \n }", "idx": 3845}
{"project": "qemu", "commit_id": "9f1963b3f72521f75a549f8afd61b19e7da63c6f", "target": 0, "func": "static int coroutine_fn raw_co_discard ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors ) \n { \n return bdrv_co_discard ( bs -> file -> bs , sector_num , nb_sectors ) ; \n }", "idx": 3920}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB * bdrv_aio_write_zeroes ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors , BdrvRequestFlags flags , \n BlockCompletionFunc * cb , void * opaque ) \n { \n trace_bdrv_aio_write_zeroes ( bs , sector_num , nb_sectors , flags , opaque ) ; \n return bdrv_co_aio_rw_vector ( bs , sector_num , NULL , nb_sectors , \n BDRV_REQ_ZERO_WRITE | flags , \n cb , opaque , true ) ; \n }", "idx": 3924}
{"project": "qemu", "commit_id": "25db9ebe15125deb32958c6df74996f745edf1f9", "target": 0, "func": "static void virtio_pci_reset ( DeviceState * d ) \n { \n VirtIOPCIProxy * proxy = container_of ( d , VirtIOPCIProxy , pci_dev . qdev ) ; \n virtio_reset ( proxy -> vdev ) ; \n msix_reset ( & proxy -> pci_dev ) ; \n proxy -> flags = 0 ; \n }", "idx": 3926}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIK ( TCGContext * s , int cond , int opc , int opinv , \n TCGReg dst , TCGReg lhs , TCGArg rhs , \n bool rhs_is_const ) \n { \n if ( rhs_is_const ) { \n int rot = encode_imm ( rhs ) ; \n if ( rot < 0 ) { \n rhs = ~ rhs ; \n rot = encode_imm ( rhs ) ; \n assert ( rot >= 0 ) ; \n opc = opinv ; \n } \n tcg_out_dat_imm ( s , cond , opc , dst , lhs , rotl ( rhs , rot ) | ( rot << 7 ) ) ; \n } else { \n tcg_out_dat_reg ( s , cond , opc , dst , lhs , rhs , SHIFT_IMM_LSL ( 0 ) ) ; \n } \n }", "idx": 3933}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int twl92230_init ( i2c_slave * i2c ) \n { \n MenelausState * s = FROM_I2C_SLAVE ( MenelausState , i2c ) ; \n s -> rtc . hz_tm = qemu_new_timer ( rt_clock , menelaus_rtc_hz , s ) ; \n qdev_init_gpio_out ( & i2c -> qdev , s -> out , 4 ) ; \n qdev_init_gpio_in ( & i2c -> qdev , menelaus_gpio_set , 3 ) ; \n s -> pwrbtn = qemu_allocate_irqs ( menelaus_pwrbtn_set , s , 1 ) [ 0 ] ; \n menelaus_reset ( & s -> i2c ) ; \n return 0 ; \n }", "idx": 3946}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond ( DisasContext * ctx , uint32_t opc , int rt , \n int base , int16_t offset ) \n { \n const char * opn = \" \" ; \n TCGv t0 , t1 ; \n t0 = tcg_temp_local_new ( ) ; \n gen_base_offset_addr ( ctx , t0 , base , offset ) ; \n t1 = tcg_temp_local_new ( ) ; \n gen_load_gpr ( t1 , rt ) ; \n switch ( opc ) { \n #if defined ( TARGET_MIPS64 )  \n  \n  case OPC_SCD : \n save_cpu_state ( ctx , 0 ) ; \n op_st_scd ( t1 , t0 , rt , ctx ) ; \n opn = \" \" ; \n break ; \n #endif \n case OPC_SC : \n save_cpu_state ( ctx , 1 ) ; \n op_st_sc ( t1 , t0 , rt , ctx ) ; \n opn = \" \" ; \n break ; \n } \n ( void ) opn ; \n MIPS_DEBUG ( \" \" , opn , regnames [ rt ] , offset , regnames [ base ] ) ; \n tcg_temp_free ( t1 ) ; \n tcg_temp_free ( t0 ) ; \n }", "idx": 3960}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf ( IDEDMA * dma , int is_write ) \n { \n BMDMAState * bm = DO_UPCAST ( BMDMAState , dma , dma ) ; \n IDEState * s = bmdma_active_if ( bm ) ; \n PCIDevice * pci_dev = PCI_DEVICE ( bm -> pci_dev ) ; \n struct { \n uint32_t addr ; \n uint32_t size ; \n } prd ; \n int l , len ; \n pci_dma_sglist_init ( & s -> sg , pci_dev , \n s -> nsector / ( BMDMA_PAGE_SIZE / 512 ) + 1 ) ; \n s -> io_buffer_size = 0 ; \n for ( ; ; ) { \n if ( bm -> cur_prd_len == 0 ) { \n if ( bm -> cur_prd_last || \n ( bm -> cur_addr - bm -> addr ) >= BMDMA_PAGE_SIZE ) { \n return s -> io_buffer_size ; \n } \n pci_dma_read ( pci_dev , bm -> cur_addr , & prd , 8 ) ; \n bm -> cur_addr += 8 ; \n prd . addr = le32_to_cpu ( prd . addr ) ; \n prd . size = le32_to_cpu ( prd . size ) ; \n len = prd . size & 0xfffe ; \n if ( len == 0 ) \n len = 0x10000 ; \n bm -> cur_prd_len = len ; \n bm -> cur_prd_addr = prd . addr ; \n bm -> cur_prd_last = ( prd . size & 0x80000000 ) ; \n } \n l = bm -> cur_prd_len ; \n if ( l > 0 ) { \n qemu_sglist_add ( & s -> sg , bm -> cur_prd_addr , l ) ; \n if ( s -> sg . size > INT32_MAX ) { \n error_report ( \" \" ) ; \n break ; \n } \n bm -> cur_prd_addr += l ; \n bm -> cur_prd_len -= l ; \n s -> io_buffer_size += l ; \n } \n } \n qemu_sglist_destroy ( & s -> sg ) ; \n s -> io_buffer_size = 0 ; \n return -1 ; \n }", "idx": 3970}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl ( unsigned long l ) \n { \n return BITS_PER_LONG == 32 ? ctpop32 ( l ) : ctpop64 ( l ) ; \n }", "idx": 3977}
{"project": "qemu", "commit_id": "c641483fbe0aa08cd7c0580d019dc2d5a7e71138", "target": 1, "func": "static inline void ide_dma_submit_check ( IDEState * s , \n BlockDriverCompletionFunc * dma_cb ) \n { \n if ( s -> bus -> dma -> aiocb ) \n return ; \n dma_cb ( s , -1 ) ; \n }", "idx": 3988}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static BlockStats * bdrv_query_bds_stats ( const BlockDriverState * bs , \n bool query_backing ) \n { \n BlockStats * s = NULL ; \n s = g_malloc0 ( sizeof ( * s ) ) ; \n s -> stats = g_malloc0 ( sizeof ( * s -> stats ) ) ; \n if ( ! bs ) { \n return s ; \n } \n if ( bdrv_get_node_name ( bs ) [ 0 ] ) { \n s -> has_node_name = true ; \n s -> node_name = g_strdup ( bdrv_get_node_name ( bs ) ) ; \n } \n s -> stats -> wr_highest_offset = stat64_get ( & bs -> wr_highest_offset ) ; \n if ( bs -> file ) { \n s -> has_parent = true ; \n s -> parent = bdrv_query_bds_stats ( bs -> file -> bs , query_backing ) ; \n } \n if ( query_backing && bs -> backing ) { \n s -> has_backing = true ; \n s -> backing = bdrv_query_bds_stats ( bs -> backing -> bs , query_backing ) ; \n } \n return s ; \n }", "idx": 4006}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry ( L2TableCache * l2_cache , CachedL2Table * l2_table ) \n { \n CachedL2Table * entry ; \n entry = qed_find_l2_cache_entry ( l2_cache , l2_table -> offset ) ; \n if ( entry ) { \n qed_unref_l2_cache_entry ( entry ) ; \n qed_unref_l2_cache_entry ( l2_table ) ; \n return ; \n } \n if ( l2_cache -> n_entries >= MAX_L2_CACHE_SIZE ) { \n entry = QTAILQ_FIRST ( & l2_cache -> entries ) ; \n QTAILQ_REMOVE ( & l2_cache -> entries , entry , node ) ; \n l2_cache -> n_entries -- ; \n qed_unref_l2_cache_entry ( entry ) ; \n } \n l2_cache -> n_entries ++ ; \n QTAILQ_INSERT_TAIL ( & l2_cache -> entries , l2_table , node ) ; \n }", "idx": 4080}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice * usb_net_init ( const char * cmdline ) \n { \n USBDevice * dev ; \n QemuOpts * opts ; \n int idx ; \n opts = qemu_opts_parse ( & qemu_net_opts , cmdline , NULL ) ; \n if ( ! opts ) { \n qemu_opt_set ( opts , \" \" , \" \" ) ; \n qemu_opt_set ( opts , \" \" , \" \" ) ; \n idx = net_client_init ( NULL , opts , 0 ) ; \n if ( idx == -1 ) { \n dev = usb_create ( NULL \n , \" \" ) ; \n qdev_set_nic_properties ( & dev -> qdev , & nd_table [ idx ] ) ; \n qdev_init_nofail ( & dev -> qdev ) ; \n return dev ;", "idx": 4093}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void handle_mousewheel ( SDL_Event * ev ) \n { \n struct sdl2_console * scon = get_scon_from_window ( ev -> key . windowID ) ; \n SDL_MouseWheelEvent * wev = & ev -> wheel ; \n InputButton btn ; \n if ( wev -> y > 0 ) { \n btn = INPUT_BUTTON_WHEEL_UP ; \n } else if ( wev -> y < 0 ) { \n btn = INPUT_BUTTON_WHEEL_DOWN ; \n } else { \n return ; \n } \n qemu_input_queue_btn ( scon -> dcl . con , btn , true ) ; \n qemu_input_event_sync ( ) ; \n qemu_input_queue_btn ( scon -> dcl . con , btn , false ) ; \n qemu_input_event_sync ( ) ; \n }", "idx": 4104}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev ( TestServer * s ) \n { \n QPCIBus * bus ; \n QVirtioPCIDevice * dev ; \n uint32_t features ; \n bus = qpci_init_pc ( NULL ) ; \n g_assert_nonnull ( bus ) ; \n dev = qvirtio_pci_device_find ( bus , VIRTIO_ID_NET ) ; \n g_assert_nonnull ( dev ) ; \n qvirtio_pci_device_enable ( dev ) ; \n qvirtio_reset ( & dev -> vdev ) ; \n qvirtio_set_acknowledge ( & dev -> vdev ) ; \n qvirtio_set_driver ( & dev -> vdev ) ; \n features = qvirtio_get_features ( & dev -> vdev ) ; \n features = features & VIRTIO_NET_F_MAC ; \n qvirtio_set_features ( & dev -> vdev , features ) ; \n qvirtio_set_driver_ok ( & dev -> vdev ) ; \n }", "idx": 4141}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io ( USBDevice * dev , USBPacket * p ) \n { \n MSDState * s = DO_UPCAST ( MSDState , dev , dev ) ; \n scsi_req_cancel ( s -> req ) ; \n }", "idx": 4165}
{"project": "qemu", "commit_id": "92cb05574b7bd489be81f9c58497dc7dfe5d8859", "target": 0, "func": "bool virtio_ipl_disk_is_valid ( void ) \n { \n return blk_cfg . blk_size && ( virtio_disk_is_scsi ( ) || virtio_disk_is_eckd ( ) ) ; \n }", "idx": 4173}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void bdrv_password_cb ( Monitor * mon , const char * password , void * opaque ) \n { \n BlockDriverState * bs = opaque ; \n int ret = 0 ; \n if ( bdrv_set_key ( bs , password ) != 0 ) { \n monitor_printf ( mon , \" \\n \" ) ; \n ret = - EPERM ; \n } \n if ( mon -> password_completion_cb ) \n mon -> password_completion_cb ( mon -> password_opaque , ret ) ; \n monitor_read_command ( mon , 1 ) ; \n }", "idx": 4178}
{"project": "qemu", "commit_id": "e8f1f9db8787be08e0ae3ed5a94da68966dbfff1", "target": 0, "func": "void net_host_device_remove ( Monitor * mon , int vlan_id , const char * device ) \n { \n VLANState * vlan ; \n VLANClientState * vc ; \n vlan = qemu_find_vlan ( vlan_id ) ; \n for ( vc = vlan -> first_client ; vc != NULL ; vc = vc -> next ) \n if ( ! strcmp ( vc -> name , device ) ) \n break ; \n if ( ! vc ) { \n monitor_printf ( mon , \" \\n \" , device ) ; \n return ; \n } \n qemu_del_vlan_client ( vc ) ; \n }", "idx": 4209}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static void vfio_bar_write ( void * opaque , hwaddr addr , \n uint64_t data , unsigned size ) \n { \n VFIOBAR * bar = opaque ; \n union { \n uint8_t byte ; \n uint16_t word ; \n uint32_t dword ; \n uint64_t qword ; \n } buf ; \n switch ( size ) { \n case 1 : \n buf . byte = data ; \n break ; \n case 2 : \n buf . word = cpu_to_le16 ( data ) ; \n break ; \n case 4 : \n buf . dword = cpu_to_le32 ( data ) ; \n break ; \n default : \n hw_error ( \" \\n \" , size ) ; \n break ; \n } \n if ( pwrite ( bar -> fd , & buf , size , bar -> fd_offset + addr ) != size ) { \n error_report ( \" \" HWADDR_PRIx \" \" PRIx64 \" \" , \n __func__ , addr , data , size ) ; \n } \n DPRINTF ( \" \" HWADDR_PRIx \" \" PRIx64 \" \\n \" , \n __func__ , bar -> nr , addr , data , size ) ; \n vfio_eoi ( container_of ( bar , VFIODevice , bars [ bar -> nr ] ) ) ; \n }", "idx": 4211}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject * parse_escape ( JSONParserContext * ctxt , va_list * ap ) \n { \n QObject * token ; \n const char * val ; \n if ( ap == NULL ) { \n return NULL ; \n } \n token = parser_context_pop_token ( ctxt ) ; \n assert ( token && token_get_type ( token ) == JSON_ESCAPE ) ; \n val = token_get_value ( token ) ; \n if ( ! strcmp ( val , \" \" ) ) { \n return va_arg ( * ap , QObject * ) ; \n } else if ( ! strcmp ( val , \" \" ) ) { \n return QOBJECT ( qbool_from_bool ( va_arg ( * ap , int ) ) ) ; \n } else if ( ! strcmp ( val , \" \" ) ) { \n return QOBJECT ( qint_from_int ( va_arg ( * ap , int ) ) ) ; \n } else if ( ! strcmp ( val , \" \" ) ) { \n return QOBJECT ( qint_from_int ( va_arg ( * ap , long ) ) ) ; \n } else if ( ! strcmp ( val , \" \" ) || \n ! strcmp ( val , \" \" ) ) { \n return QOBJECT ( qint_from_int ( va_arg ( * ap , long long ) ) ) ; \n } else if ( ! strcmp ( val , \" \" ) ) { \n return QOBJECT ( qstring_from_str ( va_arg ( * ap , const char * ) ) ) ; \n } else if ( ! strcmp ( val , \" \" ) ) { \n return QOBJECT ( qfloat_from_double ( va_arg ( * ap , double ) ) ) ; \n } \n return NULL ; \n }", "idx": 4217}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline uint64_t ldq_phys_internal ( hwaddr addr , \n enum device_endian endian ) \n { \n uint8_t * ptr ; \n uint64_t val ; \n MemoryRegionSection * section ; \n section = phys_page_find ( address_space_memory . dispatch , addr >> TARGET_PAGE_BITS ) ; \n if ( ! ( memory_region_is_ram ( section -> mr ) || \n memory_region_is_romd ( section -> mr ) ) ) { \n addr = memory_region_section_addr ( section , addr ) ; \n #ifdef TARGET_WORDS_BIGENDIAN \n val = io_mem_read ( section -> mr , addr , 4 ) << 32 ; \n val |= io_mem_read ( section -> mr , addr + 4 , 4 ) ; \n #else \n val = io_mem_read ( section -> mr , addr , 4 ) ; \n val |= io_mem_read ( section -> mr , addr + 4 , 4 ) << 32 ; \n #endif \n } else { \n ptr = qemu_get_ram_ptr ( ( memory_region_get_ram_addr ( section -> mr ) \n & TARGET_PAGE_MASK ) \n + memory_region_section_addr ( section , addr ) ) ; \n switch ( endian ) { \n case DEVICE_LITTLE_ENDIAN : \n val = ldq_le_p ( ptr ) ; \n break ; \n case DEVICE_BIG_ENDIAN : \n val = ldq_be_p ( ptr ) ; \n break ; \n default : \n val = ldq_p ( ptr ) ; \n break ; \n } \n } \n return val ; \n }", "idx": 4218}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "func": "void main_loop_wait ( int nonblocking ) \n { \n fd_set rfds , wfds , xfds ; \n int ret , nfds ; \n struct timeval tv ; \n int timeout ; \n if ( nonblocking ) \n timeout = 0 ; \n else { \n timeout = qemu_calculate_timeout ( ) ; \n qemu_bh_update_timeout ( & timeout ) ; \n } \n os_host_main_loop_wait ( & timeout ) ; \n tv . tv_sec = timeout / 1000 ; \n tv . tv_usec = ( timeout % 1000 ) * 1000 ; \n nfds = -1 ; \n FD_ZERO ( & rfds ) ; \n FD_ZERO ( & wfds ) ; \n FD_ZERO ( & xfds ) ; \n qemu_iohandler_fill ( & nfds , & rfds , & wfds , & xfds ) ; \n slirp_select_fill ( & nfds , & rfds , & wfds , & xfds ) ; \n qemu_mutex_unlock_iothread ( ) ; \n ret = select ( nfds + 1 , & rfds , & wfds , & xfds , & tv ) ; \n qemu_mutex_lock_iothread ( ) ; \n qemu_iohandler_poll ( & rfds , & wfds , & xfds , ret ) ; \n slirp_select_poll ( & rfds , & wfds , & xfds , ( ret < 0 ) ) ; \n qemu_run_all_timers ( ) ; \n qemu_bh_poll ( ) ; \n }", "idx": 4221}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all ( Error * * errp ) \n { \n BlockDriverState * bs ; \n Error * local_err = NULL ; \n BdrvNextIterator * it = NULL ; \n while ( ( it = bdrv_next ( it , & bs ) ) != NULL ) { \n AioContext * aio_context = bdrv_get_aio_context ( bs ) ; \n aio_context_acquire ( aio_context ) ; \n bdrv_invalidate_cache ( bs , & local_err ) ; \n aio_context_release ( aio_context ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n } \n }", "idx": 4253}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject * parse_keyword ( JSONParserContext * ctxt ) \n { \n QObject * token , * ret ; \n JSONParserContext saved_ctxt = parser_context_save ( ctxt ) ; \n token = parser_context_pop_token ( ctxt ) ; \n if ( token == NULL ) { \n goto out ; \n } \n if ( token_get_type ( token ) != JSON_KEYWORD ) { \n goto out ; \n } \n if ( token_is_keyword ( token , \" \" ) ) { \n ret = QOBJECT ( qbool_from_int ( true ) ) ; \n } else if ( token_is_keyword ( token , \" \" ) ) { \n ret = QOBJECT ( qbool_from_int ( false ) ) ; \n } else { \n parse_error ( ctxt , token , \" \" , token_get_value ( token ) ) ; \n goto out ; \n } \n return ret ; \n out : \n parser_context_restore ( ctxt , saved_ctxt ) ; \n return NULL ; \n }", "idx": 4256}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state ( FILE * f ) \n { \n int eflags ; \n char cc_op_name [ 32 ] ; \n eflags = cc_table [ CC_OP ] . compute_all ( ) ; \n eflags |= ( DF & DF_MASK ) ; \n if ( ( unsigned ) env -> cc_op < CC_OP_NB ) \n strcpy ( cc_op_name , cc_op_str [ env -> cc_op ] ) ; \n else \n snprintf ( cc_op_name , sizeof ( cc_op_name ) , \" \" , env -> cc_op ) ; \n fprintf ( f , \n \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" , \n env -> regs [ R_EAX ] , env -> regs [ R_EBX ] , env -> regs [ R_ECX ] , env -> regs [ R_EDX ] , \n env -> regs [ R_ESI ] , env -> regs [ R_EDI ] , env -> regs [ R_EBP ] , env -> regs [ R_ESP ] , \n env -> cc_src , env -> cc_dst , cc_op_name , \n eflags & DF_MASK ? ' ' : ' ' , \n eflags & CC_O ? ' ' : ' ' , \n eflags & CC_S ? ' ' : ' ' , \n eflags & CC_Z ? ' ' : ' ' , \n eflags & CC_A ? ' ' : ' ' , \n eflags & CC_P ? ' ' : ' ' , \n eflags & CC_C ? ' ' : ' ' , \n env -> eip ) ; \n #if 1  \n  \n  fprintf ( f , \" \\n \" , \n ( double ) ST0 , ( double ) ST1 , ( double ) ST ( 2 ) , ( double ) ST ( 3 ) ) ; \n #endif \n }", "idx": 4337}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings ( PCII440FXState * d ) \n { \n int i , r ; \n uint32_t smram ; \n bool smram_enabled ; \n memory_region_transaction_begin ( ) ; \n update_pam ( d , 0xf0000 , 0x100000 , ( d -> dev . config [ I440FX_PAM ] >> 4 ) & 3 , \n & d -> pam_regions [ 0 ] ) ; \n for ( i = 0 ; i < 12 ; i ++ ) { \n r = ( d -> dev . config [ ( i >> 1 ) + ( I440FX_PAM + 1 ) ] >> ( ( i & 1 ) * 4 ) ) & 3 ; \n update_pam ( d , 0xc0000 + 0x4000 * i , 0xc0000 + 0x4000 * ( i + 1 ) , r , \n & d -> pam_regions [ i + 1 ] ) ; \n } \n smram = d -> dev . config [ I440FX_SMRAM ] ; \n smram_enabled = ( d -> smm_enabled && ( smram & 0x08 ) ) || ( smram & 0x40 ) ; \n memory_region_set_enabled ( & d -> smram_region , ! smram_enabled ) ; \n memory_region_transaction_commit ( ) ; \n }", "idx": 4360}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network ( RDMAControlHeader * control ) \n { \n control -> type = htonl ( control -> type ) ; \n control -> len = htonl ( control -> len ) ; \n control -> repeat = htonl ( control -> repeat ) ; \n }", "idx": 4385}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport ( VirtIOSerial * vser ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( vser ) ; \n return virtio_has_feature ( vdev , VIRTIO_CONSOLE_F_MULTIPORT ) ; \n }", "idx": 4389}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void * memory_region_get_ram_ptr ( MemoryRegion * mr ) \n { \n if ( mr -> alias ) { \n return memory_region_get_ram_ptr ( mr -> alias ) + mr -> alias_offset ; \n } \n assert ( mr -> terminates ) ; \n return qemu_get_ram_ptr ( mr -> ram_addr & TARGET_PAGE_MASK ) ; \n }", "idx": 4440}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_service_interrupt ( S390CPU * cpu , uint32_t parm ) \n { \n kvm_s390_interrupt_internal ( cpu , KVM_S390_INT_SERVICE , parm , 0 , 1 ) ; \n }", "idx": 4488}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_write_tbu ( DisasContext * ctx , int sprn , int gprn ) \n { \n if ( use_icount ) { \n gen_io_start ( ) ; \n } \n gen_helper_store_tbu ( cpu_env , cpu_gpr [ gprn ] ) ; \n if ( use_icount ) { \n gen_io_end ( ) ; \n gen_stop_exception ( ctx ) ; \n } \n }", "idx": 4540}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsnabs ( DisasContext * ctx ) \n { \n if ( unlikely ( ! ctx -> spe_enabled ) ) { \n gen_exception ( ctx , POWERPC_EXCP_APU ) ; \n return ; \n } \n #if defined ( TARGET_PPC64 )  \n  \n  tcg_gen_ori_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x8000000080000000LL ) ; \n #else \n tcg_gen_ori_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x80000000 ) ; \n tcg_gen_ori_tl ( cpu_gprh [ rD ( ctx -> opcode ) ] , cpu_gprh [ rA ( ctx -> opcode ) ] , 0x80000000 ) ; \n #endif \n }", "idx": 4555}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read ( void * opaque , target_phys_addr_t offset , \n unsigned size ) \n { \n IMXTimerGState * s = ( IMXTimerGState * ) opaque ; \n DPRINTF ( \" \" , offset >> 2 ) ; \n switch ( offset >> 2 ) { \n case 0 : \n DPRINTF ( \" \\n \" , s -> cr ) ; \n return s -> cr ; \n case 1 : \n DPRINTF ( \" \\n \" , s -> pr ) ; \n return s -> pr ; \n case 2 : \n DPRINTF ( \" \\n \" , s -> sr ) ; \n return s -> sr ; \n case 3 : \n DPRINTF ( \" \\n \" , s -> ir ) ; \n return s -> ir ; \n case 4 : \n DPRINTF ( \" \\n \" , s -> ocr1 ) ; \n return s -> ocr1 ; \n case 9 : \n imx_timerg_update_counts ( s ) ; \n DPRINTF ( \" \\n \" , s -> cnt ) ; \n return s -> cnt ; \n } \n IPRINTF ( \" \\n \" , \n ( int ) offset >> 2 ) ; \n return 0 ; \n }", "idx": 4556}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_full_negative ( void ) \n { \n const char * str = \" \\t \" ; \n uint64_t res = 999 ; \n int err ; \n err = qemu_strtoull ( str , NULL , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 18446744073709551295LLU ) ; \n }", "idx": 4569}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER ( ucf64_absd ) ( float64 a ) \n { \n return float64_abs ( a ) ; \n }", "idx": 4571}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState * qemu_chr_open_null ( const char * id , \n ChardevBackend * backend , \n ChardevReturn * ret , \n Error * * errp ) \n { \n CharDriverState * chr ; \n ChardevCommon * common = backend -> u . null ; \n chr = qemu_chr_alloc ( common , errp ) ; \n if ( ! chr ) { \n return NULL ; \n } \n chr -> chr_write = null_chr_write ; \n chr -> explicit_be_open = true ; \n return chr ; \n }", "idx": 4607}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue ( CompareState * s , int mode ) \n { \n ConnectionKey key ; \n Packet * pkt = NULL ; \n Connection * conn ; \n if ( mode == PRIMARY_IN ) { \n pkt = packet_new ( s -> pri_rs . buf , \n s -> pri_rs . packet_len , \n s -> pri_rs . vnet_hdr_len ) ; \n } else { \n pkt = packet_new ( s -> sec_rs . buf , \n s -> sec_rs . packet_len , \n s -> sec_rs . vnet_hdr_len ) ; \n } \n if ( parse_packet_early ( pkt ) ) { \n packet_destroy ( pkt , NULL ) ; \n pkt = NULL ; \n return -1 ; \n } \n fill_connection_key ( pkt , & key ) ; \n conn = connection_get ( s -> connection_track_table , \n & key , \n & s -> conn_list ) ; \n if ( ! conn -> processing ) { \n g_queue_push_tail ( & s -> conn_list , conn ) ; \n conn -> processing = true ; \n } \n if ( mode == PRIMARY_IN ) { \n if ( ! colo_insert_packet ( & conn -> primary_list , pkt ) ) { \n error_report ( \" \" \n \" \" ) ; \n } \n } else { \n if ( ! colo_insert_packet ( & conn -> secondary_list , pkt ) ) { \n error_report ( \" \" \n \" \" ) ; \n } \n } \n return 0 ; \n }", "idx": 4609}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave ( CPUState * env ) \n { \n #ifdef KVM_CAP_XSAVE \n int i , r ; \n struct kvm_xsave * xsave ; \n uint16_t cwd , swd , twd , fop ; \n if ( ! kvm_has_xsave ( ) ) \n return kvm_put_fpu ( env ) ; \n xsave = qemu_memalign ( 4096 , sizeof ( struct kvm_xsave ) ) ; \n memset ( xsave , 0 , sizeof ( struct kvm_xsave ) ) ; \n cwd = swd = twd = fop = 0 ; \n swd = env -> fpus & ~ ( 7 << 11 ) ; \n swd |= ( env -> fpstt & 7 ) << 11 ; \n cwd = env -> fpuc ; \n for ( i = 0 ; i < 8 ; ++ i ) \n twd |= ( ! env -> fptags [ i ] ) << i ; \n xsave -> region [ 0 ] = ( uint32_t ) ( swd << 16 ) + cwd ; \n xsave -> region [ 1 ] = ( uint32_t ) ( fop << 16 ) + twd ; \n memcpy ( & xsave -> region [ XSAVE_ST_SPACE ] , env -> fpregs , \n sizeof env -> fpregs ) ; \n memcpy ( & xsave -> region [ XSAVE_XMM_SPACE ] , env -> xmm_regs , \n sizeof env -> xmm_regs ) ; \n xsave -> region [ XSAVE_MXCSR ] = env -> mxcsr ; \n * ( uint64_t * ) & xsave -> region [ XSAVE_XSTATE_BV ] = env -> xstate_bv ; \n memcpy ( & xsave -> region [ XSAVE_YMMH_SPACE ] , env -> ymmh_regs , \n sizeof env -> ymmh_regs ) ; \n r = kvm_vcpu_ioctl ( env , KVM_SET_XSAVE , xsave ) ; \n qemu_free ( xsave ) ; \n return r ; \n #else \n return kvm_put_fpu ( env ) ; \n #endif \n }", "idx": 4615}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_tpm2 ( GArray * table_data , BIOSLinker * linker )  \n { \n Acpi20TPM2 * tpm2_ptr ; \n tpm2_ptr = acpi_data_push ( table_data , sizeof * tpm2_ptr ) ; \n tpm2_ptr -> platform_class = cpu_to_le16 ( TPM2_ACPI_CLASS_CLIENT ) ; \n tpm2_ptr -> control_area_address = cpu_to_le64 ( 0 ) ; \n tpm2_ptr -> start_method = cpu_to_le32 ( TPM2_START_METHOD_MMIO ) ; \n build_header ( linker , table_data , \n ( void * ) tpm2_ptr , \" \" , sizeof ( * tpm2_ptr ) , 4 , NULL , NULL ) ; \n }", "idx": 4645}
{"project": "qemu", "commit_id": "a01aedc8d32e6f5b08a4041b62be3c5fab7a3382", "target": 1, "func": "void object_property_add_bool ( Object * obj , const char * name , \n bool ( * get ) ( Object * , Error * * ) , \n void ( * set ) ( Object * , bool , Error * * ) , \n Error * * errp ) \n { \n BoolProperty * prop = g_malloc0 ( sizeof ( * prop ) ) ; \n prop -> get = get ; \n prop -> set = set ; \n object_property_add ( obj , name , \" \" , \n get ? property_get_bool : NULL , \n set ? property_set_bool : NULL , \n property_release_bool , \n prop , errp ) ; \n }", "idx": 4768}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "void virtio_blk_data_plane_stop ( VirtIOBlockDataPlane * s ) \n { \n if ( ! s -> started ) { \n return ; \n } \n s -> started = false ; \n trace_virtio_blk_data_plane_stop ( s ) ; \n if ( s -> start_bh ) { \n qemu_bh_delete ( s -> start_bh ) ; \n s -> start_bh = NULL ; \n } else { \n event_poll_notify ( & s -> event_poll ) ; \n qemu_thread_join ( & s -> thread ) ; \n } \n ioq_cleanup ( & s -> ioqueue ) ; \n s -> vdev -> binding -> set_host_notifier ( s -> vdev -> binding_opaque , 0 , false ) ; \n event_poll_cleanup ( & s -> event_poll ) ; \n s -> vdev -> binding -> set_guest_notifiers ( s -> vdev -> binding_opaque , 1 , false ) ; \n vring_teardown ( & s -> vring ) ; \n }", "idx": 4770}
{"project": "qemu", "commit_id": "4bb3893908385836410346725dd9e584dcd24836", "target": 0, "func": "uint32_t wm8750_adc_dat ( void * opaque ) \n { \n WM8750State * s = ( WM8750State * ) opaque ; \n uint32_t * data ; \n if ( s -> idx_in >= sizeof ( s -> data_in ) ) \n wm8750_in_load ( s ) ; \n data = ( uint32_t * ) & s -> data_in [ s -> idx_in ] ; \n s -> req_in -= 4 ; \n s -> idx_in += 4 ; \n return * data ; \n }", "idx": 4842}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor * to_qiv ( Visitor * v ) \n { \n return container_of ( v , QmpInputVisitor , visitor ) ; \n }", "idx": 4849}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void bonito_pcihost_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ; \n k -> init = bonito_pcihost_initfn ; \n dc -> no_user = 1 ; \n }", "idx": 4874}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay_all ( MemoryRegion * mr ) \n { \n IOMMUNotifier * notifier ; \n IOMMU_NOTIFIER_FOREACH ( notifier , mr )  { \n memory_region_iommu_replay ( mr , notifier , false ) ; \n } \n }", "idx": 4892}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix3_initfn ( PCIDevice * dev ) \n { \n UHCIState * s = DO_UPCAST ( UHCIState , dev , dev ) ; \n uint8_t * pci_conf = s -> dev . config ; \n pci_config_set_vendor_id ( pci_conf , PCI_VENDOR_ID_INTEL ) ; \n pci_config_set_device_id ( pci_conf , PCI_DEVICE_ID_INTEL_82371SB_2 ) ; \n return usb_uhci_common_initfn ( s ) ; \n }", "idx": 4893}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_r ( DisasContext * dc ) \n { \n TCGv t0 ; \n DIS ( fprintf ( logfile , \" \\n \" , \n memsize_char ( memsize_zz ( dc ) ) , dc -> op2 , dc -> op1 ) ) ; \n cris_cc_mask ( dc , 0 ) ; \n t0 = tcg_temp_new ( TCG_TYPE_TL ) ; \n tcg_gen_shl_tl ( t0 , cpu_R [ dc -> op2 ] , tcg_const_tl ( dc -> zzsize ) ) ; \n tcg_gen_add_tl ( cpu_R [ dc -> op1 ] , cpu_R [ dc -> op1 ] , t0 ) ; \n tcg_temp_free ( t0 ) ; \n return 2 ; \n }", "idx": 4899}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_gpio_read ( void * opaque , hwaddr offset , \n unsigned size ) \n { \n PXA2xxGPIOInfo * s = ( PXA2xxGPIOInfo * ) opaque ; \n uint32_t ret ; \n int bank ; \n if ( offset >= 0x200 ) \n return 0 ; \n bank = pxa2xx_gpio_regs [ offset ] . bank ; \n switch ( pxa2xx_gpio_regs [ offset ] . reg ) { \n case GPDR : \n return s -> dir [ bank ] ; \n case GPSR : \n qemu_log_mask ( LOG_GUEST_ERROR , \n \" \\n \" ) ; \n return 0 ; \n case GPCR : \n qemu_log_mask ( LOG_GUEST_ERROR , \n \" \\n \" ) ; \n return 0 ; \n case GRER : \n return s -> rising [ bank ] ; \n case GFER : \n return s -> falling [ bank ] ; \n case GAFR_L : \n return s -> gafr [ bank * 2 ] ; \n case GAFR_U : \n return s -> gafr [ bank * 2 + 1 ] ; \n case GPLR : \n ret = ( s -> olevel [ bank ] & s -> dir [ bank ] ) | \n ( s -> ilevel [ bank ] & ~ s -> dir [ bank ] ) ; \n qemu_irq_raise ( s -> read_notify ) ; \n return ret ; \n case GEDR : \n return s -> status [ bank ] ; \n default : \n hw_error ( \" \" REG_FMT \" \\n \" , __FUNCTION__ , offset ) ; \n } \n return 0 ; \n }", "idx": 4961}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit ( void * opaque , int64_t new_rate ) \n { \n MigrationState * s = opaque ; \n if ( qemu_file_get_error ( s -> file ) ) { \n goto out ; \n } \n s -> xfer_limit = new_rate ; \n out : \n return s -> xfer_limit ; \n }", "idx": 5035}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_reset ( DeviceState * dev ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev . qdev , dev ) ; \n uint64_t nb_sectors ; \n scsi_device_purge_requests ( & s -> qdev , SENSE_CODE ( RESET ) ) ; \n bdrv_get_geometry ( s -> qdev . conf . bs , & nb_sectors ) ; \n nb_sectors /= s -> qdev . blocksize / 512 ; \n if ( nb_sectors ) { \n nb_sectors -- ; \n } \n s -> qdev . max_lba = nb_sectors ; \n s -> tray_locked = 0 ; \n s -> tray_open = 0 ; \n }", "idx": 5054}
{"project": "qemu", "commit_id": "955cc8c9541779e09895a9c5ccbf8ace15d884f5", "target": 0, "func": "static int virtio_ccw_set_vqs ( SubchDev * sch , uint64_t addr , uint32_t align , \n uint16_t index , uint16_t num ) \n { \n VirtIODevice * vdev = virtio_ccw_get_vdev ( sch ) ; \n if ( index >= VIRTIO_PCI_QUEUE_MAX ) { \n return - EINVAL ; \n } \n if ( addr && ( align != 4096 ) ) { \n return - EINVAL ; \n } \n if ( ! vdev ) { \n return - EINVAL ; \n } \n virtio_queue_set_addr ( vdev , index , addr ) ; \n if ( ! addr ) { \n virtio_queue_set_vector ( vdev , index , 0 ) ; \n } else { \n if ( virtio_queue_get_num ( vdev , index ) > num ) { \n return - EINVAL ; \n } \n virtio_queue_set_vector ( vdev , index , index ) ; \n } \n vdev -> config_vector = VIRTIO_PCI_QUEUE_MAX ; \n return 0 ; \n }", "idx": 5093}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void rtl8139_receive ( void * opaque , const uint8_t * buf , size_t size ) \n { \n rtl8139_do_receive ( opaque , buf , size , 1 ) ; \n }", "idx": 5099}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown ( FsContext * fs_ctx , V9fsPath * fs_path , FsCred * credp ) \n { \n char buffer [ PATH_MAX ] ; \n char * path = fs_path -> data ; \n if ( ( credp -> fc_uid == -1 && credp -> fc_gid == -1 ) || \n ( fs_ctx -> export_flags & V9FS_SM_PASSTHROUGH ) || \n ( fs_ctx -> export_flags & V9FS_SM_NONE ) ) { \n return lchown ( rpath ( fs_ctx , path , buffer ) , \n credp -> fc_uid , credp -> fc_gid ) ; \n } else if ( fs_ctx -> export_flags & V9FS_SM_MAPPED ) { \n return local_set_xattr ( rpath ( fs_ctx , path , buffer ) , credp ) ; \n } else if ( fs_ctx -> export_flags & V9FS_SM_MAPPED_FILE ) { \n return local_set_mapped_file_attr ( fs_ctx , path , credp ) ; \n } \n return -1 ; \n }", "idx": 5102}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefAlternate * tmp ; \n Visitor * v ; \n Error * err = NULL ; \n v = validate_test_init ( data , \" \" ) ; \n visit_type_UserDefAlternate ( v , NULL , & tmp , & err ) ; \n error_free_or_abort ( & err ) ; \n qapi_free_UserDefAlternate ( tmp ) ; \n }", "idx": 5121}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush ( BlockDriverState * bs ) \n { \n BDRVQcowState * s = bs -> opaque ; \n int ret ; \n qemu_co_mutex_lock ( & s -> lock ) ; \n ret = qcow2_cache_flush ( bs , s -> l2_table_cache ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n ret = qcow2_cache_flush ( bs , s -> refcount_block_cache ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return bdrv_co_flush ( bs -> file ) ; \n }", "idx": 5129}
{"project": "qemu", "commit_id": "df8ad9f128c15aa0a0ebc7b24e9a22c9775b67af", "target": 1, "func": "static int nbd_can_accept ( void ) \n { \n return nb_fds < shared ; \n }", "idx": 5171}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint ( CPUSPARCState * env , uint32_t value ) \n { \n if ( env -> softint != value ) { \n env -> softint = value ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  if ( cpu_interrupts_enabled ( env ) ) { \n cpu_check_irqs ( env ) ; \n } \n #endif \n return true ; \n } \n return false ; \n }", "idx": 5174}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key ( const char * string ) \n { \n char keybuf [ 16 ] , * q ; \n uint8_t keycodes [ 16 ] ; \n const char * p ; \n int nb_keycodes , keycode , i ; \n nb_keycodes = 0 ; \n p = string ; \n while ( * p != ' \\0 ' ) { \n q = keybuf ; \n while ( * p != ' \\0 ' && * p != ' ' ) { \n if ( ( q - keybuf ) < sizeof ( keybuf ) - 1 ) { \n * q ++ = * p ; \n } \n p ++ ; \n } \n * q = ' \\0 ' ; \n keycode = get_keycode ( keybuf ) ; \n if ( keycode < 0 ) { \n term_printf ( \" \\n \" , keybuf ) ; \n return ; \n } \n keycodes [ nb_keycodes ++ ] = keycode ; \n if ( * p == ' \\0 ' ) \n break ; \n p ++ ; \n } \n for ( i = 0 ; i < nb_keycodes ; i ++ ) { \n keycode = keycodes [ i ] ; \n if ( keycode & 0x80 ) \n kbd_put_keycode ( 0xe0 ) ; \n kbd_put_keycode ( keycode & 0x7f ) ; \n } \n for ( i = nb_keycodes - 1 ; i >= 0 ; i -- ) { \n keycode = keycodes [ i ] ; \n if ( keycode & 0x80 ) \n kbd_put_keycode ( 0xe0 ) ; \n kbd_put_keycode ( keycode | 0x80 ) ; \n } \n }", "idx": 5191}
{"project": "qemu", "commit_id": "5d39c799c3245244ebb1e89da0177dbc089962b2", "target": 0, "func": "void do_migrate_set_speed ( Monitor * mon , const QDict * qdict , QObject * * ret_data ) \n { \n double d ; \n char * ptr ; \n FdMigrationState * s ; \n const char * value = qdict_get_str ( qdict , \" \" ) ; \n d = strtod ( value , & ptr ) ; \n switch ( * ptr ) { \n case ' ' : case ' ' : \n d *= 1024 ; \n case ' ' : case ' ' : \n d *= 1024 ; \n case ' ' : case ' ' : \n d *= 1024 ; \n default : \n break ; \n } \n max_throttle = ( uint32_t ) d ; \n s = migrate_to_fms ( current_migration ) ; \n if ( s ) { \n qemu_file_set_rate_limit ( s -> file , max_throttle ) ; \n } \n }", "idx": 5198}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdneg ( DisasContext * ctx ) \n { \n if ( unlikely ( ! ctx -> spe_enabled ) ) { \n gen_exception ( ctx , POWERPC_EXCP_APU ) ; \n return ; \n } \n #if defined ( TARGET_PPC64 )  \n  \n  tcg_gen_xori_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] , 0x8000000000000000LL ) ; \n #else \n tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n tcg_gen_xori_tl ( cpu_gprh [ rD ( ctx -> opcode ) ] , cpu_gprh [ rA ( ctx -> opcode ) ] , 0x80000000 ) ; \n #endif \n }", "idx": 5201}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq ( DisasContext * ctx ) \n { \n int l1 = gen_new_label ( ) ; \n int l2 = gen_new_label ( ) ; \n TCGv t0 = tcg_temp_local_new ( ) ; \n TCGv t1 = tcg_temp_local_new ( ) ; \n TCGv t2 = tcg_temp_local_new ( ) ; \n tcg_gen_andi_tl ( t2 , cpu_gpr [ rB ( ctx -> opcode ) ] , 0x1F ) ; \n tcg_gen_movi_tl ( t1 , 0xFFFFFFFF ) ; \n tcg_gen_shr_tl ( t2 , t1 , t2 ) ; \n tcg_gen_andi_tl ( t0 , cpu_gpr [ rB ( ctx -> opcode ) ] , 0x20 ) ; \n tcg_gen_brcondi_tl ( TCG_COND_EQ , t0 , 0 , l1 ) ; \n gen_load_spr ( t0 , SPR_MQ ) ; \n tcg_gen_and_tl ( cpu_gpr [ rA ( ctx -> opcode ) ] , t0 , t2 ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_shr_tl ( t0 , cpu_gpr [ rS ( ctx -> opcode ) ] , t2 ) ; \n tcg_gen_and_tl ( t0 , t0 , t2 ) ; \n gen_load_spr ( t1 , SPR_MQ ) ; \n tcg_gen_andc_tl ( t1 , t1 , t2 ) ; \n tcg_gen_or_tl ( cpu_gpr [ rA ( ctx -> opcode ) ] , t0 , t1 ) ; \n gen_set_label ( l2 ) ; \n tcg_temp_free ( t0 ) ; \n tcg_temp_free ( t1 ) ; \n tcg_temp_free ( t2 ) ; \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) \n gen_set_Rc0 ( ctx , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; \n }", "idx": 5219}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static size_t send_control_msg ( VirtIOSerial * vser , void * buf , size_t len ) \n { \n VirtQueueElement elem ; \n VirtQueue * vq ; \n vq = vser -> c_ivq ; \n if ( ! virtio_queue_ready ( vq ) ) { \n return 0 ; \n } \n if ( ! virtqueue_pop ( vq , & elem ) ) { \n return 0 ; \n } \n iov_from_buf ( elem . in_sg , elem . in_num , 0 , buf , len ) ; \n virtqueue_push ( vq , & elem , len ) ; \n virtio_notify ( VIRTIO_DEVICE ( vser ) , vq ) ; \n return len ; \n }", "idx": 5222}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8 ( void * opaque , target_phys_addr_t addr ) \n { \n uint8_t ret ; \n OMAP_8B_REG ( addr ) ; \n cpu_physical_memory_read ( addr , ( void * ) & ret , 1 ) ; \n return ret ; \n }", "idx": 5250}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit ( IRQ_queue_t * q , int n_IRQ ) \n { \n q -> pending ++ ; \n set_bit ( q -> queue , n_IRQ ) ; \n }", "idx": 5263}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void vhost_log_stop ( MemoryListener * listener , \n MemoryRegionSection * section ) \n { \n }", "idx": 5283}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load ( TCGContext * s , TCGReg addr , int mem_index , \n TCGMemOp s_bits , int which ) \n { \n const TCGReg r0 = TCG_REG_O0 ; \n const TCGReg r1 = TCG_REG_O1 ; \n const TCGReg r2 = TCG_REG_O2 ; \n int tlb_ofs ; \n tcg_out_arithi ( s , r1 , addr , TARGET_PAGE_BITS , SHIFT_SRL ) ; \n tcg_out_movi ( s , TCG_TYPE_TL , TCG_REG_T1 , \n TARGET_PAGE_MASK | ( ( 1 << s_bits ) - 1 ) ) ; \n tcg_out_arithi ( s , r1 , r1 , CPU_TLB_SIZE - 1 , ARITH_AND ) ; \n tcg_out_arith ( s , r0 , addr , TCG_REG_T1 , ARITH_AND ) ; \n tcg_out_arithi ( s , r1 , r1 , CPU_TLB_ENTRY_BITS , SHIFT_SLL ) ; \n tcg_out_arith ( s , r1 , TCG_AREG0 , r1 , ARITH_ADD ) ; \n tlb_ofs = offsetof ( CPUArchState , tlb_table [ mem_index ] [ 0 ] ) ; \n if ( ! check_fit_tl ( tlb_ofs + sizeof ( CPUTLBEntry ) , 13 ) ) { \n tcg_out_addi ( s , r1 , tlb_ofs & ~ 0x3ff ) ; \n tlb_ofs &= 0x3ff ; \n } \n tcg_out_ld ( s , TCG_TYPE_TL , r2 , r1 , tlb_ofs + which ) ; \n tcg_out_ld ( s , TCG_TYPE_PTR , r1 , r1 , tlb_ofs + offsetof ( CPUTLBEntry , addend ) ) ; \n tcg_out_cmp ( s , r0 , r2 , 0 ) ; \n if ( SPARC64 && TARGET_LONG_BITS == 32 ) { \n tcg_out_arithi ( s , r0 , addr , 0 , SHIFT_SRL ) ; \n return r0 ; \n } \n return addr ; \n }", "idx": 5304}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static int curl_sock_cb ( CURL * curl , curl_socket_t fd , int action , \n void * s , void * sp ) \n { \n DPRINTF ( \" \\n \" , action , fd ) ; \n switch ( action ) { \n case CURL_POLL_IN : \n qemu_aio_set_fd_handler ( fd , curl_multi_do , NULL , s ) ; \n break ; \n case CURL_POLL_OUT : \n qemu_aio_set_fd_handler ( fd , NULL , curl_multi_do , s ) ; \n break ; \n case CURL_POLL_INOUT : \n qemu_aio_set_fd_handler ( fd , curl_multi_do , curl_multi_do , s ) ; \n break ; \n case CURL_POLL_REMOVE : \n qemu_aio_set_fd_handler ( fd , NULL , NULL , NULL ) ; \n break ; \n } \n return 0 ; \n }", "idx": 5306}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode ( VncState * vs , VncShareMode mode ) \n { \n #ifdef _VNC_DEBUG \n static const char * mn [ ] = { \n [ 0 ] = \" \" , \n [ VNC_SHARE_MODE_CONNECTING ] = \" \" , \n [ VNC_SHARE_MODE_SHARED ] = \" \" , \n [ VNC_SHARE_MODE_EXCLUSIVE ] = \" \" , \n [ VNC_SHARE_MODE_DISCONNECTED ] = \" \" , \n } ; \n fprintf ( stderr , \" \\n \" , __func__ , \n vs -> csock , mn [ vs -> share_mode ] , mn [ mode ] ) ; \n #endif \n if ( vs -> share_mode == VNC_SHARE_MODE_EXCLUSIVE ) { \n vs -> vd -> num_exclusive -- ; \n } \n vs -> share_mode = mode ; \n if ( vs -> share_mode == VNC_SHARE_MODE_EXCLUSIVE ) { \n vs -> vd -> num_exclusive ++ ; \n } \n }", "idx": 5314}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "func": "void * slavio_intctl_init ( target_phys_addr_t addr , target_phys_addr_t addrg , \n const uint32_t * intbit_to_level , \n qemu_irq * * irq , qemu_irq * * cpu_irq , \n unsigned int cputimer ) \n { \n int slavio_intctl_io_memory , slavio_intctlm_io_memory , i ; \n SLAVIO_INTCTLState * s ; \n s = qemu_mallocz ( sizeof ( SLAVIO_INTCTLState ) ) ; \n if ( ! s ) \n return NULL ; \n s -> intbit_to_level = intbit_to_level ; \n for ( i = 0 ; i < MAX_CPUS ; i ++ ) { \n slavio_intctl_io_memory = cpu_register_io_memory ( 0 , slavio_intctl_mem_read , slavio_intctl_mem_write , s ) ; \n cpu_register_physical_memory ( addr + i * TARGET_PAGE_SIZE , INTCTL_SIZE , \n slavio_intctl_io_memory ) ; \n } \n slavio_intctlm_io_memory = cpu_register_io_memory ( 0 , slavio_intctlm_mem_read , slavio_intctlm_mem_write , s ) ; \n cpu_register_physical_memory ( addrg , INTCTLM_SIZE , slavio_intctlm_io_memory ) ; \n register_savevm ( \" \" , addr , 1 , slavio_intctl_save , slavio_intctl_load , s ) ; \n qemu_register_reset ( slavio_intctl_reset , s ) ; \n * irq = qemu_allocate_irqs ( slavio_set_irq , s , 32 ) ; \n * cpu_irq = qemu_allocate_irqs ( slavio_set_timer_irq_cpu , s , MAX_CPUS ) ; \n s -> cputimer_bit = 1 << s -> intbit_to_level [ cputimer ] ; \n slavio_intctl_reset ( s ) ; \n return s ; \n }", "idx": 5386}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint ( void ) \n { \n ST0 = rint ( ST0 ) ; \n }", "idx": 5408}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped ( struct NetRxPkt * pkt ) \n { \n assert ( pkt ) ; \n return pkt -> vlan_stripped ; \n }", "idx": 5490}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor * validate_test_init_raw ( TestInputVisitorData * data , \n const char * json_string ) \n { \n Visitor * v ; \n data -> obj = qobject_from_json ( json_string ) ; \n g_assert ( data -> obj != NULL ) ; \n data -> qiv = qmp_input_visitor_new_strict ( data -> obj ) ; \n g_assert ( data -> qiv != NULL ) ; \n v = qmp_input_get_visitor ( data -> qiv ) ; \n g_assert ( v != NULL ) ; \n return v ; \n }", "idx": 5500}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket ( const char * path ) \n { \n int sockfd , size ; \n struct sockaddr_un helper ; \n sockfd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; \n if ( sockfd < 0 ) { \n fprintf ( stderr , \" \\n \" , strerror ( errno ) ) ; \n return -1 ; \n } \n strcpy ( helper . sun_path , path ) ; \n helper . sun_family = AF_UNIX ; \n size = strlen ( helper . sun_path ) + sizeof ( helper . sun_family ) ; \n if ( connect ( sockfd , ( struct sockaddr * ) & helper , size ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n unlink ( path ) ; \n return sockfd ; \n }", "idx": 5508}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "func": "void blk_apply_root_state ( BlockBackend * blk , BlockDriverState * bs ) \n { \n bs -> detect_zeroes = blk -> root_state . detect_zeroes ; \n }", "idx": 5581}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static uint64_t megasas_fw_time ( void ) \n { \n struct tm curtime ; \n uint64_t bcd_time ; \n qemu_get_timedate ( & curtime , 0 ) ; \n bcd_time = ( ( uint64_t ) curtime . tm_sec & 0xff ) << 48 | \n ( ( uint64_t ) curtime . tm_min & 0xff ) << 40 | \n ( ( uint64_t ) curtime . tm_hour & 0xff ) << 32 | \n ( ( uint64_t ) curtime . tm_mday & 0xff ) << 24 | \n ( ( uint64_t ) curtime . tm_mon & 0xff ) << 16 | \n ( ( uint64_t ) ( curtime . tm_year + 1900 ) & 0xffff ) ; \n return bcd_time ; \n }", "idx": 5587}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static OfDpaFlow * of_dpa_flow_alloc ( uint64_t cookie ) \n { \n OfDpaFlow * flow ; \n int64_t now = qemu_clock_get_ms ( QEMU_CLOCK_VIRTUAL ) / 1000 ; \n flow = g_new0 ( OfDpaFlow , 1 ) ; \n if ( ! flow ) { \n return NULL ; \n } \n flow -> cookie = cookie ; \n flow -> mask . tbl_id = 0xffffffff ; \n flow -> stats . install_time = flow -> stats . refresh_time = now ; \n return flow ; \n }", "idx": 5607}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject * json_parser_parse_err ( QList * tokens , va_list * ap , Error * * errp ) \n { \n JSONParserContext ctxt = { } ; \n QList * working = qlist_copy ( tokens ) ; \n QObject * result ; \n result = parse_value ( & ctxt , & working , ap ) ; \n QDECREF ( working ) ; \n error_propagate ( errp , ctxt . err ) ; \n return result ; \n }", "idx": 5624}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init ( target_phys_addr_t base , qemu_irq * irqs ) \n { \n pxa2xx_timer_info * s = pxa2xx_timer_init ( base , irqs ) ; \n s -> freq = PXA25X_FREQ ; \n s -> tm4 = NULL ; \n }", "idx": 5646}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length ( SCSICommand * cmd , SCSIDevice * dev , uint8_t * buf ) \n { \n switch ( buf [ 0 ] ) { \n case ERASE_12 : \n case ERASE_16 : \n cmd -> xfer = 0 ; \n break ; \n case READ_6 : \n case READ_REVERSE : \n case RECOVER_BUFFERED_DATA : \n case WRITE_6 : \n cmd -> len = 6 ; \n cmd -> xfer = buf [ 4 ] | ( buf [ 3 ] << 8 ) | ( buf [ 2 ] << 16 ) ; \n if ( buf [ 1 ] & 0x01 ) { \n cmd -> xfer *= dev -> blocksize ; \n } \n break ; \n case READ_16 : \n case READ_REVERSE_16 : \n case VERIFY_16 : \n case WRITE_16 : \n cmd -> len = 16 ; \n cmd -> xfer = buf [ 14 ] | ( buf [ 13 ] << 8 ) | ( buf [ 12 ] << 16 ) ; \n if ( buf [ 1 ] & 0x01 ) { \n cmd -> xfer *= dev -> blocksize ; \n } \n break ; \n case REWIND : \n case LOAD_UNLOAD : \n cmd -> len = 6 ; \n cmd -> xfer = 0 ; \n break ; \n case SPACE_16 : \n cmd -> xfer = buf [ 13 ] | ( buf [ 12 ] << 8 ) ; \n break ; \n case READ_POSITION : \n cmd -> xfer = buf [ 8 ] | ( buf [ 7 ] << 8 ) ; \n break ; \n case FORMAT_UNIT : \n cmd -> xfer = buf [ 4 ] | ( buf [ 3 ] << 8 ) ; \n break ; \n default : \n return scsi_req_length ( cmd , dev , buf ) ; \n } \n return 0 ; \n }", "idx": 5676}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "PCIDevice * pci_nic_init ( NICInfo * nd , const char * default_model , \n const char * default_devaddr ) \n { \n const char * devaddr = nd -> devaddr ? nd -> devaddr : default_devaddr ; \n PCIDevice * pci_dev ; \n DeviceState * dev ; \n int i ; \n i = qemu_check_nic_model_list ( nd , pci_nic_models , default_model ) ; \n pci_dev = pci_create ( pci_nic_names [ i ] , devaddr ) ; \n dev = & pci_dev -> qdev ; \n if ( nd -> id ) \n dev -> id = qemu_strdup ( nd -> id ) ; \n dev -> nd = nd ; \n qdev_init ( dev ) ; \n nd -> private = dev ; \n return pci_dev ; \n }", "idx": 5718}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_tmr_read ( void * opaque , hwaddr addr , unsigned len ) \n { \n OpenPICState * opp = opaque ; \n uint32_t retval = -1 ; \n int idx ; \n DPRINTF ( \" \\n \" , __func__ , addr ) ; \n if ( addr & 0xF ) { \n goto out ; \n } \n idx = ( addr >> 6 ) & 0x3 ; \n if ( addr == 0x0 ) { \n retval = opp -> tifr ; \n goto out ; \n } \n switch ( addr & 0x30 ) { \n case 0x00 : \n retval = opp -> timers [ idx ] . ticc ; \n break ; \n case 0x10 : \n retval = opp -> timers [ idx ] . tibc ; \n break ; \n case 0x20 : \n retval = read_IRQreg_ipvp ( opp , opp -> irq_tim0 + idx ) ; \n break ; \n case 0x30 : \n retval = read_IRQreg_ide ( opp , opp -> irq_tim0 + idx ) ; \n break ; \n } \n out : \n DPRINTF ( \" \\n \" , __func__ , retval ) ; \n return retval ; \n }", "idx": 5797}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "static void gen_exception_insn ( DisasContext * s , int offset , int excp ) \n { \n gen_a64_set_pc_im ( s -> pc - offset ) ; \n gen_exception ( excp ) ; \n s -> is_jmp = DISAS_JUMP ; \n }", "idx": 5810}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict * qmp_dispatch_check_obj ( const QObject * request , Error * * errp ) \n { \n const QDictEntry * ent ; \n const char * arg_name ; \n const QObject * arg_obj ; \n bool has_exec_key = false ; \n QDict * dict = NULL ; \n if ( qobject_type ( request ) != QTYPE_QDICT ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT , \n \" \" ) ; \n return NULL ; \n } \n dict = qobject_to_qdict ( request ) ; \n for ( ent = qdict_first ( dict ) ; ent ; \n ent = qdict_next ( dict , ent ) ) { \n arg_name = qdict_entry_key ( ent ) ; \n arg_obj = qdict_entry_value ( ent ) ; \n if ( ! strcmp ( arg_name , \" \" ) ) { \n if ( qobject_type ( arg_obj ) != QTYPE_QSTRING ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT_MEMBER , \" \" , \n \" \" ) ; \n return NULL ; \n } \n has_exec_key = true ; \n } else if ( strcmp ( arg_name , \" \" ) ) { \n error_setg ( errp , QERR_QMP_EXTRA_MEMBER , arg_name ) ; \n return NULL ; \n } \n } \n if ( ! has_exec_key ) { \n error_setg ( errp , QERR_QMP_BAD_INPUT_OBJECT , \" \" ) ; \n return NULL ; \n } \n return dict ; \n }", "idx": 5820}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int64 ( QEMUFile * f , void * pv , size_t size ) \n { \n int64_t * v = pv ; \n qemu_get_sbe64s ( f , v ) ; \n return 0 ; \n }", "idx": 5834}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void acpi_build_update ( void * build_opaque , uint32_t offset ) \n { \n AcpiBuildState * build_state = build_opaque ; \n AcpiBuildTables tables ; \n if ( ! build_state || build_state -> patched ) { \n return ; \n } \n build_state -> patched = 1 ; \n acpi_build_tables_init ( & tables ) ; \n acpi_build ( build_state -> guest_info , & tables ) ; \n assert ( acpi_data_len ( tables . table_data ) == build_state -> table_size ) ; \n memcpy ( build_state -> table_ram , tables . table_data -> data , \n build_state -> table_size ) ; \n acpi_build_tables_cleanup ( & tables , true ) ; \n }", "idx": 5837}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( slw ) \n { \n if ( T1 & 0x20 ) { \n T0 = 0 ; \n } else { \n T0 = T0 << T1 ; \n } \n RETURN ( ) ; \n }", "idx": 5855}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn ( PCIDevice * dev ) \n { \n PIIX4State * d = DO_UPCAST ( PIIX4State , dev , dev ) ; \n uint8_t * pci_conf ; \n isa_bus_new ( & d -> dev . qdev ) ; \n pci_conf = d -> dev . config ; \n pci_config_set_vendor_id ( pci_conf , PCI_VENDOR_ID_INTEL ) ; \n pci_config_set_device_id ( pci_conf , PCI_DEVICE_ID_INTEL_82371AB_0 ) ; \n pci_config_set_class ( pci_conf , PCI_CLASS_BRIDGE_ISA ) ; \n piix4_dev = & d -> dev ; \n qemu_register_reset ( piix4_reset , d ) ; \n return 0 ; \n }", "idx": 5899}
{"project": "qemu", "commit_id": "100f8f26086ad85a9361f2883edd55bc337ce594", "target": 1, "func": "void throttle_account ( ThrottleState * ts , bool is_write , uint64_t size ) \n { \n double units = 1.0 ; \n if ( ts -> cfg . op_size && size > ts -> cfg . op_size ) { \n units = ( double ) size / ts -> cfg . op_size ; \n } \n ts -> cfg . buckets [ THROTTLE_BPS_TOTAL ] . level += size ; \n ts -> cfg . buckets [ THROTTLE_OPS_TOTAL ] . level += units ; \n if ( is_write ) { \n ts -> cfg . buckets [ THROTTLE_BPS_WRITE ] . level += size ; \n ts -> cfg . buckets [ THROTTLE_OPS_WRITE ] . level += units ; \n } else { \n ts -> cfg . buckets [ THROTTLE_BPS_READ ] . level += size ; \n ts -> cfg . buckets [ THROTTLE_OPS_READ ] . level += units ; \n } \n }", "idx": 5920}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier ( BlockDriverState * bs , \n void ( * attached_aio_context ) ( AioContext * , \n void * ) , \n void ( * detach_aio_context ) ( void * ) , \n void * opaque ) \n { \n BdrvAioNotifier * ban , * ban_next ; \n QLIST_FOREACH_SAFE ( ban , & bs -> aio_notifiers , list , ban_next )  { \n if ( ban -> attached_aio_context == attached_aio_context && \n ban -> detach_aio_context == detach_aio_context && \n ban -> opaque == opaque ) \n { \n QLIST_REMOVE ( ban , list ) ; \n g_free ( ban ) ; \n return ; \n } \n } \n abort ( ) ; \n }", "idx": 5931}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_addq_lo ( DisasContext * s , TCGv_i64 val , int rlow ) \n { \n TCGv_i64 tmp ; \n TCGv tmp2 ; \n tmp = tcg_temp_new_i64 ( ) ; \n tmp2 = load_reg ( s , rlow ) ; \n tcg_gen_extu_i32_i64 ( tmp , tmp2 ) ; \n dead_tmp ( tmp2 ) ; \n tcg_gen_add_i64 ( val , val , tmp ) ; \n tcg_temp_free_i64 ( tmp ) ; \n }", "idx": 5962}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static VirtIOBlockReq * virtio_blk_get_request ( VirtIOBlock * s ) \n { \n VirtIOBlockReq * req = virtio_blk_alloc_request ( s ) ; \n if ( ! virtqueue_pop ( s -> vq , & req -> elem ) ) { \n virtio_blk_free_request ( req ) ; \n return NULL ; \n } \n return req ; \n }", "idx": 6007}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void qemu_system_reset ( void ) \n { \n QEMUResetEntry * re , * nre ; \n QTAILQ_FOREACH_SAFE ( re , & reset_handlers , entry , nre )  { \n re -> func ( re -> opaque ) ; \n } \n }", "idx": 6025}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_reset ( SDState * sd , BlockDriverState * bdrv ) \n { \n uint64_t size ; \n uint64_t sect ; \n if ( bdrv ) { \n bdrv_get_geometry ( bdrv , & sect ) ; \n } else { \n sect = 0 ; \n } \n size = sect << 9 ; \n sect = ( size >> ( HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT ) ) + 1 ; \n sd -> state = sd_idle_state ; \n sd -> rca = 0x0000 ; \n sd_set_ocr ( sd ) ; \n sd_set_scr ( sd ) ; \n sd_set_cid ( sd ) ; \n sd_set_csd ( sd , size ) ; \n sd_set_cardstatus ( sd ) ; \n sd_set_sdstatus ( sd ) ; \n sd -> bdrv = bdrv ; \n if ( sd -> wp_groups ) \n g_free ( sd -> wp_groups ) ; \n sd -> wp_switch = bdrv ? bdrv_is_read_only ( bdrv ) : 0 ; \n sd -> wp_groups = ( int * ) g_malloc0 ( sizeof ( int ) * sect ) ; \n memset ( sd -> function_group , 0 , sizeof ( int ) * 6 ) ; \n sd -> erase_start = 0 ; \n sd -> erase_end = 0 ; \n sd -> size = size ; \n sd -> blk_len = 0x200 ; \n sd -> pwd_len = 0 ; \n sd -> expecting_acmd = 0 ; \n }", "idx": 6032}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set ( AddressSpaceDispatch * d , \n target_phys_addr_t index , target_phys_addr_t nb , \n uint16_t leaf ) \n { \n phys_map_node_reserve ( 3 * P_L2_LEVELS ) ; \n phys_page_set_level ( & d -> phys_map , & index , & nb , leaf , P_L2_LEVELS - 1 ) ; \n }", "idx": 6033}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState * qemu_chr_open_spice_port ( const char * id , \n ChardevBackend * backend , \n ChardevReturn * ret , \n Error * * errp ) \n { \n const char * name = backend -> spiceport -> fqdn ; \n CharDriverState * chr ; \n SpiceCharDriver * s ; \n if ( name == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n return NULL ; \n } \n chr = chr_open ( \" \" , spice_port_set_fe_open ) ; \n s = chr -> opaque ; \n s -> sin . portname = g_strdup ( name ) ; \n return chr ; \n }", "idx": 6092}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref ( CPUState * cpu , CPUBreakpoint * breakpoint ) \n { \n #if defined ( TARGET_HAS_ICE )  \n  \n  QTAILQ_REMOVE ( & cpu -> breakpoints , breakpoint , entry ) ; \n breakpoint_invalidate ( cpu , breakpoint -> pc ) ; \n g_free ( breakpoint ) ; \n #endif \n }", "idx": 6098}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void * boston_fdt_filter ( void * opaque , const void * fdt_orig , \n const void * match_data , hwaddr * load_addr ) \n { \n BostonState * s = BOSTON ( opaque ) ; \n MachineState * machine = s -> mach ; \n const char * cmdline ; \n int err ; \n void * fdt ; \n size_t fdt_sz , ram_low_sz , ram_high_sz ; \n fdt_sz = fdt_totalsize ( fdt_orig ) * 2 ; \n fdt = g_malloc0 ( fdt_sz ) ; \n err = fdt_open_into ( fdt_orig , fdt , fdt_sz ) ; \n if ( err ) { \n fprintf ( stderr , \" \\n \" ) ; \n return NULL ; \n } \n cmdline = ( machine -> kernel_cmdline && machine -> kernel_cmdline [ 0 ] ) \n ? machine -> kernel_cmdline : \" \" ; \n err = qemu_fdt_setprop_string ( fdt , \" \" , \" \" , cmdline ) ; \n if ( err < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n return NULL ; \n } \n ram_low_sz = MIN ( 256 * M_BYTE , machine -> ram_size ) ; \n ram_high_sz = machine -> ram_size - ram_low_sz ; \n qemu_fdt_setprop_sized_cells ( fdt , \" \" , \" \" , \n 1 , 0x00000000 , 1 , ram_low_sz , \n 1 , 0x90000000 , 1 , ram_high_sz ) ; \n fdt = g_realloc ( fdt , fdt_totalsize ( fdt ) ) ; \n qemu_fdt_dumpdtb ( fdt , fdt_sz ) ; \n s -> fdt_base = * load_addr ; \n return fdt ; \n }", "idx": 6108}
{"project": "qemu", "commit_id": "bee62662a312b99b4418b558a99b3963a4cbff07", "target": 0, "func": "static int kvm_mips_get_fpu_registers ( CPUState * cs ) \n { \n MIPSCPU * cpu = MIPS_CPU ( cs ) ; \n CPUMIPSState * env = & cpu -> env ; \n int err , ret = 0 ; \n unsigned int i ; \n if ( env -> CP0_Config1 & ( 1 << CP0C1_FP ) ) { \n err = kvm_mips_get_one_ureg ( cs , KVM_REG_MIPS_FCR_IR , \n & env -> active_fpu . fcr0 ) ; \n if ( err < 0 ) { \n DPRINTF ( \" \\n \" , __func__ , err ) ; \n ret = err ; \n } \n err = kvm_mips_get_one_ureg ( cs , KVM_REG_MIPS_FCR_CSR , \n & env -> active_fpu . fcr31 ) ; \n if ( err < 0 ) { \n DPRINTF ( \" \\n \" , __func__ , err ) ; \n ret = err ; \n } else { \n restore_fp_status ( env ) ; \n } \n for ( i = 0 ; i < 32 ; ++ i ) { \n if ( env -> CP0_Status & ( 1 << CP0St_FR ) ) { \n err = kvm_mips_get_one_ureg64 ( cs , KVM_REG_MIPS_FPR_64 ( i ) , \n & env -> active_fpu . fpr [ i ] . d ) ; \n } else { \n err = kvm_mips_get_one_ureg ( cs , KVM_REG_MIPS_FPR_32 ( i ) , \n & env -> active_fpu . fpr [ i ] . w [ FP_ENDIAN_IDX ] ) ; \n } \n if ( err < 0 ) { \n DPRINTF ( \" \\n \" , __func__ , i , err ) ; \n ret = err ; \n } \n } \n } \n return ret ; \n }", "idx": 6189}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode ( AioContext * ctx , bool blocking ) \n { \n if ( blocking && ctx -> poll_max_ns && ctx -> poll_disable_cnt == 0 ) { \n int64_t max_ns = MIN ( ( uint64_t ) aio_compute_timeout ( ctx ) , \n ( uint64_t ) ctx -> poll_max_ns ) ; \n if ( max_ns ) { \n if ( run_poll_handlers ( ctx , max_ns ) ) { \n return true ; \n } \n } \n } \n return false ; \n }", "idx": 6206}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic ( gconstpointer data ) \n { \n QVirtioPCIDevice * dev ; \n QPCIBus * bus ; \n QVirtQueuePCI * tx , * rx ; \n QGuestAllocator * alloc ; \n void ( * func ) ( const QVirtioBus * bus , \n QVirtioDevice * dev , \n QGuestAllocator * alloc , \n QVirtQueue * rvq , \n QVirtQueue * tvq , \n int socket ) = data ; \n int sv [ 2 ] , ret ; \n ret = socketpair ( PF_UNIX , SOCK_STREAM , 0 , sv ) ; \n g_assert_cmpint ( ret , ! = , -1 ) ; \n bus = pci_test_start ( sv [ 1 ] ) ; \n dev = virtio_net_pci_init ( bus , PCI_SLOT ) ; \n alloc = pc_alloc_init ( ) ; \n rx = ( QVirtQueuePCI * ) qvirtqueue_setup ( & qvirtio_pci , & dev -> vdev , \n alloc , 0 ) ; \n tx = ( QVirtQueuePCI * ) qvirtqueue_setup ( & qvirtio_pci , & dev -> vdev , \n alloc , 1 ) ; \n driver_init ( & qvirtio_pci , & dev -> vdev ) ; \n func ( & qvirtio_pci , & dev -> vdev , alloc , & rx -> vq , & tx -> vq , sv [ 0 ] ) ; \n close ( sv [ 0 ] ) ; \n guest_free ( alloc , tx -> vq . desc ) ; \n pc_alloc_uninit ( alloc ) ; \n qvirtio_pci_device_disable ( dev ) ; \n g_free ( dev ) ; \n qpci_free_pc ( bus ) ; \n test_end ( ) ; \n }", "idx": 6217}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_negative ( void ) \n { \n const char * str = \" \\t \" ; \n unsigned long res = 999 ; \n int err ; \n err = qemu_strtoul ( str , NULL , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , -321ul ) ; \n }", "idx": 6241}
{"project": "qemu", "commit_id": "85df0de4cfe54fd64df7e37448cd152d0c9199a4", "target": 0, "func": "int fw_cfg_add_callback ( void * opaque , uint16_t key , FWCfgCallback callback , \n void * callback_opaque , uint8_t * data , size_t len ) \n { \n FWCfgState * s = opaque ; \n int arch = ! ! ( key & FW_CFG_ARCH_LOCAL ) ; \n key &= FW_CFG_ENTRY_MASK ; \n if ( key >= FW_CFG_MAX_ENTRY || ! ( key & FW_CFG_WRITE_CHANNEL ) \n || len > 65535 ) \n return 0 ; \n s -> entries [ arch ] [ key ] . data = data ; \n s -> entries [ arch ] [ key ] . len = len ; \n s -> entries [ arch ] [ key ] . callback_opaque = callback_opaque ; \n s -> entries [ arch ] [ key ] . callback = callback ; \n return 1 ; \n }", "idx": 6251}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16 ( TCGv val , TCGv addr , int index ) \n { \n tcg_gen_qemu_st16 ( val , addr , index ) ; \n dead_tmp ( val ) ; \n }", "idx": 6335}
{"project": "qemu", "commit_id": "2f295167e0c429cec233aef7dc8e9fd6f90376df", "target": 1, "func": "static void q35_host_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PCIHostBridgeClass * hc = PCI_HOST_BRIDGE_CLASS ( klass ) ; \n hc -> root_bus_path = q35_host_root_bus_path ; \n dc -> realize = q35_host_realize ; \n dc -> props = mch_props ; \n dc -> user_creatable = false ; \n set_bit ( DEVICE_CATEGORY_BRIDGE , dc -> categories ) ; \n dc -> fw_name = \" \" ; \n }", "idx": 6346}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static struct addrinfo * inet_parse_connect_saddr ( InetSocketAddress * saddr , \n Error * * errp ) \n { \n struct addrinfo ai , * res ; \n int rc ; \n Error * err = NULL ; \n memset ( & ai , 0 , sizeof ( ai ) ) ; \n ai . ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG ; \n ai . ai_family = inet_ai_family_from_address ( saddr , & err ) ; \n ai . ai_socktype = SOCK_STREAM ; \n if ( err ) { \n error_propagate ( errp , err ) ; \n return NULL ; \n } \n if ( saddr -> host == NULL || saddr -> port == NULL ) { \n error_setg ( errp , \" \" ) ; \n return NULL ; \n } \n rc = getaddrinfo ( saddr -> host , saddr -> port , & ai , & res ) ; \n if ( rc != 0 ) { \n error_setg ( errp , \" \" , \n saddr -> host , saddr -> port , gai_strerror ( rc ) ) ; \n return NULL ; \n } \n return res ; \n }", "idx": 6374}
{"project": "qemu", "commit_id": "6476615d385eb249105b25873ef30ba4b9c808dc", "target": 0, "func": "void HELPER ( stpq ) ( CPUS390XState * env , uint64_t addr , \n uint64_t low , uint64_t high ) \n { \n uintptr_t ra = GETPC ( ) ; \n if ( parallel_cpus ) { \n #ifndef CONFIG_ATOMIC128 \n cpu_loop_exit_atomic ( ENV_GET_CPU ( env ) , ra ) ; \n #else \n int mem_idx = cpu_mmu_index ( env , false ) ; \n TCGMemOpIdx oi = make_memop_idx ( MO_TEQ | MO_ALIGN_16 , mem_idx ) ; \n Int128 v = int128_make128 ( low , high ) ; \n helper_atomic_sto_be_mmu ( env , addr , v , oi , ra ) ; \n #endif \n } else { \n check_alignment ( env , addr , 16 , ra ) ; \n cpu_stq_data_ra ( env , addr + 0 , high , ra ) ; \n cpu_stq_data_ra ( env , addr + 8 , low , ra ) ; \n } \n }", "idx": 6408}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number ( void ) \n { \n int i ; \n struct { \n const char * encoded ; \n int64_t decoded ; \n int skip ; \n } test_cases [ ] = { \n { \" \" , 0 } , \n { \" \" , 1234 } , \n { \" \" , 1 } , \n { \" \" , -32 } , \n { \" \" , 0 , . skip = 1 } , \n { } , \n } ; \n for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { \n QInt * qint ; \n qint = qobject_to_qint ( qobject_from_json ( test_cases [ i ] . encoded , NULL ) ) ; \n g_assert ( qint ) ; \n g_assert ( qint_get_int ( qint ) == test_cases [ i ] . decoded ) ; \n if ( test_cases [ i ] . skip == 0 ) { \n QString * str ; \n str = qobject_to_json ( QOBJECT ( qint ) ) ; \n g_assert ( strcmp ( qstring_get_str ( str ) , test_cases [ i ] . encoded ) == 0 ) ; \n QDECREF ( str ) ; \n } \n QDECREF ( qint ) ; \n } \n }", "idx": 6486}
{"project": "qemu", "commit_id": "e13e973eedba0a52b4b8b079c4b85cdc68b7b4f0", "target": 1, "func": "static int ccid_initfn ( USBDevice * dev ) \n { \n USBCCIDState * s = DO_UPCAST ( USBCCIDState , dev , dev ) ; \n s -> bus = ccid_bus_new ( & dev -> qdev ) ; \n s -> card = NULL ; \n s -> cardinfo = NULL ; \n s -> migration_state = MIGRATION_NONE ; \n s -> migration_target_ip = 0 ; \n s -> migration_target_port = 0 ; \n s -> dev . speed = USB_SPEED_FULL ; \n s -> notify_slot_change = false ; \n s -> powered = true ; \n s -> pending_answers_num = 0 ; \n s -> last_answer_error = 0 ; \n s -> bulk_in_pending_start = 0 ; \n s -> bulk_in_pending_end = 0 ; \n s -> current_bulk_in = NULL ; \n ccid_reset_error_status ( s ) ; \n s -> bulk_out_pos = 0 ; \n ccid_reset_parameters ( s ) ; \n ccid_reset ( s ) ; \n return 0 ; \n }", "idx": 6500}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void ppc4xx_pob_reset ( void * opaque ) \n { \n ppc4xx_pob_t * pob ; \n pob = opaque ; \n pob -> bear = 0x00000000 ; \n pob -> besr [ 0 ] = 0x0000000 ; \n pob -> besr [ 1 ] = 0x0000000 ; \n }", "idx": 6507}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_net_uninit ( VMXNET3State * s ) \n { \n g_free ( s -> mcast_list ) ; \n vmxnet_tx_pkt_reset ( s -> tx_pkt ) ; \n vmxnet_tx_pkt_uninit ( s -> tx_pkt ) ; \n vmxnet_rx_pkt_uninit ( s -> rx_pkt ) ; \n qemu_del_nic ( s -> nic ) ; \n }", "idx": 6547}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState * cpu_copy ( CPUArchState * env ) \n { \n CPUState * cpu = ENV_GET_CPU ( env ) ; \n CPUState * new_cpu = cpu_init ( cpu_model ) ; \n CPUArchState * new_env = cpu -> env_ptr ; \n CPUBreakpoint * bp ; \n CPUWatchpoint * wp ; \n cpu_reset ( new_cpu ) ; \n memcpy ( new_env , env , sizeof ( CPUArchState ) ) ; \n QTAILQ_INIT ( & cpu -> breakpoints ) ; \n QTAILQ_INIT ( & cpu -> watchpoints ) ; \n QTAILQ_FOREACH ( bp , & cpu -> breakpoints , entry )  { \n cpu_breakpoint_insert ( new_cpu , bp -> pc , bp -> flags , NULL ) ; \n } \n QTAILQ_FOREACH ( wp , & cpu -> watchpoints , entry )  { \n cpu_watchpoint_insert ( new_cpu , wp -> vaddr , wp -> len , wp -> flags , NULL ) ; \n } \n return new_env ; \n }", "idx": 6577}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send ( void * opaque ) \n { \n NetSocketState * s = opaque ; \n return qemu_can_send_packet ( & s -> nc ) ; \n }", "idx": 6594}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_cpunum ( CPUMIPSState * env ) \n { \n check_hwrena ( env , 0 ) ; \n return env -> CP0_EBase & 0x3ff ; \n }", "idx": 6628}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi ( Error * * errp ) \n { \n #if defined ( TARGET_I386 )  \n  \n  CPUState * cs ; \n CPU_FOREACH ( cs ) { \n X86CPU * cpu = X86_CPU ( cs ) ; \n if ( ! cpu -> apic_state ) { \n cpu_interrupt ( cs , CPU_INTERRUPT_NMI ) ; \n } else { \n apic_deliver_nmi ( cpu -> apic_state ) ; \n } \n } \n #elif defined ( TARGET_S390X )  \n  \n  CPUState * cs ; \n S390CPU * cpu ; \n CPU_FOREACH ( cs ) { \n cpu = S390_CPU ( cs ) ; \n if ( cpu -> env . cpu_num == monitor_get_cpu_index ( ) ) { \n if ( s390_cpu_restart ( S390_CPU ( cs ) ) == -1 ) { \n error_set ( errp , QERR_UNSUPPORTED ) ; \n return ; \n } \n break ; \n } \n } \n #else \n error_set ( errp , QERR_UNSUPPORTED ) ; \n #endif \n }", "idx": 6635}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step ( CPUX86State * env ) \n { \n #ifndef CONFIG_USER_ONLY \n check_hw_breakpoints ( env , 1 ) ; \n env -> dr [ 6 ] |= DR6_BS ; \n #endif \n raise_exception ( env , EXCP01_DB ) ; \n }", "idx": 6641}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect ( struct XenDevice * xendev ) \n { \n struct XenConsole * con = container_of ( xendev , struct XenConsole , xendev ) ; \n if ( con -> chr ) { \n qemu_chr_add_handlers ( con -> chr , NULL , NULL , NULL , NULL ) ; \n qemu_chr_fe_release ( con -> chr ) ; \n } \n xen_be_unbind_evtchn ( & con -> xendev ) ; \n if ( con -> sring ) { \n if ( ! xendev -> dev ) { \n munmap ( con -> sring , XC_PAGE_SIZE ) ; \n } else { \n xengnttab_unmap ( xendev -> gnttabdev , con -> sring , 1 ) ; \n } \n con -> sring = NULL ; \n } \n }", "idx": 6650}
{"project": "qemu", "commit_id": "2e63eb2becc228232f12a1ea30a91b2aa8c5cecd", "target": 1, "func": "static void xen_pci_passthrough_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ; \n k -> realize = xen_pt_realize ; \n k -> exit = xen_pt_unregister_device ; \n k -> config_read = xen_pt_pci_read_config ; \n k -> config_write = xen_pt_pci_write_config ; \n set_bit ( DEVICE_CATEGORY_MISC , dc -> categories ) ; \n dc -> desc = \" \" ; \n dc -> props = xen_pci_passthrough_properties ; \n } ;", "idx": 6674}
{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start ( OHCIState * ohci ) \n { \n ohci -> eof_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , \n ohci_frame_boundary , \n ohci ) ; \n if ( ohci -> eof_timer == NULL ) { \n trace_usb_ohci_bus_eof_timer_failed ( ohci -> name ) ; \n ohci_die ( ohci ) ; \n return 0 ; \n } \n trace_usb_ohci_start ( ohci -> name ) ; \n ohci_eof_timer ( ohci ) ; \n return 1 ; \n }", "idx": 6685}
{"project": "qemu", "commit_id": "3ac2f2f765a0bc18dfb18c38a522e6123289ffc1", "target": 1, "func": "void bdrv_image_info_specific_dump ( fprintf_function func_fprintf , void * f , \n ImageInfoSpecific * info_spec ) \n { \n QObject * obj , * data ; \n Visitor * v = qmp_output_visitor_new ( & obj ) ; \n visit_type_ImageInfoSpecific ( v , NULL , & info_spec , & error_abort ) ; \n visit_complete ( v , & obj ) ; \n assert ( qobject_type ( obj ) == QTYPE_QDICT ) ; \n data = qdict_get ( qobject_to_qdict ( obj ) , \" \" ) ; \n dump_qobject ( func_fprintf , f , 1 , data ) ; \n visit_free ( v ) ; \n }", "idx": 6699}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault ( PowerPCCPU * cpu , vaddr eaddr , int rwx , \n int mmu_idx ) \n { \n if ( ppc64_radix_guest ( cpu ) ) { \n error_report ( \" \" ) ; \n exit ( 1 ) ; \n } else { \n return ppc_hash64_handle_mmu_fault ( cpu , eaddr , rwx , mmu_idx ) ; \n } \n }", "idx": 6753}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew ( void * opaque , uint32_t addr , uint32_t val ) \n { \n IDEBus * bus = opaque ; \n IDEState * s = idebus_active_if ( bus ) ; \n uint8_t * p ; \n if ( ! ( s -> status & DRQ_STAT ) ) \n return ; \n p = s -> data_ptr ; \n * ( uint16_t * ) p = le16_to_cpu ( val ) ; \n p += 2 ; \n s -> data_ptr = p ; \n if ( p >= s -> data_end ) \n s -> end_transfer_func ( s ) ; \n }", "idx": 6775}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void keyword_literal ( void ) \n { \n QObject * obj ; \n QBool * qbool ; \n QObject * null ; \n QString * str ; \n obj = qobject_from_json ( \" \" , NULL ) ; \n qbool = qobject_to_qbool ( obj ) ; \n g_assert ( qbool ) ; \n g_assert ( qbool_get_bool ( qbool ) == true ) ; \n str = qobject_to_json ( obj ) ; \n g_assert ( strcmp ( qstring_get_str ( str ) , \" \" ) == 0 ) ; \n QDECREF ( str ) ; \n QDECREF ( qbool ) ; \n obj = qobject_from_json ( \" \" , NULL ) ; \n qbool = qobject_to_qbool ( obj ) ; \n g_assert ( qbool ) ; \n g_assert ( qbool_get_bool ( qbool ) == false ) ; \n str = qobject_to_json ( obj ) ; \n g_assert ( strcmp ( qstring_get_str ( str ) , \" \" ) == 0 ) ; \n QDECREF ( str ) ; \n QDECREF ( qbool ) ; \n qbool = qobject_to_qbool ( qobject_from_jsonf ( \" \" , false ) ) ; \n g_assert ( qbool ) ; \n g_assert ( qbool_get_bool ( qbool ) == false ) ; \n QDECREF ( qbool ) ; \n qbool = qobject_to_qbool ( qobject_from_jsonf ( \" \" , 2 ) ) ; \n g_assert ( qbool ) ; \n g_assert ( qbool_get_bool ( qbool ) == true ) ; \n QDECREF ( qbool ) ; \n obj = qobject_from_json ( \" \" , NULL ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QNULL ) ; \n null = qnull ( ) ; \n g_assert ( null == obj ) ; \n qobject_decref ( obj ) ; \n qobject_decref ( null ) ; \n }", "idx": 6816}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "func": "void DMA_run ( void ) \n { \n }", "idx": 6838}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp ( float64 a ) \n { \n return ( a >> 52 ) & 0x7FF ; \n }", "idx": 6844}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_fcmp_un ( uint32_t a , uint32_t b ) \n { \n CPU_FloatU fa , fb ; \n uint32_t r = 0 ; \n fa . l = a ; \n fb . l = b ; \n if ( float32_is_signaling_nan ( fa . f ) || float32_is_signaling_nan ( fb . f ) ) { \n update_fpu_flags ( float_flag_invalid ) ; \n r = 1 ; \n } \n if ( float32_is_nan ( fa . f ) || float32_is_nan ( fb . f ) ) { \n r = 1 ; \n } \n return r ; \n }", "idx": 6852}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_user_start ( VhostUserState * s ) \n { \n VhostNetOptions options ; \n if ( vhost_user_running ( s ) ) { \n return 0 ; \n } \n options . backend_type = VHOST_BACKEND_TYPE_USER ; \n options . net_backend = & s -> nc ; \n options . opaque = s -> chr ; \n s -> vhost_net = vhost_net_init ( & options ) ; \n return vhost_user_running ( s ) ? 0 : -1 ; \n }", "idx": 6867}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void test_dealloc_types ( void ) \n { \n UserDefOne * ud1test , * ud1a , * ud1b ; \n UserDefOneList * ud1list ; \n ud1test = g_malloc0 ( sizeof ( UserDefOne ) ) ; \n ud1test -> base = g_new0 ( UserDefZero , 1 ) ; \n ud1test -> base -> integer = 42 ; \n ud1test -> string = g_strdup ( \" \" ) ; \n qapi_free_UserDefOne ( ud1test ) ; \n ud1a = g_malloc0 ( sizeof ( UserDefOne ) ) ; \n ud1a -> base = g_new0 ( UserDefZero , 1 ) ; \n ud1a -> base -> integer = 43 ; \n ud1a -> string = g_strdup ( \" \" ) ; \n ud1b = g_malloc0 ( sizeof ( UserDefOne ) ) ; \n ud1b -> base = g_new0 ( UserDefZero , 1 ) ; \n ud1b -> base -> integer = 44 ; \n ud1b -> string = g_strdup ( \" \" ) ; \n ud1list = g_malloc0 ( sizeof ( UserDefOneList ) ) ; \n ud1list -> value = ud1a ; \n ud1list -> next = g_malloc0 ( sizeof ( UserDefOneList ) ) ; \n ud1list -> next -> value = ud1b ; \n qapi_free_UserDefOneList ( ud1list ) ; \n }", "idx": 6919}
{"project": "qemu", "commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "target": 0, "func": "void net_checksum_calculate ( uint8_t * data , int length ) \n { \n int hlen , plen , proto , csum_offset ; \n uint16_t csum ; \n if ( ( data [ 14 ] & 0xf0 ) != 0x40 ) \n return ; \n hlen = ( data [ 14 ] & 0x0f ) * 4 ; \n plen = ( data [ 16 ] << 8 | data [ 17 ] ) - hlen ; \n proto = data [ 23 ] ; \n switch ( proto ) { \n case PROTO_TCP : \n csum_offset = 16 ; \n break ; \n case PROTO_UDP : \n csum_offset = 6 ; \n break ; \n default : \n return ; \n } \n if ( plen < csum_offset + 2 ) \n return ; \n data [ 14 + hlen + csum_offset ] = 0 ; \n data [ 14 + hlen + csum_offset + 1 ] = 0 ; \n csum = net_checksum_tcpudp ( plen , proto , data + 14 + 12 , data + 14 + hlen ) ; \n data [ 14 + hlen + csum_offset ] = csum >> 8 ; \n data [ 14 + hlen + csum_offset + 1 ] = csum & 0xff ; \n }", "idx": 6927}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "static VirtIOSCSIVring * virtio_scsi_vring_init ( VirtIOSCSI * s , \n VirtQueue * vq , \n EventNotifierHandler * handler , \n int n ) \n { \n BusState * qbus = BUS ( qdev_get_parent_bus ( DEVICE ( s ) ) ) ; \n VirtioBusClass * k = VIRTIO_BUS_GET_CLASS ( qbus ) ; \n VirtIOSCSIVring * r = g_slice_new ( VirtIOSCSIVring ) ; \n int rc ; \n rc = k -> set_host_notifier ( qbus -> parent , n , true ) ; \n if ( rc != 0 ) { \n fprintf ( stderr , \" \\n \" , \n rc ) ; \n exit ( 1 ) ; \n } \n r -> host_notifier = * virtio_queue_get_host_notifier ( vq ) ; \n r -> guest_notifier = * virtio_queue_get_guest_notifier ( vq ) ; \n aio_set_event_notifier ( s -> ctx , & r -> host_notifier , handler ) ; \n r -> parent = s ; \n if ( ! vring_setup ( & r -> vring , VIRTIO_DEVICE ( s ) , n ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n return r ; \n }", "idx": 6946}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "void qemu_net_queue_purge ( NetQueue * queue , NetClientState * from ) \n { \n NetPacket * packet , * next ; \n QTAILQ_FOREACH_SAFE ( packet , & queue -> packets , entry , next )  { \n if ( packet -> sender == from ) { \n QTAILQ_REMOVE ( & queue -> packets , packet , entry ) ; \n g_free ( packet ) ; \n } \n } \n }", "idx": 6951}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_client_read_tls ( gnutls_session_t * session , uint8_t * data , \n size_t datalen ) \n { \n ssize_t ret = gnutls_read ( * session , data , datalen ) ; \n if ( ret < 0 ) { \n if ( ret == GNUTLS_E_AGAIN ) { \n errno = EAGAIN ; \n } else { \n errno = EIO ; \n } \n ret = -1 ; \n } \n return ret ; \n }", "idx": 6953}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out ( HWVoiceOut * hw ) \n { \n void * ret ; \n PAVoiceOut * pa = ( PAVoiceOut * ) hw ; \n audio_pt_lock ( & pa -> pt , AUDIO_FUNC ) ; \n pa -> done = 1 ; \n audio_pt_unlock_and_signal ( & pa -> pt , AUDIO_FUNC ) ; \n audio_pt_join ( & pa -> pt , & ret , AUDIO_FUNC ) ; \n if ( pa -> s ) { \n pa_simple_free ( pa -> s ) ; \n pa -> s = NULL ; \n } \n audio_pt_fini ( & pa -> pt , AUDIO_FUNC ) ; \n g_free ( pa -> pcm_buf ) ; \n pa -> pcm_buf = NULL ; \n }", "idx": 7004}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_device_init ( SCSIDevice * s ) \n { \n SCSIDeviceClass * sc = SCSI_DEVICE_GET_CLASS ( s ) ; \n if ( sc -> init ) { \n return sc -> init ( s ) ; \n } \n return 0 ; \n }", "idx": 7017}
{"project": "qemu", "commit_id": "aaa0eb75e2e56d483c89731a447c999985713b43", "target": 0, "func": "static void set_dirty_bitmap ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , int dirty ) \n { \n int64_t start , end ; \n unsigned long val , idx , bit ; \n start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK ; \n end = ( sector_num + nb_sectors - 1 ) / BDRV_SECTORS_PER_DIRTY_CHUNK ; \n for ( ; start <= end ; start ++ ) { \n idx = start / ( sizeof ( unsigned long ) * 8 ) ; \n bit = start % ( sizeof ( unsigned long ) * 8 ) ; \n val = bs -> dirty_bitmap [ idx ] ; \n if ( dirty ) { \n val |= 1 << bit ; \n } else { \n val &= ~ ( 1 << bit ) ; \n } \n bs -> dirty_bitmap [ idx ] = val ; \n } \n }", "idx": 7019}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static size_t net_tx_pkt_fetch_fragment ( struct NetTxPkt * pkt , \n int * src_idx , size_t * src_offset , struct iovec * dst , int * dst_idx ) \n { \n size_t fetched = 0 ; \n struct iovec * src = pkt -> vec ; \n * dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM ; \n while ( fetched < pkt -> virt_hdr . gso_size ) { \n if ( * dst_idx == NET_MAX_FRAG_SG_LIST ) { \n break ; \n } \n if ( * src_idx == ( pkt -> payload_frags + NET_TX_PKT_PL_START_FRAG ) ) { \n break ; \n } \n dst [ * dst_idx ] . iov_base = src [ * src_idx ] . iov_base + * src_offset ; \n dst [ * dst_idx ] . iov_len = MIN ( src [ * src_idx ] . iov_len - * src_offset , \n pkt -> virt_hdr . gso_size - fetched ) ; \n * src_offset += dst [ * dst_idx ] . iov_len ; \n fetched += dst [ * dst_idx ] . iov_len ; \n if ( * src_offset == src [ * src_idx ] . iov_len ) { \n * src_offset = 0 ; \n ( * src_idx ) ++ ; \n } \n ( * dst_idx ) ++ ; \n } \n return fetched ; \n }", "idx": 7027}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_ram_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n LSIState * s = opaque ; \n uint32_t newval ; \n uint32_t mask ; \n int shift ; \n newval = s -> script_ram [ addr >> 2 ] ; \n shift = ( addr & 3 ) * 8 ; \n mask = ( ( uint64_t ) 1 << ( size * 8 ) ) - 1 ; \n newval &= ~ ( mask << shift ) ; \n newval |= val << shift ; \n s -> script_ram [ addr >> 2 ] = newval ; \n }", "idx": 7033}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate ( TCGv op0 , TCGv op1 , int size ) \n { \n switch ( size ) { \n case 1 : gen_helper_neon_addl_saturate_s32 ( op0 , cpu_env , op0 , op1 ) ; break ; \n case 2 : gen_helper_neon_addl_saturate_s64 ( op0 , cpu_env , op0 , op1 ) ; break ; \n default : abort ( ) ; \n } \n }", "idx": 7119}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all ( CharDriverState * s , uint8_t * buf , int len ) \n { \n int offset = 0 , counter = 10 ; \n int res ; \n if ( ! s -> chr_sync_read ) { \n return 0 ; \n } \n if ( s -> replay && replay_mode == REPLAY_MODE_PLAY ) { \n return replay_char_read_all_load ( buf ) ; \n } \n while ( offset < len ) { \n do { \n res = s -> chr_sync_read ( s , buf + offset , len - offset ) ; \n if ( res == -1 && errno == EAGAIN ) { \n g_usleep ( 100 ) ; \n } \n } while ( res == -1 && errno == EAGAIN ) ; \n if ( res == 0 ) { \n break ; \n } \n if ( res < 0 ) { \n if ( s -> replay && replay_mode == REPLAY_MODE_RECORD ) { \n replay_char_read_all_save_error ( res ) ; \n } \n return res ; \n } \n offset += res ; \n if ( ! counter -- ) { \n break ; \n } \n } \n if ( s -> replay && replay_mode == REPLAY_MODE_RECORD ) { \n replay_char_read_all_save_buf ( buf , offset ) ; \n } \n return offset ; \n }", "idx": 7125}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked ( struct qht * ht , struct qht_map * map , \n struct qht_bucket * head , void * p , uint32_t hash , \n bool * needs_resize ) \n { \n struct qht_bucket * b = head ; \n struct qht_bucket * prev = NULL ; \n struct qht_bucket * new = NULL ; \n int i ; \n do { \n for ( i = 0 ; i < QHT_BUCKET_ENTRIES ; i ++ ) { \n if ( b -> pointers [ i ] ) { \n if ( unlikely ( b -> pointers [ i ] == p ) ) { \n return false ; \n } \n } else { \n goto found ; \n } \n } \n prev = b ; \n b = b -> next ; \n } while ( b ) ; \n b = qemu_memalign ( QHT_BUCKET_ALIGN , sizeof ( * b ) ) ; \n memset ( b , 0 , sizeof ( * b ) ) ; \n new = b ; \n i = 0 ; \n atomic_inc ( & map -> n_added_buckets ) ; \n if ( unlikely ( qht_map_needs_resize ( map ) ) && needs_resize ) { \n * needs_resize = true ; \n } \n found : \n seqlock_write_begin ( & head -> sequence ) ; \n if ( new ) { \n atomic_rcu_set ( & prev -> next , b ) ; \n } \n b -> hashes [ i ] = hash ; \n atomic_set ( & b -> pointers [ i ] , p ) ; \n seqlock_write_end ( & head -> sequence ) ; \n return true ; \n }", "idx": 7191}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init ( Object * obj ) \n { \n VirtIOCrypto * vcrypto = VIRTIO_CRYPTO ( obj ) ; \n vcrypto -> config_size = sizeof ( struct virtio_crypto_config ) ; \n object_property_add_link ( obj , \" \" , \n TYPE_CRYPTODEV_BACKEND , \n ( Object * * ) & vcrypto -> conf . cryptodev , \n virtio_crypto_check_cryptodev_is_used , \n OBJ_PROP_LINK_UNREF_ON_RELEASE , NULL ) ; \n }", "idx": 7213}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sh4_handle_mmu_fault ( CPUState * env , target_ulong address , int rw , \n int mmu_idx , int is_softmmu ) \n { \n target_ulong physical ; \n int prot , ret , access_type ; \n access_type = ACCESS_INT ; \n ret = \n get_physical_address ( env , & physical , & prot , address , rw , \n access_type ) ; \n if ( ret != MMU_OK ) { \n env -> tea = address ; \n switch ( ret ) { \n case MMU_ITLB_MISS : \n case MMU_DTLB_MISS_READ : \n env -> exception_index = 0x040 ; \n break ; \n case MMU_DTLB_MULTIPLE : \n case MMU_ITLB_MULTIPLE : \n env -> exception_index = 0x140 ; \n break ; \n case MMU_ITLB_VIOLATION : \n env -> exception_index = 0x0a0 ; \n break ; \n case MMU_DTLB_MISS_WRITE : \n env -> exception_index = 0x060 ; \n break ; \n case MMU_DTLB_INITIAL_WRITE : \n env -> exception_index = 0x080 ; \n break ; \n case MMU_DTLB_VIOLATION_READ : \n env -> exception_index = 0x0a0 ; \n break ; \n case MMU_DTLB_VIOLATION_WRITE : \n env -> exception_index = 0x0c0 ; \n break ; \n case MMU_IADDR_ERROR : \n case MMU_DADDR_ERROR_READ : \n env -> exception_index = 0x0c0 ; \n break ; \n case MMU_DADDR_ERROR_WRITE : \n env -> exception_index = 0x100 ; \n break ; \n default : \n assert ( 0 ) ; \n } \n return 1 ; \n } \n address &= TARGET_PAGE_MASK ; \n physical &= TARGET_PAGE_MASK ; \n return tlb_set_page ( env , address , physical , prot , mmu_idx , is_softmmu ) ; \n }", "idx": 7222}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static int virtio_blk_device_exit ( DeviceState * dev ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( dev ) ; \n VirtIOBlock * s = VIRTIO_BLK ( dev ) ; \n #ifdef CONFIG_VIRTIO_BLK_DATA_PLANE \n remove_migration_state_change_notifier ( & s -> migration_state_notifier ) ; \n virtio_blk_data_plane_destroy ( s -> dataplane ) ; \n s -> dataplane = NULL ; \n #endif \n qemu_del_vm_change_state_handler ( s -> change ) ; \n unregister_savevm ( dev , \" \" , s ) ; \n blockdev_mark_auto_del ( s -> bs ) ; \n virtio_cleanup ( vdev ) ; \n return 0 ; \n }", "idx": 7243}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static void pc_dimm_get_size ( Object * obj , Visitor * v , const char * name , \n void * opaque , Error * * errp ) \n { \n uint64_t value ; \n MemoryRegion * mr ; \n PCDIMMDevice * dimm = PC_DIMM ( obj ) ; \n PCDIMMDeviceClass * ddc = PC_DIMM_GET_CLASS ( obj ) ; \n mr = ddc -> get_memory_region ( dimm ) ; \n value = memory_region_size ( mr ) ; \n visit_type_uint64 ( v , name , & value , errp ) ; \n }", "idx": 7267}
{"project": "qemu", "commit_id": "821303f59b63ab832f0921f070db55e95bb21858", "target": 1, "func": "target_ulong spapr_rtas_call ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n if ( ( token >= TOKEN_BASE ) \n && ( ( token - TOKEN_BASE ) < TOKEN_MAX ) ) { \n struct rtas_call * call = rtas_table + ( token - TOKEN_BASE ) ; \n if ( call -> fn ) { \n call -> fn ( spapr , token , nargs , args , nret , rets ) ; \n hcall_dprintf ( \" \\n \" , token ) ; \n rtas_st ( rets , 0 , -3 ) ; \n return H_PARAMETER ;", "idx": 7269}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input ( struct mbuf * m ) \n { \n struct ip6 * ip6 ; \n DEBUG_CALL ( \" \" ) ; \n DEBUG_ARG ( \" \" , ( long ) m ) ; \n DEBUG_ARG ( \" \" , m -> m_len ) ; \n if ( m -> m_len < sizeof ( struct ip6 ) ) { \n goto bad ; \n } \n ip6 = mtod ( m , struct ip6 * ) ; \n if ( ip6 -> ip_v != IP6VERSION ) { \n goto bad ; \n } \n if ( ip6 -> ip_hl == 0 ) { \n goto bad ; \n } \n switch ( ip6 -> ip_nh ) { \n case IPPROTO_TCP : \n break ; \n case IPPROTO_UDP : \n break ; \n case IPPROTO_ICMPV6 : \n icmp6_input ( m ) ; \n break ; \n default : \n m_free ( m ) ; \n } \n return ; \n bad : \n m_free ( m ) ; \n }", "idx": 7324}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void fork_start ( void ) \n { \n pthread_mutex_lock ( & tcg_ctx . tb_ctx . tb_lock ) ; \n pthread_mutex_lock ( & exclusive_lock ) ; \n mmap_fork_start ( ) ; \n }", "idx": 7326}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init ( MachineState * machine ) \n { \n const char * cpu_model = machine -> cpu_model ; \n PXA2xxState * cpu ; \n DriveInfo * dinfo ; \n int be ; \n MemoryRegion * address_space_mem = get_system_memory ( ) ; \n uint32_t verdex_rom = 0x02000000 ; \n uint32_t verdex_ram = 0x10000000 ; \n cpu = pxa270_init ( address_space_mem , verdex_ram , cpu_model ?  : \" \" ) ; \n dinfo = drive_get ( IF_PFLASH , 0 , 0 ) ; \n if ( ! dinfo && ! qtest_enabled ( ) ) { \n fprintf ( stderr , \" \" \n \" \\n \" ) ; \n exit ( 1 ) ; \n } \n #ifdef TARGET_WORDS_BIGENDIAN \n be = 1 ; \n #else \n be = 0 ; \n #endif \n if ( ! pflash_cfi01_register ( 0x00000000 , NULL , \" \" , verdex_rom , \n dinfo ? blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) : NULL , \n sector_len , verdex_rom / sector_len , \n 2 , 0 , 0 , 0 , 0 , be ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n smc91c111_init ( & nd_table [ 0 ] , 0x04000300 , \n qdev_get_gpio_in ( cpu -> gpio , 99 ) ) ; \n }", "idx": 7334}
{"project": "qemu", "commit_id": "7d08d85645def18eac2a9d672c1868a35e0bcf79", "target": 0, "func": "static void gen_mtfsfi ( DisasContext * ctx ) \n { \n int bf , sh ; \n TCGv_i64 t0 ; \n TCGv_i32 t1 ; \n if ( unlikely ( ! ctx -> fpu_enabled ) ) { \n gen_exception ( ctx , POWERPC_EXCP_FPU ) ; \n return ; \n } \n bf = crbD ( ctx -> opcode ) >> 2 ; \n sh = 7 - bf ; \n gen_update_nip ( ctx , ctx -> nip - 4 ) ; \n gen_reset_fpstatus ( ) ; \n t0 = tcg_const_i64 ( FPIMM ( ctx -> opcode ) << ( 4 * sh ) ) ; \n t1 = tcg_const_i32 ( 1 << sh ) ; \n gen_helper_store_fpscr ( cpu_env , t0 , t1 ) ; \n tcg_temp_free_i64 ( t0 ) ; \n tcg_temp_free_i32 ( t1 ) ; \n if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) { \n tcg_gen_trunc_tl_i32 ( cpu_crf [ 1 ] , cpu_fpscr ) ; \n tcg_gen_shri_i32 ( cpu_crf [ 1 ] , cpu_crf [ 1 ] , FPSCR_OX ) ; \n } \n gen_helper_float_check_status ( cpu_env ) ; \n }", "idx": 7380}
{"project": "qemu", "commit_id": "1e356fc14beaa3ece6c0e961bd479af58be3198b", "target": 1, "func": "void os_mem_prealloc ( int fd , char * area , size_t memory , Error * * errp ) \n { \n int i ; \n size_t pagesize = getpagesize ( ) ; \n memory = ( memory + pagesize - 1 ) & - pagesize ; \n for ( i = 0 ; i < memory / pagesize ; i ++ ) { \n memset ( area + pagesize * i , 0 , 1 ) ; \n } \n }", "idx": 7393}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static void hotplug ( void ) \n { \n qtest_start ( \" \" ) ; \n qpci_plug_device_test ( \" \" , \" \" , PCI_SLOT_HP , NULL ) ; \n qpci_unplug_acpi_device_test ( \" \" , PCI_SLOT_HP ) ; \n test_end ( ) ; \n }", "idx": 7420}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify ( IDEState * s ) \n { \n uint16_t * p ; \n unsigned int oldsize ; \n memset ( s -> io_buffer , 0 , 512 ) ; \n p = ( uint16_t * ) s -> io_buffer ; \n stw ( p + 0 , 0x0040 ) ; \n stw ( p + 1 , s -> cylinders ) ; \n stw ( p + 3 , s -> heads ) ; \n stw ( p + 4 , 512 * s -> sectors ) ; \n stw ( p + 5 , 512 ) ; \n stw ( p + 6 , s -> sectors ) ; \n stw ( p + 20 , 3 ) ; \n stw ( p + 21 , 512 ) ; \n stw ( p + 22 , 4 ) ; \n padstr ( ( uint8_t * ) ( p + 27 ) , \" \" , 40 ) ; \n #if MAX_MULT_SECTORS > 1  \n  \n  stw ( p + 47 , MAX_MULT_SECTORS ) ; \n #endif \n stw ( p + 48 , 1 ) ; \n stw ( p + 49 , 1 << 9 ) ; \n stw ( p + 51 , 0x200 ) ; \n stw ( p + 52 , 0x200 ) ; \n stw ( p + 54 , s -> cylinders ) ; \n stw ( p + 55 , s -> heads ) ; \n stw ( p + 56 , s -> sectors ) ; \n oldsize = s -> cylinders * s -> heads * s -> sectors ; \n stw ( p + 57 , oldsize ) ; \n stw ( p + 58 , oldsize >> 16 ) ; \n if ( s -> mult_sectors ) \n stw ( p + 59 , 0x100 | s -> mult_sectors ) ; \n stw ( p + 60 , s -> nb_sectors ) ; \n stw ( p + 61 , s -> nb_sectors >> 16 ) ; \n stw ( p + 80 , ( 1 << 1 ) | ( 1 << 2 ) ) ; \n stw ( p + 82 , ( 1 << 14 ) ) ; \n stw ( p + 83 , ( 1 << 14 ) ) ; \n stw ( p + 84 , ( 1 << 14 ) ) ; \n stw ( p + 85 , ( 1 << 14 ) ) ; \n stw ( p + 86 , 0 ) ; \n stw ( p + 87 , ( 1 << 14 ) ) ; \n }", "idx": 7430}
{"project": "qemu", "commit_id": "d62b5dea30284eacd88055bb08db7c295655945f", "target": 0, "func": "BlockDriverAIOCB * bdrv_aio_readv ( BlockDriverState * bs , int64_t sector_num , \n QEMUIOVector * qiov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n BlockDriver * drv = bs -> drv ; \n BlockDriverAIOCB * ret ; \n trace_bdrv_aio_readv ( bs , sector_num , nb_sectors , opaque ) ; \n if ( ! drv ) \n return NULL ; \n if ( bdrv_check_request ( bs , sector_num , nb_sectors ) ) \n return NULL ; \n ret = drv -> bdrv_aio_readv ( bs , sector_num , qiov , nb_sectors , \n cb , opaque ) ; \n if ( ret ) { \n bs -> rd_bytes += ( unsigned ) nb_sectors * BDRV_SECTOR_SIZE ; \n bs -> rd_ops ++ ; \n } \n return ret ; \n }", "idx": 7449}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime ( QTestState * who , const char * value ) \n { \n QDict * rsp ; \n gchar * cmd ; \n cmd = g_strdup_printf ( \" \" \n \" \" , value ) ; \n rsp = qtest_qmp ( who , cmd ) ; \n g_free ( cmd ) ; \n g_assert ( qdict_haskey ( rsp , \" \" ) ) ; \n QDECREF ( rsp ) ; \n }", "idx": 7458}
{"project": "qemu", "commit_id": "d85937e683f6ff4d68293cb24c780fb1f6820d2c", "target": 0, "func": "static qemu_irq * ppce500_init_mpic ( PPCE500Params * params , MemoryRegion * ccsr , \n qemu_irq * * irqs ) \n { \n qemu_irq * mpic ; \n DeviceState * dev ; \n SysBusDevice * s ; \n int i , j , k ; \n mpic = g_new ( qemu_irq , 256 ) ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_prop_set_uint32 ( dev , \" \" , smp_cpus ) ; \n qdev_prop_set_uint32 ( dev , \" \" , params -> mpic_version ) ; \n qdev_init_nofail ( dev ) ; \n s = SYS_BUS_DEVICE ( dev ) ; \n k = 0 ; \n for ( i = 0 ; i < smp_cpus ; i ++ ) { \n for ( j = 0 ; j < OPENPIC_OUTPUT_NB ; j ++ ) { \n sysbus_connect_irq ( s , k ++ , irqs [ i ] [ j ] ) ; \n } \n } \n for ( i = 0 ; i < 256 ; i ++ ) { \n mpic [ i ] = qdev_get_gpio_in ( dev , i ) ; \n } \n memory_region_add_subregion ( ccsr , MPC8544_MPIC_REGS_OFFSET , \n s -> mmio [ 0 ] . memory ) ; \n return mpic ; \n }", "idx": 7480}
{"project": "qemu", "commit_id": "33577b47c64435fcc2a1bc01c7e82534256f1fc3", "target": 0, "func": "CharDriverState * qemu_chr_new ( const char * label , const char * filename , void ( * init ) ( struct CharDriverState * s ) ) \n { \n const char * p ; \n CharDriverState * chr ; \n QemuOpts * opts ; \n Error * err = NULL ; \n if ( strstart ( filename , \" \" , & p ) ) { \n return qemu_chr_find ( p ) ; \n } \n opts = qemu_chr_parse_compat ( label , filename ) ; \n if ( ! opts ) \n return NULL ; \n chr = qemu_chr_new_from_opts ( opts , init , & err ) ; \n if ( err ) { \n error_report_err ( err ) ; \n } \n if ( chr && qemu_opt_get_bool ( opts , \" \" , 0 ) ) { \n qemu_chr_fe_claim_no_fail ( chr ) ; \n monitor_init ( chr , MONITOR_USE_READLINE ) ; \n } \n return chr ; \n }", "idx": 7481}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "int qdev_prop_check_globals ( void ) \n { \n GList * l ; \n int ret = 0 ; \n for ( l = global_props ; l ; l = l -> next ) { \n GlobalProperty * prop = l -> data ; \n ObjectClass * oc ; \n DeviceClass * dc ; \n if ( prop -> used ) { \n continue ; \n } \n if ( ! prop -> user_provided ) { \n continue ; \n } \n oc = object_class_by_name ( prop -> driver ) ; \n oc = object_class_dynamic_cast ( oc , TYPE_DEVICE ) ; \n if ( ! oc ) { \n error_report ( \" \" , \n prop -> driver , prop -> property ) ; \n ret = 1 ; \n continue ; \n } \n dc = DEVICE_CLASS ( oc ) ; \n if ( ! dc -> hotpluggable && ! prop -> used ) { \n error_report ( \" \" , \n prop -> driver , prop -> property , prop -> value ) ; \n ret = 1 ; \n continue ; \n } \n } \n return ret ; \n }", "idx": 7491}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make ( SDState * sd , \n uint8_t * response , uint32_t last_status ) \n { \n uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND ; \n uint32_t status ; \n status = ( sd -> card_status & ~ mask ) | ( last_status & mask ) ; \n sd -> card_status &= ~ CARD_STATUS_C | APP_CMD ; \n response [ 0 ] = ( status >> 24 ) & 0xff ; \n response [ 1 ] = ( status >> 16 ) & 0xff ; \n response [ 2 ] = ( status >> 8 ) & 0xff ; \n response [ 3 ] = ( status >> 0 ) & 0xff ; \n }", "idx": 7556}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState * qdev_try_create ( BusState * bus , const char * name ) \n { \n DeviceState * dev ; \n if ( object_class_by_name ( name ) == NULL ) { \n return NULL ; \n } \n dev = DEVICE ( object_new ( name ) ) ; \n if ( ! dev ) { \n return NULL ; \n } \n if ( ! bus ) { \n bus = sysbus_get_default ( ) ; \n } \n qdev_set_parent_bus ( dev , bus ) ; \n qdev_prop_set_globals ( dev ) ; \n return dev ; \n }", "idx": 7579}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "Visitor * qobject_input_visitor_new_keyval ( QObject * obj ) \n { \n QObjectInputVisitor * v = qobject_input_visitor_base_new ( obj ) ; \n v -> visitor . type_int64 = qobject_input_type_int64_keyval ; \n v -> visitor . type_uint64 = qobject_input_type_uint64_keyval ; \n v -> visitor . type_bool = qobject_input_type_bool_keyval ; \n v -> visitor . type_str = qobject_input_type_str ; \n v -> visitor . type_number = qobject_input_type_number_keyval ; \n v -> visitor . type_any = qobject_input_type_any ; \n v -> visitor . type_null = qobject_input_type_null ; \n v -> visitor . type_size = qobject_input_type_size_keyval ; \n return & v -> visitor ; \n }", "idx": 7590}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void * pl080_init ( uint32_t base , qemu_irq irq , int nchannels ) \n { \n int iomemtype ; \n pl080_state * s ; \n s = ( pl080_state * ) qemu_mallocz ( sizeof ( pl080_state ) ) ; \n iomemtype = cpu_register_io_memory ( 0 , pl080_readfn , \n pl080_writefn , s ) ; \n cpu_register_physical_memory ( base , 0x00000fff , iomemtype ) ; \n s -> base = base ; \n s -> irq = irq ; \n s -> nchannels = nchannels ; \n return s ; \n }", "idx": 7596}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "void * g_realloc ( void * ptr , size_t size ) \n { \n size_t old_size , copy ; \n void * new_ptr ; \n if ( ! ptr ) \n return g_malloc ( size ) ; \n old_size = * ( size_t * ) ( ( char * ) ptr - 16 ) ; \n copy = old_size < size ? old_size : size ; \n new_ptr = g_malloc ( size ) ; \n memcpy ( new_ptr , ptr , copy ) ; \n g_free ( ptr ) ; \n return new_ptr ; \n }", "idx": 7662}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init ( DeviceState * dev , I82378State * s ) \n { \n ISABus * isabus = DO_UPCAST ( ISABus , qbus , qdev_get_child_bus ( dev , \" \" ) ) ; \n ISADevice * pit ; \n qemu_irq * out0_irq ; \n qdev_init_gpio_out ( dev , s -> out , 2 ) ; \n qdev_init_gpio_in ( dev , i82378_request_pic_irq , 16 ) ; \n out0_irq = qemu_allocate_irqs ( i82378_request_out0_irq , s , 1 ) ; \n s -> i8259 = i8259_init ( isabus , * out0_irq ) ; \n isa_bus_irqs ( isabus , s -> i8259 ) ; \n pit = pit_init ( isabus , 0x40 , 0 , NULL ) ; \n pcspk_init ( isabus , pit ) ; \n DMA_init ( 1 , & s -> out [ 1 ] ) ; \n isa_create_simple ( isabus , \" \" ) ; \n isa_create_simple ( isabus , \" \" ) ; \n }", "idx": 7732}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QString * qstring_from_substr ( const char * str , int start , int end ) \n { \n QString * qstring ; \n qstring = g_malloc ( sizeof ( * qstring ) ) ; \n qstring -> length = end - start + 1 ; \n qstring -> capacity = qstring -> length ; \n qstring -> string = g_malloc ( qstring -> capacity + 1 ) ; \n memcpy ( qstring -> string , str + start , qstring -> length ) ; \n qstring -> string [ qstring -> length ] = 0 ; \n QOBJECT_INIT ( qstring , & qstring_type ) ; \n return qstring ; \n }", "idx": 7754}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier ( void ) \n { \n EventNotifierTestData data = { . n = 0 , . active = 1 } ; \n event_notifier_init ( & data . e , false ) ; \n aio_set_event_notifier ( ctx , & data . e , event_ready_cb ) ; \n g_assert ( g_main_context_iteration ( NULL , false ) ) ; \n g_assert_cmpint ( data . n , == , 0 ) ; \n g_assert_cmpint ( data . active , == , 1 ) ; \n event_notifier_set ( & data . e ) ; \n g_assert ( g_main_context_iteration ( NULL , false ) ) ; \n g_assert_cmpint ( data . n , == , 1 ) ; \n g_assert_cmpint ( data . active , == , 0 ) ; \n while ( g_main_context_iteration ( NULL , false ) ) ; \n g_assert_cmpint ( data . n , == , 1 ) ; \n g_assert_cmpint ( data . active , == , 0 ) ; \n aio_set_event_notifier ( ctx , & data . e , NULL ) ; \n while ( g_main_context_iteration ( NULL , false ) ) ; \n g_assert_cmpint ( data . n , == , 1 ) ; \n event_notifier_cleanup ( & data . e ) ; \n }", "idx": 7761}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base ( BlockDriverState * top , \n BlockDriverState * base , \n int64_t sector_num , \n int nb_sectors , int * pnum ) \n { \n BlockDriverState * intermediate ; \n int ret , n ; \n ret = bdrv_co_is_allocated ( top , sector_num , nb_sectors , & n ) ; \n if ( ret ) { \n * pnum = n ; \n return ret ; \n } \n intermediate = top -> backing_hd ; \n while ( intermediate != base ) { \n int pnum_inter ; \n ret = bdrv_co_is_allocated ( intermediate , sector_num , nb_sectors , \n & pnum_inter ) ; \n if ( ret < 0 ) { \n return ret ; \n } else if ( ret ) { \n * pnum = pnum_inter ; \n return 0 ; \n } \n if ( n > pnum_inter ) { \n n = pnum_inter ; \n } \n intermediate = intermediate -> backing_hd ; \n } \n * pnum = n ; \n return 1 ; \n }", "idx": 7762}
{"project": "qemu", "commit_id": "75f19f8c3006970632303b49043b075dc4fe922e", "target": 0, "func": "static void megasas_unmap_frame ( MegasasState * s , MegasasCmd * cmd ) \n { \n PCIDevice * p = PCI_DEVICE ( s ) ; \n pci_dma_unmap ( p , cmd -> frame , cmd -> pa_size , 0 , 0 ) ; \n cmd -> frame = NULL ; \n cmd -> pa = 0 ; \n clear_bit ( cmd -> index , s -> frame_map ) ; \n }", "idx": 7779}
{"project": "qemu", "commit_id": "02cb7f3a256517cbf3136caff2863fbafc57b540", "target": 0, "func": "int v9fs_co_open2 ( V9fsState * s , V9fsFidState * fidp , char * fullname , gid_t gid , \n int flags , int mode ) \n { \n int err ; \n FsCred cred ; \n cred_init ( & cred ) ; \n cred . fc_mode = mode & 07777 ; \n cred . fc_uid = fidp -> uid ; \n cred . fc_gid = gid ; \n v9fs_co_run_in_worker ( \n { \n fidp -> fs . fd = s -> ops -> open2 ( & s -> ctx , fullname , flags , & cred ) ; \n err = 0 ; \n if ( fidp -> fs . fd == -1 ) { \n err = - errno ; \n } \n } ) ; \n if ( ! err ) { \n total_open_fd ++ ; \n if ( total_open_fd > open_fd_hw ) { \n v9fs_reclaim_fd ( s ) ; \n } \n } \n return err ; \n }", "idx": 7780}
{"project": "qemu", "commit_id": "bbe2f399b222f1f2fcf5cd2ea78e4f5c9a66c64e", "target": 0, "func": "static int receive_filter ( VirtIONet * n , const uint8_t * buf , int size ) \n { \n static const uint8_t bcast [ ] = { 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; \n static const uint8_t vlan [ ] = { 0x81 , 0x00 } ; \n uint8_t * ptr = ( uint8_t * ) buf ; \n int i ; \n if ( n -> promisc ) \n return 1 ; \n if ( ! memcmp ( & ptr [ 12 ] , vlan , sizeof ( vlan ) ) ) { \n int vid = be16_to_cpup ( ( uint16_t * ) ( ptr + 14 ) ) & 0xfff ; \n if ( ! ( n -> vlans [ vid >> 5 ] & ( 1U << ( vid & 0x1f ) ) ) ) \n return 0 ; \n } \n if ( ( ptr [ 0 ] & 1 ) && n -> allmulti ) \n return 1 ; \n if ( ! memcmp ( ptr , bcast , sizeof ( bcast ) ) ) \n return 1 ; \n if ( ! memcmp ( ptr , n -> mac , ETH_ALEN ) ) \n return 1 ; \n for ( i = 0 ; i < n -> mac_table . in_use ; i ++ ) { \n if ( ! memcmp ( ptr , & n -> mac_table . macs [ i * ETH_ALEN ] , ETH_ALEN ) ) \n return 1 ; \n } \n return 0 ; \n }", "idx": 7782}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_tlbsx_440 ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n #else \n TCGv t0 ; \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; \n return ; \n } \n t0 = tcg_temp_new ( ) ; \n gen_addr_reg_index ( ctx , t0 ) ; \n gen_helper_440_tlbsx ( cpu_gpr [ rD ( ctx -> opcode ) ] , cpu_env , t0 ) ; \n tcg_temp_free ( t0 ) ; \n if ( Rc ( ctx -> opcode ) ) { \n int l1 = gen_new_label ( ) ; \n tcg_gen_trunc_tl_i32 ( cpu_crf [ 0 ] , cpu_so ) ; \n tcg_gen_brcondi_tl ( TCG_COND_EQ , cpu_gpr [ rD ( ctx -> opcode ) ] , -1 , l1 ) ; \n tcg_gen_ori_i32 ( cpu_crf [ 0 ] , cpu_crf [ 0 ] , 0x02 ) ; \n gen_set_label ( l1 ) ; \n } \n #endif \n }", "idx": 7814}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "GSource * iohandler_get_g_source ( void ) \n { \n iohandler_init ( ) ; \n return aio_get_g_source ( iohandler_ctx ) ; \n }", "idx": 7828}
{"project": "qemu", "commit_id": "c1076c3e13a86140cc2ba29866512df8460cc7c2", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_rot0 ( PXA2xxLCDState * s , \n hwaddr addr , int * miny , int * maxy ) \n { \n DisplaySurface * surface = qemu_console_surface ( s -> con ) ; \n int src_width , dest_width ; \n drawfn fn = NULL ; \n if ( s -> dest_width ) \n fn = s -> line_fn [ s -> transp ] [ s -> bpp ] ; \n if ( ! fn ) \n return ; \n src_width = ( s -> xres + 3 ) & ~ 3 ; \n if ( s -> bpp == pxa_lcdc_19pbpp || s -> bpp == pxa_lcdc_18pbpp ) \n src_width *= 3 ; \n else if ( s -> bpp > pxa_lcdc_16bpp ) \n src_width *= 4 ; \n else if ( s -> bpp > pxa_lcdc_8bpp ) \n src_width *= 2 ; \n dest_width = s -> xres * s -> dest_width ; \n * miny = 0 ; \n framebuffer_update_display ( surface , s -> sysmem , \n addr , s -> xres , s -> yres , \n src_width , dest_width , s -> dest_width , \n s -> invalidated , \n fn , s -> dma_ch [ 0 ] . palette , miny , maxy ) ; \n }", "idx": 7866}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dmar_q35 ( GArray * table_data , GArray * linker )  \n { \n int dmar_start = table_data -> len ; \n AcpiTableDmar * dmar ; \n AcpiDmarHardwareUnit * drhd ; \n dmar = acpi_data_push ( table_data , sizeof ( * dmar ) ) ; \n dmar -> host_address_width = VTD_HOST_ADDRESS_WIDTH - 1 ; \n dmar -> flags = 0 ; \n drhd = acpi_data_push ( table_data , sizeof ( * drhd ) ) ; \n drhd -> type = cpu_to_le16 ( ACPI_DMAR_TYPE_HARDWARE_UNIT ) ; \n drhd -> length = cpu_to_le16 ( sizeof ( * drhd ) ) ; \n drhd -> flags = ACPI_DMAR_INCLUDE_PCI_ALL ; \n drhd -> pci_segment = cpu_to_le16 ( 0 ) ; \n drhd -> address = cpu_to_le64 ( Q35_HOST_BRIDGE_IOMMU_ADDR ) ; \n build_header ( linker , table_data , ( void * ) ( table_data -> data + dmar_start ) , \n \" \" , table_data -> len - dmar_start , 1 , NULL ) ; \n }", "idx": 7869}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_flashcfg_write ( void * opaque , target_phys_addr_t offset , \n uint64_t value , unsigned size ) \n { \n mv88w8618_flashcfg_state * s = opaque ; \n switch ( offset ) { \n case MP_FLASHCFG_CFGR0 : \n s -> cfgr0 = value ; \n break ; \n } \n }", "idx": 7874}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_get_fd ( void * opaque ) \n { \n QEMUFileRDMA * rfile = opaque ; \n RDMAContext * rdma = rfile -> rdma ; \n return rdma -> comp_channel -> fd ; \n }", "idx": 7881}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void fd_coroutine_enter ( void * opaque ) \n { \n FDYieldUntilData * data = opaque ; \n qemu_set_fd_handler ( data -> fd , NULL , NULL , NULL ) ; \n qemu_coroutine_enter ( data -> co , NULL ) ; \n }", "idx": 7893}
{"project": "qemu", "commit_id": "3ad493fc5ea38c005670adc5933058a28ccabdd4", "target": 0, "func": "int cpu_arm_handle_mmu_fault ( CPUState * env , target_ulong address , \n int access_type , int mmu_idx , int is_softmmu ) \n { \n uint32_t phys_addr ; \n target_ulong page_size ; \n int prot ; \n int ret , is_user ; \n is_user = mmu_idx == MMU_USER_IDX ; \n ret = get_phys_addr ( env , address , access_type , is_user , & phys_addr , & prot , \n & page_size ) ; \n if ( ret == 0 ) { \n phys_addr &= ~ ( uint32_t ) 0x3ff ; \n address &= ~ ( uint32_t ) 0x3ff ; \n tlb_set_page ( env , address , phys_addr , prot | PAGE_EXEC , mmu_idx , \n page_size ) ; \n return 0 ; \n } \n if ( access_type == 2 ) { \n env -> cp15 . c5_insn = ret ; \n env -> cp15 . c6_insn = address ; \n env -> exception_index = EXCP_PREFETCH_ABORT ; \n } else { \n env -> cp15 . c5_data = ret ; \n if ( access_type == 1 && arm_feature ( env , ARM_FEATURE_V6 ) ) \n env -> cp15 . c5_data |= ( 1 << 11 ) ; \n env -> cp15 . c6_data = address ; \n env -> exception_index = EXCP_DATA_ABORT ; \n } \n return 1 ; \n }", "idx": 7972}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr ( QEMUFile * f , void * opaque , size_t size ) \n { \n ARMCPU * cpu = opaque ; \n CPUARMState * env = & cpu -> env ; \n uint32_t val = qemu_get_be32 ( f ) ; \n env -> aarch64 = ( ( val & PSTATE_nRW ) == 0 ) ; \n if ( is_a64 ( env ) ) { \n pstate_write ( env , val ) ; \n return 0 ; \n } \n env -> uncached_cpsr = val & CPSR_M ; \n cpsr_write ( env , val , 0xffffffff , CPSRWriteRaw ) ; \n return 0 ; \n }", "idx": 7982}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "struct omap_l4_s * omap_l4_init ( target_phys_addr_t base , int ta_num ) \n { \n struct omap_l4_s * bus = g_malloc0 ( \n sizeof ( * bus ) + ta_num * sizeof ( * bus -> ta ) ) ; \n bus -> ta_num = ta_num ; \n bus -> base = base ; \n #ifdef L4_MUX_HACK \n omap_l4_io_entries = 1 ; \n omap_l4_io_entry = g_malloc0 ( 125 * sizeof ( * omap_l4_io_entry ) ) ; \n omap_cpu_io_entry = \n cpu_register_io_memory ( omap_l4_io_readfn , \n omap_l4_io_writefn , bus , DEVICE_NATIVE_ENDIAN ) ; \n # define L4_PAGES \t(0xb4000 / TARGET_PAGE_SIZE)  \n  \n  omap_l4_io_readb_fn = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n omap_l4_io_readh_fn = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n omap_l4_io_readw_fn = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n omap_l4_io_writeb_fn = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n omap_l4_io_writeh_fn = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n omap_l4_io_writew_fn = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n omap_l4_io_opaque = g_malloc0 ( sizeof ( void * ) * L4_PAGES ) ; \n #endif \n return bus ; \n }", "idx": 8010}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qbus_list_bus ( DeviceState * dev , char * dest , int len ) \n { \n BusState * child ; \n const char * sep = \" \" ; \n int pos = 0 ; \n pos += snprintf ( dest + pos , len - pos , \" \\\" \\\" \" , \n dev -> id ? dev -> id : dev -> info -> name ) ; \n LIST_FOREACH ( child , & dev -> child_bus , sibling )  { \n pos += snprintf ( dest + pos , len - pos , \" \\\" \\\" \" , sep , child -> name ) ; \n sep = \" \" ; \n } \n }", "idx": 8018}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "func": "static void cubieboard_init ( QEMUMachineInitArgs * args ) \n { \n CubieBoardState * s = g_new ( CubieBoardState , 1 ) ; \n Error * err = NULL ; \n s -> a10 = AW_A10 ( object_new ( TYPE_AW_A10 ) ) ; \n object_property_set_bool ( OBJECT ( s -> a10 ) , true , \" \" , & err ) ; \n if ( err != NULL ) { \n error_report ( \" \\n \" , \n error_get_pretty ( err ) ) ; \n exit ( 1 ) ; \n } \n memory_region_init_ram ( & s -> sdram , NULL , \" \" , args -> ram_size ) ; \n vmstate_register_ram_global ( & s -> sdram ) ; \n memory_region_add_subregion ( get_system_memory ( ) , AW_A10_SDRAM_BASE , \n & s -> sdram ) ; \n cubieboard_binfo . ram_size = args -> ram_size ; \n cubieboard_binfo . kernel_filename = args -> kernel_filename ; \n cubieboard_binfo . kernel_cmdline = args -> kernel_cmdline ; \n arm_load_kernel ( & s -> a10 -> cpu , & cubieboard_binfo ) ; \n }", "idx": 8049}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void esp_init ( target_phys_addr_t espaddr , int it_shift , \n ESPDMAMemoryReadWriteFunc dma_memory_read , \n ESPDMAMemoryReadWriteFunc dma_memory_write , \n void * dma_opaque , qemu_irq irq , qemu_irq * reset , \n qemu_irq * dma_enable ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n SysBusESPState * sysbus ; \n ESPState * esp ; \n dev = qdev_create ( NULL , \" \" ) ; \n sysbus = DO_UPCAST ( SysBusESPState , busdev . qdev , dev ) ; \n esp = & sysbus -> esp ; \n esp -> dma_memory_read = dma_memory_read ; \n esp -> dma_memory_write = dma_memory_write ; \n esp -> dma_opaque = dma_opaque ; \n sysbus -> it_shift = it_shift ; \n esp -> dma_enabled = 1 ; \n qdev_init_nofail ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n sysbus_connect_irq ( s , 0 , irq ) ; \n sysbus_mmio_map ( s , 0 , espaddr ) ; \n * reset = qdev_get_gpio_in ( dev , 0 ) ; \n * dma_enable = qdev_get_gpio_in ( dev , 1 ) ; \n }", "idx": 8071}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error ( QIOTask * task , \n Error * * errp ) \n { \n if ( task -> err ) { \n error_propagate ( errp , task -> err ) ; \n return true ; \n } \n return false ; \n }", "idx": 8111}
{"project": "qemu", "commit_id": "f7b879e072ae6839b1b1d1312f48fa7f256397e2", "target": 1, "func": "static void device_unparent ( Object * obj ) \n { \n DeviceState * dev = DEVICE ( obj ) ; \n BusState * bus ; \n if ( dev -> realized ) { \n object_property_set_bool ( obj , false , \" \" , NULL ) ; \n } \n while ( dev -> num_child_bus ) { \n bus = QLIST_FIRST ( & dev -> child_bus ) ; \n object_unparent ( OBJECT ( bus ) ) ; \n } \n if ( dev -> parent_bus ) { \n bus_remove_child ( dev -> parent_bus , dev ) ; \n object_unref ( OBJECT ( dev -> parent_bus ) ) ; \n dev -> parent_bus = NULL ; \n } \n if ( dev -> pending_deleted_event ) { \n g_assert ( dev -> canonical_path ) ; \n qapi_event_send_device_deleted ( ! ! dev -> id , dev -> id , dev -> canonical_path , \n & error_abort ) ; \n g_free ( dev -> canonical_path ) ; \n dev -> canonical_path = NULL ; \n } \n }", "idx": 8130}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QBool * qbool_from_bool ( bool value ) \n { \n QBool * qb ; \n qb = g_malloc ( sizeof ( * qb ) ) ; \n qb -> value = value ; \n QOBJECT_INIT ( qb , & qbool_type ) ; \n return qb ; \n }", "idx": 8134}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame ( int usig , struct emulated_sigaction * ka , \n target_siginfo_t * info , \n target_sigset_t * set , CPUState * env ) \n { \n struct rt_sigframe * frame = get_sigframe ( ka , env , sizeof ( * frame ) ) ; \n int err = 0 ; \n #if 0  \n  \n  if ( ! access_ok ( VERIFY_WRITE , frame , sizeof ( * frame ) ) ) \n return 1 ; \n #endif \n __put_user_error ( & frame -> info , ( target_ulong * ) & frame -> pinfo , err ) ; \n __put_user_error ( & frame -> uc , ( target_ulong * ) & frame -> puc , err ) ; \n err |= copy_siginfo_to_user ( & frame -> info , info ) ; \n err |= __clear_user ( & frame -> uc , offsetof ( struct ucontext , uc_mcontext ) ) ; \n err |= setup_sigcontext ( & frame -> uc . uc_mcontext , \n env , set -> sig [ 0 ] ) ; \n err |= __copy_to_user ( & frame -> uc . uc_sigmask , set , sizeof ( * set ) ) ; \n if ( err == 0 ) \n err = setup_return ( env , ka , & frame -> retcode , frame , usig ) ; \n if ( err == 0 ) { \n env -> regs [ 1 ] = ( target_ulong ) frame -> pinfo ; \n env -> regs [ 2 ] = ( target_ulong ) frame -> puc ; \n } \n }", "idx": 8145}
{"project": "qemu", "commit_id": "2e50326c44c802ca9b9d591341085e49208927be", "target": 1, "func": "void tap_fd_set_offload ( int fd , int csum , int tso4 , \n int tso6 , int ecn , int ufo ) \n { \n unsigned int offload = 0 ; \n if ( csum ) { \n offload |= TUN_F_CSUM ; \n if ( tso4 ) \n offload |= TUN_F_TSO4 ; \n if ( tso6 ) \n offload |= TUN_F_TSO6 ; \n if ( ( tso4 || tso6 ) && ecn ) \n offload |= TUN_F_TSO_ECN ; \n if ( ufo ) \n offload |= TUN_F_UFO ; \n if ( ioctl ( fd , TUNSETOFFLOAD , offload ) != 0 ) { \n offload &= ~ TUN_F_UFO ; \n if ( ioctl ( fd , TUNSETOFFLOAD , offload ) != 0 ) { \n fprintf ( stderr , \" \\n \" , \n strerror ( errno ) ) ;", "idx": 8158}
{"project": "qemu", "commit_id": "29851ee7c8bd3fb8542e21cd0270c73132590350", "target": 1, "func": "int main ( ) \n { \n int rd , rt , dsp ; \n int result , resultdsp ; \n rt = 0x12345678 ; \n result = 0xA000C000 ; \n resultdsp = 1 ; \n __asm \n ( \" \\n \\t \" \n \" \\n \\t \" \n : \" \" ( rd ) , \" \" ( dsp ) \n : \" \" ( rt ) \n ) ; \n dsp = ( dsp >> 22 ) & 0x01 ; \n assert ( dsp == resultdsp ) ; \n assert ( rd == result ) ; \n return 0 ; \n }", "idx": 8209}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop ( RunState state ) \n { \n if ( qemu_in_vcpu_thread ( ) ) { \n qemu_system_vmstop_request ( state ) ; \n cpu_stop_current ( ) ; \n return 0 ; \n } \n return do_vm_stop ( state ) ; \n }", "idx": 8221}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "static unsigned do_stfle ( CPUS390XState * env , uint64_t words [ MAX_STFL_WORDS ] ) \n { \n S390CPU * cpu = s390_env_get_cpu ( env ) ; \n const unsigned long * features = cpu -> model -> features ; \n unsigned max_bit = 0 ; \n S390Feat feat ; \n memset ( words , 0 , sizeof ( uint64_t ) * MAX_STFL_WORDS ) ; \n if ( test_bit ( S390_FEAT_ZARCH , features ) ) { \n words [ 0 ] = 1ull << ( 63 - 2 ) ; \n } \n for ( feat = find_first_bit ( features , S390_FEAT_MAX ) ; \n feat < S390_FEAT_MAX ; \n feat = find_next_bit ( features , S390_FEAT_MAX , feat + 1 ) ) { \n const S390FeatDef * def = s390_feat_def ( feat ) ; \n if ( def -> type == S390_FEAT_TYPE_STFL ) { \n unsigned bit = def -> bit ; \n if ( bit > max_bit ) { \n max_bit = bit ; \n } \n assert ( bit / 64 < MAX_STFL_WORDS ) ; \n words [ bit / 64 ] |= 1ULL << ( 63 - bit % 64 ) ; \n } \n } \n return max_bit / 64 ; \n }", "idx": 8247}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_establish_connection ( BlockDriverState * bs ) \n { \n BDRVNBDState * s = bs -> opaque ; \n int sock ; \n int ret ; \n off_t size ; \n size_t blocksize ; \n if ( s -> host_spec [ 0 ] == ' ' ) { \n sock = unix_socket_outgoing ( s -> host_spec ) ; \n } else { \n sock = tcp_socket_outgoing_spec ( s -> host_spec ) ; \n } \n if ( sock < 0 ) { \n logout ( \" \\n \" ) ; \n return - errno ; \n } \n ret = nbd_receive_negotiate ( sock , s -> export_name , & s -> nbdflags , & size , \n & blocksize ) ; \n if ( ret < 0 ) { \n logout ( \" \\n \" ) ; \n closesocket ( sock ) ; \n return - errno ; \n } \n socket_set_nonblock ( sock ) ; \n qemu_aio_set_fd_handler ( s -> sock , nbd_reply_ready , NULL , \n nbd_have_request , NULL , s ) ; \n s -> sock = sock ; \n s -> size = size ; \n s -> blocksize = blocksize ; \n logout ( \" \\n \" ) ; \n return 0 ; \n }", "idx": 8254}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU * s390x_new_cpu ( const char * cpu_model , uint32_t core_id , Error * * errp ) \n { \n S390CPU * cpu ; \n Error * err = NULL ; \n cpu = cpu_s390x_create ( cpu_model , & err ) ; \n if ( err != NULL ) { \n goto out ; \n } \n object_property_set_int ( OBJECT ( cpu ) , core_id , \" \" , & err ) ; \n if ( err != NULL ) { \n goto out ; \n } \n object_property_set_bool ( OBJECT ( cpu ) , true , \" \" , & err ) ; \n out : \n if ( err ) { \n error_propagate ( errp , err ) ; \n object_unref ( OBJECT ( cpu ) ) ; \n cpu = NULL ; \n } \n return cpu ; \n }", "idx": 8291}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout ( AioContext * ctx )  \n { \n int64_t deadline ; \n int timeout = -1 ; \n QEMUBH * bh ; \n for ( bh = atomic_rcu_read ( & ctx -> first_bh ) ; bh ; \n bh = atomic_rcu_read ( & bh -> next ) ) { \n if ( bh -> scheduled ) { \n if ( bh -> idle ) { \n timeout = 10000000 ; \n } else { \n return 0 ; \n } \n } \n } \n deadline = timerlistgroup_deadline_ns ( & ctx -> tlg ) ; \n if ( deadline == 0 ) { \n return 0 ; \n } else { \n return qemu_soonest_timeout ( timeout , deadline ) ; \n } \n }", "idx": 8296}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize_interface ( TypeImpl * ti , const char * parent ) \n { \n InterfaceClass * new_iface ; \n TypeInfo info = { } ; \n TypeImpl * iface_impl ; \n info . parent = parent ; \n info . name = g_strdup_printf ( \" \" , ti -> name , info . parent ) ; \n info . abstract = true ; \n iface_impl = type_register ( & info ) ; \n type_initialize ( iface_impl ) ; \n g_free ( ( char * ) info . name ) ; \n new_iface = ( InterfaceClass * ) iface_impl -> class ; \n new_iface -> concrete_class = ti -> class ; \n ti -> class -> interfaces = g_slist_append ( ti -> class -> interfaces , \n iface_impl -> class ) ; \n }", "idx": 8357}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t nand_read ( void * opaque , target_phys_addr_t addr , unsigned size ) \n { \n struct nand_state_t * s = opaque ; \n uint32_t r ; \n int rdy ; \n r = nand_getio ( s -> nand ) ; \n nand_getpins ( s -> nand , & rdy ) ; \n s -> rdy = rdy ; \n DNAND ( printf ( \" \\n \" , __func__ , addr , r ) ) ; \n return r ; \n }", "idx": 8380}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed ( int64_t value , Error * * errp ) \n { \n MigrationState * s ; \n if ( value < 0 ) { \n value = 0 ; \n } \n s = migrate_get_current ( ) ; \n s -> bandwidth_limit = value ; \n qemu_file_set_rate_limit ( s -> file , s -> bandwidth_limit ) ; \n }", "idx": 8409}
{"project": "qemu", "commit_id": "3d5d319e1221082974711af1d09d82f0755c1698", "target": 1, "func": "void block_job_resume_all ( void ) \n { \n BlockJob * job = NULL ; \n while ( ( job = block_job_next ( job ) ) ) { \n AioContext * aio_context = blk_get_aio_context ( job -> blk ) ; \n aio_context_acquire ( aio_context ) ; \n block_job_resume ( job ) ; \n aio_context_release ( aio_context ) ; \n } \n }", "idx": 8412}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8 ( QEMUFile * f , void * pv , size_t size ) \n { \n uint8_t * v = pv ; \n qemu_put_8s ( f , v ) ; \n }", "idx": 8431}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static RemoveResult remove_hpte ( PowerPCCPU * cpu , target_ulong ptex , \n target_ulong avpn , \n target_ulong flags , \n target_ulong * vp , target_ulong * rp ) \n { \n CPUPPCState * env = & cpu -> env ; \n uint64_t token ; \n target_ulong v , r , rb ; \n if ( ! valid_pte_index ( env , ptex ) ) { \n return REMOVE_PARM ; \n } \n token = ppc_hash64_start_access ( cpu , ptex ) ; \n v = ppc_hash64_load_hpte0 ( cpu , token , 0 ) ; \n r = ppc_hash64_load_hpte1 ( cpu , token , 0 ) ; \n ppc_hash64_stop_access ( token ) ; \n if ( ( v & HPTE64_V_VALID ) == 0 || \n ( ( flags & H_AVPN ) && ( v & ~ 0x7fULL ) != avpn ) || \n ( ( flags & H_ANDCOND ) && ( v & avpn ) != 0 ) ) { \n return REMOVE_NOT_FOUND ; \n } \n * vp = v ; \n * rp = r ; \n ppc_hash64_store_hpte ( cpu , ptex , HPTE64_V_HPTE_DIRTY , 0 ) ; \n rb = compute_tlbie_rb ( v , r , ptex ) ; \n ppc_tlb_invalidate_one ( env , rb ) ; \n return REMOVE_SUCCESS ; \n }", "idx": 8435}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu ( CPUState * cpu ) \n { \n char thread_name [ VCPU_THREAD_NAME_SIZE ] ; \n static QemuCond * tcg_halt_cond ; \n static QemuThread * tcg_cpu_thread ; \n if ( ! tcg_cpu_thread ) { \n cpu -> thread = g_malloc0 ( sizeof ( QemuThread ) ) ; \n cpu -> halt_cond = g_malloc0 ( sizeof ( QemuCond ) ) ; \n qemu_cond_init ( cpu -> halt_cond ) ; \n tcg_halt_cond = cpu -> halt_cond ; \n snprintf ( thread_name , VCPU_THREAD_NAME_SIZE , \" \" , \n cpu -> cpu_index ) ; \n qemu_thread_create ( cpu -> thread , thread_name , qemu_tcg_cpu_thread_fn , \n cpu , QEMU_THREAD_JOINABLE ) ; \n #ifdef _WIN32 \n cpu -> hThread = qemu_thread_get_handle ( cpu -> thread ) ; \n #endif \n while ( ! cpu -> created ) { \n qemu_cond_wait ( & qemu_cpu_cond , & qemu_global_mutex ) ; \n } \n tcg_cpu_thread = cpu -> thread ; \n } else { \n cpu -> thread = tcg_cpu_thread ; \n cpu -> halt_cond = tcg_halt_cond ; \n } \n }", "idx": 8457}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_write_buf ( VncState * vs , const uint8_t * data , size_t datalen ) \n { \n ssize_t ret ; \n #ifdef CONFIG_VNC_TLS \n if ( vs -> tls . session ) { \n ret = vnc_client_write_tls ( & vs -> tls . session , data , datalen ) ; \n } else { \n #endif  \n  \n  \n  ret = send ( vs -> csock , ( const void * ) data , datalen , 0 ) ; \n #ifdef CONFIG_VNC_TLS  \n } \n #endif \n VNC_DEBUG ( \" \\n \" , data , datalen , ret ) ; \n return vnc_client_io_error ( vs , ret , socket_error ( ) ) ; \n }", "idx": 8466}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "func": "static int memory_access_size ( MemoryRegion * mr , unsigned l , hwaddr addr ) \n { \n unsigned access_size_min = mr -> ops -> impl . min_access_size ; \n unsigned access_size_max = mr -> ops -> impl . max_access_size ; \n if ( access_size_min == 0 ) { \n access_size_min = 1 ; \n } \n if ( access_size_max == 0 ) { \n access_size_max = 4 ; \n } \n if ( ! mr -> ops -> impl . unaligned ) { \n unsigned align_size_max = addr & - addr ; \n if ( align_size_max != 0 && align_size_max < access_size_max ) { \n access_size_max = align_size_max ; \n } \n } \n if ( l > access_size_max ) { \n l = access_size_max ; \n } \n assert ( l >= access_size_min ) ; \n return l ; \n }", "idx": 8518}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save ( QEMUFile * f , void * opaque ) \n { \n stellaris_enet_state * s = ( stellaris_enet_state * ) opaque ; \n int i ; \n qemu_put_be32 ( f , s -> ris ) ; \n qemu_put_be32 ( f , s -> im ) ; \n qemu_put_be32 ( f , s -> rctl ) ; \n qemu_put_be32 ( f , s -> tctl ) ; \n qemu_put_be32 ( f , s -> thr ) ; \n qemu_put_be32 ( f , s -> mctl ) ; \n qemu_put_be32 ( f , s -> mdv ) ; \n qemu_put_be32 ( f , s -> mtxd ) ; \n qemu_put_be32 ( f , s -> mrxd ) ; \n qemu_put_be32 ( f , s -> np ) ; \n qemu_put_be32 ( f , s -> tx_fifo_len ) ; \n qemu_put_buffer ( f , s -> tx_fifo , sizeof ( s -> tx_fifo ) ) ; \n for ( i = 0 ; i < 31 ; i ++ ) { \n qemu_put_be32 ( f , s -> rx [ i ] . len ) ; \n qemu_put_buffer ( f , s -> rx [ i ] . data , sizeof ( s -> rx [ i ] . data ) ) ; \n } \n qemu_put_be32 ( f , s -> next_packet ) ; \n qemu_put_be32 ( f , s -> rx_fifo_offset ) ; \n }", "idx": 8526}
{"project": "qemu", "commit_id": "091b1108ca6d6e3bfaea5f095f219bf5ea8c316b", "target": 1, "func": "static int coroutine_fn cow_co_is_allocated ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors , int * num_same ) \n { \n int64_t bitnum = sector_num + sizeof ( struct cow_header_v2 ) * 8 ; \n uint64_t offset = ( bitnum / 8 ) & - BDRV_SECTOR_SIZE ; \n uint8_t bitmap [ BDRV_SECTOR_SIZE ] ; \n int ret ; \n int changed ; \n ret = bdrv_pread ( bs -> file , offset , & bitmap , sizeof ( bitmap ) ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n bitnum &= BITS_PER_BITMAP_SECTOR - 1 ; \n changed = cow_test_bit ( bitnum , bitmap ) ; \n * num_same = cow_find_streak ( bitmap , changed , bitnum , nb_sectors ) ; \n return changed ; \n }", "idx": 8543}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired ( QEMUTimerList * timer_list ) \n { \n int64_t expire_time ; \n if ( ! atomic_read ( & timer_list -> active_timers ) ) { \n return false ; \n } \n qemu_mutex_lock ( & timer_list -> active_timers_lock ) ; \n if ( ! timer_list -> active_timers ) { \n qemu_mutex_unlock ( & timer_list -> active_timers_lock ) ; \n return false ; \n } \n expire_time = timer_list -> active_timers -> expire_time ; \n qemu_mutex_unlock ( & timer_list -> active_timers_lock ) ; \n return expire_time < qemu_clock_get_ns ( timer_list -> clock -> type ) ; \n }", "idx": 8565}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static int ipoctal_init ( IPackDevice * ip ) \n { \n IPOctalState * s = IPOCTAL ( ip ) ; \n unsigned i ; \n for ( i = 0 ; i < N_CHANNELS ; i ++ ) { \n SCC2698Channel * ch = & s -> ch [ i ] ; \n ch -> ipoctal = s ; \n if ( ch -> devpath ) { \n const char chr_name [ ] = \" \" ; \n char label [ ARRAY_SIZE ( chr_name ) + 2 ] ; \n static int index ; \n snprintf ( label , sizeof ( label ) , \" \" , chr_name , index ) ; \n ch -> dev = qemu_chr_new ( label , ch -> devpath , NULL ) ; \n if ( ch -> dev ) { \n index ++ ; \n qemu_chr_add_handlers ( ch -> dev , hostdev_can_receive , \n hostdev_receive , hostdev_event , ch ) ; \n DPRINTF ( \" \\n \" , \n i , ch -> devpath , label ) ; \n } else { \n DPRINTF ( \" \\n \" , \n i , ch -> devpath ) ; \n } \n } \n } \n return 0 ; \n }", "idx": 8577}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_intersection ( AddrRange r1 , AddrRange r2 ) \n { \n uint64_t start = MAX ( r1 . start , r2 . start ) ; \n uint64_t end = MIN ( addrrange_end ( r1 ) - 1 , addrrange_end ( r2 ) - 1 ) ; \n return addrrange_make ( start , end - start + 1 ) ; \n }", "idx": 8592}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static int64_t do_strtosz ( const char * nptr , char * * end , \n const char default_suffix , int64_t unit ) \n { \n int64_t retval ; \n char * endptr ; \n unsigned char c ; \n int mul_required = 0 ; \n double val , mul , integral , fraction ; \n errno = 0 ; \n val = strtod ( nptr , & endptr ) ; \n if ( isnan ( val ) || endptr == nptr || errno != 0 ) { \n retval = - EINVAL ; \n goto out ; \n } \n fraction = modf ( val , & integral ) ; \n if ( fraction != 0 ) { \n mul_required = 1 ; \n } \n c = * endptr ; \n mul = suffix_mul ( c , unit ) ; \n if ( mul >= 0 ) { \n endptr ++ ; \n } else { \n mul = suffix_mul ( default_suffix , unit ) ; \n assert ( mul >= 0 ) ; \n } \n if ( mul == 1 && mul_required ) { \n retval = - EINVAL ; \n goto out ; \n } \n if ( ( val * mul >= INT64_MAX ) || val < 0 ) { \n retval = - ERANGE ; \n goto out ; \n } \n retval = val * mul ; \n out : \n if ( end ) { \n * end = endptr ; \n } else if ( * endptr ) { \n retval = - EINVAL ; \n } \n return retval ; \n }", "idx": 8673}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static uint32_t dcr_read_pob ( void * opaque , int dcrn ) \n { \n ppc4xx_pob_t * pob ; \n uint32_t ret ; \n pob = opaque ; \n switch ( dcrn ) { \n case POB0_BEAR : \n ret = pob -> bear ; \n break ; \n case POB0_BESR0 : \n case POB0_BESR1 : \n ret = pob -> besr [ dcrn - POB0_BESR0 ] ; \n break ; \n default : \n ret = 0 ; \n break ; \n } \n return ret ; \n }", "idx": 8720}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_erase ( OneNANDState * s , int sec , int num ) \n { \n uint8_t * blankbuf , * tmpbuf ; \n blankbuf = g_malloc ( 512 ) ; \n if ( ! blankbuf ) { \n return 1 ; \n } \n tmpbuf = g_malloc ( 512 ) ; \n if ( ! tmpbuf ) { \n g_free ( blankbuf ) ; \n return 1 ; \n } \n memset ( blankbuf , 0xff , 512 ) ; \n for ( ; num > 0 ; num -- , sec ++ ) { \n if ( s -> bdrv_cur ) { \n int erasesec = s -> secs_cur + ( sec >> 5 ) ; \n if ( bdrv_write ( s -> bdrv_cur , sec , blankbuf , 1 ) < 0 ) { \n goto fail ; \n } \n if ( bdrv_read ( s -> bdrv_cur , erasesec , tmpbuf , 1 ) < 0 ) { \n goto fail ; \n } \n memcpy ( tmpbuf + ( ( sec & 31 ) << 4 ) , blankbuf , 1 << 4 ) ; \n if ( bdrv_write ( s -> bdrv_cur , erasesec , tmpbuf , 1 ) < 0 ) { \n goto fail ; \n } \n } else { \n if ( sec + 1 > s -> secs_cur ) { \n goto fail ; \n } \n memcpy ( s -> current + ( sec << 9 ) , blankbuf , 512 ) ; \n memcpy ( s -> current + ( s -> secs_cur << 9 ) + ( sec << 4 ) , \n blankbuf , 1 << 4 ) ; \n } \n } \n g_free ( tmpbuf ) ; \n g_free ( blankbuf ) ; \n return 0 ; \n fail : \n g_free ( tmpbuf ) ; \n g_free ( blankbuf ) ; \n return 1 ; \n }", "idx": 8755}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t socket_read ( int sockfd , void * buff , size_t size ) \n { \n ssize_t retval , total = 0 ; \n while ( size ) { \n retval = read ( sockfd , buff , size ) ; \n if ( retval == 0 ) { \n return - EIO ; \n } \n if ( retval < 0 ) { \n if ( errno == EINTR ) { \n continue ; \n } \n return - errno ; \n } \n size -= retval ; \n buff += retval ; \n total += retval ; \n } \n return total ; \n }", "idx": 8846}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext * blk_get_aio_context ( BlockBackend * blk ) \n { \n return bdrv_get_aio_context ( blk -> bs ) ; \n }", "idx": 8855}
{"project": "qemu", "commit_id": "6f864e6ec8812d5a5525a7861ca599c6bcabdebe", "target": 0, "func": "static int vfio_load_rom ( VFIODevice * vdev ) \n { \n uint64_t size = vdev -> rom_size ; \n char name [ 32 ] ; \n off_t off = 0 , voff = vdev -> rom_offset ; \n ssize_t bytes ; \n void * ptr ; \n if ( vdev -> pdev . romfile || ! vdev -> pdev . rom_bar || ! size ) { \n return 0 ; \n } \n DPRINTF ( \" \\n \" , __func__ , vdev -> host . domain , \n vdev -> host . bus , vdev -> host . slot , vdev -> host . function ) ; \n snprintf ( name , sizeof ( name ) , \" \" , \n vdev -> host . domain , vdev -> host . bus , vdev -> host . slot , \n vdev -> host . function ) ; \n memory_region_init_ram ( & vdev -> pdev . rom , OBJECT ( vdev ) , name , size ) ; \n ptr = memory_region_get_ram_ptr ( & vdev -> pdev . rom ) ; \n memset ( ptr , 0xff , size ) ; \n while ( size ) { \n bytes = pread ( vdev -> fd , ptr + off , size , voff + off ) ; \n if ( bytes == 0 ) { \n break ; \n } else if ( bytes > 0 ) { \n off += bytes ; \n size -= bytes ; \n } else { \n if ( errno == EINTR || errno == EAGAIN ) { \n continue ; \n } \n error_report ( \" \" ) ; \n memory_region_destroy ( & vdev -> pdev . rom ) ; \n return - errno ; \n } \n } \n pci_register_bar ( & vdev -> pdev , PCI_ROM_SLOT , 0 , & vdev -> pdev . rom ) ; \n vdev -> pdev . has_rom = true ; \n return 0 ; \n }", "idx": 8858}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo * qmp_query_uuid ( Error * * errp ) \n { \n UuidInfo * info = g_malloc0 ( sizeof ( * info ) ) ; \n char uuid [ 64 ] ; \n snprintf ( uuid , sizeof ( uuid ) , UUID_FMT , qemu_uuid [ 0 ] , qemu_uuid [ 1 ] , \n qemu_uuid [ 2 ] , qemu_uuid [ 3 ] , qemu_uuid [ 4 ] , qemu_uuid [ 5 ] , \n qemu_uuid [ 6 ] , qemu_uuid [ 7 ] , qemu_uuid [ 8 ] , qemu_uuid [ 9 ] , \n qemu_uuid [ 10 ] , qemu_uuid [ 11 ] , qemu_uuid [ 12 ] , qemu_uuid [ 13 ] , \n qemu_uuid [ 14 ] , qemu_uuid [ 15 ] ) ; \n info -> UUID = g_strdup ( uuid ) ; \n return info ; \n }", "idx": 8866}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int s390_virtio_rng_init ( VirtIOS390Device * s390_dev ) \n { \n VirtIORNGS390 * dev = VIRTIO_RNG_S390 ( s390_dev ) ; \n DeviceState * vdev = DEVICE ( & dev -> vdev ) ; \n qdev_set_parent_bus ( vdev , BUS ( & s390_dev -> bus ) ) ; \n if ( qdev_init ( vdev ) < 0 ) { \n return -1 ; \n } \n object_property_set_link ( OBJECT ( dev ) , \n OBJECT ( dev -> vdev . conf . default_backend ) , \" \" , \n NULL ) ; \n return s390_virtio_device_init ( s390_dev , VIRTIO_DEVICE ( vdev ) ) ; \n }", "idx": 8903}
{"project": "qemu", "commit_id": "0fbfbb59a9766247be20023b17eb7872e7b29323", "target": 0, "func": "static void apic_update_irq ( APICState * s ) \n { \n int irrv , ppr ; \n if ( ! ( s -> spurious_vec & APIC_SV_ENABLE ) ) \n return ; \n irrv = get_highest_priority_int ( s -> irr ) ; \n if ( irrv < 0 ) \n return ; \n ppr = apic_get_ppr ( s ) ; \n if ( ppr && ( irrv & 0xf0 ) <= ( ppr & 0xf0 ) ) \n return ; \n cpu_interrupt ( s -> cpu_env , CPU_INTERRUPT_HARD ) ; \n }", "idx": 8927}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void coroutine_fn qed_aio_complete ( QEDAIOCB * acb ) \n { \n BDRVQEDState * s = acb_to_s ( acb ) ; \n qemu_iovec_destroy ( & acb -> cur_qiov ) ; \n qed_unref_l2_cache_entry ( acb -> request . l2_table ) ; \n if ( acb -> flags & QED_AIOCB_ZERO ) { \n qemu_vfree ( acb -> qiov -> iov [ 0 ] . iov_base ) ; \n acb -> qiov -> iov [ 0 ] . iov_base = NULL ; \n } \n if ( acb == s -> allocating_acb ) { \n s -> allocating_acb = NULL ; \n if ( ! qemu_co_queue_empty ( & s -> allocating_write_reqs ) ) { \n qemu_co_enter_next ( & s -> allocating_write_reqs ) ; \n } else if ( s -> header . features & QED_F_NEED_CHECK ) { \n qed_start_need_check_timer ( s ) ; \n } \n } \n }", "idx": 8946}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_brcond ( TCGContext * s , TCGMemOp ext , TCGCond c , TCGArg a , \n TCGArg b , bool b_const , TCGLabel * l ) \n { \n intptr_t offset ; \n bool need_cmp ; \n if ( b_const && b == 0 && ( c == TCG_COND_EQ || c == TCG_COND_NE ) ) { \n need_cmp = false ; \n } else { \n need_cmp = true ; \n tcg_out_cmp ( s , ext , a , b , b_const ) ; \n } \n if ( ! l -> has_value ) { \n tcg_out_reloc ( s , s -> code_ptr , R_AARCH64_CONDBR19 , l , 0 ) ; \n offset = tcg_in32 ( s ) >> 5 ; \n } else { \n offset = l -> u . value_ptr - s -> code_ptr ; \n assert ( offset == sextract64 ( offset , 0 , 19 ) ) ; \n } \n if ( need_cmp ) { \n tcg_out_insn ( s , 3202 , B_C , c , offset ) ; \n } else if ( c == TCG_COND_EQ ) { \n tcg_out_insn ( s , 3201 , CBZ , ext , a , offset ) ; \n } else { \n tcg_out_insn ( s , 3201 , CBNZ , ext , a , offset ) ; \n } \n }", "idx": 8970}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize ( DeviceState * dev , Error * * errp ) \n { \n int i ; \n GICState * s = KVM_ARM_GIC ( dev ) ; \n SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ; \n KVMARMGICClass * kgc = KVM_ARM_GIC_GET_CLASS ( s ) ; \n kgc -> parent_realize ( dev , errp ) ; \n if ( error_is_set ( errp ) ) { \n return ; \n } \n i = s -> num_irq - GIC_INTERNAL ; \n i += ( GIC_INTERNAL * s -> num_cpu ) ; \n qdev_init_gpio_in ( dev , kvm_arm_gic_set_irq , i ) ; \n for ( i = 0 ; i < s -> num_cpu ; i ++ ) { \n sysbus_init_irq ( sbd , & s -> parent_irq [ i ] ) ; \n } \n memory_region_init_reservation ( & s -> iomem , OBJECT ( s ) , \n \" \" , 0x1000 ) ; \n sysbus_init_mmio ( sbd , & s -> iomem ) ; \n kvm_arm_register_device ( & s -> iomem , \n ( KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT ) \n | KVM_VGIC_V2_ADDR_TYPE_DIST ) ; \n memory_region_init_reservation ( & s -> cpuiomem [ 0 ] , OBJECT ( s ) , \n \" \" , 0x1000 ) ; \n sysbus_init_mmio ( sbd , & s -> cpuiomem [ 0 ] ) ; \n kvm_arm_register_device ( & s -> cpuiomem [ 0 ] , \n ( KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT ) \n | KVM_VGIC_V2_ADDR_TYPE_CPU ) ; \n }", "idx": 9039}
{"project": "qemu", "commit_id": "31783203c3b74c11015b20194d57dada559940cf", "target": 0, "func": "char * qemu_find_file ( int type , const char * name ) \n { \n int len ; \n const char * subdir ; \n char * buf ; \n if ( ( strchr ( name , ' ' ) || strchr ( name , ' \\\\ ' ) ) \n && access ( name , R_OK ) == 0 ) { \n return g_strdup ( name ) ; \n } \n switch ( type ) { \n case QEMU_FILE_TYPE_BIOS : \n subdir = \" \" ; \n break ; \n case QEMU_FILE_TYPE_KEYMAP : \n subdir = \" \" ; \n break ; \n default : \n abort ( ) ; \n } \n len = strlen ( data_dir ) + strlen ( name ) + strlen ( subdir ) + 2 ; \n buf = g_malloc0 ( len ) ; \n snprintf ( buf , len , \" \" , data_dir , subdir , name ) ; \n if ( access ( buf , R_OK ) ) { \n g_free ( buf ) ; \n return NULL ; \n } \n return buf ; \n }", "idx": 9049}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_flush ( void ) \n { \n }", "idx": 9055}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n PICCommonState * s = opaque ; \n return s -> elcr ; \n }", "idx": 9067}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts ( BlockDriverState * bs , \n BdrvCheckResult * res , \n uint16_t * refcount_table , \n int64_t refcount_table_size , \n int64_t offset , int64_t size ) \n { \n BDRVQcowState * s = bs -> opaque ; \n uint64_t start , last , cluster_offset , k ; \n if ( size <= 0 ) { \n return 0 ; \n } \n start = start_of_cluster ( s , offset ) ; \n last = start_of_cluster ( s , offset + size - 1 ) ; \n for ( cluster_offset = start ; cluster_offset <= last ; \n cluster_offset += s -> cluster_size ) { \n k = cluster_offset >> s -> cluster_bits ; \n if ( k >= refcount_table_size ) { \n fprintf ( stderr , \" \" PRIx64 \" \" \n \" \\n \" , \n cluster_offset ) ; \n res -> check_errors ++ ; \n } else { \n if ( ++ refcount_table [ k ] == 0 ) { \n fprintf ( stderr , \" \" PRIx64 \n \" \\n \" , cluster_offset ) ; \n res -> corruptions ++ ; \n } \n } \n } \n return 0 ; \n }", "idx": 9072}
{"project": "qemu", "commit_id": "f140e3000371e67ff4e00df3213e2d576d9c91be", "target": 1, "func": "static int nbd_co_request ( BlockDriverState * bs , \n NBDRequest * request , \n QEMUIOVector * qiov ) \n { \n NBDClientSession * client = nbd_get_client_session ( bs ) ; \n int ret ; \n if ( qiov ) { \n assert ( request -> type == NBD_CMD_WRITE || request -> type == NBD_CMD_READ ) ; \n assert ( request -> len == iov_size ( qiov -> iov , qiov -> niov ) ) ; \n } else { \n assert ( request -> type != NBD_CMD_WRITE && request -> type != NBD_CMD_READ ) ; \n } \n ret = nbd_co_send_request ( bs , request , \n request -> type == NBD_CMD_WRITE ? qiov : NULL ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return nbd_co_receive_reply ( client , request -> handle , \n request -> type == NBD_CMD_READ ? qiov : NULL ) ; \n }", "idx": 9087}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log ( DisasContext * ctx , uint32_t insn , \n const DisasInsn * di ) \n { \n unsigned r2 = extract32 ( insn , 21 , 5 ) ; \n unsigned r1 = extract32 ( insn , 16 , 5 ) ; \n unsigned cf = extract32 ( insn , 12 , 4 ) ; \n unsigned rt = extract32 ( insn , 0 , 5 ) ; \n TCGv tcg_r1 , tcg_r2 ; \n ExitStatus ret ; \n if ( cf ) { \n nullify_over ( ctx ) ; \n } \n tcg_r1 = load_gpr ( ctx , r1 ) ; \n tcg_r2 = load_gpr ( ctx , r2 ) ; \n ret = do_log ( ctx , rt , tcg_r1 , tcg_r2 , cf , di -> f_ttt ) ; \n return nullify_end ( ctx , ret ) ; \n }", "idx": 9091}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "func": "void memory_region_add_eventfd ( MemoryRegion * mr , \n hwaddr addr , \n unsigned size , \n bool match_data , \n uint64_t data , \n EventNotifier * e ) \n { \n MemoryRegionIoeventfd mrfd = { \n . addr . start = int128_make64 ( addr ) , \n . addr . size = int128_make64 ( size ) , \n . match_data = match_data , \n . data = data , \n . e = e , \n } ; \n unsigned i ; \n adjust_endianness ( mr , & mrfd . data , size ) ; \n memory_region_transaction_begin ( ) ; \n for ( i = 0 ; i < mr -> ioeventfd_nb ; ++ i ) { \n if ( memory_region_ioeventfd_before ( mrfd , mr -> ioeventfds [ i ] ) ) { \n break ; \n } \n } \n ++ mr -> ioeventfd_nb ; \n mr -> ioeventfds = g_realloc ( mr -> ioeventfds , \n sizeof ( * mr -> ioeventfds ) * mr -> ioeventfd_nb ) ; \n memmove ( & mr -> ioeventfds [ i + 1 ] , & mr -> ioeventfds [ i ] , \n sizeof ( * mr -> ioeventfds ) * ( mr -> ioeventfd_nb - 1 - i ) ) ; \n mr -> ioeventfds [ i ] = mrfd ; \n ioeventfd_update_pending |= mr -> enabled ; \n memory_region_transaction_commit ( ) ; \n }", "idx": 9122}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "static void gic_set_irq ( void * opaque , int irq , int level ) \n { \n GICState * s = ( GICState * ) opaque ; \n int cm , target ; \n if ( irq < ( s -> num_irq - GIC_INTERNAL ) ) { \n cm = ALL_CPU_MASK ; \n irq += GIC_INTERNAL ; \n target = GIC_TARGET ( irq ) ; \n } else { \n int cpu ; \n irq -= ( s -> num_irq - GIC_INTERNAL ) ; \n cpu = irq / GIC_INTERNAL ; \n irq %= GIC_INTERNAL ; \n cm = 1 << cpu ; \n target = cm ; \n } \n assert ( irq >= GIC_NR_SGIS ) ; \n if ( level == GIC_TEST_LEVEL ( irq , cm ) ) { \n return ; \n } \n if ( s -> revision == REV_11MPCORE || s -> revision == REV_NVIC ) { \n gic_set_irq_11mpcore ( s , irq , level , cm , target ) ; \n } else { \n gic_set_irq_generic ( s , irq , level , cm , target ) ; \n } \n gic_update ( s ) ; \n }", "idx": 9150}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice * vty_lookup ( sPAPRMachineState * spapr , target_ulong reg ) \n { \n VIOsPAPRDevice * sdev ; \n sdev = spapr_vio_find_by_reg ( spapr -> vio_bus , reg ) ; \n if ( ! sdev && reg == 0 ) { \n return spapr_vty_get_default ( spapr -> vio_bus ) ; \n return sdev ;", "idx": 9172}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void coroutine_fn block_job_pause_point ( BlockJob * job ) \n { \n assert ( job && block_job_started ( job ) ) ; \n if ( ! block_job_should_pause ( job ) ) { \n return ; \n } \n if ( block_job_is_cancelled ( job ) ) { \n return ; \n } \n if ( job -> driver -> pause ) { \n job -> driver -> pause ( job ) ; \n } \n if ( block_job_should_pause ( job ) && ! block_job_is_cancelled ( job ) ) { \n job -> paused = true ; \n job -> busy = false ; \n qemu_coroutine_yield ( ) ; \n job -> busy = true ; \n job -> paused = false ; \n } \n if ( job -> driver -> resume ) { \n job -> driver -> resume ( job ) ; \n } \n }", "idx": 9174}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread ( BlockDriverState * bs , int64_t offset , \n void * buf1 , int count1 ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( ! drv -> bdrv_pread ) \n return bdrv_pread_em ( bs , offset , buf1 , count1 ) ; \n return drv -> bdrv_pread ( bs , offset , buf1 , count1 ) ; \n }", "idx": 9176}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep ( XHCIState * xhci , unsigned int slotid , \n unsigned int epid ) \n { \n XHCISlot * slot ; \n XHCIEPContext * epctx ; \n int i ; \n trace_usb_xhci_ep_disable ( slotid , epid ) ; \n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ; \n assert ( epid >= 1 && epid <= 31 ) ; \n slot = & xhci -> slots [ slotid - 1 ] ; \n if ( ! slot -> eps [ epid - 1 ] ) { \n DPRINTF ( \" \\n \" , slotid , epid ) ; \n return CC_SUCCESS ; \n xhci_ep_nuke_xfers ( xhci , slotid , epid ) ; \n epctx = slot -> eps [ epid - 1 ] ; \n if ( epctx -> nr_pstreams ) { \n xhci_free_streams ( epctx ) ; \n xhci_set_ep_state ( xhci , epctx , NULL , EP_DISABLED ) ; \n timer_free ( epctx -> kick_timer ) ; \n g_free ( epctx ) ; \n slot -> eps [ epid - 1 ] = NULL ; \n return CC_SUCCESS ;", "idx": 9189}
{"project": "qemu", "commit_id": "bc3e6a0d6c8ab6cd7cd4b576ed567756f1dcabd2", "target": 1, "func": "int pvpanic_init ( ISABus * bus ) \n { \n isa_create_simple ( bus , TYPE_ISA_PVPANIC_DEVICE ) ; \n return 0 ; \n }", "idx": 9193}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void slirp_socket_save ( QEMUFile * f , struct socket * so ) \n { \n qemu_put_be32 ( f , so -> so_urgc ) ; \n qemu_put_be16 ( f , so -> so_ffamily ) ; \n switch ( so -> so_ffamily ) { \n case AF_INET : \n qemu_put_be32 ( f , so -> so_faddr . s_addr ) ; \n qemu_put_be16 ( f , so -> so_fport ) ; \n break ; \n default : \n error_report ( \n \" \\n \" ) ; \n } \n qemu_put_be16 ( f , so -> so_lfamily ) ; \n switch ( so -> so_lfamily ) { \n case AF_INET : \n qemu_put_be32 ( f , so -> so_laddr . s_addr ) ; \n qemu_put_be16 ( f , so -> so_lport ) ; \n break ; \n default : \n error_report ( \n \" \\n \" ) ; \n } \n qemu_put_byte ( f , so -> so_iptos ) ; \n qemu_put_byte ( f , so -> so_emu ) ; \n qemu_put_byte ( f , so -> so_type ) ; \n qemu_put_be32 ( f , so -> so_state ) ; \n slirp_sbuf_save ( f , & so -> so_rcv ) ; \n slirp_sbuf_save ( f , & so -> so_snd ) ; \n slirp_tcp_save ( f , so -> so_tcpcb ) ; \n }", "idx": 9225}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_allow_set_link ( Object * obj , const char * name , \n Object * val , Error * * errp ) \n { \n }", "idx": 9231}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static int nbd_co_readv_1 ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , QEMUIOVector * qiov , \n int offset ) \n { \n BDRVNBDState * s = bs -> opaque ; \n struct nbd_request request ; \n struct nbd_reply reply ; \n request . type = NBD_CMD_READ ; \n request . from = sector_num * 512 ; \n request . len = nb_sectors * 512 ; \n nbd_coroutine_start ( s , & request ) ; \n if ( nbd_co_send_request ( s , & request , NULL , 0 ) == -1 ) { \n reply . error = errno ; \n } else { \n nbd_co_receive_reply ( s , & request , & reply , qiov -> iov , offset ) ; \n } \n nbd_coroutine_end ( s , & request ) ; \n return - reply . error ; \n }", "idx": 9260}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov ( CPUTriCoreState * env , target_ulong r1 , \n target_ulong r2 ) \n { \n int64_t t1 = extract64 ( r1 , 0 , 32 ) ; \n int64_t t2 = extract64 ( r2 , 0 , 32 ) ; \n int64_t result = t1 * t2 ; \n return suov32 ( env , result ) ; \n }", "idx": 9352}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "func": "static void virtio_rng_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n VirtioDeviceClass * vdc = VIRTIO_DEVICE_CLASS ( klass ) ; \n dc -> props = virtio_rng_properties ; \n set_bit ( DEVICE_CATEGORY_MISC , dc -> categories ) ; \n vdc -> realize = virtio_rng_device_realize ; \n vdc -> unrealize = virtio_rng_device_unrealize ; \n vdc -> get_features = get_features ; \n vdc -> load = virtio_rng_load_device ; \n }", "idx": 9399}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init ( target_phys_addr_t addr , ram_addr_t RAM_size ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n RamDevice * d ; \n dev = qdev_create ( NULL , \" \" ) ; \n s = sysbus_from_qdev ( dev ) ; \n d = FROM_SYSBUS ( RamDevice , s ) ; \n d -> size = RAM_size ; \n qdev_init ( dev ) ; \n sysbus_mmio_map ( s , 0 , addr ) ; \n }", "idx": 9443}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat ( const sigset_t * mask ) \n { \n pthread_attr_t attr ; \n pthread_t tid ; \n struct sigfd_compat_info * info ; \n int fds [ 2 ] ; \n info = malloc ( sizeof ( * info ) ) ; \n if ( info == NULL ) { \n errno = ENOMEM ; \n return -1 ; \n } \n if ( pipe ( fds ) == -1 ) { \n free ( info ) ; \n return -1 ; \n } \n memcpy ( & info -> mask , mask , sizeof ( * mask ) ) ; \n info -> fd = fds [ 1 ] ; \n pthread_attr_init ( & attr ) ; \n pthread_attr_setdetachstate ( & attr , PTHREAD_CREATE_DETACHED ) ; \n pthread_create ( & tid , & attr , sigwait_compat , info ) ; \n pthread_attr_destroy ( & attr ) ; \n return fds [ 0 ] ; \n }", "idx": 9510}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_start_len ( VncState * vs , uint8_t * data , size_t len ) \n { \n uint32_t startlen = read_u32 ( data , 0 ) ; \n VNC_DEBUG ( \" \\n \" , startlen ) ; \n if ( startlen > SASL_DATA_MAX_LEN ) { \n VNC_DEBUG ( \" \\n \" , startlen ) ; \n vnc_client_error ( vs ) ; \n return -1 ; \n } \n if ( startlen == 0 ) \n return protocol_client_auth_sasl_start ( vs , NULL , 0 ) ; \n vnc_read_when ( vs , protocol_client_auth_sasl_start , startlen ) ; \n return 0 ; \n }", "idx": 9516}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_a ( DisasContext * dc , target_ulong pc1 , \n target_ulong pc2 , TCGv r_cond ) \n { \n int l1 ; \n l1 = gen_new_label ( ) ; \n tcg_gen_brcondi_tl ( TCG_COND_EQ , r_cond , 0 , l1 ) ; \n gen_goto_tb ( dc , 0 , pc2 , pc1 ) ; \n gen_set_label ( l1 ) ; \n gen_goto_tb ( dc , 1 , pc2 + 4 , pc2 + 8 ) ; \n }", "idx": 9546}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegion * escc_init ( target_phys_addr_t base , qemu_irq irqA , qemu_irq irqB , \n CharDriverState * chrA , CharDriverState * chrB , \n int clock , int it_shift ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n SerialState * d ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_prop_set_uint32 ( dev , \" \" , 0 ) ; \n qdev_prop_set_uint32 ( dev , \" \" , clock ) ; \n qdev_prop_set_uint32 ( dev , \" \" , it_shift ) ; \n qdev_prop_set_chr ( dev , \" \" , chrB ) ; \n qdev_prop_set_chr ( dev , \" \" , chrA ) ; \n qdev_prop_set_uint32 ( dev , \" \" , ser ) ; \n qdev_prop_set_uint32 ( dev , \" \" , ser ) ; \n qdev_init_nofail ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n sysbus_connect_irq ( s , 0 , irqB ) ; \n sysbus_connect_irq ( s , 1 , irqA ) ; \n if ( base ) { \n sysbus_mmio_map ( s , 0 , base ) ; \n } \n d = FROM_SYSBUS ( SerialState , s ) ; \n return & d -> mmio ; \n }", "idx": 9584}
{"project": "qemu", "commit_id": "603987488c61ca02ee99890d07cdaecdb118a659", "target": 1, "func": "PCIBus * pci_pmac_init ( qemu_irq * pic ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n UNINState * d ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_init_nofail ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n d = FROM_SYSBUS ( UNINState , s ) ; \n d -> host_state . bus = pci_register_bus ( & d -> busdev . qdev , \" \" , \n pci_unin_set_irq , pci_unin_map_irq , \n pic , 11 << 3 , 4 ) ; \n pci_create_simple ( d -> host_state . bus , 11 << 3 , \" \" ) ; \n sysbus_mmio_map ( s , 0 , 0xf2800000 ) ; \n sysbus_mmio_map ( s , 1 , 0xf2c00000 ) ; \n #if 0  \n  \n  \n  \n  pci_create_simple ( d -> host_state . bus , 12 << 3 , \" \" ) ; \n #endif \n pci_create_simple ( d -> host_state . bus , 13 << 3 , \" \" ) ; \n #if 0  \n  \n  \n  \n  pci_create_simple ( d -> host_state . bus , 14 << 3 , \" \" ) ; \n #endif \n return d -> host_state . bus ; \n }", "idx": 9616}
{"project": "qemu", "commit_id": "041d95f42e39ed1d3a029332cab9966889f0aeb3", "target": 0, "func": "static inline void ppc4xx_tlb_invalidate_virt ( CPUPPCState * env , \n target_ulong eaddr , uint32_t pid ) \n { \n #if ! defined ( FLUSH_ALL_TLBS )  \n  \n  CPUState * cs = CPU ( ppc_env_get_cpu ( env ) ) ; \n ppcemb_tlb_t * tlb ; \n hwaddr raddr ; \n target_ulong page , end ; \n int i ; \n for ( i = 0 ; i < env -> nb_tlb ; i ++ ) { \n tlb = & env -> tlb . tlbe [ i ] ; \n if ( ppcemb_tlb_check ( env , tlb , & raddr , eaddr , pid , 0 , i ) == 0 ) { \n end = tlb -> EPN + tlb -> size ; \n for ( page = tlb -> EPN ; page < end ; page += TARGET_PAGE_SIZE ) { \n tlb_flush_page ( cs , page ) ; \n } \n tlb -> prot &= ~ PAGE_VALID ; \n break ; \n } \n } \n #else \n ppc4xx_tlb_invalidate_all ( env ) ; \n #endif \n }", "idx": 9629}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "void qemu_pixman_linebuf_fill ( pixman_image_t * linebuf , pixman_image_t * fb , \n int width , int y ) \n { \n pixman_image_composite ( PIXMAN_OP_SRC , fb , NULL , linebuf , \n 0 , y , 0 , 0 , 0 , 0 , width , 1 ) ; \n }", "idx": 9639}
{"project": "qemu", "commit_id": "9d6f1b73f83a02fb28438fa9a487f5c7d245e4af", "target": 0, "func": "static bool ga_open_pidfile ( const char * pidfile ) \n { \n int pidfd ; \n char pidstr [ 32 ] ; \n pidfd = open ( pidfile , O_CREAT | O_WRONLY , S_IRUSR | S_IWUSR ) ; \n if ( pidfd == -1 || lockf ( pidfd , F_TLOCK , 0 ) ) { \n g_critical ( \" \" , strerror ( errno ) ) ; \n if ( pidfd != -1 ) { \n close ( pidfd ) ; \n } \n return false ; \n } \n if ( ftruncate ( pidfd , 0 ) || lseek ( pidfd , 0 , SEEK_SET ) ) { \n g_critical ( \" \" ) ; \n goto fail ; \n } \n sprintf ( pidstr , \" \" , getpid ( ) ) ; \n if ( write ( pidfd , pidstr , strlen ( pidstr ) ) != strlen ( pidstr ) ) { \n g_critical ( \" \" ) ; \n goto fail ; \n } \n return true ; \n fail : \n unlink ( pidfile ) ; \n return false ; \n }", "idx": 9647}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_write_config ( PCIDevice * d , \n uint32_t address , uint32_t val , int len ) \n { \n pci_bridge_write_config ( d , address , val , len ) ; \n msi_write_config ( d , address , val , len ) ; \n shpc_cap_write_config ( d , address , val , len ) ; \n }", "idx": 9651}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "static ram_addr_t find_ram_offset ( ram_addr_t size ) \n { \n RAMBlock * block , * next_block ; \n ram_addr_t offset = RAM_ADDR_MAX , mingap = RAM_ADDR_MAX ; \n assert ( size != 0 ) ; \n if ( QTAILQ_EMPTY ( & ram_list . blocks ) ) \n return 0 ; \n QTAILQ_FOREACH ( block , & ram_list . blocks , next )  { \n ram_addr_t end , next = RAM_ADDR_MAX ; \n end = block -> offset + block -> length ; \n QTAILQ_FOREACH ( next_block , & ram_list . blocks , next )  { \n if ( next_block -> offset >= end ) { \n next = MIN ( next , next_block -> offset ) ; \n } \n } \n if ( next - end >= size && next - end < mingap ) { \n offset = end ; \n mingap = next - end ; \n } \n } \n if ( offset == RAM_ADDR_MAX ) { \n fprintf ( stderr , \" \" PRIu64 \" \\n \" , \n ( uint64_t ) size ) ; \n abort ( ) ; \n } \n return offset ; \n }", "idx": 9670}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState * qemu_chr_alloc ( void ) \n { \n CharDriverState * chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n qemu_mutex_init ( & chr -> chr_write_lock ) ; \n return chr ; \n }", "idx": 9683}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "static void flush_queued_work ( CPUState * cpu ) \n { \n struct qemu_work_item * wi ; \n if ( cpu -> queued_work_first == NULL ) { \n return ; \n } \n while ( ( wi = cpu -> queued_work_first ) ) { \n cpu -> queued_work_first = wi -> next ; \n wi -> func ( wi -> data ) ; \n wi -> done = true ; \n if ( wi -> free ) { \n g_free ( wi ) ; \n } \n } \n cpu -> queued_work_last = NULL ; \n qemu_cond_broadcast ( & qemu_work_cond ) ; \n }", "idx": 9707}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space ( unsigned long guest_base , \n unsigned long guest_size ) \n { \n unsigned long real_start , test_page_addr ; \n test_page_addr = guest_base + ( 0xffff0f00 & qemu_host_page_mask ) ; \n if ( test_page_addr >= guest_base \n && test_page_addr <= ( guest_base + guest_size ) ) { \n return -1 ; \n } \n real_start = ( unsigned long ) \n mmap ( ( void * ) test_page_addr , qemu_host_page_size , \n PROT_READ | PROT_WRITE , \n MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS , -1 , 0 ) ; \n if ( real_start == -1ul ) { \n return 0 ; \n } \n if ( real_start != test_page_addr ) { \n munmap ( ( void * ) real_start , qemu_host_page_size ) ; \n return 0 ; \n } \n __put_user ( 5 , ( uint32_t * ) g2h ( 0xffff0ffcul ) ) ; \n if ( mprotect ( ( void * ) test_page_addr , qemu_host_page_size , PROT_READ ) ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n return 1 ; \n }", "idx": 9709}
{"project": "qemu", "commit_id": "f5f601afcec6c1081128fe5a0f831788ca9f56ed", "target": 1, "func": "long do_sigreturn ( CPUCRISState * env ) \n { \n struct target_signal_frame * frame ; \n abi_ulong frame_addr ; \n target_sigset_t target_set ; \n sigset_t set ; \n int i ; \n frame_addr = env -> regs [ R_SP ] ; \n if ( ! lock_user_struct ( VERIFY_WRITE , frame , frame_addr , 1 ) ) \n goto badframe ; \n if ( __get_user ( target_set . sig [ 0 ] , & frame -> sc . oldmask ) ) \n goto badframe ; \n for ( i = 1 ; i < TARGET_NSIG_WORDS ; i ++ ) { \n if ( __get_user ( target_set . sig [ i ] , & frame -> extramask [ i - 1 ] ) ) \n goto badframe ; \n } \n target_to_host_sigset_internal ( & set , & target_set ) ; \n do_sigprocmask ( SIG_SETMASK , & set , NULL ) ; \n restore_sigcontext ( & frame -> sc , env ) ; \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n return env -> regs [ 10 ] ; \n badframe : \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n force_sig ( TARGET_SIGSEGV ) ; \n }", "idx": 9721}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_interrupt_packet ( void * priv , uint32_t id , \n struct usb_redir_interrupt_packet_header * interrupt_packet , \n uint8_t * data , int data_len ) \n { \n USBRedirDevice * dev = priv ; \n uint8_t ep = interrupt_packet -> endpoint ; \n DPRINTF ( \" \\n \" , \n interrupt_packet -> status , ep , data_len , id ) ; \n if ( dev -> endpoint [ EP2I ( ep ) ] . type != USB_ENDPOINT_XFER_INT ) { \n ERROR ( \" \\n \" , ep ) ; \n free ( data ) ; \n return ; \n } \n if ( ep & USB_DIR_IN ) { \n if ( dev -> endpoint [ EP2I ( ep ) ] . interrupt_started == 0 ) { \n DPRINTF ( \" \\n \" , ep ) ; \n free ( data ) ; \n return ; \n } \n bufp_alloc ( dev , data , data_len , interrupt_packet -> status , ep ) ; \n } else { \n int len = interrupt_packet -> length ; \n AsyncURB * aurb = async_find ( dev , id ) ; \n if ( ! aurb ) { \n return ; \n } \n if ( aurb -> interrupt_packet . endpoint != interrupt_packet -> endpoint ) { \n ERROR ( \" \\n \" ) ; \n len = USB_RET_NAK ; \n } \n if ( aurb -> packet ) { \n aurb -> packet -> len = usbredir_handle_status ( dev , \n interrupt_packet -> status , len ) ; \n usb_packet_complete ( & dev -> dev , aurb -> packet ) ; \n } \n async_free ( dev , aurb ) ; \n } \n }", "idx": 9722}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_registers ( void ) \n { \n if ( ! ( env -> CP0_Status & ( 1 << CP0St_FR ) ) && ( PARAM1 & 1 ) ) { \n CALL_FROM_TB1 ( do_raise_exception , EXCP_RI ) ; \n } \n RETURN ( ) ; \n }", "idx": 9754}
{"project": "qemu", "commit_id": "e853ea1cc68716c3d9c22d04578020c6dd743306", "target": 1, "func": "GIOStatus ga_channel_write_all ( GAChannel * c , const char * buf , size_t size ) \n { \n GIOStatus status = G_IO_STATUS_NORMAL ; \n size_t count ; \n while ( size ) { \n status = ga_channel_write ( c , buf , size , & count ) ; \n if ( status == G_IO_STATUS_NORMAL ) { \n size -= count ; \n buf += count ; \n } else if ( status != G_IO_STATUS_AGAIN ) { \n break ; \n } \n } \n return status ; \n }", "idx": 9787}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void flush_queued_work ( CPUState * env ) \n { \n struct qemu_work_item * wi ; \n if ( ! env -> queued_work_first ) \n return ; \n while ( ( wi = env -> queued_work_first ) ) { \n env -> queued_work_first = wi -> next ; \n wi -> func ( wi -> data ) ; \n wi -> done = true ; \n } \n env -> queued_work_last = NULL ; \n qemu_cond_broadcast ( & qemu_work_cond ) ; \n }", "idx": 9805}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add ( Monitor * mon , const QDict * qdict , DriveInfo * dinfo ) \n { \n monitor_printf ( mon , \" \\n \" , dinfo -> type ) ; \n return -1 ; \n }", "idx": 9845}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice * s390_pci_find_dev_by_target ( const char * target ) \n { \n int i ; \n S390PCIBusDevice * pbdev ; \n S390pciState * s = s390_get_phb ( ) ; \n if ( ! target ) { \n return NULL ; \n } \n for ( i = 0 ; i < PCI_SLOT_MAX ; i ++ ) { \n pbdev = s -> pbdev [ i ] ; \n if ( ! pbdev ) { \n continue ; \n } \n if ( ! strcmp ( pbdev -> target , target ) ) { \n return pbdev ; \n } \n } \n return NULL ; \n }", "idx": 9870}
{"project": "qemu", "commit_id": "d15fda639ba356148fc7161bba863866fd2797ef", "target": 0, "func": "static int intel_hda_init ( PCIDevice * pci ) \n { \n IntelHDAState * d = DO_UPCAST ( IntelHDAState , pci , pci ) ; \n uint8_t * conf = d -> pci . config ; \n d -> name = d -> pci . qdev . info -> name ; \n pci_config_set_vendor_id ( conf , PCI_VENDOR_ID_INTEL ) ; \n pci_config_set_device_id ( conf , 0x2668 ) ; \n pci_config_set_revision ( conf , 1 ) ; \n pci_config_set_class ( conf , PCI_CLASS_MULTIMEDIA_HD_AUDIO ) ; \n pci_config_set_interrupt_pin ( conf , 1 ) ; \n conf [ 0x40 ] = 0x01 ; \n d -> mmio_addr = cpu_register_io_memory ( intel_hda_mmio_read , \n intel_hda_mmio_write , d , \n DEVICE_NATIVE_ENDIAN ) ; \n pci_register_bar_simple ( & d -> pci , 0 , 0x4000 , 0 , d -> mmio_addr ) ; \n if ( d -> msi ) { \n msi_init ( & d -> pci , 0x50 , 1 , true , false ) ; \n } \n hda_codec_bus_init ( & d -> pci . qdev , & d -> codecs , \n intel_hda_response , intel_hda_xfer ) ; \n return 0 ; \n }", "idx": 9956}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static BlockDriverAIOCB * raw_aio_writev ( BlockDriverState * bs , \n int64_t sector_num , QEMUIOVector * qiov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n RawAIOCB * acb ; \n acb = raw_aio_setup ( bs , sector_num , qiov , nb_sectors , cb , opaque ) ; \n if ( ! acb ) \n return NULL ; \n if ( qemu_paio_write ( & acb -> aiocb ) < 0 ) { \n raw_aio_remove ( acb ) ; \n return NULL ; \n } \n return & acb -> common ; \n }", "idx": 9961}
{"project": "qemu", "commit_id": "e3af7c788b73a6495eb9d94992ef11f6ad6f3c56", "target": 0, "func": "static inline uint32_t insn_get ( CPUX86State * env , DisasContext * s , TCGMemOp ot ) \n { \n uint32_t ret ; \n switch ( ot ) { \n case MO_8 : \n ret = cpu_ldub_code ( env , s -> pc ) ; \n s -> pc ++ ; \n break ; \n case MO_16 : \n ret = cpu_lduw_code ( env , s -> pc ) ; \n s -> pc += 2 ; \n break ; \n case MO_32 : \n #ifdef TARGET_X86_64 \n case MO_64 : \n #endif \n ret = cpu_ldl_code ( env , s -> pc ) ; \n s -> pc += 4 ; \n break ; \n default : \n tcg_abort ( ) ; \n } \n return ret ; \n }", "idx": 10000}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_throttle_write_timer_cb ( void * opaque ) \n { \n BlockDriverState * bs = opaque ; \n qemu_co_enter_next ( & bs -> throttled_reqs [ 1 ] ) ; \n }", "idx": 10026}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xcrs ( CPUState * env ) \n { \n #ifdef KVM_CAP_XCRS \n struct kvm_xcrs xcrs ; \n if ( ! kvm_has_xcrs ( ) ) \n return 0 ; \n xcrs . nr_xcrs = 1 ; \n xcrs . flags = 0 ; \n xcrs . xcrs [ 0 ] . xcr = 0 ; \n xcrs . xcrs [ 0 ] . value = env -> xcr0 ; \n return kvm_vcpu_ioctl ( env , KVM_SET_XCRS , & xcrs ) ; \n #else \n return 0 ; \n #endif \n }", "idx": 10055}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal ( DisasContext * ctx , TCGCond cond , \n TCGv cmp , int32_t disp ) \n { \n uint64_t dest = ctx -> pc + ( disp << 2 ) ; \n int lab_true = gen_new_label ( ) ; \n if ( use_goto_tb ( ctx , dest ) ) { \n tcg_gen_brcondi_i64 ( cond , cmp , 0 , lab_true ) ; \n tcg_gen_goto_tb ( 0 ) ; \n tcg_gen_movi_i64 ( cpu_pc , ctx -> pc ) ; \n tcg_gen_exit_tb ( ( uintptr_t ) ctx -> tb ) ; \n gen_set_label ( lab_true ) ; \n tcg_gen_goto_tb ( 1 ) ; \n tcg_gen_movi_i64 ( cpu_pc , dest ) ; \n tcg_gen_exit_tb ( ( uintptr_t ) ctx -> tb + 1 ) ; \n return EXIT_GOTO_TB ; \n } else { \n TCGv_i64 z = tcg_const_i64 ( 0 ) ; \n TCGv_i64 d = tcg_const_i64 ( dest ) ; \n TCGv_i64 p = tcg_const_i64 ( ctx -> pc ) ; \n tcg_gen_movcond_i64 ( cond , cpu_pc , cmp , z , d , p ) ; \n tcg_temp_free_i64 ( z ) ; \n tcg_temp_free_i64 ( d ) ; \n tcg_temp_free_i64 ( p ) ; \n return EXIT_PC_UPDATED ; \n } \n }", "idx": 10064}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_read_config ( PCIDevice * d , uint32_t address , int len ) \n { \n uint32_t val = pci_default_read_config ( d , address , len ) ; \n #ifdef TARGET_WORDS_BIGENDIAN \n val = bswap32 ( val ) ; \n #endif \n return val ; \n }", "idx": 10081}
{"project": "qemu", "commit_id": "bbade20633a6b4ed7333e03a76038eda98950946", "target": 1, "func": "static void rtas_get_time_of_day ( PowerPCCPU * cpu , sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n struct tm tm ; \n if ( nret != 8 ) { \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n return ; \n } \n qemu_get_timedate ( & tm , spapr -> rtc_offset ) ; \n rtas_st ( rets , 0 , RTAS_OUT_SUCCESS ) ; \n rtas_st ( rets , 1 , tm . tm_year + 1900 ) ; \n rtas_st ( rets , 2 , tm . tm_mon + 1 ) ; \n rtas_st ( rets , 3 , tm . tm_mday ) ; \n rtas_st ( rets , 4 , tm . tm_hour ) ; \n rtas_st ( rets , 5 , tm . tm_min ) ; \n rtas_st ( rets , 6 , tm . tm_sec ) ; \n rtas_st ( rets , 7 , 0 ) ; \n }", "idx": 10104}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_set_speed ( const char * device , int64_t speed , Error * * errp ) \n { \n BlockJob * job = find_block_job ( device ) ; \n if ( ! job ) { \n error_set ( errp , QERR_BLOCK_JOB_NOT_ACTIVE , device ) ; \n return ; \n } \n block_job_set_speed ( job , speed , errp ) ; \n }", "idx": 10128}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_socket ( int domain , int type , int protocol ) \n { \n int target_type = type ; \n int ret ; \n ret = target_to_host_sock_type ( & type ) ; \n if ( ret ) { \n return ret ; \n } \n if ( domain == PF_NETLINK ) \n return - TARGET_EAFNOSUPPORT ; \n if ( domain == AF_PACKET || \n ( domain == AF_INET && type == SOCK_PACKET ) ) { \n protocol = tswap16 ( protocol ) ; \n } \n ret = get_errno ( socket ( domain , type , protocol ) ) ; \n if ( ret >= 0 ) { \n ret = sock_flags_fixup ( ret , target_type ) ; \n if ( type == SOCK_PACKET ) { \n fd_trans_register ( ret , & target_packet_trans ) ; \n } \n } \n return ret ; \n }", "idx": 10190}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall ( CPUPPCState * env , uint8_t * buf , int buf_len ) \n { \n PowerPCCPU * cpu = ppc_env_get_cpu ( env ) ; \n CPUState * cs = CPU ( cpu ) ; \n uint32_t * hc = ( uint32_t * ) buf ; \n struct kvm_ppc_pvinfo pvinfo ; \n if ( kvm_check_extension ( cs -> kvm_state , KVM_CAP_PPC_GET_PVINFO ) && \n ! kvm_vm_ioctl ( cs -> kvm_state , KVM_PPC_GET_PVINFO , & pvinfo ) ) { \n memcpy ( buf , pvinfo . hcall , buf_len ) ; \n return 0 ; \n } \n hc [ 0 ] = 0x3860ffff ; \n hc [ 1 ] = 0x60000000 ; \n hc [ 2 ] = 0x60000000 ; \n hc [ 3 ] = 0x60000000 ; \n return 0 ; \n }", "idx": 10192}
{"project": "qemu", "commit_id": "1bcef683bf840a928d633755031ac572d5fdb851", "target": 0, "func": "void process_incoming_migration ( QEMUFile * f ) \n { \n if ( qemu_loadvm_state ( f ) < 0 ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 0 ) ; \n } \n qemu_announce_self ( ) ; \n DPRINTF ( \" \\n \" ) ; \n incoming_expected = false ; \n if ( autostart ) { \n vm_start ( ) ; \n } else { \n runstate_set ( RSTATE_PRE_LAUNCH ) ; \n } \n }", "idx": 10194}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "void qemu_coroutine_delete ( Coroutine * co_ ) \n { \n CoroutineThreadState * s = coroutine_get_thread_state ( ) ; \n CoroutineUContext * co = DO_UPCAST ( CoroutineUContext , base , co_ ) ; \n if ( s -> pool_size < POOL_MAX_SIZE ) { \n QLIST_INSERT_HEAD ( & s -> pool , & co -> base , pool_next ) ; \n co -> base . caller = NULL ; \n s -> pool_size ++ ; \n return ; \n } \n g_free ( co -> stack ) ; \n g_free ( co ) ; \n }", "idx": 10266}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq_signaling ( float64 a , float64 b STATUS_PARAM ) \n { \n if ( ( ( extractFloat64Exp ( a ) == 0x7FF ) && extractFloat64Frac ( a ) ) \n || ( ( extractFloat64Exp ( b ) == 0x7FF ) && extractFloat64Frac ( b ) ) \n ) { \n float_raise ( float_flag_invalid STATUS_VAR ) ; \n return 0 ; \n } \n return ( a == b ) || ( ( bits64 ) ( ( a | b ) << 1 ) == 0 ) ; \n }", "idx": 10268}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_tx_bufs ( int tpm_fd , \n const uint8_t * in , uint32_t in_len , \n uint8_t * out , uint32_t out_len ) \n { \n int ret ; \n ret = tpm_passthrough_unix_write ( tpm_fd , in , in_len ) ; \n if ( ret != in_len ) { \n error_report ( \" \" \n \" \\n \" , \n strerror ( errno ) , errno ) ; \n goto err_exit ; \n } \n ret = tpm_passthrough_unix_read ( tpm_fd , out , out_len ) ; \n if ( ret < 0 ) { \n error_report ( \" \" \n \" \\n \" , \n strerror ( errno ) , errno ) ; \n } else if ( ret < sizeof ( struct tpm_resp_hdr ) || \n tpm_passthrough_get_size_from_buffer ( out ) != ret ) { \n ret = -1 ; \n error_report ( \" \" \n \" \\n \" ) ; \n } \n err_exit : \n if ( ret < 0 ) { \n tpm_write_fatal_error_response ( out , out_len ) ; \n } \n return ret ; \n }", "idx": 10269}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug ( CPUArchState * env , target_ulong addr , \n uint8_t * buf , int len , int is_write ) \n { \n int l ; \n target_phys_addr_t phys_addr ; \n target_ulong page ; \n while ( len > 0 ) { \n page = addr & TARGET_PAGE_MASK ; \n phys_addr = cpu_get_phys_page_debug ( env , page ) ; \n if ( phys_addr == -1 ) \n return -1 ; \n l = ( page + TARGET_PAGE_SIZE ) - addr ; \n if ( l > len ) \n l = len ; \n phys_addr += ( addr & ~ TARGET_PAGE_MASK ) ; \n if ( is_write ) \n cpu_physical_memory_write_rom ( phys_addr , buf , l ) ; \n else \n cpu_physical_memory_rw ( phys_addr , buf , l , is_write ) ; \n len -= l ; \n buf += l ; \n addr += l ; \n } \n return 0 ; \n }", "idx": 10278}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_uwire_s * omap_uwire_init ( MemoryRegion * system_memory , \n target_phys_addr_t base , \n qemu_irq * irq , qemu_irq dma , omap_clk clk ) \n { \n struct omap_uwire_s * s = ( struct omap_uwire_s * ) \n g_malloc0 ( sizeof ( struct omap_uwire_s ) ) ; \n s -> txirq = irq [ 0 ] ; \n s -> rxirq = irq [ 1 ] ; \n s -> txdrq = dma ; \n omap_uwire_reset ( s ) ; \n memory_region_init_io ( & s -> iomem , & omap_uwire_ops , s , \" \" , 0x800 ) ; \n memory_region_add_subregion ( system_memory , base , & s -> iomem ) ; \n return s ; \n }", "idx": 10282}
{"project": "qemu", "commit_id": "66668d197fa40747e835e15617eda2f1bc80982f", "target": 0, "func": "static int send_sub_rect ( VncState * vs , int x , int y , int w , int h ) \n { \n VncPalette * palette = & color_count_palette ; \n uint32_t bg = 0 , fg = 0 ; \n int colors ; \n int ret = 0 ; \n #ifdef CONFIG_VNC_JPEG \n bool force_jpeg = false ; \n bool allow_jpeg = true ; \n #endif \n vnc_framebuffer_update ( vs , x , y , w , h , vs -> tight . type ) ; \n vnc_tight_start ( vs ) ; \n vnc_raw_send_framebuffer_update ( vs , x , y , w , h ) ; \n vnc_tight_stop ( vs ) ; \n #ifdef CONFIG_VNC_JPEG \n if ( ! vs -> vd -> non_adaptive && vs -> tight . quality != ( uint8_t ) -1 ) { \n double freq = vnc_update_freq ( vs , x , y , w , h ) ; \n if ( freq < tight_jpeg_conf [ vs -> tight . quality ] . jpeg_freq_min ) { \n allow_jpeg = false ; \n } \n if ( freq >= tight_jpeg_conf [ vs -> tight . quality ] . jpeg_freq_threshold ) { \n force_jpeg = true ; \n vnc_sent_lossy_rect ( vs , x , y , w , h ) ; \n } \n } \n #endif \n colors = tight_fill_palette ( vs , x , y , w * h , & bg , & fg , palette ) ; \n #ifdef CONFIG_VNC_JPEG \n if ( allow_jpeg && vs -> tight . quality != ( uint8_t ) -1 ) { \n ret = send_sub_rect_jpeg ( vs , x , y , w , h , bg , fg , colors , palette , \n force_jpeg ) ; \n } else { \n ret = send_sub_rect_nojpeg ( vs , x , y , w , h , bg , fg , colors , palette ) ; \n } \n #else \n ret = send_sub_rect_nojpeg ( vs , x , y , w , h , bg , fg , colors , palette ) ; \n #endif \n return ret ; \n }", "idx": 10291}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER ( ucf64_abss ) ( float32 a ) \n { \n return float32_abs ( a ) ; \n }", "idx": 10316}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_thread_equal ( QemuThread * thread1 , QemuThread * thread2 ) \n { \n return pthread_equal ( thread1 -> thread , thread2 -> thread ) ; \n }", "idx": 10322}
{"project": "qemu", "commit_id": "1b27d7a1e8609b2eeb6238f2c629eb82217523f6", "target": 0, "func": "static void ivshmem_io_writel ( void * opaque , target_phys_addr_t addr , \n uint32_t val ) \n { \n IVShmemState * s = opaque ; \n uint64_t write_one = 1 ; \n uint16_t dest = val >> 16 ; \n uint16_t vector = val & 0xff ; \n addr &= 0xfc ; \n IVSHMEM_DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n switch ( addr ) \n { \n case INTRMASK : \n ivshmem_IntrMask_write ( s , val ) ; \n break ; \n case INTRSTATUS : \n ivshmem_IntrStatus_write ( s , val ) ; \n break ; \n case DOORBELL : \n if ( ( dest < 0 ) || ( dest > s -> max_peer ) ) { \n IVSHMEM_DPRINTF ( \" \\n \" , dest ) ; \n break ; \n } \n if ( ( vector >= 0 ) && ( vector < s -> peers [ dest ] . nb_eventfds ) ) { \n IVSHMEM_DPRINTF ( \" \" PRId64 \" \\n \" , \n write_one , dest , vector ) ; \n if ( write ( s -> peers [ dest ] . eventfds [ vector ] , \n & ( write_one ) , 8 ) != 8 ) { \n IVSHMEM_DPRINTF ( \" \\n \" ) ; \n } \n } \n break ; \n default : \n IVSHMEM_DPRINTF ( \" \\n \" , dest ) ; \n } \n }", "idx": 10327}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static inline void gen_outs ( DisasContext * s , TCGMemOp ot ) \n { \n if ( use_icount ) \n gen_io_start ( ) ; \n gen_string_movl_A0_ESI ( s ) ; \n gen_op_ld_v ( s , ot , cpu_T [ 0 ] , cpu_A0 ) ; \n tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_EDX ] ) ; \n tcg_gen_andi_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , 0xffff ) ; \n tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T [ 0 ] ) ; \n gen_helper_out_func ( ot , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; \n gen_op_movl_T0_Dshift ( ot ) ; \n gen_op_add_reg_T0 ( s -> aflag , R_ESI ) ; \n if ( use_icount ) \n gen_io_end ( ) ; \n }", "idx": 10333}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "void test_fcmp ( double a , double b ) \n { \n long eflags , fpus ; \n fpu_clear_exceptions ( ) ; \n asm ( \" \\n \" \n \" \\n \" \n : \" \" ( fpus ) \n : \" \" ( a ) , \" \" ( b ) ) ; \n printf ( \" \\n \" , \n a , b , fpus & ( 0x4500 | FPUS_EMASK ) ) ; \n fpu_clear_exceptions ( ) ; \n asm ( \" \\n \" \n \" \\n \" \n : \" \" ( fpus ) \n : \" \" ( a ) , \" \" ( b ) ) ; \n printf ( \" \\n \" , \n a , b , fpus & ( 0x4500 | FPUS_EMASK ) ) ; \n if ( TEST_FCOMI ) { \n fpu_clear_exceptions ( ) ; \n asm ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n : \" \" ( eflags ) , \" \" ( fpus ) \n : \" \" ( a ) , \" \" ( b ) ) ; \n printf ( \" \\n \" , \n a , b , fpus & FPUS_EMASK , eflags & ( CC_Z | CC_P | CC_C ) ) ; \n fpu_clear_exceptions ( ) ; \n asm ( \" \\n \" \n \" \\n \" \n \" \\n \" \n \" \\n \" \n : \" \" ( eflags ) , \" \" ( fpus ) \n : \" \" ( a ) , \" \" ( b ) ) ; \n printf ( \" \\n \" , \n a , b , fpus & FPUS_EMASK , eflags & ( CC_Z | CC_P | CC_C ) ) ; \n } \n fpu_clear_exceptions ( ) ; \n asm volatile ( \" \\n \" \n \" \\n \" \n : \" \" ( fpus ) \n : \" \" ( a ) ) ; \n printf ( \" \\n \" , a , fpus & 0x4700 ) ; \n fpu_clear_exceptions ( ) ; \n }", "idx": 10338}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb ( QCryptoCipher * cipher , \n const uint8_t * key , size_t nkey , \n Error * * errp ) \n { \n QCryptoCipherBuiltin * ctxt ; \n if ( cipher -> mode != QCRYPTO_CIPHER_MODE_ECB ) { \n error_setg ( errp , \" \" , cipher -> mode ) ; \n return -1 ; \n } \n ctxt = g_new0 ( QCryptoCipherBuiltin , 1 ) ; \n ctxt -> state . desrfb . key = g_new0 ( uint8_t , nkey ) ; \n memcpy ( ctxt -> state . desrfb . key , key , nkey ) ; \n ctxt -> state . desrfb . nkey = nkey ; \n ctxt -> free = qcrypto_cipher_free_des_rfb ; \n ctxt -> setiv = qcrypto_cipher_setiv_des_rfb ; \n ctxt -> encrypt = qcrypto_cipher_encrypt_des_rfb ; \n ctxt -> decrypt = qcrypto_cipher_decrypt_des_rfb ; \n cipher -> opaque = ctxt ; \n return 0 ; \n }", "idx": 10355}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr ( VncState * client ) \n { \n Error * err = NULL ; \n client -> info = g_malloc0 ( sizeof ( * client -> info ) ) ; \n client -> info -> base = g_malloc0 ( sizeof ( * client -> info -> base ) ) ; \n vnc_init_basic_info_from_remote_addr ( client -> csock , client -> info -> base , \n & err ) ; \n if ( err ) { \n qapi_free_VncClientInfo ( client -> info ) ; \n client -> info = NULL ; \n error_free ( err ) ; \n } \n }", "idx": 10370}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_add_irqfd ( KVMState * s , int fd , int virq ) \n { \n return kvm_irqchip_assign_irqfd ( s , fd , virq , true ) ; \n }", "idx": 10374}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean udp_chr_read ( GIOChannel * chan , GIOCondition cond , void * opaque ) \n { \n CharDriverState * chr = opaque ; \n NetCharDriver * s = chr -> opaque ; \n gsize bytes_read = 0 ; \n GIOStatus status ; \n if ( s -> max_size == 0 ) \n return FALSE ; \n status = g_io_channel_read_chars ( s -> chan , ( gchar * ) s -> buf , sizeof ( s -> buf ) , \n & bytes_read , NULL ) ; \n s -> bufcnt = bytes_read ; \n s -> bufptr = s -> bufcnt ; \n if ( status != G_IO_STATUS_NORMAL ) { \n return FALSE ; \n } \n s -> bufptr = 0 ; \n while ( s -> max_size > 0 && s -> bufptr < s -> bufcnt ) { \n qemu_chr_be_write ( chr , & s -> buf [ s -> bufptr ] , 1 ) ; \n s -> bufptr ++ ; \n s -> max_size = qemu_chr_be_can_write ( chr ) ; \n } \n return TRUE ; \n }", "idx": 10385}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect ( target_ulong address , uintptr_t pc , void * puc ) \n { \n unsigned int prot ; \n PageDesc * p ; \n target_ulong host_start , host_end , addr ; \n mmap_lock ( ) ; \n p = page_find ( address >> TARGET_PAGE_BITS ) ; \n if ( ! p ) { \n mmap_unlock ( ) ; \n return 0 ; \n } \n if ( ( p -> flags & PAGE_WRITE_ORG ) && ! ( p -> flags & PAGE_WRITE ) ) { \n host_start = address & qemu_host_page_mask ; \n host_end = host_start + qemu_host_page_size ; \n prot = 0 ; \n for ( addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE ) { \n p = page_find ( addr >> TARGET_PAGE_BITS ) ; \n p -> flags |= PAGE_WRITE ; \n prot |= p -> flags ; \n tb_invalidate_phys_page ( addr , pc , puc ) ; \n #ifdef DEBUG_TB_CHECK \n tb_invalidate_check ( addr ) ; \n #endif \n } \n mprotect ( ( void * ) g2h ( host_start ) , qemu_host_page_size , \n prot & PAGE_BITS ) ; \n mmap_unlock ( ) ; \n return 1 ; \n } \n mmap_unlock ( ) ; \n return 0 ; \n }", "idx": 10416}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_v10_conditional ( DisasContext * dc , TCGv addr , TCGv val , \n unsigned int size , int mem_index ) \n { \n int l1 = gen_new_label ( ) ; \n TCGv taddr = tcg_temp_local_new ( ) ; \n TCGv tval = tcg_temp_local_new ( ) ; \n TCGv t1 = tcg_temp_local_new ( ) ; \n dc -> postinc = 0 ; \n cris_evaluate_flags ( dc ) ; \n tcg_gen_mov_tl ( taddr , addr ) ; \n tcg_gen_mov_tl ( tval , val ) ; \n tcg_gen_andi_tl ( t1 , cpu_PR [ PR_CCS ] , F_FLAG_V10 ) ; \n tcg_gen_brcondi_tl ( TCG_COND_NE , t1 , 0 , l1 ) ; \n if ( size == 1 ) { \n tcg_gen_qemu_st8 ( tval , taddr , mem_index ) ; \n } else if ( size == 2 ) { \n tcg_gen_qemu_st16 ( tval , taddr , mem_index ) ; \n } else { \n tcg_gen_qemu_st32 ( tval , taddr , mem_index ) ; \n } \n gen_set_label ( l1 ) ; \n tcg_gen_shri_tl ( t1 , t1 , 1 ) ; \n tcg_gen_or_tl ( cpu_PR [ PR_CCS ] , cpu_PR [ PR_CCS ] , t1 ) ; \n tcg_temp_free ( t1 ) ; \n tcg_temp_free ( tval ) ; \n tcg_temp_free ( taddr ) ; \n }", "idx": 10478}
{"project": "qemu", "commit_id": "947858b0ba97f4ec097de667e45eff99212867c3", "target": 0, "func": "static void ide_trim_bh_cb ( void * opaque ) \n { \n TrimAIOCB * iocb = opaque ; \n iocb -> common . cb ( iocb -> common . opaque , iocb -> ret ) ; \n qemu_bh_delete ( iocb -> bh ) ; \n iocb -> bh = NULL ; \n qemu_aio_unref ( iocb ) ; \n }", "idx": 10480}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static BdrvDirtyBitmap * block_dirty_bitmap_lookup ( const char * node , \n const char * name , \n BlockDriverState * * pbs , \n AioContext * * paio , \n Error * * errp ) \n { \n BlockDriverState * bs ; \n BdrvDirtyBitmap * bitmap ; \n AioContext * aio_context ; \n if ( ! node ) { \n error_setg ( errp , \" \" ) ; \n return NULL ; \n } \n if ( ! name ) { \n error_setg ( errp , \" \" ) ; \n return NULL ; \n } \n bs = bdrv_lookup_bs ( node , node , NULL ) ; \n if ( ! bs ) { \n error_setg ( errp , \" \" , node ) ; \n return NULL ; \n } \n aio_context = bdrv_get_aio_context ( bs ) ; \n aio_context_acquire ( aio_context ) ; \n bitmap = bdrv_find_dirty_bitmap ( bs , name ) ; \n if ( ! bitmap ) { \n error_setg ( errp , \" \" , name ) ; \n goto fail ; \n } \n if ( pbs ) { \n * pbs = bs ; \n } \n if ( paio ) { \n * paio = aio_context ; \n } else { \n aio_context_release ( aio_context ) ; \n } \n return bitmap ; \n fail : \n aio_context_release ( aio_context ) ; \n return NULL ; \n }", "idx": 10583}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m ( int a , int * * b ) \n { \n asm volatile ( \" \\n \" : \" \" ( a ) , \" \" ( * b ) ) ; \n return a ; \n }", "idx": 10640}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static void vmgenid_query_monitor_test ( void ) \n { \n QemuUUID expected , measured ; \n gchar * cmd ; \n g_assert ( qemu_uuid_parse ( VGID_GUID , & expected ) == 0 ) ; \n cmd = g_strdup_printf ( \" \" \n \" \" , VGID_GUID ) ; \n qtest_start ( cmd ) ; \n read_guid_from_monitor ( & measured ) ; \n g_assert ( memcmp ( measured . data , expected . data , sizeof ( measured . data ) ) == 0 ) ; \n qtest_quit ( global_qtest ) ; \n g_free ( cmd ) ; \n }", "idx": 10648}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static inline void gen_op_movl_seg_T0_vm ( int seg_reg ) \n { \n tcg_gen_andi_tl ( cpu_T [ 0 ] , cpu_T [ 0 ] , 0xffff ) ; \n tcg_gen_st32_tl ( cpu_T [ 0 ] , cpu_env , \n offsetof ( CPUX86State , segs [ seg_reg ] . selector ) ) ; \n tcg_gen_shli_tl ( cpu_T [ 0 ] , cpu_T [ 0 ] , 4 ) ; \n tcg_gen_st_tl ( cpu_T [ 0 ] , cpu_env , \n offsetof ( CPUX86State , segs [ seg_reg ] . base ) ) ; \n }", "idx": 10721}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector ( QVirtioPCIDevice * d , \n QGuestAllocator * alloc , uint16_t entry ) \n { \n uint16_t vector ; \n uint32_t control ; \n void * addr ; \n g_assert ( d -> pdev -> msix_enabled ) ; \n addr = d -> pdev -> msix_table + ( entry * 16 ) ; \n g_assert_cmpint ( entry , >= , 0 ) ; \n g_assert_cmpint ( entry , < , qpci_msix_table_size ( d -> pdev ) ) ; \n d -> config_msix_entry = entry ; \n d -> config_msix_data = 0x12345678 ; \n d -> config_msix_addr = guest_alloc ( alloc , 4 ) ; \n qpci_io_writel ( d -> pdev , addr + PCI_MSIX_ENTRY_LOWER_ADDR , \n d -> config_msix_addr & ~ 0UL ) ; \n qpci_io_writel ( d -> pdev , addr + PCI_MSIX_ENTRY_UPPER_ADDR , \n ( d -> config_msix_addr >> 32 ) & ~ 0UL ) ; \n qpci_io_writel ( d -> pdev , addr + PCI_MSIX_ENTRY_DATA , d -> config_msix_data ) ; \n control = qpci_io_readl ( d -> pdev , addr + PCI_MSIX_ENTRY_VECTOR_CTRL ) ; \n qpci_io_writel ( d -> pdev , addr + PCI_MSIX_ENTRY_VECTOR_CTRL , \n control & ~ PCI_MSIX_ENTRY_CTRL_MASKBIT ) ; \n qpci_io_writew ( d -> pdev , d -> addr + VIRTIO_MSI_CONFIG_VECTOR , entry ) ; \n vector = qpci_io_readw ( d -> pdev , d -> addr + VIRTIO_MSI_CONFIG_VECTOR ) ; \n g_assert_cmphex ( vector , ! = , VIRTIO_MSI_NO_VECTOR ) ; \n }", "idx": 10727}
{"project": "qemu", "commit_id": "d279279e2b5cd40dbcc863fb66a695990f304077", "target": 1, "func": "static void gen_rdhwr ( DisasContext * ctx , int rt , int rd ) \n { \n TCGv t0 ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  \n  check_insn ( ctx , ISA_MIPS32R2 ) ; \n #endif \n t0 = tcg_temp_new ( ) ; \n switch ( rd ) { \n case 0 : \n save_cpu_state ( ctx , 1 ) ; \n gen_helper_rdhwr_cpunum ( t0 , cpu_env ) ; \n gen_store_gpr ( t0 , rt ) ; \n break ; \n case 1 : \n save_cpu_state ( ctx , 1 ) ; \n gen_helper_rdhwr_synci_step ( t0 , cpu_env ) ; \n gen_store_gpr ( t0 , rt ) ; \n break ; \n case 2 : \n save_cpu_state ( ctx , 1 ) ; \n gen_helper_rdhwr_cc ( t0 , cpu_env ) ; \n gen_store_gpr ( t0 , rt ) ; \n break ; \n case 3 : \n save_cpu_state ( ctx , 1 ) ; \n gen_helper_rdhwr_ccres ( t0 , cpu_env ) ; \n gen_store_gpr ( t0 , rt ) ; \n break ; \n case 29 : \n #if defined ( CONFIG_USER_ONLY )  \n  \n  tcg_gen_ld_tl ( t0 , cpu_env , offsetof ( CPUMIPSState , tls_value ) ) ; \n gen_store_gpr ( t0 , rt ) ; \n break ; \n #else \n #endif \n default : \n MIPS_INVAL ( \" \" ) ; \n generate_exception ( ctx , EXCP_RI ) ; \n break ; \n } \n tcg_temp_free ( t0 ) ; \n }", "idx": 10730}
{"project": "qemu", "commit_id": "af01492755b82ccaf0d15014477b34ba3ea643fc", "target": 1, "func": "static void usb_msd_realize_bot ( USBDevice * dev , Error * * errp ) \n { \n MSDState * s = DO_UPCAST ( MSDState , dev , dev ) ; \n usb_desc_create_serial ( dev ) ; \n usb_desc_init ( dev ) ; \n scsi_bus_new ( & s -> bus , sizeof ( s -> bus ) , DEVICE ( dev ) , \n & usb_msd_scsi_info_bot , NULL ) ; \n s -> bus . qbus . allow_hotplug = 0 ; \n usb_msd_handle_reset ( dev ) ; \n }", "idx": 10735}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint ( CPUState * cs , struct kvm_sw_breakpoint * bp ) \n { \n if ( cpu_memory_rw_debug ( cs , bp -> pc , ( uint8_t * ) & bp -> saved_insn , \n sizeof ( diag_501 ) , 0 ) || \n cpu_memory_rw_debug ( cs , bp -> pc , ( uint8_t * ) diag_501 , \n sizeof ( diag_501 ) , 1 ) ) { \n return - EINVAL ; \n } \n return 0 ; \n }", "idx": 10741}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t * ram_chunk_start ( const RDMALocalBlock * rdma_ram_block , \n uint64_t i ) \n { \n return ( uint8_t * ) ( ( ( uintptr_t ) rdma_ram_block -> local_host_addr ) \n + ( i << RDMA_REG_CHUNK_SHIFT ) ) ; \n }", "idx": 10744}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static void csrhci_reset ( struct csrhci_s * s ) \n { \n s -> out_len = 0 ; \n s -> out_size = FIFO_LEN ; \n s -> in_len = 0 ; \n s -> baud_delay = NANOSECONDS_PER_SECOND ; \n s -> enable = 0 ; \n s -> in_hdr = INT_MAX ; \n s -> in_data = INT_MAX ; \n s -> modem_state = 0 ; \n s -> modem_state |= CHR_TIOCM_CTS ; \n memset ( & s -> bd_addr , 0 , sizeof ( bdaddr_t ) ) ; \n }", "idx": 10847}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user ( const Netdev * netdev , const char * name , \n NetClientState * peer , Error * * errp ) \n { \n int queues ; \n const NetdevVhostUserOptions * vhost_user_opts ; \n CharDriverState * chr ; \n assert ( netdev -> type == NET_CLIENT_DRIVER_VHOST_USER ) ; \n vhost_user_opts = & netdev -> u . vhost_user ; \n chr = net_vhost_parse_chardev ( vhost_user_opts , errp ) ; \n if ( ! chr ) { \n return -1 ; \n } \n if ( qemu_opts_foreach ( qemu_find_opts ( \" \" ) , net_vhost_check_net , \n ( char * ) name , errp ) ) { \n return -1 ; \n } \n queues = vhost_user_opts -> has_queues ? vhost_user_opts -> queues : 1 ; \n if ( queues < 1 || queues > MAX_QUEUE_NUM ) { \n error_setg ( errp , \n \" \" , \n MAX_QUEUE_NUM ) ; \n return -1 ; \n } \n return net_vhost_user_init ( peer , \" \" , name , chr , queues ) ; \n }", "idx": 10857}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_flat ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefFlatUnion * tmp = NULL ; \n Error * errp = NULL ; \n Visitor * v ; \n v = validate_test_init ( data , \" \" ) ; \n visit_type_UserDefFlatUnion ( v , & tmp , NULL , & errp ) ; \n g_assert ( error_is_set ( & errp ) ) ; \n qapi_free_UserDefFlatUnion ( tmp ) ; \n }", "idx": 10875}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "void cpu_x86_update_cr4 ( CPUX86State * env , uint32_t new_cr4 ) \n { \n #if defined ( DEBUG_MMU )  \n  \n  printf ( \" \\n \" , ( uint32_t ) env -> cr [ 4 ] ) ; \n #endif \n if ( ( new_cr4 & ( CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK ) ) != \n ( env -> cr [ 4 ] & ( CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK ) ) ) { \n tlb_flush ( env , 1 ) ; \n } \n if ( ! ( env -> cpuid_features & CPUID_SSE ) ) \n new_cr4 &= ~ CR4_OSFXSR_MASK ; \n if ( new_cr4 & CR4_OSFXSR_MASK ) \n env -> hflags |= HF_OSFXSR_MASK ; \n else \n env -> hflags &= ~ HF_OSFXSR_MASK ; \n env -> cr [ 4 ] = new_cr4 ; \n }", "idx": 10877}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unix_wait_for_connect ( int fd , Error * err , void * opaque ) \n { \n MigrationState * s = opaque ; \n if ( fd < 0 ) { \n DPRINTF ( \" \\n \" , error_get_pretty ( err ) ) ; \n s -> file = NULL ; \n migrate_fd_error ( s ) ; \n } else { \n DPRINTF ( \" \\n \" ) ; \n s -> file = qemu_fopen_socket ( fd , \" \" ) ; \n migrate_fd_connect ( s ) ; \n } \n }", "idx": 10914}
{"project": "qemu", "commit_id": "a52b2cbf218d52f9e357961acb271a98a2bdff71", "target": 1, "func": "static void qxl_spice_monitors_config_async ( PCIQXLDevice * qxl , int replay ) \n { \n trace_qxl_spice_monitors_config ( qxl -> id ) ; \n if ( replay ) { \n spice_qxl_monitors_config_async ( & qxl -> ssd . qxl , \n qxl -> guest_monitors_config , \n MEMSLOT_GROUP_GUEST , \n ( uintptr_t ) qxl_cookie_new ( \n QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG , \n 0 ) ) ; \n } else { \n #if SPICE_SERVER_VERSION >= 0x000c06  \n  \n  \n  if ( qxl -> max_outputs ) { \n spice_qxl_set_monitors_config_limit ( & qxl -> ssd . qxl , \n qxl -> max_outputs ) ; \n } \n #endif \n qxl -> guest_monitors_config = qxl -> ram -> monitors_config ; \n spice_qxl_monitors_config_async ( & qxl -> ssd . qxl , \n qxl -> ram -> monitors_config , \n MEMSLOT_GROUP_GUEST , \n ( uintptr_t ) qxl_cookie_new ( QXL_COOKIE_TYPE_IO , \n QXL_IO_MONITORS_CONFIG_ASYNC ) ) ; \n } \n }", "idx": 10974}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status ( VirtIONet * n , uint8_t status ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( n ) ; \n NetClientState * nc = qemu_get_queue ( n -> nic ) ; \n int queues = n -> multiqueue ? n -> max_queues : 1 ; \n if ( ! get_vhost_net ( nc -> peer ) ) { \n return ; \n } \n if ( ! ! n -> vhost_started == \n ( virtio_net_started ( n , status ) && ! nc -> peer -> link_down ) ) { \n return ; \n } \n if ( ! n -> vhost_started ) { \n int r ; \n if ( ! vhost_net_query ( get_vhost_net ( nc -> peer ) , vdev ) ) { \n return ; \n } \n n -> vhost_started = 1 ; \n r = vhost_net_start ( vdev , n -> nic -> ncs , queues ) ; \n if ( r < 0 ) { \n error_report ( \" \" \n \" \" , - r ) ; \n n -> vhost_started = 0 ; \n } \n } else { \n vhost_net_stop ( vdev , n -> nic -> ncs , queues ) ; \n n -> vhost_started = 0 ; \n } \n }", "idx": 10982}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static void spapr_cpu_core_host_initfn ( Object * obj ) \n { \n sPAPRCPUCore * core = SPAPR_CPU_CORE ( obj ) ; \n char * name = g_strdup_printf ( \" \" TYPE_POWERPC_CPU , \" \" ) ; \n ObjectClass * oc = object_class_by_name ( name ) ; \n g_assert ( oc ) ; \n g_free ( ( void * ) name ) ; \n core -> cpu_class = oc ; \n }", "idx": 10984}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void m68k_cpu_list ( FILE * f , int ( * cpu_fprintf ) ( FILE * f , const char * fmt , ... ) ) \n { \n unsigned int i ; \n for ( i = 0 ; m68k_cpu_defs [ i ] . name ; i ++ ) { \n ( * cpu_fprintf ) ( f , \" \\n \" , m68k_cpu_defs [ i ] . name ) ; \n } \n }", "idx": 10999}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug ( AcpiPciHpState * s , PCIDevice * dev , \n PCIHotplugState state ) \n { \n int slot = PCI_SLOT ( dev -> devfn ) ; \n int bsel = acpi_pcihp_get_bsel ( dev -> bus ) ; \n if ( bsel < 0 ) { \n return -1 ; \n } \n if ( state == PCI_COLDPLUG_ENABLED ) { \n s -> acpi_pcihp_pci_status [ bsel ] . device_present |= ( 1U << slot ) ; \n return 0 ; \n } \n if ( state == PCI_HOTPLUG_ENABLED ) { \n enable_device ( s , bsel , slot ) ; \n } else { \n disable_device ( s , bsel , slot ) ; \n } \n return 0 ; \n }", "idx": 11016}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_flush_nodev ( void ) \n { \n QPCIDevice * dev ; \n QPCIBar bmdma_bar , ide_bar ; \n ide_test_start ( \" \" ) ; \n dev = get_pci_device ( & bmdma_bar , & ide_bar ) ; \n qpci_io_writeb ( dev , ide_bar , reg_device , 0 ) ; \n qpci_io_writeb ( dev , ide_bar , reg_command , CMD_FLUSH_CACHE ) ; \n ide_test_quit ( ) ; \n }", "idx": 11046}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush ( int64_t handle , Error * * errp ) \n { \n GuestFileHandle * gfh = guest_file_handle_find ( handle , errp ) ; \n FILE * fh ; \n int ret ; \n if ( ! gfh ) { \n return ; \n } \n fh = gfh -> fh ; \n ret = fflush ( fh ) ; \n if ( ret == EOF ) { \n error_setg_errno ( errp , errno , \" \" ) ; \n } \n }", "idx": 11070}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "int bdrv_snapshot_delete ( BlockDriverState * bs , const char * snapshot_id ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) { \n return - ENOMEDIUM ; \n } \n if ( drv -> bdrv_snapshot_delete ) { \n return drv -> bdrv_snapshot_delete ( bs , snapshot_id ) ; \n } \n if ( bs -> file ) { \n return bdrv_snapshot_delete ( bs -> file , snapshot_id ) ; \n } \n return - ENOTSUP ; \n }", "idx": 11117}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pci_apb_ioreadl ( void * opaque , target_phys_addr_t addr ) \n { \n uint32_t val ; \n val = bswap32 ( cpu_inl ( addr & IOPORTS_MASK ) ) ; \n return val ; \n }", "idx": 11126}
{"project": "qemu", "commit_id": "5dafc53f1fb091d242f2179ffcb43bb28af36d1e", "target": 0, "func": "static void qemu_fill_buffer ( QEMUFile * f ) \n { \n int len ; \n if ( f -> is_writable ) \n return ; \n if ( f -> is_file ) { \n fseek ( f -> outfile , f -> buf_offset , SEEK_SET ) ; \n len = fread ( f -> buf , 1 , IO_BUF_SIZE , f -> outfile ) ; \n if ( len < 0 ) \n len = 0 ; \n } else { \n len = bdrv_pread ( f -> bs , f -> base_offset + f -> buf_offset , \n f -> buf , IO_BUF_SIZE ) ; \n if ( len < 0 ) \n len = 0 ; \n } \n f -> buf_index = 0 ; \n f -> buf_size = len ; \n f -> buf_offset += len ; \n }", "idx": 11127}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients ( void ) \n { \n NetHub * hub ; \n NetHubPort * port ; \n NetClientState * peer ; \n QLIST_FOREACH ( hub , & hubs , next )  { \n int has_nic = 0 , has_host_dev = 0 ; \n QLIST_FOREACH ( port , & hub -> ports , next )  { \n peer = port -> nc . peer ; \n if ( ! peer ) { \n fprintf ( stderr , \" \\n \" , \n port -> nc . name ) ; \n continue ; \n } \n switch ( peer -> info -> type ) { \n case NET_CLIENT_DRIVER_NIC : \n has_nic = 1 ; \n break ; \n case NET_CLIENT_DRIVER_USER : \n case NET_CLIENT_DRIVER_TAP : \n case NET_CLIENT_DRIVER_SOCKET : \n case NET_CLIENT_DRIVER_VDE : \n case NET_CLIENT_DRIVER_VHOST_USER : \n has_host_dev = 1 ; \n break ; \n default : \n break ; \n } \n } \n if ( has_host_dev && ! has_nic ) { \n warn_report ( \" \" , hub -> id ) ; \n } \n if ( has_nic && ! has_host_dev ) { \n fprintf ( stderr , \n \" \\n \" , \n hub -> id ) ; \n } \n } \n }", "idx": 11128}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue ( QEMUFile * f , IRQQueue * q ) \n { \n unsigned int i ; \n for ( i = 0 ; i < BF_WIDTH ( MAX_IRQ ) ; i ++ ) \n qemu_put_be32s ( f , & q -> queue [ i ] ) ; \n qemu_put_sbe32s ( f , & q -> next ) ; \n qemu_put_sbe32s ( f , & q -> priority ) ; \n }", "idx": 11142}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void omap_rtc_reset ( struct omap_rtc_s * s ) \n { \n struct tm tm ; \n s -> interrupts = 0 ; \n s -> comp_reg = 0 ; \n s -> running = 0 ; \n s -> pm_am = 0 ; \n s -> auto_comp = 0 ; \n s -> round = 0 ; \n s -> tick = qemu_get_clock ( rt_clock ) ; \n memset ( & s -> alarm_tm , 0 , sizeof ( s -> alarm_tm ) ) ; \n s -> alarm_tm . tm_mday = 0x01 ; \n s -> status = 1 << 7 ; \n qemu_get_timedate ( & tm , 0 ) ; \n s -> ti = mktimegm ( & tm ) ; \n omap_rtc_alarm_update ( s ) ; \n omap_rtc_tick ( s ) ; \n }", "idx": 11167}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_enable ( IPMIBmcSim * ibs , \n uint8_t * cmd , unsigned int cmd_len , \n uint8_t * rsp , unsigned int * rsp_len , \n unsigned int max_rsp_len ) \n { \n IPMISensor * sens ; \n IPMI_CHECK_CMD_LEN ( 3 ) ; \n if ( ( cmd [ 2 ] > MAX_SENSORS ) || \n ! IPMI_SENSOR_GET_PRESENT ( ibs -> sensors + cmd [ 2 ] ) ) { \n rsp [ 2 ] = IPMI_CC_REQ_ENTRY_NOT_PRESENT ; \n return ; \n } \n sens = ibs -> sensors + cmd [ 2 ] ; \n IPMI_ADD_RSP_DATA ( IPMI_SENSOR_GET_RET_STATUS ( sens ) ) ; \n IPMI_ADD_RSP_DATA ( sens -> assert_enable & 0xff ) ; \n IPMI_ADD_RSP_DATA ( ( sens -> assert_enable >> 8 ) & 0xff ) ; \n IPMI_ADD_RSP_DATA ( sens -> deassert_enable & 0xff ) ; \n IPMI_ADD_RSP_DATA ( ( sens -> deassert_enable >> 8 ) & 0xff ) ; \n }", "idx": 11202}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_uart_s * omap_uart_init ( hwaddr base , \n qemu_irq irq , omap_clk fclk , omap_clk iclk , \n qemu_irq txdma , qemu_irq rxdma , \n const char * label , CharDriverState * chr ) \n { \n struct omap_uart_s * s = ( struct omap_uart_s * ) \n g_malloc0 ( sizeof ( struct omap_uart_s ) ) ; \n s -> base = base ; \n s -> fclk = fclk ; \n s -> irq = irq ; \n s -> serial = serial_mm_init ( get_system_memory ( ) , base , 2 , irq , \n omap_clk_getrate ( fclk ) / 16 , \n chr ?  : qemu_chr_new ( label , \" \" , NULL ) , \n DEVICE_NATIVE_ENDIAN ) ; \n return s ; \n }", "idx": 11235}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list ( BlockDriverState * bs , \n QEMUSnapshotInfo * * psn_tab ) \n { \n BDRVRBDState * s = bs -> opaque ; \n QEMUSnapshotInfo * sn_info , * sn_tab = NULL ; \n int i , snap_count ; \n rbd_snap_info_t * snaps ; \n int max_snaps = RBD_MAX_SNAPS ; \n do { \n snaps = g_malloc ( sizeof ( * snaps ) * max_snaps ) ; \n snap_count = rbd_snap_list ( s -> image , snaps , & max_snaps ) ; \n if ( snap_count < 0 ) { \n g_free ( snaps ) ; \n } \n } while ( snap_count == - ERANGE ) ; \n if ( snap_count <= 0 ) { \n return snap_count ; \n } \n sn_tab = g_malloc0 ( snap_count * sizeof ( QEMUSnapshotInfo ) ) ; \n for ( i = 0 ; i < snap_count ; i ++ ) { \n const char * snap_name = snaps [ i ] . name ; \n sn_info = sn_tab + i ; \n pstrcpy ( sn_info -> id_str , sizeof ( sn_info -> id_str ) , snap_name ) ; \n pstrcpy ( sn_info -> name , sizeof ( sn_info -> name ) , snap_name ) ; \n sn_info -> vm_state_size = snaps [ i ] . size ; \n sn_info -> date_sec = 0 ; \n sn_info -> date_nsec = 0 ; \n sn_info -> vm_clock_nsec = 0 ; \n } \n rbd_snap_list_end ( snaps ) ; \n * psn_tab = sn_tab ; \n return snap_count ; \n }", "idx": 11303}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read ( V9fsState * s , V9fsPDU * pdu , V9fsFidState * fidp , \n uint64_t off , uint32_t max_count ) \n { \n ssize_t err ; \n size_t offset = 7 ; \n int read_count ; \n int64_t xattr_len ; \n V9fsVirtioState * v = container_of ( s , V9fsVirtioState , state ) ; \n VirtQueueElement * elem = v -> elems [ pdu -> idx ] ; \n xattr_len = fidp -> fs . xattr . len ; \n read_count = xattr_len - off ; \n if ( read_count > max_count ) { \n read_count = max_count ; \n } else if ( read_count < 0 ) { \n read_count = 0 ; \n } \n err = pdu_marshal ( pdu , offset , \" \" , read_count ) ; \n if ( err < 0 ) { \n return err ; \n } \n offset += err ; \n err = v9fs_pack ( elem -> in_sg , elem -> in_num , offset , \n ( ( char * ) fidp -> fs . xattr . value ) + off , \n read_count ) ; \n if ( err < 0 ) { \n return err ; \n } \n offset += err ; \n return offset ; \n }", "idx": 11328}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors ) \n { \n int ret ; \n BDRVVmdkState * s = bs -> opaque ; \n qemu_co_mutex_lock ( & s -> lock ) ; \n ret = vmdk_write ( bs , sector_num , buf , nb_sectors ) ; \n qemu_co_mutex_unlock ( & s -> lock ) ; \n return ret ; \n }", "idx": 11334}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void lm32_juart_set_jtx ( DeviceState * d , uint32_t jtx ) \n { \n LM32JuartState * s = LM32_JUART ( d ) ; \n unsigned char ch = jtx & 0xff ; \n trace_lm32_juart_set_jtx ( s -> jtx ) ; \n s -> jtx = jtx ; \n if ( s -> chr ) { \n qemu_chr_fe_write_all ( s -> chr , & ch , 1 ) ; \n } \n }", "idx": 11381}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "send_msg ( \n VSCMsgType  type , \n uint32_t reader_id , \n const  void * msg , \n unsigned  int length \n ) { \n VSCMsgHeader mhHeader ; \n qemu_mutex_lock ( & socket_to_send_lock ) ; \n if ( verbose > 10 ) { \n printf ( \" \\n \" , \n type , reader_id , length , length ) ; \n } \n mhHeader . type = htonl ( type ) ; \n mhHeader . reader_id = 0 ; \n mhHeader . length = htonl ( length ) ; \n g_byte_array_append ( socket_to_send , ( guint8 * ) & mhHeader , sizeof ( mhHeader ) ) ; \n g_byte_array_append ( socket_to_send , ( guint8 * ) msg , length ) ; \n g_idle_add ( socket_prepare_sending , NULL ) ; \n qemu_mutex_unlock ( & socket_to_send_lock ) ; \n return 0 ; \n }", "idx": 11400}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_platreg_read ( void * opaque , hwaddr addr , \n unsigned size ) \n { \n BostonState * s = opaque ; \n uint32_t gic_freq , val ; \n if ( size != 4 ) { \n qemu_log_mask ( LOG_UNIMP , \" \" , size ) ; \n return 0 ; \n } \n switch ( addr & 0xffff ) { \n case PLAT_FPGA_BUILD : \n case PLAT_CORE_CL : \n case PLAT_WRAPPER_CL : \n return 0 ; \n case PLAT_DDR3_STATUS : \n return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED ; \n case PLAT_MMCM_DIV : \n gic_freq = mips_gictimer_get_freq ( s -> cps -> gic . gic_timer ) / 1000000 ; \n val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT ; \n val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT ; \n val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT ; \n val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT ; \n return val ; \n case PLAT_BUILD_CFG : \n val = PLAT_BUILD_CFG_PCIE0_EN ; \n val |= PLAT_BUILD_CFG_PCIE1_EN ; \n val |= PLAT_BUILD_CFG_PCIE2_EN ; \n return val ; \n case PLAT_DDR_CFG : \n val = s -> mach -> ram_size / G_BYTE ; \n assert ( ! ( val & ~ PLAT_DDR_CFG_SIZE ) ) ; \n val |= PLAT_DDR_CFG_MHZ ; \n return val ; \n default : \n qemu_log_mask ( LOG_UNIMP , \" \" HWADDR_PRIx , \n addr & 0xffff ) ; \n return 0 ; \n } \n }", "idx": 11439}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_cancel ( Error * * errp ) \n { \n migrate_fd_cancel ( migrate_get_current ( ) ) ; \n }", "idx": 11449}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close ( struct CharDriverState * chr ) \n { \n MouseState * mouse = chr -> opaque ; \n qemu_input_handler_unregister ( mouse -> hs ) ; \n g_free ( mouse ) ; \n g_free ( chr ) ; \n }", "idx": 11501}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_init_main_loop ( void ) \n { \n int ret ; \n ret = qemu_signal_init ( ) ; \n if ( ret ) { \n return ret ; \n } \n qemu_init_sigbus ( ) ; \n return qemu_event_init ( ) ; \n }", "idx": 11516}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse ( envlist_t * envlist , const char * env , \n int ( * callback ) ( envlist_t *  , const char * ) )  \n { \n char * tmpenv , * envvar ; \n char * envsave = NULL ; \n assert ( callback != NULL ) ; \n if ( ( envlist == NULL ) || ( env == NULL ) ) \n return ( EINVAL ) ; \n if ( ( tmpenv = strdup ( env ) ) == NULL ) \n return ( errno ) ; \n envvar = strtok_r ( tmpenv , \" \" , & envsave ) ; \n while ( envvar != NULL ) { \n if ( ( * callback ) ( envlist , envvar ) != 0 ) { \n free ( tmpenv ) ; \n return ( errno ) ; \n } \n envvar = strtok_r ( NULL , \" \" , & envsave ) ; \n } \n free ( tmpenv ) ; \n return ( 0 ) ; \n }", "idx": 11524}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16 ( TCGv t0 , TCGv t1 ) \n { \n TCGv rd , tmp ; \n rd = new_tmp ( ) ; \n tmp = new_tmp ( ) ; \n tcg_gen_shli_i32 ( rd , t0 , 16 ) ; \n tcg_gen_andi_i32 ( tmp , t1 , 0xffff ) ; \n tcg_gen_or_i32 ( rd , rd , tmp ) ; \n tcg_gen_shri_i32 ( t1 , t1 , 16 ) ; \n tcg_gen_andi_i32 ( tmp , t0 , 0xffff0000 ) ; \n tcg_gen_or_i32 ( t1 , t1 , tmp ) ; \n tcg_gen_mov_i32 ( t0 , rd ) ; \n dead_tmp ( tmp ) ; \n dead_tmp ( rd ) ; \n }", "idx": 11546}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "restore_sigcontext ( CPUMIPSState * regs , struct target_sigcontext * sc )  \n { \n int err = 0 ; \n int i ; \n __get_user ( regs -> CP0_EPC , & sc -> sc_pc ) ; \n __get_user ( regs -> active_tc . HI [ 0 ] , & sc -> sc_mdhi ) ; \n __get_user ( regs -> active_tc . LO [ 0 ] , & sc -> sc_mdlo ) ; \n for ( i = 1 ; i < 32 ; ++ i ) { \n __get_user ( regs -> active_tc . gpr [ i ] , & sc -> sc_regs [ i ] ) ; \n } \n __get_user ( regs -> active_tc . HI [ 1 ] , & sc -> sc_hi1 ) ; \n __get_user ( regs -> active_tc . HI [ 2 ] , & sc -> sc_hi2 ) ; \n __get_user ( regs -> active_tc . HI [ 3 ] , & sc -> sc_hi3 ) ; \n __get_user ( regs -> active_tc . LO [ 1 ] , & sc -> sc_lo1 ) ; \n __get_user ( regs -> active_tc . LO [ 2 ] , & sc -> sc_lo2 ) ; \n __get_user ( regs -> active_tc . LO [ 3 ] , & sc -> sc_lo3 ) ; \n { \n uint32_t dsp ; \n __get_user ( dsp , & sc -> sc_dsp ) ; \n cpu_wrdsp ( dsp , 0x3ff , regs ) ; \n } \n for ( i = 0 ; i < 32 ; ++ i ) { \n __get_user ( regs -> active_fpu . fpr [ i ] . d , & sc -> sc_fpregs [ i ] ) ; \n } \n return err ; \n }", "idx": 11566}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_block_to_card ( SDHCIState * s ) \n { \n int index = 0 ; \n if ( s -> prnsts & SDHC_SPACE_AVAILABLE ) { \n if ( s -> norintstsen & SDHC_NISEN_WBUFRDY ) { \n s -> norintsts |= SDHC_NIS_WBUFRDY ; \n } \n sdhci_update_irq ( s ) ; \n return ; \n } \n if ( s -> trnmod & SDHC_TRNS_BLK_CNT_EN ) { \n if ( s -> blkcnt == 0 ) { \n return ; \n } else { \n s -> blkcnt -- ; \n } \n } \n for ( index = 0 ; index < ( s -> blksize & 0x0fff ) ; index ++ ) { \n sd_write_data ( s -> card , s -> fifo_buffer [ index ] ) ; \n } \n s -> prnsts |= SDHC_SPACE_AVAILABLE ; \n if ( ( s -> trnmod & SDHC_TRNS_MULTI ) == 0 || \n ( ( s -> trnmod & SDHC_TRNS_MULTI ) && \n ( s -> trnmod & SDHC_TRNS_BLK_CNT_EN ) && ( s -> blkcnt == 0 ) ) ) { \n SDHCI_GET_CLASS ( s ) -> end_data_transfer ( s ) ; \n } else if ( s -> norintstsen & SDHC_NISEN_WBUFRDY ) { \n s -> norintsts |= SDHC_NIS_WBUFRDY ; \n } \n if ( s -> stopped_state == sdhc_gap_write && ( s -> trnmod & SDHC_TRNS_MULTI ) && \n s -> blkcnt > 0 ) { \n s -> prnsts &= ~ SDHC_DOING_WRITE ; \n if ( s -> norintstsen & SDHC_EISEN_BLKGAP ) { \n s -> norintsts |= SDHC_EIS_BLKGAP ; \n } \n SDHCI_GET_CLASS ( s ) -> end_data_transfer ( s ) ; \n } \n sdhci_update_irq ( s ) ; \n }", "idx": 11592}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static AHCIQState * ahci_boot ( void ) \n { \n AHCIQState * s ; \n const char * cli ; \n s = g_malloc0 ( sizeof ( AHCIQState ) ) ; \n cli = \" \" \n \" \" \n \" \" \n \" \" \n \" \" ; \n s -> parent = qtest_pc_boot ( cli , tmp_path , \" \" , \" \" ) ; \n alloc_set_flags ( s -> parent -> alloc , ALLOC_LEAK_ASSERT ) ; \n s -> dev = get_ahci_device ( & s -> fingerprint ) ; \n return s ; \n }", "idx": 11608}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch ( AddressSpace * as ) \n { \n AddressSpaceDispatch * d = as -> dispatch ; \n memory_listener_unregister ( & d -> listener ) ; \n g_free ( d ) ; \n as -> dispatch = NULL ; \n }", "idx": 11624}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_readb ( void * opaque , target_phys_addr_t addr )  \n { \n mst_irq_state * s = ( mst_irq_state * ) opaque ; \n switch ( addr ) { \n case MST_LEDDAT1 : \n return s -> leddat1 ; \n case MST_LEDDAT2 : \n return s -> leddat2 ; \n case MST_LEDCTRL : \n return s -> ledctrl ; \n case MST_GPSWR : \n return s -> gpswr ; \n case MST_MSCWR1 : \n return s -> mscwr1 ; \n case MST_MSCWR2 : \n return s -> mscwr2 ; \n case MST_MSCWR3 : \n return s -> mscwr3 ; \n case MST_MSCRD : \n return s -> mscrd ; \n case MST_INTMSKENA : \n return s -> intmskena ; \n case MST_INTSETCLR : \n return s -> intsetclr ; \n case MST_PCMCIA0 : \n return s -> pcmcia0 ; \n case MST_PCMCIA1 : \n return s -> pcmcia1 ; \n default : \n printf ( \" \" \n \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n } \n return 0 ; \n }", "idx": 11631}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix_ide_initfn ( PCIIDEState * d ) \n { \n uint8_t * pci_conf = d -> dev . config ; \n pci_conf [ PCI_CLASS_PROG ] = 0x80 ; \n pci_config_set_class ( pci_conf , PCI_CLASS_STORAGE_IDE ) ; \n qemu_register_reset ( piix3_reset , d ) ; \n pci_register_bar ( & d -> dev , 4 , 0x10 , PCI_BASE_ADDRESS_SPACE_IO , bmdma_map ) ; \n vmstate_register ( & d -> dev . qdev , 0 , & vmstate_ide_pci , d ) ; \n pci_piix_init_ports ( d ) ; \n return 0 ; \n }", "idx": 11635}
{"project": "qemu", "commit_id": "da3e8a23492dbc13c4b70d90b6ae42970624e63a", "target": 0, "func": "static void virtio_net_pci_realize ( VirtIOPCIProxy * vpci_dev , Error * * errp ) \n { \n DeviceState * qdev = DEVICE ( vpci_dev ) ; \n VirtIONetPCI * dev = VIRTIO_NET_PCI ( vpci_dev ) ; \n DeviceState * vdev = DEVICE ( & dev -> vdev ) ; \n virtio_net_set_config_size ( & dev -> vdev , vpci_dev -> host_features ) ; \n virtio_net_set_netclient_name ( & dev -> vdev , qdev -> id , \n object_get_typename ( OBJECT ( qdev ) ) ) ; \n qdev_set_parent_bus ( vdev , BUS ( & vpci_dev -> bus ) ) ; \n object_property_set_bool ( OBJECT ( vdev ) , true , \" \" , errp ) ; \n }", "idx": 11641}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize ( VIOsPAPRDevice * dev , Error * * errp ) \n { \n sPAPRNVRAM * nvram = VIO_SPAPR_NVRAM ( dev ) ; \n int ret ; \n if ( nvram -> blk ) { \n nvram -> size = blk_getlength ( nvram -> blk ) ; \n ret = blk_set_perm ( nvram -> blk , \n BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE , \n BLK_PERM_ALL , errp ) ; \n if ( ret < 0 ) { \n return ; \n } \n } else { \n nvram -> size = DEFAULT_NVRAM_SIZE ; \n } \n nvram -> buf = g_malloc0 ( nvram -> size ) ; \n if ( ( nvram -> size < MIN_NVRAM_SIZE ) || ( nvram -> size > MAX_NVRAM_SIZE ) ) { \n error_setg ( errp , \" \" , \n MIN_NVRAM_SIZE , MAX_NVRAM_SIZE ) ; \n return ; \n } \n if ( nvram -> blk ) { \n int alen = blk_pread ( nvram -> blk , 0 , nvram -> buf , nvram -> size ) ; \n if ( alen != nvram -> size ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n } else if ( nb_prom_envs > 0 ) { \n chrp_nvram_create_system_partition ( nvram -> buf , MIN_NVRAM_SIZE / 4 ) ; \n chrp_nvram_create_free_partition ( & nvram -> buf [ MIN_NVRAM_SIZE / 4 ] , \n nvram -> size - MIN_NVRAM_SIZE / 4 ) ; \n } \n spapr_rtas_register ( RTAS_NVRAM_FETCH , \" \" , rtas_nvram_fetch ) ; \n spapr_rtas_register ( RTAS_NVRAM_STORE , \" \" , rtas_nvram_store ) ; \n }", "idx": 11642}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet ( EHCIPacket * p ) \n { \n trace_usb_ehci_packet_action ( p -> queue , p , \" \" ) ; \n if ( p -> async == EHCI_ASYNC_INFLIGHT ) { \n usb_cancel_packet ( & p -> packet ) ; \n usb_packet_unmap ( & p -> packet , & p -> sgl ) ; \n qemu_sglist_destroy ( & p -> sgl ) ; \n QTAILQ_REMOVE ( & p -> queue -> packets , p , next ) ; \n usb_packet_cleanup ( & p -> packet ) ; \n g_free ( p ) ;", "idx": 11646}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct ( MemoryRegion * mr , bool is_write ) \n { \n if ( memory_region_is_ram ( mr ) ) { \n return ! ( is_write && mr -> readonly ) ; \n } \n if ( memory_region_is_romd ( mr ) ) { \n return ! is_write ; \n } \n return false ; \n }", "idx": 11674}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write ( CPUARMState * env , const ARMCPRegInfo * ri , \n uint64_t value ) \n { \n if ( ri -> crm > 8 ) { \n return EXCP_UDEF ; \n } \n env -> cp15 . c6_region [ ri -> crm ] = value ; \n return 0 ; \n }", "idx": 11714}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int esp_pci_scsi_init ( PCIDevice * dev ) \n { \n PCIESPState * pci = PCI_ESP ( dev ) ; \n DeviceState * d = DEVICE ( dev ) ; \n ESPState * s = & pci -> esp ; \n uint8_t * pci_conf ; \n Error * err = NULL ; \n pci_conf = dev -> config ; \n pci_conf [ PCI_INTERRUPT_PIN ] = 0x01 ; \n s -> dma_memory_read = esp_pci_dma_memory_read ; \n s -> dma_memory_write = esp_pci_dma_memory_write ; \n s -> dma_opaque = pci ; \n s -> chip_id = TCHI_AM53C974 ; \n memory_region_init_io ( & pci -> io , OBJECT ( pci ) , & esp_pci_io_ops , pci , \n \" \" , 0x80 ) ; \n pci_register_bar ( dev , 0 , PCI_BASE_ADDRESS_SPACE_IO , & pci -> io ) ; \n s -> irq = pci_allocate_irq ( dev ) ; \n scsi_bus_new ( & s -> bus , sizeof ( s -> bus ) , d , & esp_pci_scsi_info , NULL ) ; \n if ( ! d -> hotplugged ) { \n scsi_bus_legacy_handle_cmdline ( & s -> bus , & err ) ; \n if ( err != NULL ) { \n error_free ( err ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 11748}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir ( FsContext * ctx , V9fsFidOpenState * fs ) \n { \n return telldir ( fs -> dir ) ; \n }", "idx": 11781}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "void commit_active_start ( BlockDriverState * bs , BlockDriverState * base , \n int64_t speed , \n BlockdevOnError on_error , \n BlockDriverCompletionFunc * cb , \n void * opaque , Error * * errp ) \n { \n int64_t length , base_length ; \n int orig_base_flags ; \n orig_base_flags = bdrv_get_flags ( base ) ; \n if ( bdrv_reopen ( base , bs -> open_flags , errp ) ) { \n return ; \n } \n length = bdrv_getlength ( bs ) ; \n if ( length < 0 ) { \n error_setg ( errp , \" \" , bs -> filename ) ; \n goto error_restore_flags ; \n } \n base_length = bdrv_getlength ( base ) ; \n if ( base_length < 0 ) { \n error_setg ( errp , \" \" , base -> filename ) ; \n goto error_restore_flags ; \n } \n if ( length > base_length ) { \n if ( bdrv_truncate ( base , length ) < 0 ) { \n error_setg ( errp , \" \" \n \" \" , \n bs -> filename , base -> filename ) ; \n goto error_restore_flags ; \n } \n } \n bdrv_ref ( base ) ; \n mirror_start_job ( bs , base , speed , 0 , 0 , \n on_error , on_error , cb , opaque , errp , \n & commit_active_job_driver , false , base ) ; \n if ( error_is_set ( errp ) ) { \n goto error_restore_flags ; \n } \n return ; \n error_restore_flags : \n bdrv_reopen ( base , orig_base_flags , NULL ) ; \n return ; \n }", "idx": 11810}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access ( CPUState * cs , hwaddr addr , \n bool is_write , bool is_exec , int unused , \n unsigned size ) \n { \n AlphaCPU * cpu = ALPHA_CPU ( cs ) ; \n CPUAlphaState * env = & cpu -> env ; \n env -> trap_arg0 = addr ; \n env -> trap_arg1 = is_write ? 1 : 0 ; \n dynamic_excp ( env , 0 , EXCP_MCHK , 0 ) ; \n }", "idx": 11833}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static int virtio_serial_init_pci ( PCIDevice * pci_dev ) \n { \n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ; \n VirtIODevice * vdev ; \n if ( proxy -> class_code != PCI_CLASS_COMMUNICATION_OTHER && \n proxy -> class_code != PCI_CLASS_DISPLAY_OTHER && \n proxy -> class_code != PCI_CLASS_OTHERS ) \n proxy -> class_code = PCI_CLASS_COMMUNICATION_OTHER ; \n vdev = virtio_serial_init ( & pci_dev -> qdev , & proxy -> serial ) ; \n if ( ! vdev ) { \n return -1 ; \n } \n vdev -> nvectors = proxy -> nvectors == DEV_NVECTORS_UNSPECIFIED \n ? proxy -> serial . max_virtserial_ports + 1 \n : proxy -> nvectors ; \n virtio_init_pci ( proxy , vdev , \n PCI_VENDOR_ID_REDHAT_QUMRANET , \n PCI_DEVICE_ID_VIRTIO_CONSOLE , \n proxy -> class_code , 0x00 ) ; \n proxy -> nvectors = vdev -> nvectors ; \n return 0 ; \n }", "idx": 11834}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState * qmp_chardev_open_serial ( const char * id , \n ChardevBackend * backend , \n ChardevReturn * ret , \n Error * * errp ) \n { \n ChardevHostdev * serial = backend -> serial ; \n int fd ; \n fd = qmp_chardev_open_file_source ( serial -> device , O_RDWR , errp ) ; \n if ( fd < 0 ) { \n return NULL ; \n } \n qemu_set_nonblock ( fd ) ; \n return qemu_chr_open_tty_fd ( fd ) ; \n }", "idx": 11840}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup ( PCIBus * pci_bus ) \n { \n switch ( vga_interface_type ) { \n #ifdef CONFIG_SPICE \n case VGA_QXL : \n pci_create_simple ( pci_bus , -1 , \" \" ) ; \n return ; \n #endif \n case VGA_CIRRUS : \n pci_cirrus_vga_init ( pci_bus ) ; \n return ; \n case VGA_VMWARE : \n if ( pci_vmsvga_init ( pci_bus ) ) { \n return ; \n } \n break ; \n } \n if ( vga_interface_type != VGA_NONE ) { \n pci_vga_init ( pci_bus ) ; \n } \n }", "idx": 11843}
{"project": "qemu", "commit_id": "75554a3ca10a7ad295d2a3d2e14ee6ba90f94c8b", "target": 0, "func": "struct omap_uart_s * omap2_uart_init ( struct omap_target_agent_s * ta , \n qemu_irq irq , omap_clk fclk , omap_clk iclk , \n qemu_irq txdma , qemu_irq rxdma , CharDriverState * chr ) \n { \n target_phys_addr_t base = omap_l4_attach ( ta , 0 , 0 ) ; \n struct omap_uart_s * s = omap_uart_init ( base , irq , \n fclk , iclk , txdma , rxdma , chr ) ; \n int iomemtype = cpu_register_io_memory ( 0 , omap_uart_readfn , \n omap_uart_writefn , s ) ; \n s -> ta = ta ; \n s -> base = base ; \n cpu_register_physical_memory ( s -> base + 0x20 , 0x100 , iomemtype ) ; \n return s ; \n }", "idx": 11844}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void coroutine_fn bdrv_create_co_entry ( void * opaque ) \n { \n Error * local_err = NULL ; \n int ret ; \n CreateCo * cco = opaque ; \n assert ( cco -> drv ) ; \n ret = cco -> drv -> bdrv_create ( cco -> filename , cco -> opts , & local_err ) ; \n if ( local_err ) { \n error_propagate ( & cco -> err , local_err ) ; \n } \n cco -> ret = ret ; \n }", "idx": 11853}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void helper_mtc0_entryhi ( CPUMIPSState * env , target_ulong arg1 ) \n { \n target_ulong old , val , mask ; \n mask = ( TARGET_PAGE_MASK << 1 ) | env -> CP0_EntryHi_ASID_mask ; \n if ( ( ( env -> CP0_Config4 >> CP0C4_IE ) & 0x3 ) >= 2 ) { \n mask |= 1 << CP0EnHi_EHINV ; \n } \n #if defined ( TARGET_MIPS64 )  \n  \n  if ( env -> insn_flags & ISA_MIPS32R6 ) { \n int entryhi_r = extract64 ( arg1 , 62 , 2 ) ; \n int config0_at = extract32 ( env -> CP0_Config0 , 13 , 2 ) ; \n bool no_supervisor = ( env -> CP0_Status_rw_bitmask & 0x8 ) == 0 ; \n if ( ( entryhi_r == 2 ) || \n ( entryhi_r == 1 && ( no_supervisor || config0_at == 1 ) ) ) { \n mask &= ~ ( 0x3ull << 62 ) ; \n } \n } \n mask &= env -> SEGMask ; \n #endif \n old = env -> CP0_EntryHi ; \n val = ( arg1 & mask ) | ( old & ~ mask ) ; \n env -> CP0_EntryHi = val ; \n if ( env -> CP0_Config3 & ( 1 << CP0C3_MT ) ) { \n sync_c0_entryhi ( env , env -> current_tc ) ; \n } \n if ( ( old & env -> CP0_EntryHi_ASID_mask ) != \n ( val & env -> CP0_EntryHi_ASID_mask ) ) { \n cpu_mips_tlb_flush ( env ) ; \n } \n }", "idx": 11854}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static bool vmxnet3_verify_driver_magic ( hwaddr dshmem ) \n { \n return ( VMXNET3_READ_DRV_SHARED32 ( dshmem , magic ) == VMXNET3_REV1_MAGIC ) ; \n }", "idx": 11861}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail ( void * ptr ) \n { \n ram_addr_t ram_addr ; \n if ( qemu_ram_addr_from_host ( ptr , & ram_addr ) ) { \n fprintf ( stderr , \" \\n \" , ptr ) ; \n abort ( ) ; \n } \n return ram_addr ; \n }", "idx": 11865}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit ( uint32_t * field , int bit ) \n { \n return ( field [ bit >> 5 ] & 1 << ( bit & 0x1F ) ) != 0 ; \n }", "idx": 11911}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal ( void ) \n { \n const char * str = \" \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n unsigned long res = 999 ; \n int err ; \n err = qemu_strtoul ( str , & endptr , 10 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 123 ) ; \n g_assert ( endptr == str + strlen ( str ) ) ; \n str = \" \" ; \n res = 999 ; \n endptr = & f ; \n err = qemu_strtoul ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 123 ) ; \n g_assert ( endptr == str + strlen ( str ) ) ; \n }", "idx": 11919}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ; \n dc -> desc = \" \" ; \n dc -> vmsd = & vmstate_piix3 ; \n dc -> no_user = 1 , \n k -> no_hotplug = 1 ; \n k -> init = piix3_initfn ; \n k -> config_write = piix3_write_config ; \n k -> vendor_id = PCI_VENDOR_ID_INTEL ; \n k -> device_id = PCI_DEVICE_ID_INTEL_82371SB_0 ; \n k -> class_id = PCI_CLASS_BRIDGE_ISA ; \n }", "idx": 11933}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch ( GSource * source , \n GSourceFunc callback , \n gpointer user_data )  \n { \n QIOChannelFunc func = ( QIOChannelFunc ) callback ; \n QIOChannelWebsockSource * wsource = ( QIOChannelWebsockSource * ) source ; \n GIOCondition cond = 0 ; \n if ( wsource -> wioc -> rawinput . offset ) { \n cond |= G_IO_IN ; \n } \n if ( wsource -> wioc -> rawoutput . offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER ) { \n cond |= G_IO_OUT ; \n } \n return ( * func ) ( QIO_CHANNEL ( wsource -> wioc ) , \n ( cond & wsource -> condition ) , \n user_data ) ; \n }", "idx": 11936}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_parent_open ( BlockDriverState * bs ) \n { \n char * p_name ; \n char desc [ DESC_SIZE + 1 ] ; \n BDRVVmdkState * s = bs -> opaque ; \n desc [ DESC_SIZE ] = ' \\0 ' ; \n if ( bdrv_pread ( bs -> file , s -> desc_offset , desc , DESC_SIZE ) != DESC_SIZE ) { \n return -1 ; \n } \n if ( ( p_name = strstr ( desc , \" \" ) ) != NULL ) { \n char * end_name ; \n p_name += sizeof ( \" \" ) + 1 ; \n if ( ( end_name = strchr ( p_name , ' \\\" ' ) ) == NULL ) \n return -1 ; \n if ( ( end_name - p_name ) > sizeof ( bs -> backing_file ) - 1 ) \n return -1 ; \n pstrcpy ( bs -> backing_file , end_name - p_name + 1 , p_name ) ; \n } \n return 0 ; \n }", "idx": 11958}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static MemoryRegionSection address_space_do_translate ( AddressSpace * as , \n hwaddr addr , \n hwaddr * xlat , \n hwaddr * plen , \n bool is_write , \n bool is_mmio ) \n { \n IOMMUTLBEntry iotlb ; \n MemoryRegionSection * section ; \n MemoryRegion * mr ; \n for ( ; ; ) { \n AddressSpaceDispatch * d = atomic_rcu_read ( & as -> dispatch ) ; \n section = address_space_translate_internal ( d , addr , & addr , plen , is_mmio ) ; \n mr = section -> mr ; \n if ( ! mr -> iommu_ops ) { \n break ; \n } \n iotlb = mr -> iommu_ops -> translate ( mr , addr , is_write ) ; \n addr = ( ( iotlb . translated_addr & ~ iotlb . addr_mask ) \n | ( addr & iotlb . addr_mask ) ) ; \n * plen = MIN ( * plen , ( addr | iotlb . addr_mask ) - addr + 1 ) ; \n if ( ! ( iotlb . perm & ( 1 << is_write ) ) ) { \n goto translate_fail ; \n } \n as = iotlb . target_as ; \n } \n * xlat = addr ; \n return * section ; \n translate_fail : \n return ( MemoryRegionSection ) { . mr = & io_mem_unassigned } ; \n }", "idx": 11969}
{"project": "qemu", "commit_id": "30de46db50d2f9f74c5f7ab1cc463b8dec026407", "target": 0, "func": "static void read_guest_mem ( void ) \n { \n uint32_t * guest_mem ; \n gint64 end_time ; \n int i , j ; \n size_t size ; \n g_mutex_lock ( data_mutex ) ; \n end_time = g_get_monotonic_time ( ) + 5 * G_TIME_SPAN_SECOND ; \n while ( ! fds_num ) { \n if ( ! _cond_wait_until ( data_cond , data_mutex , end_time ) ) { \n g_assert ( fds_num ) ; \n break ; \n } \n } \n g_assert_cmpint ( fds_num , > , 0 ) ; \n g_assert_cmpint ( fds_num , == , memory . nregions ) ; \n for ( i = 0 ; i < fds_num ; i ++ ) { \n if ( memory . regions [ i ] . guest_phys_addr != 0x0 ) { \n continue ; \n } \n g_assert_cmpint ( memory . regions [ i ] . memory_size , > , 1024 ) ; \n size = memory . regions [ i ] . memory_size + memory . regions [ i ] . mmap_offset ; \n guest_mem = mmap ( 0 , size , PROT_READ | PROT_WRITE , \n MAP_SHARED , fds [ i ] , 0 ) ; \n g_assert ( guest_mem != MAP_FAILED ) ; \n guest_mem += ( memory . regions [ i ] . mmap_offset / sizeof ( * guest_mem ) ) ; \n for ( j = 0 ; j < 256 ; j ++ ) { \n uint32_t a = readl ( memory . regions [ i ] . guest_phys_addr + j * 4 ) ; \n uint32_t b = guest_mem [ j ] ; \n g_assert_cmpint ( a , == , b ) ; \n } \n munmap ( guest_mem , memory . regions [ i ] . memory_size ) ; \n } \n g_assert_cmpint ( 1 , == , 1 ) ; \n g_mutex_unlock ( data_mutex ) ; \n }", "idx": 11975}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew ( QPCIBus * bus , int devfn , uint8_t offset , uint16_t value ) \n { \n outl ( 0xcf8 , ( 1 << 31 ) | ( devfn << 8 ) | offset ) ; \n outw ( 0xcfc , value ) ; \n }", "idx": 11980}
{"project": "qemu", "commit_id": "3daa41078aedf227ec98b0d1c9d56b77b6d20153", "target": 1, "func": "void scsi_req_cancel ( SCSIRequest * req ) \n { \n trace_scsi_req_cancel ( req -> dev -> id , req -> lun , req -> tag ) ; \n if ( ! req -> enqueued ) { \n return ; \n } \n scsi_req_ref ( req ) ; \n scsi_req_dequeue ( req ) ; \n req -> io_canceled = true ; \n if ( req -> aiocb ) { \n blk_aio_cancel ( req -> aiocb ) ; \n } else { \n scsi_req_cancel_complete ( req ) ; \n } \n }", "idx": 11988}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_exception_return ( DisasContext * s , TCGv_i32 pc ) \n { \n TCGv_i32 tmp ; \n store_reg ( s , 15 , pc ) ; \n tmp = load_cpu_field ( spsr ) ; \n gen_set_cpsr ( tmp , CPSR_ERET_MASK ) ; \n tcg_temp_free_i32 ( tmp ) ; \n s -> is_jmp = DISAS_UPDATE ; \n }", "idx": 11998}
{"project": "qemu", "commit_id": "8dfd5f96515ca20c4eb109cb0ee28e2bb32fc505", "target": 0, "func": "static void qio_channel_websock_write_close ( QIOChannelWebsock * ioc , \n uint16_t code , const char * reason ) \n { \n struct iovec iov ; \n buffer_reserve ( & ioc -> rawoutput , 2 + ( reason ? strlen ( reason ) : 0 ) ) ; \n * ( uint16_t * ) ( ioc -> rawoutput . buffer + ioc -> rawoutput . offset ) = \n cpu_to_be16 ( code ) ; \n ioc -> rawoutput . offset += 2 ; \n if ( reason ) { \n buffer_append ( & ioc -> rawoutput , reason , strlen ( reason ) ) ; \n } \n iov . iov_base = ioc -> rawoutput . buffer ; \n iov . iov_len = ioc -> rawoutput . offset ; \n qio_channel_websock_encode ( ioc , QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE , \n & iov , 1 , iov . iov_len ) ; \n buffer_reset ( & ioc -> rawoutput ) ; \n qio_channel_websock_write_wire ( ioc , NULL ) ; \n qio_channel_shutdown ( ioc -> master , QIO_CHANNEL_SHUTDOWN_BOTH , NULL ) ; \n }", "idx": 12023}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup ( AcpiFadtDescriptorRev1 * fadt , AcpiPmInfo * pm ) \n { \n fadt -> model = 1 ; \n fadt -> reserved1 = 0 ; \n fadt -> sci_int = cpu_to_le16 ( pm -> sci_int ) ; \n fadt -> smi_cmd = cpu_to_le32 ( ACPI_PORT_SMI_CMD ) ; \n fadt -> acpi_enable = pm -> acpi_enable_cmd ; \n fadt -> acpi_disable = pm -> acpi_disable_cmd ; \n fadt -> pm1a_evt_blk = cpu_to_le32 ( pm -> io_base ) ; \n fadt -> pm1a_cnt_blk = cpu_to_le32 ( pm -> io_base + 0x04 ) ; \n fadt -> pm_tmr_blk = cpu_to_le32 ( pm -> io_base + 0x08 ) ; \n fadt -> gpe0_blk = cpu_to_le32 ( pm -> gpe0_blk ) ; \n fadt -> pm1_evt_len = 4 ; \n fadt -> pm1_cnt_len = 2 ; \n fadt -> pm_tmr_len = 4 ; \n fadt -> gpe0_blk_len = pm -> gpe0_blk_len ; \n fadt -> plvl2_lat = cpu_to_le16 ( 0xfff ) ; \n fadt -> plvl3_lat = cpu_to_le16 ( 0xfff ) ; \n fadt -> flags = cpu_to_le32 ( ( 1 << ACPI_FADT_F_WBINVD ) | \n ( 1 << ACPI_FADT_F_PROC_C1 ) | \n ( 1 << ACPI_FADT_F_SLP_BUTTON ) | \n ( 1 << ACPI_FADT_F_RTC_S4 ) ) ; \n fadt -> flags |= cpu_to_le32 ( 1 << ACPI_FADT_F_USE_PLATFORM_CLOCK ) ; \n if ( max_cpus > 8 ) { \n fadt -> flags |= cpu_to_le32 ( 1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL ) ; \n } \n fadt -> century = RTC_CENTURY ; \n }", "idx": 12026}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_write ( ACPIREGS * ar , uint16_t val ) \n { \n ar -> pm1 . cnt . cnt = val & ~ ( ACPI_BITMASK_SLEEP_ENABLE ) ; \n if ( val & ACPI_BITMASK_SLEEP_ENABLE ) { \n uint16_t sus_typ = ( val >> 10 ) & 7 ; \n switch ( sus_typ ) { \n case 0 : \n qemu_system_shutdown_request ( ) ; \n break ; \n case 1 : \n ar -> pm1 . evt . sts |= \n ( ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS ) ; \n qemu_system_reset_request ( ) ; \n qemu_irq_raise ( ar -> pm1 . cnt . cmos_s3 ) ; \n default : \n break ; \n } \n } \n }", "idx": 12036}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer ( struct qemu_alarm_timer * t ) \n { \n struct qemu_alarm_win32 * data = t -> priv ; \n uint64_t nearest_delta_us ; \n if ( ! active_timers [ QEMU_TIMER_REALTIME ] && \n ! active_timers [ QEMU_TIMER_VIRTUAL ] ) \n return ; \n nearest_delta_us = qemu_next_deadline_dyntick ( ) ; \n nearest_delta_us /= 1000 ; \n timeKillEvent ( data -> timerId ) ; \n data -> timerId = timeSetEvent ( 1 , \n data -> period , \n host_alarm_handler , \n ( DWORD ) t , \n TIME_ONESHOT | TIME_PERIODIC ) ; \n if ( ! data -> timerId ) { \n fprintf ( stderr , \" \\n \" , \n GetLastError ( ) ) ; \n timeEndPeriod ( data -> period ) ; \n exit ( 1 ) ; \n } \n }", "idx": 12038}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qapi_dealloc_end_struct ( Visitor * v , Error * * errp ) \n { \n QapiDeallocVisitor * qov = to_qov ( v ) ; \n void * * obj = qapi_dealloc_pop ( qov ) ; \n if ( obj ) { \n g_free ( * obj ) ; \n } \n }", "idx": 12075}
{"project": "qemu", "commit_id": "6350b0904615cc0531cc3059ea34db5c009c88aa", "target": 1, "func": "static void set_int8 ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n DeviceState * dev = DEVICE ( obj ) ; \n Property * prop = opaque ; \n int8_t * ptr = qdev_get_prop_ptr ( dev , prop ) ; \n Error * local_err = NULL ; \n int64_t value ; \n if ( dev -> state != DEV_STATE_CREATED ) { \n error_set ( errp , QERR_PERMISSION_DENIED ) ; \n return ; \n } \n visit_type_int ( v , & value , name , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n if ( value > prop -> info -> min && value <= prop -> info -> max ) { \n * ptr = value ; \n } else { \n error_set ( errp , QERR_PROPERTY_VALUE_OUT_OF_RANGE , \n dev -> id ?  : \" \" , name , value , prop -> info -> min , \n prop -> info -> max ) ; \n } \n }", "idx": 12083}
{"project": "qemu", "commit_id": "d7cd369402191814a1bb339a730f3af411e9682f", "target": 1, "func": "static void enter_migration_coroutine ( void * opaque ) \n { \n Coroutine * co = opaque ; \n qemu_coroutine_enter ( co , NULL ) ; \n }", "idx": 12086}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "int qemu_paio_init ( struct qemu_paioinit * aioinit ) \n { \n int ret ; \n ret = pthread_attr_init ( & attr ) ; \n if ( ret ) die2 ( ret , \" \" ) ; \n ret = pthread_attr_setdetachstate ( & attr , PTHREAD_CREATE_DETACHED ) ; \n if ( ret ) die2 ( ret , \" \" ) ; \n TAILQ_INIT ( & request_list ) ; \n return 0 ; \n }", "idx": 12111}
{"project": "qemu", "commit_id": "2c80e42395bfe0bf291c082f9399431e1ff9d758", "target": 0, "func": "dprint ( int  level , const  char * fmt , ... ) \n { \n va_list args ; \n if ( level <= debug ) { \n va_start ( args , fmt ) ; \n vfprintf ( stderr , fmt , args ) ; \n va_end ( args ) ; \n } \n }", "idx": 12130}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug ( HotplugHandler * hotplug_dev , \n DeviceState * dev , Error * * errp ) \n { \n PCIDevice * pci_dev = PCI_DEVICE ( dev ) ; \n S390PCIBusDevice * pbdev ; \n S390pciState * s = S390_PCI_HOST_BRIDGE ( pci_device_root_bus ( pci_dev ) \n -> qbus . parent ) ; \n pbdev = & s -> pbdev [ PCI_SLOT ( pci_dev -> devfn ) ] ; \n pbdev -> fid = s390_pci_get_pfid ( pci_dev ) ; \n pbdev -> pdev = pci_dev ; \n pbdev -> configured = true ; \n pbdev -> fh = s390_pci_get_pfh ( pci_dev ) ; \n s390_pcihost_setup_msix ( pbdev ) ; \n if ( dev -> hotplugged ) { \n s390_pci_generate_plug_event ( HP_EVENT_RESERVED_TO_STANDBY , \n pbdev -> fh , pbdev -> fid ) ; \n s390_pci_generate_plug_event ( HP_EVENT_TO_CONFIGURED , \n pbdev -> fh , pbdev -> fid ) ; \n } \n }", "idx": 12133}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read ( void * opaque , hwaddr addr , \n unsigned size ) \n { \n PXA2xxState * s = ( PXA2xxState * ) opaque ; \n switch ( addr ) { \n case MDCNFG . . . SA1110 : \n if ( ( addr & 3 ) == 0 ) \n return s -> mm_regs [ addr >> 2 ] ; \n default : \n printf ( \" \" REG_FMT \" \\n \" , __FUNCTION__ , addr ) ; \n break ; \n } \n return 0 ; \n }", "idx": 12134}
{"project": "qemu", "commit_id": "c471ad0e9bd46ca5f5c9c796e727230e043a091d", "target": 0, "func": "static int vhost_verify_ring_mappings ( struct vhost_dev * dev , \n uint64_t start_addr , \n uint64_t size ) \n { \n int i , j ; \n int r = 0 ; \n const char * part_name [ ] = { \n \" \" , \n \" \" , \n \" \" \n } ; \n for ( i = 0 ; i < dev -> nvqs ; ++ i ) { \n struct vhost_virtqueue * vq = dev -> vqs + i ; \n j = 0 ; \n r = vhost_verify_ring_part_mapping ( vq -> desc , vq -> desc_phys , \n vq -> desc_size , start_addr , size ) ; \n if ( ! r ) { \n break ; \n } \n j ++ ; \n r = vhost_verify_ring_part_mapping ( vq -> avail , vq -> avail_phys , \n vq -> avail_size , start_addr , size ) ; \n if ( ! r ) { \n break ; \n } \n j ++ ; \n r = vhost_verify_ring_part_mapping ( vq -> used , vq -> used_phys , \n vq -> used_size , start_addr , size ) ; \n if ( ! r ) { \n break ; \n } \n } \n if ( r == - ENOMEM ) { \n error_report ( \" \" , part_name [ j ] , i ) ; \n } else if ( r == - EBUSY ) { \n error_report ( \" \" , part_name [ j ] , i ) ; \n } \n return r ; \n }", "idx": 12142}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "const char * object_get_typename ( Object * obj ) \n { \n return obj -> class -> type -> name ; \n }", "idx": 12182}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int ram_init1 ( SysBusDevice * dev ) \n { \n RamDevice * d = SUN4U_RAM ( dev ) ; \n memory_region_init_ram ( & d -> ram , OBJECT ( d ) , \" \" , d -> size , \n & error_abort ) ; \n vmstate_register_ram_global ( & d -> ram ) ; \n sysbus_init_mmio ( dev , & d -> ram ) ; \n return 0 ; \n }", "idx": 12200}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco ( const TestData * d ) \n { \n uint32_t val ; \n val = qpci_io_readw ( d -> dev , d -> tco_io_base + TCO1_CNT ) ; \n val |= TCO_TMR_HLT ; \n qpci_io_writew ( d -> dev , d -> tco_io_base + TCO1_CNT , val ) ; \n }", "idx": 12205}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be32 ( QEMUFile * f , unsigned int v ) \n { \n qemu_put_byte ( f , v >> 24 ) ; \n qemu_put_byte ( f , v >> 16 ) ; \n qemu_put_byte ( f , v >> 8 ) ; \n qemu_put_byte ( f , v ) ; \n }", "idx": 12215}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "bool bdrv_is_first_non_filter ( BlockDriverState * candidate ) \n { \n BlockDriverState * bs ; \n BdrvNextIterator * it = NULL ; \n while ( ( it = bdrv_next ( it , & bs ) ) != NULL ) { \n bool perm ; \n perm = bdrv_recurse_is_first_non_filter ( bs , candidate ) ; \n if ( perm ) { \n return true ; \n } \n } \n return false ; \n }", "idx": 12243}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "static int nbd_co_readv_1 ( NbdClientSession * client , int64_t sector_num , \n int nb_sectors , QEMUIOVector * qiov , \n int offset ) \n { \n struct nbd_request request ; \n struct nbd_reply reply ; \n ssize_t ret ; \n request . type = NBD_CMD_READ ; \n request . from = sector_num * 512 ; \n request . len = nb_sectors * 512 ; \n nbd_coroutine_start ( client , & request ) ; \n ret = nbd_co_send_request ( client , & request , NULL , 0 ) ; \n if ( ret < 0 ) { \n reply . error = - ret ; \n } else { \n nbd_co_receive_reply ( client , & request , & reply , qiov , offset ) ; \n } \n nbd_coroutine_end ( client , & request ) ; \n return - reply . error ; \n }", "idx": 12257}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void find_best_solid_area ( VncState * vs , int x , int y , int w , int h , \n uint32_t color , int * w_ptr , int * h_ptr ) \n { \n int dx , dy , dw , dh ; \n int w_prev ; \n int w_best = 0 , h_best = 0 ; \n w_prev = w ; \n for ( dy = y ; dy < y + h ; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE ) { \n dh = MIN ( VNC_TIGHT_MAX_SPLIT_TILE_SIZE , y + h - dy ) ; \n dw = MIN ( VNC_TIGHT_MAX_SPLIT_TILE_SIZE , w_prev ) ; \n if ( ! check_solid_tile ( vs , x , dy , dw , dh , & color , true ) ) { \n break ; \n } \n for ( dx = x + dw ; dx < x + w_prev ; ) { \n dw = MIN ( VNC_TIGHT_MAX_SPLIT_TILE_SIZE , x + w_prev - dx ) ; \n if ( ! check_solid_tile ( vs , dx , dy , dw , dh , & color , true ) ) { \n break ; \n } \n dx += dw ; \n } \n w_prev = dx - x ; \n if ( w_prev * ( dy + dh - y ) > w_best * h_best ) { \n w_best = w_prev ; \n h_best = dy + dh - y ; \n } \n } \n * w_ptr = w_best ; \n * h_ptr = h_best ; \n }", "idx": 12307}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock * qemu_get_ram_block ( ram_addr_t addr ) \n { \n RAMBlock * block ; \n block = ram_list . mru_block ; \n if ( block && addr - block -> offset < block -> max_length ) { \n goto found ; \n } \n QTAILQ_FOREACH ( block , & ram_list . blocks , next )  { \n if ( addr - block -> offset < block -> max_length ) { \n goto found ; \n } \n } \n fprintf ( stderr , \" \" PRIx64 \" \\n \" , ( uint64_t ) addr ) ; \n abort ( ) ; \n found : \n ram_list . mru_block = block ; \n return block ; \n }", "idx": 12314}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usbnet_can_receive ( VLANClientState * nc ) \n { \n USBNetState * s = DO_UPCAST ( NICState , nc , nc ) -> opaque ; \n if ( s -> rndis && ! s -> rndis_state == RNDIS_DATA_INITIALIZED ) \n return 1 ; \n return ! s -> in_len ; \n }", "idx": 12320}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void AUD_vlog ( const char * cap , const char * fmt , va_list ap ) \n { \n if ( conf . log_to_monitor ) { \n if ( cap ) { \n monitor_printf ( default_mon , \" \" , cap ) ; \n } \n monitor_vprintf ( default_mon , fmt , ap ) ; \n } \n else { \n if ( cap ) { \n fprintf ( stderr , \" \" , cap ) ; \n } \n vfprintf ( stderr , fmt , ap ) ; \n } \n }", "idx": 12347}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int start_auth_vencrypt_subauth ( VncState * vs ) \n { \n switch ( vs -> vd -> subauth ) { \n case VNC_AUTH_VENCRYPT_TLSNONE : \n case VNC_AUTH_VENCRYPT_X509NONE : \n VNC_DEBUG ( \" \\n \" ) ; \n vnc_write_u32 ( vs , 0 ) ; \n vnc_read_when ( vs , protocol_client_init , 1 ) ; \n break ; \n case VNC_AUTH_VENCRYPT_TLSVNC : \n case VNC_AUTH_VENCRYPT_X509VNC : \n VNC_DEBUG ( \" \\n \" ) ; \n return start_auth_vnc ( vs ) ; \n default : \n VNC_DEBUG ( \" \\n \" , vs -> vd -> auth ) ; \n vnc_write_u8 ( vs , 1 ) ; \n if ( vs -> minor >= 8 ) { \n static const char err [ ] = \" \" ; \n vnc_write_u32 ( vs , sizeof ( err ) ) ; \n vnc_write ( vs , err , sizeof ( err ) ) ; \n } \n vnc_client_error ( vs ) ; \n } \n return 0 ; \n }", "idx": 12365}
{"project": "qemu", "commit_id": "1dde716ed6719c341c1bfa427781f0715af90cbc", "target": 0, "func": "iscsi_unmap_cb ( struct iscsi_context *  iscsi , int  status , \n void * command_data , void * opaque ) \n { \n IscsiAIOCB * acb = opaque ; \n if ( acb -> canceled != 0 ) { \n return ; \n } \n acb -> status = 0 ; \n if ( status < 0 ) { \n error_report ( \" \" , \n iscsi_get_error ( iscsi ) ) ; \n acb -> status = - EIO ; \n } \n iscsi_schedule_bh ( acb ) ; \n }", "idx": 12367}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify ( struct subchannel_id schid ) \n { \n kvm_hypercall ( KVM_S390_VIRTIO_CCW_NOTIFY , * ( u32 * ) & schid , 0 ) ; \n }", "idx": 12376}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub2 ( CPUState * env , target_phys_addr_t paddr ) \n { \n struct kvm_x86_mce mce = { \n . bank = 9 , \n . status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN \n | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S \n | 0xc0 , \n . mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV , \n . addr = paddr , \n . misc = ( MCM_ADDR_PHYS << 6 ) | 0xc , \n } ; \n kvm_inject_x86_mce_on ( env , & mce , ABORT_ON_ERROR ) ; \n kvm_mce_broadcast_rest ( env ) ; \n }", "idx": 12377}
{"project": "qemu", "commit_id": "075a1fe788d36b271ec25507466c30b9a90b5d54", "target": 0, "func": "static void gen_msa_branch ( CPUMIPSState * env , DisasContext * ctx , uint32_t op1 ) \n { \n uint8_t df = ( ctx -> opcode >> 21 ) & 0x3 ; \n uint8_t wt = ( ctx -> opcode >> 16 ) & 0x1f ; \n int64_t s16 = ( int16_t ) ctx -> opcode ; \n check_msa_access ( ctx ) ; \n if ( ctx -> insn_flags & ISA_MIPS32R6 && ctx -> hflags & MIPS_HFLAG_BMASK ) { \n generate_exception_end ( ctx , EXCP_RI ) ; \n return ; \n } \n switch ( op1 ) { \n case OPC_BZ_V : \n case OPC_BNZ_V : \n { \n TCGv_i64 t0 = tcg_temp_new_i64 ( ) ; \n tcg_gen_or_i64 ( t0 , msa_wr_d [ wt << 1 ] , msa_wr_d [ ( wt << 1 ) + 1 ] ) ; \n tcg_gen_setcondi_i64 ( ( op1 == OPC_BZ_V ) ? \n TCG_COND_EQ : TCG_COND_NE , t0 , t0 , 0 ) ; \n tcg_gen_trunc_i64_tl ( bcond , t0 ) ; \n tcg_temp_free_i64 ( t0 ) ; \n } \n break ; \n case OPC_BZ_B : \n case OPC_BZ_H : \n case OPC_BZ_W : \n case OPC_BZ_D : \n gen_check_zero_element ( bcond , df , wt ) ; \n break ; \n case OPC_BNZ_B : \n case OPC_BNZ_H : \n case OPC_BNZ_W : \n case OPC_BNZ_D : \n gen_check_zero_element ( bcond , df , wt ) ; \n tcg_gen_setcondi_tl ( TCG_COND_EQ , bcond , bcond , 0 ) ; \n break ; \n } \n ctx -> btarget = ctx -> pc + ( s16 << 2 ) + 4 ; \n ctx -> hflags |= MIPS_HFLAG_BC ; \n ctx -> hflags |= MIPS_HFLAG_BDS32 ; \n }", "idx": 12383}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject * parse_keyword ( JSONParserContext * ctxt , QList * * tokens ) \n { \n QObject * token , * ret ; \n QList * working = qlist_copy ( * tokens ) ; \n token = qlist_pop ( working ) ; \n if ( token == NULL ) { \n goto out ; \n } \n if ( token_get_type ( token ) != JSON_KEYWORD ) { \n goto out ; \n } \n if ( token_is_keyword ( token , \" \" ) ) { \n ret = QOBJECT ( qbool_from_int ( true ) ) ; \n } else if ( token_is_keyword ( token , \" \" ) ) { \n ret = QOBJECT ( qbool_from_int ( false ) ) ; \n } else { \n parse_error ( ctxt , token , \" \" , token_get_value ( token ) ) ; \n goto out ; \n } \n qobject_decref ( token ) ; \n QDECREF ( * tokens ) ; \n * tokens = working ; \n return ret ; \n out : \n qobject_decref ( token ) ; \n QDECREF ( working ) ; \n return NULL ; \n }", "idx": 12384}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check ( bool * cap_list , \n MigrationCapabilityStatusList * params , \n Error * * errp ) \n { \n MigrationCapabilityStatusList * cap ; \n bool old_postcopy_cap ; \n old_postcopy_cap = cap_list [ MIGRATION_CAPABILITY_POSTCOPY_RAM ] ; \n for ( cap = params ; cap ; cap = cap -> next ) { \n cap_list [ cap -> value -> capability ] = cap -> value -> state ; \n } \n #ifndef CONFIG_LIVE_BLOCK_MIGRATION \n if ( cap_list [ MIGRATION_CAPABILITY_BLOCK ] ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n error_append_hint ( errp , \" \\n \" ) ; \n return false ; \n } \n #endif \n if ( cap_list [ MIGRATION_CAPABILITY_POSTCOPY_RAM ] ) { \n if ( cap_list [ MIGRATION_CAPABILITY_COMPRESS ] ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n return false ; \n } \n if ( ! old_postcopy_cap && runstate_check ( RUN_STATE_INMIGRATE ) && \n ! postcopy_ram_supported_by_host ( ) ) { \n error_setg ( errp , \" \" ) ; \n return false ; \n } \n } \n return true ; \n }", "idx": 12470}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int virtio_blk_handle_rw_error ( VirtIOBlockReq * req , int error , \n bool is_read ) \n { \n BlockErrorAction action = bdrv_get_error_action ( req -> dev -> bs , is_read , error ) ; \n VirtIOBlock * s = req -> dev ; \n if ( action == BLOCK_ERROR_ACTION_STOP ) { \n req -> next = s -> rq ; \n s -> rq = req ; \n } else if ( action == BLOCK_ERROR_ACTION_REPORT ) { \n virtio_blk_req_complete ( req , VIRTIO_BLK_S_IOERR ) ; \n block_acct_done ( bdrv_get_stats ( s -> bs ) , & req -> acct ) ; \n virtio_blk_free_request ( req ) ; \n } \n bdrv_error_action ( s -> bs , action , is_read , error ) ; \n return action != BLOCK_ERROR_ACTION_IGNORE ; \n }", "idx": 12477}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "struct omap_mmc_s * omap2_mmc_init ( struct omap_target_agent_s * ta , \n BlockDriverState * bd , qemu_irq irq , qemu_irq dma [ ] , \n omap_clk fclk , omap_clk iclk ) \n { \n struct omap_mmc_s * s = ( struct omap_mmc_s * ) \n g_malloc0 ( sizeof ( struct omap_mmc_s ) ) ; \n s -> irq = irq ; \n s -> dma = dma ; \n s -> clk = fclk ; \n s -> lines = 4 ; \n s -> rev = 2 ; \n omap_mmc_reset ( s ) ; \n memory_region_init_io ( & s -> iomem , NULL , & omap_mmc_ops , s , \" \" , \n omap_l4_region_size ( ta , 0 ) ) ; \n omap_l4_attach ( ta , 0 , & s -> iomem ) ; \n s -> card = sd_init ( bd , false ) ; \n if ( s -> card == NULL ) { \n exit ( 1 ) ; \n } \n s -> cdet = qemu_allocate_irqs ( omap_mmc_cover_cb , s , 1 ) [ 0 ] ; \n sd_set_cb ( s -> card , NULL , s -> cdet ) ; \n return s ; \n }", "idx": 12499}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_mcast_filters ( VMXNET3State * s ) \n { \n uint16_t list_bytes = \n VMXNET3_READ_DRV_SHARED16 ( s -> drv_shmem , \n devRead . rxFilterConf . mfTableLen ) ; \n s -> mcast_list_len = list_bytes / sizeof ( s -> mcast_list [ 0 ] ) ; \n s -> mcast_list = g_realloc ( s -> mcast_list , list_bytes ) ; \n if ( ! s -> mcast_list ) { \n if ( s -> mcast_list_len == 0 ) { \n VMW_CFPRN ( \" \" ) ; \n } else { \n VMW_ERPRN ( \" \" , \n s -> mcast_list_len ) ; \n } \n s -> mcast_list_len = 0 ; \n } else { \n int i ; \n hwaddr mcast_list_pa = \n VMXNET3_READ_DRV_SHARED64 ( s -> drv_shmem , \n devRead . rxFilterConf . mfTablePA ) ; \n pci_dma_read ( PCI_DEVICE ( s ) , mcast_list_pa , s -> mcast_list , list_bytes ) ; \n VMW_CFPRN ( \" \" , s -> mcast_list_len ) ; \n for ( i = 0 ; i < s -> mcast_list_len ; i ++ ) { \n VMW_CFPRN ( \" \\t \" MAC_FMT , MAC_ARG ( s -> mcast_list [ i ] . a ) ) ; \n } \n } \n }", "idx": 12548}
{"project": "qemu", "commit_id": "913a87885f589d263e682c2eb6637c6e14538061", "target": 1, "func": "static int cirrus_bitblt_solidfill ( CirrusVGAState * s , int blt_rop ) \n { \n cirrus_fill_t rop_func ; \n if ( blit_is_unsafe ( s ) ) { \n return 0 ; \n } \n rop_func = cirrus_fill [ rop_to_index [ blt_rop ] ] [ s -> cirrus_blt_pixelwidth - 1 ] ; \n rop_func ( s , s -> vga . vram_ptr + ( s -> cirrus_blt_dstaddr & s -> cirrus_addr_mask ) , \n s -> cirrus_blt_dstpitch , \n s -> cirrus_blt_width , s -> cirrus_blt_height ) ; \n cirrus_invalidate_region ( s , s -> cirrus_blt_dstaddr , \n s -> cirrus_blt_dstpitch , s -> cirrus_blt_width , \n s -> cirrus_blt_height ) ; \n cirrus_bitblt_reset ( s ) ; \n return 1 ; \n }", "idx": 12596}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands ( Monitor * mon , QObject * * ret_data ) \n { \n QList * cmd_list ; \n const mon_cmd_t * cmd ; \n cmd_list = qlist_new ( ) ; \n for ( cmd = qmp_cmds ; cmd -> name != NULL ; cmd ++ ) { \n if ( monitor_handler_ported ( cmd ) && ! monitor_cmd_user_only ( cmd ) && \n ! compare_cmd ( cmd -> name , \" \" ) ) { \n qlist_append_obj ( cmd_list , get_cmd_dict ( cmd -> name ) ) ; \n } \n } \n for ( cmd = qmp_query_cmds ; cmd -> name != NULL ; cmd ++ ) { \n if ( monitor_handler_ported ( cmd ) && ! monitor_cmd_user_only ( cmd ) ) { \n char buf [ 128 ] ; \n snprintf ( buf , sizeof ( buf ) , \" \" , cmd -> name ) ; \n qlist_append_obj ( cmd_list , get_cmd_dict ( buf ) ) ; \n } \n } \n * ret_data = QOBJECT ( cmd_list ) ; \n }", "idx": 12624}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "func": "static void spapr_msi_write ( void * opaque , hwaddr addr , \n uint64_t data , unsigned size ) \n { \n sPAPRPHBState * phb = opaque ; \n int ndev = addr >> 16 ; \n int vec = ( ( addr & 0xFFFF ) >> 2 ) | data ; \n uint32_t irq = phb -> msi_table [ ndev ] . irq + vec ; \n trace_spapr_pci_msi_write ( addr , data , irq ) ; \n qemu_irq_pulse ( xics_get_qirq ( spapr -> icp , irq ) ) ; \n }", "idx": 12635}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static void pxa2xx_pm_write ( void * opaque , target_phys_addr_t addr , \n uint32_t value ) \n { \n struct pxa2xx_state_s * s = ( struct pxa2xx_state_s * ) opaque ; \n if ( addr > s -> pm_base + PCMD31 ) { \n pxa2xx_i2c_write ( s -> i2c [ 1 ] , addr , value ) ; \n return ; \n } \n addr -= s -> pm_base ; \n switch ( addr ) { \n case PMCR : \n s -> pm_regs [ addr >> 2 ] &= 0x15 & ~ ( value & 0x2a ) ; \n s -> pm_regs [ addr >> 2 ] |= value & 0x15 ; \n break ; \n case PSSR : \n case RCSR : \n case PKSR : \n s -> pm_regs [ addr >> 2 ] &= ~ value ; \n break ; \n default : \n if ( addr >= PMCR && addr <= PCMD31 && ! ( addr & 3 ) ) { \n s -> pm_regs [ addr >> 2 ] = value ; \n break ; \n } \n printf ( \" \" REG_FMT \" \\n \" , __FUNCTION__ , addr ) ; \n break ; \n } \n }", "idx": 12642}
{"project": "qemu", "commit_id": "9c605cb13547a5faa5cb1092e3e44ac8b0d0b841", "target": 0, "func": "CPUX86State * cpu_x86_init ( void ) \n { \n CPUX86State * env ; \n int i ; \n static int inited ; \n cpu_x86_tblocks_init ( ) ; \n env = malloc ( sizeof ( CPUX86State ) ) ; \n if ( ! env ) \n return NULL ; \n memset ( env , 0 , sizeof ( CPUX86State ) ) ; \n for ( i = 0 ; i < 8 ; i ++ ) \n env -> fptags [ i ] = 1 ; \n env -> fpuc = 0x37f ; \n env -> eflags = 0 ; \n if ( ! inited ) { \n inited = 1 ; \n optimize_flags_init ( ) ; \n } \n return env ; \n }", "idx": 12645}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt ( ReadLineState * rs ) \n { \n monitor_printf ( rs -> mon , \" \" , rs -> prompt ) ; \n monitor_flush ( rs -> mon ) ; \n rs -> last_cmd_buf_index = 0 ; \n rs -> last_cmd_buf_size = 0 ; \n rs -> esc_state = IS_NORM ; \n }", "idx": 12663}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int parallel_parse ( const char * devname ) \n { \n static int index = 0 ; \n char label [ 32 ] ; \n if ( strcmp ( devname , \" \" ) == 0 ) \n return 0 ; \n if ( index == MAX_PARALLEL_PORTS ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n snprintf ( label , sizeof ( label ) , \" \" , index ) ; \n parallel_hds [ index ] = qemu_chr_new ( label , devname , NULL ) ; \n if ( ! parallel_hds [ index ] ) { \n fprintf ( stderr , \" \" \n \" \\n \" , devname ) ; \n return -1 ; \n } \n index ++ ; \n return 0 ; \n }", "idx": 12667}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "START_TEST ( qfloat_destroy_test ) \n { \n QFloat * qf = qfloat_from_double ( 0.0 ) ; \n QDECREF ( qf ) ; \n }", "idx": 12668}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat ( FsContext * fs_ctx , V9fsPath * fs_path , struct stat * stbuf ) \n { \n int err ; \n char buffer [ PATH_MAX ] ; \n char * path = fs_path -> data ; \n err = lstat ( rpath ( fs_ctx , path , buffer ) , stbuf ) ; \n if ( err ) { \n return err ; \n } \n if ( fs_ctx -> fs_sm == SM_MAPPED ) { \n uid_t tmp_uid ; \n gid_t tmp_gid ; \n mode_t tmp_mode ; \n dev_t tmp_dev ; \n if ( getxattr ( rpath ( fs_ctx , path , buffer ) , \" \" , & tmp_uid , \n sizeof ( uid_t ) ) > 0 ) { \n stbuf -> st_uid = tmp_uid ; \n } \n if ( getxattr ( rpath ( fs_ctx , path , buffer ) , \" \" , & tmp_gid , \n sizeof ( gid_t ) ) > 0 ) { \n stbuf -> st_gid = tmp_gid ; \n } \n if ( getxattr ( rpath ( fs_ctx , path , buffer ) , \" \" , \n & tmp_mode , sizeof ( mode_t ) ) > 0 ) { \n stbuf -> st_mode = tmp_mode ; \n } \n if ( getxattr ( rpath ( fs_ctx , path , buffer ) , \" \" , & tmp_dev , \n sizeof ( dev_t ) ) > 0 ) { \n stbuf -> st_rdev = tmp_dev ; \n } \n } \n return err ; \n }", "idx": 12672}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception ( CPUS390XState * env , int excp , \n uintptr_t retaddr ) \n { \n CPUState * cs = CPU ( s390_env_get_cpu ( env ) ) ; \n int t ; \n cs -> exception_index = EXCP_PGM ; \n env -> int_pgm_code = excp ; \n cpu_restore_state ( cs , retaddr ) ; \n t = cpu_ldub_code ( env , env -> psw . addr ) ; \n env -> int_pgm_ilen = t = get_ilen ( t ) ; \n env -> psw . addr += t ; \n cpu_loop_exit ( cs ) ; \n }", "idx": 12686}
{"project": "qemu", "commit_id": "a277c3e094d5e9f653ccc861f59e07c94c7fe6c7", "target": 0, "func": "static int usb_host_init ( void ) \n { \n const struct libusb_pollfd * * poll ; \n int i , rc ; \n if ( ctx ) { \n return 0 ; \n } \n rc = libusb_init ( & ctx ) ; \n if ( rc != 0 ) { \n return -1 ; \n } \n libusb_set_debug ( ctx , loglevel ) ; \n libusb_set_pollfd_notifiers ( ctx , usb_host_add_fd , \n usb_host_del_fd , \n ctx ) ; \n poll = libusb_get_pollfds ( ctx ) ; \n if ( poll ) { \n for ( i = 0 ; poll [ i ] != NULL ; i ++ ) { \n usb_host_add_fd ( poll [ i ] -> fd , poll [ i ] -> events , ctx ) ; \n } \n } \n free ( poll ) ; \n return 0 ; \n }", "idx": 12701}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req ( VirtIOSCSIReq * req ) \n { \n VirtIOSCSI * s = req -> dev ; \n VirtQueue * vq = req -> vq ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( s ) ; \n virtqueue_push ( vq , & req -> elem , req -> qsgl . size + req -> elem . in_sg [ 0 ] . iov_len ) ; \n if ( req -> sreq ) { \n req -> sreq -> hba_private = NULL ; \n scsi_req_unref ( req -> sreq ) ; \n } \n virtio_scsi_free_req ( req ) ; \n virtio_notify ( vdev , vq ) ; \n }", "idx": 12710}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "bool timer_pending ( QEMUTimer * ts ) \n { \n QEMUTimer * t ; \n for ( t = ts -> timer_list -> active_timers ; t != NULL ; t = t -> next ) { \n if ( t == ts ) { \n return true ; \n } \n } \n return false ; \n }", "idx": 12724}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static void tcp_chr_telnet_init ( QIOChannel * ioc ) \n { \n char buf [ 3 ] ; \n IACSET ( buf , 0xff , 0xfb , 0x01 ) ; \n qio_channel_write ( ioc , buf , 3 , NULL ) ; \n IACSET ( buf , 0xff , 0xfb , 0x03 ) ; \n qio_channel_write ( ioc , buf , 3 , NULL ) ; \n IACSET ( buf , 0xff , 0xfb , 0x00 ) ; \n qio_channel_write ( ioc , buf , 3 , NULL ) ; \n IACSET ( buf , 0xff , 0xfd , 0x00 ) ; \n qio_channel_write ( ioc , buf , 3 , NULL ) ; \n }", "idx": 12777}
{"project": "qemu", "commit_id": "1606e4cf8a976513ecac70ad6642a7ec45744cf5", "target": 1, "func": "static void blk_delete ( BlockBackend * blk ) \n { \n assert ( ! blk -> refcnt ) ; \n assert ( ! blk -> name ) ; \n assert ( ! blk -> dev ) ; \n if ( blk -> root ) { \n blk_remove_bs ( blk ) ; \n assert ( QLIST_EMPTY ( & blk -> remove_bs_notifiers . notifiers ) ) ; \n assert ( QLIST_EMPTY ( & blk -> insert_bs_notifiers . notifiers ) ) ; \n QTAILQ_REMOVE ( & block_backends , blk , link ) ; \n drive_info_del ( blk -> legacy_dinfo ) ; \n block_acct_cleanup ( & blk -> stats ) ; \n g_free ( blk ) ;", "idx": 12780}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open ( int port ) \n { \n struct sockaddr_in sockaddr ; \n int fd , val , ret ; \n fd = socket ( PF_INET , SOCK_STREAM , 0 ) ; \n if ( fd < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n #ifndef _WIN32 \n fcntl ( fd , F_SETFD , FD_CLOEXEC ) ; \n #endif \n val = 1 ; \n setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , ( char * ) & val , sizeof ( val ) ) ; \n sockaddr . sin_family = AF_INET ; \n sockaddr . sin_port = htons ( port ) ; \n sockaddr . sin_addr . s_addr = 0 ; \n ret = bind ( fd , ( struct sockaddr * ) & sockaddr , sizeof ( sockaddr ) ) ; \n if ( ret < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n ret = listen ( fd , 0 ) ; \n if ( ret < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n return fd ; \n }", "idx": 12785}
{"project": "qemu", "commit_id": "280503ee9d7833a793770d732dda5358659825e9", "target": 1, "func": "static void spapr_nvram_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n VIOsPAPRDeviceClass * k = VIO_SPAPR_DEVICE_CLASS ( klass ) ; \n k -> realize = spapr_nvram_realize ; \n k -> devnode = spapr_nvram_devnode ; \n k -> dt_name = \" \" ; \n k -> dt_type = \" \" ; \n k -> dt_compatible = \" \" ; \n set_bit ( DEVICE_CATEGORY_MISC , dc -> categories ) ; \n dc -> props = spapr_nvram_properties ; \n dc -> vmsd = & vmstate_spapr_nvram ; \n }", "idx": 12786}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static void cpu_handle_ioreq ( void * opaque ) \n { \n XenIOState * state = opaque ; \n ioreq_t * req = cpu_get_ioreq ( state ) ; \n handle_buffered_iopage ( state ) ; \n if ( req ) { \n ioreq_t copy = * req ; \n xen_rmb ( ) ; \n handle_ioreq ( state , & copy ) ; \n req -> data = copy . data ; \n if ( req -> state != STATE_IOREQ_INPROCESS ) { \n fprintf ( stderr , \" \" \n \" \" PRIx64 \" \" \n \" \" PRIx64 \" \\n \" , \n req -> state , req -> data_is_ptr , req -> addr , \n req -> data , req -> count , req -> size , req -> type ) ; \n destroy_hvm_domain ( false ) ; \n return ; \n } \n xen_wmb ( ) ; \n if ( runstate_is_running ( ) ) { \n if ( qemu_shutdown_requested_get ( ) ) { \n destroy_hvm_domain ( false ) ; \n } \n if ( qemu_reset_requested_get ( ) ) { \n qemu_system_reset ( VMRESET_REPORT ) ; \n destroy_hvm_domain ( true ) ; \n } \n } \n req -> state = STATE_IORESP_READY ; \n xenevtchn_notify ( state -> xce_handle , \n state -> ioreq_local_port [ state -> send_vcpu ] ) ; \n } \n }", "idx": 12787}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry ( SCSITargetReq * r ) \n { \n assert ( r -> req . dev -> lun != r -> req . lun ) ; \n if ( r -> req . cmd . buf [ 1 ] & 0x2 ) { \n return false ; \n } \n if ( r -> req . cmd . buf [ 1 ] & 0x1 ) { \n uint8_t page_code = r -> req . cmd . buf [ 2 ] ; \n r -> buf [ r -> len ++ ] = page_code ; \n r -> buf [ r -> len ++ ] = 0x00 ; \n switch ( page_code ) { \n case 0x00 : \n { \n int pages ; \n pages = r -> len ++ ; \n r -> buf [ r -> len ++ ] = 0x00 ; \n r -> buf [ pages ] = r -> len - pages - 1 ; \n break ; \n } \n default : \n return false ; \n } \n assert ( r -> len < sizeof ( r -> buf ) ) ; \n r -> len = MIN ( r -> req . cmd . xfer , r -> len ) ; \n return true ; \n } \n if ( r -> req . cmd . buf [ 2 ] != 0 ) { \n return false ; \n } \n r -> len = MIN ( r -> req . cmd . xfer , 36 ) ; \n memset ( r -> buf , 0 , r -> len ) ; \n if ( r -> req . lun != 0 ) { \n r -> buf [ 0 ] = TYPE_NO_LUN ; \n } else { \n r -> buf [ 0 ] = TYPE_NOT_PRESENT | TYPE_INACTIVE ; \n r -> buf [ 2 ] = 5 ; \n r -> buf [ 3 ] = 2 | 0x10 ; \n r -> buf [ 4 ] = r -> len - 5 ; \n r -> buf [ 7 ] = 0x10 | ( r -> req . bus -> info -> tcq ? 0x02 : 0 ) ; \n memcpy ( & r -> buf [ 8 ] , \" \" , 8 ) ; \n memcpy ( & r -> buf [ 16 ] , \" \" , 16 ) ; \n pstrcpy ( ( char * ) & r -> buf [ 32 ] , 4 , qemu_get_version ( ) ) ; \n } \n return true ; \n }", "idx": 12789}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2 ( FsContext * fs_ctx , const char * path , int flags , \n FsCred * credp ) \n { \n int fd = -1 ; \n int err = -1 ; \n int serrno = 0 ; \n if ( fs_ctx -> fs_sm == SM_MAPPED ) { \n fd = open ( rpath ( fs_ctx , path ) , flags , SM_LOCAL_MODE_BITS ) ; \n if ( fd == -1 ) { \n return fd ; \n } \n credp -> fc_mode = credp -> fc_mode | S_IFREG ; \n err = local_set_xattr ( rpath ( fs_ctx , path ) , credp ) ; \n if ( err == -1 ) { \n serrno = errno ; \n goto err_end ; \n } \n } else if ( fs_ctx -> fs_sm == SM_PASSTHROUGH ) { \n fd = open ( rpath ( fs_ctx , path ) , flags , credp -> fc_mode ) ; \n if ( fd == -1 ) { \n return fd ; \n } \n err = local_post_create_passthrough ( fs_ctx , path , credp ) ; \n if ( err == -1 ) { \n serrno = errno ; \n goto err_end ; \n } \n } \n return fd ; \n err_end : \n close ( fd ) ; \n remove ( rpath ( fs_ctx , path ) ) ; \n errno = serrno ; \n return err ; \n }", "idx": 12805}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_broadcast_packet ( USBHubState * s , USBPacket * p ) \n { \n USBHubPort * port ; \n USBDevice * dev ; \n int i , ret ; \n for ( i = 0 ; i < NUM_PORTS ; i ++ ) { \n port = & s -> ports [ i ] ; \n dev = port -> port . dev ; \n if ( dev && ( port -> wPortStatus & PORT_STAT_ENABLE ) ) { \n ret = usb_handle_packet ( dev , p ) ; \n if ( ret != USB_RET_NODEV ) { \n return ret ; \n } \n } \n } \n return USB_RET_NODEV ; \n }", "idx": 12894}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "BlockDriverAIOCB * bdrv_aio_writev ( BlockDriverState * bs , int64_t sector_num , \n QEMUIOVector * qiov , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n BlockDriver * drv = bs -> drv ; \n BlockDriverAIOCB * ret ; \n if ( ! drv ) \n return NULL ; \n if ( bs -> read_only ) \n return NULL ; \n if ( bdrv_check_request ( bs , sector_num , nb_sectors ) ) \n return NULL ; \n if ( bs -> dirty_tracking ) { \n set_dirty_bitmap ( bs , sector_num , nb_sectors , 1 ) ; \n } \n ret = drv -> bdrv_aio_writev ( bs , sector_num , qiov , nb_sectors , \n cb , opaque ) ; \n if ( ret ) { \n bs -> wr_bytes += ( unsigned ) nb_sectors * BDRV_SECTOR_SIZE ; \n bs -> wr_ops ++ ; \n } \n return ret ; \n }", "idx": 12916}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER ( mvc ) ( CPUS390XState * env , uint32_t l , uint64_t dest , uint64_t src ) \n { \n int i = 0 ; \n int x = 0 ; \n uint32_t l_64 = ( l + 1 ) / 8 ; \n HELPER_LOG ( \" \" PRIx64 \" \" PRIx64 \" \\n \" , \n __func__ , l , dest , src ) ; \n #ifndef CONFIG_USER_ONLY \n if ( ( l > 32 ) && \n ( src & TARGET_PAGE_MASK ) == ( ( src + l ) & TARGET_PAGE_MASK ) && \n ( dest & TARGET_PAGE_MASK ) == ( ( dest + l ) & TARGET_PAGE_MASK ) ) { \n if ( dest == ( src + 1 ) ) { \n mvc_fast_memset ( env , l + 1 , dest , cpu_ldub_data ( env , src ) ) ; \n return ; \n } else if ( ( src & TARGET_PAGE_MASK ) != ( dest & TARGET_PAGE_MASK ) ) { \n mvc_fast_memmove ( env , l + 1 , dest , src ) ; \n return ; \n } \n } \n #else \n if ( dest == ( src + 1 ) ) { \n memset ( g2h ( dest ) , cpu_ldub_data ( env , src ) , l + 1 ) ; \n return ; \n } else { \n memmove ( g2h ( dest ) , g2h ( src ) , l + 1 ) ; \n return ; \n } \n #endif \n if ( dest != ( src + 1 ) ) { \n for ( i = 0 ; i < l_64 ; i ++ ) { \n cpu_stq_data ( env , dest + x , cpu_ldq_data ( env , src + x ) ) ; \n x += 8 ; \n } \n } \n for ( i = x ; i <= l ; i ++ ) { \n cpu_stb_data ( env , dest + i , cpu_ldub_data ( env , src + i ) ) ; \n } \n }", "idx": 12946}
{"project": "qemu", "commit_id": "0d2cd785ef1282b14687f9f7f4b63ae4a2430be3", "target": 1, "func": "static void test_properties ( const char * path , bool recurse ) \n { \n char * child_path ; \n QDict * response , * tuple ; \n QList * list ; \n QListEntry * entry ; \n g_test_message ( \" \" , path ) ; \n response = qmp ( \" \" \n \" \" , path ) ; \n g_assert ( response ) ; \n if ( ! recurse ) { \n return ; \n } \n g_assert ( qdict_haskey ( response , \" \" ) ) ; \n list = qobject_to_qlist ( qdict_get ( response , \" \" ) ) ; \n QLIST_FOREACH_ENTRY ( list , entry )  { \n tuple = qobject_to_qdict ( qlist_entry_obj ( entry ) ) ; \n bool is_child = strstart ( qdict_get_str ( tuple , \" \" ) , \" \" , NULL ) ; \n bool is_link = strstart ( qdict_get_str ( tuple , \" \" ) , \" \" , NULL ) ; \n if ( is_child || is_link ) { \n child_path = g_strdup_printf ( \" \" , \n path , qdict_get_str ( tuple , \" \" ) ) ; \n test_properties ( child_path , is_child ) ; \n g_free ( child_path ) ; \n } else { \n const char * prop = qdict_get_str ( tuple , \" \" ) ; \n g_test_message ( \" \" , path , prop ) ; \n response = qmp ( \" \" \n \" \" \n \" \" , \n path , prop ) ; \n g_assert ( response ) ; \n } \n } \n }", "idx": 12949}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_input_pci_realize ( VirtIOPCIProxy * vpci_dev , Error * * errp ) \n { \n VirtIOInputPCI * vinput = VIRTIO_INPUT_PCI ( vpci_dev ) ; \n DeviceState * vdev = DEVICE ( & vinput -> vdev ) ; \n qdev_set_parent_bus ( vdev , BUS ( & vpci_dev -> bus ) ) ; \n vpci_dev -> flags &= ~ VIRTIO_PCI_FLAG_DISABLE_MODERN ; \n vpci_dev -> flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY ; \n object_property_set_bool ( OBJECT ( vdev ) , true , \" \" , errp ) ; \n }", "idx": 13001}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_out_string ( TestOutputVisitorData * data , \n const void * unused ) \n { \n char * string = ( char * ) \" \" ; \n Error * err = NULL ; \n QObject * obj ; \n visit_type_str ( data -> ov , & string , NULL , & err ) ; \n g_assert ( ! err ) ; \n obj = qmp_output_get_qobject ( data -> qov ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QSTRING ) ; \n g_assert_cmpstr ( qstring_get_str ( qobject_to_qstring ( obj ) ) , == , string ) ; \n qobject_decref ( obj ) ; \n }", "idx": 13002}
{"project": "qemu", "commit_id": "d1048bef9df0aacde9a54bf9b5b97a6e10950d8c", "target": 0, "func": "static void pc_machine_set_vmport ( Object * obj , bool value , Error * * errp ) \n { \n PCMachineState * pcms = PC_MACHINE ( obj ) ; \n pcms -> vmport = value ; \n }", "idx": 13012}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int buffer_empty ( Buffer * buffer ) \n { \n return buffer -> offset == 0 ; \n }", "idx": 13031}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer ( gpointer opaque ) \n { \n struct CharDriverState * chr = opaque ; \n PtyCharDriver * s = chr -> opaque ; \n if ( s -> connected ) { \n goto out ; \n } \n pty_chr_update_read_handler ( chr ) ; \n out : \n s -> timer_tag = 0 ; \n return FALSE ; \n }", "idx": 13035}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init ( MachineState * machine ) \n { \n ram_addr_t ram_size = machine -> ram_size ; \n const char * cpu_model = machine -> cpu_model ; \n const char * kernel_filename = machine -> kernel_filename ; \n const char * initrd_filename = machine -> initrd_filename ; \n CPUUniCore32State * env ; \n UniCore32CPU * cpu ; \n if ( initrd_filename ) { \n error_report ( \" \" ) ; \n exit ( 1 ) ; \n } \n if ( ! cpu_model ) { \n cpu_model = \" \" ; \n } \n cpu = UNICORE32_CPU ( cpu_generic_init ( TYPE_UNICORE32_CPU , cpu_model ) ) ; \n if ( ! cpu ) { \n error_report ( \" \" ) ; \n exit ( 1 ) ; \n } \n env = & cpu -> env ; \n puv3_soc_init ( env ) ; \n puv3_board_init ( env , ram_size ) ; \n puv3_load_kernel ( kernel_filename ) ; \n }", "idx": 13077}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init ( uint32_t base , qemu_irq irq , \n CharDriverState * chr ) \n { \n int iomemtype ; \n pl011_state * s ; \n s = ( pl011_state * ) qemu_mallocz ( sizeof ( pl011_state ) ) ; \n iomemtype = cpu_register_io_memory ( 0 , pl011_readfn , \n pl011_writefn , s ) ; \n cpu_register_physical_memory ( base , 0x00000fff , iomemtype ) ; \n s -> base = base ; \n s -> irq = irq ; \n s -> chr = chr ; \n s -> read_trigger = 1 ; \n s -> ifl = 0x12 ; \n s -> cr = 0x300 ; \n s -> flags = 0x90 ; \n if ( chr ) { \n qemu_chr_add_handlers ( chr , pl011_can_recieve , pl011_recieve , \n pl011_event , s ) ; \n } \n }", "idx": 13114}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer ( DisasContext * ctx , int gprn , int sprn ) \n { \n gen_read_xer ( cpu_gpr [ gprn ] ) ; \n }", "idx": 13118}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_invalid ( void ) \n { \n const char * str = \" \\t \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n unsigned long res = 999 ; \n int err ; \n err = qemu_strtoul ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert ( endptr == str ) ; \n }", "idx": 13136}
{"project": "qemu", "commit_id": "afcf905cff7971324c2706600ead35a1f41f417a", "target": 1, "func": "static void aml_free ( gpointer data , gpointer user_data ) \n { \n Aml * var = data ; \n build_free_array ( var -> buf ) ; \n }", "idx": 13140}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState * text_console_init ( QemuOpts * opts ) \n { \n CharDriverState * chr ; \n QemuConsole * s ; \n unsigned width ; \n unsigned height ; \n chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n width = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n if ( width == 0 ) \n width = qemu_opt_get_number ( opts , \" \" , 0 ) * FONT_WIDTH ; \n height = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n if ( height == 0 ) \n height = qemu_opt_get_number ( opts , \" \" , 0 ) * FONT_HEIGHT ; \n if ( width == 0 || height == 0 ) { \n s = new_console ( NULL , TEXT_CONSOLE ) ; \n } else { \n s = new_console ( NULL , TEXT_CONSOLE_FIXED_SIZE ) ; \n } \n if ( ! s ) { \n g_free ( chr ) ; \n return NULL ; \n } \n s -> chr = chr ; \n s -> g_width = width ; \n s -> g_height = height ; \n chr -> opaque = s ; \n chr -> chr_set_echo = text_console_set_echo ; \n return chr ; \n }", "idx": 13154}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n EEPRO100State * s = opaque ; \n switch ( size ) { \n case 1 : return eepro100_read1 ( s , addr ) ; \n case 2 : return eepro100_read2 ( s , addr ) ; \n case 4 : return eepro100_read4 ( s , addr ) ; \n default : abort ( ) ; \n } \n }", "idx": 13155}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify ( VirtIODevice * vdev , Vring * vring ) \n { \n uint16_t old , new ; \n bool v ; \n smp_mb ( ) ; \n if ( ( vdev -> guest_features & ( 1 << VIRTIO_F_NOTIFY_ON_EMPTY ) ) && \n unlikely ( ! vring_more_avail ( vdev , vring ) ) ) { \n return true ; \n } \n if ( ! ( vdev -> guest_features & ( 1 << VIRTIO_RING_F_EVENT_IDX ) ) ) { \n return ! ( vring_get_avail_flags ( vdev , vring ) & \n VRING_AVAIL_F_NO_INTERRUPT ) ; \n } \n old = vring -> signalled_used ; \n v = vring -> signalled_used_valid ; \n new = vring -> signalled_used = vring -> last_used_idx ; \n vring -> signalled_used_valid = true ; \n if ( unlikely ( ! v ) ) { \n return true ; \n } \n return vring_need_event ( vring_used_event ( & vring -> vr ) , new , old ) ; \n }", "idx": 13156}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access ( target_phys_addr_t addr , int is_write , int is_exec , \n int is_asi , int size ) \n { \n CPUState * saved_env ; \n saved_env = env ; \n env = cpu_single_env ; \n qemu_log ( \" \" TARGET_FMT_plx \" \\n \" , \n addr , is_write , is_exec ) ; \n if ( ! ( env -> sregs [ SR_MSR ] & MSR_EE ) ) { \n return ; \n } \n if ( is_exec ) { \n if ( ! ( env -> pvr . regs [ 2 ] & PVR2_IOPB_BUS_EXC_MASK ) ) { \n env -> sregs [ SR_ESR ] = ESR_EC_INSN_BUS ; \n helper_raise_exception ( EXCP_HW_EXCP ) ; \n } \n } else { \n if ( ! ( env -> pvr . regs [ 2 ] & PVR2_DOPB_BUS_EXC_MASK ) ) { \n env -> sregs [ SR_ESR ] = ESR_EC_DATA_BUS ; \n helper_raise_exception ( EXCP_HW_EXCP ) ; \n } \n } \n }", "idx": 13172}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void ohci_async_cancel_device ( OHCIState * ohci , USBDevice * dev ) \n { \n if ( ohci -> async_td && \n ohci -> usb_packet . owner != NULL && \n ohci -> usb_packet . owner -> dev == dev ) { \n usb_cancel_packet ( & ohci -> usb_packet ) ; \n ohci -> async_td = 0 ; \n } \n }", "idx": 13236}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_abs_store ( CPUTriCoreState * env , DisasContext * ctx ) \n { \n int32_t op2 ; \n int32_t r1 ; \n uint32_t address ; \n TCGv temp ; \n r1 = MASK_OP_ABS_S1D ( ctx -> opcode ) ; \n address = MASK_OP_ABS_OFF18 ( ctx -> opcode ) ; \n op2 = MASK_OP_ABS_OP2 ( ctx -> opcode ) ; \n temp = tcg_const_i32 ( EA_ABS_FORMAT ( address ) ) ; \n switch ( op2 ) { \n case OPC2_32_ABS_ST_A : \n tcg_gen_qemu_st_tl ( cpu_gpr_a [ r1 ] , temp , ctx -> mem_idx , MO_LESL ) ; \n break ; \n case OPC2_32_ABS_ST_D : \n gen_st_2regs_64 ( cpu_gpr_d [ r1 + 1 ] , cpu_gpr_d [ r1 ] , temp , ctx ) ; \n break ; \n case OPC2_32_ABS_ST_DA : \n gen_st_2regs_64 ( cpu_gpr_a [ r1 + 1 ] , cpu_gpr_a [ r1 ] , temp , ctx ) ; \n break ; \n case OPC2_32_ABS_ST_W : \n tcg_gen_qemu_st_tl ( cpu_gpr_d [ r1 ] , temp , ctx -> mem_idx , MO_LESL ) ; \n break ; \n } \n tcg_temp_free ( temp ) ; \n }", "idx": 13347}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readdir ( void * opaque ) \n { \n int32_t fid ; \n V9fsFidState * fidp ; \n ssize_t retval = 0 ; \n size_t offset = 7 ; \n uint64_t initial_offset ; \n int32_t count ; \n uint32_t max_count ; \n V9fsPDU * pdu = opaque ; \n V9fsState * s = pdu -> s ; \n pdu_unmarshal ( pdu , offset , \" \" , & fid , & initial_offset , & max_count ) ; \n trace_v9fs_readdir ( pdu -> tag , pdu -> id , fid , initial_offset , max_count ) ; \n fidp = get_fid ( pdu , fid ) ; \n if ( fidp == NULL ) { \n retval = - EINVAL ; \n goto out_nofid ; \n } \n if ( ! fidp -> fs . dir ) { \n retval = - EINVAL ; \n goto out ; \n } \n if ( initial_offset == 0 ) { \n v9fs_co_rewinddir ( pdu , fidp ) ; \n } else { \n v9fs_co_seekdir ( pdu , fidp , initial_offset ) ; \n } \n count = v9fs_do_readdir ( pdu , fidp , max_count ) ; \n if ( count < 0 ) { \n retval = count ; \n goto out ; \n } \n retval = offset ; \n retval += pdu_marshal ( pdu , offset , \" \" , count ) ; \n retval += count ; \n trace_v9fs_readdir_return ( pdu -> tag , pdu -> id , count , retval ) ; \n out : \n put_fid ( pdu , fidp ) ; \n out_nofid : \n complete_pdu ( s , pdu , retval ) ; \n }", "idx": 13357}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "uint64_t HELPER ( lra ) ( CPUS390XState * env , uint64_t addr ) \n { \n CPUState * cs = CPU ( s390_env_get_cpu ( env ) ) ; \n uint32_t cc = 0 ; \n int old_exc = cs -> exception_index ; \n uint64_t asc = env -> psw . mask & PSW_MASK_ASC ; \n uint64_t ret ; \n int flags ; \n if ( ! ( env -> psw . mask & PSW_MASK_64 ) && ( addr >> 32 ) ) { \n program_interrupt ( env , PGM_SPECIAL_OP , 2 ) ; \n } \n cs -> exception_index = old_exc ; \n if ( mmu_translate ( env , addr , 0 , asc , & ret , & flags ) ) { \n cc = 3 ; \n } \n if ( cs -> exception_index == EXCP_PGM ) { \n ret = env -> int_pgm_code | 0x80000000 ; \n } else { \n ret |= addr & ~ TARGET_PAGE_MASK ; \n } \n cs -> exception_index = old_exc ; \n env -> cc_op = cc ; \n return ret ; \n }", "idx": 13363}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter ( Monitor * mon , QObject * data ) \n { \n QDict * qmp ; \n qmp = qdict_new ( ) ; \n if ( ! monitor_has_error ( mon ) ) { \n if ( data ) { \n assert ( qobject_type ( data ) == QTYPE_QDICT ) ; \n qobject_incref ( data ) ; \n qdict_put_obj ( qmp , \" \" , data ) ; \n } else { \n qdict_put ( qmp , \" \" , qdict_new ( ) ) ; \n } \n } else { \n qdict_put ( mon -> error -> error , \" \" , qerror_human ( mon -> error ) ) ; \n qdict_put ( qmp , \" \" , mon -> error -> error ) ; \n QINCREF ( mon -> error -> error ) ; \n QDECREF ( mon -> error ) ; \n mon -> error = NULL ; \n } \n if ( mon -> mc -> id ) { \n qdict_put_obj ( qmp , \" \" , mon -> mc -> id ) ; \n mon -> mc -> id = NULL ; \n } \n monitor_json_emitter ( mon , QOBJECT ( qmp ) ) ; \n QDECREF ( qmp ) ; \n }", "idx": 13366}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors ) \n { \n BlockDriver * drv = bs -> drv ; \n int ret ; \n if ( ! drv ) { \n return - ENOMEDIUM ; \n } \n if ( ! drv -> bdrv_write_compressed ) { \n return - ENOTSUP ; \n } \n ret = bdrv_check_request ( bs , sector_num , nb_sectors ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n assert ( QLIST_EMPTY ( & bs -> dirty_bitmaps ) ) ; \n return drv -> bdrv_write_compressed ( bs , sector_num , buf , nb_sectors ) ; \n }", "idx": 13415}
{"project": "qemu", "commit_id": "274250c30158f60aefb46088a7bb0d711061226c", "target": 1, "func": "static inline void s390_machine_initfn ( Object * obj ) \n { \n object_property_add_bool ( obj , \" \" , \n machine_get_aes_key_wrap , \n machine_set_aes_key_wrap , NULL ) ; \n object_property_set_description ( obj , \" \" , \n \" \" , \n object_property_set_bool ( obj , true , \" \" , NULL )  ; \n object_property_add_bool ( obj , \" \" , \n machine_get_dea_key_wrap , \n machine_set_dea_key_wrap , NULL ) ; \n object_property_set_description ( obj , \" \" , \n \" \" , \n object_property_set_bool ( obj , true , \" \" , NULL )  ; \n object_property_add_str ( obj , \" \" , \n machine_get_loadparm , machine_set_loadparm , NULL ) ; \n object_property_set_description ( obj , \" \" , \n \" \" \n \" \" \n \" \" , \n }", "idx": 13437}
{"project": "qemu", "commit_id": "b5e751b51f14cffada6be647aa576b79f1755d7e", "target": 1, "func": "static void qemu_spice_display_init_one ( QemuConsole * con ) \n { \n SimpleSpiceDisplay * ssd = g_new0 ( SimpleSpiceDisplay , 1 ) ; \n qemu_spice_display_init_common ( ssd ) ; \n ssd -> qxl . base . sif = & dpy_interface . base ; \n qemu_spice_add_display_interface ( & ssd -> qxl , con ) ; \n assert ( ssd -> worker ) ; \n qemu_spice_create_host_memslot ( ssd ) ; \n ssd -> dcl . ops = & display_listener_ops ; \n ssd -> dcl . con = con ; \n register_displaychangelistener ( & ssd -> dcl ) ; \n }", "idx": 13448}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int32 ( TestInputVisitorData * data , \n const void * unused ) \n { \n test_native_list_integer_helper ( data , unused , \n USER_DEF_NATIVE_LIST_UNION_KIND_S32 ) ; \n }", "idx": 13494}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset ( QEMUResetHandler * func , void * opaque ) \n { \n QEMUResetEntry * re = qemu_mallocz ( sizeof ( QEMUResetEntry ) ) ; \n re -> func = func ; \n re -> opaque = opaque ; \n TAILQ_INSERT_TAIL ( & reset_handlers , re , entry ) ; \n }", "idx": 13513}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "void stl_phys_notdirty ( hwaddr addr , uint32_t val ) \n { \n uint8_t * ptr ; \n MemoryRegionSection * section ; \n section = phys_page_find ( address_space_memory . dispatch , addr >> TARGET_PAGE_BITS ) ; \n if ( ! memory_region_is_ram ( section -> mr ) || section -> readonly ) { \n addr = memory_region_section_addr ( section , addr ) ; \n if ( memory_region_is_ram ( section -> mr ) ) { \n section = & phys_sections [ phys_section_rom ] ; \n } \n io_mem_write ( section -> mr , addr , val , 4 ) ; \n } else { \n unsigned long addr1 = ( memory_region_get_ram_addr ( section -> mr ) \n & TARGET_PAGE_MASK ) \n + memory_region_section_addr ( section , addr ) ; \n ptr = qemu_get_ram_ptr ( addr1 ) ; \n stl_p ( ptr , val ) ; \n if ( unlikely ( in_migration ) ) { \n if ( ! cpu_physical_memory_is_dirty ( addr1 ) ) { \n tb_invalidate_phys_page_range ( addr1 , addr1 + 4 , 0 ) ; \n cpu_physical_memory_set_dirty_flags ( \n addr1 , ( 0xff & ~ CODE_DIRTY_FLAG ) ) ; \n } \n } \n } \n }", "idx": 13517}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus * i440fx_init ( PCII440FXState * * pi440fx_state , int * piix3_devfn , qemu_irq * pic , int ram_size ) \n { \n DeviceState * dev ; \n PCIBus * b ; \n PCIDevice * d ; \n I440FXState * s ; \n PIIX3State * piix3 ; \n dev = qdev_create ( NULL , \" \" ) ; \n s = FROM_SYSBUS ( I440FXState , sysbus_from_qdev ( dev ) ) ; \n b = pci_bus_new ( & s -> busdev . qdev , NULL , 0 ) ; \n s -> bus = b ; \n qdev_init_nofail ( dev ) ; \n d = pci_create_simple ( b , 0 , \" \" ) ; \n * pi440fx_state = DO_UPCAST ( PCII440FXState , dev , d ) ; \n piix3 = DO_UPCAST ( PIIX3State , dev , \n pci_create_simple ( b , -1 , \" \" ) ) ; \n piix3 -> pic = pic ; \n pci_bus_irqs ( b , piix3_set_irq , pci_slot_get_pirq , piix3 , 4 ) ; \n ( * pi440fx_state ) -> piix3 = piix3 ; \n * piix3_devfn = piix3 -> dev . devfn ; \n ram_size = ram_size / 8 / 1024 / 1024 ; \n if ( ram_size > 255 ) \n ram_size = 255 ; \n ( * pi440fx_state ) -> dev . config [ 0x57 ] = ram_size ; \n return b ; \n }", "idx": 13548}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_c ( CPUAlphaState * env , uint64_t a ) \n { \n return inline_cvttq ( env , a , float_round_to_zero , 0 ) ; \n }", "idx": 13554}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu ( DisasContext * dc , TCGv dest , TCGv srca , TCGv srcb ) \n { \n TCGv sr_cy = tcg_temp_new ( ) ; \n tcg_gen_muls2_tl ( dest , sr_cy , srca , srcb ) ; \n tcg_gen_setcondi_tl ( TCG_COND_NE , sr_cy , sr_cy , 0 ) ; \n tcg_gen_deposit_tl ( cpu_sr , cpu_sr , sr_cy , ctz32 ( SR_CY ) , 1 ) ; \n gen_ove_cy ( dc , sr_cy ) ; \n tcg_temp_free ( sr_cy ) ; \n }", "idx": 13556}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4 ( int , sys_utimensat , int , dirfd , const char * , pathname , \n const struct timespec * , tsp , int , flags ) \n #endif \n #endif \n #ifdef CONFIG_INOTIFY \n #include <sys/inotify.h>  \n  \n  \n  \n  #if defined ( TARGET_NR_inotify_init ) && defined ( __NR_inotify_init )  \n  \n  static int sys_inotify_init ( void ) \n { \n return ( inotify_init ( ) ) ; \n }", "idx": 13589}
{"project": "qemu", "commit_id": "8dc7a7725bd6db2aa7e3c09b49bc21a1a25f40cb", "target": 1, "func": "static void curl_readv_bh_cb ( void * p ) \n { \n CURLState * state ; \n int running ; \n CURLAIOCB * acb = p ; \n BDRVCURLState * s = acb -> common . bs -> opaque ; \n qemu_bh_delete ( acb -> bh ) ; \n acb -> bh = NULL ; \n size_t start = acb -> sector_num * SECTOR_SIZE ; \n size_t end ; \n switch ( curl_find_buf ( s , start , acb -> nb_sectors * SECTOR_SIZE , acb ) ) { \n case FIND_RET_OK : \n qemu_aio_release ( acb ) ; \n case FIND_RET_WAIT : \n return ; \n default : \n break ; \n } \n state = curl_init_state ( s ) ; \n if ( ! state ) { \n acb -> common . cb ( acb -> common . opaque , - EIO ) ; \n qemu_aio_release ( acb ) ; \n return ; \n } \n acb -> start = 0 ; \n acb -> end = ( acb -> nb_sectors * SECTOR_SIZE ) ; \n state -> buf_off = 0 ; \n g_free ( state -> orig_buf ) ; \n state -> buf_start = start ; \n state -> buf_len = acb -> end + s -> readahead_size ; \n end = MIN ( start + state -> buf_len , s -> len ) - 1 ; \n state -> orig_buf = g_malloc ( state -> buf_len ) ; \n state -> acb [ 0 ] = acb ; \n snprintf ( state -> range , 127 , \" \" , start , end ) ; \n DPRINTF ( \" \\n \" , \n ( acb -> nb_sectors * SECTOR_SIZE ) , start , state -> range ) ; \n curl_easy_setopt ( state -> curl , CURLOPT_RANGE , state -> range ) ; \n curl_multi_add_handle ( s -> multi , state -> curl ) ; \n curl_multi_socket_action ( s -> multi , CURL_SOCKET_TIMEOUT , 0 , & running ) ; \n }", "idx": 13604}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static inline void menelaus_rtc_stop ( struct menelaus_s * s ) \n { \n qemu_del_timer ( s -> rtc . hz ) ; \n s -> rtc . next = - qemu_get_clock ( rt_clock ) ; \n if ( s -> rtc . next < 1 ) \n s -> rtc . next = 1 ; \n }", "idx": 13667}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq ( gic_state * s , int cpu , int irq ) \n { \n int update = 0 ; \n int cm = 1 << cpu ; \n DPRINTF ( \" \\n \" , irq ) ; \n if ( s -> running_irq [ cpu ] == 1023 ) \n return ; \n if ( irq != 1023 ) { \n if ( ! GIC_TEST_TRIGGER ( irq ) && GIC_TEST_ENABLED ( irq , cm ) \n && GIC_TEST_LEVEL ( irq , cm ) && ( GIC_TARGET ( irq ) & cm ) != 0 ) { \n DPRINTF ( \" \\n \" , irq , cm ) ; \n GIC_SET_PENDING ( irq , cm ) ; \n update = 1 ; \n } \n } \n if ( irq != s -> running_irq [ cpu ] ) { \n int tmp = s -> running_irq [ cpu ] ; \n while ( s -> last_active [ tmp ] [ cpu ] != 1023 ) { \n if ( s -> last_active [ tmp ] [ cpu ] == irq ) { \n s -> last_active [ tmp ] [ cpu ] = s -> last_active [ irq ] [ cpu ] ; \n break ; \n } \n tmp = s -> last_active [ tmp ] [ cpu ] ; \n } \n if ( update ) { \n gic_update ( s ) ; \n } \n } else { \n gic_set_running_irq ( s , cpu , s -> last_active [ s -> running_irq [ cpu ] ] [ cpu ] ) ; \n } \n }", "idx": 13706}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char * vnc_display_local_addr ( const char * id ) \n { \n VncDisplay * vs = vnc_display_find ( id ) ; \n return vnc_socket_local_addr ( \" \" , vs -> lsock ) ; \n }", "idx": 13726}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( set_T0 ) \n { \n T0 = PARAM ( 1 ) ; \n RETURN ( ) ; \n }", "idx": 13728}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_struct_nested ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefTwo * udp = NULL ; \n Error * err = NULL ; \n Visitor * v ; \n v = validate_test_init ( data , \" \" ) ; \n visit_type_UserDefTwo ( v , NULL , & udp , & err ) ; \n error_free_or_abort ( & err ) ; \n qapi_free_UserDefTwo ( udp ) ; \n }", "idx": 13734}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer ( void * opaque , uint8_t * buf , int64_t pos , int size ) \n { \n QEMUFileSocket * s = opaque ; \n ssize_t len ; \n do { \n len = qemu_recv ( s -> fd , buf , size , 0 ) ; \n } while ( len == -1 && socket_error ( ) == EINTR ) ; \n if ( len == -1 ) \n len = - socket_error ( ) ; \n return len ; \n }", "idx": 13736}
{"project": "qemu", "commit_id": "b71706d122838d9656e1a6dae80e22401babdf37", "target": 1, "func": "static GIOStatus ga_channel_write ( GAChannel * c , const char * buf , size_t size , \n size_t * count ) \n { \n GIOStatus status ; \n OVERLAPPED ov = { 0 } ; \n BOOL ret ; \n DWORD written ; \n ov . hEvent = CreateEvent ( NULL , FALSE , FALSE , NULL ) ; \n ret = WriteFile ( c -> handle , buf , size , & written , & ov ) ; \n if ( ! ret ) { \n if ( GetLastError ( ) == ERROR_IO_PENDING ) { \n ret = GetOverlappedResult ( c -> handle , & ov , & written , TRUE ) ; \n if ( ! ret ) { \n if ( ! GetLastError ( ) ) { \n status = G_IO_STATUS_AGAIN ; \n } else { \n status = G_IO_STATUS_ERROR ; \n } else { \n status = G_IO_STATUS_NORMAL ; \n * count = written ; \n } else { \n status = G_IO_STATUS_ERROR ; \n } else { \n status = G_IO_STATUS_NORMAL ; \n * count = written ; \n return status ;", "idx": 13739}
{"project": "qemu", "commit_id": "7d6250e3d1a145e5427f21f5664995e0056b34a6", "target": 0, "func": "void helper_store_sdr1 ( CPUPPCState * env , target_ulong val ) \n { \n PowerPCCPU * cpu = ppc_env_get_cpu ( env ) ; \n if ( ! env -> external_htab ) { \n if ( env -> spr [ SPR_SDR1 ] != val ) { \n ppc_store_sdr1 ( env , val ) ; \n tlb_flush ( CPU ( cpu ) ) ; \n } \n } \n }", "idx": 13754}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_comb_valid ( void * opaque , target_phys_addr_t addr , \n unsigned size , bool is_write ) \n { \n return ( size == 1 ) || ( is_write && size == 2 ) ; \n }", "idx": 13768}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "sPAPRTCETable * spapr_tce_new_table ( DeviceState * owner , uint32_t liobn , \n uint64_t bus_offset , \n uint32_t page_shift , \n uint32_t nb_table , \n bool vfio_accel ) \n { \n sPAPRTCETable * tcet ; \n char tmp [ 64 ] ; \n if ( spapr_tce_find_by_liobn ( liobn ) ) { \n fprintf ( stderr , \" \" \n \" \\n \" , liobn ) ; \n return NULL ; \n } \n if ( ! nb_table ) { \n return NULL ; \n } \n tcet = SPAPR_TCE_TABLE ( object_new ( TYPE_SPAPR_TCE_TABLE ) ) ; \n tcet -> liobn = liobn ; \n tcet -> bus_offset = bus_offset ; \n tcet -> page_shift = page_shift ; \n tcet -> nb_table = nb_table ; \n tcet -> vfio_accel = vfio_accel ; \n snprintf ( tmp , sizeof ( tmp ) , \" \" , liobn ) ; \n object_property_add_child ( OBJECT ( owner ) , tmp , OBJECT ( tcet ) , NULL ) ; \n object_property_set_bool ( OBJECT ( tcet ) , true , \" \" , NULL ) ; \n return tcet ; \n }", "idx": 13772}
{"project": "qemu", "commit_id": "192cf55cc02dc0838bbfa5ac17feb7f6c1651441", "target": 1, "func": "static void debug_print_fis ( uint8_t * fis , int cmd_len ) \n { \n #ifdef DEBUG_AHCI \n int i ; \n fprintf ( stderr , \" \" ) ; \n for ( i = 0 ; i < cmd_len ; i ++ ) { \n if ( ( i & 0xf ) == 0 ) { \n fprintf ( stderr , \" \\n \" , i ) ; \n } \n fprintf ( stderr , \" \" , fis [ i ] ) ; \n } \n fprintf ( stderr , \" \\n \" ) ; \n #endif \n }", "idx": 13784}
{"project": "qemu", "commit_id": "caae58cba07efec5f0616f568531c9dfaf1e9179", "target": 1, "func": "static void pci_spapr_set_irq ( void * opaque , int irq_num , int level ) \n { \n sPAPRPHBState * phb = opaque ; \n trace_spapr_pci_lsi_set ( phb -> busname , irq_num , phb -> lsi_table [ irq_num ] . irq ) ; \n qemu_set_irq ( spapr_phb_lsi_qirq ( phb , irq_num ) , level ) ; \n }", "idx": 13897}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read ( IORange * ioport , uint64_t addr , unsigned width , \n uint64_t * data ) \n { \n PIIX4PMState * s = container_of ( ioport , PIIX4PMState , ioport ) ; \n uint32_t val ; \n switch ( addr ) { \n case 0x00 : \n val = acpi_pm1_evt_get_sts ( & s -> ar , s -> ar . tmr . overflow_time ) ; \n break ; \n case 0x02 : \n val = s -> ar . pm1 . evt . en ; \n break ; \n case 0x04 : \n val = s -> ar . pm1 . cnt . cnt ; \n break ; \n case 0x08 : \n val = acpi_pm_tmr_get ( & s -> ar ) ; \n break ; \n default : \n val = 0 ; \n break ; \n } \n PIIX4_DPRINTF ( \" \\n \" , ( unsigned int ) addr , val ) ; \n * data = val ; \n }", "idx": 13988}
{"project": "qemu", "commit_id": "01b05c66a3616d5a4adc39fc90962e9efaf791d1", "target": 1, "func": "int nbd_receive_reply ( QIOChannel * ioc , NBDReply * reply , Error * * errp ) \n { \n int ret ; \n const char * type ; \n ret = nbd_read_eof ( ioc , & reply -> magic , sizeof ( reply -> magic ) , errp ) ; \n if ( ret <= 0 ) { \n return ret ; \n } \n be32_to_cpus ( & reply -> magic ) ; \n switch ( reply -> magic ) { \n case NBD_SIMPLE_REPLY_MAGIC : \n ret = nbd_receive_simple_reply ( ioc , & reply -> simple , errp ) ; \n if ( ret < 0 ) { \n break ; \n } \n trace_nbd_receive_simple_reply ( reply -> simple . error , \n nbd_err_lookup ( reply -> simple . error ) , \n reply -> handle ) ; \n if ( reply -> simple . error == NBD_ESHUTDOWN ) { \n error_setg ( errp , \" \" ) ; \n return - EINVAL ; \n } \n break ; \n case NBD_STRUCTURED_REPLY_MAGIC : \n ret = nbd_receive_structured_reply_chunk ( ioc , & reply -> structured , errp ) ; \n if ( ret < 0 ) { \n break ; \n } \n type = nbd_reply_type_lookup ( reply -> structured . type ) ; \n trace_nbd_receive_structured_reply_chunk ( reply -> structured . flags , \n reply -> structured . type , type , \n reply -> structured . handle , \n reply -> structured . length ) ; \n break ; \n default : \n error_setg ( errp , \" \" PRIx32 \" \" , reply -> magic ) ; \n return - EINVAL ; \n } \n if ( ret < 0 ) { \n return ret ; \n } \n return 1 ; \n }", "idx": 14022}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests ( SCSIDiskState * s ) \n { \n SCSIDiskReq * r ; \n while ( ! QTAILQ_EMPTY ( & s -> qdev . requests ) ) { \n r = DO_UPCAST ( SCSIDiskReq , req , QTAILQ_FIRST ( & s -> qdev . requests ) ) ; \n if ( r -> req . aiocb ) { \n bdrv_aio_cancel ( r -> req . aiocb ) ; \n } \n scsi_remove_request ( r ) ; \n } \n }", "idx": 14025}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int net_slirp_init ( VLANState * vlan ) \n { \n if ( ! slirp_inited ) { \n slirp_inited = 1 ; \n slirp_init ( ) ; \n } \n slirp_vc = qemu_new_vlan_client ( vlan , \n slirp_receive , NULL ) ; \n snprintf ( slirp_vc -> info_str , sizeof ( slirp_vc -> info_str ) , \" \" ) ; \n return 0 ; \n }", "idx": 14031}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_rw ( target_phys_addr_t addr , uint8_t * buf , \n int len , int is_write ) \n { \n return address_space_rw ( & address_space_memory , addr , buf , len , is_write ) ; \n }", "idx": 14076}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_link ( void * opaque ) \n { \n V9fsPDU * pdu = opaque ; \n V9fsState * s = pdu -> s ; \n int32_t dfid , oldfid ; \n V9fsFidState * dfidp , * oldfidp ; \n V9fsString name ; \n size_t offset = 7 ; \n int err = 0 ; \n pdu_unmarshal ( pdu , offset , \" \" , & dfid , & oldfid , & name ) ; \n trace_v9fs_link ( pdu -> tag , pdu -> id , dfid , oldfid , name . data ) ; \n dfidp = get_fid ( pdu , dfid ) ; \n if ( dfidp == NULL ) { \n err = - ENOENT ; \n goto out_nofid ; \n } \n oldfidp = get_fid ( pdu , oldfid ) ; \n if ( oldfidp == NULL ) { \n err = - ENOENT ; \n goto out ; \n } \n err = v9fs_co_link ( pdu , oldfidp , dfidp , & name ) ; \n if ( ! err ) { \n err = offset ; \n } \n out : \n put_fid ( pdu , dfidp ) ; \n out_nofid : \n v9fs_string_free ( & name ) ; \n complete_pdu ( s , pdu , err ) ; \n }", "idx": 14090}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static XenPTBarFlag xen_pt_bar_reg_parse ( XenPCIPassthroughState * s , \n XenPTRegInfo * reg ) \n { \n PCIDevice * d = & s -> dev ; \n XenPTRegion * region = NULL ; \n PCIIORegion * r ; \n int index = 0 ; \n index = xen_pt_bar_offset_to_index ( reg -> offset ) ; \n if ( ( 0 < index ) && ( index < PCI_ROM_SLOT ) ) { \n int type = s -> real_device . io_regions [ index - 1 ] . type ; \n if ( ( type & XEN_HOST_PCI_REGION_TYPE_MEM ) \n && ( type & XEN_HOST_PCI_REGION_TYPE_MEM_64 ) ) { \n region = & s -> bases [ index - 1 ] ; \n if ( region -> bar_flag != XEN_PT_BAR_FLAG_UPPER ) { \n return XEN_PT_BAR_FLAG_UPPER ; \n } \n } \n } \n r = & d -> io_regions [ index ] ; \n if ( ! xen_pt_get_bar_size ( r ) ) { \n return XEN_PT_BAR_FLAG_UNUSED ; \n } \n if ( index == PCI_ROM_SLOT ) { \n return XEN_PT_BAR_FLAG_MEM ; \n } \n if ( s -> real_device . io_regions [ index ] . type & XEN_HOST_PCI_REGION_TYPE_IO ) { \n return XEN_PT_BAR_FLAG_IO ; \n } else { \n return XEN_PT_BAR_FLAG_MEM ; \n } \n }", "idx": 14126}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_plug_child ( HotplugHandler * plug_handler , \n DeviceState * plugged_dev , Error * * errp ) \n { \n sPAPRPHBState * phb = SPAPR_PCI_HOST_BRIDGE ( DEVICE ( plug_handler ) ) ; \n PCIDevice * pdev = PCI_DEVICE ( plugged_dev ) ; \n sPAPRDRConnector * drc = spapr_phb_get_pci_drc ( phb , pdev ) ; \n Error * local_err = NULL ; \n if ( ! phb -> dr_enabled ) { \n if ( plugged_dev -> hotplugged ) { \n error_setg ( errp , QERR_BUS_NO_HOTPLUG , \n object_get_typename ( OBJECT ( phb ) ) ) ; \n } \n return ; \n } \n g_assert ( drc ) ; \n spapr_phb_add_pci_device ( drc , phb , pdev , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n if ( plugged_dev -> hotplugged ) { \n spapr_hotplug_req_add_by_index ( drc ) ; \n } \n }", "idx": 14162}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options ( const char * fmt , QemuOpts * opts , \n const char * base_filename , \n const char * base_fmt ) \n { \n if ( base_filename ) { \n if ( qemu_opt_set ( opts , BLOCK_OPT_BACKING_FILE , base_filename ) ) { \n error_report ( \" \" , \n fmt ) ; \n return -1 ; \n } \n } \n if ( base_fmt ) { \n if ( qemu_opt_set ( opts , BLOCK_OPT_BACKING_FMT , base_fmt ) ) { \n error_report ( \" \" \n \" \" , fmt ) ; \n return -1 ; \n } \n } \n return 0 ; \n }", "idx": 14220}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_flush_queued_packets ( VLANClientState * vc ) \n { \n while ( ! TAILQ_EMPTY ( & vc -> vlan -> send_queue ) ) { \n VLANPacket * packet ; \n int ret ; \n packet = TAILQ_FIRST ( & vc -> vlan -> send_queue ) ; \n TAILQ_REMOVE ( & vc -> vlan -> send_queue , packet , entry ) ; \n ret = qemu_deliver_packet ( packet -> sender , packet -> data , packet -> size ) ; \n if ( ret == 0 && packet -> sent_cb != NULL ) { \n TAILQ_INSERT_HEAD ( & vc -> vlan -> send_queue , packet , entry ) ; \n break ; \n } \n if ( packet -> sent_cb ) \n packet -> sent_cb ( packet -> sender , ret ) ; \n qemu_free ( packet ) ; \n } \n }", "idx": 14228}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static BlockAIOCB * bdrv_co_aio_rw_vector ( BdrvChild * child , \n int64_t sector_num , \n QEMUIOVector * qiov , \n int nb_sectors , \n BdrvRequestFlags flags , \n BlockCompletionFunc * cb , \n void * opaque , \n bool is_write ) \n { \n Coroutine * co ; \n BlockAIOCBCoroutine * acb ; \n acb = qemu_aio_get ( & bdrv_em_co_aiocb_info , child -> bs , cb , opaque ) ; \n acb -> child = child ; \n acb -> need_bh = true ; \n acb -> req . error = - EINPROGRESS ; \n acb -> req . sector = sector_num ; \n acb -> req . nb_sectors = nb_sectors ; \n acb -> req . qiov = qiov ; \n acb -> req . flags = flags ; \n acb -> is_write = is_write ; \n co = qemu_coroutine_create ( bdrv_co_do_rw ) ; \n qemu_coroutine_enter ( co , acb ) ; \n bdrv_co_maybe_schedule_bh ( acb ) ; \n return & acb -> common ; \n }", "idx": 14324}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init ( ObjectClass * oc , void * data ) \n { \n MachineClass * mc = MACHINE_CLASS ( oc ) ; \n NMIClass * nc = NMI_CLASS ( oc ) ; \n HotplugHandlerClass * hc = HOTPLUG_HANDLER_CLASS ( oc ) ; \n S390CcwMachineClass * s390mc = S390_MACHINE_CLASS ( mc ) ; \n s390mc -> ri_allowed = true ; \n s390mc -> cpu_model_allowed = true ; \n s390mc -> css_migration_enabled = true ; \n s390mc -> gs_allowed = true ; \n mc -> init = ccw_init ; \n mc -> reset = s390_machine_reset ; \n mc -> hot_add_cpu = s390_hot_add_cpu ; \n mc -> block_default_type = IF_VIRTIO ; \n mc -> no_cdrom = 1 ; \n mc -> no_floppy = 1 ; \n mc -> no_serial = 1 ; \n mc -> no_parallel = 1 ; \n mc -> no_sdcard = 1 ; \n mc -> use_sclp = 1 ; \n mc -> max_cpus = S390_MAX_CPUS ; \n mc -> has_hotpluggable_cpus = true ; \n mc -> get_hotplug_handler = s390_get_hotplug_handler ; \n mc -> cpu_index_to_instance_props = s390_cpu_index_to_props ; \n mc -> possible_cpu_arch_ids = s390_possible_cpu_arch_ids ; \n mc -> default_cpu_type = S390_CPU_TYPE_NAME ( \" \" ) ; \n hc -> plug = s390_machine_device_plug ; \n hc -> unplug_request = s390_machine_device_unplug_request ; \n nc -> nmi_monitor_handler = s390_nmi ; \n }", "idx": 14356}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_arm_shift_im ( TCGv var , int shiftop , int shift , int flags ) \n { \n switch ( shiftop ) { \n case 0 : \n if ( shift != 0 ) { \n if ( flags ) \n shifter_out_im ( var , 32 - shift ) ; \n tcg_gen_shli_i32 ( var , var , shift ) ; \n } \n break ; \n case 1 : \n if ( shift == 0 ) { \n if ( flags ) { \n tcg_gen_shri_i32 ( var , var , 31 ) ; \n gen_set_CF ( var ) ; \n } \n tcg_gen_movi_i32 ( var , 0 ) ; \n } else { \n if ( flags ) \n shifter_out_im ( var , shift - 1 ) ; \n tcg_gen_shri_i32 ( var , var , shift ) ; \n } \n break ; \n case 2 : \n if ( shift == 0 ) \n shift = 32 ; \n if ( flags ) \n shifter_out_im ( var , shift - 1 ) ; \n if ( shift == 32 ) \n shift = 31 ; \n tcg_gen_sari_i32 ( var , var , shift ) ; \n break ; \n case 3 : \n if ( shift != 0 ) { \n if ( flags ) \n shifter_out_im ( var , shift - 1 ) ; \n tcg_gen_rotri_i32 ( var , var , shift ) ; break ; \n } else { \n TCGv tmp = load_cpu_field ( CF ) ; \n if ( flags ) \n shifter_out_im ( var , 0 ) ; \n tcg_gen_shri_i32 ( var , var , 1 ) ; \n tcg_gen_shli_i32 ( tmp , tmp , 31 ) ; \n tcg_gen_or_i32 ( var , var , tmp ) ; \n dead_tmp ( tmp ) ; \n } \n } \n } ;", "idx": 14376}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters ( VMXNET3State * s ) \n { \n int i ; \n VMXNET3_READ_DRV_SHARED ( s -> drv_shmem , \n devRead . rxFilterConf . vfTable , \n s -> vlan_table , \n sizeof ( s -> vlan_table ) ) ; \n for ( i = 0 ; i < ARRAY_SIZE ( s -> vlan_table ) ; i ++ ) { \n s -> vlan_table [ i ] = le32_to_cpu ( s -> vlan_table [ i ] ) ; \n } \n VMW_CFPRN ( \" \" ) ; \n for ( i = 0 ; i < sizeof ( s -> vlan_table ) * 8 ; i ++ ) { \n if ( VMXNET3_VFTABLE_ENTRY_IS_SET ( s -> vlan_table , i ) ) { \n VMW_CFPRN ( \" \\t \" , i ) ; \n } \n } \n }", "idx": 14379}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate ( arm_timer_state * s , int reload ) \n { \n uint32_t limit ; \n if ( ( s -> control & TIMER_CTRL_PERIODIC ) == 0 ) { \n if ( s -> control & TIMER_CTRL_32BIT ) \n limit = 0xffffffff ; \n else \n limit = 0xffff ; \n } else { \n limit = s -> limit ; \n } \n ptimer_set_limit ( s -> timer , limit , reload ) ; \n }", "idx": 14387}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_down_char ( void ) \n { \n if ( term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1 ) \n return ; \n if ( term_history [ ++ term_hist_entry ] != NULL ) { \n pstrcpy ( term_cmd_buf , sizeof ( term_cmd_buf ) , \n term_history [ term_hist_entry ] ) ; \n } else { \n term_hist_entry = -1 ; \n } \n term_cmd_buf_index = term_cmd_buf_size = strlen ( term_cmd_buf ) ; \n }", "idx": 14388}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_log_start ( target_phys_addr_t phys_addr , ram_addr_t size ) \n { \n return kvm_dirty_pages_log_change ( phys_addr , size , \n KVM_MEM_LOG_DIRTY_PAGES , \n KVM_MEM_LOG_DIRTY_PAGES ) ; \n }", "idx": 14393}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log ( int argc , const char * * argv ) \n { \n int mask ; \n if ( argc != 2 ) \n goto help ; \n if ( ! strcmp ( argv [ 1 ] , \" \" ) ) { \n mask = 0 ; \n } else { \n mask = cpu_str_to_log_mask ( argv [ 1 ] ) ; \n if ( ! mask ) { \n help : \n help_cmd ( argv [ 0 ] ) ; \n return ; \n } \n } \n cpu_set_log ( mask ) ; \n }", "idx": 14413}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static int kvm_client_migration_log ( struct CPUPhysMemoryClient * client , \n int enable ) \n { \n return kvm_set_migration_log ( enable ) ; \n }", "idx": 14476}
{"project": "qemu", "commit_id": "bd5c51ee6c4f1c79cae5ad2516d711a27b4ea8ec", "target": 0, "func": "static CharDriverState * qemu_chr_open_fd ( int fd_in , int fd_out ) \n { \n CharDriverState * chr ; \n FDCharDriver * s ; \n chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n s = g_malloc0 ( sizeof ( FDCharDriver ) ) ; \n s -> fd_in = io_channel_from_fd ( fd_in ) ; \n s -> fd_out = io_channel_from_fd ( fd_out ) ; \n fcntl ( fd_out , F_SETFL , O_NONBLOCK ) ; \n s -> chr = chr ; \n chr -> opaque = s ; \n chr -> chr_add_watch = fd_chr_add_watch ; \n chr -> chr_write = fd_chr_write ; \n chr -> chr_update_read_handler = fd_chr_update_read_handler ; \n chr -> chr_close = fd_chr_close ; \n qemu_chr_be_generic_open ( chr ) ; \n return chr ; \n }", "idx": 14557}
{"project": "qemu", "commit_id": "9c4bab2668e6b5a9b69f77e3533380b6fd79034e", "target": 0, "func": "static int openfile ( char * name , int flags ) \n { \n if ( bs ) { \n fprintf ( stderr , \" \\n \" ) ; \n return 1 ; \n } \n bs = bdrv_new ( \" \" ) ; \n if ( ! bs ) \n return 1 ; \n if ( bdrv_open ( bs , name , flags ) == -1 ) { \n fprintf ( stderr , \" \\n \" , progname , name ) ; \n bs = NULL ; \n return 1 ; \n } \n return 0 ; \n }", "idx": 14589}
{"project": "qemu", "commit_id": "67113c03423a23e60915574275aed7d60e9f85e1", "target": 0, "func": "static void e500_pcihost_bridge_realize ( PCIDevice * d , Error * * errp ) \n { \n PPCE500PCIBridgeState * b = PPC_E500_PCI_BRIDGE ( d ) ; \n PPCE500CCSRState * ccsr = CCSR ( container_get ( qdev_get_machine ( ) , \n \" \" ) ) ; \n pci_config_set_class ( d -> config , PCI_CLASS_BRIDGE_PCI ) ; \n d -> config [ PCI_HEADER_TYPE ] = \n ( d -> config [ PCI_HEADER_TYPE ] & PCI_HEADER_TYPE_MULTI_FUNCTION ) | \n PCI_HEADER_TYPE_BRIDGE ; \n memory_region_init_alias ( & b -> bar0 , OBJECT ( ccsr ) , \" \" , & ccsr -> ccsr_space , \n 0 , int128_get64 ( ccsr -> ccsr_space . size ) ) ; \n pci_register_bar ( d , 0 , PCI_BASE_ADDRESS_SPACE_MEMORY , & b -> bar0 ) ; \n }", "idx": 14591}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static void pci_unin_main_config_writel ( void * opaque , target_phys_addr_t addr , \n uint32_t val ) \n { \n UNINState * s = opaque ; \n UNIN_DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr , val ) ; \n #ifdef TARGET_WORDS_BIGENDIAN \n val = bswap32 ( val ) ; \n #endif \n s -> config_reg = val ; \n }", "idx": 14679}
{"project": "qemu", "commit_id": "523b018dde3b7650fe5401d0499b30cf2f117515", "target": 1, "func": "vubr_set_vring_addr_exec ( VubrDev * dev , VhostUserMsg * vmsg )  \n { \n struct vhost_vring_addr * vra = & vmsg -> payload . addr ; \n unsigned int index = vra -> index ; \n VubrVirtq * vq = & dev -> vq [ index ] ; \n DPRINT ( \" \\n \" ) ; \n DPRINT ( \" \\n \" , vra -> index ) ; \n DPRINT ( \" \\n \" , vra -> flags ) ; \n DPRINT ( \" \\n \" , vra -> desc_user_addr ) ; \n DPRINT ( \" \\n \" , vra -> used_user_addr ) ; \n DPRINT ( \" \\n \" , vra -> avail_user_addr ) ; \n DPRINT ( \" \\n \" , vra -> log_guest_addr ) ; \n vq -> desc = ( struct vring_desc * ) ( uintptr_t ) qva_to_va ( dev , vra -> desc_user_addr ) ; \n vq -> used = ( struct vring_used * ) ( uintptr_t ) qva_to_va ( dev , vra -> used_user_addr ) ; \n vq -> avail = ( struct vring_avail * ) ( uintptr_t ) qva_to_va ( dev , vra -> avail_user_addr ) ; \n vq -> log_guest_addr = vra -> log_guest_addr ; \n DPRINT ( \" \\n \" ) ; \n DPRINT ( \" \\n \" , vq -> desc ) ; \n DPRINT ( \" \\n \" , vq -> used ) ; \n DPRINT ( \" \\n \" , vq -> avail ) ; \n vq -> last_used_index = vq -> used -> idx ; \n return 0 ; ", "idx": 14680}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static PCIBridgeWindows * pci_bridge_region_init ( PCIBridge * br ) \n { \n PCIDevice * pd = PCI_DEVICE ( br ) ; \n PCIBus * parent = pd -> bus ; \n PCIBridgeWindows * w = g_new ( PCIBridgeWindows , 1 ) ; \n uint16_t cmd = pci_get_word ( pd -> config + PCI_COMMAND ) ; \n pci_bridge_init_alias ( br , & w -> alias_pref_mem , \n PCI_BASE_ADDRESS_MEM_PREFETCH , \n \" \" , \n & br -> address_space_mem , \n parent -> address_space_mem , \n cmd & PCI_COMMAND_MEMORY ) ; \n pci_bridge_init_alias ( br , & w -> alias_mem , \n PCI_BASE_ADDRESS_SPACE_MEMORY , \n \" \" , \n & br -> address_space_mem , \n parent -> address_space_mem , \n cmd & PCI_COMMAND_MEMORY ) ; \n pci_bridge_init_alias ( br , & w -> alias_io , \n PCI_BASE_ADDRESS_SPACE_IO , \n \" \" , \n & br -> address_space_io , \n parent -> address_space_io , \n cmd & PCI_COMMAND_IO ) ; \n pci_bridge_init_vga_aliases ( br , parent , w -> alias_vga ) ; \n return w ; \n }", "idx": 14716}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain ( BlockDriverState * bs ) \n { \n BDRVQEDState * s = bs -> opaque ; \n qed_cancel_need_check_timer ( s ) ; \n qed_plug_allocating_write_reqs ( s ) ; \n bdrv_aio_flush ( s -> bs , qed_clear_need_check , s ) ; \n }", "idx": 14750}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid ( void ) \n { \n const char * str = \" \\t \" ; \n char f = ' ' ; \n const char * endptr = & f ; \n long res = 999 ; \n int err ; \n err = qemu_strtol ( str , & endptr , 0 , & res ) ; \n g_assert_cmpint ( err , == , 0 ) ; \n g_assert_cmpint ( res , == , 0 ) ; \n g_assert ( endptr == str ) ; \n }", "idx": 14774}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind ( const char * hostname , bool * has_proto ) \n { \n int fd = -1 ; \n struct addrinfo ai , * res = NULL ; \n int rc ; \n int ret = -1 ; \n memset ( & ai , 0 , sizeof ( ai ) ) ; \n ai . ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG ; \n ai . ai_family = AF_UNSPEC ; \n ai . ai_socktype = SOCK_STREAM ; \n rc = getaddrinfo ( hostname , NULL , & ai , & res ) ; \n if ( rc != 0 ) { \n if ( rc == EAI_ADDRFAMILY || \n rc == EAI_FAMILY ) { \n * has_proto = false ; \n goto done ; \n } \n goto cleanup ; \n } \n fd = qemu_socket ( res -> ai_family , res -> ai_socktype , res -> ai_protocol ) ; \n if ( fd < 0 ) { \n goto cleanup ; \n } \n if ( bind ( fd , res -> ai_addr , res -> ai_addrlen ) < 0 ) { \n if ( errno == EADDRNOTAVAIL ) { \n * has_proto = false ; \n goto done ; \n } \n goto cleanup ; \n } \n * has_proto = true ; \n done : \n ret = 0 ; \n cleanup : \n if ( fd != -1 ) { \n close ( fd ) ; \n } \n if ( res ) { \n freeaddrinfo ( res ) ; \n } \n return ret ; \n }", "idx": 14775}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool run_poll_handlers ( AioContext * ctx , int64_t max_ns ) \n { \n bool progress = false ; \n int64_t end_time ; \n assert ( ctx -> notify_me ) ; \n assert ( ctx -> walking_handlers > 0 ) ; \n assert ( ctx -> poll_disable_cnt == 0 ) ; \n trace_run_poll_handlers_begin ( ctx , max_ns ) ; \n end_time = qemu_clock_get_ns ( QEMU_CLOCK_REALTIME ) + max_ns ; \n do { \n AioHandler * node ; \n QLIST_FOREACH ( node , & ctx -> aio_handlers , node )  { \n if ( ! node -> deleted && node -> io_poll && \n node -> io_poll ( node -> opaque ) ) { \n progress = true ; \n } \n } \n } while ( ! progress && qemu_clock_get_ns ( QEMU_CLOCK_REALTIME ) < end_time ) ; \n trace_run_poll_handlers_end ( ctx , progress ) ; \n return progress ; \n }", "idx": 14777}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg ( int reg ) \n { \n TCGv var = new_tmp ( ) ; \n tcg_gen_ld_i32 ( var , cpu_env , offsetof ( CPUState , iwmmxt . cregs [ reg ] ) ) ; \n return var ; \n }", "idx": 14814}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void HELPER ( set_cp_reg64 ) ( CPUARMState * env , void * rip , uint64_t value ) \n { \n const ARMCPRegInfo * ri = rip ; \n ri -> writefn ( env , ri , value ) ; \n }", "idx": 14816}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop ( VHostSCSI * s ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( s ) ; \n BusState * qbus = BUS ( qdev_get_parent_bus ( DEVICE ( vdev ) ) ) ; \n VirtioBusClass * k = VIRTIO_BUS_GET_CLASS ( qbus ) ; \n int ret = 0 ; \n if ( ! k -> set_guest_notifiers ) { \n ret = k -> set_guest_notifiers ( qbus -> parent , s -> dev . nvqs , false ) ; \n if ( ret < 0 ) { \n error_report ( \" \\n \" , ret ) ; \n } \n } \n assert ( ret >= 0 ) ; \n vhost_scsi_clear_endpoint ( s ) ; \n vhost_dev_stop ( & s -> dev , vdev ) ; \n vhost_dev_disable_notifiers ( & s -> dev , vdev ) ; \n }", "idx": 14822}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void start_tco ( const TestData * d ) \n { \n uint32_t val ; \n val = qpci_io_readw ( d -> dev , d -> tco_io_base + TCO1_CNT ) ; \n val &= ~ TCO_TMR_HLT ; \n qpci_io_writew ( d -> dev , d -> tco_io_base + TCO1_CNT , val ) ; \n }", "idx": 14823}
{"project": "qemu", "commit_id": "1931076077254a2886daa7c830c7838ebd1f81ef", "target": 0, "func": "void memory_global_dirty_log_stop ( void ) \n { \n global_dirty_log = false ; \n memory_region_transaction_begin ( ) ; \n memory_region_update_pending = true ; \n memory_region_transaction_commit ( ) ; \n MEMORY_LISTENER_CALL_GLOBAL ( log_global_stop , Reverse ) ; \n }", "idx": 14840}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle ( int mountfd , const char * fh , int flags ) \n { \n errno = ENOSYS ; \n return -1 ; \n }", "idx": 14842}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size ( int n ) \n { \n qemu_mutex_lock ( & pool_lock ) ; \n pool_max_size += n ; \n assert ( pool_max_size >= POOL_DEFAULT_SIZE ) ; \n while ( pool_size > pool_max_size ) { \n Coroutine * co = QSLIST_FIRST ( & pool ) ; \n QSLIST_REMOVE_HEAD ( & pool , pool_next ) ; \n pool_size -- ; \n qemu_coroutine_delete ( co ) ; \n } \n qemu_mutex_unlock ( & pool_lock ) ; \n }", "idx": 14904}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void rndis_clear_responsequeue ( USBNetState * s ) \n { \n struct rndis_response * r ; \n while ( ( r = s -> rndis_resp . tqh_first ) ) { \n TAILQ_REMOVE ( & s -> rndis_resp , r , entries ) ; \n qemu_free ( r ) ; \n } \n }", "idx": 14911}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate ( BlockDriverState * bs , int64_t offset ) \n { \n BDRVSheepdogState * s = bs -> opaque ; \n int ret , fd ; \n unsigned int datalen ; \n if ( offset < s -> inode . vdi_size ) { \n error_report ( \" \" ) ; \n return - EINVAL ; \n } else if ( offset > SD_MAX_VDI_SIZE ) { \n error_report ( \" \" ) ; \n return - EINVAL ; \n } \n fd = connect_to_sdog ( s -> addr , s -> port ) ; \n if ( fd < 0 ) { \n return fd ; \n } \n datalen = SD_INODE_SIZE - sizeof ( s -> inode . data_vdi_id ) ; \n s -> inode . vdi_size = offset ; \n ret = write_object ( fd , ( char * ) & s -> inode , vid_to_vdi_oid ( s -> inode . vdi_id ) , \n s -> inode . nr_copies , datalen , 0 , false , s -> cache_enabled ) ; \n close ( fd ) ; \n if ( ret < 0 ) { \n error_report ( \" \" ) ; \n } \n return ret ; \n }", "idx": 14951}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int rndis_parse ( USBNetState * s , uint8_t * data , int length ) \n { \n uint32_t msg_type ; \n le32 * tmp = ( le32 * ) data ; \n msg_type = le32_to_cpup ( tmp ) ; \n switch ( msg_type ) { \n case RNDIS_INITIALIZE_MSG : \n s -> rndis_state = RNDIS_INITIALIZED ; \n return rndis_init_response ( s , ( rndis_init_msg_type * ) data ) ; \n case RNDIS_HALT_MSG : \n s -> rndis_state = RNDIS_UNINITIALIZED ; \n return 0 ; \n case RNDIS_QUERY_MSG : \n return rndis_query_response ( s , ( rndis_query_msg_type * ) data , length ) ; \n case RNDIS_SET_MSG : \n return rndis_set_response ( s , ( rndis_set_msg_type * ) data , length ) ; \n case RNDIS_RESET_MSG : \n rndis_clear_responsequeue ( s ) ; \n s -> out_ptr = s -> in_ptr = s -> in_len = 0 ; \n return rndis_reset_response ( s , ( rndis_reset_msg_type * ) data ) ; \n case RNDIS_KEEPALIVE_MSG : \n return rndis_keepalive_response ( s , ( rndis_keepalive_msg_type * ) data ) ; \n } \n return USB_RET_STALL ; \n }", "idx": 14982}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "static void virtio_blk_handle_output ( VirtIODevice * vdev , VirtQueue * vq ) \n { \n VirtIOBlock * s = VIRTIO_BLK ( vdev ) ; \n VirtIOBlockReq * req ; \n MultiReqBuffer mrb = { } ; \n if ( s -> dataplane ) { \n virtio_blk_data_plane_start ( s -> dataplane ) ; \n return ; \n } \n blk_io_plug ( s -> blk ) ; \n while ( ( req = virtio_blk_get_request ( s ) ) ) { \n virtio_blk_handle_request ( req , & mrb ) ; \n } \n if ( mrb . num_reqs ) { \n virtio_blk_submit_multireq ( s -> blk , & mrb ) ; \n } \n blk_io_unplug ( s -> blk ) ; \n }", "idx": 15016}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "static void realize ( DeviceState * d , Error * * errp ) \n { \n sPAPRDRConnector * drc = SPAPR_DR_CONNECTOR ( d ) ; \n Object * root_container ; \n char link_name [ 256 ] ; \n gchar * child_name ; \n Error * err = NULL ; \n trace_spapr_drc_realize ( spapr_drc_index ( drc ) ) ; \n root_container = container_get ( object_get_root ( ) , DRC_CONTAINER_PATH ) ; \n snprintf ( link_name , sizeof ( link_name ) , \" \" , spapr_drc_index ( drc ) ) ; \n child_name = object_get_canonical_path_component ( OBJECT ( drc ) ) ; \n trace_spapr_drc_realize_child ( spapr_drc_index ( drc ) , child_name ) ; \n object_property_add_alias ( root_container , link_name , \n drc -> owner , child_name , & err ) ; \n g_free ( child_name ) ; \n if ( err ) { \n error_propagate ( errp , err ) ; \n return ; \n } \n vmstate_register ( DEVICE ( drc ) , spapr_drc_index ( drc ) , & vmstate_spapr_drc , \n drc ) ; \n qemu_register_reset ( drc_reset , drc ) ; \n trace_spapr_drc_realize_complete ( spapr_drc_index ( drc ) ) ; \n }", "idx": 15055}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ld_asi ( DisasContext * dc , TCGv dst , TCGv addr , \n int insn , int size , int sign ) \n { \n TCGv_i32 r_asi , r_size , r_sign ; \n r_asi = gen_get_asi ( dc , insn ) ; \n r_size = tcg_const_i32 ( size ) ; \n r_sign = tcg_const_i32 ( sign ) ; \n #ifdef TARGET_SPARC64 \n gen_helper_ld_asi ( dst , cpu_env , addr , r_asi , r_size , r_sign ) ; \n #else \n { \n TCGv_i64 t64 = tcg_temp_new_i64 ( ) ; \n gen_helper_ld_asi ( t64 , cpu_env , addr , r_asi , r_size , r_sign ) ; \n tcg_gen_trunc_i64_tl ( dst , t64 ) ; \n tcg_temp_free_i64 ( t64 ) ; \n } \n #endif \n tcg_temp_free_i32 ( r_sign ) ; \n tcg_temp_free_i32 ( r_size ) ; \n tcg_temp_free_i32 ( r_asi ) ; \n }", "idx": 15061}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod ( uint64_t i ) \n { \n union { \n uint64_t i ; \n float64 d ; \n } v ; \n v . i = i ; \n return v . d ; \n }", "idx": 15066}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_pop ( Visitor * v , void * * obj ) \n { \n QmpInputVisitor * qiv = to_qiv ( v ) ; \n StackObject * tos = QSLIST_FIRST ( & qiv -> stack ) ; \n assert ( tos && tos -> qapi == obj ) ; \n QSLIST_REMOVE_HEAD ( & qiv -> stack , node ) ; \n qmp_input_stack_object_free ( tos ) ; \n }", "idx": 15082}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done ( void * opaque , int ret ) \n { \n struct aio_ctx * ctx = opaque ; \n struct timeval t2 ; \n gettimeofday ( & t2 , NULL ) ; \n if ( ret < 0 ) { \n printf ( \" \\n \" , strerror ( - ret ) ) ; \n goto out ; \n } \n if ( ctx -> Pflag ) { \n void * cmp_buf = g_malloc ( ctx -> qiov . size ) ; \n memset ( cmp_buf , ctx -> pattern , ctx -> qiov . size ) ; \n if ( memcmp ( ctx -> buf , cmp_buf , ctx -> qiov . size ) ) { \n printf ( \" \" \n PRId64 \" \\n \" , ctx -> offset , ctx -> qiov . size ) ; \n } \n g_free ( cmp_buf ) ; \n } \n if ( ctx -> qflag ) { \n goto out ; \n } \n if ( ctx -> vflag ) { \n dump_buffer ( ctx -> buf , ctx -> offset , ctx -> qiov . size ) ; \n } \n t2 = tsub ( t2 , ctx -> t1 ) ; \n print_report ( \" \" , & t2 , ctx -> offset , ctx -> qiov . size , \n ctx -> qiov . size , 1 , ctx -> Cflag ) ; \n out : \n qemu_io_free ( ctx -> buf ) ; \n g_free ( ctx ) ; \n }", "idx": 15132}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init ( void ) \n { \n spapr_rtas_register ( \" \" , rtas_read_pci_config ) ; \n spapr_rtas_register ( \" \" , rtas_write_pci_config ) ; \n spapr_rtas_register ( \" \" , rtas_ibm_read_pci_config ) ; \n spapr_rtas_register ( \" \" , rtas_ibm_write_pci_config ) ; \n if ( msi_supported ) { \n spapr_rtas_register ( \" \" , \n rtas_ibm_query_interrupt_source_number ) ; \n spapr_rtas_register ( \" \" , rtas_ibm_change_msi ) ; \n } \n }", "idx": 15147}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_sec_rs_finalize ( SocketReadState * sec_rs ) \n { \n CompareState * s = container_of ( sec_rs , CompareState , sec_rs ) ; \n if ( packet_enqueue ( s , SECONDARY_IN ) ) { \n trace_colo_compare_main ( \" \" ) ; \n } else { \n g_queue_foreach ( & s -> conn_list , colo_compare_connection , s ) ; \n } \n }", "idx": 15173}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl * fdctrl_init_isa ( DriveInfo * * fds ) \n { \n ISADevice * dev ; \n dev = isa_create ( \" \" ) ; \n if ( fds [ 0 ] ) { \n qdev_prop_set_drive_nofail ( & dev -> qdev , \" \" , fds [ 0 ] -> bdrv ) ; \n } \n if ( fds [ 1 ] ) { \n qdev_prop_set_drive_nofail ( & dev -> qdev , \" \" , fds [ 1 ] -> bdrv ) ; \n } \n if ( qdev_init ( & dev -> qdev ) < 0 ) \n return NULL ; \n return & ( DO_UPCAST ( FDCtrlISABus , busdev , dev ) -> state ) ; \n }", "idx": 15201}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER ( access_check_cp_reg ) ( CPUARMState * env , void * rip , uint32_t syndrome ) \n { \n const ARMCPRegInfo * ri = rip ; \n switch ( ri -> accessfn ( env , ri ) ) { \n case CP_ACCESS_OK : \n case CP_ACCESS_TRAP : \n break ; \n case CP_ACCESS_TRAP_UNCATEGORIZED : \n env -> exception . syndrome = syn_uncategorized ( ) ; \n break ; \n default : \n g_assert_not_reached ( ) ;", "idx": 15209}
{"project": "qemu", "commit_id": "b7c8c35f0afb62efcacd18a64067fe164e3206b6", "target": 1, "func": "static char * scsibus_get_dev_path ( DeviceState * dev ) \n { \n SCSIDevice * d = DO_UPCAST ( SCSIDevice , qdev , dev ) ; \n DeviceState * hba = dev -> parent_bus -> parent ; \n char * id = NULL ; \n if ( hba && hba -> parent_bus && hba -> parent_bus -> info -> get_dev_path ) { \n id = hba -> parent_bus -> info -> get_dev_path ( hba ) ; \n } \n if ( id ) { \n return g_strdup_printf ( \" \" , id , d -> channel , d -> id , d -> lun ) ; \n } else { \n return g_strdup_printf ( \" \" , d -> channel , d -> id , d -> lun ) ; \n } \n }", "idx": 15239}
{"project": "qemu", "commit_id": "8de433cb0820dc1f387a2d580d255744aacd60cc", "target": 1, "func": "void pc_hot_add_cpu ( const int64_t id , Error * * errp ) \n { \n DeviceState * icc_bridge ; \n int64_t apic_id = x86_cpu_apic_id_from_index ( id ) ; \n if ( cpu_exists ( apic_id ) ) { \n error_setg ( errp , \" \" PRIi64 \n \" \" , id ) ; \n if ( id >= max_cpus ) { \n error_setg ( errp , \" \" PRIi64 \n \" \" , id , max_cpus - 1 ) ; \n icc_bridge = DEVICE ( object_resolve_path_type ( \" \" , \n TYPE_ICC_BRIDGE , NULL ) ) ; \n pc_new_cpu ( current_cpu_model , apic_id , icc_bridge , errp ) ;", "idx": 15260}
{"project": "qemu", "commit_id": "a5cf8262e4eb9c4646434e2c6211ef8608db3233", "target": 0, "func": "static char * pcibus_get_fw_dev_path ( DeviceState * dev ) \n { \n PCIDevice * d = ( PCIDevice * ) dev ; \n char path [ 50 ] , name [ 33 ] ; \n int off ; \n off = snprintf ( path , sizeof ( path ) , \" \" , \n pci_dev_fw_name ( dev , name , sizeof name ) , \n PCI_SLOT ( d -> devfn ) ) ; \n if ( PCI_FUNC ( d -> devfn ) ) \n snprintf ( path + off , sizeof ( path ) + off , \" \" , PCI_FUNC ( d -> devfn ) ) ; \n return strdup ( path ) ; \n }", "idx": 15341}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static int qio_channel_websock_handshake_send_response ( QIOChannelWebsock * ioc , \n const char * key , \n Error * * errp ) \n { \n char combined_key [ QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + \n QIO_CHANNEL_WEBSOCK_GUID_LEN + 1 ] ; \n char * accept = NULL , * response = NULL ; \n size_t responselen ; \n g_strlcpy ( combined_key , key , QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1 ) ; \n g_strlcat ( combined_key , QIO_CHANNEL_WEBSOCK_GUID , \n QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + \n QIO_CHANNEL_WEBSOCK_GUID_LEN + 1 ) ; \n if ( qcrypto_hash_base64 ( QCRYPTO_HASH_ALG_SHA1 , \n combined_key , \n QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + \n QIO_CHANNEL_WEBSOCK_GUID_LEN , \n & accept , \n errp ) < 0 ) { \n return -1 ; \n } \n response = g_strdup_printf ( QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE , accept ) ; \n responselen = strlen ( response ) ; \n buffer_reserve ( & ioc -> encoutput , responselen ) ; \n buffer_append ( & ioc -> encoutput , response , responselen ) ; \n g_free ( accept ) ; \n g_free ( response ) ; \n return 0 ; \n }", "idx": 15368}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy ( QemuConsole * con , int src_x , int src_y , \n int dst_x , int dst_y , int w , int h ) \n { \n DisplayState * s = con -> ds ; \n DisplayChangeListener * dcl ; \n if ( ! qemu_console_is_visible ( con ) ) { \n return ; \n } \n QLIST_FOREACH ( dcl , & s -> listeners , next )  { \n if ( con != ( dcl -> con ? dcl -> con : active_console ) ) { \n continue ; \n } \n if ( dcl -> ops -> dpy_gfx_copy ) { \n dcl -> ops -> dpy_gfx_copy ( dcl , src_x , src_y , dst_x , dst_y , w , h ) ; \n } else { \n dcl -> ops -> dpy_gfx_update ( dcl , dst_x , dst_y , w , h ) ; \n } \n } \n }", "idx": 15373}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_print ( QemuOpts * opts , void * dummy ) \n { \n QemuOpt * opt ; \n fprintf ( stderr , \" \" , opts -> list -> name , \n opts -> id ? opts -> id : \" \" ) ; \n TAILQ_FOREACH ( opt , & opts -> head , next )  { \n fprintf ( stderr , \" \\\" \\\" \" , opt -> name , opt -> str ) ; \n } \n fprintf ( stderr , \" \\n \" ) ; \n return 0 ; \n }", "idx": 15411}
{"project": "qemu", "commit_id": "158fd3ce98afd21f2e2639600f6414ea703a9121", "target": 0, "func": "void qemu_run_all_timers ( void ) \n { \n alarm_timer -> pending = 0 ; \n if ( alarm_timer -> expired ) { \n alarm_timer -> expired = 0 ; \n qemu_rearm_alarm_timer ( alarm_timer ) ; \n } \n qemu_run_timers ( vm_clock ) ; \n qemu_run_timers ( rt_clock ) ; \n qemu_run_timers ( host_clock ) ; \n }", "idx": 15434}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce ( CPUState * env , struct kvm_x86_mce * m ) \n { \n return kvm_vcpu_ioctl ( env , KVM_X86_SET_MCE , m ) ; \n }", "idx": 15492}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd ( IDEState * s ) \n { \n uint8_t * buf ; \n buf = s -> io_buffer ; \n #ifdef DEBUG_IDE_ATAPI \n { \n int i ; \n printf ( \" \" , s -> lcyl | ( s -> hcyl << 8 ) ) ; \n for ( i = 0 ; i < ATAPI_PACKET_SIZE ; i ++ ) { \n printf ( \" \" , buf [ i ] ) ; \n } \n printf ( \" \\n \" ) ; \n } \n #endif \n if ( s -> sense_key == UNIT_ATTENTION && \n ! ( atapi_cmd_table [ s -> io_buffer [ 0 ] ] . flags & ALLOW_UA ) ) { \n ide_atapi_cmd_check_status ( s ) ; \n return ; \n } \n if ( ! ( atapi_cmd_table [ s -> io_buffer [ 0 ] ] . flags & ALLOW_UA ) && \n ! s -> tray_open && bdrv_is_inserted ( s -> bs ) && s -> cdrom_changed ) { \n if ( s -> cdrom_changed == 1 ) { \n ide_atapi_cmd_error ( s , NOT_READY , ASC_MEDIUM_NOT_PRESENT ) ; \n s -> cdrom_changed = 2 ; \n } else { \n ide_atapi_cmd_error ( s , UNIT_ATTENTION , ASC_MEDIUM_MAY_HAVE_CHANGED ) ; \n s -> cdrom_changed = 0 ; \n } \n return ; \n } \n if ( ( atapi_cmd_table [ s -> io_buffer [ 0 ] ] . flags & CHECK_READY ) && \n ( ! media_present ( s ) || ! bdrv_is_inserted ( s -> bs ) ) ) \n { \n ide_atapi_cmd_error ( s , NOT_READY , ASC_MEDIUM_NOT_PRESENT ) ; \n return ; \n } \n if ( atapi_cmd_table [ s -> io_buffer [ 0 ] ] . handler ) { \n atapi_cmd_table [ s -> io_buffer [ 0 ] ] . handler ( s , buf ) ; \n return ; \n } \n ide_atapi_cmd_error ( s , ILLEGAL_REQUEST , ASC_ILLEGAL_OPCODE ) ; \n }", "idx": 15495}
{"project": "qemu", "commit_id": "5f706fdc164b20b48254eadf7bd413edace34499", "target": 1, "func": "int s390_cpu_write_elf64_note ( WriteCoreDumpFunction f , CPUState * cs , \n int cpuid , void * opaque ) \n { \n S390CPU * cpu = S390_CPU ( cs ) ; \n return s390x_write_all_elf64_notes ( \" \" , f , cpu , cpuid , opaque ) ; \n }", "idx": 15517}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static int ppc_hash64_pte_update_flags ( struct mmu_ctx_hash64 * ctx , \n target_ulong * pte1p , \n int ret , int rw ) \n { \n int store = 0 ; \n if ( ! ( * pte1p & HPTE64_R_R ) ) { \n * pte1p |= HPTE64_R_R ; \n store = 1 ; \n } \n if ( ! ( * pte1p & HPTE64_R_C ) ) { \n if ( rw == 1 && ret == 0 ) { \n * pte1p |= HPTE64_R_C ; \n store = 1 ; \n } else { \n ctx -> prot &= ~ PAGE_WRITE ; \n } \n } \n return store ; \n }", "idx": 15521}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB * dma_bdrv_write ( BlockDriverState * bs , \n QEMUSGList * sg , uint64_t sector , \n void ( * cb ) ( void * opaque , int ret ) , void * opaque ) \n { \n return dma_bdrv_io ( bs , sg , sector , bdrv_aio_writev , cb , opaque , \n DMA_DIRECTION_TO_DEVICE ) ; \n }", "idx": 15524}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int discard_single_l2 ( BlockDriverState * bs , uint64_t offset , \n unsigned int nb_clusters , enum qcow2_discard_type type , bool full_discard ) \n { \n BDRVQcow2State * s = bs -> opaque ; \n uint64_t * l2_table ; \n int l2_index ; \n int ret ; \n int i ; \n ret = get_cluster_table ( bs , offset , & l2_table , & l2_index ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n nb_clusters = MIN ( nb_clusters , s -> l2_size - l2_index ) ; \n for ( i = 0 ; i < nb_clusters ; i ++ ) { \n uint64_t old_l2_entry ; \n old_l2_entry = be64_to_cpu ( l2_table [ l2_index + i ] ) ; \n switch ( qcow2_get_cluster_type ( old_l2_entry ) ) { \n case QCOW2_CLUSTER_UNALLOCATED : \n if ( full_discard || ! bs -> backing_hd ) { \n continue ; \n } \n break ; \n case QCOW2_CLUSTER_ZERO : \n if ( ! full_discard ) { \n continue ; \n } \n break ; \n case QCOW2_CLUSTER_NORMAL : \n case QCOW2_CLUSTER_COMPRESSED : \n break ; \n default : \n abort ( ) ; \n } \n qcow2_cache_entry_mark_dirty ( bs , s -> l2_table_cache , l2_table ) ; \n if ( ! full_discard && s -> qcow_version >= 3 ) { \n l2_table [ l2_index + i ] = cpu_to_be64 ( QCOW_OFLAG_ZERO ) ; \n } else { \n l2_table [ l2_index + i ] = cpu_to_be64 ( 0 ) ; \n } \n qcow2_free_any_clusters ( bs , old_l2_entry , 1 , type ) ; \n } \n qcow2_cache_put ( bs , s -> l2_table_cache , ( void * * ) & l2_table ) ; \n return nb_clusters ; \n }", "idx": 15530}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int64_t qemu_archipelago_getlength ( BlockDriverState * bs ) \n { \n int64_t ret ; \n BDRVArchipelagoState * s = bs -> opaque ; \n ret = archipelago_volume_info ( s ) ; \n return ret ; \n }", "idx": 15534}
{"project": "qemu", "commit_id": "47445c80fb57035331574ac1ac0bcee67fb84aeb", "target": 0, "func": "static void rtas_ibm_set_eeh_option ( PowerPCCPU * cpu , \n sPAPRMachineState * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , uint32_t nret , \n target_ulong rets ) \n { \n sPAPRPHBState * sphb ; \n sPAPRPHBClass * spc ; \n PCIDevice * pdev ; \n uint32_t addr , option ; \n uint64_t buid ; \n int ret ; \n if ( ( nargs != 4 ) || ( nret != 1 ) ) { \n goto param_error_exit ; \n } \n buid = rtas_ldq ( args , 1 ) ; \n addr = rtas_ld ( args , 0 ) ; \n option = rtas_ld ( args , 3 ) ; \n sphb = spapr_pci_find_phb ( spapr , buid ) ; \n if ( ! sphb ) { \n goto param_error_exit ; \n } \n pdev = pci_find_device ( PCI_HOST_BRIDGE ( sphb ) -> bus , \n ( addr >> 16 ) & 0xFF , ( addr >> 8 ) & 0xFF ) ; \n if ( ! pdev || ! object_dynamic_cast ( OBJECT ( pdev ) , \" \" ) ) { \n goto param_error_exit ; \n } \n spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS ( sphb ) ; \n if ( ! spc -> eeh_set_option ) { \n goto param_error_exit ; \n } \n ret = spc -> eeh_set_option ( sphb , addr , option ) ; \n rtas_st ( rets , 0 , ret ) ; \n return ; \n param_error_exit : \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n }", "idx": 15535}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_remove ( qemu_acl * acl , \n const char * match ) \n { \n qemu_acl_entry * entry ; \n int i = 0 ; \n TAILQ_FOREACH ( entry , & acl -> entries , next )  { \n i ++ ; \n if ( strcmp ( entry -> match , match ) == 0 ) { \n TAILQ_REMOVE ( & acl -> entries , entry , next ) ; \n return i ; \n } \n } \n return -1 ; \n }", "idx": 15537}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_initfn ( PCIDevice * dev ) \n { \n PCIAC97LinkState * d = DO_UPCAST ( PCIAC97LinkState , dev , dev ) ; \n AC97LinkState * s = & d -> ac97 ; \n uint8_t * c = d -> dev . config ; \n s -> pci_dev = & d -> dev ; \n pci_config_set_vendor_id ( c , PCI_VENDOR_ID_INTEL ) ; \n pci_config_set_device_id ( c , PCI_DEVICE_ID_INTEL_82801AA_5 ) ; \n c [ 0x04 ] = 0x00 ; \n c [ 0x05 ] = 0x00 ; \n c [ 0x06 ] = 0x80 ; \n c [ 0x07 ] = 0x02 ; \n c [ 0x08 ] = 0x01 ; \n c [ 0x09 ] = 0x00 ; \n pci_config_set_class ( c , PCI_CLASS_MULTIMEDIA_AUDIO ) ; \n c [ PCI_HEADER_TYPE ] = PCI_HEADER_TYPE_NORMAL ; \n c [ 0x10 ] = 0x01 ; \n c [ 0x11 ] = 0x00 ; \n c [ 0x12 ] = 0x00 ; \n c [ 0x13 ] = 0x00 ; \n c [ 0x14 ] = 0x01 ; \n c [ 0x15 ] = 0x00 ; \n c [ 0x16 ] = 0x00 ; \n c [ 0x17 ] = 0x00 ; \n c [ 0x2c ] = 0x86 ; \n c [ 0x2d ] = 0x80 ; \n c [ 0x2e ] = 0x00 ; \n c [ 0x2f ] = 0x00 ; \n c [ 0x3c ] = 0x00 ; \n c [ 0x3d ] = 0x01 ; \n pci_register_bar ( & d -> dev , 0 , 256 * 4 , PCI_ADDRESS_SPACE_IO , ac97_map ) ; \n pci_register_bar ( & d -> dev , 1 , 64 * 4 , PCI_ADDRESS_SPACE_IO , ac97_map ) ; \n register_savevm ( \" \" , 0 , 2 , ac97_save , ac97_load , s ) ; \n qemu_register_reset ( ac97_on_reset , s ) ; \n AUD_register_card ( \" \" , & s -> card ) ; \n ac97_on_reset ( s ) ; \n }", "idx": 15549}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_output_end_struct ( Visitor * v , Error * * errp ) \n { \n QmpOutputVisitor * qov = to_qov ( v ) ; \n QObject * value = qmp_output_pop ( qov ) ; \n assert ( qobject_type ( value ) == QTYPE_QDICT ) ; \n }", "idx": 15582}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum ( uint8_t * data , uint32_t n , uint32_t sloc , uint32_t css , uint32_t cse )  \n { \n uint32_t sum ; \n if ( cse && cse < n ) \n n = cse + 1 ; \n if ( sloc < n - 1 ) { \n sum = net_checksum_add ( n - css , data + css ) ; \n stw_be_p ( data + sloc , net_checksum_finish ( sum ) ) ; \n } \n }", "idx": 15594}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER ( clcle ) ( CPUS390XState * env , uint32_t r1 , uint64_t a2 , \n uint32_t r3 ) \n { \n uintptr_t ra = GETPC ( ) ; \n uint64_t destlen = get_length ( env , r1 + 1 ) ; \n uint64_t dest = get_address ( env , r1 ) ; \n uint64_t srclen = get_length ( env , r3 + 1 ) ; \n uint64_t src = get_address ( env , r3 ) ; \n uint8_t pad = a2 & 0xff ; \n uint32_t cc = 0 ; \n if ( ! ( destlen || srclen ) ) { \n return cc ; \n } \n if ( srclen > destlen ) { \n srclen = destlen ; \n } \n for ( ; destlen || srclen ; src ++ , dest ++ , destlen -- , srclen -- ) { \n uint8_t v1 = srclen ? cpu_ldub_data_ra ( env , src , ra ) : pad ; \n uint8_t v2 = destlen ? cpu_ldub_data_ra ( env , dest , ra ) : pad ; \n if ( v1 != v2 ) { \n cc = ( v1 < v2 ) ? 1 : 2 ; \n break ; \n } \n } \n set_length ( env , r1 + 1 , destlen ) ; \n set_length ( env , r3 + 1 , env -> regs [ r3 + 1 ] - src - env -> regs [ r3 ] ) ; \n set_address ( env , r1 , dest ) ; \n set_address ( env , r3 , src ) ; \n return cc ; \n }", "idx": 15615}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void * bios_linker_loader_cleanup ( GArray * linker ) \n { \n return g_array_free ( linker , false ) ; \n }", "idx": 15634}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "const ppc_hash_pte64_t * ppc_hash64_map_hptes ( PowerPCCPU * cpu , \n hwaddr ptex , int n ) \n { \n ppc_hash_pte64_t * hptes = NULL ; \n hwaddr pte_offset = ptex * HASH_PTE_SIZE_64 ; \n if ( cpu -> env . external_htab == MMU_HASH64_KVM_MANAGED_HPT ) { \n hptes = g_malloc ( HASH_PTEG_SIZE_64 ) ; \n kvmppc_read_hptes ( hptes , ptex , n ) ; \n } else if ( cpu -> env . external_htab ) { \n hptes = ( ppc_hash_pte64_t * ) ( cpu -> env . external_htab + pte_offset ) ; \n } else if ( cpu -> env . htab_base ) { \n hwaddr plen = n * HASH_PTE_SIZE_64 ; \n hptes = address_space_map ( CPU ( cpu ) -> as , cpu -> env . htab_base + pte_offset , \n & plen , false ) ; \n if ( plen < ( n * HASH_PTE_SIZE_64 ) ) { \n hw_error ( \" \\n \" , __func__ ) ; \n } \n } \n return hptes ; \n }", "idx": 15644}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled ( CPUARMState * env , \n ARMMMUIdx mmu_idx ) \n { \n if ( arm_feature ( env , ARM_FEATURE_M ) ) { \n switch ( env -> v7m . mpu_ctrl & \n ( R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK ) ) { \n case R_V7M_MPU_CTRL_ENABLE_MASK : \n return mmu_idx == ARMMMUIdx_MNegPri || \n mmu_idx == ARMMMUIdx_MSNegPri ; \n case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK : \n return false ; \n case 0 : \n default : \n return true ; \n } \n } \n if ( mmu_idx == ARMMMUIdx_S2NS ) { \n return ( env -> cp15 . hcr_el2 & HCR_VM ) == 0 ; \n } \n return ( regime_sctlr ( env , mmu_idx ) & SCTLR_M ) == 0 ; \n }", "idx": 15653}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read ( void * opaque , target_phys_addr_t addr , unsigned size )  \n { \n E1000State * s = opaque ; \n unsigned int index = ( addr & 0x1ffff ) >> 2 ; \n if ( index < NREADOPS && macreg_readops [ index ] ) \n { \n return macreg_readops [ index ] ( s , index ) ; \n } \n DBGOUT ( UNKNOWN , \" \\n \" , index << 2 ) ; \n return 0 ; \n }", "idx": 15655}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest ( USBCCIDState * s , CCID_XferBlock * recv ) \n { \n uint32_t len ; \n if ( ccid_card_status ( s ) != ICC_STATUS_PRESENT_ACTIVE ) { \n DPRINTF ( s , 1 , \n \" \\n \" ) ; \n ccid_write_data_block_error ( s , recv -> hdr . bSlot , recv -> hdr . bSeq ) ; \n return ; \n } \n len = le32_to_cpu ( recv -> hdr . dwLength ) ; \n DPRINTF ( s , 1 , \" \\n \" , __func__ , \n recv -> hdr . bSeq , len ) ; \n ccid_add_pending_answer ( s , ( CCID_Header * ) recv ) ; \n if ( s -> card ) { \n ccid_card_apdu_from_guest ( s -> card , recv -> abData , len ) ; \n } else { \n DPRINTF ( s , D_WARN , \" \\n \" ) ; \n } \n }", "idx": 15664}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long target_to_host_timespec ( struct timespec * host_ts , \n abi_ulong target_addr ) \n { \n struct target_timespec * target_ts ; \n if ( ! lock_user_struct ( VERIFY_READ , target_ts , target_addr , 1 ) ) \n return - TARGET_EFAULT ; \n host_ts -> tv_sec = tswapal ( target_ts -> tv_sec ) ; \n host_ts -> tv_nsec = tswapal ( target_ts -> tv_nsec ) ; \n unlock_user_struct ( target_ts , target_addr , 0 ) ; \n return 0 ; \n }", "idx": 15690}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void DMA_init ( int high_page_enable , qemu_irq * cpu_request_exit ) \n { \n }", "idx": 15696}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writeb ( void * opaque , target_phys_addr_t addr , uint32_t val ) \n { \n IntelHDAState * d = opaque ; \n const IntelHDAReg * reg = intel_hda_reg_find ( d , addr ) ; \n intel_hda_reg_write ( d , reg , val , 0xff ) ; \n }", "idx": 15728}
{"project": "qemu", "commit_id": "1a29cc8f5ebd657e159dbe4be340102595846d42", "target": 0, "func": "void serial_realize_core ( SerialState * s , Error * * errp ) \n { \n if ( ! qemu_chr_fe_backend_connected ( & s -> chr ) ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n s -> modem_status_poll = timer_new_ns ( QEMU_CLOCK_VIRTUAL , ( QEMUTimerCB * ) serial_update_msl , s ) ; \n s -> fifo_timeout_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , ( QEMUTimerCB * ) fifo_timeout_int , s ) ; \n qemu_register_reset ( serial_reset , s ) ; \n qemu_chr_fe_set_handlers ( & s -> chr , serial_can_receive1 , serial_receive1 , \n serial_event , NULL , s , NULL , true ) ; \n fifo8_create ( & s -> recv_fifo , UART_FIFO_LENGTH ) ; \n fifo8_create ( & s -> xmit_fifo , UART_FIFO_LENGTH ) ; \n serial_reset ( s ) ; \n }", "idx": 15775}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read ( void ) \n { \n logout ( \" \\n \" , \n eeprom . tick , eeprom . scl , eeprom . sda , eeprom . data ) ; \n return eeprom . sda ; \n }", "idx": 15788}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "static void blockdev_do_action ( int kind , void * data , Error * * errp ) \n { \n TransactionAction action ; \n TransactionActionList list ; \n action . kind = kind ; \n action . data = data ; \n list . value = & action ; \n list . next = NULL ; \n qmp_transaction ( & list , errp ) ; \n }", "idx": 15791}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "func": "static uint32_t drc_isolate_physical ( sPAPRDRConnector * drc ) \n { \n switch ( drc -> state ) { \n case SPAPR_DRC_STATE_PHYSICAL_POWERON : \n return RTAS_OUT_SUCCESS ; \n case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED : \n break ; \n case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE : \n return RTAS_OUT_PARAM_ERROR ; \n default : \n g_assert_not_reached ( ) ; \n } \n g_free ( drc -> ccs ) ; \n drc -> ccs = NULL ; \n drc -> state = SPAPR_DRC_STATE_PHYSICAL_POWERON ; \n if ( drc -> unplug_requested ) { \n uint32_t drc_index = spapr_drc_index ( drc ) ; \n trace_spapr_drc_set_isolation_state_finalizing ( drc_index ) ; \n spapr_drc_detach ( drc ) ; \n } \n return RTAS_OUT_SUCCESS ; \n }", "idx": 15818}
{"project": "qemu", "commit_id": "2e6a64cb8d7506ad27d3b6c8000bc8d773936932", "target": 0, "func": "static void input_linux_event_mouse ( void * opaque ) \n { \n InputLinux * il = opaque ; \n struct input_event event ; \n int rc ; \n for ( ; ; ) { \n rc = read ( il -> fd , & event , sizeof ( event ) ) ; \n if ( rc != sizeof ( event ) ) { \n if ( rc < 0 && errno != EAGAIN ) { \n fprintf ( stderr , \" \\n \" , __func__ , strerror ( errno ) ) ; \n qemu_set_fd_handler ( il -> fd , NULL , NULL , NULL ) ; \n close ( il -> fd ) ; \n } \n break ; \n } \n input_linux_handle_mouse ( il , & event ) ; \n } \n }", "idx": 15823}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq ( float64 a , float64 b STATUS_PARAM ) \n { \n if ( ( ( extractFloat64Exp ( a ) == 0x7FF ) && extractFloat64Frac ( a ) ) \n || ( ( extractFloat64Exp ( b ) == 0x7FF ) && extractFloat64Frac ( b ) ) \n ) { \n if ( float64_is_signaling_nan ( a ) || float64_is_signaling_nan ( b ) ) { \n float_raise ( float_flag_invalid STATUS_VAR ) ; \n } \n return 0 ; \n } \n return ( a == b ) || ( ( bits64 ) ( ( a | b ) << 1 ) == 0 ) ; \n }", "idx": 15833}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_cmp ( TCGCond cond , \n int ra , int rb , int rc , \n int islit , uint8_t lit ) \n { \n int l1 , l2 ; \n TCGv tmp ; \n if ( unlikely ( rc == 31 ) ) \n return ; \n l1 = gen_new_label ( ) ; \n l2 = gen_new_label ( ) ; \n if ( ra != 31 ) { \n tmp = tcg_temp_new ( TCG_TYPE_I64 ) ; \n tcg_gen_mov_i64 ( tmp , cpu_ir [ ra ] ) ; \n } else \n tmp = tcg_const_i64 ( 0 ) ; \n if ( islit ) \n tcg_gen_brcondi_i64 ( cond , tmp , lit , l1 ) ; \n else \n tcg_gen_brcond_i64 ( cond , tmp , cpu_ir [ rb ] , l1 ) ; \n tcg_gen_movi_i64 ( cpu_ir [ rc ] , 0 ) ; \n tcg_gen_br ( l2 ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_movi_i64 ( cpu_ir [ rc ] , 1 ) ; \n gen_set_label ( l2 ) ; \n }", "idx": 15840}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int virtio_scsi_device_exit ( DeviceState * qdev ) \n { \n VirtIOSCSI * s = VIRTIO_SCSI ( qdev ) ; \n VirtIOSCSICommon * vs = VIRTIO_SCSI_COMMON ( qdev ) ; \n unregister_savevm ( qdev , \" \" , s ) ; \n return virtio_scsi_common_exit ( vs ) ; \n }", "idx": 15846}
{"project": "qemu", "commit_id": "7d6e771f49c36f4388798ce25bde1dede40cda74", "target": 0, "func": "static int pci_vpb_init ( SysBusDevice * dev ) \n { \n PCIVPBState * s = FROM_SYSBUS ( PCIVPBState , dev ) ; \n PCIBus * bus ; \n int i ; \n for ( i = 0 ; i < 4 ; i ++ ) { \n sysbus_init_irq ( dev , & s -> irq [ i ] ) ; \n } \n bus = pci_register_bus ( & dev -> qdev , \" \" , \n pci_vpb_set_irq , pci_vpb_map_irq , s -> irq , \n get_system_memory ( ) , get_system_io ( ) , \n PCI_DEVFN ( 11 , 0 ) , 4 ) ; \n memory_region_init_io ( & s -> mem_config , & pci_vpb_config_ops , bus , \n \" \" , 0x1000000 ) ; \n memory_region_init_io ( & s -> mem_config2 , & pci_vpb_config_ops , bus , \n \" \" , 0x1000000 ) ; \n if ( s -> realview ) { \n isa_mmio_setup ( & s -> isa , 0x0100000 ) ; \n } \n sysbus_init_mmio_cb2 ( dev , pci_vpb_map , pci_vpb_unmap ) ; \n pci_create_simple ( bus , -1 , \" \" ) ; \n return 0 ; \n }", "idx": 15879}
{"project": "qemu", "commit_id": "feced894fb6c474eb56daeb2b2d1f99bae87677f", "target": 0, "func": "static void rng_random_set_filename ( Object * obj , const char * filename , \n Error * * errp ) \n { \n RngBackend * b = RNG_BACKEND ( obj ) ; \n RndRandom * s = RNG_RANDOM ( obj ) ; \n if ( b -> opened ) { \n error_set ( errp , QERR_PERMISSION_DENIED ) ; \n return ; \n } \n if ( s -> filename ) { \n g_free ( s -> filename ) ; \n } \n s -> filename = g_strdup ( filename ) ; \n }", "idx": 15883}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2 ( PowerPCCPU * cpu , \n sPAPRMachineState * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , uint32_t nret , \n target_ulong rets ) \n { \n sPAPRPHBState * sphb ; \n PCIDevice * pdev ; \n uint32_t addr , option ; \n uint64_t buid ; \n if ( ( nargs != 4 ) || ( nret != 2 ) ) { \n goto param_error_exit ; \n } \n buid = rtas_ldq ( args , 1 ) ; \n sphb = spapr_pci_find_phb ( spapr , buid ) ; \n if ( ! sphb ) { \n goto param_error_exit ; \n } \n if ( ! spapr_phb_eeh_available ( sphb ) ) { \n goto param_error_exit ; \n } \n option = rtas_ld ( args , 3 ) ; \n switch ( option ) { \n case RTAS_GET_PE_ADDR : \n addr = rtas_ld ( args , 0 ) ; \n pdev = spapr_pci_find_dev ( spapr , buid , addr ) ; \n if ( ! pdev ) { \n goto param_error_exit ; \n } \n rtas_st ( rets , 1 , ( pci_bus_num ( pdev -> bus ) << 16 ) + 1 ) ; \n break ; \n case RTAS_GET_PE_MODE : \n rtas_st ( rets , 1 , RTAS_PE_MODE_SHARED ) ; \n break ; \n default : \n goto param_error_exit ; \n } \n rtas_st ( rets , 0 , RTAS_OUT_SUCCESS ) ; \n return ; \n param_error_exit : \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n }", "idx": 15885}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_completed ( MigrationState * s ) \n { \n DPRINTF ( \" \\n \" ) ; \n migrate_fd_cleanup ( s ) ; \n if ( s -> state == MIG_STATE_ACTIVE ) { \n s -> state = MIG_STATE_COMPLETED ; \n runstate_set ( RUN_STATE_POSTMIGRATE ) ; \n } \n notifier_list_notify ( & migration_state_notifiers , s ) ; \n }", "idx": 15890}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_adds_r ( DisasContext * dc ) \n { \n TCGv t0 ; \n int size = memsize_z ( dc ) ; \n DIS ( fprintf ( logfile , \" \\n \" , \n memsize_char ( size ) , \n dc -> op1 , dc -> op2 ) ) ; \n cris_cc_mask ( dc , CC_MASK_NZVC ) ; \n t0 = tcg_temp_new ( TCG_TYPE_TL ) ; \n t_gen_sext ( t0 , cpu_R [ dc -> op1 ] , size ) ; \n cris_alu ( dc , CC_OP_ADD , \n cpu_R [ dc -> op2 ] , cpu_R [ dc -> op2 ] , t0 , 4 ) ; \n tcg_temp_free ( t0 ) ; \n return 2 ; \n }", "idx": 15897}
{"project": "qemu", "commit_id": "b6866fee58bc25b01485dcfcf8be44a915c5f573", "target": 0, "func": "static void virtio_scsi_parse_req ( VirtIOSCSI * s , VirtQueue * vq , \n VirtIOSCSIReq * req ) \n { \n assert ( req -> elem . out_num && req -> elem . in_num ) ; \n req -> vq = vq ; \n req -> dev = s ; \n req -> sreq = NULL ; \n req -> req . buf = req -> elem . out_sg [ 0 ] . iov_base ; \n req -> resp . buf = req -> elem . in_sg [ 0 ] . iov_base ; \n if ( req -> elem . out_num > 1 ) { \n qemu_sgl_init_external ( & req -> qsgl , & req -> elem . out_sg [ 1 ] , \n & req -> elem . out_addr [ 1 ] , \n req -> elem . out_num - 1 ) ; \n } else { \n qemu_sgl_init_external ( & req -> qsgl , & req -> elem . in_sg [ 1 ] , \n & req -> elem . in_addr [ 1 ] , \n req -> elem . in_num - 1 ) ; \n } \n }", "idx": 15911}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int ide_qdev_init ( DeviceState * qdev , DeviceInfo * base ) \n { \n IDEDevice * dev = DO_UPCAST ( IDEDevice , qdev , qdev ) ; \n IDEDeviceInfo * info = DO_UPCAST ( IDEDeviceInfo , qdev , base ) ; \n IDEBus * bus = DO_UPCAST ( IDEBus , qbus , qdev -> parent_bus ) ; \n if ( ! dev -> conf . dinfo ) { \n fprintf ( stderr , \" \\n \" , qdev -> info -> name ) ; \n goto err ; \n } \n if ( dev -> unit == -1 ) { \n dev -> unit = bus -> master ? 1 : 0 ; \n } \n switch ( dev -> unit ) { \n case 0 : \n if ( bus -> master ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto err ; \n } \n bus -> master = dev ; \n break ; \n case 1 : \n if ( bus -> slave ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto err ; \n } \n bus -> slave = dev ; \n break ; \n default : \n goto err ; \n } \n return info -> init ( dev ) ; \n err : \n return -1 ; \n }", "idx": 15929}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_ori ( TCGType type , tcg_target_long val ) \n { \n if ( facilities & FACILITY_EXT_IMM ) { \n if ( type == TCG_TYPE_I32 ) { \n return 1 ; \n } \n } \n if ( val < 0 ) { \n if ( val == ( int16_t ) val ) { \n return 0 ; \n } \n if ( facilities & FACILITY_EXT_IMM ) { \n if ( val == ( int32_t ) val ) { \n return 0 ; \n } \n } \n } \n return 1 ; \n }", "idx": 15943}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_addq_EDI_T0 ( void ) \n { \n EDI = ( EDI + T0 ) ; \n }", "idx": 15962}
{"project": "qemu", "commit_id": "af08a58f0ca338eafee855921859a8c1ace0175b", "target": 0, "func": "static void hypercall_register_types ( void ) \n { \n spapr_register_hypercall ( H_ENTER , h_enter ) ; \n spapr_register_hypercall ( H_REMOVE , h_remove ) ; \n spapr_register_hypercall ( H_PROTECT , h_protect ) ; \n spapr_register_hypercall ( H_READ , h_read ) ; \n spapr_register_hypercall ( H_BULK_REMOVE , h_bulk_remove ) ; \n spapr_register_hypercall ( H_SET_DABR , h_set_dabr ) ; \n spapr_register_hypercall ( H_REGISTER_VPA , h_register_vpa ) ; \n spapr_register_hypercall ( H_CEDE , h_cede ) ; \n spapr_register_hypercall ( H_SET_SPRG0 , h_set_sprg0 ) ; \n spapr_register_hypercall ( H_SET_MODE , h_set_mode ) ; \n spapr_register_hypercall ( H_LOGICAL_CI_LOAD , h_logical_load ) ; \n spapr_register_hypercall ( H_LOGICAL_CI_STORE , h_logical_store ) ; \n spapr_register_hypercall ( H_LOGICAL_CACHE_LOAD , h_logical_load ) ; \n spapr_register_hypercall ( H_LOGICAL_CACHE_STORE , h_logical_store ) ; \n spapr_register_hypercall ( H_LOGICAL_ICBI , h_logical_icbi ) ; \n spapr_register_hypercall ( H_LOGICAL_DCBF , h_logical_dcbf ) ; \n spapr_register_hypercall ( KVMPPC_H_LOGICAL_MEMOP , h_logical_memop ) ; \n spapr_register_hypercall ( KVMPPC_H_RTAS , h_rtas ) ; \n spapr_register_hypercall ( KVMPPC_H_CAS , h_client_architecture_support ) ; \n }", "idx": 15965}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_update_config ( VirtIODevice * vdev , uint8_t * config ) \n { \n VirtIOBlock * s = VIRTIO_BLK ( vdev ) ; \n BlockConf * conf = & s -> conf . conf ; \n struct virtio_blk_config blkcfg ; \n uint64_t capacity ; \n int blk_size = conf -> logical_block_size ; \n bdrv_get_geometry ( s -> bs , & capacity ) ; \n memset ( & blkcfg , 0 , sizeof ( blkcfg ) ) ; \n virtio_stq_p ( vdev , & blkcfg . capacity , capacity ) ; \n virtio_stl_p ( vdev , & blkcfg . seg_max , 128 - 2 ) ; \n virtio_stw_p ( vdev , & blkcfg . cylinders , conf -> cyls ) ; \n virtio_stl_p ( vdev , & blkcfg . blk_size , blk_size ) ; \n virtio_stw_p ( vdev , & blkcfg . min_io_size , conf -> min_io_size / blk_size ) ; \n virtio_stw_p ( vdev , & blkcfg . opt_io_size , conf -> opt_io_size / blk_size ) ; \n blkcfg . heads = conf -> heads ; \n if ( bdrv_getlength ( s -> bs ) / conf -> heads / conf -> secs % blk_size ) { \n blkcfg . sectors = conf -> secs & ~ s -> sector_mask ; \n } else { \n blkcfg . sectors = conf -> secs ; \n } \n blkcfg . size_max = 0 ; \n blkcfg . physical_block_exp = get_physical_block_exp ( conf ) ; \n blkcfg . alignment_offset = 0 ; \n blkcfg . wce = bdrv_enable_write_cache ( s -> bs ) ; \n memcpy ( config , & blkcfg , sizeof ( struct virtio_blk_config ) ) ; \n }", "idx": 15977}
{"project": "qemu", "commit_id": "8f3a73bc57ea83e5b3930d14fc596ea51859987a", "target": 0, "func": "bool blk_dev_is_tray_open ( BlockBackend * blk ) \n { \n if ( blk -> dev_ops && blk -> dev_ops -> is_tray_open ) { \n return blk -> dev_ops -> is_tray_open ( blk -> dev_opaque ) ; \n } \n return false ; \n }", "idx": 15985}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "int bdrv_pwrite ( BlockDriverState * bs , int64_t offset , \n const void * buf1 , int count1 ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( ! drv -> bdrv_pwrite ) \n return bdrv_pwrite_em ( bs , offset , buf1 , count1 ) ; \n if ( bdrv_wr_badreq_bytes ( bs , offset , count1 ) ) \n return - EDOM ; \n return drv -> bdrv_pwrite ( bs , offset , buf1 , count1 ) ; \n }", "idx": 16047}
{"project": "qemu", "commit_id": "ac125d993b461d4dee4d6df4d93ac3f2eb959d1d", "target": 1, "func": "static int local_truncate ( FsContext * ctx , V9fsPath * fs_path , off_t size ) \n { \n char * buffer ; \n int ret ; \n char * path = fs_path -> data ; \n buffer = rpath ( ctx , path ) ; \n ret = truncate ( buffer , size ) ; \n g_free ( buffer ) ; \n return ret ; \n }", "idx": 16057}
{"project": "qemu", "commit_id": "8ba2aae32c40f544def6be7ae82be9bcb781e01d", "target": 0, "func": "void uuid_unparse ( const uuid_t uu , char * out ) \n { \n snprintf ( out , 37 , UUID_FMT , \n uu [ 0 ] , uu [ 1 ] , uu [ 2 ] , uu [ 3 ] , uu [ 4 ] , uu [ 5 ] , uu [ 6 ] , uu [ 7 ] , \n uu [ 8 ] , uu [ 9 ] , uu [ 10 ] , uu [ 11 ] , uu [ 12 ] , uu [ 13 ] , uu [ 14 ] , uu [ 15 ] ) ; \n }", "idx": 16068}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int stellaris_enet_can_receive ( void * opaque ) \n { \n stellaris_enet_state * s = ( stellaris_enet_state * ) opaque ; \n if ( ( s -> rctl & SE_RCTL_RXEN ) == 0 ) \n return 1 ; \n return ( s -> np < 31 ) ; \n }", "idx": 16083}
{"project": "qemu", "commit_id": "75f27498220e6ff6f78bf08fbe2cc662ec76ba89", "target": 0, "func": "void acpi_memory_unplug_cb ( MemHotplugState * mem_st , \n DeviceState * dev , Error * * errp ) \n { \n MemStatus * mdev ; \n mdev = acpi_memory_slot_status ( mem_st , dev , errp ) ; \n if ( ! mdev ) { \n return ; \n } \n assert ( ! object_dynamic_cast ( OBJECT ( dev ) , TYPE_NVDIMM ) ) ; \n mdev -> is_enabled = false ; \n mdev -> dimm = NULL ; \n }", "idx": 16089}
{"project": "qemu", "commit_id": "a7824a886ed50eb4fe3c6fcd6afd8814a6973583", "target": 0, "func": "alloc_f ( int  argc , char * * argv ) \n { \n int64_t offset ; \n int nb_sectors ; \n char s1 [ 64 ] ; \n int num ; \n int ret ; \n const char * retstr ; \n offset = cvtnum ( argv [ 1 ] ) ; \n if ( offset & 0x1ff ) { \n printf ( \" \\n \" , \n ( long long ) offset ) ; \n return 0 ; \n } \n if ( argc == 3 ) \n nb_sectors = cvtnum ( argv [ 2 ] ) ; \n else \n nb_sectors = 1 ; \n ret = bdrv_is_allocated ( bs , offset >> 9 , nb_sectors , & num ) ; \n cvtstr ( offset , s1 , sizeof ( s1 ) ) ; \n retstr = ret ? \" \" : \" \" ; \n if ( nb_sectors == 1 ) \n printf ( \" \\n \" , retstr , s1 ) ; \n else \n printf ( \" \\n \" , \n num , nb_sectors , retstr , s1 ) ; \n return 0 ; \n }", "idx": 16090}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void hmp_cont_cb ( void * opaque , int err ) \n { \n if ( ! err ) { \n qmp_cont ( NULL ) ; \n } \n }", "idx": 16093}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state ( QEMUFile * f , const VMStateDescription * vmsd , \n void * opaque , int version_id ) \n { \n VMStateField * field = vmsd -> fields ; \n if ( version_id > vmsd -> version_id ) { \n return - EINVAL ; \n } \n if ( version_id < vmsd -> minimum_version_id_old ) { \n return - EINVAL ; \n } \n if ( version_id < vmsd -> minimum_version_id ) { \n return vmsd -> load_state_old ( f , opaque , version_id ) ; \n } \n while ( field -> name ) { \n if ( field -> version_id <= version_id ) { \n void * base_addr = opaque + field -> offset ; \n int ret , i , n_elems = 1 ; \n if ( field -> flags & VMS_ARRAY ) { \n n_elems = field -> num ; \n } else if ( field -> flags & VMS_VARRAY ) { \n n_elems = * ( size_t * ) ( opaque + field -> num_offset ) ; \n } \n if ( field -> flags & VMS_POINTER ) { \n base_addr = * ( void * * ) base_addr ; \n } \n for ( i = 0 ; i < n_elems ; i ++ ) { \n void * addr = base_addr + field -> size * i ; \n if ( field -> flags & VMS_STRUCT ) { \n ret = vmstate_load_state ( f , field -> vmsd , addr , version_id ) ; \n } else { \n ret = field -> info -> get ( f , addr , field -> size ) ; \n } \n if ( ret < 0 ) { \n return ret ; \n } \n } \n } \n field ++ ; \n } \n if ( vmsd -> run_after_load ) \n return vmsd -> run_after_load ( opaque ) ; \n return 0 ; \n }", "idx": 16147}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_setcond2 ( TCGContext * s , TCGCond cond , TCGReg ret , \n TCGReg al , TCGReg ah , TCGReg bl , TCGReg bh ) \n { \n TCGReg tmp0 = TCG_TMP0 ; \n TCGReg tmp1 = ret ; \n assert ( ret != TCG_TMP0 ) ; \n if ( ret == ah || ret == bh ) { \n assert ( ret != TCG_TMP1 ) ; \n tmp1 = TCG_TMP1 ; \n } \n switch ( cond ) { \n case TCG_COND_EQ : \n case TCG_COND_NE : \n tmp1 = tcg_out_reduce_eq2 ( s , tmp0 , tmp1 , al , ah , bl , bh ) ; \n tcg_out_setcond ( s , cond , ret , tmp1 , TCG_REG_ZERO ) ; \n break ; \n default : \n tcg_out_setcond ( s , TCG_COND_EQ , tmp0 , ah , bh ) ; \n tcg_out_setcond ( s , tcg_unsigned_cond ( cond ) , tmp1 , al , bl ) ; \n tcg_out_opc_reg ( s , OPC_AND , tmp1 , tmp1 , tmp0 ) ; \n tcg_out_setcond ( s , tcg_high_cond ( cond ) , tmp0 , ah , bh ) ; \n tcg_out_opc_reg ( s , OPC_OR , ret , tmp1 , tmp0 ) ; \n break ; \n } \n }", "idx": 16155}
{"project": "qemu", "commit_id": "28f4a7083dcca084243e313ab18fcdb20d60334e", "target": 0, "func": "static void display_mouse_define ( DisplayChangeListener * dcl , \n QEMUCursor * c ) \n { \n SimpleSpiceDisplay * ssd = container_of ( dcl , SimpleSpiceDisplay , dcl ) ; \n qemu_mutex_lock ( & ssd -> lock ) ; \n if ( c ) { \n cursor_get ( c ) ; \n } \n cursor_put ( ssd -> cursor ) ; \n ssd -> cursor = c ; \n ssd -> hot_x = c -> hot_x ; \n ssd -> hot_y = c -> hot_y ; \n g_free ( ssd -> ptr_move ) ; \n ssd -> ptr_move = NULL ; \n g_free ( ssd -> ptr_define ) ; \n ssd -> ptr_define = qemu_spice_create_cursor_update ( ssd , c , 0 ) ; \n qemu_mutex_unlock ( & ssd -> lock ) ; \n }", "idx": 16163}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline void stw_phys_internal ( hwaddr addr , uint32_t val , \n enum device_endian endian ) \n { \n uint8_t * ptr ; \n MemoryRegionSection * section ; \n section = phys_page_find ( address_space_memory . dispatch , addr >> TARGET_PAGE_BITS ) ; \n if ( ! memory_region_is_ram ( section -> mr ) || section -> readonly ) { \n addr = memory_region_section_addr ( section , addr ) ; \n if ( memory_region_is_ram ( section -> mr ) ) { \n section = & phys_sections [ phys_section_rom ] ; \n } \n #if defined ( TARGET_WORDS_BIGENDIAN )  \n  \n  if ( endian == DEVICE_LITTLE_ENDIAN ) { \n val = bswap16 ( val ) ; \n } \n #else \n if ( endian == DEVICE_BIG_ENDIAN ) { \n val = bswap16 ( val ) ; \n } \n #endif \n io_mem_write ( section -> mr , addr , val , 2 ) ; \n } else { \n unsigned long addr1 ; \n addr1 = ( memory_region_get_ram_addr ( section -> mr ) & TARGET_PAGE_MASK ) \n + memory_region_section_addr ( section , addr ) ; \n ptr = qemu_get_ram_ptr ( addr1 ) ; \n switch ( endian ) { \n case DEVICE_LITTLE_ENDIAN : \n stw_le_p ( ptr , val ) ; \n break ; \n case DEVICE_BIG_ENDIAN : \n stw_be_p ( ptr , val ) ; \n break ; \n default : \n stw_p ( ptr , val ) ; \n break ; \n } \n invalidate_and_set_dirty ( addr1 , 2 ) ; \n } \n }", "idx": 16164}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtdcrx ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n return ; \n } \n gen_update_nip ( ctx , ctx -> nip - 4 ) ; \n gen_helper_store_dcr ( cpu_env , cpu_gpr [ rA ( ctx -> opcode ) ] , \n cpu_gpr [ rS ( ctx -> opcode ) ] ) ; \n #endif \n }", "idx": 16207}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map ( USBPacket * p , QEMUSGList * sgl ) \n { \n int is_write = ( p -> pid == USB_TOKEN_IN ) ; \n target_phys_addr_t len ; \n void * mem ; \n int i ; \n for ( i = 0 ; i < sgl -> nsg ; i ++ ) { \n len = sgl -> sg [ i ] . len ; \n mem = cpu_physical_memory_map ( sgl -> sg [ i ] . base , & len , \n is_write ) ; \n if ( ! mem ) { \n goto err ; \n } \n qemu_iovec_add ( & p -> iov , mem , len ) ; \n if ( len != sgl -> sg [ i ] . len ) { \n goto err ; \n } \n } \n return 0 ; \n err : \n usb_packet_unmap ( p ) ; \n return -1 ; \n }", "idx": 16211}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_status ( IPMIBmcSim * ibs , \n uint8_t * cmd , unsigned int cmd_len , \n uint8_t * rsp , unsigned int * rsp_len , \n unsigned int max_rsp_len ) \n { \n IPMISensor * sens ; \n IPMI_CHECK_CMD_LEN ( 3 ) ; \n if ( ( cmd [ 2 ] > MAX_SENSORS ) || \n ! IPMI_SENSOR_GET_PRESENT ( ibs -> sensors + cmd [ 2 ] ) ) { \n rsp [ 2 ] = IPMI_CC_REQ_ENTRY_NOT_PRESENT ; \n return ; \n } \n sens = ibs -> sensors + cmd [ 2 ] ; \n IPMI_ADD_RSP_DATA ( sens -> reading ) ; \n IPMI_ADD_RSP_DATA ( IPMI_SENSOR_GET_RET_STATUS ( sens ) ) ; \n IPMI_ADD_RSP_DATA ( sens -> assert_states & 0xff ) ; \n IPMI_ADD_RSP_DATA ( ( sens -> assert_states >> 8 ) & 0xff ) ; \n IPMI_ADD_RSP_DATA ( sens -> deassert_states & 0xff ) ; \n IPMI_ADD_RSP_DATA ( ( sens -> deassert_states >> 8 ) & 0xff ) ; \n }", "idx": 16216}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags ( mmu_ctx_t * ctx , target_ulong * pte1p , \n int ret , int rw ) \n { \n int store = 0 ; \n if ( ! ( * pte1p & 0x00000100 ) ) { \n * pte1p |= 0x00000100 ; \n store = 1 ; \n } \n if ( ! ( * pte1p & 0x00000080 ) ) { \n if ( rw == 1 && ret == 0 ) { \n * pte1p |= 0x00000080 ; \n store = 1 ; \n } else { \n ctx -> prot &= ~ PAGE_WRITE ; \n } \n } \n return store ; \n }", "idx": 16237}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device ( AcpiPciHpState * s , unsigned bsel , int slot ) \n { \n s -> acpi_pcihp_pci_status [ bsel ] . device_present |= ( 1U << slot ) ; \n }", "idx": 16246}
{"project": "qemu", "commit_id": "22d5cd82e98b61b1dbd791fab9f4ae0f77c0ed14", "target": 0, "func": "static int raw_inactivate ( BlockDriverState * bs ) \n { \n int ret ; \n uint64_t perm = 0 ; \n uint64_t shared = BLK_PERM_ALL ; \n ret = raw_handle_perm_lock ( bs , RAW_PL_PREPARE , perm , shared , NULL ) ; \n if ( ret ) { \n return ret ; \n } \n raw_handle_perm_lock ( bs , RAW_PL_COMMIT , perm , shared , NULL ) ; \n return 0 ; \n }", "idx": 16274}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_any ( Visitor * v , const char * name , QObject * * obj , \n Error * * errp ) \n { \n QmpOutputVisitor * qov = to_qov ( v ) ; \n qobject_incref ( * obj ) ; \n qmp_output_add_obj ( qov , name , * obj ) ; \n }", "idx": 16276}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static int setup_sigcontext ( struct target_sigcontext * sc , \n CPUSH4State * regs , unsigned long mask ) \n { \n int err = 0 ; \n int i ; \n #define COPY ( x )          __put_user(regs->x, &sc->sc_##x)  \n  \n  COPY ( gregs [ 0 ] ) ; COPY ( gregs [ 1 ] ) ; \n COPY ( gregs [ 2 ] ) ; COPY ( gregs [ 3 ] ) ; \n COPY ( gregs [ 4 ] ) ; COPY ( gregs [ 5 ] ) ; \n COPY ( gregs [ 6 ] ) ; COPY ( gregs [ 7 ] ) ; \n COPY ( gregs [ 8 ] ) ; COPY ( gregs [ 9 ] ) ; \n COPY ( gregs [ 10 ] ) ; COPY ( gregs [ 11 ] ) ; \n COPY ( gregs [ 12 ] ) ; COPY ( gregs [ 13 ] ) ; \n COPY ( gregs [ 14 ] ) ; COPY ( gregs [ 15 ] ) ; \n COPY ( gbr ) ; COPY ( mach ) ; \n COPY ( macl ) ; COPY ( pr ) ; \n COPY ( sr ) ; COPY ( pc ) ; \n #undef  COPY  \n  \n  \n  \n  for ( i = 0 ; i < 16 ; i ++ ) { \n __put_user ( regs -> fregs [ i ] , & sc -> sc_fpregs [ i ] ) ; \n } \n __put_user ( regs -> fpscr , & sc -> sc_fpscr ) ; \n __put_user ( regs -> fpul , & sc -> sc_fpul ) ; \n __put_user ( mask , & sc -> oldmask ) ; \n return err ; \n }", "idx": 16281}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar ( VFIODevice * vdev , int nr ) \n { \n VFIOBAR * bar = & vdev -> bars [ nr ] ; \n if ( ! bar -> size ) { \n return ; \n } \n vfio_bar_quirk_teardown ( vdev , nr ) ; \n memory_region_del_subregion ( & bar -> mem , & bar -> mmap_mem ) ; \n munmap ( bar -> mmap , memory_region_size ( & bar -> mmap_mem ) ) ; \n if ( vdev -> msix && vdev -> msix -> table_bar == nr ) { \n memory_region_del_subregion ( & bar -> mem , & vdev -> msix -> mmap_mem ) ; \n munmap ( vdev -> msix -> mmap , memory_region_size ( & vdev -> msix -> mmap_mem ) ) ; \n } \n memory_region_destroy ( & bar -> mem ) ; \n }", "idx": 16293}
{"project": "qemu", "commit_id": "babfa20ca4721e950d8096f32b1dc091763a8837", "target": 0, "func": "static bool ept_emulation_fault ( uint64_t ept_qual ) \n { \n int read , write ; \n if ( ept_qual & EPT_VIOLATION_INST_FETCH ) { \n return false ; \n } \n read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0 ; \n write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0 ; \n if ( ( read | write ) == 0 ) { \n return false ; \n } \n if ( ( ept_qual & EPT_VIOLATION_GLA_VALID ) == 0 || \n ( ept_qual & EPT_VIOLATION_XLAT_VALID ) == 0 ) { \n return false ; \n } \n return true ; \n }", "idx": 16318}
{"project": "qemu", "commit_id": "225d02cd1a34d5d87e8acefbf8e244a5d12f5f8c", "target": 1, "func": "int qemu_calculate_timeout ( void ) \n { \n #ifndef CONFIG_IOTHREAD \n int timeout ; \n if ( ! vm_running ) \n timeout = 5000 ; \n else { \n int64_t add ; \n int64_t delta ; \n delta = qemu_icount_delta ( ) ; \n if ( delta > 0 ) { \n timeout = ( delta + 999999 ) / 1000000 ; \n } else { \n add = qemu_next_deadline ( ) ; \n if ( add > 10000000 ) \n add = 10000000 ; \n delta += add ; \n qemu_icount += qemu_icount_round ( add ) ; \n timeout = delta / 1000000 ; \n if ( timeout < 0 ) \n timeout = 0 ; \n } \n } \n return timeout ; \n #else \n return 1000 ; \n #endif \n }", "idx": 16365}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void * iothread_run ( void * opaque ) \n { \n IOThread * iothread = opaque ; \n qemu_mutex_lock ( & iothread -> init_done_lock ) ; \n iothread -> thread_id = qemu_get_thread_id ( ) ; \n qemu_cond_signal ( & iothread -> init_done_cond ) ; \n qemu_mutex_unlock ( & iothread -> init_done_lock ) ; \n while ( ! iothread -> stopping ) { \n aio_context_acquire ( iothread -> ctx ) ; \n while ( ! iothread -> stopping && aio_poll ( iothread -> ctx , true ) ) { \n } \n aio_context_release ( iothread -> ctx ) ; \n } \n return NULL ; \n }", "idx": 16410}
{"project": "qemu", "commit_id": "3c3e88a814ef4eb8b2f8bf81863baec24838d998", "target": 0, "func": "static void pc_dimm_get_size ( Object * obj , Visitor * v , const char * name , \n void * opaque , Error * * errp ) \n { \n int64_t value ; \n MemoryRegion * mr ; \n PCDIMMDevice * dimm = PC_DIMM ( obj ) ; \n mr = host_memory_backend_get_memory ( dimm -> hostmem , errp ) ; \n value = memory_region_size ( mr ) ; \n visit_type_int ( v , name , & value , errp ) ; \n }", "idx": 16415}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod ( V9fsState * s , V9fsString * path , mode_t mode ) \n { \n return s -> ops -> chmod ( & s -> ctx , path -> data , mode ) ; \n }", "idx": 16422}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical ( CPUState * env , mmu_ctx_t * ctx , \n target_ulong eaddr , int rw ) \n { \n int in_plb , ret ; \n ctx -> raddr = eaddr ; \n ctx -> prot = PAGE_READ ; \n ret = 0 ; \n switch ( env -> mmu_model ) { \n case POWERPC_MMU_32B : \n case POWERPC_MMU_SOFT_6xx : \n case POWERPC_MMU_SOFT_74xx : \n case POWERPC_MMU_601 : \n case POWERPC_MMU_SOFT_4xx : \n case POWERPC_MMU_REAL_4xx : \n case POWERPC_MMU_BOOKE : \n ctx -> prot |= PAGE_WRITE ; \n break ; \n #if defined ( TARGET_PPC64 )  \n  \n  case POWERPC_MMU_64B : \n case POWERPC_MMU_64BRIDGE : \n ctx -> raddr &= 0x0FFFFFFFFFFFFFFFULL ; \n ctx -> prot |= PAGE_WRITE ; \n break ; \n #endif \n case POWERPC_MMU_SOFT_4xx_Z : \n if ( unlikely ( msr_pe != 0 ) ) { \n in_plb = \n ( env -> pb [ 0 ] < env -> pb [ 1 ] && \n eaddr >= env -> pb [ 0 ] && eaddr < env -> pb [ 1 ] ) || \n ( env -> pb [ 2 ] < env -> pb [ 3 ] && \n eaddr >= env -> pb [ 2 ] && eaddr < env -> pb [ 3 ] ) ? 1 : 0 ; \n if ( in_plb ^ msr_px ) { \n if ( rw == 1 ) { \n ret = -2 ; \n } \n } else { \n ctx -> prot |= PAGE_WRITE ; \n } \n } \n break ; \n case POWERPC_MMU_BOOKE_FSL : \n cpu_abort ( env , \" \\n \" ) ; \n break ; \n default : \n cpu_abort ( env , \" \\n \" ) ; \n return -1 ; \n } \n return ret ; \n }", "idx": 16431}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void set_system_memory_map ( MemoryRegion * mr ) \n { \n memory_region_transaction_begin ( ) ; \n address_space_memory . root = mr ; \n memory_region_transaction_commit ( ) ; \n }", "idx": 16449}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry ( BlockDriverState * bs , int l1_index ) \n { \n BDRVQcowState * s = bs -> opaque ; \n uint64_t buf [ L1_ENTRIES_PER_SECTOR ] ; \n int l1_start_index ; \n int i , ret ; \n l1_start_index = l1_index & ~ ( L1_ENTRIES_PER_SECTOR - 1 ) ; \n for ( i = 0 ; i < L1_ENTRIES_PER_SECTOR ; i ++ ) { \n buf [ i ] = cpu_to_be64 ( s -> l1_table [ l1_start_index + i ] ) ; \n } \n ret = qcow2_pre_write_overlap_check ( bs , \n QCOW2_OL_DEFAULT & ~ QCOW2_OL_ACTIVE_L1 , \n s -> l1_table_offset + 8 * l1_start_index , sizeof ( buf ) ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n BLKDBG_EVENT ( bs -> file , BLKDBG_L1_UPDATE ) ; \n ret = bdrv_pwrite_sync ( bs -> file , s -> l1_table_offset + 8 * l1_start_index , \n buf , sizeof ( buf ) ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return 0 ; \n }", "idx": 16465}
{"project": "qemu", "commit_id": "f46e9a0b9911fcfbc13f85f3a8808067990a0f5c", "target": 0, "func": "static void zero_bss ( abi_ulong elf_bss , abi_ulong last_bss , int prot ) \n { \n uintptr_t host_start , host_map_start , host_end ; \n last_bss = TARGET_PAGE_ALIGN ( last_bss ) ; \n host_start = ( uintptr_t ) g2h ( elf_bss ) ; \n host_end = ( uintptr_t ) g2h ( last_bss ) ; \n host_map_start = ( host_start + qemu_real_host_page_size - 1 ) ; \n host_map_start &= - qemu_real_host_page_size ; \n if ( host_map_start < host_end ) { \n void * p = mmap ( ( void * ) host_map_start , host_end - host_map_start , \n prot , MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS , -1 , 0 ) ; \n if ( p == MAP_FAILED ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n page_set_flags ( elf_bss & TARGET_PAGE_MASK , last_bss , prot | PAGE_VALID ) ; \n } \n if ( host_start < host_map_start ) { \n memset ( ( void * ) host_start , 0 , host_map_start - host_start ) ; \n } \n }", "idx": 16483}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_ld ( TCGContext * s , TCGType type , TCGReg ret , \n TCGReg arg1 , intptr_t arg2 ) \n { \n int opi , opx ; \n assert ( TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32 ) ; \n if ( type == TCG_TYPE_I32 ) { \n opi = LWZ , opx = LWZX ; \n } else { \n opi = LD , opx = LDX ; \n } \n tcg_out_mem_long ( s , opi , opx , ret , arg1 , arg2 ) ; \n }", "idx": 16501}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm ( Monitor * mon , const QDict * qdict ) \n { \n BlockDriverState * bs , * bs1 ; \n Error * err = NULL ; \n const char * name = qdict_get_str ( qdict , \" \" ) ; \n bs = find_vmstate_bs ( ) ; \n if ( ! bs ) { \n monitor_printf ( mon , \" \\n \" ) ; \n return ; \n } \n bs1 = NULL ; \n while ( ( bs1 = bdrv_next ( bs1 ) ) ) { \n if ( bdrv_can_snapshot ( bs1 ) ) { \n bdrv_snapshot_delete_by_id_or_name ( bs , name , & err ) ; \n if ( err ) { \n monitor_printf ( mon , \n \" \" \n \" \\n \" , \n bdrv_get_device_name ( bs ) , \n error_get_pretty ( err ) ) ; \n error_free ( err ) ; \n } \n } \n } \n }", "idx": 16507}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "void object_property_add ( Object * obj , const char * name , const char * type , \n ObjectPropertyAccessor * get , \n ObjectPropertyAccessor * set , \n ObjectPropertyRelease * release , \n void * opaque , Error * * errp ) \n { \n ObjectProperty * prop ; \n QTAILQ_FOREACH ( prop , & obj -> properties , node )  { \n if ( strcmp ( prop -> name , name ) == 0 ) { \n error_setg ( errp , \" \" \n \" \" , name , \n object_get_typename ( obj ) ) ; \n return ; \n } \n } \n prop = g_malloc0 ( sizeof ( * prop ) ) ; \n prop -> name = g_strdup ( name ) ; \n prop -> type = g_strdup ( type ) ; \n prop -> get = get ; \n prop -> set = set ; \n prop -> release = release ; \n prop -> opaque = opaque ; \n QTAILQ_INSERT_TAIL ( & obj -> properties , prop , node ) ; \n }", "idx": 16521}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init ( MachineState * machine ) \n { \n const char * cpu_model = machine -> cpu_model ; \n const char * kernel_filename = machine -> kernel_filename ; \n const char * kernel_cmdline = machine -> kernel_cmdline ; \n const char * initrd_filename = machine -> initrd_filename ; \n StrongARMState * s ; \n DriveInfo * dinfo ; \n MemoryRegion * sysmem = get_system_memory ( ) ; \n if ( ! cpu_model ) { \n cpu_model = \" \" ; \n } \n s = sa1110_init ( sysmem , collie_binfo . ram_size , cpu_model ) ; \n dinfo = drive_get ( IF_PFLASH , 0 , 0 ) ; \n pflash_cfi01_register ( SA_CS0 , NULL , \" \" , 0x02000000 , \n dinfo ? blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) : NULL , \n ( 64 * 1024 ) , 512 , 4 , 0x00 , 0x00 , 0x00 , 0x00 , 0 ) ; \n dinfo = drive_get ( IF_PFLASH , 0 , 1 ) ; \n pflash_cfi01_register ( SA_CS1 , NULL , \" \" , 0x02000000 , \n dinfo ? blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) : NULL , \n ( 64 * 1024 ) , 512 , 4 , 0x00 , 0x00 , 0x00 , 0x00 , 0 ) ; \n sysbus_create_simple ( \" \" , 0x40800000 , NULL ) ; \n collie_binfo . kernel_filename = kernel_filename ; \n collie_binfo . kernel_cmdline = kernel_cmdline ; \n collie_binfo . initrd_filename = initrd_filename ; \n collie_binfo . board_id = 0x208 ; \n arm_load_kernel ( s -> cpu , & collie_binfo ) ; \n }", "idx": 16524}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all ( struct XenBlkDev * blkdev ) \n { \n struct ioreq * ioreq ; \n int send_notify = 0 ; \n while ( ! LIST_EMPTY ( & blkdev -> finished ) ) { \n ioreq = LIST_FIRST ( & blkdev -> finished ) ; \n send_notify += blk_send_response_one ( ioreq ) ; \n ioreq_release ( ioreq ) ; \n } \n if ( send_notify ) \n xen_be_send_notify ( & blkdev -> xendev ) ; \n }", "idx": 16542}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void save_native_fp_fsave ( CPUState * env ) \n { \n int fptag , i , j ; \n uint16_t fpuc ; \n struct fpstate fp1 , * fp = & fp1 ; \n asm volatile ( \" \" : : \" \" ( * fp ) ) ; \n env -> fpuc = fp -> fpuc ; \n env -> fpstt = ( fp -> fpus >> 11 ) & 7 ; \n env -> fpus = fp -> fpus & ~ 0x3800 ; \n fptag = fp -> fptag ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n env -> fptags [ i ] = ( ( fptag & 3 ) == 3 ) ; \n fptag >>= 2 ; \n } \n j = env -> fpstt ; \n for ( i = 0 ; i < 8 ; i ++ ) { \n memcpy ( & env -> fpregs [ j ] . d , & fp -> fpregs1 [ i * 10 ] , 10 ) ; \n j = ( j + 1 ) & 7 ; \n } \n fpuc = 0x037f | ( env -> fpuc & ( 3 << 10 ) ) ; \n asm volatile ( \" \" : : \" \" ( fpuc ) ) ; \n }", "idx": 16628}
{"project": "qemu", "commit_id": "a38648290ee277c7cb8a53eabdcdb08bb7a9f23f", "target": 1, "func": "static void cpu_ioreq_pio ( ioreq_t * req ) \n { \n int i , sign ; \n sign = req -> df ? -1 : 1 ; \n if ( req -> dir == IOREQ_READ ) { \n if ( ! req -> data_is_ptr ) { \n req -> data = do_inp ( req -> addr , req -> size ) ; \n } else { \n uint32_t tmp ; \n for ( i = 0 ; i < req -> count ; i ++ ) { \n tmp = do_inp ( req -> addr , req -> size ) ; \n cpu_physical_memory_write ( \n req -> data + ( sign * i * ( int64_t ) req -> size ) , \n ( uint8_t * ) & tmp , req -> size ) ; \n } \n } \n } else if ( req -> dir == IOREQ_WRITE ) { \n if ( ! req -> data_is_ptr ) { \n do_outp ( req -> addr , req -> size , req -> data ) ; \n } else { \n for ( i = 0 ; i < req -> count ; i ++ ) { \n uint32_t tmp = 0 ; \n cpu_physical_memory_read ( \n req -> data + ( sign * i * ( int64_t ) req -> size ) , \n ( uint8_t * ) & tmp , req -> size ) ; \n do_outp ( req -> addr , req -> size , tmp ) ; \n } \n } \n } \n }", "idx": 16666}
{"project": "qemu", "commit_id": "bd8b92d5c8387c2c94f06665514c05000169fafd", "target": 1, "func": "void usb_claim_port ( USBDevice * dev , Error * * errp ) \n { \n USBBus * bus = usb_bus_from_device ( dev ) ; \n USBPort * port ; \n assert ( dev -> port == NULL ) ; \n if ( dev -> port_path ) { \n QTAILQ_FOREACH ( port , & bus -> free , next )  { \n if ( strcmp ( port -> path , dev -> port_path ) == 0 ) { \n break ; \n } \n } \n if ( port == NULL ) { \n error_setg ( errp , \" \" , \n dev -> port_path , bus -> qbus . name ) ; \n return ; \n } \n } else { \n if ( bus -> nfree == 1 && strcmp ( object_get_typename ( OBJECT ( dev ) ) , \" \" ) != 0 ) { \n usb_create_simple ( bus , \" \" ) ; \n } \n if ( bus -> nfree == 0 ) { \n error_setg ( errp , \" \" \n \" \" , dev -> product_desc ) ; \n return ; \n } \n port = QTAILQ_FIRST ( & bus -> free ) ; \n } \n trace_usb_port_claim ( bus -> busnr , port -> path ) ; \n QTAILQ_REMOVE ( & bus -> free , port , next ) ; \n bus -> nfree -- ; \n dev -> port = port ; \n port -> dev = dev ; \n QTAILQ_INSERT_TAIL ( & bus -> used , port , next ) ; \n bus -> nused ++ ; \n }", "idx": 16717}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static void vmxnet3_update_features ( VMXNET3State * s ) \n { \n uint32_t guest_features ; \n int rxcso_supported ; \n guest_features = VMXNET3_READ_DRV_SHARED32 ( s -> drv_shmem , \n devRead . misc . uptFeatures ) ; \n rxcso_supported = VMXNET_FLAG_IS_SET ( guest_features , UPT1_F_RXCSUM ) ; \n s -> rx_vlan_stripping = VMXNET_FLAG_IS_SET ( guest_features , UPT1_F_RXVLAN ) ; \n s -> lro_supported = VMXNET_FLAG_IS_SET ( guest_features , UPT1_F_LRO ) ; \n VMW_CFPRN ( \" \" , \n s -> lro_supported , rxcso_supported , \n s -> rx_vlan_stripping ) ; \n if ( s -> peer_has_vhdr ) { \n qemu_peer_set_offload ( qemu_get_queue ( s -> nic ) , \n rxcso_supported , \n s -> lro_supported , \n s -> lro_supported , \n 0 , \n 0 ) ; \n } \n }", "idx": 16723}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int virtio_blk_exit_pci ( PCIDevice * pci_dev ) \n { \n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ; \n blockdev_mark_auto_del ( proxy -> block . dinfo -> bdrv ) ; \n return virtio_exit_pci ( pci_dev ) ; \n }", "idx": 16724}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete ( USBPacket * packet , void * opaque ) \n { \n UHCIState * s = opaque ; \n UHCIAsync * async = ( UHCIAsync * ) packet ; \n DPRINTF ( \" \\n \" , async -> td , async -> token ) ; \n async -> done = 1 ; \n uhci_process_frame ( s ) ; \n }", "idx": 16728}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip ( int reg , int q , int tmp , int size ) \n { \n int n ; \n TCGv t0 , t1 ; \n for ( n = 0 ; n < q + 1 ; n += 2 ) { \n t0 = neon_load_reg ( reg , n ) ; \n t1 = neon_load_reg ( reg , n + 1 ) ; \n switch ( size ) { \n case 0 : gen_neon_unzip_u8 ( t0 , t1 ) ; break ; \n case 1 : gen_neon_zip_u16 ( t0 , t1 ) ; break ; \n case 2 : \n ; break ; \n default : abort ( ) ; \n } \n neon_store_scratch ( tmp + n , t0 ) ; \n neon_store_scratch ( tmp + n + 1 , t1 ) ; \n } \n }", "idx": 16735}
{"project": "qemu", "commit_id": "f892291eee376505cfec8b6cade7ccf952a6d3e0", "target": 0, "func": "static void parse_numa_distance ( NumaDistOptions * dist , Error * * errp ) \n { \n uint16_t src = dist -> src ; \n uint16_t dst = dist -> dst ; \n uint8_t val = dist -> val ; \n if ( src >= MAX_NODES || dst >= MAX_NODES ) { \n error_setg ( errp , \n \" \" PRIu16 \n \" \" PRIu16 , \n MAX ( src , dst ) , MAX_NODES ) ; \n return ; \n } \n if ( ! numa_info [ src ] . present || ! numa_info [ dst ] . present ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n return ; \n } \n if ( val < NUMA_DISTANCE_MIN ) { \n error_setg ( errp , \" \" PRIu8 \" \" \n \" \" , \n val , NUMA_DISTANCE_MIN ) ; \n return ; \n } \n if ( src == dst && val != NUMA_DISTANCE_MIN ) { \n error_setg ( errp , \" \" , \n src , NUMA_DISTANCE_MIN ) ; \n return ; \n } \n numa_info [ src ] . distance [ dst ] = val ; \n have_numa_distance = true ; \n }", "idx": 16752}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "uint32_t kvm_arch_get_supported_cpuid ( CPUState * env , uint32_t function , \n uint32_t index , int reg ) \n { \n struct kvm_cpuid2 * cpuid ; \n int i , max ; \n uint32_t ret = 0 ; \n uint32_t cpuid_1_edx ; \n if ( ! kvm_check_extension ( env -> kvm_state , KVM_CAP_EXT_CPUID ) ) { \n return -1U ; \n } \n max = 1 ; \n while ( ( cpuid = try_get_cpuid ( env -> kvm_state , max ) ) == NULL ) { \n max *= 2 ; \n } \n for ( i = 0 ; i < cpuid -> nent ; ++ i ) { \n if ( cpuid -> entries [ i ] . function == function && \n cpuid -> entries [ i ] . index == index ) { \n switch ( reg ) { \n case R_EAX : \n ret = cpuid -> entries [ i ] . eax ; \n break ; \n case R_EBX : \n ret = cpuid -> entries [ i ] . ebx ; \n break ; \n case R_ECX : \n ret = cpuid -> entries [ i ] . ecx ; \n break ; \n case R_EDX : \n ret = cpuid -> entries [ i ] . edx ; \n switch ( function ) { \n case 1 : \n ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA ; \n break ; \n case 0x80000001 : \n cpuid_1_edx = kvm_arch_get_supported_cpuid ( env , 1 , 0 , R_EDX ) ; \n ret |= cpuid_1_edx & 0x183f7ff ; \n break ; \n } \n break ; \n } \n } \n } \n qemu_free ( cpuid ) ; \n return ret ; \n }", "idx": 16771}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static bool get_next_page ( GuestPhysBlock * * blockptr , uint64_t * pfnptr , \n uint8_t * * bufptr , DumpState * s ) \n { \n GuestPhysBlock * block = * blockptr ; \n hwaddr addr ; \n uint8_t * buf ; \n if ( ! block ) { \n block = QTAILQ_FIRST ( & s -> guest_phys_blocks . head ) ; \n * blockptr = block ; \n assert ( block -> target_start % s -> page_size == 0 ) ; \n assert ( block -> target_end % s -> page_size == 0 ) ; \n * pfnptr = paddr_to_pfn ( block -> target_start ) ; \n if ( bufptr ) { \n * bufptr = block -> host_addr ; \n } \n return true ; \n } \n * pfnptr = * pfnptr + 1 ; \n addr = pfn_to_paddr ( * pfnptr ) ; \n if ( ( addr >= block -> target_start ) && \n ( addr + s -> page_size <= block -> target_end ) ) { \n buf = block -> host_addr + ( addr - block -> target_start ) ; \n } else { \n block = QTAILQ_NEXT ( block , next ) ; \n * blockptr = block ; \n if ( ! block ) { \n return false ; \n } \n assert ( block -> target_start % s -> page_size == 0 ) ; \n assert ( block -> target_end % s -> page_size == 0 ) ; \n * pfnptr = paddr_to_pfn ( block -> target_start ) ; \n buf = block -> host_addr ; \n } \n if ( bufptr ) { \n * bufptr = buf ; \n } \n return true ; \n }", "idx": 16780}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_get_descriptor ( USBDevice * dev , int value , uint8_t * dest , size_t len ) \n { \n const USBDesc * desc = dev -> info -> usb_desc ; \n uint8_t buf [ 256 ] ; \n uint8_t type = value >> 8 ; \n uint8_t index = value & 0xff ; \n int ret = -1 ; \n switch ( type ) { \n case USB_DT_DEVICE : \n ret = usb_desc_device ( & desc -> id , desc -> full , buf , sizeof ( buf ) ) ; \n trace_usb_desc_device ( dev -> addr , len , ret ) ; \n break ; \n case USB_DT_CONFIG : \n if ( index < desc -> full -> bNumConfigurations ) { \n ret = usb_desc_config ( desc -> full -> confs + index , buf , sizeof ( buf ) ) ; \n } \n trace_usb_desc_config ( dev -> addr , index , len , ret ) ; \n break ; \n case USB_DT_STRING : \n ret = usb_desc_string ( dev , index , buf , sizeof ( buf ) ) ; \n trace_usb_desc_string ( dev -> addr , index , len , ret ) ; \n break ; \n default : \n fprintf ( stderr , \" \\n \" , __FUNCTION__ , \n dev -> addr , type , len ) ; \n break ; \n } \n if ( ret > 0 ) { \n if ( ret > len ) { \n ret = len ; \n } \n memcpy ( dest , buf , ret ) ; \n } \n return ret ; \n }", "idx": 16787}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init ( MachineState * machine ) \n { \n PXA2xxState * cpu ; \n DriveInfo * dinfo ; \n int be ; \n MemoryRegion * address_space_mem = get_system_memory ( ) ; \n uint32_t connex_rom = 0x01000000 ; \n uint32_t connex_ram = 0x04000000 ; \n cpu = pxa255_init ( address_space_mem , connex_ram ) ; \n dinfo = drive_get ( IF_PFLASH , 0 , 0 ) ; \n if ( ! dinfo && ! qtest_enabled ( ) ) { \n fprintf ( stderr , \" \" \n \" \\n \" ) ; \n exit ( 1 ) ; \n } \n #ifdef TARGET_WORDS_BIGENDIAN \n be = 1 ; \n #else \n be = 0 ; \n #endif \n if ( ! pflash_cfi01_register ( 0x00000000 , NULL , \" \" , connex_rom , \n dinfo ? blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) : NULL , \n sector_len , connex_rom / sector_len , \n 2 , 0 , 0 , 0 , 0 , be ) ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n smc91c111_init ( & nd_table [ 0 ] , 0x04000300 , \n qdev_get_gpio_in ( cpu -> gpio , 36 ) ) ; \n }", "idx": 16792}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier ( AioContext * ctx , \n EventNotifier * notifier , \n bool is_external , \n EventNotifierHandler * io_read , \n AioPollFn * io_poll ) \n { \n aio_set_fd_handler ( ctx , event_notifier_get_fd ( notifier ) , is_external , \n ( IOHandler * ) io_read , NULL , io_poll , notifier ) ; \n }", "idx": 16794}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_modify_page ( CPUState * env , ram_addr_t ram_addr ) \n { \n unsigned long page_index ; \n int ret ; \n #ifdef _WIN32 \n DWORD temp ; \n #endif \n page_index = ram_addr >> TARGET_PAGE_BITS ; \n if ( ! modified_ram_pages_table [ page_index ] ) { \n #if 0  \n  \n  printf ( \" \\n \" , nb_modified_ram_pages , ram_addr ) ; \n #endif \n modified_ram_pages_table [ page_index ] = 1 ; \n modified_ram_pages [ nb_modified_ram_pages ++ ] = ram_addr ; \n if ( nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES ) { \n #ifdef _WIN32 \n ret = DeviceIoControl ( kqemu_fd , KQEMU_MODIFY_RAM_PAGES , \n & nb_modified_ram_pages , \n sizeof ( nb_modified_ram_pages ) , \n NULL , 0 , & temp , NULL ) ; \n #else \n ret = ioctl ( kqemu_fd , KQEMU_MODIFY_RAM_PAGES , \n & nb_modified_ram_pages ) ; \n #endif \n kqemu_reset_modified_ram_pages ( ) ; \n } \n } \n }", "idx": 16812}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll ( AioContext * ctx , GPollFD * pfds , \n unsigned npfd , int64_t timeout ) \n { \n if ( ! ctx -> epoll_available ) { \n return false ; \n } \n if ( aio_epoll_enabled ( ctx ) ) { \n return true ; \n } \n if ( npfd >= EPOLL_ENABLE_THRESHOLD ) { \n if ( aio_epoll_try_enable ( ctx ) ) { \n return true ; \n } else { \n aio_epoll_disable ( ctx ) ; \n } \n } \n return false ; \n }", "idx": 16829}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void aarch64_cpu_register_types ( void ) \n { \n int i ; \n type_register_static ( & aarch64_cpu_type_info ) ; \n for ( i = 0 ; i < ARRAY_SIZE ( aarch64_cpus ) ; i ++ ) { \n aarch64_cpu_register ( & aarch64_cpus [ i ] ) ; \n } \n }", "idx": 16842}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write ( void * opaque , target_phys_addr_t offset , \n uint64_t value , unsigned size ) \n { \n musicpal_lcd_state * s = opaque ; \n switch ( offset ) { \n case MP_LCD_IRQCTRL : \n s -> irqctrl = value ; \n break ; \n case MP_LCD_SPICTRL : \n if ( value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD ) { \n s -> mode = value ; \n } else { \n s -> mode = MP_LCD_SPI_INVALID ; \n } \n break ; \n case MP_LCD_INST : \n if ( value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7 ) { \n s -> page = value - MP_LCD_INST_SETPAGE0 ; \n s -> page_off = 0 ; \n } \n break ; \n case MP_LCD_DATA : \n if ( s -> mode == MP_LCD_SPI_CMD ) { \n if ( value >= MP_LCD_INST_SETPAGE0 && \n value <= MP_LCD_INST_SETPAGE7 ) { \n s -> page = value - MP_LCD_INST_SETPAGE0 ; \n s -> page_off = 0 ; \n } \n } else if ( s -> mode == MP_LCD_SPI_DATA ) { \n s -> video_ram [ s -> page * 128 + s -> page_off ] = value ; \n s -> page_off = ( s -> page_off + 1 ) & 127 ; \n } \n break ; \n } \n }", "idx": 16862}
{"project": "qemu", "commit_id": "3b2e934463121f06d04e4d17658a9a7cdc3717b0", "target": 0, "func": "static inline uint32_t nvic_gprio_mask ( NVICState * s ) \n { \n return ~ 0U << ( s -> prigroup + 1 ) ; \n }", "idx": 16870}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "int qemu_eventfd ( int fds [ 2 ] ) \n { \n #ifdef CONFIG_EVENTFD \n int ret ; \n ret = eventfd ( 0 , 0 ) ; \n if ( ret >= 0 ) { \n fds [ 0 ] = ret ; \n qemu_set_cloexec ( ret ) ; \n if ( ( fds [ 1 ] = dup ( ret ) ) == -1 ) { \n close ( ret ) ; \n return -1 ; \n } \n qemu_set_cloexec ( fds [ 1 ] ) ; \n return 0 ; \n } \n if ( errno != ENOSYS ) { \n return -1 ; \n } \n #endif \n return qemu_pipe ( fds ) ; \n }", "idx": 16879}
{"project": "qemu", "commit_id": "77a5a0001bd9eaee9da7dc8f0b69702d56b0cc67", "target": 0, "func": "static int bdrv_qed_truncate ( BlockDriverState * bs , int64_t offset ) \n { \n return - ENOTSUP ; \n }", "idx": 16888}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER ( wsr_ibreakenable ) ( uint32_t v ) \n { \n uint32_t change = v ^ env -> sregs [ IBREAKENABLE ] ; \n unsigned i ; \n for ( i = 0 ; i < env -> config -> nibreak ; ++ i ) { \n if ( change & ( 1 << i ) ) { \n tb_invalidate_phys_page_range ( \n env -> sregs [ IBREAKA + i ] , env -> sregs [ IBREAKA + i ] + 1 , 0 ) ; \n } \n } \n env -> sregs [ IBREAKENABLE ] = v & ( ( 1 << env -> config -> nibreak ) - 1 ) ; \n }", "idx": 16890}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init ( ObjectClass * oc , void * data ) \n { \n OpenRISCCPUClass * occ = OPENRISC_CPU_CLASS ( oc ) ; \n CPUClass * cc = CPU_CLASS ( occ ) ; \n DeviceClass * dc = DEVICE_CLASS ( oc ) ; \n occ -> parent_realize = dc -> realize ; \n dc -> realize = openrisc_cpu_realizefn ; \n occ -> parent_reset = cc -> reset ; \n cc -> reset = openrisc_cpu_reset ; \n cc -> class_by_name = openrisc_cpu_class_by_name ; \n cc -> has_work = openrisc_cpu_has_work ; \n cc -> do_interrupt = openrisc_cpu_do_interrupt ; \n cc -> cpu_exec_interrupt = openrisc_cpu_exec_interrupt ; \n cc -> dump_state = openrisc_cpu_dump_state ; \n cc -> set_pc = openrisc_cpu_set_pc ; \n cc -> gdb_read_register = openrisc_cpu_gdb_read_register ; \n cc -> gdb_write_register = openrisc_cpu_gdb_write_register ; \n #ifdef CONFIG_USER_ONLY \n cc -> handle_mmu_fault = openrisc_cpu_handle_mmu_fault ; \n #else \n cc -> get_phys_page_debug = openrisc_cpu_get_phys_page_debug ; \n dc -> vmsd = & vmstate_openrisc_cpu ; \n #endif \n cc -> gdb_num_core_regs = 32 + 3 ; \n dc -> cannot_destroy_with_object_finalize_yet = true ; \n }", "idx": 16924}
{"project": "qemu", "commit_id": "d99598cc9929ad6993ad3d19d9b1ec1d891f0d7f", "target": 1, "func": "static void tcp_accept_incoming_migration ( void * opaque ) \n { \n struct sockaddr_in addr ; \n socklen_t addrlen = sizeof ( addr ) ; \n int s = ( intptr_t ) opaque ; \n QEMUFile * f ; \n int c ; \n do { \n c = qemu_accept ( s , ( struct sockaddr * ) & addr , & addrlen ) ; \n } while ( c == -1 && socket_error ( ) == EINTR ) ; \n qemu_set_fd_handler2 ( s , NULL , NULL , NULL , NULL ) ; \n closesocket ( s ) ; \n DPRINTF ( \" \\n \" ) ; \n if ( c == -1 ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto out ; \n } \n f = qemu_fopen_socket ( c , \" \" ) ; \n if ( f == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n goto out ; \n } \n process_incoming_migration ( f ) ; \n return ; \n out : \n closesocket ( c ) ; \n }", "idx": 16930}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static void quorum_copy_qiov ( QEMUIOVector * dest , QEMUIOVector * source ) \n { \n int i ; \n assert ( dest -> niov == source -> niov ) ; \n assert ( dest -> size == source -> size ) ; \n for ( i = 0 ; i < source -> niov ; i ++ ) { \n assert ( dest -> iov [ i ] . iov_len == source -> iov [ i ] . iov_len ) ; \n memcpy ( dest -> iov [ i ] . iov_base , \n source -> iov [ i ] . iov_base , \n source -> iov [ i ] . iov_len ) ; \n } \n }", "idx": 16933}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "int xen_be_send_notify ( struct XenDevice * xendev ) \n { \n return xc_evtchn_notify ( xendev -> evtchndev , xendev -> local_port ) ; \n }", "idx": 17004}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void slavio_led_mem_writes ( void * opaque , target_phys_addr_t addr , \n uint32_t val ) \n { \n MiscState * s = opaque ; \n uint32_t saddr ; \n saddr = addr & LED_MAXADDR ; \n MISC_DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr , \n val ) ; \n switch ( saddr ) { \n case 0 : \n s -> leds = val ; \n break ; \n default : \n break ; \n } \n }", "idx": 17021}
{"project": "qemu", "commit_id": "aff3f0f150769ec4f97c6e2cefe91c4a0377b548", "target": 0, "func": "static void xlnx_ep108_machine_init ( MachineClass * mc ) \n { \n mc -> desc = \" \" ; \n mc -> init = xlnx_ep108_init ; \n mc -> block_default_type = IF_IDE ; \n mc -> units_per_default_bus = 1 ; \n mc -> ignore_memory_transaction_failures = true ; \n }", "idx": 17043}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_logicali ( TCGContext * s , AArch64Insn insn , TCGType ext , \n TCGReg rd , TCGReg rn , uint64_t limm ) \n { \n unsigned h , l , r , c ; \n assert ( is_limm ( limm ) ) ; \n h = clz64 ( limm ) ; \n l = ctz64 ( limm ) ; \n if ( l == 0 ) { \n r = 0 ; \n c = ctz64 ( ~ limm ) - 1 ; \n if ( h == 0 ) { \n r = clz64 ( ~ limm ) ; \n c += r ; \n } \n } else { \n r = 64 - l ; \n c = r - h - 1 ; \n } \n if ( ext == TCG_TYPE_I32 ) { \n r &= 31 ; \n c &= 31 ; \n } \n tcg_out_insn_3404 ( s , insn , ext , rd , rn , ext , r , c ) ; \n }", "idx": 17048}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor * visitor_input_test_init_raw ( TestInputVisitorData * data , \n const char * json_string ) \n { \n return visitor_input_test_init_internal ( data , json_string , NULL ) ; \n }", "idx": 17085}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version ( Monitor * mon ) \n { \n monitor_printf ( mon , \" \\n \" , QEMU_VERSION ) ; \n }", "idx": 17092}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init ( QCryptoIVGen * ivgen , \n const uint8_t * key , size_t nkey , \n Error * * errp ) \n { \n uint8_t * salt ; \n size_t nhash ; \n size_t nsalt ; \n QCryptoIVGenESSIV * essiv = g_new0 ( QCryptoIVGenESSIV , 1 ) ; \n nsalt = qcrypto_cipher_get_key_len ( ivgen -> cipher ) ; \n nhash = qcrypto_hash_digest_len ( ivgen -> hash ) ; \n salt = g_new0 ( uint8_t , MAX ( nhash , nsalt ) ) ; \n if ( qcrypto_hash_bytes ( ivgen -> hash , ( const gchar * ) key , nkey , \n & salt , & nhash , \n errp ) < 0 ) { \n g_free ( essiv ) ; \n return -1 ; \n } \n essiv -> cipher = qcrypto_cipher_new ( ivgen -> cipher , \n QCRYPTO_CIPHER_MODE_ECB , \n salt , MIN ( nhash , nsalt ) , \n errp ) ; \n if ( ! essiv -> cipher ) { \n g_free ( essiv ) ; \n return -1 ; \n } \n ivgen -> private = essiv ; \n return 0 ; \n }", "idx": 17101}
{"project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "target": 0, "func": "static void handle_ti ( ESPState * s ) \n { \n uint32_t dmalen , minlen ; \n if ( s -> dma && ! s -> dma_enabled ) { \n s -> dma_cb = handle_ti ; \n return ; \n } \n dmalen = s -> rregs [ ESP_TCLO ] ; \n dmalen |= s -> rregs [ ESP_TCMID ] << 8 ; \n dmalen |= s -> rregs [ ESP_TCHI ] << 16 ; \n if ( dmalen == 0 ) { \n dmalen = 0x10000 ; \n } \n s -> dma_counter = dmalen ; \n if ( s -> do_cmd ) \n minlen = ( dmalen < 32 ) ? dmalen : 32 ; \n else if ( s -> ti_size < 0 ) \n minlen = ( dmalen < - s -> ti_size ) ? dmalen : - s -> ti_size ; \n else \n minlen = ( dmalen < s -> ti_size ) ? dmalen : s -> ti_size ; \n trace_esp_handle_ti ( minlen ) ; \n if ( s -> dma ) { \n s -> dma_left = minlen ; \n s -> rregs [ ESP_RSTAT ] &= ~ STAT_TC ; \n esp_do_dma ( s ) ; \n } \n if ( s -> do_cmd ) { \n trace_esp_handle_ti_cmd ( s -> cmdlen ) ; \n s -> ti_size = 0 ; \n s -> cmdlen = 0 ; \n s -> do_cmd = 0 ; \n do_cmd ( s , s -> cmdbuf ) ; \n } \n }", "idx": 17141}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void lsi53c895a_register_devices ( void ) \n { \n type_register_static ( & lsi_info ) ; \n type_register_static_alias ( & lsi_info , \" \" ) ; \n }", "idx": 17152}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void receive_from_chr_layer ( SCLPConsole * scon , const uint8_t * buf , \n int size ) \n { \n assert ( size <= SIZE_BUFFER_VT220 - scon -> iov_data_len ) ; \n memcpy ( & scon -> iov [ scon -> iov_bs ] , buf , size ) ; \n scon -> iov_data_len += size ; \n scon -> iov_sclp_rest += size ; \n scon -> iov_bs += size ; \n scon -> event . event_pending = true ; \n }", "idx": 17172}
{"project": "qemu", "commit_id": "d3aea641a4002e0abe940c65d318ef38eda245df", "target": 1, "func": "static void usbredir_do_attach ( void * opaque ) \n { \n USBRedirDevice * dev = opaque ; \n if ( ( dev -> dev . port -> speedmask & USB_SPEED_MASK_SUPER ) && ! ( \n usb_redir_cap_ep_info_max_packet_size ) && \n usb_redir_cap_64bits_ids ) ) ) { \n ERROR ( \" \\n \" ) ; \n usbredir_reject_device ( dev ) ; \n return ; \n } \n if ( usb_device_attach ( & dev -> dev ) != 0 ) { \n WARNING ( \" \\n \" ) ; \n usbredir_reject_device ( dev ) ; \n } \n }", "idx": 17199}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init ( MachineState * machine ) \n { \n static const LxBoardDesc kc705_board = { \n . flash_base = 0xf0000000 , \n . flash_size = 0x08000000 , \n . flash_boot_base = 0x06000000 , \n . flash_sector_size = 0x20000 , \n . sram_size = 0x2000000 , \n } ; \n lx_init ( & kc705_board , machine ) ; \n }", "idx": 17240}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void virtqueue_unmap_sg ( VirtQueue * vq , const VirtQueueElement * elem , \n unsigned int len ) \n { \n unsigned int offset ; \n int i ; \n offset = 0 ; \n for ( i = 0 ; i < elem -> in_num ; i ++ ) { \n size_t size = MIN ( len - offset , elem -> in_sg [ i ] . iov_len ) ; \n cpu_physical_memory_unmap ( elem -> in_sg [ i ] . iov_base , \n elem -> in_sg [ i ] . iov_len , \n 1 , size ) ; \n offset += size ; \n } \n for ( i = 0 ; i < elem -> out_num ; i ++ ) \n cpu_physical_memory_unmap ( elem -> out_sg [ i ] . iov_base , \n elem -> out_sg [ i ] . iov_len , \n 0 , elem -> out_sg [ i ] . iov_len ) ; \n }", "idx": 17242}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare ( BDRVReopenState * state , \n BlockReopenQueue * queue , Error * * errp ) \n { \n BDRVVmdkState * s ; \n int ret = -1 ; \n int i ; \n VmdkExtent * e ; \n assert ( state != NULL ) ; \n assert ( state -> bs != NULL ) ; \n if ( queue == NULL ) { \n error_setg ( errp , \" \" ) ; \n goto exit ; \n } \n s = state -> bs -> opaque ; \n assert ( s != NULL ) ; \n for ( i = 0 ; i < s -> num_extents ; i ++ ) { \n e = & s -> extents [ i ] ; \n if ( e -> file != state -> bs -> file ) { \n bdrv_reopen_queue ( queue , e -> file , state -> flags ) ; \n } \n } \n ret = 0 ; \n exit : \n return ret ; \n }", "idx": 17246}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label ( TCGContext * s , int label_index ) \n { \n TCGLabel * l = & s -> labels [ label_index ] ; \n if ( ! l -> has_value ) { \n tcg_out_reloc ( s , s -> code_ptr , R_AARCH64_JUMP26 , label_index , 0 ) ; \n tcg_out_goto_noaddr ( s ) ; \n } else { \n tcg_out_goto ( s , l -> u . value_ptr ) ; \n } \n }", "idx": 17258}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map ( PCIDevice * pci_dev , int region_num , \n uint32_t addr , uint32_t size , int type ) \n { \n PCIAC97LinkState * d = ( PCIAC97LinkState * ) pci_dev ; \n AC97LinkState * s = & d -> ac97 ; \n if ( ! region_num ) { \n s -> base [ 0 ] = addr ; \n register_ioport_read ( addr , 256 * 1 , 1 , nam_readb , d ) ; \n register_ioport_read ( addr , 256 * 2 , 2 , nam_readw , d ) ; \n register_ioport_read ( addr , 256 * 4 , 4 , nam_readl , d ) ; \n register_ioport_write ( addr , 256 * 1 , 1 , nam_writeb , d ) ; \n register_ioport_write ( addr , 256 * 2 , 2 , nam_writew , d ) ; \n register_ioport_write ( addr , 256 * 4 , 4 , nam_writel , d ) ; \n } \n else { \n s -> base [ 1 ] = addr ; \n register_ioport_read ( addr , 64 * 1 , 1 , nabm_readb , d ) ; \n register_ioport_read ( addr , 64 * 2 , 2 , nabm_readw , d ) ; \n register_ioport_read ( addr , 64 * 4 , 4 , nabm_readl , d ) ; \n register_ioport_write ( addr , 64 * 1 , 1 , nabm_writeb , d ) ; \n register_ioport_write ( addr , 64 * 2 , 2 , nabm_writew , d ) ; \n register_ioport_write ( addr , 64 * 4 , 4 , nabm_writel , d ) ; \n } \n }", "idx": 17266}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister ( DeviceState * dev , const VMStateDescription * vmsd , \n void * opaque ) \n { \n SaveStateEntry * se , * new_se ; \n QTAILQ_FOREACH_SAFE ( se , & savevm_state . handlers , entry , new_se )  { \n if ( se -> vmsd == vmsd && se -> opaque == opaque ) { \n QTAILQ_REMOVE ( & savevm_state . handlers , se , entry ) ; \n if ( se -> compat ) { \n g_free ( se -> compat ) ; \n } \n g_free ( se ) ; \n } \n } \n }", "idx": 17267}
{"project": "qemu", "commit_id": "47d3df2387ed6927732584ffa4159c26d9f4dee8", "target": 0, "func": "static int xenfb_send_motion ( struct XenInput * xenfb , \n int rel_x , int rel_y , int rel_z ) \n { \n union xenkbd_in_event event ; \n memset ( & event , 0 , XENKBD_IN_EVENT_SIZE ) ; \n event . type = XENKBD_TYPE_MOTION ; \n event . motion . rel_x = rel_x ; \n event . motion . rel_y = rel_y ; \n #if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207  \n  \n  event . motion . rel_z = rel_z ; \n #endif \n return xenfb_kbd_event ( xenfb , & event ) ; \n }", "idx": 17274}
{"project": "qemu", "commit_id": "eaf136f9a21e02a2f55346e44d2d88df37b2cde3", "target": 0, "func": "static int slirp_socket_load ( QEMUFile * f , struct socket * so ) \n { \n if ( tcp_attach ( so ) < 0 ) \n return - ENOMEM ; \n so -> so_urgc = qemu_get_be32 ( f ) ; \n so -> so_ffamily = qemu_get_be16 ( f ) ; \n switch ( so -> so_ffamily ) { \n case AF_INET : \n so -> so_faddr . s_addr = qemu_get_be32 ( f ) ; \n so -> so_fport = qemu_get_be16 ( f ) ; \n break ; \n default : \n error_report ( \n \" \\n \" ) ; \n } \n so -> so_lfamily = qemu_get_be16 ( f ) ; \n switch ( so -> so_lfamily ) { \n case AF_INET : \n so -> so_laddr . s_addr = qemu_get_be32 ( f ) ; \n so -> so_lport = qemu_get_be16 ( f ) ; \n break ; \n default : \n error_report ( \n \" \\n \" ) ; \n } \n so -> so_iptos = qemu_get_byte ( f ) ; \n so -> so_emu = qemu_get_byte ( f ) ; \n so -> so_type = qemu_get_byte ( f ) ; \n so -> so_state = qemu_get_be32 ( f ) ; \n if ( slirp_sbuf_load ( f , & so -> so_rcv ) < 0 ) \n return - ENOMEM ; \n if ( slirp_sbuf_load ( f , & so -> so_snd ) < 0 ) \n return - ENOMEM ; \n slirp_tcp_load ( f , so -> so_tcpcb ) ; \n return 0 ; \n }", "idx": 17301}
{"project": "qemu", "commit_id": "22f2e344748370b2e13888ba1057ebea2579970c", "target": 0, "func": "static int qdev_print_devinfo ( DeviceInfo * info , char * dest , int len ) \n { \n int pos = 0 ; \n pos += snprintf ( dest + pos , len - pos , \" \\\" \\\" \" , \n info -> name , info -> bus_info -> name ) ; \n if ( info -> alias ) \n pos += snprintf ( dest + pos , len - pos , \" \\\" \\\" \" , info -> alias ) ; \n if ( info -> desc ) \n pos += snprintf ( dest + pos , len - pos , \" \\\" \\\" \" , info -> desc ) ; \n if ( info -> no_user ) \n pos += snprintf ( dest + pos , len - pos , \" \" ) ; \n return pos ; \n }", "idx": 17307}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_l1_entry ( BlockDriverState * bs , int l1_index ) \n { \n BDRVQcowState * s = bs -> opaque ; \n uint64_t buf [ L1_ENTRIES_PER_SECTOR ] ; \n int l1_start_index ; \n int i , ret ; \n l1_start_index = l1_index & ~ ( L1_ENTRIES_PER_SECTOR - 1 ) ; \n for ( i = 0 ; i < L1_ENTRIES_PER_SECTOR ; i ++ ) { \n buf [ i ] = cpu_to_be64 ( s -> l1_table [ l1_start_index + i ] ) ; \n } \n BLKDBG_EVENT ( bs -> file , BLKDBG_L1_UPDATE ) ; \n ret = bdrv_pwrite ( bs -> file , s -> l1_table_offset + 8 * l1_start_index , \n buf , sizeof ( buf ) ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return 0 ; \n }", "idx": 17328}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read ( BlockDriverState * bs , int64_t sector_num , \n uint8_t * buf , int nb_sectors ) \n { \n BlockDriver * drv = bs -> drv ; \n if ( ! drv ) \n return - ENOMEDIUM ; \n if ( drv -> bdrv_pread ) { \n int ret , len ; \n len = nb_sectors * 512 ; \n ret = drv -> bdrv_pread ( bs , sector_num * 512 , buf , len ) ; \n if ( ret < 0 ) \n return ret ; \n else if ( ret != len ) \n return - EINVAL ; \n else { \n bs -> rd_bytes += ( unsigned ) len ; \n bs -> rd_ops ++ ; \n return 0 ; \n } \n } else { \n return drv -> bdrv_read ( bs , sector_num , buf , nb_sectors ) ; \n } \n }", "idx": 17337}
{"project": "qemu", "commit_id": "fb506e701e9bafa3e0685747c1c98962c52d1962", "target": 1, "func": "static bool vtd_decide_config ( IntelIOMMUState * s , Error * * errp ) \n { \n X86IOMMUState * x86_iommu = X86_IOMMU_DEVICE ( s ) ; \n if ( x86_iommu -> intr_supported && kvm_irqchip_in_kernel ( ) && \n ! kvm_irqchip_is_split ( ) ) { \n error_setg ( errp , \" \" \n \" \" ) ; \n return false ; \n } \n if ( s -> intr_eim == ON_OFF_AUTO_ON && ! x86_iommu -> intr_supported ) { \n error_setg ( errp , \" \" ) ; \n return false ; \n } \n if ( s -> intr_eim == ON_OFF_AUTO_AUTO ) { \n s -> intr_eim = x86_iommu -> intr_supported ? \n ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF ; \n } \n return true ; \n }", "idx": 17362}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int no_init_in ( HWVoiceIn * hw , struct audsettings * as ) \n { \n audio_pcm_init_info ( & hw -> info , as ) ; \n hw -> samples = 1024 ; \n return 0 ; \n }", "idx": 17370}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete ( QEMUFile * f , void * opaque ) \n { \n int ret ; \n DPRINTF ( \" \\n \" , \n block_mig_state . submitted , block_mig_state . transferred ) ; \n ret = flush_blks ( f ) ; \n if ( ret ) { \n return ret ; \n } \n blk_mig_reset_dirty_cursor ( ) ; \n blk_mig_lock ( ) ; \n assert ( block_mig_state . submitted == 0 ) ; \n blk_mig_unlock ( ) ; \n do { \n ret = blk_mig_save_dirty_block ( f , 0 ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n } while ( ret == 0 ) ; \n qemu_put_be64 ( f , ( 100 << BDRV_SECTOR_BITS ) | BLK_MIG_FLAG_PROGRESS ) ; \n DPRINTF ( \" \\n \" ) ; \n qemu_put_be64 ( f , BLK_MIG_FLAG_EOS ) ; \n blk_mig_cleanup ( ) ; \n return 0 ; \n }", "idx": 17411}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread ( QPCIDevice * dev , void * data , void * buf , size_t len ) \n { \n uintptr_t addr = ( uintptr_t ) data ; \n g_assert ( addr >= QPCI_PIO_LIMIT ) ; \n dev -> bus -> memread ( dev -> bus , addr , buf , len ) ; \n }", "idx": 17449}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush ( void ) \n { \n AioHandler * node ; \n int ret ; \n do { \n ret = 0 ; \n qemu_aio_wait ( ) ; \n LIST_FOREACH ( node , & aio_handlers , node )  { \n ret |= node -> io_flush ( node -> opaque ) ; \n } \n } while ( ret > 0 ) ; \n }", "idx": 17482}
{"project": "qemu", "commit_id": "dbb7405d8caad0814ceddd568cb49f163a847561", "target": 1, "func": "static int xen_platform_initfn ( PCIDevice * dev ) \n { \n PCIXenPlatformState * d = XEN_PLATFORM ( dev ) ; \n uint8_t * pci_conf ; \n pci_conf = dev -> config ; \n pci_set_word ( pci_conf + PCI_COMMAND , PCI_COMMAND_IO | PCI_COMMAND_MEMORY ) ; \n pci_config_set_prog_interface ( pci_conf , 0 ) ; \n pci_conf [ PCI_INTERRUPT_PIN ] = 1 ; \n platform_ioport_bar_setup ( d ) ; \n pci_register_bar ( dev , 0 , PCI_BASE_ADDRESS_SPACE_IO , & d -> bar ) ; \n platform_mmio_setup ( d ) ; \n pci_register_bar ( dev , 1 , PCI_BASE_ADDRESS_MEM_PREFETCH , \n & d -> mmio_bar ) ; \n platform_fixed_ioport_init ( d ) ; \n return 0 ; \n }", "idx": 17518}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn c1_fn ( void * opaque ) \n { \n Coroutine * c2 = opaque ; \n qemu_coroutine_enter ( c2 , NULL ) ; \n }", "idx": 17548}
{"project": "qemu", "commit_id": "9217e26f43df4aab7deaea35b21caacc1f1f854b", "target": 1, "func": "static int write_target_commit ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buffer , int nb_sectors ) { \n BDRVVVFATState * s = bs -> opaque ; \n return try_commit ( s ) ; \n }", "idx": 17553}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport ( SDHCIState * s , uint32_t value , unsigned size ) \n { \n unsigned i ; \n if ( ! ( s -> prnsts & SDHC_SPACE_AVAILABLE ) ) { \n ERRPRINT ( \" \\n \" ) ; \n return ; \n } \n for ( i = 0 ; i < size ; i ++ ) { \n s -> fifo_buffer [ s -> data_count ] = value & 0xFF ; \n s -> data_count ++ ; \n value >>= 8 ; \n if ( s -> data_count >= ( s -> blksize & 0x0fff ) ) { \n DPRINT_L2 ( \" \\n \" , \n s -> data_count ) ; \n s -> data_count = 0 ; \n s -> prnsts &= ~ SDHC_SPACE_AVAILABLE ; \n if ( s -> prnsts & SDHC_DOING_WRITE ) { \n SDHCI_GET_CLASS ( s ) -> write_block_to_card ( s ) ; \n } \n } \n } \n }", "idx": 17576}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n struct omap_mpu_state_s * s = ( struct omap_mpu_state_s * ) opaque ; \n uint16_t ret ; \n if ( size != 2 ) { \n return omap_badwidth_read16 ( opaque , addr ) ; \n } \n switch ( addr ) { \n case 0x14 : \n ret = s -> ulpd_pm_regs [ addr >> 2 ] ; \n s -> ulpd_pm_regs [ addr >> 2 ] = 0 ; \n qemu_irq_lower ( s -> irq [ 1 ] [ OMAP_INT_GAUGE_32K ] ) ; \n return ret ; \n case 0x18 : \n case 0x1c : \n case 0x20 : \n case 0x28 : \n case 0x2c : \n OMAP_BAD_REG ( addr ) ; \n case 0x00 : \n case 0x04 : \n case 0x08 : \n case 0x0c : \n case 0x10 : \n case 0x24 : \n case 0x30 : \n case 0x34 : \n case 0x38 : \n case 0x3c : \n case 0x40 : \n case 0x48 : \n case 0x4c : \n case 0x50 : \n return s -> ulpd_pm_regs [ addr >> 2 ] ; \n } \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 17581}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init ( SysBusDevice * dev ) \n { \n MilkymistMemcardState * s = MILKYMIST_MEMCARD ( dev ) ; \n DriveInfo * dinfo ; \n BlockDriverState * bs ; \n dinfo = drive_get_next ( IF_SD ) ; \n bs = dinfo ? blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) : NULL ; \n s -> card = sd_init ( bs , false ) ; \n if ( s -> card == NULL ) { \n return -1 ; \n } \n s -> enabled = bs && bdrv_is_inserted ( bs ) ; \n memory_region_init_io ( & s -> regs_region , OBJECT ( s ) , & memcard_mmio_ops , s , \n \" \" , R_MAX * 4 ) ; \n sysbus_init_mmio ( dev , & s -> regs_region ) ; \n return 0 ; \n }", "idx": 17587}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal ( TestOutputVisitorData * data , \n bool human ) \n { \n data -> human = human ; \n data -> sov = string_output_visitor_new ( human ) ; \n g_assert ( data -> sov ) ; \n data -> ov = string_output_get_visitor ( data -> sov ) ; \n g_assert ( data -> ov ) ; \n }", "idx": 17596}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_src_addr ( const struct iovec *  pkt , int pkt_frags , \n size_t dsthdr_offset , \n struct  ip6_ext_hdr * ext_hdr , \n struct  in6_address * src_addr ) \n { \n size_t bytes_left = ( ext_hdr -> ip6r_len + 1 ) * 8 - sizeof ( * ext_hdr ) ; \n struct ip6_option_hdr opthdr ; \n size_t opt_offset = dsthdr_offset + sizeof ( * ext_hdr ) ; \n while ( bytes_left > sizeof ( opthdr ) ) { \n size_t input_size = iov_size ( pkt , pkt_frags ) ; \n size_t bytes_read , optlen ; \n if ( input_size < opt_offset ) { \n return false ; \n } \n bytes_read = iov_to_buf ( pkt , pkt_frags , opt_offset , \n & opthdr , sizeof ( opthdr ) ) ; \n if ( bytes_read != sizeof ( opthdr ) ) { \n return false ; \n } \n optlen = ( opthdr . type == IP6_OPT_PAD1 ) ? 1 \n : ( opthdr . len + sizeof ( opthdr ) ) ; \n if ( optlen > bytes_left ) { \n return false ; \n } \n if ( opthdr . type == IP6_OPT_HOME ) { \n size_t input_size = iov_size ( pkt , pkt_frags ) ; \n if ( input_size < opt_offset + sizeof ( opthdr ) ) { \n return false ; \n } \n bytes_read = iov_to_buf ( pkt , pkt_frags , \n opt_offset + sizeof ( opthdr ) , \n src_addr , sizeof ( * src_addr ) ) ; \n return bytes_read == sizeof ( src_addr ) ; \n } \n opt_offset += optlen ; \n bytes_left -= optlen ; \n } \n return false ; \n }", "idx": 17611}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static void inc_refcounts ( BlockDriverState * bs , \n BdrvCheckResult * res , \n uint16_t * refcount_table , \n int refcount_table_size , \n int64_t offset , int64_t size ) \n { \n BDRVQcowState * s = bs -> opaque ; \n uint64_t start , last , cluster_offset , k ; \n if ( size <= 0 ) \n return ; \n start = start_of_cluster ( s , offset ) ; \n last = start_of_cluster ( s , offset + size - 1 ) ; \n for ( cluster_offset = start ; cluster_offset <= last ; \n cluster_offset += s -> cluster_size ) { \n k = cluster_offset >> s -> cluster_bits ; \n if ( k >= refcount_table_size ) { \n fprintf ( stderr , \" \" PRIx64 \" \" \n \" \\n \" , \n cluster_offset ) ; \n res -> check_errors ++ ; \n } else { \n if ( ++ refcount_table [ k ] == 0 ) { \n fprintf ( stderr , \" \" PRIx64 \n \" \\n \" , cluster_offset ) ; \n res -> corruptions ++ ; \n } \n } \n } \n }", "idx": 17627}
{"project": "qemu", "commit_id": "733f0b02c80c3a7106d8327a83948ab68db10ea7", "target": 0, "func": "void stw_phys ( target_phys_addr_t addr , uint32_t val ) \n { \n uint16_t v = tswap16 ( val ) ; \n cpu_physical_memory_write ( addr , ( const uint8_t * ) & v , 2 ) ; \n }", "idx": 17641}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup ( Slirp * slirp ) \n { \n TAILQ_REMOVE ( & slirp_instances , slirp , entry ) ; \n unregister_savevm ( \" \" , slirp ) ; \n qemu_free ( slirp -> tftp_prefix ) ; \n qemu_free ( slirp -> bootp_filename ) ; \n qemu_free ( slirp ) ; \n }", "idx": 17664}
{"project": "qemu", "commit_id": "eda470e41a753070e057380a9a71e2ad7347f667", "target": 0, "func": "void scsi_req_abort ( SCSIRequest * req , int status ) \n { \n if ( ! req -> enqueued ) { \n return ; \n } \n scsi_req_ref ( req ) ; \n scsi_req_dequeue ( req ) ; \n req -> io_canceled = true ; \n if ( req -> ops -> cancel_io ) { \n req -> ops -> cancel_io ( req ) ; \n } \n scsi_req_complete ( req , status ) ; \n scsi_req_unref ( req ) ; \n }", "idx": 17670}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool pc_machine_get_nvdimm ( Object * obj , Error * * errp ) \n { \n PCMachineState * pcms = PC_MACHINE ( obj ) ; \n return pcms -> nvdimm ; \n }", "idx": 17700}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_header ( GArray * linker , GArray * table_data , \n AcpiTableHeader * h , const char * sig , int len , uint8_t rev , \n const char * oem_table_id )  \n { \n memcpy ( & h -> signature , sig , 4 ) ; \n h -> length = cpu_to_le32 ( len ) ; \n h -> revision = rev ; \n memcpy ( h -> oem_id , ACPI_BUILD_APPNAME6 , 6 ) ; \n if ( oem_table_id ) { \n strncpy ( ( char * ) h -> oem_table_id , oem_table_id , sizeof ( h -> oem_table_id ) ) ; \n } else { \n memcpy ( h -> oem_table_id , ACPI_BUILD_APPNAME4 , 4 ) ; \n memcpy ( h -> oem_table_id + 4 , sig , 4 ) ; \n } \n h -> oem_revision = cpu_to_le32 ( 1 ) ; \n memcpy ( h -> asl_compiler_id , ACPI_BUILD_APPNAME4 , 4 ) ; \n h -> asl_compiler_revision = cpu_to_le32 ( 1 ) ; \n h -> checksum = 0 ; \n bios_linker_loader_add_checksum ( linker , ACPI_BUILD_TABLE_FILE , \n table_data -> data , h , len , & h -> checksum ) ; \n }", "idx": 17710}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "static void vnc_dpy_copy ( DisplayState * ds , int src_x , int src_y , int dst_x , int dst_y , int w , int h ) \n { \n VncDisplay * vd = ds -> opaque ; \n VncState * vs = vd -> clients ; \n while ( vs != NULL ) { \n if ( vnc_has_feature ( vs , VNC_FEATURE_COPYRECT ) ) \n vnc_copy ( vs , src_x , src_y , dst_x , dst_y , w , h ) ; \n else \n vnc_update ( vs , dst_x , dst_y , w , h ) ; \n vs = vs -> next ; \n } \n }", "idx": 17883}
{"project": "qemu", "commit_id": "da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56", "target": 1, "func": "static int emulated_exitfn ( CCIDCardState * base ) \n { \n EmulatedState * card = DO_UPCAST ( EmulatedState , base , base ) ; \n VEvent * vevent = vevent_new ( VEVENT_LAST , NULL , NULL ) ; \n vevent_queue_vevent ( vevent ) ; \n qemu_mutex_lock ( & card -> apdu_thread_quit_mutex ) ; \n card -> quit_apdu_thread = 1 ; \n qemu_cond_signal ( & card -> handle_apdu_cond ) ; \n qemu_cond_wait ( & card -> apdu_thread_quit_cond , \n & card -> apdu_thread_quit_mutex ) ; \n qemu_cond_destroy ( & card -> handle_apdu_cond ) ; \n qemu_cond_destroy ( & card -> apdu_thread_quit_cond ) ; \n qemu_mutex_destroy ( & card -> apdu_thread_quit_mutex ) ; \n qemu_mutex_destroy ( & card -> handle_apdu_mutex ) ; \n qemu_mutex_destroy ( & card -> vreader_mutex ) ; \n qemu_mutex_destroy ( & card -> event_list_mutex ) ; \n return 0 ; \n }", "idx": 17885}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_enable ( QVirtioPCIDevice * d ) \n { \n qpci_device_enable ( d -> pdev ) ; \n d -> addr = qpci_iomap ( d -> pdev , 0 , NULL ) ; \n g_assert ( d -> addr != NULL ) ; \n }", "idx": 17909}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState * qemu_chr_open_pipe ( const char * id , \n ChardevBackend * backend , \n ChardevReturn * ret , \n Error * * errp ) \n { \n ChardevHostdev * opts = backend -> u . pipe ; \n const char * filename = opts -> device ; \n CharDriverState * chr ; \n WinCharState * s ; \n chr = qemu_chr_alloc ( ) ; \n s = g_new0 ( WinCharState , 1 ) ; \n chr -> opaque = s ; \n chr -> chr_write = win_chr_write ; \n chr -> chr_close = win_chr_close ; \n if ( win_chr_pipe_init ( chr , filename , errp ) < 0 ) { \n g_free ( s ) ; \n g_free ( chr ) ; \n return NULL ; \n } \n return chr ; \n }", "idx": 17972}
{"project": "qemu", "commit_id": "7bbcb0afe715c36545bbbd872441c473927c1a4e", "target": 0, "func": "uint32_t HELPER ( clz ) ( uint32_t x ) \n { \n int count ; \n for ( count = 32 ; x ; count -- ) \n x >>= 1 ; \n return count ; \n }", "idx": 17981}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected ( int shift ) \n { \n helper_ret_protected ( shift , 1 , 0 ) ; \n }", "idx": 18020}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_schedule ( QEMUBH * bh ) \n { \n AioContext * ctx ; \n ctx = bh -> ctx ; \n bh -> idle = 0 ; \n if ( atomic_xchg ( & bh -> scheduled , 1 ) == 0 ) { \n aio_notify ( ctx ) ; \n } \n }", "idx": 18038}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static SpiceTimer * timer_add ( SpiceTimerFunc func , void * opaque ) \n { \n SpiceTimer * timer ; \n timer = qemu_mallocz ( sizeof ( * timer ) ) ; \n timer -> timer = qemu_new_timer ( rt_clock , func , opaque ) ; \n QTAILQ_INSERT_TAIL ( & timers , timer , next ) ; \n return timer ; \n }", "idx": 18044}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use ( VirtIOPCIProxy * proxy , \n unsigned int queue_no , \n unsigned int vector , \n MSIMessage msg ) \n { \n VirtQueue * vq = virtio_get_queue ( proxy -> vdev , queue_no ) ; \n EventNotifier * n = virtio_queue_get_guest_notifier ( vq ) ; \n VirtIOIRQFD * irqfd = & proxy -> vector_irqfd [ vector ] ; \n int ret ; \n if ( irqfd -> users == 0 ) { \n ret = kvm_irqchip_add_msi_route ( kvm_state , msg ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n irqfd -> virq = ret ; \n } \n irqfd -> users ++ ; \n ret = kvm_irqchip_add_irq_notifier ( kvm_state , n , irqfd -> virq ) ; \n if ( ret < 0 ) { \n if ( -- irqfd -> users == 0 ) { \n kvm_irqchip_release_virq ( kvm_state , irqfd -> virq ) ; \n } \n return ret ; \n } \n virtio_queue_set_guest_notifier_fd_handler ( vq , true , true ) ; \n return 0 ; \n }", "idx": 18067}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_fixed_disk ( int fd , uint8_t * buf , int64_t total_size ) \n { \n int ret = - EIO ; \n total_size += 512 ; \n if ( ftruncate ( fd , total_size ) != 0 ) { \n ret = - errno ; \n goto fail ; \n } \n if ( lseek ( fd , -512 , SEEK_END ) < 0 ) { \n goto fail ; \n } \n if ( write ( fd , buf , HEADER_SIZE ) != HEADER_SIZE ) { \n goto fail ; \n } \n ret = 0 ; \n fail : \n return ret ; \n }", "idx": 18138}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r ( FsContext * ctx , V9fsFidOpenState * fs , \n struct dirent * entry , \n struct dirent * * result ) \n { \n return readdir_r ( fs -> dir , entry , result ) ; \n }", "idx": 18142}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mmio_ide_status_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n MMIOState * s = opaque ; \n return ide_status_read ( & s -> bus , 0 ) ; \n }", "idx": 18159}
{"project": "qemu", "commit_id": "e37e6ee6e100ebc355b4a48ae9a7802b38b8dac0", "target": 0, "func": "void tlb_flush_page ( CPUState * env , target_ulong addr ) \n { \n int i ; \n #if defined ( DEBUG_TLB )  \n  \n  printf ( \" \" TARGET_FMT_lx \" \\n \" , addr ) ; \n #endif \n env -> current_tb = NULL ; \n addr &= TARGET_PAGE_MASK ; \n i = ( addr >> TARGET_PAGE_BITS ) & ( CPU_TLB_SIZE - 1 ) ; \n tlb_flush_entry ( & env -> tlb_table [ 0 ] [ i ] , addr ) ; \n tlb_flush_entry ( & env -> tlb_table [ 1 ] [ i ] , addr ) ; \n #if ( NB_MMU_MODES >= 3 )  \n  \n  tlb_flush_entry ( & env -> tlb_table [ 2 ] [ i ] , addr ) ; \n #if ( NB_MMU_MODES == 4 )  \n  \n  tlb_flush_entry ( & env -> tlb_table [ 3 ] [ i ] , addr ) ; \n #endif \n #endif \n tlb_flush_jmp_cache ( env , addr ) ; \n #ifdef USE_KQEMU \n if ( env -> kqemu_enabled ) { \n kqemu_flush_page ( env , addr ) ; \n } \n #endif \n }", "idx": 18161}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height ( VncState * vs , int y , int last_x , int x ) \n { \n int h ; \n for ( h = 1 ; h < ( vs -> serverds . height - y ) ; h ++ ) { \n int tmp_x ; \n if ( ! vnc_get_bit ( vs -> dirty_row [ y + h ] , last_x ) ) \n break ; \n for ( tmp_x = last_x ; tmp_x < x ; tmp_x ++ ) \n vnc_clear_bit ( vs -> dirty_row [ y + h ] , tmp_x ) ; \n } \n return h ; \n }", "idx": 18194}
{"project": "qemu", "commit_id": "a0067da1577e3eb0c60758384282568f4b2328fe", "target": 1, "func": "static void test_dispatch_cmd_failure ( void ) \n { \n QDict * req = qdict_new ( ) ; \n QObject * resp ; \n qdict_put_obj ( req , \" \" , QOBJECT ( qstring_from_str ( \" \" ) ) ) ; \n resp = qmp_dispatch ( QOBJECT ( req ) ) ; \n assert ( resp != NULL ) ; \n assert ( qdict_haskey ( qobject_to_qdict ( resp ) , \" \" ) ) ; \n qobject_decref ( resp ) ; \n QDECREF ( req ) ; \n req = qdict_new ( ) ; \n qdict_put ( args , \" \" , qint_from_int ( 66 ) ) ; \n qdict_put ( req , \" \" , args ) ; \n qdict_put_obj ( req , \" \" , QOBJECT ( qstring_from_str ( \" \" ) ) ) ; \n resp = qmp_dispatch ( QOBJECT ( req ) ) ; \n assert ( resp != NULL ) ; \n assert ( qdict_haskey ( qobject_to_qdict ( resp ) , \" \" ) ) ; \n qobject_decref ( resp ) ; \n QDECREF ( req ) ; \n }", "idx": 18195}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64 ( QEMUFile * f , void * pv , size_t size ) \n { \n uint64_t * v = pv ; \n qemu_put_be64s ( f , v ) ; \n }", "idx": 18211}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON * qjson_new ( void ) \n { \n QJSON * json = QJSON ( object_new ( TYPE_QJSON ) ) ; \n return json ; \n }", "idx": 18220}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_record_dump ( void ) \n { \n PCRecord * * pr , * r ; \n int i , h ; \n FILE * f ; \n int64_t total , sum ; \n pr = malloc ( sizeof ( PCRecord * ) * nb_pc_records ) ; \n i = 0 ; \n total = 0 ; \n for ( h = 0 ; h < PC_REC_HASH_SIZE ; h ++ ) { \n for ( r = pc_rec_hash [ h ] ; r != NULL ; r = r -> next ) { \n pr [ i ++ ] = r ; \n total += r -> count ; \n } \n } \n qsort ( pr , nb_pc_records , sizeof ( PCRecord * ) , pc_rec_cmp ) ; \n f = fopen ( \" \" , \" \" ) ; \n if ( ! f ) { \n perror ( \" \" ) ; \n exit ( 1 ) ; \n } \n fprintf ( f , \" \" PRId64 \" \\n \" , total ) ; \n sum = 0 ; \n for ( i = 0 ; i < nb_pc_records ; i ++ ) { \n r = pr [ i ] ; \n sum += r -> count ; \n fprintf ( f , \" \" PRId64 \" \\n \" , \n r -> pc , \n r -> count , \n ( double ) r -> count / ( double ) total * 100.0 , \n ( double ) sum / ( double ) total * 100.0 ) ; \n } \n fclose ( f ) ; \n free ( pr ) ; \n kqemu_record_flush ( ) ; \n }", "idx": 18231}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_reply_ready ( void * opaque ) \n { \n NbdClientSession * s = opaque ; \n uint64_t i ; \n int ret ; \n if ( s -> reply . handle == 0 ) { \n ret = nbd_receive_reply ( s -> sock , & s -> reply ) ; \n if ( ret == - EAGAIN ) { \n return ; \n } \n if ( ret < 0 ) { \n s -> reply . handle = 0 ; \n goto fail ; \n } \n } \n i = HANDLE_TO_INDEX ( s , s -> reply . handle ) ; \n if ( i >= MAX_NBD_REQUESTS ) { \n goto fail ; \n } \n if ( s -> recv_coroutine [ i ] ) { \n qemu_coroutine_enter ( s -> recv_coroutine [ i ] , NULL ) ; \n return ; \n } \n fail : \n nbd_teardown_connection ( s ) ; \n }", "idx": 18267}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_cursor_define ( struct vmsvga_state_s * s , \n struct vmsvga_cursor_definition_s * c ) \n { \n QEMUCursor * qc ; \n int i , pixels ; \n qc = cursor_alloc ( c -> width , c -> height ) ; \n qc -> hot_x = c -> hot_x ; \n qc -> hot_y = c -> hot_y ; \n switch ( c -> bpp ) { \n case 1 : \n cursor_set_mono ( qc , 0xffffff , 0x000000 , ( void * ) c -> image , \n 1 , ( void * ) c -> mask ) ; \n #ifdef DEBUG \n cursor_print_ascii_art ( qc , \" \" ) ; \n #endif \n break ; \n case 32 : \n cursor_set_mono ( qc , 0x000000 , 0x000000 , ( void * ) c -> mask , \n 1 , ( void * ) c -> mask ) ; \n pixels = c -> width * c -> height ; \n for ( i = 0 ; i < pixels ; i ++ ) { \n qc -> data [ i ] |= c -> image [ i ] & 0xffffff ; \n } \n #ifdef DEBUG \n cursor_print_ascii_art ( qc , \" \" ) ; \n #endif \n break ; \n default : \n fprintf ( stderr , \" \\n \" , \n __FUNCTION__ , c -> bpp ) ; \n cursor_put ( qc ) ; \n qc = cursor_builtin_left_ptr ( ) ; \n } \n dpy_cursor_define ( s -> vga . ds , qc ) ; \n cursor_put ( qc ) ; \n }", "idx": 18272}
{"project": "qemu", "commit_id": "6ca8d0fd51154c37b571ea74dd0b3e7a60ab847a", "target": 0, "func": "static void set_proc_name ( const char * s ) \n { \n #ifdef __linux__ \n char name [ 16 ] ; \n if ( ! s ) \n return ; \n name [ sizeof ( name ) - 1 ] = 0 ; \n strncpy ( name , s , sizeof ( name ) ) ; \n prctl ( PR_SET_NAME , name ) ; \n #endif \n }", "idx": 18282}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "int nbd_client_session_co_flush ( NbdClientSession * client ) \n { \n struct nbd_request request ; \n struct nbd_reply reply ; \n ssize_t ret ; \n if ( ! ( client -> nbdflags & NBD_FLAG_SEND_FLUSH ) ) { \n return 0 ; \n } \n request . type = NBD_CMD_FLUSH ; \n if ( client -> nbdflags & NBD_FLAG_SEND_FUA ) { \n request . type |= NBD_CMD_FLAG_FUA ; \n } \n request . from = 0 ; \n request . len = 0 ; \n nbd_coroutine_start ( client , & request ) ; \n ret = nbd_co_send_request ( client , & request , NULL , 0 ) ; \n if ( ret < 0 ) { \n reply . error = - ret ; \n } else { \n nbd_co_receive_reply ( client , & request , & reply , NULL , 0 ) ; \n } \n nbd_coroutine_end ( client , & request ) ; \n return - reply . error ; \n }", "idx": 18285}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit ( QEMUFile * f , int64_t limit ) \n { \n f -> xfer_limit = limit ; \n }", "idx": 18326}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_bool ( Visitor * v , const char * name , bool * obj , \n Error * * errp ) \n { \n QObjectInputVisitor * qiv = to_qiv ( v ) ; \n QObject * qobj = qobject_input_get_object ( qiv , name , true , errp ) ; \n QBool * qbool ; \n if ( ! qobj ) { \n return ; \n } \n qbool = qobject_to_qbool ( qobj ) ; \n if ( ! qbool ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : \" \" , \n \" \" ) ; \n return ; \n } \n * obj = qbool_get_bool ( qbool ) ; \n }", "idx": 18329}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog ( const char * p ) \n { \n WatchdogTimerModel * model ; \n QemuOpts * opts ; \n if ( strcmp ( p , \" \" ) == 0 ) { \n LIST_FOREACH ( model , & watchdog_list , entry )  { \n fprintf ( stderr , \" \\t \\t \\n \" , \n model -> wdt_name , model -> wdt_description ) ; \n } \n return 2 ; \n } \n LIST_FOREACH ( model , & watchdog_list , entry )  { \n if ( strcasecmp ( model -> wdt_name , p ) == 0 ) { \n opts = qemu_opts_create ( & qemu_device_opts , NULL , 0 ) ; \n qemu_opt_set ( opts , \" \" , p ) ; \n return 0 ; \n } \n } \n fprintf ( stderr , \" \\n \" ) ; \n LIST_FOREACH ( model , & watchdog_list , entry )  { \n fprintf ( stderr , \" \\t \\t \\n \" , \n model -> wdt_name , model -> wdt_description ) ; \n } \n return 1 ; \n }", "idx": 18345}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output ( VirtIODevice * vdev , VirtQueue * vq ) \n { \n VirtIOBalloon * s = VIRTIO_BALLOON ( vdev ) ; \n VirtQueueElement elem ; \n MemoryRegionSection section ; \n while ( virtqueue_pop ( vq , & elem ) ) { \n size_t offset = 0 ; \n uint32_t pfn ; \n while ( iov_to_buf ( elem . out_sg , elem . out_num , offset , & pfn , 4 ) == 4 ) { \n ram_addr_t pa ; \n ram_addr_t addr ; \n int p = virtio_ldl_p ( vdev , & pfn ) ; \n pa = ( ram_addr_t ) p << VIRTIO_BALLOON_PFN_SHIFT ; \n offset += 4 ; \n section = memory_region_find ( get_system_memory ( ) , pa , 1 ) ; \n if ( ! int128_nz ( section . size ) || ! memory_region_is_ram ( section . mr ) ) \n continue ; \n trace_virtio_balloon_handle_output ( memory_region_name ( section . mr ) , \n pa ) ; \n addr = section . offset_within_region ; \n balloon_page ( memory_region_get_ram_ptr ( section . mr ) + addr , \n ! ! ( vq == s -> dvq ) ) ; \n memory_region_unref ( section . mr ) ; \n } \n virtqueue_push ( vq , & elem , offset ) ; \n virtio_notify ( vdev , vq ) ; \n } \n }", "idx": 18351}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_send ( QEMUFile * f , BlkMigBlock * blk ) \n { \n int len ; \n uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK ; \n if ( block_mig_state . zero_blocks && \n buffer_is_zero ( blk -> buf , BLOCK_SIZE ) ) { \n flags |= BLK_MIG_FLAG_ZERO_BLOCK ; \n } \n qemu_put_be64 ( f , ( blk -> sector << BDRV_SECTOR_BITS ) \n | flags ) ; \n len = strlen ( bdrv_get_device_name ( blk -> bmds -> bs ) ) ; \n qemu_put_byte ( f , len ) ; \n qemu_put_buffer ( f , ( uint8_t * ) bdrv_get_device_name ( blk -> bmds -> bs ) , len ) ; \n if ( flags & BLK_MIG_FLAG_ZERO_BLOCK ) { \n qemu_fflush ( f ) ; \n return ; \n } \n qemu_put_buffer ( f , blk -> buf , BLOCK_SIZE ) ; \n }", "idx": 18384}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze ( Error * * err ) \n { \n int ret = 0 , i = 0 ; \n FsMountList mounts ; \n struct FsMount * mount ; \n Error * local_err = NULL ; \n int fd ; \n slog ( \" \" ) ; \n execute_fsfreeze_hook ( FSFREEZE_HOOK_FREEZE , & local_err ) ; \n if ( error_is_set ( & local_err ) ) { \n error_propagate ( err , local_err ) ; \n return -1 ; \n } \n QTAILQ_INIT ( & mounts ) ; \n build_fs_mount_list ( & mounts , & local_err ) ; \n if ( error_is_set ( & local_err ) ) { \n error_propagate ( err , local_err ) ; \n return -1 ; \n } \n ga_set_frozen ( ga_state ) ; \n QTAILQ_FOREACH ( mount , & mounts , next )  { \n fd = qemu_open ( mount -> dirname , O_RDONLY ) ; \n if ( fd == -1 ) { \n error_setg_errno ( err , errno , \" \" , mount -> dirname ) ; \n goto error ; \n } \n ret = ioctl ( fd , FIFREEZE ) ; \n if ( ret == -1 ) { \n if ( errno != EOPNOTSUPP ) { \n error_setg_errno ( err , errno , \" \" , \n mount -> dirname ) ; \n close ( fd ) ; \n goto error ; \n } \n } else { \n i ++ ; \n } \n close ( fd ) ; \n } \n free_fs_mount_list ( & mounts ) ; \n return i ; \n error : \n free_fs_mount_list ( & mounts ) ; \n qmp_guest_fsfreeze_thaw ( NULL ) ; \n return 0 ; \n }", "idx": 18409}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_string ( void * fdt , const char * node_path , \n const char * property , const char * string ) \n { \n int offset ; \n offset = fdt_path_offset ( fdt , node_path ) ; \n if ( offset < 0 ) \n return offset ; \n return fdt_setprop_string ( fdt , offset , property , string ) ; \n }", "idx": 18412}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit ( BlkActionState * common ) \n { \n ExternalSnapshotState * state = \n DO_UPCAST ( ExternalSnapshotState , common , common ) ; \n bdrv_set_aio_context ( state -> new_bs , state -> aio_context ) ; \n bdrv_append ( state -> new_bs , state -> old_bs ) ; \n bdrv_reopen ( state -> old_bs , state -> old_bs -> open_flags & ~ BDRV_O_RDWR , \n NULL ) ; \n }", "idx": 18437}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_as_update_one ( rc4030State * s , int index , uint32_t frame ) \n { \n if ( index < MAX_TL_ENTRIES ) { \n memory_region_set_enabled ( & s -> dma_mrs [ index ] , false ) ; \n } \n if ( ! frame ) { \n return ; \n } \n if ( index >= MAX_TL_ENTRIES ) { \n qemu_log_mask ( LOG_UNIMP , \n \" \" \n \" \" , \n index , MAX_TL_ENTRIES ) ; \n return ; \n } \n memory_region_set_alias_offset ( & s -> dma_mrs [ index ] , frame ) ; \n memory_region_set_enabled ( & s -> dma_mrs [ index ] , true ) ; \n }", "idx": 18439}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd ( VirtIODevice * vdev , \n VirtQueue * vq ) \n { \n VirtIOSCSI * s = ( VirtIOSCSI * ) vdev ; \n assert ( s -> ctx && s -> dataplane_started ) ; \n return virtio_scsi_handle_cmd_vq ( s , vq ) ; \n }", "idx": 18447}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start ( TraceBufferRecord * rec , TraceEventID event , size_t datasize ) \n { \n unsigned int idx , rec_off , old_idx , new_idx ; \n uint32_t rec_len = sizeof ( TraceRecord ) + datasize ; \n uint64_t event_u64 = event ; \n uint64_t timestamp_ns = get_clock ( ) ; \n do { \n old_idx = g_atomic_int_get ( & trace_idx ) ; \n smp_rmb ( ) ; \n new_idx = old_idx + rec_len ; \n if ( new_idx - writeout_idx > TRACE_BUF_LEN ) { \n g_atomic_int_inc ( & dropped_events ) ; \n return - ENOSPC ; \n } \n } while ( ! g_atomic_int_compare_and_exchange ( & trace_idx , old_idx , new_idx ) ) ; \n idx = old_idx % TRACE_BUF_LEN ; \n rec_off = idx ; \n rec_off = write_to_buffer ( rec_off , & event_u64 , sizeof ( event_u64 ) ) ; \n rec_off = write_to_buffer ( rec_off , & timestamp_ns , sizeof ( timestamp_ns ) ) ; \n rec_off = write_to_buffer ( rec_off , & rec_len , sizeof ( rec_len ) ) ; \n rec_off = write_to_buffer ( rec_off , & trace_pid , sizeof ( trace_pid ) ) ; \n rec -> tbuf_idx = idx ; \n rec -> rec_off = ( idx + sizeof ( TraceRecord ) ) % TRACE_BUF_LEN ; \n return 0 ; \n }", "idx": 18477}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket ( MapCacheEntry * entry , \n hwaddr size , \n hwaddr address_index ) \n { \n uint8_t * vaddr_base ; \n xen_pfn_t * pfns ; \n int * err ; \n unsigned int i ; \n hwaddr nb_pfn = size >> XC_PAGE_SHIFT ; \n trace_xen_remap_bucket ( address_index ) ; \n pfns = g_malloc0 ( nb_pfn * sizeof ( xen_pfn_t ) ) ; \n err = g_malloc0 ( nb_pfn * sizeof ( int ) ) ; \n if ( entry -> vaddr_base != NULL ) { \n if ( munmap ( entry -> vaddr_base , entry -> size ) != 0 ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n } \n g_free ( entry -> valid_mapping ) ; \n entry -> valid_mapping = NULL ; \n for ( i = 0 ; i < nb_pfn ; i ++ ) { \n pfns [ i ] = ( address_index << ( MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT ) ) + i ; \n } \n vaddr_base = xc_map_foreign_bulk ( xen_xc , xen_domid , PROT_READ | PROT_WRITE , \n pfns , err , nb_pfn ) ; \n if ( vaddr_base == NULL ) { \n perror ( \" \" ) ; \n exit ( -1 ) ; \n } \n entry -> vaddr_base = vaddr_base ; \n entry -> paddr_index = address_index ; \n entry -> size = size ; \n entry -> valid_mapping = ( unsigned long * ) g_malloc0 ( sizeof ( unsigned long ) * \n BITS_TO_LONGS ( size >> XC_PAGE_SHIFT ) ) ; \n bitmap_zero ( entry -> valid_mapping , nb_pfn ) ; \n for ( i = 0 ; i < nb_pfn ; i ++ ) { \n if ( ! err [ i ] ) { \n bitmap_set ( entry -> valid_mapping , i , 1 ) ; \n } \n } \n g_free ( pfns ) ; \n g_free ( err ) ; \n }", "idx": 18512}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete ( USBDevice * dev , USBPacket * p ) \n { \n USBEndpoint * ep = p -> ep ; \n int ret ; \n assert ( p -> state == USB_PACKET_ASYNC ) ; \n assert ( QTAILQ_FIRST ( & ep -> queue ) == p ) ; \n usb_packet_set_state ( p , USB_PACKET_COMPLETE ) ; \n QTAILQ_REMOVE ( & ep -> queue , p , queue ) ; \n dev -> port -> ops -> complete ( dev -> port , p ) ; \n while ( ! QTAILQ_EMPTY ( & ep -> queue ) ) { \n p = QTAILQ_FIRST ( & ep -> queue ) ; \n if ( p -> state == USB_PACKET_ASYNC ) { \n break ; \n } \n assert ( p -> state == USB_PACKET_QUEUED ) ; \n ret = usb_process_one ( p ) ; \n if ( ret == USB_RET_ASYNC ) { \n usb_packet_set_state ( p , USB_PACKET_ASYNC ) ; \n break ; \n } \n p -> result = ret ; \n usb_packet_set_state ( p , USB_PACKET_COMPLETE ) ; \n QTAILQ_REMOVE ( & ep -> queue , p , queue ) ; \n dev -> port -> ops -> complete ( dev -> port , p ) ; \n } \n }", "idx": 18513}
{"project": "qemu", "commit_id": "b6b75a99dab760c902c3d355519e0dc2616872e1", "target": 1, "func": "static void bitmap_free ( Qcow2Bitmap * bm ) \n { \n g_free ( bm -> name ) ; \n g_free ( bm ) ; ", "idx": 18562}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_enqueue_packet ( VLANClientState * sender , \n const uint8_t * buf , int size , \n NetPacketSent * sent_cb ) \n { \n VLANPacket * packet ; \n packet = qemu_malloc ( sizeof ( VLANPacket ) + size ) ; \n packet -> sender = sender ; \n packet -> size = size ; \n packet -> sent_cb = sent_cb ; \n memcpy ( packet -> data , buf , size ) ; \n TAILQ_INSERT_TAIL ( & sender -> vlan -> send_queue , packet , entry ) ; \n }", "idx": 18596}
{"project": "qemu", "commit_id": "7d6b1daedd00b35e50ce87ea835f662b36a23160", "target": 0, "func": "static inline uint64_t cpu_ppc_get_tb ( CPUPPCState * env ) \n { \n return 0 ; \n }", "idx": 18597}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp ( uint16_t length , uint16_t proto , \n uint8_t * addrs , uint8_t * buf ) \n { \n uint32_t sum = 0 ; \n sum += net_checksum_add ( length , buf ) ; \n sum += net_checksum_add ( 8 , addrs ) ; \n sum += proto + length ; \n return net_checksum_finish ( sum ) ; \n }", "idx": 18598}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit ( CPUState * env1 ) \n { \n env1 -> current_tb = NULL ; \n longjmp ( env1 -> jmp_env , 1 ) ; \n }", "idx": 18614}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_transfer ( int tpm_fd , \n const TPMLocality * locty_data ) \n { \n return tpm_passthrough_unix_tx_bufs ( tpm_fd , \n locty_data -> w_buffer . buffer , \n locty_data -> w_offset , \n locty_data -> r_buffer . buffer , \n locty_data -> r_buffer . size ) ; \n }", "idx": 18673}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_tw ( int flags ) \n { \n if ( ! likely ( ! ( ( ( int32_t ) T0 < ( int32_t ) T1 && ( flags & 0x10 ) ) || \n ( ( int32_t ) T0 > ( int32_t ) T1 && ( flags & 0x08 ) ) || \n ( ( int32_t ) T0 == ( int32_t ) T1 && ( flags & 0x04 ) ) || \n ( ( uint32_t ) T0 < ( uint32_t ) T1 && ( flags & 0x02 ) ) || \n ( ( uint32_t ) T0 > ( uint32_t ) T1 && ( flags & 0x01 ) ) ) ) ) { \n do_raise_exception_err ( EXCP_PROGRAM , EXCP_TRAP ) ; \n } \n }", "idx": 18675}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline unsigned int msi_nr_vectors ( uint16_t flags ) \n { \n return 1U << \n ( ( flags & PCI_MSI_FLAGS_QSIZE ) >> ( ffs ( PCI_MSI_FLAGS_QSIZE ) - 1 ) ) ; \n }", "idx": 18724}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_init ( MachineState * machine ) \n { \n ram_addr_t ram_size = machine -> ram_size ; \n const char * cpu_model = machine -> cpu_model ; \n const char * kernel_filename = machine -> kernel_filename ; \n OpenRISCCPU * cpu = NULL ; \n MemoryRegion * ram ; \n int n ; \n if ( ! cpu_model ) { \n cpu_model = \" \" ; \n } \n for ( n = 0 ; n < smp_cpus ; n ++ ) { \n cpu = OPENRISC_CPU ( cpu_generic_init ( TYPE_OPENRISC_CPU , cpu_model ) ) ; \n qemu_register_reset ( main_cpu_reset , cpu ) ; \n main_cpu_reset ( cpu ) ; \n } \n ram = g_malloc ( sizeof ( * ram ) ) ; \n memory_region_init_ram ( ram , NULL , \" \" , ram_size , & error_fatal ) ; \n memory_region_add_subregion ( get_system_memory ( ) , 0 , ram ) ; \n cpu_openrisc_pic_init ( cpu ) ; \n cpu_openrisc_clock_init ( cpu ) ; \n serial_mm_init ( get_system_memory ( ) , 0x90000000 , 0 , cpu -> env . irq [ 2 ] , \n 115200 , serial_hds [ 0 ] , DEVICE_NATIVE_ENDIAN ) ; \n if ( nd_table [ 0 ] . used ) { \n openrisc_sim_net_init ( get_system_memory ( ) , 0x92000000 , \n 0x92000400 , cpu -> env . irq [ 4 ] , nd_table ) ; \n } \n cpu_openrisc_load_kernel ( ram_size , kernel_filename , cpu ) ; \n }", "idx": 18727}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "static void ohci_reset ( void * opaque ) \n { \n OHCIState * ohci = opaque ; \n OHCIPort * port ; \n int i ; \n ohci_bus_stop ( ohci ) ; \n ohci -> ctl = 0 ; \n ohci -> old_ctl = 0 ; \n ohci -> status = 0 ; \n ohci -> intr_status = 0 ; \n ohci -> intr = OHCI_INTR_MIE ; \n ohci -> hcca = 0 ; \n ohci -> ctrl_head = ohci -> ctrl_cur = 0 ; \n ohci -> bulk_head = ohci -> bulk_cur = 0 ; \n ohci -> per_cur = 0 ; \n ohci -> done = 0 ; \n ohci -> done_count = 7 ; \n ohci -> fsmps = 0x2778 ; \n ohci -> fi = 0x2edf ; \n ohci -> fit = 0 ; \n ohci -> frt = 0 ; \n ohci -> frame_number = 0 ; \n ohci -> pstart = 0 ; \n ohci -> lst = OHCI_LS_THRESH ; \n ohci -> rhdesc_a = OHCI_RHA_NPS | ohci -> num_ports ; \n ohci -> rhdesc_b = 0x0 ; \n ohci -> rhstatus = 0 ; \n for ( i = 0 ; i < ohci -> num_ports ; i ++ ) \n { \n port = & ohci -> rhport [ i ] ; \n port -> ctrl = 0 ; \n if ( port -> port . dev ) { \n usb_attach ( & port -> port , port -> port . dev ) ; \n } \n } \n if ( ohci -> async_td ) { \n usb_cancel_packet ( & ohci -> usb_packet ) ; \n ohci -> async_td = 0 ; \n } \n DPRINTF ( \" \\n \" , ohci -> name ) ; \n }", "idx": 18741}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub ( CPUPPCState * env , uint64_t arg1 , uint64_t arg2 ) \n { \n CPU_DoubleU farg1 , farg2 ; \n farg1 . ll = arg1 ; \n farg2 . ll = arg2 ; \n if ( unlikely ( float64_is_infinity ( farg1 . d ) && float64_is_infinity ( farg2 . d ) && \n float64_is_neg ( farg1 . d ) == float64_is_neg ( farg2 . d ) ) ) { \n farg1 . ll = fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXISI ) ; \n } else { \n if ( unlikely ( float64_is_signaling_nan ( farg1 . d ) || \n float64_is_signaling_nan ( farg2 . d ) ) ) { \n fload_invalid_op_excp ( env , POWERPC_EXCP_FP_VXSNAN ) ; \n } \n farg1 . d = float64_sub ( farg1 . d , farg2 . d , & env -> fp_status ) ; \n } \n return farg1 . ll ; \n }", "idx": 18744}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_connect_init ( NetClientState * peer , \n const char * model , \n const char * name , \n const char * host_str ) \n { \n NetSocketState * s ; \n int fd , connected , ret ; \n struct sockaddr_in saddr ; \n if ( parse_host_port ( & saddr , host_str ) < 0 ) \n return -1 ; \n fd = qemu_socket ( PF_INET , SOCK_STREAM , 0 ) ; \n if ( fd < 0 ) { \n perror ( \" \" ) ; \n return -1 ; \n } \n qemu_set_nonblock ( fd ) ; \n connected = 0 ; \n for ( ; ; ) { \n ret = connect ( fd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ; \n if ( ret < 0 ) { \n if ( errno == EINTR || errno == EWOULDBLOCK ) { \n } else if ( errno == EINPROGRESS || \n errno == EALREADY || \n errno == EINVAL ) { \n break ; \n } else { \n perror ( \" \" ) ; \n closesocket ( fd ) ; \n return -1 ; \n } \n } else { \n connected = 1 ; \n break ; \n } \n } \n s = net_socket_fd_init ( peer , model , name , fd , connected ) ; \n if ( ! s ) \n return -1 ; \n snprintf ( s -> nc . info_str , sizeof ( s -> nc . info_str ) , \n \" \" , \n inet_ntoa ( saddr . sin_addr ) , ntohs ( saddr . sin_port ) ) ; \n return 0 ; \n }", "idx": 18759}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_anon ( TestInputVisitorData * data , \n const void * unused ) \n { \n UserDefAnonUnion * tmp = NULL ; \n Visitor * v ; \n Error * errp = NULL ; \n v = validate_test_init ( data , \" \" ) ; \n visit_type_UserDefAnonUnion ( v , & tmp , NULL , & errp ) ; \n g_assert ( error_is_set ( & errp ) ) ; \n qapi_free_UserDefAnonUnion ( tmp ) ; \n }", "idx": 18781}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init ( struct vhost_dev * dev , \n struct vhost_virtqueue * vq , int n ) \n { \n struct vhost_vring_file file = { \n . index = n , \n } ; \n int r = event_notifier_init ( & vq -> masked_notifier , 0 ) ; \n if ( r < 0 ) { \n return r ; \n } \n file . fd = event_notifier_get_fd ( & vq -> masked_notifier ) ; \n r = dev -> vhost_ops -> vhost_call ( dev , VHOST_SET_VRING_CALL , & file ) ; \n if ( r ) { \n r = - errno ; \n goto fail_call ; \n } \n return 0 ; \n fail_call : \n event_notifier_cleanup ( & vq -> masked_notifier ) ; \n return r ; \n }", "idx": 18799}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice * usb_msd_init ( const char * filename ) \n { \n static int nr = 0 ; \n char id [ 8 ] ; \n QemuOpts * opts ; \n DriveInfo * dinfo ; \n USBDevice * dev ; \n int fatal_error ; \n const char * p1 ; \n char fmt [ 32 ] ; \n snprintf ( id , sizeof ( id ) , \" \" , nr ++ ) ; \n opts = qemu_opts_create ( & qemu_drive_opts , id , 0 ) ; \n p1 = strchr ( filename , ' ' ) ; \n if ( p1 ++ ) { \n const char * p2 ; \n if ( strstart ( filename , \" \" , & p2 ) ) { \n int len = MIN ( p1 - p2 , sizeof ( fmt ) ) ; \n pstrcpy ( fmt , len , p2 ) ; \n qemu_opt_set ( opts , \" \" , fmt ) ; \n } else if ( * filename != ' ' ) { \n printf ( \" \\n \" , filename ) ; \n filename = p1 ; \n if ( ! * filename ) { \n printf ( \" \\n \" ) ; \n qemu_opt_set ( opts , \" \" , filename ) ; \n qemu_opt_set ( opts , \" \" , \" \" ) ; \n dinfo = drive_init ( opts , NULL , & fatal_error ) ; \n if ( ! dinfo ) { \n qemu_opts_del ( opts ) ; \n dev = usb_create ( NULL \n , \" \" ) ; \n qdev_prop_set_drive ( & dev -> qdev , \" \" , dinfo ) ; \n if ( qdev_init ( & dev -> qdev ) < 0 ) \n return dev ;", "idx": 18820}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect ( MigrationState * s ) \n { \n s -> state = MIG_STATE_SETUP ; \n trace_migrate_set_state ( MIG_STATE_SETUP ) ; \n s -> expected_downtime = max_downtime / 1000000 ; \n s -> cleanup_bh = qemu_bh_new ( migrate_fd_cleanup , s ) ; \n qemu_file_set_rate_limit ( s -> file , \n s -> bandwidth_limit / XFER_LIMIT_RATIO ) ; \n qemu_thread_create ( & s -> thread , migration_thread , s , \n QEMU_THREAD_JOINABLE ) ; \n notifier_list_notify ( & migration_state_notifiers , s ) ; \n }", "idx": 18833}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_cmd_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n CMD646BAR * cmd646bar = opaque ; \n if ( addr != 2 || size != 1 ) { \n return ( ( uint64_t ) 1 << ( size * 8 ) ) - 1 ; \n } \n return ide_status_read ( cmd646bar -> bus , addr + 2 ) ; \n }", "idx": 18853}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_msch ( S390CPU * cpu , uint64_t reg1 , uint32_t ipb ) \n { \n int cssid , ssid , schid , m ; \n SubchDev * sch ; \n SCHIB schib ; \n uint64_t addr ; \n int ret = - ENODEV ; \n int cc ; \n CPUS390XState * env = & cpu -> env ; \n uint8_t ar ; \n addr = decode_basedisp_s ( env , ipb , & ar ) ; \n if ( addr & 3 ) { \n program_interrupt ( env , PGM_SPECIFICATION , 2 ) ; \n return ; \n } \n if ( s390_cpu_virt_mem_read ( cpu , addr , ar , & schib , sizeof ( schib ) ) ) { \n return ; \n } \n if ( ioinst_disassemble_sch_ident ( reg1 , & m , & cssid , & ssid , & schid ) || \n ! ioinst_schib_valid ( & schib ) ) { \n program_interrupt ( env , PGM_OPERAND , 2 ) ; \n return ; \n } \n trace_ioinst_sch_id ( \" \" , cssid , ssid , schid ) ; \n sch = css_find_subch ( m , cssid , ssid , schid ) ; \n if ( sch && css_subch_visible ( sch ) ) { \n ret = css_do_msch ( sch , & schib ) ; \n } \n switch ( ret ) { \n case - ENODEV : \n cc = 3 ; \n break ; \n case - EBUSY : \n cc = 2 ; \n break ; \n case 0 : \n cc = 0 ; \n break ; \n default : \n cc = 1 ; \n break ; \n } \n setcc ( cpu , cc ) ; \n }", "idx": 18931}
{"project": "qemu", "commit_id": "2af3da91839c04a5d73643b4eacce4cd93b9d428", "target": 0, "func": "void cpu_dump_state ( CPUState * env , FILE * f , fprintf_function cpu_fprintf , \n int flags ) \n { \n int i ; \n cpu_fprintf ( f , \" \\n \" , env -> pc ) ; \n for ( i = 0 ; i < 16 ; ++ i ) { \n cpu_fprintf ( f , \" \" , i , env -> regs [ i ] , \n ( i % 4 ) == 3 ? ' \\n ' : ' ' ) ; \n } \n }", "idx": 18988}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_bool ( Visitor * v , bool * obj , const char * name , Error * * errp ) \n { \n if ( ! error_is_set ( errp ) ) { \n v -> type_bool ( v , obj , name , errp ) ; \n } \n }", "idx": 19005}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq * pxa2xx_pic_init ( target_phys_addr_t base , CPUState * env ) \n { \n struct pxa2xx_pic_state_s * s ; \n int iomemtype ; \n qemu_irq * qi ; \n s = ( struct pxa2xx_pic_state_s * ) \n qemu_mallocz ( sizeof ( struct pxa2xx_pic_state_s ) ) ; \n if ( ! s ) \n return NULL ; \n s -> cpu_env = env ; \n s -> base = base ; \n s -> int_pending [ 0 ] = 0 ; \n s -> int_pending [ 1 ] = 0 ; \n s -> int_enabled [ 0 ] = 0 ; \n s -> int_enabled [ 1 ] = 0 ; \n s -> is_fiq [ 0 ] = 0 ; \n s -> is_fiq [ 1 ] = 0 ; \n qi = qemu_allocate_irqs ( pxa2xx_pic_set_irq , s , PXA2XX_PIC_SRCS ) ; \n iomemtype = cpu_register_io_memory ( 0 , pxa2xx_pic_readfn , \n pxa2xx_pic_writefn , s ) ; \n cpu_register_physical_memory ( base , 0x000fffff , iomemtype ) ; \n cpu_arm_set_cp_io ( env , 6 , pxa2xx_pic_cp_read , pxa2xx_pic_cp_write , s ) ; \n register_savevm ( \" \" , 0 , 0 , pxa2xx_pic_save , pxa2xx_pic_load , s ) ; \n return qi ; \n }", "idx": 19027}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static InetSocketAddress * ssh_config ( QDict * options , Error * * errp ) \n { \n InetSocketAddress * inet = NULL ; \n QDict * addr = NULL ; \n QObject * crumpled_addr = NULL ; \n Visitor * iv = NULL ; \n Error * local_error = NULL ; \n qdict_extract_subqdict ( options , & addr , \" \" ) ; \n if ( ! qdict_size ( addr ) ) { \n error_setg ( errp , \" \" ) ; \n goto out ; \n } \n crumpled_addr = qdict_crumple ( addr , errp ) ; \n if ( ! crumpled_addr ) { \n goto out ; \n } \n iv = qobject_input_visitor_new ( crumpled_addr ) ; \n visit_type_InetSocketAddress ( iv , NULL , & inet , & local_error ) ; \n if ( local_error ) { \n error_propagate ( errp , local_error ) ; \n goto out ; \n } \n out : \n QDECREF ( addr ) ; \n qobject_decref ( crumpled_addr ) ; \n visit_free ( iv ) ; \n return inet ; \n }", "idx": 19075}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "sdhci_buff_access_is_sequential ( SDHCIState * s , unsigned byte_num )  \n { \n if ( ( s -> data_count & 0x3 ) != byte_num ) { \n ERRPRINT ( \" \" \n \" \\n \" ) ; \n return false ; \n } \n return true ; \n }", "idx": 19082}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int nbd_negotiate_write ( QIOChannel * ioc , const void * buffer , size_t size ) \n { \n ssize_t ret ; \n guint watch ; \n assert ( qemu_in_coroutine ( ) ) ; \n watch = qio_channel_add_watch ( ioc , \n G_IO_OUT , \n nbd_negotiate_continue , \n qemu_coroutine_self ( ) , \n NULL ) ; \n ret = write_sync ( ioc , buffer , size , NULL ) ; \n g_source_remove ( watch ) ; \n return ret ; \n }", "idx": 19090}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static void aio_read_done ( void * opaque , int ret ) \n { \n struct aio_ctx * ctx = opaque ; \n struct timeval t2 ; \n gettimeofday ( & t2 , NULL ) ; \n if ( ret < 0 ) { \n printf ( \" \\n \" , strerror ( - ret ) ) ; \n goto out ; \n } \n if ( ctx -> Pflag ) { \n void * cmp_buf = malloc ( ctx -> qiov . size ) ; \n memset ( cmp_buf , ctx -> pattern , ctx -> qiov . size ) ; \n if ( memcmp ( ctx -> buf , cmp_buf , ctx -> qiov . size ) ) { \n printf ( \" \" \n PRId64 \" \\n \" , ctx -> offset , ctx -> qiov . size ) ; \n } \n free ( cmp_buf ) ; \n } \n if ( ctx -> qflag ) { \n goto out ; \n } \n if ( ctx -> vflag ) { \n dump_buffer ( ctx -> buf , ctx -> offset , ctx -> qiov . size ) ; \n } \n t2 = tsub ( t2 , ctx -> t1 ) ; \n print_report ( \" \" , & t2 , ctx -> offset , ctx -> qiov . size , \n ctx -> qiov . size , 1 , ctx -> Cflag ) ; \n out : \n qemu_io_free ( ctx -> buf ) ; \n free ( ctx ) ; \n }", "idx": 19102}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_read_tbu ( DisasContext * ctx , int gprn , int sprn ) \n { \n if ( use_icount ) { \n gen_io_start ( ) ; \n } \n gen_helper_load_tbu ( cpu_gpr [ gprn ] , cpu_env ) ; \n if ( use_icount ) { \n gen_io_end ( ) ; \n gen_stop_exception ( ctx ) ; \n } \n }", "idx": 19108}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred ( void ) \n { \n gnutls_anon_server_credentials anon_cred ; \n int ret ; \n if ( ( ret = gnutls_anon_allocate_server_credentials ( & anon_cred ) ) < 0 ) { \n VNC_DEBUG ( \" \\n \" , gnutls_strerror ( ret ) ) ; \n return NULL ; \n } \n gnutls_anon_set_server_dh_params ( anon_cred , dh_params ) ; \n return anon_cred ; \n }", "idx": 19116}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2 ( BlockDriverState * bs , uint64_t offset , \n unsigned int nb_clusters ) \n { \n BDRVQcowState * s = bs -> opaque ; \n uint64_t * l2_table ; \n int l2_index ; \n int ret ; \n int i ; \n ret = get_cluster_table ( bs , offset , & l2_table , & l2_index ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n nb_clusters = MIN ( nb_clusters , s -> l2_size - l2_index ) ; \n for ( i = 0 ; i < nb_clusters ; i ++ ) { \n uint64_t old_offset ; \n old_offset = be64_to_cpu ( l2_table [ l2_index + i ] ) ; \n qcow2_cache_entry_mark_dirty ( bs , s -> l2_table_cache , l2_table ) ; \n if ( old_offset & QCOW_OFLAG_COMPRESSED ) { \n l2_table [ l2_index + i ] = cpu_to_be64 ( QCOW_OFLAG_ZERO ) ; \n qcow2_free_any_clusters ( bs , old_offset , 1 , QCOW2_DISCARD_REQUEST ) ; \n } else { \n l2_table [ l2_index + i ] |= cpu_to_be64 ( QCOW_OFLAG_ZERO ) ; \n } \n } \n ret = qcow2_cache_put ( bs , s -> l2_table_cache , ( void * * ) & l2_table ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n return nb_clusters ; \n }", "idx": 19119}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "static AddressSpace * s390_pci_dma_iommu ( PCIBus * bus , void * opaque , int devfn ) \n { \n S390pciState * s = opaque ; \n return & s -> pbdev [ PCI_SLOT ( devfn ) ] . as ; \n }", "idx": 19126}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_info_commands ( void ) \n { \n char * resp , * info , * info_buf , * endp ; \n info_buf = info = hmp ( \" \" ) ; \n while ( * info ) { \n g_assert ( strncmp ( info , \" \" , 5 ) == 0 ) ; \n endp = strchr ( & info [ 5 ] , ' ' ) ; \n g_assert ( endp != NULL ) ; \n * endp = ' \\0 ' ; \n if ( verbose ) { \n fprintf ( stderr , \" \\t \\n \" , info ) ; \n } \n resp = hmp ( info ) ; \n g_free ( resp ) ; \n info = strchr ( endp + 1 , ' \\n ' ) ; \n if ( ! info ) { \n break ; \n } \n info += 1 ; \n } \n g_free ( info_buf ) ; \n }", "idx": 19128}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov ( TCGContext * s , TCGType type , TCGReg ret , TCGReg arg ) \n { \n uint8_t * old_code_ptr = s -> code_ptr ; \n assert ( ret != arg ) ; \n #if TCG_TARGET_REG_BITS == 32  \n  \n  tcg_out_op_t ( s , INDEX_op_mov_i32 ) ; \n #else \n tcg_out_op_t ( s , INDEX_op_mov_i64 ) ; \n #endif \n tcg_out_r ( s , ret ) ; \n tcg_out_r ( s , arg ) ; \n old_code_ptr [ 1 ] = s -> code_ptr - old_code_ptr ; \n }", "idx": 19129}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in ( USBDevice * s , USBPacket * p ) \n { \n int request , value , index ; \n int ret = 0 ; \n assert ( p -> devep == 0 ) ; \n request = ( s -> setup_buf [ 0 ] << 8 ) | s -> setup_buf [ 1 ] ; \n value = ( s -> setup_buf [ 3 ] << 8 ) | s -> setup_buf [ 2 ] ; \n index = ( s -> setup_buf [ 5 ] << 8 ) | s -> setup_buf [ 4 ] ; \n switch ( s -> setup_state ) { \n case SETUP_STATE_ACK : \n if ( ! ( s -> setup_buf [ 0 ] & USB_DIR_IN ) ) { \n ret = usb_device_handle_control ( s , p , request , value , index , \n s -> setup_len , s -> data_buf ) ; \n if ( ret == USB_RET_ASYNC ) { \n return USB_RET_ASYNC ; \n } \n s -> setup_state = SETUP_STATE_IDLE ; \n if ( ret > 0 ) \n return 0 ; \n return ret ; \n } \n return 0 ; \n case SETUP_STATE_DATA : \n if ( s -> setup_buf [ 0 ] & USB_DIR_IN ) { \n int len = s -> setup_len - s -> setup_index ; \n if ( len > p -> iov . size ) { \n len = p -> iov . size ; \n } \n usb_packet_copy ( p , s -> data_buf + s -> setup_index , len ) ; \n s -> setup_index += len ; \n if ( s -> setup_index >= s -> setup_len ) \n s -> setup_state = SETUP_STATE_ACK ; \n return len ; \n } \n s -> setup_state = SETUP_STATE_IDLE ; \n return USB_RET_STALL ; \n default : \n return USB_RET_STALL ; \n } \n }", "idx": 19133}
{"project": "qemu", "commit_id": "d157ed5f7235f3d2d5596a514ad7507b18e24b88", "target": 0, "func": "static int inject_error ( BlockDriverState * bs , BlkdebugRule * rule ) \n { \n BDRVBlkdebugState * s = bs -> opaque ; \n int error = rule -> options . inject . error ; \n bool immediately = rule -> options . inject . immediately ; \n if ( rule -> options . inject . once ) { \n QSIMPLEQ_REMOVE ( & s -> active_rules , rule , BlkdebugRule , active_next ) ; \n remove_rule ( rule ) ; \n } \n if ( ! immediately ) { \n aio_co_schedule ( qemu_get_current_aio_context ( ) , qemu_coroutine_self ( ) ) ; \n qemu_coroutine_yield ( ) ; \n } \n return - error ; \n }", "idx": 19184}
{"project": "qemu", "commit_id": "4c055ab54fae39b6329c57bcb5334d59b920463e", "target": 0, "func": "int kvm_init_vcpu ( CPUState * cpu ) \n { \n KVMState * s = kvm_state ; \n long mmap_size ; \n int ret ; \n DPRINTF ( \" \\n \" ) ; \n ret = kvm_vm_ioctl ( s , KVM_CREATE_VCPU , ( void * ) kvm_arch_vcpu_id ( cpu ) ) ; \n if ( ret < 0 ) { \n DPRINTF ( \" \\n \" ) ; \n goto err ; \n } \n cpu -> kvm_fd = ret ; \n cpu -> kvm_state = s ; \n cpu -> kvm_vcpu_dirty = true ; \n mmap_size = kvm_ioctl ( s , KVM_GET_VCPU_MMAP_SIZE , 0 ) ; \n if ( mmap_size < 0 ) { \n ret = mmap_size ; \n DPRINTF ( \" \\n \" ) ; \n goto err ; \n } \n cpu -> kvm_run = mmap ( NULL , mmap_size , PROT_READ | PROT_WRITE , MAP_SHARED , \n cpu -> kvm_fd , 0 ) ; \n if ( cpu -> kvm_run == MAP_FAILED ) { \n ret = - errno ; \n DPRINTF ( \" \\n \" ) ; \n goto err ; \n } \n if ( s -> coalesced_mmio && ! s -> coalesced_mmio_ring ) { \n s -> coalesced_mmio_ring = \n ( void * ) cpu -> kvm_run + s -> coalesced_mmio * PAGE_SIZE ; \n } \n ret = kvm_arch_init_vcpu ( cpu ) ; \n err : \n return ret ; \n }", "idx": 19204}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt ( CPUState * cs ) \n { \n ARMCPU * cpu = ARM_CPU ( cs ) ; \n CPUARMState * env = & cpu -> env ; \n unsigned int new_el = env -> exception . target_el ; \n assert ( ! arm_feature ( env , ARM_FEATURE_M ) ) ; \n arm_log_exception ( cs -> exception_index ) ; \n qemu_log_mask ( CPU_LOG_INT , \" \\n \" , arm_current_el ( env ) , \n new_el ) ; \n if ( qemu_loglevel_mask ( CPU_LOG_INT ) \n && ! excp_is_internal ( cs -> exception_index ) ) { \n qemu_log_mask ( CPU_LOG_INT , \" \" PRIx32 \" \\n \" , \n env -> exception . syndrome >> ARM_EL_EC_SHIFT , \n env -> exception . syndrome ) ; \n } \n if ( arm_is_psci_call ( cpu , cs -> exception_index ) ) { \n arm_handle_psci_call ( cpu ) ; \n qemu_log_mask ( CPU_LOG_INT , \" \\n \" ) ; \n return ; \n } ", "idx": 19216}
{"project": "qemu", "commit_id": "e3f30488e5f802547b3a60e40cebaef3b4ec16a3", "target": 1, "func": "static void virtio_net_flush_tx ( VirtIONet * n , VirtQueue * vq ) \n { \n VirtQueueElement elem ; \n if ( ! ( n -> vdev . status & VIRTIO_CONFIG_S_DRIVER_OK ) ) \n return ; \n if ( n -> async_tx . elem . out_num ) { \n virtio_queue_set_notification ( n -> tx_vq , 0 ) ; \n return ; \n } \n while ( virtqueue_pop ( vq , & elem ) ) { \n ssize_t ret , len = 0 ; \n unsigned int out_num = elem . out_num ; \n struct iovec * out_sg = & elem . out_sg [ 0 ] ; \n unsigned hdr_len ; \n hdr_len = n -> mergeable_rx_bufs ? \n sizeof ( struct virtio_net_hdr_mrg_rxbuf ) : \n sizeof ( struct virtio_net_hdr ) ; \n if ( out_num < 1 || out_sg -> iov_len != hdr_len ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n if ( ! n -> has_vnet_hdr ) { \n out_num -- ; \n out_sg ++ ; \n len += hdr_len ; \n } else if ( n -> mergeable_rx_bufs ) { \n hdr_len -= sizeof ( struct virtio_net_hdr ) ; \n out_sg -> iov_len -= hdr_len ; \n len += hdr_len ; \n } \n ret = qemu_sendv_packet_async ( & n -> nic -> nc , out_sg , out_num , \n virtio_net_tx_complete ) ; \n if ( ret == 0 ) { \n virtio_queue_set_notification ( n -> tx_vq , 0 ) ; \n n -> async_tx . elem = elem ; \n n -> async_tx . len = len ; \n return ; \n } \n len += ret ; \n virtqueue_push ( vq , & elem , len ) ; \n virtio_notify ( & n -> vdev , vq ) ; \n } \n }", "idx": 19223}
{"project": "qemu", "commit_id": "a1c5975270f2335e1d7129c084a6e562d7b99bdd", "target": 1, "func": "static void flush_queued_data ( VirtIOSerialPort * port , bool discard ) \n { \n assert ( port || discard ) ; \n do_flush_queued_data ( port , port -> ovq , & port -> vser -> vdev , discard ) ; \n }", "idx": 19237}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline ( SCSIBus * bus ) \n { \n Location loc ; \n DriveInfo * dinfo ; \n int res = 0 , unit ; \n loc_push_none ( & loc ) ; \n for ( unit = 0 ; unit < bus -> info -> max_target ; unit ++ ) { \n dinfo = drive_get ( IF_SCSI , bus -> busnr , unit ) ; \n if ( dinfo == NULL ) { \n continue ; \n } \n qemu_opts_loc_restore ( dinfo -> opts ) ; \n if ( ! scsi_bus_legacy_add_drive ( bus , dinfo -> bdrv , unit , false , -1 ) ) { \n res = -1 ; \n break ; \n } \n } \n loc_pop ( & loc ) ; \n return res ; \n }", "idx": 19243}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qpa_init_in ( HWVoiceIn * hw , audsettings_t * as ) \n { \n int error ; \n static pa_sample_spec ss ; \n audsettings_t obt_as = * as ; \n PAVoiceIn * pa = ( PAVoiceIn * ) hw ; \n ss . format = audfmt_to_pa ( as -> fmt , as -> endianness ) ; \n ss . channels = as -> nchannels ; \n ss . rate = as -> freq ; \n obt_as . fmt = pa_to_audfmt ( ss . format , & obt_as . endianness ) ; \n pa -> s = pa_simple_new ( \n conf . server , \n \" \" , \n PA_STREAM_RECORD , \n conf . source , \n \" \" , \n & ss , \n NULL , \n NULL , \n & error \n ) ; \n if ( ! pa -> s ) { \n qpa_logerr ( error , \" \\n \" ) ; \n goto fail1 ; \n } \n audio_pcm_init_info ( & hw -> info , & obt_as ) ; \n hw -> samples = conf . samples ; \n pa -> pcm_buf = audio_calloc ( AUDIO_FUNC , hw -> samples , 1 << hw -> info . shift ) ; \n if ( ! pa -> pcm_buf ) { \n dolog ( \" \\n \" , \n hw -> samples << hw -> info . shift ) ; \n goto fail2 ; \n } \n if ( audio_pt_init ( & pa -> pt , qpa_thread_in , hw , AUDIO_CAP , AUDIO_FUNC ) ) { \n goto fail3 ; \n } \n return 0 ; \n fail3 : \n free ( pa -> pcm_buf ) ; \n pa -> pcm_buf = NULL ; \n fail2 : \n pa_simple_free ( pa -> s ) ; \n pa -> s = NULL ; \n fail1 : \n return -1 ; \n }", "idx": 19256}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_compute_fprf ( uint64_t arg , uint32_t set_fprf ) \n { \n CPU_DoubleU farg ; \n int isneg ; \n int ret ; \n farg . ll = arg ; \n isneg = float64_is_neg ( farg . d ) ; \n if ( unlikely ( float64_is_nan ( farg . d ) ) ) { \n if ( float64_is_signaling_nan ( farg . d ) ) { \n ret = 0x00 ; \n } else { \n ret = 0x11 ; \n } \n } else if ( unlikely ( float64_is_infinity ( farg . d ) ) ) { \n if ( isneg ) \n ret = 0x09 ; \n else \n ret = 0x05 ; \n } else { \n if ( float64_is_zero ( farg . d ) ) { \n if ( isneg ) \n ret = 0x12 ; \n else \n ret = 0x02 ; \n } else { \n if ( isden ( farg . d ) ) { \n ret = 0x10 ; \n } else { \n ret = 0x00 ; \n } \n if ( isneg ) { \n ret |= 0x08 ; \n } else { \n ret |= 0x04 ; \n } \n } \n } \n if ( set_fprf ) { \n env -> fpscr &= ~ ( 0x1F << FPSCR_FPRF ) ; \n env -> fpscr |= ret << FPSCR_FPRF ; \n } \n return ret & 0xF ; \n }", "idx": 19274}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive ( NetClientState * nc ) \n { \n USBNetState * s = qemu_get_nic_opaque ( nc ) ; \n if ( ! s -> dev . config ) { \n return 0 ; \n } \n if ( is_rndis ( s ) && s -> rndis_state != RNDIS_DATA_INITIALIZED ) { \n return 1 ; \n } \n return ! s -> in_len ; \n }", "idx": 19291}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void dhcp_decode ( const uint8_t * buf , int size , \n int * pmsg_type ) \n { \n const uint8_t * p , * p_end ; \n int len , tag ; \n * pmsg_type = 0 ; \n p = buf ; \n p_end = buf + size ; \n if ( size < 5 ) \n return ; \n if ( memcmp ( p , rfc1533_cookie , 4 ) != 0 ) \n return ; \n p += 4 ; \n while ( p < p_end ) { \n tag = p [ 0 ] ; \n if ( tag == RFC1533_PAD ) { \n p ++ ; \n } else if ( tag == RFC1533_END ) { \n break ; \n } else { \n p ++ ; \n if ( p >= p_end ) \n break ; \n len = * p ++ ; \n dprintf ( \" \\n \" , tag , len ) ; \n switch ( tag ) { \n case RFC2132_MSG_TYPE : \n if ( len >= 1 ) \n * pmsg_type = p [ 0 ] ; \n break ; \n default : \n break ; \n } \n p += len ; \n } \n } \n }", "idx": 19301}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_free_timer ( QEMUTimer * ts ) \n { \n g_free ( ts ) ; \n }", "idx": 19322}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_read_toc ( SCSIRequest * req , uint8_t * outbuf ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; \n int start_track , format , msf , toclen ; \n uint64_t nb_sectors ; \n msf = req -> cmd . buf [ 1 ] & 2 ; \n format = req -> cmd . buf [ 2 ] & 0xf ; \n start_track = req -> cmd . buf [ 6 ] ; \n bdrv_get_geometry ( s -> qdev . conf . bs , & nb_sectors ) ; \n DPRINTF ( \" \\n \" , start_track , format , msf >> 1 ) ; \n nb_sectors /= s -> qdev . blocksize / 512 ; \n switch ( format ) { \n case 0 : \n toclen = cdrom_read_toc ( nb_sectors , outbuf , msf , start_track ) ; \n break ; \n case 1 : \n toclen = 12 ; \n memset ( outbuf , 0 , 12 ) ; \n outbuf [ 1 ] = 0x0a ; \n outbuf [ 2 ] = 0x01 ; \n outbuf [ 3 ] = 0x01 ; \n break ; \n case 2 : \n toclen = cdrom_read_toc_raw ( nb_sectors , outbuf , msf , start_track ) ; \n break ; \n default : \n return -1 ; \n } \n return toclen ; \n }", "idx": 19373}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache ( BlockDriverState * bs , Error * * errp ) \n { \n Error * local_err = NULL ; \n int ret ; \n if ( ! bs -> drv ) { \n return ; \n } \n if ( ! ( bs -> open_flags & BDRV_O_INACTIVE ) ) { \n return ; \n } \n bs -> open_flags &= ~ BDRV_O_INACTIVE ; \n if ( bs -> drv -> bdrv_invalidate_cache ) { \n bs -> drv -> bdrv_invalidate_cache ( bs , & local_err ) ; \n } else if ( bs -> file ) { \n bdrv_invalidate_cache ( bs -> file -> bs , & local_err ) ; \n } \n if ( local_err ) { \n bs -> open_flags |= BDRV_O_INACTIVE ; \n error_propagate ( errp , local_err ) ; \n return ; \n } \n ret = refresh_total_sectors ( bs , bs -> total_sectors ) ; \n if ( ret < 0 ) { \n bs -> open_flags |= BDRV_O_INACTIVE ; \n error_setg_errno ( errp , - ret , \" \" ) ; \n return ; \n } \n }", "idx": 19380}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_vt82c686b_initfn ( PCIDevice * dev ) \n { \n UHCIState * s = DO_UPCAST ( UHCIState , dev , dev ) ; \n uint8_t * pci_conf = s -> dev . config ; \n pci_config_set_vendor_id ( pci_conf , PCI_VENDOR_ID_VIA ) ; \n pci_config_set_device_id ( pci_conf , PCI_DEVICE_ID_VIA_UHCI ) ; \n pci_set_long ( pci_conf + 0x40 , 0x00001000 ) ; \n pci_set_long ( pci_conf + 0x80 , 0x00020001 ) ; \n pci_set_long ( pci_conf + 0xc0 , 0x00002000 ) ; \n return usb_uhci_common_initfn ( s ) ; \n }", "idx": 19389}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline int gen_iwmmxt_shift ( uint32_t insn , uint32_t mask , TCGv dest ) \n { \n int rd = ( insn >> 0 ) & 0xf ; \n TCGv tmp ; \n if ( insn & ( 1 << 8 ) ) { \n if ( rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3 ) { \n return 1 ; \n } else { \n tmp = iwmmxt_load_creg ( rd ) ; \n } \n } else { \n tmp = new_tmp ( ) ; \n iwmmxt_load_reg ( cpu_V0 , rd ) ; \n tcg_gen_trunc_i64_i32 ( tmp , cpu_V0 ) ; \n } \n tcg_gen_andi_i32 ( tmp , tmp , mask ) ; \n tcg_gen_mov_i32 ( dest , tmp ) ; \n dead_tmp ( tmp ) ; \n return 0 ; \n }", "idx": 19403}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_nvidia_3d0_quirk ( VFIOPCIDevice * vdev ) \n { \n VFIOQuirk * quirk ; \n VFIONvidia3d0Quirk * data ; \n if ( ! vfio_pci_is ( vdev , PCI_VENDOR_ID_NVIDIA , PCI_ANY_ID ) || \n ! vdev -> bars [ 1 ] . region . size ) { \n return ; \n } \n quirk = g_malloc0 ( sizeof ( * quirk ) ) ; \n quirk -> data = data = g_malloc0 ( sizeof ( * data ) ) ; \n quirk -> mem = g_malloc0 ( sizeof ( MemoryRegion ) * 2 ) ; \n quirk -> nr_mem = 2 ; \n data -> vdev = vdev ; \n memory_region_init_io ( & quirk -> mem [ 0 ] , OBJECT ( vdev ) , & vfio_nvidia_3d4_quirk , \n data , \" \" , 2 ) ; \n memory_region_add_subregion ( & vdev -> vga . region [ QEMU_PCI_VGA_IO_HI ] . mem , \n 0x14 \n , & quirk -> mem [ 0 ] ) ; \n memory_region_init_io ( & quirk -> mem [ 1 ] , OBJECT ( vdev ) , & vfio_nvidia_3d0_quirk , \n data , \" \" , 2 ) ; \n memory_region_add_subregion ( & vdev -> vga . region [ QEMU_PCI_VGA_IO_HI ] . mem , \n 0x10 \n , & quirk -> mem [ 1 ] ) ; \n QLIST_INSERT_HEAD ( & vdev -> vga . region [ QEMU_PCI_VGA_IO_HI ] . quirks , \n quirk , next ) ; \n trace_vfio_quirk_nvidia_3d0_probe ( vdev -> vbasedev . name ) ; \n }", "idx": 19408}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd ( sPAPRMachineState * spapr ) \n { \n if ( spapr -> htab_fd >= 0 ) { \n return spapr -> htab_fd ; \n } \n spapr -> htab_fd = kvmppc_get_htab_fd ( false ) ; \n if ( spapr -> htab_fd < 0 ) { \n error_report ( \" \" , \n strerror ( errno ) ) ; \n } \n return spapr -> htab_fd ; \n }", "idx": 19434}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_list ( Visitor * v , const char * name , \n GenericList * * list , size_t size , \n Error * * errp ) \n { \n QObjectInputVisitor * qiv = to_qiv ( v ) ; \n QObject * qobj = qobject_input_get_object ( qiv , name , true , errp ) ; \n const QListEntry * entry ; \n if ( list ) { \n * list = NULL ; \n } \n if ( ! qobj ) { \n return ; \n } \n if ( qobject_type ( qobj ) != QTYPE_QLIST ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : \" \" , \n \" \" ) ; \n return ; \n } \n entry = qobject_input_push ( qiv , qobj , list ) ; \n if ( entry && list ) { \n * list = g_malloc0 ( size ) ; \n } \n }", "idx": 19441}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint16 ( TestOutputVisitorData * data , \n const void * unused ) \n { \n test_native_list ( data , unused , USER_DEF_NATIVE_LIST_UNION_KIND_U16 ) ; \n }", "idx": 19473}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov ( TCGContext * s , TCGOp * op , TCGArg * args , \n TCGArg dst , TCGArg src ) \n { \n if ( temps_are_copies ( dst , src ) ) { \n tcg_op_remove ( s , op ) ; \n return ; \n } \n if ( temp_is_const ( src ) ) { \n tcg_opt_gen_movi ( s , op , args , dst , temps [ src ] . val ) ; \n return ; \n } \n TCGOpcode new_op = op_to_mov ( op -> opc ) ; \n tcg_target_ulong mask ; \n op -> opc = new_op ; \n reset_temp ( dst ) ; \n mask = temps [ src ] . mask ; \n if ( TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32 ) { \n mask |= ~ 0xffffffffull ; \n } \n temps [ dst ] . mask = mask ; \n assert ( ! temp_is_const ( src ) ) ; \n if ( s -> temps [ src ] . type == s -> temps [ dst ] . type ) { \n temps [ dst ] . next_copy = temps [ src ] . next_copy ; \n temps [ dst ] . prev_copy = src ; \n temps [ temps [ dst ] . next_copy ] . prev_copy = dst ; \n temps [ src ] . next_copy = dst ; \n temps [ dst ] . is_const = false ; \n } \n args [ 0 ] = dst ; \n args [ 1 ] = src ; \n }", "idx": 19492}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16 ( DeviceState * dev , Property * prop , const char * str ) \n { \n uint16_t * ptr = qdev_get_prop_ptr ( dev , prop ) ; \n const char * fmt ; \n fmt = strncasecmp ( str , \" \" , 2 ) == 0 ? \" \" PRIx16 : \" \" PRIu16 ; \n if ( sscanf ( str , fmt , ptr ) != 1 ) \n return - EINVAL ; \n return 0 ; \n }", "idx": 19554}
{"project": "qemu", "commit_id": "b6954712abea03afd686b724060f9873e2c61f2b", "target": 0, "func": "void replay_input_event ( QemuConsole * src , InputEvent * evt ) \n { \n if ( replay_mode == REPLAY_MODE_PLAY ) { \n } else if ( replay_mode == REPLAY_MODE_RECORD ) { \n replay_add_input_event ( qapi_clone_InputEvent ( evt ) ) ; \n } else { \n qemu_input_event_send_impl ( src , evt ) ; \n } \n }", "idx": 19576}
{"project": "qemu", "commit_id": "db3b3c7281ca82e2647e072a1f97db111313dd73", "target": 1, "func": "static int handle_parse_opts ( QemuOpts * opts , FsDriverEntry * fse , Error * * errp ) \n { \n const char * sec_model = qemu_opt_get ( opts , \" \" ) ; \n const char * path = qemu_opt_get ( opts , \" \" ) ; \n if ( sec_model ) { \n error_report ( \" \" ) ; \n return -1 ; \n } \n if ( ! path ) { \n error_report ( \" \" ) ; \n return -1 ; \n } \n fse -> path = g_strdup ( path ) ; \n return 0 ; \n }", "idx": 19612}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup ( VncState * vs ) \n { \n if ( vs -> sasl . conn ) { \n vs -> sasl . runSSF = vs -> sasl . waitWriteSSF = vs -> sasl . wantSSF = 0 ; \n vs -> sasl . encodedLength = vs -> sasl . encodedOffset = 0 ; \n vs -> sasl . encoded = NULL ; \n g_free ( vs -> sasl . username ) ; \n free ( vs -> sasl . mechlist ) ; \n vs -> sasl . username = vs -> sasl . mechlist = NULL ; \n sasl_dispose ( & vs -> sasl . conn ) ; \n vs -> sasl . conn = NULL ; \n } \n }", "idx": 19633}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int integratorcm_init ( SysBusDevice * dev ) \n { \n IntegratorCMState * s = INTEGRATOR_CM ( dev ) ; \n s -> cm_osc = 0x01000048 ; \n s -> cm_auxosc = 0x0007feff ; \n s -> cm_sdram = 0x00011122 ; \n if ( s -> memsz >= 256 ) { \n integrator_spd [ 31 ] = 64 ; \n s -> cm_sdram |= 0x10 ; \n } else if ( s -> memsz >= 128 ) { \n integrator_spd [ 31 ] = 32 ; \n s -> cm_sdram |= 0x0c ; \n } else if ( s -> memsz >= 64 ) { \n integrator_spd [ 31 ] = 16 ; \n s -> cm_sdram |= 0x08 ; \n } else if ( s -> memsz >= 32 ) { \n integrator_spd [ 31 ] = 4 ; \n s -> cm_sdram |= 0x04 ; \n } else { \n integrator_spd [ 31 ] = 2 ; \n } \n memcpy ( integrator_spd + 73 , \" \" , 11 ) ; \n s -> cm_init = 0x00000112 ; \n s -> cm_refcnt_offset = muldiv64 ( qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) , 24 , \n 1000 ) ; \n memory_region_init_ram ( & s -> flash , OBJECT ( s ) , \" \" , 0x100000 , \n & error_abort ) ; \n vmstate_register_ram_global ( & s -> flash ) ; \n memory_region_init_io ( & s -> iomem , OBJECT ( s ) , & integratorcm_ops , s , \n \" \" , 0x00800000 ) ; \n sysbus_init_mmio ( dev , & s -> iomem ) ; \n integratorcm_do_remap ( s ) ; \n return 0 ; \n }", "idx": 19643}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma ( void ) \n { \n QObject * obj = qobject_from_json ( \" \" , NULL ) ; \n g_assert ( obj == NULL ) ; \n }", "idx": 19650}
{"project": "qemu", "commit_id": "2b3de6ada5d180130ba083d5b45ed51ce8e4def2", "target": 1, "func": "static void ehci_writeback_async_complete_packet ( EHCIPacket * p ) \n { \n EHCIQueue * q = p -> queue ; \n int state ; \n state = ehci_get_state ( q -> ehci , q -> async ) ; \n ehci_state_executing ( q ) ; \n ehci_state_writeback ( q ) ; \n if ( ! ( q -> qh . token & QTD_TOKEN_HALT ) ) { \n ehci_state_advqueue ( q ) ; \n ehci_set_state ( q -> ehci , q -> async , state ) ;", "idx": 19685}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n DIAG288Class * diag288 = DIAG288_CLASS ( klass ) ; \n dc -> realize = wdt_diag288_realize ; \n dc -> unrealize = wdt_diag288_unrealize ; \n dc -> reset = wdt_diag288_reset ; \n set_bit ( DEVICE_CATEGORY_MISC , dc -> categories ) ; \n dc -> vmsd = & vmstate_diag288 ; \n diag288 -> handle_timer = wdt_diag288_handle_timer ; \n }", "idx": 19716}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsr ( DisasContext * ctx ) \n { \n #if defined ( CONFIG_USER_ONLY )  \n  \n  gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n #else \n if ( unlikely ( ctx -> pr ) ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_REG ) ; \n return ; \n } \n if ( ctx -> opcode & 0x00010000 ) { \n TCGv t0 = tcg_temp_new ( ) ; \n tcg_gen_andi_tl ( t0 , cpu_gpr [ rS ( ctx -> opcode ) ] , ( 1 << MSR_RI ) | ( 1 << MSR_EE ) ) ; \n tcg_gen_andi_tl ( cpu_msr , cpu_msr , ~ ( target_ulong ) ( ( 1 << MSR_RI ) | ( 1 << MSR_EE ) ) ) ; \n tcg_gen_or_tl ( cpu_msr , cpu_msr , t0 ) ; \n tcg_temp_free ( t0 ) ; \n } else { \n TCGv msr = tcg_temp_new ( ) ; \n gen_update_nip ( ctx , ctx -> nip ) ; \n #if defined ( TARGET_PPC64 )  \n  \n  tcg_gen_deposit_tl ( msr , cpu_msr , cpu_gpr [ rS ( ctx -> opcode ) ] , 0 , 32 ) ; \n #else \n tcg_gen_mov_tl ( msr , cpu_gpr [ rS ( ctx -> opcode ) ] ) ; \n #endif \n gen_helper_store_msr ( cpu_env , msr ) ; \n tcg_temp_free ( msr ) ; \n gen_stop_exception ( ctx ) ; \n } \n #endif \n }", "idx": 19808}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref ( FlatView * view ) \n { \n atomic_inc ( & view -> ref ) ; \n }", "idx": 19809}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static void test_task_complete ( void ) \n { \n QIOTask * task ; \n Object * obj = object_new ( TYPE_DUMMY ) ; \n Object * src ; \n struct TestTaskData data = { NULL , NULL , false } ; \n task = qio_task_new ( obj , task_callback , & data , NULL ) ; \n src = qio_task_get_source ( task ) ; \n qio_task_complete ( task ) ; \n g_assert ( obj == src ) ; \n object_unref ( obj ) ; \n object_unref ( src ) ; \n g_assert ( data . source == obj ) ; \n g_assert ( data . err == NULL ) ; \n g_assert ( data . freed == false ) ; \n }", "idx": 19834}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list ( NICInfo * nd , const char * const * models , \n const char * default_model ) \n { \n int i , exit_status = 0 ; \n if ( ! nd -> model ) \n nd -> model = strdup ( default_model ) ; \n if ( strcmp ( nd -> model , \" \" ) != 0 ) { \n for ( i = 0 ; models [ i ] ; i ++ ) \n if ( strcmp ( nd -> model , models [ i ] ) == 0 ) \n return i ; \n fprintf ( stderr , \" \\n \" , nd -> model ) ; \n exit_status = 1 ; \n } \n fprintf ( stderr , \" \" ) ; \n for ( i = 0 ; models [ i ] ; i ++ ) \n fprintf ( stderr , \" \" , models [ i ] , models [ i + 1 ] ? ' ' : ' \\n ' ) ; \n exit ( exit_status ) ; \n }", "idx": 19916}
{"project": "qemu", "commit_id": "8103b4d161d7c00ea3ff89ffe66bb2bc2c67de5d", "target": 0, "func": "static void virtio_s390_notify ( void * opaque , uint16_t vector ) \n { \n VirtIOS390Device * dev = ( VirtIOS390Device * ) opaque ; \n uint64_t token = s390_virtio_device_vq_token ( dev , vector ) ; \n kvm_s390_virtio_irq ( s390_cpu_addr2state ( 0 ) , 0 , token ) ; \n }", "idx": 19927}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static bool check_throttle_config ( ThrottleConfig * cfg , Error * * errp ) \n { \n if ( throttle_conflicting ( cfg , errp ) ) { \n return false ; \n } \n if ( ! throttle_is_valid ( cfg , errp ) ) { \n return false ; \n } \n if ( throttle_max_is_missing_limit ( cfg , errp ) ) { \n return false ; \n } \n return true ; \n }", "idx": 19962}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start ( void ) \n { \n }", "idx": 19966}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void cpu_devinit ( const char * cpu_model , unsigned int id , \n uint64_t prom_addr , qemu_irq * * cpu_irqs ) \n { \n CPUState * cs ; \n SPARCCPU * cpu ; \n CPUSPARCState * env ; \n cpu = SPARC_CPU ( cpu_generic_init ( TYPE_SPARC_CPU , cpu_model ) ) ; \n if ( cpu == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n env = & cpu -> env ; \n cpu_sparc_set_id ( env , id ) ; \n if ( id == 0 ) { \n qemu_register_reset ( main_cpu_reset , cpu ) ; \n } else { \n qemu_register_reset ( secondary_cpu_reset , cpu ) ; \n cs = CPU ( cpu ) ; \n cs -> halted = 1 ; \n } \n * cpu_irqs = qemu_allocate_irqs ( cpu_set_irq , cpu , MAX_PILS ) ; \n env -> prom_addr = prom_addr ; \n }", "idx": 19987}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static int read_naa_id ( const uint8_t * p , uint64_t * p_wwn ) \n { \n int i ; \n if ( ( p [ 1 ] & 0xF ) == 3 ) { \n if ( p [ 3 ] != 8 ) { \n return - EINVAL ; \n } \n * p_wwn = ldq_be_p ( p + 4 ) ; \n return 0 ; \n } \n if ( ( p [ 1 ] & 0xF ) == 8 ) { \n if ( p [ 3 ] < 20 || memcmp ( & p [ 4 ] , \" \" , 4 ) ) { \n return - EINVAL ; \n } \n if ( p [ 3 ] > 20 && p [ 24 ] != ' ' ) { \n return - EINVAL ; \n } \n * p_wwn = 0 ; \n for ( i = 8 ; i < 24 ; i ++ ) { \n char c = toupper ( p [ i ] ) ; \n c -= ( c >= ' ' && c <= ' ' ? ' ' : ' ' - 10 ) ; \n * p_wwn = ( * p_wwn << 4 ) | c ; \n } \n return 0 ; \n } \n return - EINVAL ; \n }", "idx": 19999}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd ( VSCSIState * s , vscsi_req * req ) \n { \n union srp_iu * srp = & req -> iu . srp ; \n SCSIDevice * sdev ; \n int n , id , lun ; \n vscsi_decode_id_lun ( be64_to_cpu ( srp -> cmd . lun ) , & id , & lun ) ; \n sdev = ( id < 8 && lun < 16 ) ? s -> bus . devs [ id ] : NULL ; \n if ( ! sdev ) { \n dprintf ( \" \\n \" , id ) ; \n if ( srp -> cmd . cdb [ 0 ] == INQUIRY ) { \n vscsi_inquiry_no_target ( s , req ) ; \n } else { \n vscsi_makeup_sense ( s , req , ILLEGAL_REQUEST , 0x24 , 0x00 ) ; \n vscsi_send_rsp ( s , req , CHECK_CONDITION , 0 , 0 ) ; \n } return 1 ; \n } \n req -> sdev = sdev ; \n req -> lun = lun ; \n n = sdev -> info -> send_command ( sdev , req -> qtag , srp -> cmd . cdb , lun ) ; \n dprintf ( \" \\n \" , \n req -> qtag , srp -> cmd . cdb [ 0 ] , id , lun , n ) ; \n if ( n ) { \n req -> writing = ( n < 1 ) ; \n vscsi_preprocess_desc ( req ) ; \n } \n if ( n > 0 ) { \n req -> data_len = n ; \n sdev -> info -> read_data ( sdev , req -> qtag ) ; \n } else if ( n < 0 ) { \n req -> data_len = - n ; \n sdev -> info -> write_data ( sdev , req -> qtag ) ; \n } \n return 0 ; \n }", "idx": 20026}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_set ( QemuOpts * opts , const char * name , const char * value ) \n { \n QemuOpt * opt ; \n opt = qemu_opt_find ( opts , name ) ; \n if ( ! opt ) { \n QemuOptDesc * desc = opts -> list -> desc ; \n int i ; \n for ( i = 0 ; desc [ i ] . name != NULL ; i ++ ) { \n if ( strcmp ( desc [ i ] . name , name ) == 0 ) { \n break ; \n } \n } \n if ( desc [ i ] . name == NULL ) { \n if ( i == 0 ) { \n ; \n } else { \n fprintf ( stderr , \" \\\" \\\" \\n \" , \n name , opts -> list -> name ) ; \n return -1 ; \n } \n } \n opt = qemu_mallocz ( sizeof ( * opt ) ) ; \n opt -> name = qemu_strdup ( name ) ; \n opt -> opts = opts ; \n TAILQ_INSERT_TAIL ( & opts -> head , opt , next ) ; \n if ( desc [ i ] . name != NULL ) { \n opt -> desc = desc + i ; \n } \n } \n qemu_free ( ( \n char * ) opt -> str ) ; \n opt -> str = NULL ; \n if ( value ) { \n opt -> str = qemu_strdup ( value ) ; \n } \n if ( qemu_opt_parse ( opt ) < 0 ) { \n fprintf ( stderr , \" \\\" \\\" \\\" \\\" \\n \" , opt -> str , \n opts -> list -> name , opt -> name ) ; \n qemu_opt_del ( opt ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 20070}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex ( EHCIState * ehci , int frames ) \n { \n int i ; \n if ( ! ehci_enabled ( ehci ) ) { \n return ; \n } \n for ( i = 0 ; i < frames ; i ++ ) { \n ehci -> frindex += 8 ; \n if ( ehci -> frindex == 0x00002000 ) { \n ehci_raise_irq ( ehci , USBSTS_FLR ) ; \n } \n if ( ehci -> frindex == 0x00004000 ) { \n ehci_raise_irq ( ehci , USBSTS_FLR ) ; \n ehci -> frindex = 0 ; \n if ( ehci -> usbsts_frindex >= 0x00004000 ) { \n ehci -> usbsts_frindex -= 0x00004000 ; \n } else { \n ehci -> usbsts_frindex = 0 ; \n } \n } \n } \n }", "idx": 20095}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static void pty_chr_state ( CharDriverState * chr , int connected ) \n { \n PtyCharDriver * s = chr -> opaque ; \n if ( ! connected ) { \n if ( s -> fd_tag ) { \n g_source_remove ( s -> fd_tag ) ; \n s -> fd_tag = 0 ; \n } \n s -> connected = 0 ; \n s -> polling = 0 ; \n pty_chr_rearm_timer ( chr , 1000 ) ; \n } else { \n if ( ! s -> connected ) \n qemu_chr_be_generic_open ( chr ) ; \n s -> connected = 1 ; \n } \n }", "idx": 20105}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void continue_after_map_failure ( void * opaque ) \n { \n DMAAIOCB * dbs = ( DMAAIOCB * ) opaque ; \n dbs -> bh = qemu_bh_new ( reschedule_dma , dbs ) ; \n qemu_bh_schedule ( dbs -> bh ) ; \n }", "idx": 20131}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector * spapr_drc_by_index ( uint32_t index ) \n { \n Object * obj ; \n char name [ 256 ] ; \n snprintf ( name , sizeof ( name ) , \" \" , DRC_CONTAINER_PATH , index ) ; \n obj = object_resolve_path ( name , NULL ) ; \n return ! obj ? NULL : SPAPR_DR_CONNECTOR ( obj ) ; \n }", "idx": 20151}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe ( const uint8_t * buf , int buf_size , const char * filename ) \n { \n const struct cow_header_v2 * cow_header = ( const void * ) buf ; \n if ( buf_size >= sizeof ( struct cow_header_v2 ) && \n be32_to_cpu ( cow_header -> magic ) == COW_MAGIC && \n be32_to_cpu ( cow_header -> version ) == COW_VERSION ) \n return 100 ; \n else \n return 0 ; \n }", "idx": 20189}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "uint64_t ram_bytes_remaining ( void ) \n { \n return ram_save_remaining ( ) * TARGET_PAGE_SIZE ; \n }", "idx": 20197}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush ( QEMUFileBuffered * s ) \n { \n size_t offset = 0 ; \n ssize_t ret = 0 ; \n DPRINTF ( \" \\n \" , s -> buffer_size ) ; \n while ( s -> bytes_xfer < s -> xfer_limit && offset < s -> buffer_size ) { \n size_t to_send = MIN ( s -> buffer_size - offset , s -> xfer_limit - s -> bytes_xfer ) ; \n ret = migrate_fd_put_buffer ( s -> migration_state , s -> buffer + offset , \n to_send ) ; \n if ( ret <= 0 ) { \n DPRINTF ( \" \\n \" , ret ) ; \n break ; \n } else { \n DPRINTF ( \" \\n \" , ret ) ; \n offset += ret ; \n s -> bytes_xfer += ret ; \n } \n } \n DPRINTF ( \" \\n \" , offset , s -> buffer_size ) ; \n memmove ( s -> buffer , s -> buffer + offset , s -> buffer_size - offset ) ; \n s -> buffer_size -= offset ; \n if ( ret < 0 ) { \n return ret ; \n } \n return offset ; \n }", "idx": 20200}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void pci_qdev_register ( PCIDeviceInfo * info ) \n { \n info -> qdev . init = pci_qdev_init ; \n info -> qdev . bus_type = BUS_TYPE_PCI ; \n qdev_register ( & info -> qdev ) ; \n }", "idx": 20213}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static void vhost_net_stop_one ( struct vhost_net * net , \n VirtIODevice * dev ) \n { \n struct vhost_vring_file file = { . fd = -1 } ; \n if ( ! net -> dev . started ) { \n return ; \n } \n if ( net -> nc -> info -> type == NET_CLIENT_OPTIONS_KIND_TAP ) { \n for ( file . index = 0 ; file . index < net -> dev . nvqs ; ++ file . index ) { \n const VhostOps * vhost_ops = net -> dev . vhost_ops ; \n int r = vhost_ops -> vhost_call ( & net -> dev , VHOST_NET_SET_BACKEND , \n & file ) ; \n assert ( r >= 0 ) ; \n } \n } \n if ( net -> nc -> info -> poll ) { \n net -> nc -> info -> poll ( net -> nc , true ) ; \n } \n vhost_dev_stop ( & net -> dev , dev ) ; \n vhost_dev_disable_notifiers ( & net -> dev , dev ) ; \n }", "idx": 20233}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_s390x_handle_mmu_fault ( CPUState * env , target_ulong address , int rw , \n int mmu_idx , int is_softmmu ) \n { \n target_ulong phys ; \n int prot ; \n phys = address ; \n prot = PAGE_READ | PAGE_WRITE ; \n return tlb_set_page ( env , address & TARGET_PAGE_MASK , \n phys & TARGET_PAGE_MASK , prot , \n mmu_idx , is_softmmu ) ; \n }", "idx": 20238}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int inc_refcounts ( BlockDriverState * bs , \n BdrvCheckResult * res , \n void * * refcount_table , \n int64_t * refcount_table_size , \n int64_t offset , int64_t size ) \n { \n BDRVQcow2State * s = bs -> opaque ; \n uint64_t start , last , cluster_offset , k , refcount ; \n int ret ; \n if ( size <= 0 ) { \n return 0 ; \n } \n start = start_of_cluster ( s , offset ) ; \n last = start_of_cluster ( s , offset + size - 1 ) ; \n for ( cluster_offset = start ; cluster_offset <= last ; \n cluster_offset += s -> cluster_size ) { \n k = cluster_offset >> s -> cluster_bits ; \n if ( k >= * refcount_table_size ) { \n ret = realloc_refcount_array ( s , refcount_table , \n refcount_table_size , k + 1 ) ; \n if ( ret < 0 ) { \n res -> check_errors ++ ; \n return ret ; \n } \n } \n refcount = s -> get_refcount ( * refcount_table , k ) ; \n if ( refcount == s -> refcount_max ) { \n fprintf ( stderr , \" \" PRIx64 \n \" \\n \" , cluster_offset ) ; \n fprintf ( stderr , \" \" \n \" \" \n \" \\n \" ) ; \n res -> corruptions ++ ; \n continue ; \n } \n s -> set_refcount ( * refcount_table , k , refcount + 1 ) ; \n } \n return 0 ; \n }", "idx": 20248}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_do_cpu_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned size ) \n { \n GICState * * backref = ( GICState * * ) opaque ; \n GICState * s = * backref ; \n int id = ( backref - s -> backref ) ; \n gic_cpu_write ( s , id , addr , value ) ; \n }", "idx": 20257}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys ( target_phys_addr_t addr , uint64_t val ) \n { \n val = cpu_to_be64 ( val ) ; \n cpu_physical_memory_write ( addr , & val , 8 ) ; \n }", "idx": 20282}
{"project": "qemu", "commit_id": "9f2130f58d5dd4e1fcb435cca08bf77e7c32e6c6", "target": 0, "func": "static int fb_initialise ( struct XenDevice * xendev ) \n { \n struct XenFB * fb = container_of ( xendev , struct XenFB , c . xendev ) ; \n struct xenfb_page * fb_page ; \n int videoram ; \n int rc ; \n if ( xenstore_read_fe_int ( xendev , \" \" , & videoram ) == -1 ) \n videoram = 0 ; \n rc = common_bind ( & fb -> c ) ; \n if ( rc != 0 ) \n return rc ; \n fb_page = fb -> c . page ; \n rc = xenfb_configure_fb ( fb , videoram * 1024 * 1024U , \n fb_page -> width , fb_page -> height , fb_page -> depth , \n fb_page -> mem_length , 0 , fb_page -> line_length ) ; \n if ( rc != 0 ) \n return rc ; \n rc = xenfb_map_fb ( fb ) ; \n if ( rc != 0 ) \n return rc ; \n #if 0  \n  \n  \n  if ( ! fb -> have_console ) { \n fb -> c . ds = graphic_console_init ( xenfb_update , \n xenfb_invalidate , \n NULL , \n NULL , \n fb ) ; \n fb -> have_console = 1 ; \n } \n #endif \n if ( xenstore_read_fe_int ( xendev , \" \" , & fb -> feature_update ) == -1 ) \n fb -> feature_update = 0 ; \n if ( fb -> feature_update ) \n xenstore_write_be_int ( xendev , \" \" , 1 ) ; \n xen_pv_printf ( xendev , 1 , \" \\n \" , \n fb -> feature_update , videoram ) ; \n return 0 ; \n }", "idx": 20283}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_exts ( int ot , TCGv reg ) \n { \n switch ( ot ) { \n case OT_BYTE : \n tcg_gen_ext8s_tl ( reg , reg ) ; \n break ; \n case OT_WORD : \n tcg_gen_ext16s_tl ( reg , reg ) ; \n break ; \n case OT_LONG : \n tcg_gen_ext32s_tl ( reg , reg ) ; \n break ; \n default : \n break ; \n } \n }", "idx": 20299}
{"project": "qemu", "commit_id": "c0462f6d75fa481f7660c15a5ca3a60205aa4eca", "target": 0, "func": "bool is_valid_option_list ( const char * param ) \n { \n size_t buflen = strlen ( param ) + 1 ; \n char * buf = g_malloc ( buflen ) ; \n const char * p = param ; \n bool result = true ; \n while ( * p ) { \n p = get_opt_value ( buf , buflen , p ) ; \n if ( * p && ! * ++ p ) { \n result = false ; \n goto out ; \n } \n if ( ! * buf || * buf == ' ' ) { \n result = false ; \n goto out ; \n } \n } \n out : \n free ( buf ) ; \n return result ; \n }", "idx": 20301}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup ( NetClientState * nc ) \n { \n NetL2TPV3State * s = DO_UPCAST ( NetL2TPV3State , nc , nc ) ; \n qemu_purge_queued_packets ( nc ) ; \n l2tpv3_read_poll ( s , false ) ; \n l2tpv3_write_poll ( s , false ) ; \n if ( s -> fd > 0 ) { \n close ( s -> fd ) ; \n } \n destroy_vector ( s -> msgvec , MAX_L2TPV3_MSGCNT , IOVSIZE ) ; \n g_free ( s -> vec ) ; \n g_free ( s -> header_buf ) ; \n g_free ( s -> dgram_dst ) ; \n }", "idx": 20327}
{"project": "qemu", "commit_id": "79d5ca5617cfc9be13a4f314ed800fca1267d903", "target": 1, "func": "static AioHandler * find_aio_handler ( int fd ) \n { \n AioHandler * node ; \n LIST_FOREACH ( node , & aio_handlers , node )  { \n if ( node -> fd == fd ) \n return node ; \n } \n return NULL ; \n }", "idx": 20328}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_flush ( BlockDriverState * bs ) \n { \n BDRVNBDState * s = bs -> opaque ; \n return nbd_client_session_co_flush ( & s -> client ) ; \n }", "idx": 20398}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned ( QEMUIOVector * qiov ) \n { \n int i ; \n for ( i = 0 ; i < qiov -> niov ; i ++ ) { \n if ( ( uintptr_t ) qiov -> iov [ i ] . iov_base % BDRV_SECTOR_SIZE ) { \n return 0 ; \n } \n } \n return 1 ; \n }", "idx": 20410}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void breakpoint_handler ( CPUState * env ) \n { \n CPUBreakpoint * bp ; \n if ( env -> watchpoint_hit ) { \n if ( env -> watchpoint_hit -> flags & BP_CPU ) { \n env -> watchpoint_hit = NULL ; \n if ( check_hw_breakpoints ( env , 0 ) ) \n raise_exception ( EXCP01_DB ) ; \n else \n cpu_resume_from_signal ( env , NULL ) ; \n } \n } else { \n TAILQ_FOREACH ( bp , & env -> breakpoints , entry )  \n if ( bp -> pc == env -> eip ) { \n if ( bp -> flags & BP_CPU ) { \n check_hw_breakpoints ( env , 1 ) ; \n raise_exception ( EXCP01_DB ) ; \n } \n break ; \n } \n } \n if ( prev_debug_excp_handler ) \n prev_debug_excp_handler ( env ) ; \n }", "idx": 20433}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event ( GtkWidget * widget , GdkEventButton * button , \n void * opaque ) \n { \n VirtualConsole * vc = opaque ; \n GtkDisplayState * s = vc -> s ; \n InputButton btn ; \n if ( button -> button == 1 && button -> type == GDK_BUTTON_PRESS && \n ! qemu_input_is_absolute ( ) && ! gd_is_grab_active ( s ) ) { \n gtk_check_menu_item_set_active ( GTK_CHECK_MENU_ITEM ( s -> grab_item ) , \n TRUE ) ; \n return TRUE ; \n } \n if ( button -> button == 1 ) { \n btn = INPUT_BUTTON_LEFT ; \n } else if ( button -> button == 2 ) { \n btn = INPUT_BUTTON_MIDDLE ; \n } else if ( button -> button == 3 ) { \n btn = INPUT_BUTTON_RIGHT ; \n } else { \n return TRUE ; \n } \n qemu_input_queue_btn ( vc -> gfx . dcl . con , btn , \n button -> type == GDK_BUTTON_PRESS ) ; \n qemu_input_event_sync ( ) ; \n return TRUE ; \n }", "idx": 20434}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in ( void * opaque , int hz ) \n { \n struct wm8750_s * s = ( struct wm8750_s * ) opaque ; \n s -> ext_adc_hz = hz ; \n s -> ext_dac_hz = hz ; \n wm8750_clk_update ( s , 1 ) ; \n }", "idx": 20471}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete ( BlockDriverState * bs ) \n { \n assert ( ! bs -> job ) ; \n assert ( bdrv_op_blocker_is_empty ( bs ) ) ; \n assert ( ! bs -> refcnt ) ; \n assert ( QLIST_EMPTY ( & bs -> dirty_bitmaps ) ) ; \n bdrv_close ( bs ) ; \n bdrv_make_anon ( bs ) ; \n g_free ( bs ) ; \n }", "idx": 20485}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay ( IOMMUMemoryRegion * iommu_mr , IOMMUNotifier * n ) \n { \n VTDAddressSpace * vtd_as = container_of ( iommu_mr , VTDAddressSpace , iommu ) ; \n IntelIOMMUState * s = vtd_as -> iommu_state ; \n uint8_t bus_n = pci_bus_num ( vtd_as -> bus ) ; \n VTDContextEntry ce ; \n vtd_address_space_unmap ( vtd_as , n ) ; \n if ( vtd_dev_to_context_entry ( s , bus_n , vtd_as -> devfn , & ce ) == 0 ) { \n trace_vtd_replay_ce_valid ( bus_n , PCI_SLOT ( vtd_as -> devfn ) , \n PCI_FUNC ( vtd_as -> devfn ) , \n VTD_CONTEXT_ENTRY_DID ( ce . hi ) , \n ce . hi , ce . lo ) ; \n vtd_page_walk ( & ce , 0 , ~ 0ULL , vtd_replay_hook , ( void * ) n , false ) ; \n } else { \n trace_vtd_replay_ce_invalid ( bus_n , PCI_SLOT ( vtd_as -> devfn ) , \n PCI_FUNC ( vtd_as -> devfn ) ) ; \n } \n return ; \n }", "idx": 20495}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr ( SDState * sd , uint32_t addr ) \n { \n return sd -> wp_groups [ addr >> \n ( HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT ) ] ; \n }", "idx": 20507}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element ( DisasContext * s , TCGv_i64 tcg_src , int destidx , \n int element , TCGMemOp memop ) \n { \n int vect_off = vec_reg_offset ( destidx , element , memop & MO_SIZE ) ; \n switch ( memop ) { \n case MO_8 : \n tcg_gen_st8_i64 ( tcg_src , cpu_env , vect_off ) ; \n break ; \n case MO_16 : \n tcg_gen_st16_i64 ( tcg_src , cpu_env , vect_off ) ; \n break ; \n case MO_32 : \n tcg_gen_st32_i64 ( tcg_src , cpu_env , vect_off ) ; \n break ; \n case MO_64 : \n tcg_gen_st_i64 ( tcg_src , cpu_env , vect_off ) ; \n break ; \n default : \n g_assert_not_reached ( ) ; \n } \n }", "idx": 20520}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_ext_h ( void ( * tcg_gen_ext_i64 ) ( TCGv t0 , TCGv t1 ) , \n int ra , int rb , int rc , \n int islit , uint8_t lit ) \n { \n if ( unlikely ( rc == 31 ) ) \n return ; \n if ( ra != 31 ) { \n if ( islit ) { \n if ( lit != 0 ) \n tcg_gen_shli_i64 ( cpu_ir [ rc ] , cpu_ir [ ra ] , 64 - ( ( lit & 7 ) * 8 ) ) ; \n else \n tcg_gen_mov_i64 ( cpu_ir [ rc ] , cpu_ir [ ra ] ) ; \n } else { \n TCGv tmp1 , tmp2 ; \n tmp1 = tcg_temp_new ( TCG_TYPE_I64 ) ; \n tcg_gen_andi_i64 ( tmp1 , cpu_ir [ rb ] , 7 ) ; \n tcg_gen_shli_i64 ( tmp1 , tmp1 , 3 ) ; \n tmp2 = tcg_const_i64 ( 64 ) ; \n tcg_gen_sub_i64 ( tmp1 , tmp2 , tmp1 ) ; \n tcg_temp_free ( tmp2 ) ; \n tcg_gen_shl_i64 ( cpu_ir [ rc ] , cpu_ir [ ra ] , tmp1 ) ; \n tcg_temp_free ( tmp1 ) ; \n } \n if ( tcg_gen_ext_i64 ) \n tcg_gen_ext_i64 ( cpu_ir [ rc ] , cpu_ir [ rc ] ) ; \n } else \n tcg_gen_movi_i64 ( cpu_ir [ rc ] , 0 ) ; \n }", "idx": 20531}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_mmio_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n LSIState * s = opaque ; \n return lsi_reg_readb ( s , addr & 0xff ) ; \n }", "idx": 20548}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free ( envlist_t * envlist )  \n { \n struct envlist_entry * entry ; \n assert ( envlist != NULL ) ; \n while ( envlist -> el_entries . lh_first != NULL ) { \n entry = envlist -> el_entries . lh_first ; \n LIST_REMOVE ( entry , ev_link ) ; \n free ( ( char * ) entry -> ev_var ) ; \n free ( entry ) ; \n } \n free ( envlist ) ; \n }", "idx": 20553}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable ( void ) \n { \n AHCIQState * ahci ; \n ahci = ahci_boot ( ) ; \n ahci_pci_enable ( ahci ) ; \n ahci_hba_enable ( ahci ) ; \n ahci_shutdown ( ahci ) ; \n }", "idx": 20562}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2 ( sqrtt ) \n IEEE_ARITH2 ( cvtst )  \n IEEE_ARITH2 ( cvtts ) \n static void gen_cvttq ( DisasContext * ctx , int rb , int rc , int fn11 ) \n { \n TCGv vb , vc ; \n vb = gen_ieee_input ( ctx , rb , fn11 , 0 ) ; \n vc = dest_fpr ( ctx , rc ) ; \n switch ( fn11 ) { \n case QUAL_RM_C : \n gen_helper_cvttq_c ( vc , cpu_env , vb ) ; \n break ; \n case QUAL_V | QUAL_RM_C : \n case QUAL_S | QUAL_V | QUAL_RM_C : \n case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C : \n gen_helper_cvttq_svic ( vc , cpu_env , vb ) ; \n break ; \n default : \n gen_qual_roundmode ( ctx , fn11 ) ; \n gen_helper_cvttq ( vc , cpu_env , vb ) ; \n break ; \n } \n gen_fp_exc_raise ( rc , fn11 ) ; \n }", "idx": 20631}
{"project": "qemu", "commit_id": "0e86c13fe2058adb8c792ebb7c51a6a7ca9d3d55", "target": 1, "func": "static int virtio_serial_device_exit ( DeviceState * dev ) \n { \n VirtIOSerial * vser = VIRTIO_SERIAL ( dev ) ; \n VirtIODevice * vdev = VIRTIO_DEVICE ( dev ) ; \n unregister_savevm ( dev , \" \" , vser ) ; \n g_free ( vser -> ivqs ) ; \n g_free ( vser -> ovqs ) ; \n g_free ( vser -> ports_map ) ; \n if ( vser -> post_load ) { \n g_free ( vser -> post_load -> connected ) ; \n timer_del ( vser -> post_load -> timer ) ; \n timer_free ( vser -> post_load -> timer ) ; \n g_free ( vser -> post_load ) ; \n } \n virtio_cleanup ( vdev ) ; \n return 0 ; \n }", "idx": 20643}
{"project": "qemu", "commit_id": "5666ca4ae06d20497f887241151278e266947087", "target": 1, "func": "int kvm_arch_init_vcpu ( CPUState * cenv ) \n { \n int ret = 0 ; \n struct kvm_sregs sregs ; \n sregs . pvr = cenv -> spr [ SPR_PVR ] ; \n ret = kvm_vcpu_ioctl ( cenv , KVM_SET_SREGS , & sregs ) ; \n idle_timer = qemu_new_timer_ns ( vm_clock , kvm_kick_env , cenv ) ; \n return ret ; \n }", "idx": 20644}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq ( VirtQueue * vq ) \n { \n if ( vq -> vring . desc && vq -> handle_output ) { \n VirtIODevice * vdev = vq -> vdev ; \n trace_virtio_queue_notify ( vdev , vq - vdev -> vq , vq ) ; \n vq -> handle_output ( vdev , vq ) ;", "idx": 20647}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer ( CPUPPCState * env , uint32_t value ) \n { \n xer_so = ( value >> XER_SO ) & 0x01 ; \n xer_ov = ( value >> XER_OV ) & 0x01 ; \n xer_ca = ( value >> XER_CA ) & 0x01 ; \n xer_cmp = ( value >> XER_CMP ) & 0xFF ; \n xer_bc = ( value >> XER_BC ) & 0x3F ; \n }", "idx": 20716}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_enum ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n EnumProperty * prop = opaque ; \n int value ; \n value = prop -> get ( obj , errp ) ; \n visit_type_enum ( v , & value , prop -> strings , NULL , name , errp ) ; \n }", "idx": 20722}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol ( const char * path ) \n { \n #ifdef _WIN32 \n if ( is_windows_drive ( path ) || \n is_windows_drive_prefix ( path ) ) { \n return 0 ; \n } \n #endif \n return strchr ( path , ' ' ) != NULL ; \n }", "idx": 20728}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_write ( AddressSpace * as , target_phys_addr_t addr , \n const uint8_t * buf , int len ) \n { \n address_space_rw ( as , addr , ( uint8_t * ) buf , len , true ) ; \n }", "idx": 20743}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_run_capture ( AudioState * s ) \n { \n CaptureVoiceOut * cap ; \n for ( cap = s -> cap_head . lh_first ; cap ; cap = cap -> entries . le_next ) { \n int live , rpos , captured ; \n HWVoiceOut * hw = & cap -> hw ; \n SWVoiceOut * sw ; \n captured = live = audio_pcm_hw_get_live_out ( hw ) ; \n rpos = hw -> rpos ; \n while ( live ) { \n int left = hw -> samples - rpos ; \n int to_capture = audio_MIN ( live , left ) ; \n st_sample_t * src ; \n struct capture_callback * cb ; \n src = hw -> mix_buf + rpos ; \n hw -> clip ( cap -> buf , src , to_capture ) ; \n mixeng_clear ( src , to_capture ) ; \n for ( cb = cap -> cb_head . lh_first ; cb ; cb = cb -> entries . le_next ) { \n cb -> ops . capture ( cb -> opaque , cap -> buf , \n to_capture << hw -> info . shift ) ; \n } \n rpos = ( rpos + to_capture ) % hw -> samples ; \n live -= to_capture ; \n } \n hw -> rpos = rpos ; \n for ( sw = hw -> sw_head . lh_first ; sw ; sw = sw -> entries . le_next ) { \n if ( ! sw -> active && sw -> empty ) { \n continue ; \n } \n if ( audio_bug ( AUDIO_FUNC , captured > sw -> total_hw_samples_mixed ) ) { \n dolog ( \" \\n \" , \n captured , sw -> total_hw_samples_mixed ) ; \n captured = sw -> total_hw_samples_mixed ; \n } \n sw -> total_hw_samples_mixed -= captured ; \n sw -> empty = sw -> total_hw_samples_mixed == 0 ; \n } \n } \n }", "idx": 20751}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState * qemu_chr_alloc ( void ) \n { \n CharDriverState * chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n return chr ; \n }", "idx": 20761}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ecc_init ( target_phys_addr_t base , qemu_irq irq , uint32_t version ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_prop_set_uint32 ( dev , \" \" , version ) ; \n qdev_init ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n sysbus_connect_irq ( s , 0 , irq ) ; \n sysbus_mmio_map ( s , 0 , base ) ; \n if ( version == 0 ) { \n sysbus_mmio_map ( s , 1 , base + 0x1000 ) ; \n } \n }", "idx": 20766}
{"project": "qemu", "commit_id": "293d2a0014a0e849477413f55aaa05f2743b2e04", "target": 0, "func": "static gboolean monitor_unblocked ( GIOChannel * chan , GIOCondition cond , \n void * opaque ) \n { \n monitor_flush ( opaque ) ; \n return FALSE ; \n }", "idx": 20802}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_store_spr ( int reg , TCGv t ) \n { \n tcg_gen_st_tl ( t , cpu_env , offsetof ( CPUState , spr [ reg ] ) ) ; \n }", "idx": 20803}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_read_only ( BlockDriverState * bs ) \n { \n return bs -> read_only ; \n }", "idx": 20811}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bw_conf1_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n PCIBus * b = opaque ; \n pci_data_write ( b , addr , val , size ) ; \n }", "idx": 20812}
{"project": "qemu", "commit_id": "54ca9095f046dfa03c3d093cc55f6d76b61864e1", "target": 0, "func": "void tlb_fill ( target_ulong addr , int is_write , int is_user , void * retaddr ) \n { \n TranslationBlock * tb ; \n int ret ; \n unsigned long pc ; \n CPUX86State * saved_env ; \n saved_env = env ; \n env = cpu_single_env ; \n ret = cpu_x86_handle_mmu_fault ( env , addr , is_write , is_user , 1 ) ; \n if ( ret ) { \n if ( retaddr ) { \n pc = ( unsigned long ) retaddr ; \n tb = tb_find_pc ( pc ) ; \n if ( tb ) { \n cpu_restore_state ( tb , env , pc , NULL ) ; \n } \n } \n if ( retaddr ) \n raise_exception_err ( EXCP0E_PAGE , env -> error_code ) ; \n else \n raise_exception_err_norestore ( EXCP0E_PAGE , env -> error_code ) ; \n } \n env = saved_env ; \n }", "idx": 20831}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits ( void ) \n { \n TestData d ; \n uint16_t ticks = 8 ; \n uint16_t val ; \n int ret ; \n d . args = NULL ; \n d . noreboot = true ; \n test_init ( & d ) ; \n stop_tco ( & d ) ; \n clear_tco_status ( & d ) ; \n reset_on_second_timeout ( false ) ; \n set_tco_timeout ( & d , ticks ) ; \n load_tco ( & d ) ; \n start_tco ( & d ) ; \n clock_step ( ticks * TCO_TICK_NSEC ) ; \n qpci_io_writeb ( d . dev , d . tco_io_base + TCO_DAT_IN , 0 ) ; \n qpci_io_writeb ( d . dev , d . tco_io_base + TCO_DAT_OUT , 0 ) ; \n val = qpci_io_readw ( d . dev , d . tco_io_base + TCO1_STS ) ; \n ret = val & ( TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS ) ? 1 : 0 ; \n g_assert ( ret == 1 ) ; \n qpci_io_writew ( d . dev , d . tco_io_base + TCO1_STS , val ) ; \n g_assert_cmpint ( qpci_io_readw ( d . dev , d . tco_io_base + TCO1_STS ) , == , 0 ) ; \n qtest_end ( ) ; \n }", "idx": 20835}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init ( QCryptoBlockFormat  format , \n QemuOpts  * opts , \n Error * * errp ) \n { \n OptsVisitor * ov ; \n QCryptoBlockCreateOptions * ret = NULL ; \n Error * local_err = NULL ; \n ret = g_new0 ( QCryptoBlockCreateOptions , 1 ) ; \n ret -> format = format ; \n ov = opts_visitor_new ( opts ) ; \n visit_start_struct ( opts_get_visitor ( ov ) , \n NULL , NULL , 0 , & local_err ) ; \n if ( local_err ) { \n goto out ; \n } \n switch ( format ) { \n case Q_CRYPTO_BLOCK_FORMAT_LUKS : \n visit_type_QCryptoBlockCreateOptionsLUKS_members ( \n opts_get_visitor ( ov ) , & ret -> u . luks , & local_err ) ; \n break ; \n default : \n error_setg ( & local_err , \" \" , format ) ; \n break ; \n } \n error_propagate ( errp , local_err ) ; \n local_err = NULL ; \n visit_end_struct ( opts_get_visitor ( ov ) , & local_err ) ; \n out : \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n qapi_free_QCryptoBlockCreateOptions ( ret ) ; \n ret = NULL ; \n } \n opts_visitor_cleanup ( ov ) ; \n return ret ; \n }", "idx": 20840}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_list ( gpointer key , gpointer opaque ) \n { \n ARMCPU * cpu = opaque ; \n uint64_t regidx ; \n const ARMCPRegInfo * ri ; \n regidx = * ( uint32_t * ) key ; \n ri = get_arm_cp_reginfo ( cpu -> cp_regs , regidx ) ; \n if ( ! ( ri -> type & ARM_CP_NO_MIGRATE ) ) { \n cpu -> cpreg_indexes [ cpu -> cpreg_array_len ] = cpreg_to_kvm_id ( regidx ) ; \n cpu -> cpreg_array_len ++ ; \n } \n }", "idx": 20902}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static inline int alarm_has_dynticks ( struct qemu_alarm_timer * t ) \n { \n return t && t -> rearm ; \n }", "idx": 20908}
{"project": "qemu", "commit_id": "26e92f65525ef4446a500d85e185cf78835922aa", "target": 0, "func": "static uint32_t arm_sysctl_read ( void * opaque , target_phys_addr_t offset ) \n { \n arm_sysctl_state * s = ( arm_sysctl_state * ) opaque ; \n switch ( offset ) { \n case 0x00 : \n return s -> sys_id ; \n case 0x04 : \n return 0 ; \n case 0x08 : \n return s -> leds ; \n case 0x20 : \n return s -> lockval ; \n case 0x0c : \n case 0x10 : \n case 0x14 : \n case 0x18 : \n case 0x1c : \n case 0x24 : \n return 0 ; \n case 0x28 : \n return s -> cfgdata1 ; \n case 0x2c : \n return s -> cfgdata2 ; \n case 0x30 : \n return s -> flags ; \n case 0x38 : \n return s -> nvflags ; \n case 0x40 : \n return s -> resetlevel ; \n case 0x44 : \n return 1 ; \n case 0x48 : \n return 0 ; \n case 0x4c : \n return 0 ; \n case 0x50 : \n return 0x1000 ; \n case 0x54 : \n return 0 ; \n case 0x58 : \n return 0 ; \n case 0x5c : \n return muldiv64 ( qemu_get_clock ( vm_clock ) , 24000000 , get_ticks_per_sec ( ) ) ; \n case 0x60 : \n return 0 ; \n case 0x84 : \n return 0x02000000 ; \n case 0x88 : \n return 0xff000000 ; \n case 0x64 : \n case 0x68 : \n case 0x6c : \n case 0x70 : \n case 0x74 : \n case 0x80 : \n case 0x8c : \n case 0x90 : \n case 0x94 : \n case 0x98 : \n case 0x9c : \n case 0xc0 : \n case 0xc4 : \n case 0xc8 : \n case 0xcc : \n case 0xd0 : \n return 0 ; \n default : \n printf ( \" \\n \" , ( int ) offset ) ; \n return 0 ; \n } \n }", "idx": 20938}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "void run_on_cpu ( CPUState * cpu , void ( * func ) ( void * data ) , void * data ) \n { \n struct qemu_work_item wi ; \n if ( qemu_cpu_is_self ( cpu ) ) { \n func ( data ) ; \n return ; \n } \n wi . func = func ; \n wi . data = data ; \n wi . free = false ; \n if ( cpu -> queued_work_first == NULL ) { \n cpu -> queued_work_first = & wi ; \n } else { \n cpu -> queued_work_last -> next = & wi ; \n } \n cpu -> queued_work_last = & wi ; \n wi . next = NULL ; \n wi . done = false ; \n qemu_cpu_kick ( cpu ) ; \n while ( ! wi . done ) { \n CPUState * self_cpu = current_cpu ; \n qemu_cond_wait ( & qemu_work_cond , & qemu_global_mutex ) ; \n current_cpu = self_cpu ; \n } \n }", "idx": 20945}
{"project": "qemu", "commit_id": "a659979328fb6d4d6100d398f5bd9a2310c3e169", "target": 0, "func": "open_f ( int  argc , char * * argv ) \n { \n int flags = 0 ; \n int readonly = 0 ; \n int growable = 0 ; \n int c ; \n while ( ( c = getopt ( argc , argv , \" \" ) ) != EOF ) { \n switch ( c ) { \n case ' ' : \n flags |= BDRV_O_SNAPSHOT ; \n break ; \n case ' ' : \n flags |= BDRV_O_NOCACHE ; \n break ; \n case ' ' : \n readonly = 1 ; \n break ; \n case ' ' : \n growable = 1 ; \n break ; \n default : \n return command_usage ( & open_cmd ) ; \n } \n } \n if ( ! readonly ) { \n flags |= BDRV_O_RDWR ; \n } \n if ( optind != argc - 1 ) \n return command_usage ( & open_cmd ) ; \n return openfile ( argv [ optind ] , flags , growable ) ; \n }", "idx": 20970}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static unsigned int event_status_media ( IDEState * s , \n uint8_t * buf ) \n { \n uint8_t event_code , media_status ; \n media_status = 0 ; \n if ( s -> tray_open ) { \n media_status = MS_TRAY_OPEN ; \n } else if ( bdrv_is_inserted ( s -> bs ) ) { \n media_status = MS_MEDIA_PRESENT ; \n } \n event_code = MEC_NO_CHANGE ; \n if ( media_status != MS_TRAY_OPEN ) { \n if ( s -> events . new_media ) { \n event_code = MEC_NEW_MEDIA ; \n s -> events . new_media = false ; \n } else if ( s -> events . eject_request ) { \n event_code = MEC_EJECT_REQUESTED ; \n s -> events . eject_request = false ; \n } \n } \n buf [ 4 ] = event_code ; \n buf [ 5 ] = media_status ; \n buf [ 6 ] = 0 ; \n buf [ 7 ] = 0 ; \n return 8 ; \n }", "idx": 20975}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_scsi_hotunplug ( HotplugHandler * hotplug_dev , DeviceState * dev , \n Error * * errp ) \n { \n VirtIODevice * vdev = VIRTIO_DEVICE ( hotplug_dev ) ; \n VirtIOSCSI * s = VIRTIO_SCSI ( vdev ) ; \n SCSIDevice * sd = SCSI_DEVICE ( dev ) ; \n if ( ( vdev -> guest_features >> VIRTIO_SCSI_F_HOTPLUG ) & 1 ) { \n virtio_scsi_push_event ( s , sd , \n VIRTIO_SCSI_T_TRANSPORT_RESET , \n VIRTIO_SCSI_EVT_RESET_REMOVED ) ; \n } \n if ( s -> ctx ) { \n blk_op_unblock_all ( sd -> conf . blk , s -> blocker ) ; \n } \n qdev_simple_device_unplug_cb ( hotplug_dev , dev , errp ) ; \n }", "idx": 20994}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_connect_sync ( QIOChannelSocket * ioc , \n SocketAddress * addr , \n Error * * errp ) \n { \n int fd ; \n trace_qio_channel_socket_connect_sync ( ioc , addr ) ; \n fd = socket_connect ( addr , NULL , NULL , errp ) ; \n if ( fd < 0 ) { \n trace_qio_channel_socket_connect_fail ( ioc ) ; \n return -1 ; \n } \n trace_qio_channel_socket_connect_complete ( ioc , fd ) ; \n if ( qio_channel_socket_set_fd ( ioc , fd , errp ) < 0 ) { \n close ( fd ) ; \n return -1 ; \n } \n return 0 ; \n }", "idx": 20996}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid ( uint32_t function , uint32_t count , \n uint32_t * eax , uint32_t * ebx , \n uint32_t * ecx , uint32_t * edx ) \n { \n #if defined ( CONFIG_KVM )  \n  \n  uint32_t vec [ 4 ] ; \n #ifdef __x86_64__ \n asm volatile ( \" \" \n : \" \" ( vec [ 0 ] ) , \" \" ( vec [ 1 ] ) , \n \" \" ( vec [ 2 ] ) , \" \" ( vec [ 3 ] ) \n : \" \" ( function ) , \" \" ( count ) : \" \" ) ; \n #else \n asm volatile ( \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \\n \\t \" \n \" \" \n : : \" \" ( function ) , \" \" ( count ) , \" \" ( vec ) \n : \" \" , \" \" ) ; \n #endif \n if ( eax ) \n * eax = vec [ 0 ] ; \n if ( ebx ) \n * ebx = vec [ 1 ] ; \n if ( ecx ) \n * ecx = vec [ 2 ] ; \n if ( edx ) \n * edx = vec [ 3 ] ; \n #endif \n }", "idx": 21034}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_mmio_map ( PCIDevice * d , int region_num , \n pcibus_t addr , pcibus_t size , int type ) \n { \n int mmio_io_addr ; \n mmio_io_addr = cpu_register_io_memory_simple ( & platform_mmio_handler , \n DEVICE_NATIVE_ENDIAN ) ; \n cpu_register_physical_memory ( addr , size , mmio_io_addr ) ; \n }", "idx": 21092}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int kvm_s390_register_io_adapter ( S390FLICState * fs , uint32_t id , \n uint8_t isc , bool swap , \n bool is_maskable ) \n { \n struct kvm_s390_io_adapter adapter = { \n . id = id , \n . isc = isc , \n . maskable = is_maskable , \n . swap = swap , \n } ; \n KVMS390FLICState * flic = KVM_S390_FLIC ( fs ) ; \n int r , ret ; \n struct kvm_device_attr attr = { \n . group = KVM_DEV_FLIC_ADAPTER_REGISTER , \n . addr = ( uint64_t ) & adapter , \n } ; \n if ( ! kvm_check_extension ( kvm_state , KVM_CAP_IRQ_ROUTING ) ) { \n return 0 ; \n } \n r = ioctl ( flic -> fd , KVM_SET_DEVICE_ATTR , & attr ) ; \n ret = r ? - errno : 0 ; \n return ret ; \n }", "idx": 21102}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock ( QEMUTimerList * timer_list ) \n { \n return timer_list -> clock -> type ; \n }", "idx": 21110}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize ( Object * obj ) \n { \n QIOChannelCommand * ioc = QIO_CHANNEL_COMMAND ( obj ) ; \n if ( ioc -> readfd != -1 ) { \n close ( ioc -> readfd ) ; \n ioc -> readfd = -1 ; \n } \n if ( ioc -> writefd != -1 ) { \n close ( ioc -> writefd ) ; \n ioc -> writefd = -1 ; \n } \n if ( ioc -> pid > 0 ) { \n #ifndef WIN32 \n qio_channel_command_abort ( ioc , NULL ) ; \n #endif \n } \n }", "idx": 21135}
{"project": "qemu", "commit_id": "970d622e8ab1de8fdf5762e23e92a2dea9d7d36c", "target": 0, "func": "uint64_t helper_cmpbge ( uint64_t op1 , uint64_t op2 ) \n { \n uint8_t opa , opb , res ; \n int i ; \n res = 0 ; \n for ( i = 0 ; i < 7 ; i ++ ) { \n opa = op1 >> ( i * 8 ) ; \n opb = op2 >> ( i * 8 ) ; \n if ( opa >= opb ) \n res |= 1 << i ; \n } \n return res ; \n }", "idx": 21218}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse ( const char * devname ) \n { \n QemuOptsList * device = qemu_find_opts ( \" \" ) ; \n static int index = 0 ; \n char label [ 32 ] ; \n QemuOpts * bus_opts , * dev_opts ; \n if ( strcmp ( devname , \" \" ) == 0 ) \n return 0 ; \n if ( index == MAX_VIRTIO_CONSOLES ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n bus_opts = qemu_opts_create ( device , NULL , 0 ) ; \n if ( arch_type == QEMU_ARCH_S390X ) { \n qemu_opt_set ( bus_opts , \" \" , \" \" ) ; \n } else { \n qemu_opt_set ( bus_opts , \" \" , \" \" ) ; \n } \n dev_opts = qemu_opts_create ( device , NULL , 0 ) ; \n qemu_opt_set ( dev_opts , \" \" , \" \" ) ; \n snprintf ( label , sizeof ( label ) , \" \" , index ) ; \n virtcon_hds [ index ] = qemu_chr_new ( label , devname , NULL ) ; \n if ( ! virtcon_hds [ index ] ) { \n fprintf ( stderr , \" \\n \" , \n devname , strerror ( errno ) ) ; \n return -1 ; \n } \n qemu_opt_set ( dev_opts , \" \" , label ) ; \n index ++ ; \n return 0 ; \n }", "idx": 21250}
{"project": "qemu", "commit_id": "6cff3e8594cd974a507d531da09455d1c7aeb30d", "target": 0, "func": "static void monitor_puts ( Monitor * mon , const char * str ) \n { \n char c ; \n for ( ; ; ) { \n c = * str ++ ; \n if ( c == ' \\0 ' ) \n break ; \n if ( c == ' \\n ' ) { \n qstring_append_chr ( mon -> outbuf , ' \\r ' ) ; \n } \n qstring_append_chr ( mon -> outbuf , c ) ; \n if ( c == ' \\n ' ) { \n monitor_flush ( mon ) ; \n } \n } \n }", "idx": 21256}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0 ( DisasContext * s , int seg_reg ) \n { \n if ( s -> pe && ! s -> vm86 ) { \n tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; \n gen_helper_load_seg ( cpu_env , tcg_const_i32 ( seg_reg ) , cpu_tmp2_i32 ) ; \n if ( seg_reg == R_SS || ( s -> code32 && seg_reg < R_FS ) ) \n s -> is_jmp = DISAS_TB_JUMP ; \n } else { \n gen_op_movl_seg_T0_vm ( seg_reg ) ; \n if ( seg_reg == R_SS ) \n s -> is_jmp = DISAS_TB_JUMP ; \n } \n }", "idx": 21261}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd ( NvmeCtrl * n , NvmeCmd * cmd , NvmeRequest * req ) \n { \n NvmeNamespace * ns ; \n uint32_t nsid = le32_to_cpu ( cmd -> nsid ) ; \n if ( nsid == 0 || nsid > n -> num_namespaces ) { \n return NVME_INVALID_NSID | NVME_DNR ; \n } \n ns = & n -> namespaces [ nsid - 1 ] ; \n switch ( cmd -> opcode ) { \n case NVME_CMD_FLUSH : \n return nvme_flush ( n , ns , cmd , req ) ; \n case NVME_CMD_WRITE_ZEROS : \n return nvme_write_zeros ( n , ns , cmd , req ) ; \n case NVME_CMD_WRITE : \n case NVME_CMD_READ : \n return nvme_rw ( n , ns , cmd , req ) ; \n default : \n return NVME_INVALID_OPCODE | NVME_DNR ; \n } \n }", "idx": 21296}
{"project": "qemu", "commit_id": "375cb560295484b88898262ebf400eff9a011206", "target": 0, "func": "static uint64_t pl110_read ( void * opaque , hwaddr offset , \n unsigned size ) \n { \n pl110_state * s = ( pl110_state * ) opaque ; \n if ( offset >= 0xfe0 && offset < 0x1000 ) { \n return idregs [ s -> version ] [ ( offset - 0xfe0 ) >> 2 ] ; \n } \n if ( offset >= 0x200 && offset < 0x400 ) { \n return s -> raw_palette [ ( offset - 0x200 ) >> 2 ] ; \n } \n switch ( offset >> 2 ) { \n case 0 : \n return s -> timing [ 0 ] ; \n case 1 : \n return s -> timing [ 1 ] ; \n case 2 : \n return s -> timing [ 2 ] ; \n case 3 : \n return s -> timing [ 3 ] ; \n case 4 : \n return s -> upbase ; \n case 5 : \n return s -> lpbase ; \n case 6 : \n if ( s -> version != PL110 ) { \n return s -> cr ; \n } \n return s -> int_mask ; \n case 7 : \n if ( s -> version != PL110 ) { \n return s -> int_mask ; \n } \n return s -> cr ; \n case 8 : \n return s -> int_status ; \n case 9 : \n return s -> int_status & s -> int_mask ; \n case 11 : \n return s -> upbase ; \n case 12 : \n return s -> lpbase ; \n default : \n hw_error ( \" \\n \" , ( int ) offset ) ; \n return 0 ; \n } \n }", "idx": 21306}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_start ( MemoryListener * listener , \n MemoryRegionSection * section ) \n { \n XenIOState * state = container_of ( listener , XenIOState , memory_listener ) ; \n xen_sync_dirty_bitmap ( state , section -> offset_within_address_space , \n int128_get64 ( section -> size ) ) ; \n }", "idx": 21348}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "func": "static void test_smbios_ep_address ( test_data * data ) \n { \n uint32_t off ; \n for ( off = 0xf0000 ; off < 0x100000 ; off += 0x10 ) { \n uint8_t sig [ ] = \" \" ; \n int i ; \n for ( i = 0 ; i < sizeof sig - 1 ; ++ i ) { \n sig [ i ] = readb ( off + i ) ; \n } \n if ( ! memcmp ( sig , \" \" , sizeof sig ) ) { \n break ; \n } \n } \n g_assert_cmphex ( off , < , 0x100000 ) ; \n data -> smbios_ep_addr = off ; \n }", "idx": 21383}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init ( DisplayState * ds ) \n { \n assert ( sdpy . ds == NULL ) ; \n qemu_spice_display_init_common ( & sdpy , ds ) ; \n register_displaychangelistener ( ds , & display_listener ) ; \n sdpy . qxl . base . sif = & dpy_interface . base ; \n qemu_spice_add_interface ( & sdpy . qxl . base ) ; \n assert ( sdpy . worker ) ; \n qemu_spice_create_host_memslot ( & sdpy ) ; \n qemu_spice_create_host_primary ( & sdpy ) ; \n }", "idx": 21392}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int qcow2_is_allocated ( BlockDriverState * bs , int64_t sector_num , \n int nb_sectors , int * pnum ) \n { \n uint64_t cluster_offset ; \n int ret ; \n * pnum = nb_sectors ; \n ret = qcow2_get_cluster_offset ( bs , sector_num << 9 , pnum , & cluster_offset ) ; \n if ( ret < 0 ) { \n * pnum = 0 ; \n } \n return ( cluster_offset != 0 ) ; \n }", "idx": 21411}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_test_apply ( MigrateSetParameters * params , \n MigrationParameters * dest ) \n { \n * dest = migrate_get_current ( ) -> parameters ; \n if ( params -> has_compress_level ) { \n dest -> compress_level = params -> compress_level ; \n } \n if ( params -> has_compress_threads ) { \n dest -> compress_threads = params -> compress_threads ; \n } \n if ( params -> has_decompress_threads ) { \n dest -> decompress_threads = params -> decompress_threads ; \n } \n if ( params -> has_cpu_throttle_initial ) { \n dest -> cpu_throttle_initial = params -> cpu_throttle_initial ; \n } \n if ( params -> has_cpu_throttle_increment ) { \n dest -> cpu_throttle_increment = params -> cpu_throttle_increment ; \n } \n if ( params -> has_tls_creds ) { \n dest -> tls_creds = g_strdup ( params -> tls_creds ) ; \n } \n if ( params -> has_tls_hostname ) { \n dest -> tls_hostname = g_strdup ( params -> tls_hostname ) ; \n } \n if ( params -> has_max_bandwidth ) { \n dest -> max_bandwidth = params -> max_bandwidth ; \n } \n if ( params -> has_downtime_limit ) { \n dest -> downtime_limit = params -> downtime_limit ; \n } \n if ( params -> has_x_checkpoint_delay ) { \n dest -> x_checkpoint_delay = params -> x_checkpoint_delay ; \n } \n if ( params -> has_block_incremental ) { \n dest -> block_incremental = params -> block_incremental ; \n } \n }", "idx": 21413}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked ( BlockDriverState * bs , BlockOpType op , Error * * errp ) \n { \n BdrvOpBlocker * blocker ; \n assert ( ( int ) op >= 0 && op < BLOCK_OP_TYPE_MAX ) ; \n if ( ! QLIST_EMPTY ( & bs -> op_blockers [ op ] ) ) { \n blocker = QLIST_FIRST ( & bs -> op_blockers [ op ] ) ; \n if ( errp ) { \n * errp = error_copy ( blocker -> reason ) ; \n error_prepend ( errp , \" \" , \n bdrv_get_device_or_node_name ( bs ) ) ; \n } \n return true ; \n } \n return false ; \n }", "idx": 21430}
{"project": "qemu", "commit_id": "3ddf3efefa364505ee44582873612dd8f6abb838", "target": 0, "func": "static BlockJob * find_block_job ( const char * device , AioContext * * aio_context , \n Error * * errp ) \n { \n BlockBackend * blk ; \n BlockDriverState * bs ; \n * aio_context = NULL ; \n blk = blk_by_name ( device ) ; \n if ( ! blk ) { \n goto notfound ; \n } \n * aio_context = blk_get_aio_context ( blk ) ; \n aio_context_acquire ( * aio_context ) ; \n if ( ! blk_is_available ( blk ) ) { \n goto notfound ; \n } \n bs = blk_bs ( blk ) ; \n if ( ! bs -> job ) { \n goto notfound ; \n } \n return bs -> job ; \n notfound : \n error_set ( errp , ERROR_CLASS_DEVICE_NOT_ACTIVE , \n \" \" , device ) ; \n if ( * aio_context ) { \n aio_context_release ( * aio_context ) ; \n * aio_context = NULL ; \n } \n return NULL ; \n }", "idx": 21435}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse ( const char * str ) \n { \n struct HCIInfo * hci ; \n bdaddr_t bdaddr ; \n if ( nb_hcis >= MAX_NICS ) { \n fprintf ( stderr , \" \\n \" , MAX_NICS ) ; \n return -1 ; \n } \n hci = hci_init ( str ) ; \n if ( ! hci ) \n return -1 ; \n bdaddr . b [ 0 ] = 0x52 ; \n bdaddr . b [ 1 ] = 0x54 ; \n bdaddr . b [ 2 ] = 0x00 ; \n bdaddr . b [ 3 ] = 0x12 ; \n bdaddr . b [ 4 ] = 0x34 ; \n bdaddr . b [ 5 ] = 0x56 + nb_hcis ; \n hci -> bdaddr_set ( hci , bdaddr . b ) ; \n hci_table [ nb_hcis ++ ] = hci ; \n return 0 ; \n }", "idx": 21450}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dst ( DisasContext * ctx ) \n { \n if ( rA ( ctx -> opcode ) == 0 ) { \n gen_inval_exception ( ctx , POWERPC_EXCP_INVAL_LSWX ) ; \n } else { \n } \n }", "idx": 21466}
{"project": "qemu", "commit_id": "96193c22ab39ea24f81e386ad7883260ff24f5fd", "target": 0, "func": "static void x86_cpu_enable_xsave_components ( X86CPU * cpu ) \n { \n CPUX86State * env = & cpu -> env ; \n int i ; \n if ( ! ( env -> features [ FEAT_1_ECX ] & CPUID_EXT_XSAVE ) ) { \n return ; \n } \n env -> xsave_components = ( XSTATE_FP_MASK | XSTATE_SSE_MASK ) ; \n for ( i = 2 ; i < ARRAY_SIZE ( x86_ext_save_areas ) ; i ++ ) { \n const ExtSaveArea * esa = & x86_ext_save_areas [ i ] ; \n if ( env -> features [ esa -> feature ] & esa -> bits ) { \n env -> xsave_components |= ( 1ULL << i ) ; \n } \n } \n if ( kvm_enabled ( ) ) { \n KVMState * s = kvm_state ; \n uint64_t kvm_mask = kvm_arch_get_supported_cpuid ( s , 0xd , 0 , R_EDX ) ; \n kvm_mask <<= 32 ; \n kvm_mask |= kvm_arch_get_supported_cpuid ( s , 0xd , 0 , R_EAX ) ; \n env -> xsave_components &= kvm_mask ; \n } \n }", "idx": 21473}
{"project": "qemu", "commit_id": "2bcf018340cbf233f7145e643fc1bb367f23fd90", "target": 0, "func": "int mmu_translate_real ( CPUS390XState * env , target_ulong raddr , int rw , \n target_ulong * addr , int * flags ) \n { \n * flags = PAGE_READ | PAGE_WRITE ; \n * addr = mmu_real2abs ( env , raddr ) ; \n return 0 ; \n }", "idx": 21487}
{"project": "qemu", "commit_id": "6cded3a43ad0044d9831590795d9c6cf0dc2d2ee", "target": 0, "func": "static void nic_selective_reset ( EEPRO100State * s ) \n { \n size_t i ; \n uint16_t * eeprom_contents = eeprom93xx_data ( s -> eeprom ) ; \n memcpy ( eeprom_contents , s -> conf . macaddr . a , 6 ) ; \n eeprom_contents [ 0xa ] = 0x4000 ; \n if ( s -> device == i82557B || s -> device == i82557C ) \n eeprom_contents [ 5 ] = 0x0100 ; \n uint16_t sum = 0 ; \n for ( i = 0 ; i < EEPROM_SIZE - 1 ; i ++ ) { \n sum += eeprom_contents [ i ] ; \n } \n eeprom_contents [ EEPROM_SIZE - 1 ] = 0xbaba - sum ; \n TRACE ( EEPROM , logout ( \" \\n \" , eeprom_contents [ EEPROM_SIZE - 1 ] ) ) ; \n memset ( s -> mem , 0 , sizeof ( s -> mem ) ) ; \n uint32_t val = BIT ( 21 ) ; \n memcpy ( & s -> mem [ SCBCtrlMDI ] , & val , sizeof ( val ) ) ; \n assert ( sizeof ( s -> mdimem ) == sizeof ( eepro100_mdi_default ) ) ; \n memcpy ( & s -> mdimem [ 0 ] , & eepro100_mdi_default [ 0 ] , sizeof ( s -> mdimem ) ) ; \n }", "idx": 21492}
{"project": "qemu", "commit_id": "0208def1cadd4f72f862e62548c2af268a543b20", "target": 1, "func": "void pci_bridge_reset_reg ( PCIDevice * dev ) \n { \n uint8_t * conf = dev -> config ; \n conf [ PCI_PRIMARY_BUS ] = 0 ; \n conf [ PCI_SECONDARY_BUS ] = 0 ; \n conf [ PCI_SUBORDINATE_BUS ] = 0 ; \n conf [ PCI_SEC_LATENCY_TIMER ] = 0 ; \n conf [ PCI_IO_BASE ] = 0 ; \n conf [ PCI_IO_LIMIT ] = 0 ; \n pci_set_word ( conf + PCI_MEMORY_BASE , 0 ) ; \n pci_set_word ( conf + PCI_MEMORY_LIMIT , 0 ) ; \n pci_set_word ( conf + PCI_PREF_MEMORY_BASE , 0 ) ; \n pci_set_word ( conf + PCI_PREF_MEMORY_LIMIT , 0 ) ; \n pci_set_word ( conf + PCI_PREF_BASE_UPPER32 , 0 ) ; \n pci_set_word ( conf + PCI_PREF_LIMIT_UPPER32 , 0 ) ; \n pci_set_word ( conf + PCI_BRIDGE_CONTROL , 0 ) ; \n }", "idx": 21508}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_sync_dirty_bitmap ( struct CPUPhysMemoryClient * client , \n target_phys_addr_t start_addr , \n target_phys_addr_t end_addr ) \n { \n return kvm_physical_sync_dirty_bitmap ( start_addr , end_addr ) ; \n }", "idx": 21511}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl ( void * opaque , target_phys_addr_t addr ) \n { \n PCIBonitoState * s = opaque ; \n uint32_t saddr ; \n saddr = ( addr - BONITO_REGBASE ) >> 2 ; \n DPRINTF ( \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n switch ( saddr ) { \n case BONITO_INTISR : \n return s -> regs [ saddr ] ; \n default : \n return s -> regs [ saddr ] ; \n } \n }", "idx": 21513}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_client_close ( NBDClient * client ) \n { \n if ( client -> closing ) { \n return ; \n } \n client -> closing = true ; \n shutdown ( client -> sock , 2 ) ; \n if ( client -> close ) { \n client -> close ( client ) ; \n } \n }", "idx": 21549}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static bool find_dirty_block ( RAMState * rs , PageSearchStatus * pss , \n bool * again , ram_addr_t * ram_addr_abs ) \n { \n pss -> offset = migration_bitmap_find_dirty ( rs , pss -> block , pss -> offset , \n ram_addr_abs ) ; \n if ( pss -> complete_round && pss -> block == rs -> last_seen_block && \n pss -> offset >= rs -> last_offset ) { \n * again = false ; \n return false ; \n } \n if ( pss -> offset >= pss -> block -> used_length ) { \n pss -> offset = 0 ; \n pss -> block = QLIST_NEXT_RCU ( pss -> block , next ) ; \n if ( ! pss -> block ) { \n pss -> block = QLIST_FIRST_RCU ( & ram_list . blocks ) ; \n pss -> complete_round = true ; \n rs -> ram_bulk_stage = false ; \n if ( migrate_use_xbzrle ( ) ) { \n flush_compressed_data ( rs ) ; \n } \n } \n * again = true ; \n return false ; \n } else { \n * again = true ; \n return true ; \n } \n }", "idx": 21567}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_POWER_doz ( void ) \n { \n if ( Ts1 > Ts0 ) \n T0 = T1 - T0 ; \n else \n T0 = 0 ; \n RETURN ( ) ; \n }", "idx": 21569}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty ( MemoryRegion * mr , hwaddr addr , \n hwaddr size , unsigned client ) \n { \n assert ( mr -> terminates ) ; \n return cpu_physical_memory_test_and_clear_dirty ( mr -> ram_addr + addr , \n size , client ) ; \n }", "idx": 21612}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int bdrv_get_cluster_size ( BlockDriverState * bs ) \n { \n BlockDriverInfo bdi ; \n int ret ; \n ret = bdrv_get_info ( bs , & bdi ) ; \n if ( ret < 0 || bdi . cluster_size == 0 ) { \n return bs -> request_alignment ; \n } else { \n return bdi . cluster_size ; \n } \n }", "idx": 21622}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void mvp_init ( CPUMIPSState * env , const mips_def_t * def ) \n { \n env -> mvp = g_malloc0 ( sizeof ( CPUMIPSMVPContext ) ) ; \n env -> mvp -> CP0_MVPConf0 = ( 1 << CP0MVPC0_M ) | ( 1 << CP0MVPC0_TLBS ) | \n ( 0 << CP0MVPC0_GS ) | ( 1 << CP0MVPC0_PCP ) | \n ( 1 << CP0MVPC0_TCA ) | ( 0x0 << CP0MVPC0_PVPE ) | \n ( 0x00 << CP0MVPC0_PTC ) ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  \n  \n  env -> mvp -> CP0_MVPConf0 |= ( env -> tlb -> nb_tlb << CP0MVPC0_PTLBE ) ; \n #endif \n env -> mvp -> CP0_MVPConf1 = ( 1 << CP0MVPC1_CIM ) | ( 1 << CP0MVPC1_CIF ) | \n ( 0x0 << CP0MVPC1_PCX ) | ( 0x0 << CP0MVPC1_PCP2 ) | \n ( 0x1 << CP0MVPC1_PCP1 ) ; \n }", "idx": 21694}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init ( VirtIOS390Device * dev , VirtIODevice * vdev ) \n { \n VirtIOS390Bus * bus ; \n int dev_len ; \n bus = DO_UPCAST ( VirtIOS390Bus , bus , dev -> qdev . parent_bus ) ; \n dev -> vdev = vdev ; \n dev -> dev_offs = bus -> dev_offs ; \n dev -> feat_len = sizeof ( uint32_t ) ; \n dev_len = VIRTIO_DEV_OFFS_CONFIG ; \n dev_len += s390_virtio_device_num_vq ( dev ) * VIRTIO_VQCONFIG_LEN ; \n dev_len += dev -> feat_len * 2 ; \n dev_len += virtio_bus_get_vdev_config_len ( & dev -> bus ) ; \n bus -> dev_offs += dev_len ; \n dev -> host_features = virtio_bus_get_vdev_features ( & dev -> bus , \n dev -> host_features ) ; \n s390_virtio_device_sync ( dev ) ; \n s390_virtio_reset_idx ( dev ) ; \n if ( dev -> qdev . hotplugged ) { \n S390CPU * cpu = s390_cpu_addr2state ( 0 ) ; \n s390_virtio_irq ( cpu , VIRTIO_PARAM_DEV_ADD , dev -> dev_offs ) ; \n } \n return 0 ; \n }", "idx": 21723}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock * qemu_ram_alloc_internal ( ram_addr_t size , ram_addr_t max_size , \n void ( * resized ) ( const char * , \n uint64_t length , \n void * host ) , \n void * host , bool resizeable , \n MemoryRegion * mr , Error * * errp ) \n { \n RAMBlock * new_block ; \n Error * local_err = NULL ; \n size = HOST_PAGE_ALIGN ( size ) ; \n max_size = HOST_PAGE_ALIGN ( max_size ) ; \n new_block = g_malloc0 ( sizeof ( * new_block ) ) ; \n new_block -> mr = mr ; \n new_block -> resized = resized ; \n new_block -> used_length = size ; \n new_block -> max_length = max_size ; \n assert ( max_size >= size ) ; \n new_block -> fd = -1 ; \n new_block -> host = host ; \n if ( host ) { \n new_block -> flags |= RAM_PREALLOC ; \n } \n if ( resizeable ) { \n new_block -> flags |= RAM_RESIZEABLE ; \n } \n ram_block_add ( new_block , & local_err ) ; \n if ( local_err ) { \n g_free ( new_block ) ; \n error_propagate ( errp , local_err ) ; \n return NULL ; \n } \n mr -> ram_block = new_block ; \n return new_block ; \n }", "idx": 21731}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi ( TCGContext * s , TCGType type , \n int ret , tcg_target_long arg ) \n { \n #if defined ( __sparc_v9__ ) && ! defined ( __sparc_v8plus__ )  \n  \n  if ( arg != ( arg & 0xffffffff ) ) \n fprintf ( stderr , \" \\n \" , __func__ , arg ) ; \n #endif \n if ( arg == ( arg & 0xfff ) ) \n tcg_out32 ( s , ARITH_OR | INSN_RD ( ret ) | INSN_RS1 ( TCG_REG_G0 ) | \n INSN_IMM13 ( arg ) ) ; \n else { \n tcg_out32 ( s , SETHI | INSN_RD ( ret ) | ( ( arg & 0xfffffc00 ) >> 10 ) ) ; \n if ( arg & 0x3ff ) \n tcg_out32 ( s , ARITH_OR | INSN_RD ( ret ) | INSN_RS1 ( ret ) | \n INSN_IMM13 ( arg & 0x3ff ) ) ; \n } \n }", "idx": 21739}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add ( ram_addr_t ram_addr ) \n { \n HWPoisonPage * page ; \n QLIST_FOREACH ( page , & hwpoison_page_list , list )  { \n if ( page -> ram_addr == ram_addr ) { \n return ; \n } \n } \n page = g_malloc ( sizeof ( HWPoisonPage ) ) ; \n page -> ram_addr = ram_addr ; \n QLIST_INSERT_HEAD ( & hwpoison_page_list , page , list ) ; \n }", "idx": 21794}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write ( PCIBus * s , \n uint32_t mmcfg_addr , uint32_t val , int len ) \n { \n PCIDevice * pci_dev = pcie_dev_find_by_mmcfg_addr ( s , mmcfg_addr ) ; \n if ( ! pci_dev ) { \n return ; \n } \n pci_host_config_write_common ( pci_dev , PCIE_MMCFG_CONFOFFSET ( mmcfg_addr ) , \n pci_config_size ( pci_dev ) , val , len ) ; \n }", "idx": 21820}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup ( AioContext * ctx , Error * * errp ) \n { \n #ifdef CONFIG_EPOLL \n assert ( ! ctx -> epollfd ) ; \n ctx -> epollfd = epoll_create1 ( EPOLL_CLOEXEC ) ; \n if ( ctx -> epollfd == -1 ) { \n ctx -> epoll_available = false ; \n } else { \n ctx -> epoll_available = true ; \n } \n #endif \n }", "idx": 21836}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write ( void * opaque , hwaddr addr , uint64_t val , \n unsigned size ) \n { \n }", "idx": 21889}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( divw ) \n { \n if ( ( Ts0 == INT32_MIN && Ts1 == -1 ) || Ts1 == 0 ) { \n T0 = ( int32_t ) ( ( -1 ) * ( T0 >> 31 ) ) ; \n } else { \n T0 = ( Ts0 / Ts1 ) ; \n } \n RETURN ( ) ; \n }", "idx": 21957}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror ( BlockDriverState * bdrv ) \n { \n int index ; \n for ( index = 0 ; index < nb_drives ; index ++ ) \n if ( drives_table [ index ] . bdrv == bdrv ) \n return drives_table [ index ] . onerror ; \n return BLOCK_ERR_REPORT ; \n }", "idx": 21958}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize ( Object * obj ) \n { \n NetFilterState * nf = NETFILTER ( obj ) ; \n NetFilterClass * nfc = NETFILTER_GET_CLASS ( obj ) ; \n if ( nfc -> cleanup ) { \n nfc -> cleanup ( nf ) ; \n } \n if ( nf -> netdev && ! QTAILQ_EMPTY ( & nf -> netdev -> filters ) ) { \n QTAILQ_REMOVE ( & nf -> netdev -> filters , nf , next ) ; \n } \n }", "idx": 21962}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4 ( QEMUMachineInitArgs * args ) \n { \n pc_compat_1_5 ( args ) ; \n has_pvpanic = false ; \n x86_cpu_compat_set_features ( \" \" , FEAT_1_ECX , 0 , CPUID_EXT_MOVBE ) ; \n x86_cpu_compat_set_features ( \" \" , FEAT_1_ECX , 0 , CPUID_EXT_PCLMULQDQ ) ; \n }", "idx": 21967}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize ( DeviceState * dev , Error * * err ) \n { \n int ret = 0 ; \n AMDVIState * s = AMD_IOMMU_DEVICE ( dev ) ; \n X86IOMMUState * x86_iommu = X86_IOMMU_DEVICE ( dev ) ; \n PCIBus * bus = PC_MACHINE ( qdev_get_machine ( ) ) -> bus ; \n s -> iotlb = g_hash_table_new_full ( amdvi_uint64_hash , \n amdvi_uint64_equal , g_free , g_free ) ; \n x86_iommu -> type = TYPE_AMD ; \n qdev_set_parent_bus ( DEVICE ( & s -> pci ) , & bus -> qbus ) ; \n object_property_set_bool ( OBJECT ( & s -> pci ) , true , \" \" , err ) ; \n s -> capab_offset = pci_add_capability ( & s -> pci . dev , AMDVI_CAPAB_ID_SEC , 0 , \n AMDVI_CAPAB_SIZE ) ; \n assert ( s -> capab_offset > 0 ) ; \n ret = pci_add_capability ( & s -> pci . dev , PCI_CAP_ID_MSI , 0 , AMDVI_CAPAB_REG_SIZE ) ; \n assert ( ret > 0 ) ; \n ret = pci_add_capability ( & s -> pci . dev , PCI_CAP_ID_HT , 0 , AMDVI_CAPAB_REG_SIZE ) ; \n assert ( ret > 0 ) ; \n memory_region_init_io ( & s -> mmio , OBJECT ( s ) , & mmio_mem_ops , s , \" \" , \n AMDVI_MMIO_SIZE ) ; \n sysbus_init_mmio ( SYS_BUS_DEVICE ( s ) , & s -> mmio ) ; \n sysbus_mmio_map ( SYS_BUS_DEVICE ( s ) , 0 , AMDVI_BASE_ADDR ) ; \n pci_setup_iommu ( bus , amdvi_host_dma_iommu , s ) ; \n s -> devid = object_property_get_int ( OBJECT ( & s -> pci ) , \" \" , err ) ; \n msi_init ( & s -> pci . dev , 0 , 1 , true , false , err ) ; \n amdvi_init ( s ) ; \n }", "idx": 21969}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append ( NetQueue * queue , \n NetClientState * sender , \n unsigned flags , \n const uint8_t * buf , \n size_t size , \n NetPacketSent * sent_cb ) \n { \n NetPacket * packet ; \n if ( queue -> nq_count >= queue -> nq_maxlen && ! sent_cb ) { \n return ; \n } \n packet = g_malloc ( sizeof ( NetPacket ) + size ) ; \n packet -> sender = sender ; \n packet -> flags = flags ; \n packet -> size = size ; \n packet -> sent_cb = sent_cb ; \n memcpy ( packet -> data , buf , size ) ; \n QTAILQ_INSERT_TAIL ( & queue -> packets , packet , entry ) ; \n }", "idx": 21995}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired ( QEMUTimerList * timer_list ) \n { \n int64_t expire_time ; \n if ( ! atomic_read ( & timer_list -> active_timers ) ) { \n return false ; \n } \n qemu_mutex_lock ( & timer_list -> active_timers_lock ) ; \n if ( ! timer_list -> active_timers ) { \n qemu_mutex_unlock ( & timer_list -> active_timers_lock ) ; \n return false ; \n } \n expire_time = timer_list -> active_timers -> expire_time ; \n qemu_mutex_unlock ( & timer_list -> active_timers_lock ) ; \n return expire_time < qemu_clock_get_ns ( timer_list -> clock -> type ) ; \n }", "idx": 22006}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate ( Error * * dst_errp , Error * local_err ) \n { \n if ( local_err && dst_errp == & error_abort ) { \n error_report_err ( local_err ) ; \n abort ( ) ; \n } else if ( dst_errp && ! * dst_errp ) { \n * dst_errp = local_err ; \n } else if ( local_err ) { \n error_free ( local_err ) ; \n } \n }", "idx": 22047}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero ( float64 a STATUS_PARAM ) \n { \n flag aSign ; \n int16 aExp , shiftCount ; \n uint64_t aSig , savedASig ; \n int32 z ; \n a = float64_squash_input_denormal ( a STATUS_VAR ) ; \n aSig = extractFloat64Frac ( a ) ; \n aExp = extractFloat64Exp ( a ) ; \n aSign = extractFloat64Sign ( a ) ; \n if ( 0x41E < aExp ) { \n if ( ( aExp == 0x7FF ) && aSig ) aSign = 0 ; \n goto invalid ; \n } \n else if ( aExp < 0x3FF ) { \n if ( aExp || aSig ) STATUS ( float_exception_flags ) |= float_flag_inexact ; \n return 0 ; \n } \n aSig |= LIT64 ( 0x0010000000000000 ) ; \n shiftCount = 0x433 - aExp ; \n savedASig = aSig ; \n aSig >>= shiftCount ; \n z = aSig ; \n if ( aSign ) z = - z ; \n if ( ( z < 0 ) ^ aSign ) { \n invalid : \n float_raise ( float_flag_invalid STATUS_VAR ) ; \n return aSign ? ( int32_t ) 0x80000000 : 0x7FFFFFFF ; \n } \n if ( ( aSig << shiftCount ) != savedASig ) { \n STATUS ( float_exception_flags ) |= float_flag_inexact ; \n } \n return z ; \n }", "idx": 22065}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue * bdrv_reopen_queue ( BlockReopenQueue * bs_queue , \n BlockDriverState * bs , int flags ) \n { \n assert ( bs != NULL ) ; \n BlockReopenQueueEntry * bs_entry ; \n if ( bs_queue == NULL ) { \n bs_queue = g_new0 ( BlockReopenQueue , 1 ) ; \n QSIMPLEQ_INIT ( bs_queue ) ; \n } \n flags &= ~ BDRV_O_PROTOCOL ; \n if ( bs -> file ) { \n bdrv_reopen_queue ( bs_queue , bs -> file , bdrv_inherited_flags ( flags ) ) ; \n } \n bs_entry = g_new0 ( BlockReopenQueueEntry , 1 ) ; \n QSIMPLEQ_INSERT_TAIL ( bs_queue , bs_entry , entry ) ; \n bs_entry -> state . bs = bs ; \n bs_entry -> state . flags = flags ; \n return bs_queue ; \n }", "idx": 22082}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask ( CPUState * env , const sigset_t * sigset ) \n { \n struct kvm_signal_mask * sigmask ; \n int r ; \n if ( ! sigset ) \n return kvm_vcpu_ioctl ( env , KVM_SET_SIGNAL_MASK , NULL ) ; \n sigmask = qemu_malloc ( sizeof ( * sigmask ) + sizeof ( * sigset ) ) ; \n sigmask -> len = 8 ; \n memcpy ( sigmask -> sigset , sigset , sizeof ( * sigset ) ) ; \n r = kvm_vcpu_ioctl ( env , KVM_SET_SIGNAL_MASK , sigmask ) ; \n free ( sigmask ) ; \n return r ; \n }", "idx": 22094}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close ( void * opaque ) \n { \n QEMUFileSocket * s = opaque ; \n close ( s -> fd ) ; \n g_free ( s ) ; \n return 0 ; \n }", "idx": 22132}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read ( void * opaque ) \n { \n CharDriverState * chr = opaque ; \n FDCharDriver * s = chr -> opaque ; \n int size , len ; \n uint8_t buf [ 1024 ] ; \n len = sizeof ( buf ) ; \n if ( len > s -> max_size ) \n len = s -> max_size ; \n if ( len == 0 ) \n return ; \n size = read ( s -> fd_in , buf , len ) ; \n if ( size == 0 ) { \n qemu_set_fd_handler2 ( s -> fd_in , NULL , NULL , NULL , NULL ) ; \n qemu_chr_event ( chr , CHR_EVENT_CLOSED ) ; \n return ; \n } \n if ( size > 0 ) { \n qemu_chr_read ( chr , buf , size ) ; \n } \n }", "idx": 22140}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields ( QemuOpts * opts ) \n { \n const char * val ; \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n smbios_add_field ( 1 , offsetof ( struct smbios_type_1 , manufacturer_str ) , \n val , strlen ( val ) + 1 ) ; \n } \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n smbios_add_field ( 1 , offsetof ( struct smbios_type_1 , product_name_str ) , \n val , strlen ( val ) + 1 ) ; \n } \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n smbios_add_field ( 1 , offsetof ( struct smbios_type_1 , version_str ) , \n val , strlen ( val ) + 1 ) ; \n } \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n smbios_add_field ( 1 , offsetof ( struct smbios_type_1 , serial_number_str ) , \n val , strlen ( val ) + 1 ) ; \n } \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n if ( qemu_uuid_parse ( val , qemu_uuid ) != 0 ) { \n error_report ( \" \" ) ; \n exit ( 1 ) ; \n } \n } \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n smbios_add_field ( 1 , offsetof ( struct smbios_type_1 , sku_number_str ) , \n val , strlen ( val ) + 1 ) ; \n } \n val = qemu_opt_get ( opts , \" \" ) ; \n if ( val ) { \n smbios_add_field ( 1 , offsetof ( struct smbios_type_1 , family_str ) , \n val , strlen ( val ) + 1 ) ; \n } \n }", "idx": 22151}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments ( const struct stat * st ) \n { \n #ifdef CONFIG_LINUX \n char buf [ 32 ] ; \n const char * end ; \n char * sysfspath ; \n int ret ; \n int fd = -1 ; \n long max_segments ; \n sysfspath = g_strdup_printf ( \" \" , \n major ( st -> st_rdev ) , minor ( st -> st_rdev ) ) ; \n fd = open ( sysfspath , O_RDONLY ) ; \n if ( fd == -1 ) { \n ret = - errno ; \n goto out ; \n } \n do { \n ret = read ( fd , buf , sizeof ( buf ) ) ; \n } while ( ret == -1 && errno == EINTR ) ; \n if ( ret < 0 ) { \n ret = - errno ; \n goto out ; \n } else if ( ret == 0 ) { \n ret = - EIO ; \n goto out ; \n } \n buf [ ret ] = 0 ; \n ret = qemu_strtol ( buf , & end , 10 , & max_segments ) ; \n if ( ret == 0 && end && * end == ' \\n ' ) { \n ret = max_segments ; \n } \n out : \n g_free ( sysfspath ) ; \n return ret ; \n #else \n return - ENOTSUP ; \n #endif \n }", "idx": 22167}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq ( APICCommonState * s ) \n { \n if ( ! ( s -> spurious_vec & APIC_SV_ENABLE ) ) { \n return ; \n } \n if ( apic_irq_pending ( s ) > 0 ) { \n cpu_interrupt ( s -> cpu_env , CPU_INTERRUPT_HARD ) ; \n } else if ( apic_accept_pic_intr ( & s -> busdev . qdev ) && \n pic_get_output ( isa_pic ) ) { \n apic_deliver_pic_intr ( & s -> busdev . qdev , 1 ) ; \n } \n }", "idx": 22201}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( extsh ) \n { \n T0 = ( int32_t ) ( ( int16_t ) ( Ts0 ) ) ; \n RETURN ( ) ; \n }", "idx": 22250}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open ( BlockDriverState * bs , QDict * options , int flags , \n Error * * errp ) { \n NFSClient * client = bs -> opaque ; \n int64_t ret ; \n client -> aio_context = bdrv_get_aio_context ( bs ) ; \n ret = nfs_client_open ( client , options , \n ( flags & BDRV_O_RDWR ) ? O_RDWR : O_RDONLY , \n bs -> open_flags , errp ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n qemu_mutex_init ( & client -> mutex ) ; \n bs -> total_sectors = ret ; \n ret = 0 ; \n return ret ; \n }", "idx": 22265}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb ( void * opaque , target_phys_addr_t addr ) \n { \n uint8_t retval ; \n MACIOIDEState * d = opaque ; \n addr = ( addr & 0xFFF ) >> 4 ; \n switch ( addr ) { \n case 1 . . . 7 : \n retval = ide_ioport_read ( & d -> bus , addr ) ; \n break ; \n case 8 : \n case 22 : \n retval = ide_status_read ( & d -> bus , 0 ) ; \n break ; \n default : \n retval = 0xFF ; \n break ; \n } \n return retval ; \n }", "idx": 22270}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size ( CPUState * env , ppcmas_tlb_t * tlb ) \n { \n uint32_t tlbncfg ; \n int tlbn = booke206_tlbm_to_tlbn ( env , tlb ) ; \n int tlbm_size ; \n tlbncfg = env -> spr [ SPR_BOOKE_TLB0CFG + tlbn ] ; \n if ( tlbncfg & TLBnCFG_AVAIL ) { \n tlbm_size = ( tlb -> mas1 & MAS1_TSIZE_MASK ) >> MAS1_TSIZE_SHIFT ; \n } else { \n tlbm_size = ( tlbncfg & TLBnCFG_MINSIZE ) >> TLBnCFG_MINSIZE_SHIFT ; \n tlbm_size <<= 1 ; \n } \n return 1024ULL << tlbm_size ; \n }", "idx": 22276}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet ( XHCITransfer * xfer , XHCIPort * port , int ep ) \n { \n usb_packet_setup ( & xfer -> packet , \n xfer -> in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT , \n xfer -> xhci -> slots [ xfer -> slotid - 1 ] . devaddr , \n ep & 0x7f ) ; \n usb_packet_addbuf ( & xfer -> packet , xfer -> data , xfer -> data_length ) ; \n DPRINTF ( \" \\n \" , \n xfer -> packet . pid , xfer -> packet . devaddr , xfer -> packet . devep ) ; \n return 0 ; \n }", "idx": 22279}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel ( BlockAIOCB * acb ) \n { \n ThreadPoolElement * elem = ( ThreadPoolElement * ) acb ; \n ThreadPool * pool = elem -> pool ; \n trace_thread_pool_cancel ( elem , elem -> common . opaque ) ; \n qemu_mutex_lock ( & pool -> lock ) ; \n if ( elem -> state == THREAD_QUEUED && \n qemu_sem_timedwait ( & pool -> sem , 0 ) == 0 ) { \n QTAILQ_REMOVE ( & pool -> request_list , elem , reqs ) ; \n qemu_bh_schedule ( pool -> completion_bh ) ; \n elem -> state = THREAD_DONE ; \n elem -> ret = - ECANCELED ; \n } \n qemu_mutex_unlock ( & pool -> lock ) ; \n }", "idx": 22280}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init ( void ) \n { \n qemu_mutex_init ( & monitor_event_state_lock ) ; \n monitor_protocol_event_throttle ( QEVENT_RTC_CHANGE , 1000 ) ; \n monitor_protocol_event_throttle ( QEVENT_BALLOON_CHANGE , 1000 ) ; \n monitor_protocol_event_throttle ( QEVENT_WATCHDOG , 1000 ) ; \n }", "idx": 22300}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit ( BlockDriverState * bs , int64_t bitnum ) \n { \n uint64_t offset = sizeof ( struct cow_header_v2 ) + bitnum / 8 ; \n uint8_t bitmap ; \n if ( bdrv_pread ( bs -> file , offset , & bitmap , sizeof ( bitmap ) ) != \n sizeof ( bitmap ) ) { \n return - errno ; \n } \n bitmap |= ( 1 << ( bitnum % 8 ) ) ; \n if ( bdrv_pwrite ( bs -> file , offset , & bitmap , sizeof ( bitmap ) ) != \n sizeof ( bitmap ) ) { \n return - errno ; \n } \n return 0 ; \n }", "idx": 22365}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( cmpl ) \n { \n if ( T0 < T1 ) { \n T0 = 0x08 ; \n } else if ( T0 > T1 ) { \n T0 = 0x04 ; \n } else { \n T0 = 0x02 ; \n } \n RETURN ( ) ; \n }", "idx": 22369}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare ( BlkActionState * common , Error * * errp ) \n { \n DriveBackupState * state = DO_UPCAST ( DriveBackupState , common , common ) ; \n BlockDriverState * bs ; \n DriveBackup * backup ; \n Error * local_err = NULL ; \n assert ( common -> action -> type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP ) ; \n backup = common -> action -> u . drive_backup . data ; \n bs = qmp_get_root_bs ( backup -> device , errp ) ; \n if ( ! bs ) { \n return ; \n } \n state -> aio_context = bdrv_get_aio_context ( bs ) ; \n aio_context_acquire ( state -> aio_context ) ; \n bdrv_drained_begin ( bs ) ; \n state -> bs = bs ; \n do_drive_backup ( backup , common -> block_job_txn , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n state -> job = state -> bs -> job ; \n }", "idx": 22387}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP ( DisasContext * ctx ) \n { \n gen_op_update_nip ( ( ctx ) -> nip ) ; \n ctx -> exception = EXCP_MTMSR ; \n }", "idx": 22389}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd ( int sockfd , int * status ) \n { \n struct iovec iov ; \n struct msghdr msg ; \n struct cmsghdr * cmsg ; \n int retval , data , fd ; \n union MsgControl msg_control ; \n iov . iov_base = & data ; \n iov . iov_len = sizeof ( data ) ; \n memset ( & msg , 0 , sizeof ( msg ) ) ; \n msg . msg_iov = & iov ; \n msg . msg_iovlen = 1 ; \n msg . msg_control = & msg_control ; \n msg . msg_controllen = sizeof ( msg_control ) ; \n do { \n retval = recvmsg ( sockfd , & msg , 0 ) ; \n } while ( retval < 0 && errno == EINTR ) ; \n if ( retval <= 0 ) { \n return retval ; \n } \n if ( data != V9FS_FD_VALID ) { \n * status = data ; \n return 0 ; \n } \n for ( cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg ; cmsg = CMSG_NXTHDR ( & msg , cmsg ) ) { \n if ( cmsg -> cmsg_len != CMSG_LEN ( sizeof ( int ) ) || \n cmsg -> cmsg_level != SOL_SOCKET || \n cmsg -> cmsg_type != SCM_RIGHTS ) { \n continue ; \n } \n fd = * ( ( int * ) CMSG_DATA ( cmsg ) ) ; \n * status = fd ; \n return 0 ; \n } \n * status = - ENFILE ; \n return 0 ; \n }", "idx": 22413}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on ( CPUState * env , struct kvm_x86_mce * mce , \n int flag ) \n { \n struct kvm_x86_mce_data data = { \n . env = env , \n . mce = mce , \n . abort_on_error = ( flag & ABORT_ON_ERROR ) , \n } ; \n if ( ! env -> mcg_cap ) { \n fprintf ( stderr , \" \\n \" ) ; \n return ; \n } \n run_on_cpu ( env , kvm_do_inject_x86_mce , & data ) ; \n }", "idx": 22417}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler * find_aio_handler ( AioContext * ctx , int fd ) \n { \n AioHandler * node ; \n QLIST_FOREACH ( node , & ctx -> aio_handlers , node )  { \n if ( node -> pfd . fd == fd ) \n if ( ! node -> deleted ) \n return node ; \n } \n return NULL ; \n }", "idx": 22418}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error ( QEMUFile * f , int ret ) \n { \n if ( f -> last_error == 0 ) { \n f -> last_error = ret ; \n } \n }", "idx": 22431}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz ( uint64_t val ) \n { \n CPU_DoubleU u ; \n u . ll = val ; \n if ( unlikely ( float64_is_nan ( u . d ) ) ) \n return 0 ; \n return float64_to_uint64_round_to_zero ( u . d , & env -> vec_status ) ; \n }", "idx": 22462}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum ( BIOSLinker * linker , const char * file_name , \n void * start , unsigned size , \n uint8_t * checksum ) \n { \n BiosLinkerLoaderEntry entry ; \n const BiosLinkerFileEntry * file = bios_linker_find_file ( linker , file_name ) ; \n ptrdiff_t checksum_offset = ( gchar * ) checksum - file -> blob -> data ; \n ptrdiff_t start_offset = ( gchar * ) start - file -> blob -> data ; \n assert ( checksum_offset >= 0 ) ; \n assert ( start_offset >= 0 ) ; \n assert ( checksum_offset + 1 <= file -> blob -> len ) ; \n assert ( start_offset + size <= file -> blob -> len ) ; \n assert ( * checksum == 0x0 ) ; \n memset ( & entry , 0 , sizeof entry ) ; \n strncpy ( entry . cksum . file , file_name , sizeof entry . cksum . file - 1 ) ; \n entry . command = cpu_to_le32 ( BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM ) ; \n entry . cksum . offset = cpu_to_le32 ( checksum_offset ) ; \n entry . cksum . start = cpu_to_le32 ( start_offset ) ; \n entry . cksum . length = cpu_to_le32 ( size ) ; \n g_array_append_vals ( linker -> cmd_blob , & entry , sizeof entry ) ; \n }", "idx": 22465}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread ( void ) \n { \n if ( ! tcg_enabled ( ) ) { \n qemu_mutex_lock ( & qemu_global_mutex ) ; \n } else { \n iothread_requesting_mutex = true ; \n if ( qemu_mutex_trylock ( & qemu_global_mutex ) ) { \n qemu_cpu_kick_thread ( first_cpu ) ; \n qemu_mutex_lock ( & qemu_global_mutex ) ; \n } \n iothread_requesting_mutex = false ; \n qemu_cond_broadcast ( & qemu_io_proceeded_cond ) ; \n } \n }", "idx": 22534}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im ( int32_t val ) \n { \n tcg_gen_ld_tl ( cpu_tmp0 , cpu_env , offsetof ( CPUState , regs [ R_ESP ] ) ) ; \n tcg_gen_addi_tl ( cpu_tmp0 , cpu_tmp0 , val ) ; \n #ifdef TARGET_X86_64 \n tcg_gen_andi_tl ( cpu_tmp0 , cpu_tmp0 , 0xffffffff ) ; \n #endif \n tcg_gen_st_tl ( cpu_tmp0 , cpu_env , offsetof ( CPUState , regs [ R_ESP ] ) ) ; \n }", "idx": 22545}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r ( DisasContext * dc ) \n { \n TCGv t0 ; \n int size = memsize_z ( dc ) ; \n DIS ( fprintf ( logfile , \" \\n \" , \n memsize_char ( size ) , \n dc -> op1 , dc -> op2 ) ) ; \n cris_cc_mask ( dc , CC_MASK_NZ ) ; \n t0 = tcg_temp_new ( TCG_TYPE_TL ) ; \n dec_prep_move_r ( dc , dc -> op1 , dc -> op2 , size , 0 , t0 ) ; \n cris_alu ( dc , CC_OP_MOVE , cpu_R [ dc -> op2 ] , cpu_R [ dc -> op2 ] , t0 , 4 ) ; \n tcg_temp_free ( t0 ) ; \n return 2 ; \n }", "idx": 22552}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv ( void ) \n { \n QemuOpts * opts ; \n QEMUMachine * machine ; \n char * filename ; \n if ( bios_name == NULL ) { \n bios_name = BIOS_FILENAME ; \n } \n filename = qemu_find_file ( QEMU_FILE_TYPE_BIOS , bios_name ) ; \n opts = drive_add ( IF_PFLASH , -1 , filename , \" \" ) ; \n g_free ( filename ) ; \n if ( opts == NULL ) { \n return ; \n } \n machine = find_default_machine ( ) ; \n if ( machine == NULL ) { \n return ; \n } \n drive_init ( opts , machine -> use_scsi ) ; \n }", "idx": 22615}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start ( BlockDriverState * bs , BlockDriverState * base , \n const char * base_id , int64_t speed , \n BlockDriverCompletionFunc * cb , \n void * opaque , Error * * errp ) \n { \n StreamBlockJob * s ; \n Coroutine * co ; \n s = block_job_create ( & stream_job_type , bs , speed , cb , opaque , errp ) ; \n if ( ! s ) { \n return ; \n } \n s -> base = base ; \n if ( base_id ) { \n pstrcpy ( s -> backing_file_id , sizeof ( s -> backing_file_id ) , base_id ) ; \n } \n co = qemu_coroutine_create ( stream_run ) ; \n trace_stream_start ( bs , base , s , co , opaque ) ; \n qemu_coroutine_enter ( co , s ) ; \n }", "idx": 22652}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP ( srawi ) \n { \n T1 = T0 ; \n T0 = ( Ts0 >> PARAM ( 1 ) ) ; \n if ( Ts1 < 0 && ( Ts1 & PARAM ( 2 ) ) != 0 ) { \n xer_ca = 1 ; \n } else { \n xer_ca = 0 ; \n } \n RETURN ( ) ; \n }", "idx": 22683}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file ( const char * file ) \n { \n #ifdef CONFIG_TRACE_SIMPLE \n st_set_trace_file ( file ) ; \n #elif defined CONFIG_TRACE_LOG  \n  \n  \n  if ( file ) { \n qemu_set_log_filename ( file ) ; \n } \n #else \n if ( file ) { \n fprintf ( stderr , \" \" \n \" \\n \" ) ; \n exit ( 1 ) ; \n } \n #endif \n }", "idx": 22693}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug ( PIIX4PMState * s ) \n { \n PCIDevice * dev = & s -> dev ; \n BusState * bus = qdev_get_parent_bus ( & dev -> qdev ) ; \n DeviceState * qdev , * next ; \n s -> pci0_hotplug_enable = ~ 0 ; \n QTAILQ_FOREACH_SAFE ( qdev , & bus -> children , sibling , next )  { \n PCIDevice * pdev = PCI_DEVICE ( qdev ) ; \n PCIDeviceClass * pc = PCI_DEVICE_GET_CLASS ( pdev ) ; \n int slot = PCI_SLOT ( pdev -> devfn ) ; \n if ( pc -> no_hotplug ) { \n s -> pci0_hotplug_enable &= ~ ( 1 << slot ) ; \n } \n } \n }", "idx": 22705}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed ( BlockJob * job , int64_t speed , Error * * errp ) \n { \n StreamBlockJob * s = container_of ( job , StreamBlockJob , common ) ; \n if ( speed < 0 ) { \n error_setg ( errp , QERR_INVALID_PARAMETER , \" \" ) ; \n return ; \n } \n ratelimit_set_speed ( & s -> limit , speed / BDRV_SECTOR_SIZE , SLICE_TIME ) ; \n }", "idx": 22709}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration ( const char * path ) \n { \n struct sockaddr_un un ; \n int sock ; \n dprintf ( \" \\n \" ) ; \n sock = socket ( PF_UNIX , SOCK_STREAM , 0 ) ; \n if ( sock < 0 ) { \n fprintf ( stderr , \" \\n \" , strerror ( errno ) ) ; \n return - EINVAL ; \n } \n memset ( & un , 0 , sizeof ( un ) ) ; \n un . sun_family = AF_UNIX ; \n snprintf ( un . sun_path , sizeof ( un . sun_path ) , \" \" , path ) ; \n unlink ( un . sun_path ) ; \n if ( bind ( sock , ( struct sockaddr * ) & un , sizeof ( un ) ) < 0 ) { \n fprintf ( stderr , \" \\n \" , un . sun_path , strerror ( errno ) ) ; \n goto err ; \n } \n if ( listen ( sock , 1 ) < 0 ) { \n fprintf ( stderr , \" \\n \" , un . sun_path , strerror ( errno ) ) ; \n goto err ; \n } \n qemu_set_fd_handler2 ( sock , NULL , unix_accept_incoming_migration , NULL , \n ( void * ) ( unsigned long ) sock ) ; \n return 0 ; \n err : \n close ( sock ) ; \n return - EINVAL ; \n }", "idx": 22741}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl ( QPCIBus * bus , int devfn , uint8_t offset ) \n { \n outl ( 0xcf8 , ( 1 << 31 ) | ( devfn << 8 ) | offset ) ; \n return inl ( 0xcfc ) ; \n }", "idx": 22834}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset ( S390CPU * cpu ) \n { \n S390CPUClass * scc = S390_CPU_GET_CLASS ( cpu ) ; \n pause_all_vcpus ( ) ; \n cpu_synchronize_all_states ( ) ; \n cpu_reset_all ( ) ; \n io_subsystem_reset ( ) ; \n scc -> initial_cpu_reset ( CPU ( cpu ) ) ; \n scc -> load_normal ( CPU ( cpu ) ) ; \n cpu_synchronize_all_post_reset ( ) ; \n resume_all_vcpus ( ) ; \n return 0 ; \n }", "idx": 22875}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate ( V9fsState * s , V9fsLcreateState * vs , int err ) \n { \n if ( err == 0 ) { \n v9fs_string_copy ( & vs -> fidp -> path , & vs -> fullname ) ; \n stat_to_qid ( & vs -> stbuf , & vs -> qid ) ; \n vs -> offset += pdu_marshal ( vs -> pdu , vs -> offset , \" \" , & vs -> qid , \n & vs -> iounit ) ; \n err = vs -> offset ; \n } else { \n vs -> fidp -> fid_type = P9_FID_NONE ; \n close ( vs -> fidp -> fs . fd ) ; \n err = - errno ; \n } \n complete_pdu ( s , vs -> pdu , err ) ; \n v9fs_string_free ( & vs -> name ) ; \n v9fs_string_free ( & vs -> fullname ) ; \n qemu_free ( vs ) ; \n }", "idx": 22876}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats ( MigrationInfo * info ) \n { \n if ( migrate_use_xbzrle ( ) ) { \n info -> has_xbzrle_cache = true ; \n info -> xbzrle_cache = g_malloc0 ( sizeof ( * info -> xbzrle_cache ) ) ; \n info -> xbzrle_cache -> cache_size = migrate_xbzrle_cache_size ( ) ; \n info -> xbzrle_cache -> bytes = xbzrle_mig_bytes_transferred ( ) ; \n info -> xbzrle_cache -> pages = xbzrle_mig_pages_transferred ( ) ; \n info -> xbzrle_cache -> cache_miss = xbzrle_mig_pages_cache_miss ( ) ; \n info -> xbzrle_cache -> cache_miss_rate = xbzrle_mig_cache_miss_rate ( ) ; \n info -> xbzrle_cache -> overflow = xbzrle_mig_pages_overflow ( ) ; \n } \n }", "idx": 22906}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU * ppc440_init_xilinx ( ram_addr_t * ram_size , \n int do_init , \n const char * cpu_model , \n uint32_t sysclk ) \n { \n PowerPCCPU * cpu ; \n CPUPPCState * env ; \n qemu_irq * irqs ; \n cpu = POWERPC_CPU ( cpu_generic_init ( TYPE_POWERPC_CPU , cpu_model ) ) ; \n if ( cpu == NULL ) { \n fprintf ( stderr , \" \\n \" ) ; \n exit ( 1 ) ; \n } \n env = & cpu -> env ; \n ppc_booke_timers_init ( cpu , sysclk , 0 \n ) ; \n ppc_dcr_init ( env , NULL , NULL ) ; \n irqs = g_malloc0 ( sizeof ( qemu_irq ) * PPCUIC_OUTPUT_NB ) ; \n irqs [ PPCUIC_OUTPUT_INT ] = ( ( qemu_irq * ) env -> irq_inputs ) [ PPC40x_INPUT_INT ] ; \n irqs [ PPCUIC_OUTPUT_CINT ] = ( ( qemu_irq * ) env -> irq_inputs ) [ PPC40x_INPUT_CINT ] ; \n ppcuic_init ( env , irqs , 0x0C0 , 0 , 1 ) ; \n return cpu ; \n }", "idx": 22931}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish ( VncState * vs ) \n { \n vnc_qmp_event ( vs , QEVENT_VNC_DISCONNECTED ) ; \n buffer_free ( & vs -> input ) ; \n buffer_free ( & vs -> output ) ; \n qobject_decref ( vs -> info ) ; \n #ifdef CONFIG_VNC_TLS \n vnc_tls_client_cleanup ( vs ) ; \n #endif \n #ifdef CONFIG_VNC_SASL \n vnc_sasl_client_cleanup ( vs ) ; \n #endif \n audio_del ( vs ) ; \n QTAILQ_REMOVE ( & vs -> vd -> clients , vs , next ) ; \n if ( QTAILQ_EMPTY ( & vs -> vd -> clients ) ) { \n dcl -> idle = 1 ; \n } \n qemu_remove_mouse_mode_change_notifier ( & vs -> mouse_mode_notifier ) ; \n vnc_remove_timer ( vs -> vd ) ; \n if ( vs -> vd -> lock_key_sync ) \n qemu_remove_led_event_handler ( vs -> led ) ; \n qemu_free ( vs ) ; \n }", "idx": 22980}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print ( QemuOpts * opts ) \n { \n QemuOpt * opt ; \n QemuOptDesc * desc = opts -> list -> desc ; \n if ( desc [ 0 ] . name == NULL ) { \n QTAILQ_FOREACH ( opt , & opts -> head , next )  { \n printf ( \" \\\" \\\" \" , opt -> name , opt -> str ) ; \n } \n return ; \n } \n for ( ; desc && desc -> name ; desc ++ ) { \n const char * value ; \n QemuOpt * opt = qemu_opt_find ( opts , desc -> name ) ; \n value = opt ? opt -> str : desc -> def_value_str ; \n if ( ! value ) { \n continue ; \n } \n if ( desc -> type == QEMU_OPT_STRING ) { \n printf ( \" \" , desc -> name , value ) ; \n } else if ( ( desc -> type == QEMU_OPT_SIZE || \n desc -> type == QEMU_OPT_NUMBER ) && opt ) { \n printf ( \" \" PRId64 \" \" , desc -> name , opt -> value . uint ) ; \n } else { \n printf ( \" \" , desc -> name , value ) ; \n } \n } \n }", "idx": 22994}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress * tcp_build_address ( const char * host_port , Error * * errp ) \n { \n InetSocketAddress * iaddr = g_new ( InetSocketAddress , 1 ) ; \n SocketAddress * saddr ; \n if ( inet_parse ( iaddr , host_port , errp ) ) { \n qapi_free_InetSocketAddress ( iaddr ) ; \n return NULL ; \n } \n saddr = g_new0 ( SocketAddress , 1 ) ; \n saddr -> type = SOCKET_ADDRESS_KIND_INET ; \n saddr -> u . inet . data = iaddr ; \n return saddr ; \n }", "idx": 23066}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close ( BlockDriverState * bs ) \n { \n BDRVNBDState * s = bs -> opaque ; \n qemu_opts_del ( s -> socket_opts ) ; \n nbd_client_session_close ( & s -> client ) ; \n }", "idx": 23074}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset ( DeviceState * d ) \n { \n sPAPRDRConnector * drc = SPAPR_DR_CONNECTOR ( d ) ; \n sPAPRDRConnectorClass * drck = SPAPR_DR_CONNECTOR_GET_CLASS ( drc ) ; \n trace_spapr_drc_reset ( spapr_drc_index ( drc ) ) ; \n g_free ( drc -> ccs ) ; \n drc -> ccs = NULL ; \n if ( drc -> awaiting_release ) { \n drck -> set_isolation_state ( drc , SPAPR_DR_ISOLATION_STATE_ISOLATED ) ; \n if ( drc -> awaiting_release ) { \n spapr_drc_detach ( drc , DEVICE ( drc -> dev ) , NULL ) ; \n } \n if ( spapr_drc_type ( drc ) != SPAPR_DR_CONNECTOR_TYPE_PCI && \n drc -> awaiting_release ) { \n drck -> set_allocation_state ( drc , SPAPR_DR_ALLOCATION_STATE_UNUSABLE ) ; \n } \n } \n }", "idx": 23076}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint ( CPUState * current_env , target_ulong addr , \n target_ulong len , int type ) \n { \n struct kvm_sw_breakpoint * bp ; \n CPUState * env ; \n int err ; \n if ( type == GDB_BREAKPOINT_SW ) { \n bp = kvm_find_sw_breakpoint ( current_env , addr ) ; \n if ( ! bp ) \n return - ENOENT ; \n if ( bp -> use_count > 1 ) { \n bp -> use_count -- ; \n return 0 ; \n } \n err = kvm_arch_remove_sw_breakpoint ( current_env , bp ) ; \n if ( err ) \n return err ; \n QTAILQ_REMOVE ( & current_env -> kvm_state -> kvm_sw_breakpoints , bp , entry ) ; \n qemu_free ( bp ) ; \n } else { \n err = kvm_arch_remove_hw_breakpoint ( addr , len , type ) ; \n if ( err ) \n return err ; \n } \n for ( env = first_cpu ; env != NULL ; env = env -> next_cpu ) { \n err = kvm_update_guest_debug ( env , 0 ) ; \n if ( err ) \n return err ; \n } \n return 0 ; \n }", "idx": 23088}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT ( CPUSH4State * env , float64 t0 , float64 t1 ) \n { \n int relation ; \n set_float_exception_flags ( 0 , & env -> fp_status ) ; \n relation = float64_compare ( t0 , t1 , & env -> fp_status ) ; \n if ( unlikely ( relation == float_relation_unordered ) ) { \n update_fpscr ( env , GETPC ( ) ) ; \n } else { \n env -> sr_t = ( relation == float_relation_greater ) ; \n } \n }", "idx": 23104}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync ( QIODNSResolver * resolver , \n SocketAddressLegacy * addr , \n size_t * naddrs , \n SocketAddressLegacy * * * addrs , \n Error * * errp ) \n { \n switch ( addr -> type ) { \n case SOCKET_ADDRESS_LEGACY_KIND_INET : \n return qio_dns_resolver_lookup_sync_inet ( resolver , \n addr , \n naddrs , \n addrs , \n errp ) ; \n case SOCKET_ADDRESS_LEGACY_KIND_UNIX : \n case SOCKET_ADDRESS_LEGACY_KIND_VSOCK : \n case SOCKET_ADDRESS_LEGACY_KIND_FD : \n return qio_dns_resolver_lookup_sync_nop ( resolver , \n addr , \n naddrs , \n addrs , \n errp ) ; \n default : \n abort ( ) ; \n } \n }", "idx": 23108}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl ( KVMState * s , int type , ... ) \n { \n int ret ; \n void * arg ; \n va_list ap ; \n va_start ( ap , type ) ; \n arg = va_arg ( ap , void * ) ; \n va_end ( ap ) ; \n ret = ioctl ( s -> fd , type , arg ) ; \n if ( ret == -1 ) \n ret = - errno ; \n return ret ; \n }", "idx": 23145}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate ( CPUS390XState * env , target_ulong vaddr , int rw , uint64_t asc , \n target_ulong * raddr , int * flags ) \n { \n int r = -1 ; \n uint8_t * sk ; \n * flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC ; \n vaddr &= TARGET_PAGE_MASK ; \n if ( ! ( env -> psw . mask & PSW_MASK_DAT ) ) { \n * raddr = vaddr ; \n r = 0 ; \n goto out ; \n } \n switch ( asc ) { \n case PSW_ASC_PRIMARY : \n case PSW_ASC_HOME : \n r = mmu_translate_asc ( env , vaddr , asc , raddr , flags , rw ) ; \n break ; \n case PSW_ASC_SECONDARY : \n if ( rw == 2 ) { \n r = mmu_translate_asc ( env , vaddr , PSW_ASC_PRIMARY , raddr , flags , \n rw ) ; \n * flags &= ~ ( PAGE_READ | PAGE_WRITE ) ; \n } else { \n r = mmu_translate_asc ( env , vaddr , PSW_ASC_SECONDARY , raddr , flags , \n rw ) ; \n * flags &= ~ ( PAGE_EXEC ) ; \n } \n break ; \n case PSW_ASC_ACCREG : \n default : \n hw_error ( \" \\n \" ) ; \n break ; \n } \n out : \n * raddr = mmu_real2abs ( env , * raddr ) ; \n if ( * raddr <= ram_size ) { \n sk = & env -> storage_keys [ * raddr / TARGET_PAGE_SIZE ] ; \n if ( * flags & PAGE_READ ) { \n * sk |= SK_R ; \n } \n if ( * flags & PAGE_WRITE ) { \n * sk |= SK_C ; \n } \n } \n return r ; \n }", "idx": 23174}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir ( FsContext * ctx , \n V9fsPath * fs_path , V9fsFidOpenState * fs ) \n { \n int dirfd ; \n DIR * stream ; \n dirfd = local_opendir_nofollow ( ctx , fs_path -> data ) ; \n if ( dirfd == -1 ) { \n return -1 ; \n } \n stream = fdopendir ( dirfd ) ; \n if ( ! stream ) { \n return -1 ; \n } \n fs -> dir . stream = stream ; \n return 0 ; \n }", "idx": 23186}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message ( gint error )  \n { \n HMODULE module = NULL ; \n gchar * retval = NULL ; \n wchar_t * msg = NULL ; \n int flags ; \n size_t nchars ; \n flags = FORMAT_MESSAGE_ALLOCATE_BUFFER | \n FORMAT_MESSAGE_IGNORE_INSERTS | \n FORMAT_MESSAGE_FROM_SYSTEM ; \n if ( error >= NERR_BASE && error <= MAX_NERR ) { \n module = LoadLibraryExW ( L\" \" , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; \n if ( module != NULL ) { \n flags |= FORMAT_MESSAGE_FROM_HMODULE ; \n } \n } \n FormatMessageW ( flags , module , error , 0 , ( LPWSTR ) & msg , 0 , NULL ) ; \n if ( msg != NULL ) { \n nchars = wcslen ( msg ) ; \n if ( nchars > 2 && \n msg [ nchars - 1 ] == L' \\n ' && \n msg [ nchars - 2 ] == L' \\r ' ) { \n msg [ nchars - 2 ] = L' \\0 ' ; \n } \n retval = g_utf16_to_utf8 ( msg , -1 , NULL , NULL , NULL ) ; \n LocalFree ( msg ) ; \n } \n if ( module != NULL ) { \n FreeLibrary ( module ) ; \n } \n return retval ; \n }", "idx": 23213}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush ( void ) \n { \n PCRecord * r , * r_next ; \n int h ; \n for ( h = 0 ; h < PC_REC_HASH_SIZE ; h ++ ) { \n for ( r = pc_rec_hash [ h ] ; r != NULL ; r = r_next ) { \n r_next = r -> next ; \n free ( r ) ; \n } \n pc_rec_hash [ h ] = NULL ; \n } \n nb_pc_records = 0 ; \n }", "idx": 23237}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set ( IscsiLun * iscsilun , int64_t sector_num , \n int nb_sectors ) \n { \n int64_t cluster_num , nb_clusters ; \n if ( iscsilun -> allocationmap == NULL ) { \n return ; \n } \n cluster_num = sector_num / iscsilun -> cluster_sectors ; \n nb_clusters = DIV_ROUND_UP ( sector_num + nb_sectors , \n iscsilun -> cluster_sectors ) - cluster_num ; \n bitmap_set ( iscsilun -> allocationmap , cluster_num , nb_clusters ) ; \n }", "idx": 23244}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric ( void ) \n { \n const char * str = \" \" ; \n char * endptr = NULL ; \n int64_t res ; \n res = qemu_strtosz_metric ( str , & endptr ) ; \n g_assert_cmpint ( res , == , 12345000 ) ; \n g_assert ( endptr == str + 6 ) ; \n }", "idx": 23247}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm ( const char * idstr , \n int instance_id , \n int version_id , \n SaveStateHandler * save_state , \n LoadStateHandler * load_state , \n void * opaque ) \n { \n SaveStateEntry * se , * * pse ; \n se = qemu_malloc ( sizeof ( SaveStateEntry ) ) ; \n if ( ! se ) \n return -1 ; \n pstrcpy ( se -> idstr , sizeof ( se -> idstr ) , idstr ) ; \n se -> instance_id = ( instance_id == -1 ) ? 0 : instance_id ; \n se -> version_id = version_id ; \n se -> save_state = save_state ; \n se -> load_state = load_state ; \n se -> opaque = opaque ; \n se -> next = NULL ; \n pse = & first_se ; \n while ( * pse != NULL ) { \n if ( instance_id == -1 \n && strcmp ( se -> idstr , ( * pse ) -> idstr ) == 0 \n && se -> instance_id <= ( * pse ) -> instance_id ) \n se -> instance_id = ( * pse ) -> instance_id + 1 ; \n pse = & ( * pse ) -> next ; \n } \n * pse = se ; \n return 0 ; \n }", "idx": 23274}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init ( ObjectClass * klass , void * data ) \n { \n DeviceClass * dc = DEVICE_CLASS ( klass ) ; \n dc -> realize = arm_mptimer_realize ; \n dc -> vmsd = & vmstate_arm_mptimer ; \n dc -> reset = arm_mptimer_reset ; \n dc -> no_user = 1 ; \n dc -> props = arm_mptimer_properties ; \n }", "idx": 23277}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl ( CPUMIPSState * env , target_ulong arg1 , \n target_ulong arg2 , int mem_idx ) \n { \n uint64_t tmp ; \n tmp = do_lbu ( env , arg2 , mem_idx ) ; \n arg1 = ( arg1 & 0x00FFFFFFFFFFFFFFULL ) | ( tmp << 56 ) ; \n if ( GET_LMASK64 ( arg2 ) <= 6 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 1 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFF00FFFFFFFFFFFFULL ) | ( tmp << 48 ) ; \n } \n if ( GET_LMASK64 ( arg2 ) <= 5 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 2 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFFFF00FFFFFFFFFFULL ) | ( tmp << 40 ) ; \n } \n if ( GET_LMASK64 ( arg2 ) <= 4 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 3 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFFFFFF00FFFFFFFFULL ) | ( tmp << 32 ) ; \n } \n if ( GET_LMASK64 ( arg2 ) <= 3 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 4 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFFFFFFFF00FFFFFFULL ) | ( tmp << 24 ) ; \n } \n if ( GET_LMASK64 ( arg2 ) <= 2 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 5 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFFFFFFFFFF00FFFFULL ) | ( tmp << 16 ) ; \n } \n if ( GET_LMASK64 ( arg2 ) <= 1 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 6 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFFFFFFFFFFFF00FFULL ) | ( tmp << 8 ) ; \n } \n if ( GET_LMASK64 ( arg2 ) == 0 ) { \n tmp = do_lbu ( env , GET_OFFSET ( arg2 , 7 ) , mem_idx ) ; \n arg1 = ( arg1 & 0xFFFFFFFFFFFFFF00ULL ) | tmp ; \n } \n return arg1 ; \n }", "idx": 23339}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler ( int sig ) \n { \n int status ; \n while ( waitpid ( -1 , & status , WNOHANG ) > 0 ) \n ; \n }", "idx": 23354}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset ( DeviceState * dev ) \n { \n IMXEPITState * s = IMX_EPIT ( dev ) ; \n s -> cr &= ( CR_EN | CR_ENMOD | CR_STOPEN | CR_DOZEN | CR_WAITEN | CR_DBGEN ) ; \n s -> sr = 0 ; \n s -> lr = TIMER_MAX ; \n s -> cmp = 0 ; \n s -> cnt = 0 ; \n ptimer_stop ( s -> timer_cmp ) ; \n ptimer_stop ( s -> timer_reload ) ; \n imx_epit_set_freq ( s ) ; \n ptimer_set_limit ( s -> timer_cmp , TIMER_MAX , 1 ) ; \n ptimer_set_limit ( s -> timer_reload , TIMER_MAX , 1 ) ; \n if ( s -> freq && ( s -> cr & CR_EN ) ) { \n ptimer_run ( s -> timer_reload , 0 ) ; \n } \n }", "idx": 23371}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers ( void ) \n { \n alarm_timer -> stop ( alarm_timer ) ; \n alarm_timer = NULL ; \n }", "idx": 23374}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB * raw_aio_read ( BlockDriverState * bs , \n int64_t sector_num , uint8_t * buf , int nb_sectors , \n BlockDriverCompletionFunc * cb , void * opaque ) \n { \n RawAIOCB * acb ; \n BDRVRawState * s = bs -> opaque ; \n if ( unlikely ( s -> aligned_buf != NULL && ( ( uintptr_t ) buf % 512 ) ) ) { \n QEMUBH * bh ; \n acb = qemu_aio_get ( bs , cb , opaque ) ; \n acb -> ret = raw_pread ( bs , 512 * sector_num , buf , 512 * nb_sectors ) ; \n bh = qemu_bh_new ( raw_aio_em_cb , acb ) ; \n qemu_bh_schedule ( bh ) ; \n return & acb -> common ; \n } \n acb = raw_aio_setup ( bs , sector_num , buf , nb_sectors , cb , opaque ) ; \n if ( ! acb ) \n return NULL ; \n if ( aio_read ( & acb -> aiocb ) < 0 ) { \n qemu_aio_release ( acb ) ; \n return NULL ; \n } \n return & acb -> common ; \n }", "idx": 23393}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv ( BdrvChild * child , \n int64_t sector_num , int nb_sectors , QEMUIOVector * qiov , \n BdrvRequestFlags flags ) \n { \n if ( nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS ) { \n return - EINVAL ; \n } \n return bdrv_co_preadv ( child -> bs , sector_num << BDRV_SECTOR_BITS , \n nb_sectors << BDRV_SECTOR_BITS , qiov , flags ) ; \n }", "idx": 23405}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler ( int signal ) \n { \n qemu_bh_schedule ( sigchld_bh ) ; \n }", "idx": 23411}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq ( S390CPU * cpu , int config_change , uint64_t token ) \n { \n if ( kvm_enabled ( ) ) { \n kvm_s390_virtio_irq ( cpu , config_change , token ) ; \n } else { \n cpu_inject_ext ( cpu , VIRTIO_EXT_CODE , config_change , token ) ; \n } \n }", "idx": 23455}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState * bdrv_next ( BlockDriverState * bs ) \n { \n if ( ! bs ) { \n return QTAILQ_FIRST ( & bdrv_states ) ; \n } \n return QTAILQ_NEXT ( bs , device_list ) ; \n }", "idx": 23491}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write ( void * opaque , target_phys_addr_t addr , \n uint64_t val , unsigned size ) \n { \n mcf_uart_state * s = ( mcf_uart_state * ) opaque ; \n switch ( addr & 0x3f ) { \n case 0x00 : \n s -> mr [ s -> current_mr ] = val ; \n s -> current_mr = 1 ; \n break ; \n case 0x04 : \n break ; \n case 0x08 : \n mcf_do_command ( s , val ) ; \n break ; \n case 0x0c : \n s -> sr &= ~ MCF_UART_TxEMP ; \n s -> tb = val ; \n mcf_uart_do_tx ( s ) ; \n break ; \n case 0x10 : \n break ; \n case 0x14 : \n s -> imr = val ; \n break ; \n default : \n break ; \n } \n mcf_uart_update ( s ) ; \n }", "idx": 23495}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run ( CPUState * cs , struct kvm_run * run ) \n { \n ARMCPU * cpu ; \n uint32_t switched_level ; \n if ( kvm_irqchip_in_kernel ( ) ) { \n return MEMTXATTRS_UNSPECIFIED ; \n } \n cpu = ARM_CPU ( cs ) ; \n if ( run -> s . regs . device_irq_level != cpu -> device_irq_level ) { \n switched_level = cpu -> device_irq_level ^ run -> s . regs . device_irq_level ; \n qemu_mutex_lock_iothread ( ) ; \n if ( switched_level & KVM_ARM_DEV_EL1_VTIMER ) { \n qemu_set_irq ( cpu -> gt_timer_outputs [ GTIMER_VIRT ] , \n ! ! ( run -> s . regs . device_irq_level & \n KVM_ARM_DEV_EL1_VTIMER ) ) ; \n switched_level &= ~ KVM_ARM_DEV_EL1_VTIMER ; \n } \n if ( switched_level & KVM_ARM_DEV_EL1_PTIMER ) { \n qemu_set_irq ( cpu -> gt_timer_outputs [ GTIMER_PHYS ] , \n ! ! ( run -> s . regs . device_irq_level & \n KVM_ARM_DEV_EL1_PTIMER ) ) ; \n switched_level &= ~ KVM_ARM_DEV_EL1_PTIMER ; \n } \n if ( switched_level ) { \n qemu_log_mask ( LOG_UNIMP , \" \\n \" , \n __func__ , switched_level ) ; \n } \n cpu -> device_irq_level = run -> s . regs . device_irq_level ; \n qemu_mutex_unlock_iothread ( ) ; \n } \n return MEMTXATTRS_UNSPECIFIED ; \n }", "idx": 23504}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read ( void * opaque , target_phys_addr_t addr , \n unsigned size ) \n { \n if ( size != 2 ) { \n return omap_badwidth_read16 ( opaque , addr ) ; \n } \n if ( addr == OMAP_MPUI_BASE ) \n return 0xfe4d ; \n OMAP_BAD_REG ( addr ) ; \n return 0 ; \n }", "idx": 23516}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb ( void * opaque , uint32_t addr , uint32_t val ) \n { \n PCIAC97LinkState * d = opaque ; \n AC97LinkState * s = & d -> ac97 ; \n dolog ( \" \\n \" , addr , val ) ; \n s -> cas = 0 ; \n }", "idx": 23540}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize ( DeviceState * dev , Error * * errp ) \n { \n S390FLICState * fs = S390_FLIC_COMMON ( dev ) ; \n uint32_t max_batch = fs -> adapter_routes_max_batch ; \n if ( max_batch > ADAPTER_ROUTES_MAX_GSI ) { \n error_setg ( errp , \" \" \n \" \" , max_batch , ADAPTER_ROUTES_MAX_GSI ) ; \n } \n fs -> ais_supported = true ; \n }", "idx": 23555}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr ( void ) \n { \n target_ulong val ; \n if ( unlikely ( env -> dcr_env == NULL ) ) { \n if ( loglevel != 0 ) { \n fprintf ( logfile , \" \\n \" ) ; \n } \n do_raise_exception_err ( EXCP_PROGRAM , EXCP_INVAL | EXCP_INVAL_INVAL ) ; \n } else if ( unlikely ( ppc_dcr_read ( env -> dcr_env , T0 , & val ) != 0 ) ) { \n if ( loglevel != 0 ) { \n fprintf ( logfile , \" \\n \" , ( int ) T0 , ( int ) T0 ) ; \n } \n do_raise_exception_err ( EXCP_PROGRAM , EXCP_INVAL | EXCP_PRIV_REG ) ; \n } else { \n T0 = val ; \n } \n }", "idx": 23587}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write ( Monitor * mon , const QDict * qdict ) \n { \n uint32_t size ; \n const char * chardev = qdict_get_str ( qdict , \" \" ) ; \n const char * data = qdict_get_str ( qdict , \" \" ) ; \n Error * errp = NULL ; \n size = strlen ( data ) ; \n qmp_memchar_write ( chardev , size , data , false , 0 , & errp ) ; \n hmp_handle_error ( mon , & errp ) ; \n }", "idx": 23656}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write ( void * opaque , hwaddr addr , \n uint64_t val , unsigned size ) \n { \n MaltaFPGAState * s = opaque ; \n uint32_t saddr ; \n saddr = ( addr & 0xfffff ) ; \n switch ( saddr ) { \n case 0x00200 : \n break ; \n case 0x00210 : \n break ; \n case 0x00408 : \n s -> leds = val & 0xff ; \n malta_fpga_update_display ( s ) ; \n break ; \n case 0x00410 : \n snprintf ( s -> display_text , 9 , \" \" , ( uint32_t ) val ) ; \n malta_fpga_update_display ( s ) ; \n break ; \n case 0x00418 : \n case 0x00420 : \n case 0x00428 : \n case 0x00430 : \n case 0x00438 : \n case 0x00440 : \n case 0x00448 : \n case 0x00450 : \n s -> display_text [ ( saddr - 0x00418 ) >> 3 ] = ( char ) val ; \n malta_fpga_update_display ( s ) ; \n break ; \n case 0x00500 : \n if ( val == 0x42 ) \n qemu_system_reset_request ( ) ; \n break ; \n case 0x00508 : \n s -> brk = val & 0xff ; \n break ; \n case 0x00a00 : \n s -> gpout = val & 0xff ; \n break ; \n case 0x00b08 : \n s -> i2coe = val & 0x03 ; \n break ; \n case 0x00b10 : \n eeprom24c0x_write ( val & 0x02 , val & 0x01 ) ; \n s -> i2cout = val ; \n break ; \n case 0x00b18 : \n s -> i2csel = val & 0x01 ; \n break ; \n default : \n #if 0  \n  \n  printf ( \" \" TARGET_FMT_lx \" \\n \" , \n addr ) ; \n #endif \n break ; \n } \n }", "idx": 23688}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet ( GArray * table_data , GArray * linker )  \n { \n Acpi20Hpet * hpet ; \n hpet = acpi_data_push ( table_data , sizeof ( * hpet ) ) ; \n hpet -> timer_block_id = cpu_to_le32 ( 0x8086a201 ) ; \n hpet -> addr . address = cpu_to_le64 ( HPET_BASE ) ; \n build_header ( linker , table_data , \n ( void * ) hpet , \" \" , sizeof ( * hpet ) , 1 , NULL ) ; \n }", "idx": 23696}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map ( VirtIOPCIProxy * proxy , \n VirtIOPCIRegion * region , \n struct virtio_pci_cap * cap ) \n { \n memory_region_add_subregion ( & proxy -> modern_bar , \n region -> offset , \n & region -> mr ) ; \n cap -> cfg_type = region -> type ; \n cap -> offset = cpu_to_le32 ( region -> offset ) ; \n cap -> length = cpu_to_le32 ( memory_region_size ( & region -> mr ) ) ; \n virtio_pci_add_mem_cap ( proxy , cap ) ; \n }", "idx": 23744}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard ( BlockDriverState * bs , int64_t offset , int count ) \n { \n Coroutine * co ; \n DiscardCo rwco = { \n . bs = bs , \n . offset = offset , \n . count = count , \n . ret = NOT_DONE , \n } ; \n if ( qemu_in_coroutine ( ) ) { \n bdrv_pdiscard_co_entry ( & rwco ) ; \n } else { \n AioContext * aio_context = bdrv_get_aio_context ( bs ) ; \n co = qemu_coroutine_create ( bdrv_pdiscard_co_entry , & rwco ) ; \n qemu_coroutine_enter ( co ) ; \n while ( rwco . ret == NOT_DONE ) { \n aio_poll ( aio_context , true ) ; \n } \n } \n return rwco . ret ; \n }", "idx": 23751}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER ( stby_b ) ( CPUHPPAState * env , target_ulong addr , target_ulong val ) \n { \n uintptr_t ra = GETPC ( ) ; \n switch ( addr & 3 ) { \n case 3 : \n cpu_stb_data_ra ( env , addr , val , ra ) ; \n break ; \n case 2 : \n cpu_stw_data_ra ( env , addr , val , ra ) ; \n break ; \n case 1 : \n if ( parallel_cpus ) { \n atomic_store_3 ( env , addr , val , 0x00ffffffu , ra ) ; \n } else { \n cpu_stb_data_ra ( env , addr , val >> 16 , ra ) ; \n cpu_stw_data_ra ( env , addr + 1 , val , ra ) ; \n } \n break ; \n default : \n cpu_stl_data_ra ( env , addr , val , ra ) ; \n break ; \n } \n }", "idx": 23758}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias ( MemoryRegion * mr ) \n { \n memory_region_unref ( mr -> alias ) ; \n }", "idx": 23771}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts * qemu_opts_from_qdict ( QemuOptsList * list , const QDict * qdict ) \n { \n QemuOpts * opts ; \n opts = qemu_opts_create ( list , qdict_get_try_str ( qdict , \" \" ) , 1 ) ; \n if ( opts == NULL ) \n return NULL ; \n qdict_iter ( qdict , qemu_opts_from_qdict_1 , opts ) ; \n return opts ; \n }", "idx": 23809}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch ( DBDMA_channel * ch ) \n { \n dbdma_cmd * current = & ch -> current ; \n uint16_t br ; \n uint16_t sel_mask , sel_value ; \n uint32_t status ; \n int cond ; \n DBDMA_DPRINTF ( \" \\n \" ) ; \n br = le16_to_cpu ( current -> command ) & BR_MASK ; \n switch ( br ) { \n case BR_NEVER : \n next ( ch ) ; \n return ; \n case BR_ALWAYS : \n branch ( ch ) ; \n return ; \n } \n status = be32_to_cpu ( ch -> regs [ DBDMA_STATUS ] ) & DEVSTAT ; \n sel_mask = ( be32_to_cpu ( ch -> regs [ DBDMA_BRANCH_SEL ] ) >> 16 ) & 0x0f ; \n sel_value = be32_to_cpu ( ch -> regs [ DBDMA_BRANCH_SEL ] ) & 0x0f ; \n cond = ( status & sel_mask ) == ( sel_value & sel_mask ) ; \n switch ( br ) { \n case BR_IFSET : \n if ( cond ) \n branch ( ch ) ; \n else \n next ( ch ) ; \n return ; \n case BR_IFCLR : \n if ( ! cond ) \n branch ( ch ) ; \n else \n next ( ch ) ; \n return ; \n } \n }", "idx": 23816}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept ( void ) \n { \n GDBState * s ; \n struct sockaddr_in sockaddr ; \n socklen_t len ; \n int fd ; \n for ( ; ; ) { \n len = sizeof ( sockaddr ) ; \n fd = accept ( gdbserver_fd , ( struct sockaddr * ) & sockaddr , & len ) ; \n if ( fd < 0 && errno != EINTR ) { \n perror ( \" \" ) ; \n return ; \n } else if ( fd >= 0 ) { \n #ifndef _WIN32 \n fcntl ( fd , F_SETFD , FD_CLOEXEC ) ; \n #endif \n break ; \n } \n } \n socket_set_nodelay ( fd ) ; \n s = g_malloc0 ( sizeof ( GDBState ) ) ; \n s -> c_cpu = first_cpu ; \n s -> g_cpu = first_cpu ; \n s -> fd = fd ; \n gdb_has_xml = false ; \n gdbserver_state = s ; \n fcntl ( fd , F_SETFL , O_NONBLOCK ) ; \n }", "idx": 23855}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit ( const unsigned long * addr , unsigned long size , \n unsigned long offset ) \n { \n const unsigned long * p = addr + BITOP_WORD ( offset ) ; \n unsigned long result = offset & ~ ( BITS_PER_LONG - 1 ) ; \n unsigned long tmp ; \n if ( offset >= size ) { \n return size ; \n } \n size -= result ; \n offset %= BITS_PER_LONG ; \n if ( offset ) { \n tmp = * ( p ++ ) ; \n tmp |= ~ 0UL >> ( BITS_PER_LONG - offset ) ; \n if ( size < BITS_PER_LONG ) { \n goto found_first ; \n } \n if ( ~ tmp ) { \n goto found_middle ; \n } \n size -= BITS_PER_LONG ; \n result += BITS_PER_LONG ; \n } \n while ( size & ~ ( BITS_PER_LONG - 1 ) ) { \n if ( ~ ( tmp = * ( p ++ ) ) ) { \n goto found_middle ; \n } \n result += BITS_PER_LONG ; \n size -= BITS_PER_LONG ; \n } \n if ( ! size ) { \n return result ; \n } \n tmp = * p ; \n found_first : \n tmp |= ~ 0UL << size ; \n if ( tmp == ~ 0UL ) { \n return result + size ; \n } \n found_middle : \n return result + ffz ( tmp ) ; \n }", "idx": 23888}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct ( Visitor * v , Error * * errp ) \n { \n assert ( ! error_is_set ( errp ) ) ; \n if ( v -> end_implicit_struct ) { \n v -> end_implicit_struct ( v , errp ) ; \n } \n }", "idx": 23895}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length ( NBDClient * client , bool fatal , Error * * errp ) \n { \n int ret ; \n assert ( client -> optlen ) ; \n if ( nbd_drop ( client -> ioc , client -> optlen , errp ) < 0 ) { \n return - EIO ; \n } \n ret = nbd_negotiate_send_rep_err ( client , NBD_REP_ERR_INVALID , errp , \n \" \" , \n nbd_opt_lookup ( client -> opt ) ) ; \n if ( fatal && ! ret ) { \n error_setg ( errp , \" \" , \n nbd_opt_lookup ( client -> opt ) ) ; \n return - EINVAL ; \n } \n return ret ; \n }", "idx": 23899}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property ( const char * node_path , const char * prop , \n void * val , size_t len ) \n { \n char * path ; \n FILE * f ; \n int ret ; \n int pathlen ; \n pathlen = snprintf ( NULL , 0 , \" \" , PROC_DEVTREE_PATH , node_path , prop ) \n + 1 ; \n path = qemu_malloc ( pathlen ) ; \n if ( path == NULL ) { \n ret = - ENOMEM ; \n goto out ; \n } \n snprintf ( path , pathlen , \" \" , PROC_DEVTREE_PATH , node_path , prop ) ; \n f = fopen ( path , \" \" ) ; \n if ( f == NULL ) { \n ret = errno ; \n goto free ; \n } \n len = fread ( val , len , 1 , f ) ; \n if ( len != 1 ) { \n ret = ferror ( f ) ; \n goto close ; \n } \n close : \n fclose ( f ) ; \n free : \n free ( path ) ; \n out : \n return ret ; \n }", "idx": 23912}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup ( OptsVisitor * ov )  \n { \n if ( ov -> unprocessed_opts != NULL ) { \n g_hash_table_destroy ( ov -> unprocessed_opts ) ; \n } \n g_free ( ov -> fake_id_opt ) ; \n memset ( ov , ' \\0 ' , sizeof * ov ) ; \n }", "idx": 23918}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize ( int64_t new_size , Error * * errp ) \n { \n PageCache * new_cache ; \n int64_t ret ; \n if ( new_size != ( size_t ) new_size ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_VALUE , \" \" , \n \" \" ) ; \n return -1 ; \n } \n if ( new_size > ram_bytes_total ( ) ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_VALUE , \" \" , \n \" \" ) ; \n return -1 ; \n } \n XBZRLE_cache_lock ( ) ; \n if ( XBZRLE . cache != NULL ) { \n if ( pow2floor ( new_size ) == migrate_xbzrle_cache_size ( ) ) { \n goto out_new_size ; \n } \n new_cache = cache_init ( new_size , TARGET_PAGE_SIZE , errp ) ; \n if ( ! new_cache ) { \n ret = -1 ; \n goto out ; \n } \n cache_fini ( XBZRLE . cache ) ; \n XBZRLE . cache = new_cache ; \n } \n out_new_size : \n ret = pow2floor ( new_size ) ; \n out : \n XBZRLE_cache_unlock ( ) ; \n return ret ; \n }", "idx": 23924}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset ( DeviceState * dev ) \n { \n IMXGPTState * s = IMX_GPT ( dev ) ; \n ptimer_stop ( s -> timer ) ; \n s -> cr &= ~ ( GPT_CR_EN | GPT_CR_ENMOD | GPT_CR_STOPEN | GPT_CR_DOZEN | \n GPT_CR_WAITEN | GPT_CR_DBGEN ) ; \n s -> sr = 0 ; \n s -> pr = 0 ; \n s -> ir = 0 ; \n s -> cnt = 0 ; \n s -> ocr1 = TIMER_MAX ; \n s -> ocr2 = TIMER_MAX ; \n s -> ocr3 = TIMER_MAX ; \n s -> icr1 = 0 ; \n s -> icr2 = 0 ; \n s -> next_timeout = TIMER_MAX ; \n s -> next_int = 0 ; \n imx_gpt_set_freq ( s ) ; \n ptimer_set_limit ( s -> timer , TIMER_MAX , 1 ) ; \n if ( s -> freq && ( s -> cr & GPT_CR_EN ) ) { \n ptimer_run ( s -> timer , 1 ) ; \n } \n }", "idx": 23938}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer ( struct qemu_alarm_timer * t ) \n { \n struct sigevent ev ; \n timer_t host_timer ; \n struct sigaction act ; \n sigfillset ( & act . sa_mask ) ; \n act . sa_flags = 0 ; \n act . sa_handler = host_alarm_handler ; \n sigaction ( SIGALRM , & act , NULL ) ; \n ev . sigev_value . sival_int = 0 ; \n ev . sigev_notify = SIGEV_SIGNAL ; \n ev . sigev_signo = SIGALRM ; \n if ( timer_create ( CLOCK_REALTIME , & ev , & host_timer ) ) { \n perror ( \" \" ) ; \n fprintf ( stderr , \" \\n \" ) ; \n return -1 ; \n } \n t -> priv = ( void * ) ( long ) host_timer ; \n return 0 ; \n }", "idx": 23942}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event ( uint8_t cc , uint16_t pec , uint32_t fh , \n uint32_t fid , uint64_t faddr , uint32_t e ) \n { \n SeiContainer * sei_cont = g_malloc0 ( sizeof ( SeiContainer ) ) ; \n S390pciState * s = S390_PCI_HOST_BRIDGE ( \n object_resolve_path ( TYPE_S390_PCI_HOST_BRIDGE , NULL ) ) ; \n if ( ! s ) { \n return ; \n } \n sei_cont -> fh = fh ; \n sei_cont -> fid = fid ; \n sei_cont -> cc = cc ; \n sei_cont -> pec = pec ; \n sei_cont -> faddr = faddr ; \n sei_cont -> e = e ; \n QTAILQ_INSERT_TAIL ( & s -> pending_sei , sei_cont , link ) ; \n css_generate_css_crws ( 0 ) ; \n }", "idx": 23947}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov ( DisasContext * ctx , TCGv arg0 , \n TCGv arg1 , TCGv arg2 , int sub ) \n { \n TCGv t0 = tcg_temp_new ( ) ; \n tcg_gen_xor_tl ( cpu_ov , arg0 , arg1 ) ; \n tcg_gen_xor_tl ( t0 , arg1 , arg2 ) ; \n if ( sub ) { \n tcg_gen_and_tl ( cpu_ov , cpu_ov , t0 ) ; \n } else { \n tcg_gen_andc_tl ( cpu_ov , cpu_ov , t0 ) ; \n } \n tcg_temp_free ( t0 ) ; \n if ( NARROW_MODE ( ctx ) ) { \n tcg_gen_ext32s_tl ( cpu_ov , cpu_ov ) ; \n } \n tcg_gen_shri_tl ( cpu_ov , cpu_ov , TARGET_LONG_BITS - 1 ) ; \n tcg_gen_or_tl ( cpu_so , cpu_so , cpu_ov ) ; \n }", "idx": 24009}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset ( CPUState * cpu ) \n { \n CPUClass * cc = CPU_GET_CLASS ( cpu ) ; \n if ( qemu_loglevel_mask ( CPU_LOG_RESET ) ) { \n qemu_log ( \" \\n \" , cpu -> cpu_index ) ; \n log_cpu_state ( cpu , cc -> reset_dump_flags ) ; \n } \n cpu -> interrupt_request = 0 ; \n cpu -> halted = 0 ; \n cpu -> mem_io_pc = 0 ; \n cpu -> mem_io_vaddr = 0 ; \n cpu -> icount_extra = 0 ; \n cpu -> icount_decr . u32 = 0 ; \n cpu -> can_do_io = 1 ; \n cpu -> exception_index = -1 ; \n cpu -> crash_occurred = false ; \n if ( tcg_enabled ( ) ) { \n cpu_tb_jmp_cache_clear ( cpu ) ; \n #ifdef CONFIG_SOFTMMU \n tlb_flush ( cpu , 0 ) ; \n #endif \n } \n }", "idx": 24044}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach ( QemuOptsList * list , qemu_opts_loopfunc func , void * opaque , \n int abort_on_failure ) \n { \n QemuOpts * opts ; \n int rc = 0 ; \n TAILQ_FOREACH ( opts , & list -> head , next )  { \n rc = func ( opts , opaque ) ; \n if ( abort_on_failure && rc != 0 ) \n break ; \n } \n return rc ; \n }", "idx": 24047}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write ( void * opaque , target_phys_addr_t addr , \n uint64_t value , unsigned len ) \n { \n subpage_t * mmio = opaque ; \n unsigned int idx = SUBPAGE_IDX ( addr ) ; \n MemoryRegionSection * section ; \n #if defined ( DEBUG_SUBPAGE )  \n  \n  printf ( \" \" TARGET_FMT_plx \n \" \" PRIx64 \" \\n \" , \n __func__ , mmio , len , addr , idx , value ) ; \n #endif \n section = & phys_sections [ mmio -> sub_section [ idx ] ] ; \n addr += mmio -> base ; \n addr -= section -> offset_within_address_space ; \n addr += section -> offset_within_region ; \n io_mem_write ( section -> mr , addr , value , len ) ; \n }", "idx": 24050}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache ( CPUState * cpu , target_ulong addr ) \n { \n unsigned int i ; \n i = tb_jmp_cache_hash_page ( addr - TARGET_PAGE_SIZE ) ; \n memset ( & cpu -> tb_jmp_cache [ i ] , 0 , \n TB_JMP_PAGE_SIZE * sizeof ( TranslationBlock * ) ) ; \n i = tb_jmp_cache_hash_page ( addr ) ; \n memset ( & cpu -> tb_jmp_cache [ i ] , 0 , \n TB_JMP_PAGE_SIZE * sizeof ( TranslationBlock * ) ) ; \n }", "idx": 24075}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState * bdrv_get_attached ( BlockDriverState * bs ) \n { \n return bs -> peer ; \n }", "idx": 24084}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push ( QapiDeallocVisitor * qov , void * value ) \n { \n StackEntry * e = g_malloc0 ( sizeof ( * e ) ) ; \n e -> value = value ; \n if ( value == NULL ) { \n e -> is_list_head = true ; \n } \n QTAILQ_INSERT_HEAD ( & qov -> stack , e , node ) ; \n }", "idx": 24085}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void * vnc_zlib_zalloc ( void * x , unsigned items , unsigned size ) \n { \n void * p ; \n size *= items ; \n size = ( size + ZALLOC_ALIGNMENT - 1 ) & ~ ( ZALLOC_ALIGNMENT - 1 ) ; \n p = qemu_mallocz ( size ) ; \n return ( p ) ; \n }", "idx": 24087}
{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state ( AcpiNVDIMMState * state , MemoryRegion * io , \n FWCfgState * fw_cfg , Object * owner ) \n { \n memory_region_init_io ( & state -> io_mr , owner , & nvdimm_dsm_ops , state , \n \" \" , NVDIMM_ACPI_IO_LEN ) ; \n memory_region_add_subregion ( io , NVDIMM_ACPI_IO_BASE , & state -> io_mr ) ; \n state -> dsm_mem = g_array_new ( false , true \n , 1 ) ; \n acpi_data_push ( state -> dsm_mem , TARGET_PAGE_SIZE ) ; \n fw_cfg_add_file ( fw_cfg , NVDIMM_DSM_MEM_FILE , state -> dsm_mem -> data , \n state -> dsm_mem -> len ) ; \n }", "idx": 24100}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd ( EHCIQueue * q , target_phys_addr_t addr , EHCIqtd * qtd ) \n { \n trace_usb_ehci_qtd ( q , addr , qtd -> next , qtd -> altnext , \n get_field ( qtd -> token , QTD_TOKEN_TBYTES ) , \n get_field ( qtd -> token , QTD_TOKEN_CPAGE ) , \n get_field ( qtd -> token , QTD_TOKEN_CERR ) , \n get_field ( qtd -> token , QTD_TOKEN_PID ) , \n ( bool ) ( qtd -> token & QTD_TOKEN_IOC ) , \n ( bool ) ( qtd -> token & QTD_TOKEN_ACTIVE ) , \n ( bool ) ( qtd -> token & QTD_TOKEN_HALT ) , \n ( bool ) ( qtd -> token & QTD_TOKEN_BABBLE ) , \n ( bool ) ( qtd -> token & QTD_TOKEN_XACTERR ) ) ; \n }", "idx": 24123}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit ( PCIDevice * d ) \n { \n MegasasState * s = MEGASAS ( d ) ; \n if ( megasas_use_msix ( s ) ) { \n msix_uninit ( d , & s -> mmio_io , & s -> mmio_io ) ; \n } \n if ( megasas_use_msi ( s ) ) { \n msi_uninit ( d ) ; \n } \n }", "idx": 24141}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi ( VFIODevice * vbasedev ) \n { \n VFIOINTp * intp ; \n VFIOPlatformDevice * vdev = \n container_of ( vbasedev , VFIOPlatformDevice , vbasedev ) ; \n qemu_mutex_lock ( & vdev -> intp_mutex ) ; \n QLIST_FOREACH ( intp , & vdev -> intp_list , next )  { \n if ( intp -> state == VFIO_IRQ_ACTIVE ) { \n trace_vfio_platform_eoi ( intp -> pin , \n event_notifier_get_fd ( & intp -> interrupt ) ) ; \n intp -> state = VFIO_IRQ_INACTIVE ; \n qemu_set_irq ( intp -> qemuirq , 0 ) ; \n if ( intp -> flags & VFIO_IRQ_INFO_AUTOMASKED ) { \n vfio_unmask_single_irqindex ( vbasedev , intp -> pin ) ; \n } \n break ; \n } \n } \n if ( ! QSIMPLEQ_EMPTY ( & vdev -> pending_intp_queue ) ) { \n intp = QSIMPLEQ_FIRST ( & vdev -> pending_intp_queue ) ; \n vfio_intp_inject_pending_lockheld ( intp ) ; \n QSIMPLEQ_REMOVE_HEAD ( & vdev -> pending_intp_queue , pqnext ) ; \n } \n qemu_mutex_unlock ( & vdev -> intp_mutex ) ; \n }", "idx": 24162}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg ( DisasContext * s , int rlow , int rhigh , TCGv val ) \n { \n TCGv tmp ; \n tmp = new_tmp ( ) ; \n tcg_gen_trunc_i64_i32 ( tmp , val ) ; \n store_reg ( s , rlow , tmp ) ; \n tmp = new_tmp ( ) ; \n tcg_gen_shri_i64 ( val , val , 32 ) ; \n tcg_gen_trunc_i64_i32 ( tmp , val ) ; \n store_reg ( s , rhigh , tmp ) ; \n }", "idx": 24164}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number ( void ) \n { \n QObject * obj ; \n QInt * qint ; \n QFloat * qfloat ; \n int value = 0x2342 ; \n int64_t value64 = 0x2342342343LL ; \n double valuef = 2.323423423 ; \n obj = qobject_from_jsonf ( \" \" , value ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QINT ) ; \n qint = qobject_to_qint ( obj ) ; \n g_assert ( qint_get_int ( qint ) == value ) ; \n QDECREF ( qint ) ; \n obj = qobject_from_jsonf ( \" \" PRId64 , value64 ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QINT ) ; \n qint = qobject_to_qint ( obj ) ; \n g_assert ( qint_get_int ( qint ) == value64 ) ; \n QDECREF ( qint ) ; \n obj = qobject_from_jsonf ( \" \" , valuef ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QFLOAT ) ; \n qfloat = qobject_to_qfloat ( obj ) ; \n g_assert ( qfloat_get_double ( qfloat ) == valuef ) ; \n QDECREF ( qfloat ) ; \n }", "idx": 24179}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable ( S390PCIBusDevice * pbdev ) \n { \n memory_region_del_subregion ( & pbdev -> mr , & pbdev -> iommu_mr ) ; \n object_unparent ( OBJECT ( & pbdev -> iommu_mr ) ) ; \n pbdev -> iommu_enabled = false ; \n }", "idx": 24201}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int ( TestOutputVisitorData * data , \n const void * unused ) \n { \n int64_t value = -42 ; \n QObject * obj ; \n visit_type_int ( data -> ov , NULL , & value , & error_abort ) ; \n obj = visitor_get ( data ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QINT ) ; \n g_assert_cmpint ( qint_get_int ( qobject_to_qint ( obj ) ) , == , value ) ; \n }", "idx": 24212}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove ( Monitor * mon , const char * src_str ) \n { \n struct in_addr host_addr = { . s_addr = INADDR_ANY } ; \n int host_port ; \n char buf [ 256 ] = \" \" ; \n const char * p = src_str ; \n int is_udp = 0 ; \n int n ; \n if ( ! slirp_inited ) { \n monitor_printf ( mon , \" \\n \" ) ; \n return ; \n } \n if ( ! src_str || ! src_str [ 0 ] ) \n goto fail_syntax ; \n get_str_sep ( buf , sizeof ( buf ) , & p , ' ' ) ; \n if ( ! strcmp ( buf , \" \" ) || buf [ 0 ] == ' \\0 ' ) { \n is_udp = 0 ; \n } else if ( ! strcmp ( buf , \" \" ) ) { \n is_udp = 1 ; \n } else { \n goto fail_syntax ; \n } \n if ( get_str_sep ( buf , sizeof ( buf ) , & p , ' ' ) < 0 ) { \n goto fail_syntax ; \n } \n if ( buf [ 0 ] != ' \\0 ' && ! inet_aton ( buf , & host_addr ) ) { \n goto fail_syntax ; \n } \n host_port = atoi ( p ) ; \n n = slirp_remove_hostfwd ( is_udp , host_addr , host_port ) ; \n monitor_printf ( mon , \" \\n \" , n , \n src_str ) ; \n return ; \n fail_syntax : \n monitor_printf ( mon , \" \\n \" ) ; \n }", "idx": 24213}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void * qemu_fopen_rdma ( RDMAContext * rdma , const char * mode ) \n { \n QEMUFileRDMA * r = g_malloc0 ( sizeof ( QEMUFileRDMA ) ) ; \n if ( qemu_file_mode_is_not_valid ( mode ) ) { \n return NULL ; \n } \n r -> rdma = rdma ; \n if ( mode [ 0 ] == ' ' ) { \n r -> file = qemu_fopen_ops ( r , & rdma_write_ops ) ; \n } else { \n r -> file = qemu_fopen_ops ( r , & rdma_read_ops ) ; \n } \n return r -> file ; \n }", "idx": 24231}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain ( BlockDriverState * bs ) \n { \n bool busy = true ; \n bdrv_drain_recurse ( bs ) ; \n while ( busy ) { \n bdrv_flush_io_queue ( bs ) ; \n busy = bdrv_requests_pending ( bs ) ; \n busy |= aio_poll ( bdrv_get_aio_context ( bs ) , busy ) ;", "idx": 24292}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop ( void ) \n { \n bool nonblocking ; \n int last_io  __attribute__ ( ( unused ) ) = 0 ; \n #ifdef CONFIG_PROFILER \n int64_t ti ; \n #endif \n int r ; \n qemu_main_loop_start ( ) ; \n for ( ; ; ) { \n #ifdef CONFIG_IOTHREAD \n nonblocking = ! kvm_enabled ( ) && last_io > 0 ; \n #else \n nonblocking = cpu_exec_all ( ) ; \n if ( vm_request_pending ( ) ) { \n nonblocking = true ; \n } \n #endif \n #ifdef CONFIG_PROFILER \n ti = profile_getclock ( ) ; \n #endif \n last_io = main_loop_wait ( nonblocking ) ; \n #ifdef CONFIG_PROFILER \n dev_time += profile_getclock ( ) - ti ; \n #endif \n if ( qemu_debug_requested ( ) ) { \n vm_stop ( VMSTOP_DEBUG ) ; \n } \n if ( qemu_shutdown_requested ( ) ) { \n qemu_kill_report ( ) ; \n monitor_protocol_event ( QEVENT_SHUTDOWN , NULL ) ; \n if ( no_shutdown ) { \n vm_stop ( VMSTOP_SHUTDOWN ) ; \n } else \n break ; \n } \n if ( qemu_reset_requested ( ) ) { \n pause_all_vcpus ( ) ; \n cpu_synchronize_all_states ( ) ; \n qemu_system_reset ( VMRESET_REPORT ) ; \n resume_all_vcpus ( ) ; \n } \n if ( qemu_powerdown_requested ( ) ) { \n monitor_protocol_event ( QEVENT_POWERDOWN , NULL ) ; \n qemu_irq_raise ( qemu_system_powerdown ) ; \n } \n if ( ( r = qemu_vmstop_requested ( ) ) ) { \n vm_stop ( r ) ; \n } \n } \n bdrv_close_all ( ) ; \n pause_all_vcpus ( ) ; \n }", "idx": 24294}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features ( FILE * f , \n int ( * cpu_fprintf ) ( FILE * f , const char * fmt , ... ) , \n uint32_t features , const char * prefix ) \n { \n unsigned int i ; \n for ( i = 0 ; i < ARRAY_SIZE ( feature_name ) ; i ++ ) \n if ( feature_name [ i ] && ( features & ( 1 << i ) ) ) { \n if ( prefix ) \n ( * cpu_fprintf ) ( f , \" \" , prefix ) ; \n ( * cpu_fprintf ) ( f , \" \" , feature_name [ i ] ) ; \n } \n }", "idx": 24312}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char * qobject_input_get_keyval ( QObjectInputVisitor * qiv , \n const char * name , \n Error * * errp ) \n { \n QObject * qobj ; \n QString * qstr ; \n qobj = qobject_input_get_object ( qiv , name , true , errp ) ; \n if ( ! qobj ) { \n return NULL ; \n } \n qstr = qobject_to_qstring ( qobj ) ; \n if ( ! qstr ) { \n error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , \n full_name ( qiv , name ) , \" \" ) ; \n return NULL ; \n } \n return qstring_get_str ( qstr ) ; \n }", "idx": 24328}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize ( Object * obj ) \n { \n QIOChannelSocket * ioc = QIO_CHANNEL_SOCKET ( obj ) ; \n if ( ioc -> fd != -1 ) { \n #ifdef WIN32 \n WSAEventSelect ( ioc -> fd , NULL , 0 ) ; \n #endif \n closesocket ( ioc -> fd ) ; \n ioc -> fd = -1 ;", "idx": 24331}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init ( void ) \n { \n char mount_point [ PATH_MAX ] ; \n char path [ PATH_MAX ] ; \n int debugfs_found ; \n int trace_fd = -1 ; \n debugfs_found = find_mount ( mount_point , \" \" ) ; \n if ( debugfs_found ) { \n snprintf ( path , PATH_MAX , \" \" , mount_point ) ; \n trace_fd = open ( path , O_WRONLY ) ; \n if ( trace_fd < 0 ) { \n if ( errno == EACCES ) { \n trace_marker_fd = open ( \" \" , O_WRONLY ) ; \n if ( trace_marker_fd != -1 ) { \n return true ; \n } \n } \n perror ( \" \" ) ; \n return false ; \n } else { \n if ( write ( trace_fd , \" \" , 1 ) < 0 ) { \n perror ( \" \" ) ; \n close ( trace_fd ) ; \n return false ; \n } \n close ( trace_fd ) ; \n } \n snprintf ( path , PATH_MAX , \" \" , mount_point ) ; \n trace_marker_fd = open ( path , O_WRONLY ) ; \n if ( trace_marker_fd < 0 ) { \n perror ( \" \" ) ; \n return false ; \n } \n } else { \n fprintf ( stderr , \" \\n \" ) ; \n return false ; \n } \n return true ; \n }", "idx": 24351}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int ( Visitor * v , int64_t * obj , const char * name , Error * * errp ) \n { \n if ( ! error_is_set ( errp ) ) { \n v -> type_int ( v , obj , name , errp ) ; \n } \n }", "idx": 24364}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push ( gnutls_transport_ptr_t transport , \n const void * data , \n size_t len ) { \n VncState * vs = ( VncState * ) transport ; \n int ret ; \n retry : \n ret = send ( vs -> csock , data , len , 0 ) ; \n if ( ret < 0 ) { \n if ( errno == EINTR ) \n goto retry ; \n return -1 ; \n } \n return ret ; \n }", "idx": 24485}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum ( Object * obj , Visitor * v , void * opaque , \n const char * name , Error * * errp ) \n { \n EnumProperty * prop = opaque ; \n int value ; \n visit_type_enum ( v , & value , prop -> strings , NULL , name , errp ) ; \n prop -> set ( obj , value , errp ) ; \n }", "idx": 24486}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject ( const char * device , bool has_force , bool force , Error * * errp ) \n { \n Error * local_err = NULL ; \n int rc ; \n if ( ! has_force ) { \n force = false ; \n } \n rc = do_open_tray ( device , force , & local_err ) ; \n if ( local_err ) { \n error_propagate ( errp , local_err ) ; \n return ; \n } \n if ( rc == EINPROGRESS ) { \n error_setg ( errp , \" \" \n \" \" , device ) ; \n return ; \n } \n qmp_x_blockdev_remove_medium ( device , errp ) ; \n }", "idx": 24501}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot ( int prot , int rw , int access_type ) \n { \n int ret ; \n if ( access_type == ACCESS_CODE ) { \n if ( prot & PAGE_EXEC ) { \n ret = 0 ; \n } else { \n ret = -2 ; \n } \n } else if ( rw ) { \n if ( prot & PAGE_WRITE ) { \n ret = 0 ; \n } else { \n ret = -2 ; \n } \n } else { \n if ( prot & PAGE_READ ) { \n ret = 0 ; \n } else { \n ret = -2 ; \n } \n } \n return ret ; \n }", "idx": 24508}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def ( target_long * pval , const char * name ) \n { \n const MonitorDef * md ; \n void * ptr ; \n for ( md = monitor_defs ; md -> name != NULL ; md ++ ) { \n if ( compare_cmd ( name , md -> name ) ) { \n if ( md -> get_value ) { \n * pval = md -> get_value ( md , md -> offset ) ; \n } else { \n CPUState * env = mon_get_cpu ( ) ; \n if ( ! env ) \n return -2 ; \n ptr = ( uint8_t * ) env + md -> offset ; \n switch ( md -> type ) { \n case MD_I32 : \n * pval = * ( int32_t * ) ptr ; \n break ; \n case MD_TLONG : \n * pval = * ( target_long * ) ptr ; \n break ; \n default : \n * pval = 0 ; \n break ; \n } \n } \n return 0 ; \n } \n } \n return -1 ; \n }", "idx": 24559}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2 ( CPUState * env , target_ulong frame_addr , \n struct target_ucontext_v2 * uc ) \n { \n sigset_t host_set ; \n abi_ulong * regspace ; \n target_to_host_sigset ( & host_set , & uc -> tuc_sigmask ) ; \n sigprocmask ( SIG_SETMASK , & host_set , NULL ) ; \n if ( restore_sigcontext ( env , & uc -> tuc_mcontext ) ) \n if ( do_sigaltstack ( frame_addr + offsetof ( struct target_ucontext_v2 , tuc_stack ) , 0 , get_sp_from_cpustate ( env ) ) == - EFAULT )  \n #if 0  \n  \n  if ( ptrace_cancel_bpt ( current ) ) \n send_sig ( SIGTRAP , current , 1 ) ; \n #endif \n return 0 ; ", "idx": 24578}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key ( VncState * vs , int keysym ) \n { \n int keycode = keysym2scancode ( vs -> vd -> kbd_layout , keysym ) & SCANCODE_KEYMASK ; \n qemu_input_event_send_key_number ( vs -> vd -> dcl . con , keycode , true ) ; \n qemu_input_event_send_key_delay ( 0 ) ; \n qemu_input_event_send_key_number ( vs -> vd -> dcl . con , keycode , false ) ; \n qemu_input_event_send_key_delay ( 0 ) ; \n }", "idx": 24603}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier ( AioContext * ctx , \n EventNotifier * e , \n EventNotifierHandler * io_notify , \n AioFlushEventNotifierHandler * io_flush ) \n { \n AioHandler * node ; \n QLIST_FOREACH ( node , & ctx -> aio_handlers , node )  { \n if ( node -> e == e && ! node -> deleted ) { \n break ; \n } \n } \n if ( ! io_notify ) { \n if ( node ) { \n g_source_remove_poll ( & ctx -> source , & node -> pfd ) ; \n if ( ctx -> walking_handlers ) { \n node -> deleted = 1 ; \n node -> pfd . revents = 0 ; \n } else { \n QLIST_REMOVE ( node , node ) ; \n g_free ( node ) ; \n } \n } \n } else { \n if ( node == NULL ) { \n node = g_malloc0 ( sizeof ( AioHandler ) ) ; \n node -> e = e ; \n node -> pfd . fd = ( uintptr_t ) event_notifier_get_handle ( e ) ; \n node -> pfd . events = G_IO_IN ; \n QLIST_INSERT_HEAD ( & ctx -> aio_handlers , node , node ) ; \n g_source_add_poll ( & ctx -> source , & node -> pfd ) ; \n } \n node -> io_notify = io_notify ; \n node -> io_flush = io_flush ; \n } \n aio_notify ( ctx ) ; \n }", "idx": 24626}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close ( BlockDriverState * bs ) { \n BDRVVVFATState * s = * ( ( BDRVVVFATState * * ) bs -> opaque ) ; \n bdrv_delete ( s -> qcow ) ; \n free ( s -> qcow_filename ) ; \n }", "idx": 24730}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu ( DisasContext * dc ) \n { \n int l1 ; \n LOG_DIS ( \" \\n \" , dc -> r2 , dc -> r0 , dc -> r1 ) ; \n if ( ! ( dc -> features & LM32_FEATURE_DIVIDE ) ) { \n qemu_log_mask ( LOG_GUEST_ERROR , \" \\n \" ) ; \n t_gen_illegal_insn ( dc ) ; \n return ; \n } \n l1 = gen_new_label ( ) ; \n tcg_gen_brcondi_tl ( TCG_COND_NE , cpu_R [ dc -> r1 ] , 0 , l1 ) ; \n tcg_gen_movi_tl ( cpu_pc , dc -> pc ) ; \n t_gen_raise_exception ( dc , EXCP_DIVIDE_BY_ZERO ) ; \n gen_set_label ( l1 ) ; \n tcg_gen_remu_tl ( cpu_R [ dc -> r2 ] , cpu_R [ dc -> r0 ] , cpu_R [ dc -> r1 ] ) ; \n }", "idx": 24744}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb ( void * opaque , target_phys_addr_t addr , \n uint32_t value ) \n { \n unsigned int i = ( addr - OMAP2_L4_BASE ) >> TARGET_PAGE_BITS ; \n return omap_l4_io_writeb_fn [ i ] ( omap_l4_io_opaque [ i ] , addr , value ) ; \n }", "idx": 24748}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init ( CPUState * env ) \n { \n }", "idx": 24756}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n if ( ( token >= TOKEN_BASE ) \n && ( ( token - TOKEN_BASE ) < TOKEN_MAX ) ) { \n struct rtas_call * call = rtas_table + ( token - TOKEN_BASE ) ; \n if ( call -> fn ) { \n call -> fn ( spapr , token , nargs , args , nret , rets ) ; \n return H_SUCCESS ; \n } \n } \n if ( token == 0xa ) { \n rtas_display_character ( spapr , 0xa , nargs , args , nret , rets ) ; \n return H_SUCCESS ; \n } \n hcall_dprintf ( \" \\n \" , token ) ; \n rtas_st ( rets , 0 , -3 ) ; \n return H_PARAMETER ; \n }", "idx": 24759}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify ( const char * block_name , void * host_addr , \n ram_addr_t offset , ram_addr_t length , \n void * opaque ) \n { \n MigrationIncomingState * mis = opaque ; \n struct uffdio_register reg_struct ; \n reg_struct . range . start = ( uintptr_t ) host_addr ; \n reg_struct . range . len = length ; \n reg_struct . mode = UFFDIO_REGISTER_MODE_MISSING ; \n if ( ioctl ( mis -> userfault_fd , UFFDIO_REGISTER , & reg_struct ) ) { \n error_report ( \" \" , __func__ , strerror ( errno ) ) ; \n return 0 ;", "idx": 24771}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out ( QemuOpts * opts , CharDriverState * * _chr ) \n { \n const char * file_out = qemu_opt_get ( opts , \" \" ) ; \n HANDLE fd_out ; \n fd_out = CreateFile ( file_out , GENERIC_WRITE , FILE_SHARE_READ , NULL , \n OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL ) ; \n if ( fd_out == INVALID_HANDLE_VALUE ) { \n return - EIO ; \n } \n return qemu_chr_open_win_file ( fd_out , _chr ) ; \n }", "idx": 24794}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1 ( CPUMIPSState * env , target_ulong arg1 , uint32_t reg ) \n { \n switch ( reg ) { \n case 25 : \n if ( arg1 & 0xffffff00 ) \n return ; \n env -> active_fpu . fcr31 = ( env -> active_fpu . fcr31 & 0x017fffff ) | ( ( arg1 & 0xfe ) << 24 ) | \n ( ( arg1 & 0x1 ) << 23 ) ; \n break ; \n case 26 : \n if ( arg1 & 0x007c0000 ) \n return ; \n env -> active_fpu . fcr31 = ( env -> active_fpu . fcr31 & 0xfffc0f83 ) | ( arg1 & 0x0003f07c ) ; \n break ; \n case 28 : \n if ( arg1 & 0x007c0000 ) \n return ; \n env -> active_fpu . fcr31 = ( env -> active_fpu . fcr31 & 0xfefff07c ) | ( arg1 & 0x00000f83 ) | \n ( ( arg1 & 0x4 ) << 22 ) ; \n break ; \n case 31 : \n if ( arg1 & 0x007c0000 ) \n return ; \n env -> active_fpu . fcr31 = arg1 ; \n break ; \n default : \n return ; \n } \n restore_rounding_mode ( env ) ; \n restore_flush_mode ( env ) ; \n set_float_exception_flags ( 0 , & env -> active_fpu . fp_status ) ; \n if ( ( GET_FP_ENABLE ( env -> active_fpu . fcr31 ) | 0x20 ) & GET_FP_CAUSE ( env -> active_fpu . fcr31 ) ) \n do_raise_exception ( env , EXCP_FPE , GETPC ( ) ) ; \n }", "idx": 24847}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq ( void * opaque , int irq , int level ) \n { \n CPUState * env = opaque ; \n if ( level ) { \n CPUIRQ_DPRINTF ( \" \\n \" , irq ) ; \n env -> halted = 0 ; \n env -> pil_in |= 1 << irq ; \n cpu_check_irqs ( env ) ; \n } else { \n CPUIRQ_DPRINTF ( \" \\n \" , irq ) ; \n env -> pil_in &= ~ ( 1 << irq ) ; \n cpu_check_irqs ( env ) ; \n } \n }", "idx": 24853}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize ( BlockDriverState * bdrv ) \n { \n uint8_t cmd [ 6 ] ; \n uint8_t buf [ 12 ] ; \n uint8_t sensebuf [ 8 ] ; \n sg_io_hdr_t io_header ; \n int ret ; \n memset ( cmd , 0 , sizeof ( cmd ) ) ; \n memset ( buf , 0 , sizeof ( buf ) ) ; \n cmd [ 0 ] = MODE_SENSE ; \n cmd [ 4 ] = sizeof ( buf ) ; \n memset ( & io_header , 0 , sizeof ( io_header ) ) ; \n io_header . interface_id = ' ' ; \n io_header . dxfer_direction = SG_DXFER_FROM_DEV ; \n io_header . dxfer_len = sizeof ( buf ) ; \n io_header . dxferp = buf ; \n io_header . cmdp = cmd ; \n io_header . cmd_len = sizeof ( cmd ) ; \n io_header . mx_sb_len = sizeof ( sensebuf ) ; \n io_header . sbp = sensebuf ; \n io_header . timeout = 6000 ; \n ret = bdrv_ioctl ( bdrv , SG_IO , & io_header ) ; \n if ( ret < 0 || io_header . driver_status || io_header . host_status ) { \n return -1 ; \n } \n return ( buf [ 9 ] << 16 ) | ( buf [ 10 ] << 8 ) | buf [ 11 ] ; \n }", "idx": 24855}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check ( BlockDriverState * bs , int ign , int64_t offset , \n int64_t size ) \n { \n int ret = qcow2_check_metadata_overlap ( bs , ign , offset , size ) ; \n if ( ret < 0 ) { \n return ret ; \n } else if ( ret > 0 ) { \n int metadata_ol_bitnr = ffs ( ret ) - 1 ; \n assert ( metadata_ol_bitnr < QCOW2_OL_MAX_BITNR ) ; \n qcow2_signal_corruption ( bs , true , offset , size , \" \" \n \" \" , \n metadata_ol_names [ metadata_ol_bitnr ] ) ; \n return - EIO ; \n } \n return 0 ; \n }", "idx": 24880}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request ( void * opaque ) \n { \n BDRVSheepdogState * s = opaque ; \n qemu_coroutine_enter ( s -> co_send , NULL ) ; \n }", "idx": 24895}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen ( Slirp * slirp , u_int32_t haddr , u_int hport , u_int32_t laddr , \n u_int lport , int flags )  \n { \n struct sockaddr_in addr ; \n struct socket * so ; \n socklen_t addrlen = sizeof ( struct sockaddr_in ) , opt = 1 ; \n so = socreate ( slirp ) ; \n if ( ! so ) { \n return NULL ; \n } \n so -> s = socket ( AF_INET , SOCK_DGRAM , 0 ) ; \n so -> so_expire = curtime + SO_EXPIRE ; \n insque ( so , & slirp -> udb ) ; \n addr . sin_family = AF_INET ; \n addr . sin_addr . s_addr = haddr ; \n addr . sin_port = hport ; \n if ( bind ( so -> s , ( struct sockaddr * ) & addr , addrlen ) < 0 ) { \n udp_detach ( so ) ; \n return NULL ; \n } \n setsockopt ( so -> s , SOL_SOCKET , SO_REUSEADDR , ( char * ) & opt , sizeof ( int ) ) ; \n getsockname ( so -> s , ( struct sockaddr * ) & addr , & addrlen ) ; \n so -> so_fport = addr . sin_port ; \n if ( addr . sin_addr . s_addr == 0 || \n addr . sin_addr . s_addr == loopback_addr . s_addr ) { \n so -> so_faddr = slirp -> vhost_addr ; \n } else { \n so -> so_faddr = addr . sin_addr ; \n } \n so -> so_lport = lport ; \n so -> so_laddr . s_addr = laddr ; \n if ( flags != SS_FACCEPTONCE ) \n so -> so_expire = 0 ; \n so -> so_state &= SS_PERSISTENT_MASK ; \n so -> so_state |= SS_ISFCONNECTED | flags ; \n return so ; \n }", "idx": 24897}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl ( void * opaque , target_phys_addr_t addr ) \n { \n IRQMP * irqmp = opaque ; \n IRQMPState * state ; \n assert ( irqmp != NULL ) ; \n state = irqmp -> state ; \n assert ( state != NULL ) ; \n addr &= 0xff ; \n switch ( addr ) { \n case LEVEL_OFFSET : \n return state -> level ; \n case PENDING_OFFSET : \n return state -> pending ; \n case FORCE0_OFFSET : \n return state -> force [ 0 ] ; \n case CLEAR_OFFSET : \n case MP_STATUS_OFFSET : \n return 0 ; \n case BROADCAST_OFFSET : \n return state -> broadcast ; \n default : \n break ; \n } \n if ( addr >= MASK_OFFSET && addr < FORCE_OFFSET ) { \n int cpu = ( addr - MASK_OFFSET ) / 4 ; \n assert ( cpu >= 0 && cpu < IRQMP_MAX_CPU ) ; \n return state -> mask [ cpu ] ; \n } \n if ( addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET ) { \n int cpu = ( addr - FORCE_OFFSET ) / 4 ; \n assert ( cpu >= 0 && cpu < IRQMP_MAX_CPU ) ; \n return state -> force [ cpu ] ; \n } \n if ( addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE ) { \n int cpu = ( addr - EXTENDED_OFFSET ) / 4 ; \n assert ( cpu >= 0 && cpu < IRQMP_MAX_CPU ) ; \n return state -> extended [ cpu ] ; \n } \n trace_grlib_irqmp_unknown_register ( \" \" , addr ) ; \n return 0 ; \n }", "idx": 24899}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy ( QEMUSGList * qsg ) \n { \n g_free ( qsg -> sg ) ; \n }", "idx": 24902}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status ( SCSIDiskReq * r , int status , int sense_code ) \n { \n SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; \n r -> req . status = status ; \n scsi_disk_set_sense ( s , sense_code ) ; \n }", "idx": 24968}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write ( SDHCIState * s , uint8_t value ) \n { \n if ( ( value & SDHC_STOP_AT_GAP_REQ ) && ( s -> blkgap & SDHC_STOP_AT_GAP_REQ ) ) { \n return ; \n } \n s -> blkgap = value & SDHC_STOP_AT_GAP_REQ ; \n if ( ( value & SDHC_CONTINUE_REQ ) && s -> stopped_state && \n ( s -> blkgap & SDHC_STOP_AT_GAP_REQ ) == 0 ) { \n if ( s -> stopped_state == sdhc_gap_read ) { \n s -> prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ ; \n SDHCI_GET_CLASS ( s ) -> read_block_from_card ( s ) ; \n } else { \n s -> prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE ; \n SDHCI_GET_CLASS ( s ) -> write_block_to_card ( s ) ; \n } \n s -> stopped_state = sdhc_not_stopped ; \n } else if ( ! s -> stopped_state && ( value & SDHC_STOP_AT_GAP_REQ ) ) { \n if ( s -> prnsts & SDHC_DOING_READ ) { \n s -> stopped_state = sdhc_gap_read ; \n } else if ( s -> prnsts & SDHC_DOING_WRITE ) { \n s -> stopped_state = sdhc_gap_write ; \n } \n } \n }", "idx": 25005}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc ( QemuOpts * opts , ChardevBackend * backend , \n Error * * errp ) \n { \n int val ; \n backend -> vc = g_new0 ( ChardevVC , 1 ) ; \n val = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n if ( val != 0 ) { \n backend -> vc -> has_width = true ; \n backend -> vc -> width = val ; \n } \n val = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n if ( val != 0 ) { \n backend -> vc -> has_height = true ; \n backend -> vc -> height = val ; \n } \n val = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n if ( val != 0 ) { \n backend -> vc -> has_cols = true ; \n backend -> vc -> cols = val ; \n } \n val = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n if ( val != 0 ) { \n backend -> vc -> has_rows = true ; \n backend -> vc -> rows = val ; \n } \n }", "idx": 25024}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0 ( void ) \n { \n int den , q , r ; \n int64_t num ; \n num = ( ( uint32_t ) EAX ) | ( ( uint64_t ) ( ( uint32_t ) EDX ) << 32 ) ; \n den = T0 ; \n if ( den == 0 ) { \n raise_exception ( EXCP00_DIVZ ) ; \n } \n #ifdef BUGGY_GCC_DIV64 \n r = idiv32 ( & q , num , den ) ; \n #else \n q = ( num / den ) ; \n r = ( num % den ) ; \n #endif \n EAX = ( uint32_t ) q ; \n EDX = ( uint32_t ) r ; \n }", "idx": 25075}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup ( struct n800_s * s ) \n { \n char * otp_region ; \n DriveInfo * dinfo ; \n s -> nand = qdev_create ( NULL , \" \" ) ; \n qdev_prop_set_uint16 ( s -> nand , \" \" , NAND_MFR_SAMSUNG ) ; \n qdev_prop_set_uint16 ( s -> nand , \" \" , 0x48 ) ; \n qdev_prop_set_uint16 ( s -> nand , \" \" , 0 ) ; \n qdev_prop_set_int32 ( s -> nand , \" \" , 1 ) ; \n dinfo = drive_get ( IF_MTD , 0 , 0 ) ; \n if ( dinfo ) { \n qdev_prop_set_drive_nofail ( s -> nand , \" \" , \n blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) ) ; \n } \n qdev_init_nofail ( s -> nand ) ; \n sysbus_connect_irq ( SYS_BUS_DEVICE ( s -> nand ) , 0 , \n qdev_get_gpio_in ( s -> mpu -> gpio , N8X0_ONENAND_GPIO ) ) ; \n omap_gpmc_attach ( s -> mpu -> gpmc , N8X0_ONENAND_CS , \n sysbus_mmio_get_region ( SYS_BUS_DEVICE ( s -> nand ) , 0 ) ) ; \n otp_region = onenand_raw_otp ( s -> nand ) ; \n memcpy ( otp_region + 0x000 , n8x0_cal_wlan_mac , sizeof ( n8x0_cal_wlan_mac ) ) ; \n memcpy ( otp_region + 0x800 , n8x0_cal_bt_id , sizeof ( n8x0_cal_bt_id ) ) ; \n }", "idx": 25113}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state ( CPUState * env , FILE * f , \n int ( * cpu_fprintf ) ( FILE * f , const char * fmt , ... ) , \n int flags ) \n { \n uint32_t c0_status ; \n int i ; \n cpu_fprintf ( f , \" \" TARGET_FMT_lx \" \" TARGET_FMT_lx \" \" TARGET_FMT_lx \" \" TARGET_FMT_lx \" \\n \" , \n env -> PC , env -> HI , env -> LO , env -> hflags , env -> btarget , env -> bcond ) ; \n for ( i = 0 ; i < 32 ; i ++ ) { \n if ( ( i & 3 ) == 0 ) \n cpu_fprintf ( f , \" \" , i ) ; \n cpu_fprintf ( f , \" \" TARGET_FMT_lx , regnames [ i ] , env -> gpr [ i ] ) ; \n if ( ( i & 3 ) == 3 ) \n cpu_fprintf ( f , \" \\n \" ) ; \n } \n c0_status = env -> CP0_Status ; \n cpu_fprintf ( f , \" \" TARGET_FMT_lx \" \\n \" , \n c0_status , env -> CP0_Cause , env -> CP0_EPC ) ; \n cpu_fprintf ( f , \" \" TARGET_FMT_lx \" \\n \" , \n env -> CP0_Config0 , env -> CP0_Config1 , env -> CP0_LLAddr ) ; \n if ( c0_status & ( 1 << CP0St_CU1 ) ) \n fpu_dump_state ( env , f , cpu_fprintf , flags ) ; \n #if defined ( TARGET_MIPS64 ) && defined ( MIPS_DEBUG_SIGN_EXTENSIONS )  \n  \n  cpu_mips_check_sign_extensions ( env , f , cpu_fprintf , flags ) ; \n #endif \n }", "idx": 25119}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h ( void * opaque , int sprn ) \n { \n DisasContext * ctx = opaque ; \n gen_op_store_dbatu ( ( sprn - SPR_DBAT4U ) / 2 ) ; \n RET_STOP ( ctx ) ; \n }", "idx": 25163}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len ( char * string , const char * format , ... ) \n #else \n sprintf_len ( va_alist ) va_dcl \n #endif \n { \n va_list args  ; \n #ifdef __STDC__ \n va_start ( args , format ) ; \n #else \n char * string ; \n char * format ; \n va_start ( args ) ; \n string = va_arg ( args , char * ) ; \n format = va_arg ( args , char * ) ; \n #endif \n vsprintf ( string , format , args ) ; \n return strlen ( string ) ; \n }", "idx": 25167}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout ( DisplayChangeListener * dcl , \n uint32_t backing_id , bool backing_y_0_top , \n uint32_t x , uint32_t y , \n uint32_t w , uint32_t h ) \n { \n struct sdl2_console * scon = container_of ( dcl , struct sdl2_console , dcl ) ; \n assert ( scon -> opengl ) ; \n scon -> x = x ; \n scon -> y = y ; \n scon -> w = w ; \n scon -> h = h ; \n scon -> tex_id = backing_id ; \n scon -> y0_top = backing_y_0_top ; \n SDL_GL_MakeCurrent ( scon -> real_window , scon -> winctx ) ; \n if ( scon -> tex_id == 0 || scon -> w == 0 || scon -> h == 0 ) { \n sdl2_set_scanout_mode ( scon , false ) ; \n return ; \n } \n sdl2_set_scanout_mode ( scon , true ) ; \n if ( ! scon -> fbo_id ) { \n glGenFramebuffers ( 1 , & scon -> fbo_id ) ; \n } \n glBindFramebuffer ( GL_FRAMEBUFFER_EXT , scon -> fbo_id ) ; \n glFramebufferTexture2DEXT ( GL_FRAMEBUFFER_EXT , GL_COLOR_ATTACHMENT0_EXT , \n GL_TEXTURE_2D , scon -> tex_id , 0 ) ; \n }", "idx": 25182}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer ( struct qemu_alarm_timer * t ) \n { \n timeKillEvent ( mm_timer ) ; \n timeEndPeriod ( mm_period ) ; \n }", "idx": 25185}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile * qemu_fopen_fd ( int fd ) \n { \n QEMUFileFD * s = qemu_mallocz ( sizeof ( QEMUFileFD ) ) ; \n if ( s == NULL ) \n return NULL ; \n s -> fd = fd ; \n s -> file = qemu_fopen_ops ( s , fd_put_buffer , fd_get_buffer , fd_close , NULL ) ; \n return s -> file ; \n }", "idx": 25223}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event ( void * opaque , int event ) \n { \n BostonState * s = opaque ; \n if ( event == CHR_EVENT_OPENED && ! s -> lcd_inited ) { \n qemu_chr_fe_printf ( & s -> lcd_display , \" \" ) ; \n s -> lcd_inited = true ; \n } \n }", "idx": 25247}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command ( const cmdinfo_t * ci ) \n { \n cmdtab = realloc ( ( void * ) cmdtab , ++ ncmds * sizeof ( * cmdtab ) ) ; \n cmdtab [ ncmds - 1 ] = * ci ; \n qsort ( cmdtab , ncmds , sizeof ( * cmdtab ) , compare ) ; \n }", "idx": 25252}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq ( OpenPICState * opp , int n_IRQ ) \n { \n IRQ_src_t * src ; \n int i ; \n src = & opp -> src [ n_IRQ ] ; \n if ( ! src -> pending ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( src -> ipvp & IPVP_MASK_MASK ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( IPVP_PRIORITY ( src -> ipvp ) == 0 ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( src -> ipvp & IPVP_ACTIVITY_MASK ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( src -> ide == 0 ) { \n DPRINTF ( \" \\n \" , __func__ , n_IRQ ) ; \n return ; \n } \n if ( src -> ide == ( 1 << src -> last_cpu ) ) { \n IRQ_local_pipe ( opp , src -> last_cpu , n_IRQ ) ; \n } else if ( ! ( src -> ipvp & IPVP_MODE_MASK ) ) { \n for ( i = 0 ; i < opp -> nb_cpus ; i ++ ) { \n if ( src -> ide & ( 1 << i ) ) { \n IRQ_local_pipe ( opp , i , n_IRQ ) ; \n } \n } \n } else { \n for ( i = src -> last_cpu + 1 ; i != src -> last_cpu ; i ++ ) { \n if ( i == opp -> nb_cpus ) \n i = 0 ; \n if ( src -> ide & ( 1 << i ) ) { \n IRQ_local_pipe ( opp , i , n_IRQ ) ; \n src -> last_cpu = i ; \n break ; \n } \n } \n } \n }", "idx": 25260}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue ( struct USBBtState * s , \n struct usb_hci_out_fifo_s * fifo , \n void ( * send ) ( struct HCIInfo * , const uint8_t * , int ) , \n int ( * complete ) ( const uint8_t * , int ) , \n const uint8_t * data , int len ) \n { \n if ( fifo -> len ) { \n memcpy ( fifo -> data + fifo -> len , data , len ) ; \n fifo -> len += len ; \n if ( complete ( fifo -> data , fifo -> len ) ) { \n send ( s -> hci , fifo -> data , fifo -> len ) ; \n fifo -> len = 0 ; \n } \n } else if ( complete ( data , len ) ) \n send ( s -> hci , data , len ) ; \n else { \n memcpy ( fifo -> data , data , len ) ; \n fifo -> len = len ; \n } \n }", "idx": 25263}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister ( const VMStateDescription * vmsd , void * opaque ) \n { \n SaveStateEntry * se , * new_se ; \n TAILQ_FOREACH_SAFE ( se , & savevm_handlers , entry , new_se )  { \n if ( se -> vmsd == vmsd && se -> opaque == opaque ) { \n TAILQ_REMOVE ( & savevm_handlers , se , entry ) ; \n qemu_free ( se ) ; \n } \n } \n }", "idx": 25370}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg ( CPUState * env , uint8_t * mem_buf , int n ) \n { \n if ( n < 32 ) { \n #ifdef WORDS_BIGENDIAN \n env -> avr [ n ] . u64 [ 0 ] = ldq_p ( mem_buf ) ; \n env -> avr [ n ] . u64 [ 1 ] = ldq_p ( mem_buf + 8 ) ; \n #else \n env -> avr [ n ] . u64 [ 1 ] = ldq_p ( mem_buf ) ; \n env -> avr [ n ] . u64 [ 0 ] = ldq_p ( mem_buf + 8 ) ; \n #endif \n return 16 ; \n } \n if ( n == 33 ) { \n env -> vscr = ldl_p ( mem_buf ) ; \n return 4 ; \n } \n if ( n == 34 ) { \n env -> spr [ SPR_VRSAVE ] = ( target_ulong ) ldl_p ( mem_buf ) ; \n return 4 ; \n } \n return 0 ; \n }", "idx": 25459}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell ( QEMUFile * f ) \n { \n qemu_fflush ( f ) ; \n return f -> pos ; \n }", "idx": 25492}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read ( eeprom_t * eeprom ) \n { \n logout ( \" \\n \" , eeprom -> eecs , eeprom -> eedo ) ; \n return ( eeprom -> eedo ) ; \n }", "idx": 25510}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq * pxa2xx_pic_init ( target_phys_addr_t base , CPUState * env ) \n { \n PXA2xxPICState * s ; \n int iomemtype ; \n qemu_irq * qi ; \n s = ( PXA2xxPICState * ) \n qemu_mallocz ( sizeof ( PXA2xxPICState ) ) ; \n if ( ! s ) \n return NULL ; \n s -> cpu_env = env ; \n s -> int_pending [ 0 ] = 0 ; \n s -> int_pending [ 1 ] = 0 ; \n s -> int_enabled [ 0 ] = 0 ; \n s -> int_enabled [ 1 ] = 0 ; \n s -> is_fiq [ 0 ] = 0 ; \n s -> is_fiq [ 1 ] = 0 ; \n qi = qemu_allocate_irqs ( pxa2xx_pic_set_irq , s , PXA2XX_PIC_SRCS ) ; \n iomemtype = cpu_register_io_memory ( pxa2xx_pic_readfn , \n pxa2xx_pic_writefn , s , DEVICE_NATIVE_ENDIAN ) ; \n cpu_register_physical_memory ( base , 0x00100000 , iomemtype ) ; \n cpu_arm_set_cp_io ( env , 6 , pxa2xx_pic_cp_read , pxa2xx_pic_cp_write , s ) ; \n register_savevm ( NULL , \" \" , 0 , 0 , pxa2xx_pic_save , \n pxa2xx_pic_load , s ) ; \n return qi ; \n }", "idx": 25549}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde ( QemuOpts * opts , const NetClientOptions * new_opts , \n const char * name , VLANState * vlan ) \n { \n const char * sock ; \n const char * group ; \n int port , mode ; \n sock = qemu_opt_get ( opts , \" \" ) ; \n group = qemu_opt_get ( opts , \" \" ) ; \n port = qemu_opt_get_number ( opts , \" \" , 0 ) ; \n mode = qemu_opt_get_number ( opts , \" \" , 0700 ) ; \n if ( net_vde_init ( vlan , \" \" , name , sock , port , group , mode ) == -1 ) { \n return -1 ; \n } \n return 0 ; \n }", "idx": 25550}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj ( QObject * obj ) \n { \n QString * qs ; \n assert ( obj != NULL ) ; \n qs = qobject_to_qstring ( obj ) ; \n g_free ( qs -> string ) ; \n g_free ( qs ) ; \n }", "idx": 25571}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending ( AioContext * ctx ) \n { \n AioHandler * node ; \n bool result = false ; \n qemu_lockcnt_inc ( & ctx -> list_lock ) ; \n QLIST_FOREACH_RCU ( node , & ctx -> aio_handlers , node )  { \n if ( node -> pfd . revents && node -> io_notify ) { \n result = true ; \n break ; \n } \n if ( ( node -> pfd . revents & G_IO_IN ) && node -> io_read ) { \n result = true ; \n break ; \n } \n if ( ( node -> pfd . revents & G_IO_OUT ) && node -> io_write ) { \n result = true ; \n break ; \n } \n } \n qemu_lockcnt_dec ( & ctx -> list_lock ) ; \n return result ; \n }", "idx": 25574}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size ( VirtQueue * vq ) \n { \n unsigned int in , out ; \n virtqueue_get_avail_bytes ( vq , & in , & out ) ; \n return in ; \n }", "idx": 25578}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit ( int argc , const char * * argv ) \n { \n exit ( 0 ) ; \n }", "idx": 25580}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data ( USBDevice * dev , USBPacket * p ) \n { \n struct USBBtState * s = ( struct USBBtState * ) dev -> opaque ; \n int ret = 0 ; \n if ( ! s -> config ) \n goto fail ; \n switch ( p -> pid ) { \n case USB_TOKEN_IN : \n switch ( p -> devep & 0xf ) { \n case USB_EVT_EP : \n ret = usb_bt_fifo_dequeue ( & s -> evt , p ) ; \n break ; \n case USB_ACL_EP : \n ret = usb_bt_fifo_dequeue ( & s -> acl , p ) ; \n break ; \n case USB_SCO_EP : \n ret = usb_bt_fifo_dequeue ( & s -> sco , p ) ; \n break ; \n default : \n goto fail ; \n } \n break ; \n case USB_TOKEN_OUT : \n switch ( p -> devep & 0xf ) { \n case USB_ACL_EP : \n usb_bt_fifo_out_enqueue ( s , & s -> outacl , s -> hci -> acl_send , \n usb_bt_hci_acl_complete , p -> data , p -> len ) ; \n break ; \n case USB_SCO_EP : \n usb_bt_fifo_out_enqueue ( s , & s -> outsco , s -> hci -> sco_send , \n usb_bt_hci_sco_complete , p -> data , p -> len ) ; \n break ; \n default : \n goto fail ; \n } \n break ; \n default : \n fail : \n ret = USB_RET_STALL ; \n break ; \n } \n return ret ; \n }", "idx": 25602}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2 ( PowerPCCPU * cpu , \n sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , uint32_t nret , \n target_ulong rets ) \n { \n sPAPRPHBState * sphb ; \n sPAPRPHBClass * spc ; \n uint64_t buid ; \n int state , ret ; \n if ( ( nargs != 3 ) || ( nret != 4 && nret != 5 ) ) { \n goto param_error_exit ; \n } \n buid = ( ( uint64_t ) rtas_ld ( args , 1 ) << 32 ) | rtas_ld ( args , 2 ) ; \n sphb = find_phb ( spapr , buid ) ; \n if ( ! sphb ) { \n goto param_error_exit ; \n } \n spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS ( sphb ) ; \n if ( ! spc -> eeh_get_state ) { \n goto param_error_exit ; \n } \n ret = spc -> eeh_get_state ( sphb , & state ) ; \n rtas_st ( rets , 0 , ret ) ; \n if ( ret != RTAS_OUT_SUCCESS ) { \n return ; \n } \n rtas_st ( rets , 1 , state ) ; \n rtas_st ( rets , 2 , RTAS_EEH_SUPPORT ) ; \n rtas_st ( rets , 3 , RTAS_EEH_PE_UNAVAIL_INFO ) ; \n if ( nret >= 5 ) { \n rtas_st ( rets , 4 , RTAS_EEH_PE_RECOVER_INFO ) ; \n } \n return ; \n param_error_exit : \n rtas_st ( rets , 0 , RTAS_OUT_PARAM_ERROR ) ; \n }", "idx": 25619}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size ( int64_t value , Error * * errp ) \n { \n MigrationState * s = migrate_get_current ( ) ; \n if ( value != ( size_t ) value ) { \n error_set ( errp , QERR_INVALID_PARAMETER_VALUE , \" \" , \n \" \" ) ; \n return ; \n } \n s -> xbzrle_cache_size = xbzrle_cache_resize ( value ) ; \n }", "idx": 25636}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute ( const char * path ) \n { \n const char * p ; \n #ifdef _WIN32 \n if ( * path == ' ' || * path == ' \\\\ ' ) \n return 1 ; \n #endif \n p = strchr ( path , ' ' ) ; \n if ( p ) \n p ++ ; \n else \n p = path ; \n #ifdef _WIN32 \n return ( * p == ' ' || * p == ' \\\\ ' ) ; \n #else \n return ( * p == ' ' ) ; \n #endif \n }", "idx": 25669}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct ( Visitor * v , Error * * errp )  \n { \n OptsVisitor * ov = to_ov ( v ) ; \n GHashTableIter iter ; \n GQueue * any ; \n if ( -- ov -> depth > 0 ) { \n return ; \n } \n g_hash_table_iter_init ( & iter , ov -> unprocessed_opts ) ; \n if ( g_hash_table_iter_next ( & iter , NULL , ( void * * ) & any ) ) { \n const QemuOpt * first ; \n first = g_queue_peek_head ( any ) ; \n error_setg ( errp , QERR_INVALID_PARAMETER , first -> name ) ; \n } \n g_hash_table_destroy ( ov -> unprocessed_opts ) ; \n ov -> unprocessed_opts = NULL ; \n if ( ov -> fake_id_opt ) { \n g_free ( ov -> fake_id_opt -> name ) ; \n g_free ( ov -> fake_id_opt -> str ) ; \n g_free ( ov -> fake_id_opt ) ; \n } \n ov -> fake_id_opt = NULL ; \n }", "idx": 25670}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy * tcp_build_address ( const char * host_port , Error * * errp ) \n { \n InetSocketAddress * iaddr = g_new ( InetSocketAddress , 1 ) ; \n SocketAddressLegacy * saddr ; \n if ( inet_parse ( iaddr , host_port , errp ) ) { \n qapi_free_InetSocketAddress ( iaddr ) ; \n return NULL ; \n } \n saddr = g_new0 ( SocketAddressLegacy , 1 ) ; \n saddr -> type = SOCKET_ADDRESS_LEGACY_KIND_INET ; \n saddr -> u . inet . data = iaddr ; \n return saddr ; \n }", "idx": 25711}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject * qmp_input_get_object ( QmpInputVisitor * qiv , \n const char * name ) \n { \n const QObject * qobj ; \n if ( qiv -> nb_stack == 0 ) { \n qobj = qiv -> obj ; \n } else { \n qobj = qiv -> stack [ qiv -> nb_stack - 1 ] . obj ; \n } \n if ( name && qobject_type ( qobj ) == QTYPE_QDICT ) { \n return qdict_get ( qobject_to_qdict ( qobj ) , name ) ; \n } else if ( qiv -> nb_stack > 0 && qobject_type ( qobj ) == QTYPE_QLIST ) { \n return qlist_entry_obj ( qiv -> stack [ qiv -> nb_stack - 1 ] . entry ) ; \n } \n return qobj ; \n }", "idx": 25734}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write ( BlockDriverState * bs , int64_t sector_num , \n const uint8_t * buf , int nb_sectors ) \n { \n BDRVVPCState * s = bs -> opaque ; \n int64_t offset ; \n int64_t sectors , sectors_per_block ; \n int ret ; \n VHDFooter * footer = ( VHDFooter * ) s -> footer_buf ; \n if ( cpu_to_be32 ( footer -> type ) == VHD_FIXED ) { \n return bdrv_write ( bs -> file , sector_num , buf , nb_sectors ) ; \n } \n while ( nb_sectors > 0 ) { \n offset = get_sector_offset ( bs , sector_num , 1 ) ; \n sectors_per_block = s -> block_size >> BDRV_SECTOR_BITS ; \n sectors = sectors_per_block - ( sector_num % sectors_per_block ) ; \n if ( sectors > nb_sectors ) { \n sectors = nb_sectors ; \n } \n if ( offset == -1 ) { \n offset = alloc_block ( bs , sector_num ) ; \n if ( offset < 0 ) \n return -1 ; \n } \n ret = bdrv_pwrite ( bs -> file , offset , buf , sectors * BDRV_SECTOR_SIZE ) ; \n if ( ret != sectors * BDRV_SECTOR_SIZE ) { \n return -1 ; \n } \n nb_sectors -= sectors ; \n sector_num += sectors ; \n buf += sectors * BDRV_SECTOR_SIZE ; \n } \n return 0 ; \n }", "idx": 25741}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output ( void ) \n { \n return ! slirp_vc || qemu_can_send_packet ( slirp_vc ) ; \n }", "idx": 25813}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn ( ObjectClass * klass , void * data ) \n { \n USBDeviceClass * uc = USB_DEVICE_CLASS ( klass ) ; \n uc -> init = usb_tablet_initfn ; \n uc -> product_desc = \" \" ; \n uc -> usb_desc = & desc_tablet ; \n uc -> handle_packet = usb_generic_handle_packet ; \n uc -> handle_reset = usb_hid_handle_reset ; \n uc -> handle_control = usb_hid_handle_control ; \n uc -> handle_data = usb_hid_handle_data ; \n uc -> handle_destroy = usb_hid_handle_destroy ; \n }", "idx": 25814}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options ( MachineClass * mc ) \n { \n S390CcwMachineClass * s390mc = S390_MACHINE_CLASS ( mc ) ; \n s390mc -> gs_allowed = false ; \n ccw_machine_2_10_class_options ( mc ) ; \n SET_MACHINE_COMPAT ( mc , CCW_COMPAT_2_9 ) ; \n s390mc -> css_migration_enabled = false ; \n }", "idx": 25831}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented ( void ) \n { \n AHCIQState * ahci ; \n AHCICommand * cmd ; \n uint8_t px ; \n size_t bufsize = 4096 ; \n unsigned char * tx = g_malloc ( bufsize ) ; \n unsigned char * rx = g_malloc0 ( bufsize ) ; \n uint64_t ptr ; \n ahci = ahci_boot_and_enable ( NULL ) ; \n px = ahci_port_select ( ahci ) ; \n ahci_port_clear ( ahci , px ) ; \n generate_pattern ( tx , bufsize , AHCI_SECTOR_SIZE ) ; \n ptr = guest_alloc ( ahci -> parent -> alloc , bufsize ) ; \n g_assert ( ptr ) ; \n bufwrite ( ptr , tx , bufsize ) ; \n cmd = ahci_command_create ( CMD_WRITE_DMA ) ; \n ahci_command_adjust ( cmd , 0 , ptr , bufsize , 32 ) ; \n ahci_command_commit ( ahci , cmd , px ) ; \n ahci_command_issue ( ahci , cmd ) ; \n ahci_command_verify ( ahci , cmd ) ; \n g_free ( cmd ) ; \n cmd = ahci_command_create ( CMD_READ_DMA ) ; \n ahci_command_adjust ( cmd , 0 , ptr , bufsize , 32 ) ; \n ahci_command_commit ( ahci , cmd , px ) ; \n ahci_command_issue ( ahci , cmd ) ; \n ahci_command_verify ( ahci , cmd ) ; \n g_free ( cmd ) ; \n bufread ( ptr , rx , bufsize ) ; \n guest_free ( ahci -> parent -> alloc , ptr ) ; \n g_assert_cmphex ( memcmp ( tx , rx , bufsize ) , == , 0 ) ; \n ahci_shutdown ( ahci ) ; \n g_free ( rx ) ; \n g_free ( tx ) ; \n }", "idx": 25862}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read ( void * opaque , uint32_t addr ) \n { \n uint32_t val = 0 ; \n struct pci_status * g = opaque ; \n switch ( addr ) { \n case PCI_BASE : \n val = g -> up ; \n break ; \n case PCI_BASE + 4 : \n val = g -> down ; \n break ; \n default : \n break ; \n } \n PIIX4_DPRINTF ( \" \\n \" , addr , val ) ; \n return val ; \n }", "idx": 25865}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect ( VncJob * job , int x , int y , int w , int h ) \n { \n VncRectEntry * entry = g_malloc0 ( sizeof ( VncRectEntry ) ) ; \n entry -> rect . x = x ; \n entry -> rect . y = y ; \n entry -> rect . w = w ; \n entry -> rect . h = h ; \n vnc_lock_queue ( queue ) ; \n QLIST_INSERT_HEAD ( & job -> rectangles , entry , next ) ; \n vnc_unlock_queue ( queue ) ; \n return 1 ; \n }", "idx": 25872}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end ( BdrvTrackedRequest * req ) \n { \n if ( req -> serialising ) { \n req -> bs -> serialising_in_flight -- ; \n } \n QLIST_REMOVE ( req , list ) ; \n qemu_co_queue_restart_all ( & req -> wait_queue ) ; \n }", "idx": 25932}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f ( BlockBackend * blk , int argc , char * * argv ) \n { \n struct timeval t1 , t2 ; \n int Cflag = 0 , qflag = 0 ; \n int c , ret ; \n int64_t offset , count ; \n while ( ( c = getopt ( argc , argv , \" \" ) ) != -1 ) { \n switch ( c ) { \n case ' ' : \n Cflag = 1 ; \n break ; \n case ' ' : \n qflag = 1 ; \n break ; \n default : \n return qemuio_command_usage ( & discard_cmd ) ; \n } \n } \n if ( optind != argc - 2 ) { \n return qemuio_command_usage ( & discard_cmd ) ; \n } \n offset = cvtnum ( argv [ optind ] ) ; \n if ( offset < 0 ) { \n print_cvtnum_err ( offset , argv [ optind ] ) ; \n return 0 ; \n } \n optind ++ ; \n count = cvtnum ( argv [ optind ] ) ; \n if ( count < 0 ) { \n print_cvtnum_err ( count , argv [ optind ] ) ; \n return 0 ; \n } else if ( count >> BDRV_SECTOR_BITS > INT_MAX ) { \n printf ( \" \" PRIu64 \" \\n \" , \n ( uint64_t ) INT_MAX << BDRV_SECTOR_BITS , \n argv [ optind ] ) ; \n return 0 ; \n } \n gettimeofday ( & t1 , NULL ) ; \n ret = blk_discard ( blk , offset >> BDRV_SECTOR_BITS , \n count >> BDRV_SECTOR_BITS ) ; \n gettimeofday ( & t2 , NULL ) ; \n if ( ret < 0 ) { \n printf ( \" \\n \" , strerror ( - ret ) ) ; \n goto out ; \n } \n if ( ! qflag ) { \n t2 = tsub ( t2 , t1 ) ; \n print_report ( \" \" , & t2 , offset , count , count , 1 , Cflag ) ; \n } \n out : \n return 0 ; \n }", "idx": 25958}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty ( MemoryRegion * mr , hwaddr addr , \n hwaddr size ) \n { \n assert ( mr -> terminates ) ; \n cpu_physical_memory_set_dirty_range ( mr -> ram_addr + addr , size , \n memory_region_get_dirty_log_mask ( mr ) ) ; \n }", "idx": 25997}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr ( VncDisplay * vd ) \n { \n SocketAddressLegacy * addr ; \n Error * err = NULL ; \n if ( ! vd -> nlsock ) { \n return ; \n } \n addr = qio_channel_socket_get_local_address ( vd -> lsock [ 0 ] , & err ) ; \n if ( ! addr ) { \n return ; \n } \n if ( addr -> type != SOCKET_ADDRESS_LEGACY_KIND_INET ) { \n qapi_free_SocketAddressLegacy ( addr ) ; \n return ; \n } \n error_printf_unless_qmp ( \" \\n \" , \n addr -> u . inet . data -> host , \n addr -> u . inet . data -> port ) ; \n qapi_free_SocketAddressLegacy ( addr ) ; \n }", "idx": 26003}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat ( FsContext * fs_ctx , \n V9fsPath * fs_path , struct stat * stbuf ) \n { \n V9fsSynthNode * node = * ( V9fsSynthNode * * ) fs_path -> data ; \n v9fs_synth_fill_statbuf ( node , stbuf ) ; \n return 0 ; \n }", "idx": 26008}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending ( void * opaque , int irq ) \n { \n NVICState * s = ( NVICState * ) opaque ; \n VecInfo * vec ; \n assert ( irq > ARMV7M_EXCP_RESET && irq < s -> num_irq ) ; \n vec = & s -> vectors [ irq ] ; \n trace_nvic_clear_pending ( irq , vec -> enabled , vec -> prio ) ; \n if ( vec -> pending ) { \n vec -> pending = 0 ; \n nvic_irq_update ( s ) ; \n } \n }", "idx": 26059}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string ( void ) \n { \n int i ; \n struct { \n const char * decoded ; \n } test_cases [ ] = { \n { \" \" } , \n { \" \" } , \n { } \n } ; \n for ( i = 0 ; test_cases [ i ] . decoded ; i ++ ) { \n QObject * obj ; \n QString * str ; \n obj = qobject_from_jsonf ( \" \" , test_cases [ i ] . decoded ) ; \n g_assert ( obj != NULL ) ; \n g_assert ( qobject_type ( obj ) == QTYPE_QSTRING ) ; \n str = qobject_to_qstring ( obj ) ; \n g_assert ( strcmp ( qstring_get_str ( str ) , test_cases [ i ] . decoded ) == 0 ) ; \n QDECREF ( str ) ; \n } \n }", "idx": 26061}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit ( DeviceState * qdev ) \n { \n SCSIDevice * dev = SCSI_DEVICE ( qdev ) ; \n if ( dev -> vmsentry ) { \n qemu_del_vm_change_state_handler ( dev -> vmsentry ) ; \n } \n scsi_device_destroy ( dev ) ; \n return 0 ; \n }", "idx": 26069}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init ( target_phys_addr_t base , \n target_phys_addr_t aux1_base , \n target_phys_addr_t aux2_base , qemu_irq irq , \n qemu_irq fdc_tc ) \n { \n DeviceState * dev ; \n SysBusDevice * s ; \n dev = qdev_create ( NULL , \" \" ) ; \n qdev_init ( dev ) ; \n s = sysbus_from_qdev ( dev ) ; \n if ( base ) { \n sysbus_mmio_map ( s , 0 , base + MISC_CFG ) ; \n sysbus_mmio_map ( s , 1 , base + MISC_DIAG ) ; \n sysbus_mmio_map ( s , 2 , base + MISC_MDM ) ; \n sysbus_mmio_map ( s , 3 , base + MISC_LEDS ) ; \n sysbus_mmio_map ( s , 4 , base + MISC_SYS ) ; \n } \n if ( aux1_base ) { \n sysbus_mmio_map ( s , 5 , aux1_base ) ; \n } \n if ( aux2_base ) { \n sysbus_mmio_map ( s , 6 , aux2_base ) ; \n } \n sysbus_connect_irq ( s , 0 , irq ) ; \n sysbus_connect_irq ( s , 1 , fdc_tc ) ; \n qemu_system_powerdown = qdev_get_gpio_in ( dev , 0 ) ; \n }", "idx": 26090}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer ( void * opaque , const uint8_t * buf , \n int64_t pos , int size ) \n { \n QEMUFileBdrv * s = opaque ; \n bdrv_pwrite ( s -> bs , s -> base_offset + pos , buf , size ) ; \n }", "idx": 26113}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init ( QEMUClockType type ) \n { \n QEMUClock * clock = qemu_clock_ptr ( type ) ; \n assert ( main_loop_tlg . tl [ type ] == NULL ) ; \n clock -> type = type ; \n clock -> enabled = ( type == QEMU_CLOCK_VIRTUAL ? false : true ) ; \n clock -> last = INT64_MIN ; \n QLIST_INIT ( & clock -> timerlists ) ; \n notifier_list_init ( & clock -> reset_notifiers ) ; \n main_loop_tlg . tl [ type ] = timerlist_new ( type , NULL , NULL ) ; \n }", "idx": 26117}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState * qemu_chr_open_pty ( QemuOpts * opts ) \n { \n CharDriverState * chr ; \n PtyCharDriver * s ; \n struct termios tty ; \n int master_fd , slave_fd , len ; \n #if defined ( __OpenBSD__ ) || defined ( __DragonFly__ )  \n  \n  char pty_name [ PATH_MAX ] ; \n #define q_ptsname ( x )  pty_name  \n  \n  #else \n char * pty_name = NULL ; \n #define q_ptsname ( x )  ptsname(x)  \n  \n  #endif \n if ( openpty ( & master_fd , & slave_fd , pty_name , NULL , NULL ) < 0 ) { \n return NULL ; \n } \n tcgetattr ( slave_fd , & tty ) ; \n cfmakeraw ( & tty ) ; \n tcsetattr ( slave_fd , TCSAFLUSH , & tty ) ; \n close ( slave_fd ) ; \n chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; \n len = strlen ( q_ptsname ( master_fd ) ) + 5 ; \n chr -> filename = g_malloc ( len ) ; \n snprintf ( chr -> filename , len , \" \" , q_ptsname ( master_fd ) ) ; \n qemu_opt_set ( opts , \" \" , q_ptsname ( master_fd ) ) ; \n fprintf ( stderr , \" \\n \" , q_ptsname ( master_fd ) ) ; \n s = g_malloc0 ( sizeof ( PtyCharDriver ) ) ; \n chr -> opaque = s ; \n chr -> chr_write = pty_chr_write ; \n chr -> chr_update_read_handler = pty_chr_update_read_handler ; \n chr -> chr_close = pty_chr_close ; \n s -> fd = master_fd ; \n s -> timer = qemu_new_timer_ms ( rt_clock , pty_chr_timer , chr ) ; \n return chr ; \n }", "idx": 26136}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER ( sigp ) ( CPUS390XState * env , uint64_t order_code , uint32_t r1 , \n uint64_t cpu_addr ) \n { \n int cc = SIGP_CC_ORDER_CODE_ACCEPTED ; \n HELPER_LOG ( \" \" PRIx64 \" \" PRIx64 \" \\n \" , \n __func__ , order_code , r1 , cpu_addr ) ; \n switch ( order_code ) { \n case SIGP_SET_ARCH : \n break ; \n case SIGP_SENSE : \n if ( cpu_addr ) { \n return 3 ; \n } \n env -> regs [ r1 ] &= 0xffffffff00000000ULL ; \n cc = 1 ; \n break ; \n #if ! defined ( CONFIG_USER_ONLY )  \n  \n  case SIGP_RESTART : \n qemu_system_reset_request ( ) ; \n cpu_loop_exit ( CPU ( s390_env_get_cpu ( env ) ) ) ; \n break ; \n case SIGP_STOP : \n qemu_system_shutdown_request ( ) ; \n cpu_loop_exit ( CPU ( s390_env_get_cpu ( env ) ) ) ; \n break ; \n #endif \n default : \n fprintf ( stderr , \" \" PRIx64 \" \\n \" , order_code ) ; \n cc = SIGP_CC_NOT_OPERATIONAL ; \n } \n return cc ; \n }", "idx": 26152}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main ( OneNANDState * s , int sec , int secn , \n void * src ) \n { \n int result = 0 ; \n if ( secn > 0 ) { \n uint32_t size = ( uint32_t ) secn * 512 ; \n const uint8_t * sp = ( const uint8_t * ) src ; \n uint8_t * dp = 0 ; \n if ( s -> bdrv_cur ) { \n dp = g_malloc ( size ) ; \n if ( ! dp || bdrv_read ( s -> bdrv_cur , sec , dp , secn ) < 0 ) { \n result = 1 ; \n } \n } else { \n if ( sec + secn > s -> secs_cur ) { \n result = 1 ; \n } else { \n dp = ( uint8_t * ) s -> current + ( sec << 9 ) ; \n } \n } \n if ( ! result ) { \n uint32_t i ; \n for ( i = 0 ; i < size ; i ++ ) { \n dp [ i ] &= sp [ i ] ; \n } \n if ( s -> bdrv_cur ) { \n result = bdrv_write ( s -> bdrv_cur , sec , dp , secn ) < 0 ; \n } \n } \n if ( dp && s -> bdrv_cur ) { \n g_free ( dp ) ; \n } \n } \n return result ; \n }", "idx": 26158}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32 ( Error * * errp , int win32_err , const char * fmt , ... ) \n { \n va_list ap ; \n char * msg1 , * msg2 ; \n if ( errp == NULL ) { \n return ; \n } \n va_start ( ap , fmt ) ; \n error_setv ( errp , ERROR_CLASS_GENERIC_ERROR , fmt , ap ) ; \n va_end ( ap ) ; \n if ( win32_err != 0 ) { \n msg1 = ( * errp ) -> msg ; \n msg2 = g_win32_error_message ( win32_err ) ; \n ( * errp ) -> msg = g_strdup_printf ( \" \" , msg1 , msg2 , \n ( unsigned ) win32_err ) ; \n g_free ( msg2 ) ; \n g_free ( msg1 ) ; \n } \n }", "idx": 26175}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer ( QEMUFile * f , uint8_t * buf , int size1 ) \n { \n int size , l ; \n if ( f -> is_write ) \n abort ( ) ; \n size = size1 ; \n while ( size > 0 ) { \n l = f -> buf_size - f -> buf_index ; \n if ( l == 0 ) { \n qemu_fill_buffer ( f ) ; \n l = f -> buf_size - f -> buf_index ; \n if ( l == 0 ) \n break ; \n } \n if ( l > size ) \n l = size ; \n memcpy ( buf , f -> buf + f -> buf_index , l ) ; \n f -> buf_index += l ; \n buf += l ; \n size -= l ; \n } \n return size1 - size ; \n }", "idx": 26191}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void * rom_ptr ( target_phys_addr_t addr ) \n { \n Rom * rom ; \n rom = find_rom ( addr ) ; \n if ( ! rom || ! rom -> data ) \n return NULL ; \n return rom -> data + ( addr - rom -> addr ) ; \n }", "idx": 26225}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void * do_data_decompress ( void * opaque ) \n { \n DecompressParam * param = opaque ; \n unsigned long pagesize ; \n while ( ! quit_decomp_thread ) { \n qemu_mutex_lock ( & param -> mutex ) ; \n while ( ! param -> start && ! quit_decomp_thread ) { \n qemu_cond_wait ( & param -> cond , & param -> mutex ) ; \n } \n if ( ! quit_decomp_thread ) { \n pagesize = TARGET_PAGE_SIZE ; \n uncompress ( ( Bytef * ) param -> des , & pagesize , \n ( const Bytef * ) param -> compbuf , param -> len ) ; \n } \n param -> start = false ; \n qemu_mutex_unlock ( & param -> mutex ) ; \n qemu_mutex_lock ( & decomp_done_lock ) ; \n param -> done = true ; \n qemu_cond_signal ( & decomp_done_cond ) ; \n qemu_mutex_unlock ( & decomp_done_lock ) ; \n } \n return NULL ; \n }", "idx": 26226}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn ( CPUSH4State * regs ) \n { \n struct target_sigframe * frame ; \n abi_ulong frame_addr ; \n sigset_t blocked ; \n target_sigset_t target_set ; \n target_ulong r0 ; \n int i ; \n int err = 0 ; \n #if defined ( DEBUG_SIGNAL )  \n  \n  fprintf ( stderr , \" \\n \" ) ; \n #endif \n frame_addr = regs -> gregs [ 15 ] ; \n if ( ! lock_user_struct ( VERIFY_READ , frame , frame_addr , 1 ) ) \n goto badframe ; \n __get_user ( target_set . sig [ 0 ] , & frame -> sc . oldmask ) ; \n for ( i = 1 ; i < TARGET_NSIG_WORDS ; i ++ ) { \n __get_user ( target_set . sig [ i ] , & frame -> extramask [ i - 1 ] ) ; \n } \n if ( err ) \n goto badframe ; \n target_to_host_sigset_internal ( & blocked , & target_set ) ; \n do_sigprocmask ( SIG_SETMASK , & blocked , NULL ) ; \n if ( restore_sigcontext ( regs , & frame -> sc , & r0 ) ) \n goto badframe ; \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n return r0 ; \n badframe : \n unlock_user_struct ( frame , frame_addr , 0 ) ; \n force_sig ( TARGET_SIGSEGV ) ; \n return 0 ; \n }", "idx": 26234}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common ( DeviceState * dev ) \n { \n APICCommonState * s = APIC_COMMON ( dev ) ; \n APICCommonClass * info = APIC_COMMON_GET_CLASS ( s ) ; \n bool bsp ; \n bsp = cpu_is_bsp ( s -> cpu ) ; \n s -> apicbase = APIC_DEFAULT_ADDRESS | \n ( bsp ? MSR_IA32_APICBASE_BSP : 0 ) | MSR_IA32_APICBASE_ENABLE ; \n s -> vapic_paddr = 0 ; \n info -> vapic_base_update ( s ) ; \n apic_init_reset ( dev ) ; \n if ( bsp ) { \n s -> lvt [ APIC_LVT_LINT0 ] = 0x700 ; \n } \n }", "idx": 26242}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init ( target_phys_addr_t base , struct omap_mpu_state_s * s , \n omap_clk clk ) \n { \n int iomemtype ; \n s -> pwt . base = base ; \n s -> pwt . clk = clk ; \n omap_pwt_reset ( s ) ; \n iomemtype = cpu_register_io_memory ( 0 , omap_pwt_readfn , \n omap_pwt_writefn , s ) ; \n cpu_register_physical_memory ( s -> pwt . base , 0x800 , iomemtype ) ; \n }", "idx": 26243}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update ( VncState * vs , int x , \n int y , int w , int h ) \n { \n int i , j ; \n int has_fg , has_bg ; \n uint8_t * last_fg , * last_bg ; \n VncDisplay * vd = vs -> vd ; \n last_fg = ( uint8_t * ) qemu_malloc ( vd -> server -> pf . bytes_per_pixel ) ; \n last_bg = ( uint8_t * ) qemu_malloc ( vd -> server -> pf . bytes_per_pixel ) ; \n has_fg = has_bg = 0 ; \n for ( j = y ; j < ( y + h ) ; j += 16 ) { \n for ( i = x ; i < ( x + w ) ; i += 16 ) { \n vs -> send_hextile_tile ( vs , i , j , \n MIN ( 16 , x + w - i ) , MIN ( 16 , y + h - j ) , \n last_bg , last_fg , & has_bg , & has_fg ) ; \n } \n } \n free ( last_fg ) ; \n free ( last_bg ) ; \n return 1 ; \n }", "idx": 26245}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em ( BlockDriverState * bs , int64_t sector_num , \n uint8_t * buf , int nb_sectors ) \n { \n int async_ret ; \n BlockDriverAIOCB * acb ; \n struct iovec iov ; \n QEMUIOVector qiov ; \n async_ret = NOT_DONE ; \n iov . iov_base = ( void * ) buf ; \n iov . iov_len = nb_sectors * BDRV_SECTOR_SIZE ; \n qemu_iovec_init_external ( & qiov , & iov , 1 ) ; \n acb = bs -> drv -> bdrv_aio_readv ( bs , sector_num , & qiov , nb_sectors , \n bdrv_rw_em_cb , & async_ret ) ; \n if ( acb == NULL ) { \n async_ret = -1 ; \n goto fail ; \n } \n while ( async_ret == NOT_DONE ) { \n qemu_aio_wait ( ) ; \n } \n fail : \n return async_ret ; \n }", "idx": 26251}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs ( PowerPCCPU * cpu ) \n { \n CPUPPCState * env = & cpu -> env ; \n struct kvm_sregs sregs ; \n int ret ; \n int i ; \n ret = kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_GET_SREGS , & sregs ) ; \n if ( ret < 0 ) { \n return ret ; \n } \n if ( ! env -> external_htab ) { \n ppc_store_sdr1 ( env , sregs . u . s . sdr1 ) ; \n } \n #ifdef TARGET_PPC64 \n memset ( env -> slb , 0 , sizeof ( env -> slb ) ) ; \n for ( i = 0 ; i < ARRAY_SIZE ( env -> slb ) ; i ++ ) { \n target_ulong rb = sregs . u . s . ppc64 . slb [ i ] . slbe ; \n target_ulong rs = sregs . u . s . ppc64 . slb [ i ] . slbv ; \n if ( rb & SLB_ESID_V ) { \n ppc_store_slb ( cpu , rb & 0xfff , rb & ~ 0xfffULL , rs ) ; \n } \n } \n #endif \n for ( i = 0 ; i < 16 ; i ++ ) { \n env -> sr [ i ] = sregs . u . s . ppc32 . sr [ i ] ; \n } \n for ( i = 0 ; i < 8 ; i ++ ) { \n env -> DBAT [ 0 ] [ i ] = sregs . u . s . ppc32 . dbat [ i ] & 0xffffffff ; \n env -> DBAT [ 1 ] [ i ] = sregs . u . s . ppc32 . dbat [ i ] >> 32 ; \n env -> IBAT [ 0 ] [ i ] = sregs . u . s . ppc32 . ibat [ i ] & 0xffffffff ; \n env -> IBAT [ 1 ] [ i ] = sregs . u . s . ppc32 . ibat [ i ] >> 32 ; \n } \n return 0 ; \n }", "idx": 26257}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont ( Monitor * mon , const QDict * qdict ) \n { \n BlockInfoList * bdev_list , * bdev ; \n Error * err = NULL ; \n bdev_list = qmp_query_block ( NULL ) ; \n for ( bdev = bdev_list ; bdev ; bdev = bdev -> next ) { \n if ( key_is_missing ( bdev -> value ) ) { \n monitor_read_block_device_key ( mon , bdev -> value -> device , \n hmp_cont_cb , NULL ) ; \n goto out ; \n } \n } \n qmp_cont ( & err ) ; \n hmp_handle_error ( mon , & err ) ; \n out : \n qapi_free_BlockInfoList ( bdev_list ) ; \n }", "idx": 26291}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init ( Object * obj ) \n { \n AUXTOI2CState * s = AUXTOI2C ( obj ) ; \n s -> i2c_bus = i2c_init_bus ( DEVICE ( obj ) , \" \" ) ; \n }", "idx": 26306}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb ( void * opaque ) \n { \n BdrvCoDrainData * data = opaque ; \n Coroutine * co = data -> co ; \n qemu_bh_delete ( data -> bh ) ; \n bdrv_drain_poll ( data -> bs ) ; \n data -> done = true ; \n qemu_coroutine_enter ( co , NULL ) ; \n }", "idx": 26315}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client ( Monitor * mon , const QDict * qdict , QObject * * ret_data ) \n { \n const char * protocol = qdict_get_str ( qdict , \" \" ) ; \n const char * fdname = qdict_get_str ( qdict , \" \" ) ; \n CharDriverState * s ; \n if ( strcmp ( protocol , \" \" ) == 0 ) { \n int fd = monitor_get_fd ( mon , fdname , NULL ) ; \n int skipauth = qdict_get_try_bool ( qdict , \" \" , 0 ) ; \n int tls = qdict_get_try_bool ( qdict , \" \" , 0 ) ; \n if ( ! using_spice ) { \n qerror_report ( QERR_DEVICE_NOT_ACTIVE , \" \" ) ; \n return -1 ; \n } \n if ( qemu_spice_display_add_client ( fd , skipauth , tls ) < 0 ) { \n close ( fd ) ; \n } \n return 0 ; \n #ifdef CONFIG_VNC  \n } else if ( strcmp ( protocol , \" \" ) == 0 ) { \n int fd = monitor_get_fd ( mon , fdname , NULL ) ; \n int skipauth = qdict_get_try_bool ( qdict , \" \" , 0 ) ; \n vnc_display_add_client ( NULL , fd , skipauth ) ; \n return 0 ; \n #endif  \n  \n  } else if ( ( s = qemu_chr_find ( protocol ) ) != NULL ) { \n int fd = monitor_get_fd ( mon , fdname , NULL ) ; \n if ( qemu_chr_add_client ( s , fd ) < 0 ) { \n qerror_report ( QERR_ADD_CLIENT_FAILED ) ; \n return -1 ; \n } \n return 0 ; \n } \n qerror_report ( QERR_INVALID_PARAMETER , \" \" ) ; \n return -1 ; \n }", "idx": 26320}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io ( QIOChannel * ioc , \n GIOCondition condition , \n gpointer user_data ) \n { \n QIOTask * task = user_data ; \n QIOChannelTLS * tioc = QIO_CHANNEL_TLS ( \n qio_task_get_source ( task ) ) ; \n qio_channel_tls_handshake_task ( \n tioc , task ) ; \n object_unref ( OBJECT ( tioc ) ) ; \n return FALSE ; \n }", "idx": 26330}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci ( VT686PMState * s ) \n { \n int sci_level , pmsts ; \n pmsts = acpi_pm1_evt_get_sts ( & s -> ar , s -> ar . tmr . overflow_time ) ; \n sci_level = ( ( ( pmsts & s -> ar . pm1 . evt . en ) & \n ( ACPI_BITMASK_RT_CLOCK_ENABLE | \n ACPI_BITMASK_POWER_BUTTON_ENABLE | \n ACPI_BITMASK_GLOBAL_LOCK_ENABLE | \n ACPI_BITMASK_TIMER_ENABLE ) ) != 0 ) ; \n qemu_set_irq ( s -> dev . irq [ 0 ] , sci_level ) ; \n acpi_pm_tmr_update ( & s -> ar , ( s -> ar . pm1 . evt . en & ACPI_BITMASK_TIMER_ENABLE ) && \n ! ( pmsts & ACPI_BITMASK_TIMER_STATUS ) ) ; \n }", "idx": 26333}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel ( void * opaque , target_phys_addr_t addr , uint32_t val ) \n { \n IntelHDAState * d = opaque ; \n const IntelHDAReg * reg = intel_hda_reg_find ( d , addr ) ; \n intel_hda_reg_write ( d , reg , val , 0xffffffff ) ; \n }", "idx": 26396}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init ( SysBusDevice * dev ) \n { \n LedState * s = FROM_SYSBUS ( LedState , dev ) ; \n memory_region_init_io ( & s -> iomem , & led_ops , s , \" \" , 1 ) ; \n sysbus_init_mmio ( dev , & s -> iomem ) ; \n s -> ds = graphic_console_init ( jazz_led_update_display , \n jazz_led_invalidate_display , \n jazz_led_screen_dump , \n jazz_led_text_update , s ) ; \n return 0 ; \n }", "idx": 26443}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read ( void * opaque , target_phys_addr_t addr , unsigned int size )  \n { \n struct fs_dma_ctrl * ctrl = opaque ; \n int c ; \n uint32_t r = 0 ; \n if ( size != 4 ) { \n dma_rinvalid ( opaque , addr ) ; \n } \n c = fs_channel ( addr ) ; \n addr &= 0xff ; \n addr >>= 2 ; \n switch ( addr ) \n { \n case RW_STAT : \n r = ctrl -> channels [ c ] . state & 7 ; \n r |= ctrl -> channels [ c ] . eol << 5 ; \n r |= ctrl -> channels [ c ] . stream_cmd_src << 8 ; \n break ; \n default : \n r = ctrl -> channels [ c ] . regs [ addr ] ; \n D ( printf ( \" \" TARGET_FMT_plx \" \\n \" , \n __func__ , c , addr ) ) ; \n break ; \n } \n return r ; \n }", "idx": 26451}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load ( struct pxa2xx_lcdc_s * s ) \n { \n struct pxa_frame_descriptor_s desc ; \n target_phys_addr_t descptr ; \n int i ; \n for ( i = 0 ; i < PXA_LCDDMA_CHANS ; i ++ ) { \n s -> dma_ch [ i ] . source = 0 ; \n if ( ! s -> dma_ch [ i ] . up ) \n continue ; \n if ( s -> dma_ch [ i ] . branch & FBR_BRA ) { \n descptr = s -> dma_ch [ i ] . branch & FBR_SRCADDR ; \n if ( s -> dma_ch [ i ] . branch & FBR_BINT ) \n pxa2xx_dma_bs_set ( s , i ) ; \n s -> dma_ch [ i ] . branch &= ~ FBR_BRA ; \n } else \n descptr = s -> dma_ch [ i ] . descriptor ; \n if ( ! ( descptr >= PXA2XX_SDRAM_BASE && descptr + \n sizeof ( desc ) <= PXA2XX_SDRAM_BASE + phys_ram_size ) ) \n continue ; \n cpu_physical_memory_read ( descptr , ( void * ) & desc , sizeof ( desc ) ) ; \n s -> dma_ch [ i ] . descriptor = tswap32 ( desc . fdaddr ) ; \n s -> dma_ch [ i ] . source = tswap32 ( desc . fsaddr ) ; \n s -> dma_ch [ i ] . id = tswap32 ( desc . fidr ) ; \n s -> dma_ch [ i ] . command = tswap32 ( desc . ldcmd ) ; \n } \n }", "idx": 26458}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice ( VIOsPAPRBus * bus , void * fdt ) \n { \n DeviceState * qdev , * * qdevs ; \n BusChild * kid ; \n int i , num , ret = 0 ; \n num = 0 ; \n QTAILQ_FOREACH ( kid , & bus -> bus . children , sibling )  { \n num ++ ; \n } \n qdevs = g_malloc ( sizeof ( qdev ) * num ) ; \n num = 0 ; \n QTAILQ_FOREACH ( kid , & bus -> bus . children , sibling )  { \n qdevs [ num ++ ] = kid -> child ; \n } \n qsort ( qdevs , num , sizeof ( qdev ) , compare_reg ) ; \n for ( i = num - 1 ; i >= 0 ; i -- ) { \n VIOsPAPRDevice * dev = ( VIOsPAPRDevice * ) ( qdevs [ i ] ) ; \n ret = vio_make_devnode ( dev , fdt ) ; \n if ( ret < 0 ) { \n goto out ; \n } \n } \n ret = 0 ; \n out : \n free ( qdevs ) ; \n return ret ; \n }", "idx": 26468}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all ( CPUPPCState * env ) \n { \n switch ( env -> mmu_model ) { \n case POWERPC_MMU_SOFT_6xx : \n case POWERPC_MMU_SOFT_74xx : \n ppc6xx_tlb_invalidate_all ( env ) ; \n break ; \n case POWERPC_MMU_SOFT_4xx : \n case POWERPC_MMU_SOFT_4xx_Z : \n ppc4xx_tlb_invalidate_all ( env ) ; \n break ; \n case POWERPC_MMU_REAL : \n cpu_abort ( env , \" \\n \" ) ; \n break ; \n case POWERPC_MMU_MPC8xx : \n cpu_abort ( env , \" \\n \" ) ; \n break ; \n case POWERPC_MMU_BOOKE : \n tlb_flush ( env , 1 ) ; \n break ; \n case POWERPC_MMU_BOOKE206 : \n booke206_flush_tlb ( env , -1 , 0 ) ; \n break ; \n case POWERPC_MMU_32B : \n case POWERPC_MMU_601 : \n #if defined ( TARGET_PPC64 )  \n  \n  case POWERPC_MMU_620 : \n case POWERPC_MMU_64B : \n case POWERPC_MMU_2_06 : \n #endif \n tlb_flush ( env , 1 ) ; \n break ; \n default : \n cpu_abort ( env , \" \\n \" ) ; \n break ; \n } \n }", "idx": 26472}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER ( lcebr ) ( CPUS390XState * env , uint32_t f1 , uint32_t f2 ) \n { \n env -> fregs [ f1 ] . l . upper = float32_chs ( env -> fregs [ f2 ] . l . upper ) ; \n return set_cc_nz_f32 ( env -> fregs [ f1 ] . l . upper ) ; \n }", "idx": 26480}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap ( AddressSpace * as , void * buffer , target_phys_addr_t len , \n int is_write , target_phys_addr_t access_len ) \n { \n if ( buffer != bounce . buffer ) { \n if ( is_write ) { \n ram_addr_t addr1 = qemu_ram_addr_from_host_nofail ( buffer ) ; \n while ( access_len ) { \n unsigned l ; \n l = TARGET_PAGE_SIZE ; \n if ( l > access_len ) \n l = access_len ; \n invalidate_and_set_dirty ( addr1 , l ) ; \n addr1 += l ; \n access_len -= l ; \n } \n } \n if ( xen_enabled ( ) ) { \n xen_invalidate_map_cache_entry ( buffer ) ; \n } \n return ; \n } \n if ( is_write ) { \n address_space_write ( as , bounce . addr , bounce . buffer , access_len ) ; \n } \n qemu_vfree ( bounce . buffer ) ; \n bounce . buffer = NULL ; \n cpu_notify_map_clients ( ) ; \n }", "idx": 26496}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl ( void * opaque , target_phys_addr_t addr ) \n { \n #ifdef DEBUG_UNASSIGNED \n printf ( \" \" TARGET_FMT_plx \" \\n \" , addr ) ; \n #endif \n #if defined ( TARGET_ALPHA ) || defined ( TARGET_SPARC ) || defined ( TARGET_MICROBLAZE )  \n  \n  do_unassigned_access ( addr , 0 , 0 , 0 , 4 ) ; \n #endif \n return 0 ; \n }", "idx": 26530}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw ( TCGv_i64 a , TCGv b ) \n { \n TCGv_i64 tmp64 = tcg_temp_new_i64 ( ) ; \n tcg_gen_extu_i32_i64 ( tmp64 , b ) ; \n dead_tmp ( b ) ; \n tcg_gen_shli_i64 ( tmp64 , tmp64 , 32 ) ; \n tcg_gen_add_i64 ( a , tmp64 , a ) ; \n tcg_temp_free_i64 ( tmp64 ) ; \n return a ; \n }", "idx": 26531}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free ( QVirtIOSCSI * vs ) \n { \n int i ; \n for ( i = 0 ; i < vs -> num_queues + 2 ; i ++ ) { \n qvirtqueue_cleanup ( vs -> dev -> bus , vs -> vq [ i ] , vs -> alloc ) ; \n } \n pc_alloc_uninit ( vs -> alloc ) ; \n qvirtio_pci_device_disable ( container_of ( vs -> dev , QVirtioPCIDevice , vdev ) ) ; \n g_free ( vs -> dev ) ; \n qpci_free_pc ( vs -> bus ) ; \n g_free ( vs ) ; \n }", "idx": 26535}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events ( sPAPRMachineState * spapr ) \n { \n sPAPREventLogEntry * entry = NULL ; \n QTAILQ_FOREACH ( entry , & spapr -> pending_events , next )  { \n QTAILQ_REMOVE ( & spapr -> pending_events , entry , next ) ; \n g_free ( entry -> extended_log ) ; \n g_free ( entry ) ; \n } \n }", "idx": 26538}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask ( void ) \n { \n WriteEventMask * sccb = ( void * ) _sccb ; \n sccb -> h . length = sizeof ( WriteEventMask ) ; \n sccb -> mask_length = sizeof ( unsigned int ) ; \n sccb -> receive_mask = SCLP_EVENT_MASK_MSG_ASCII ; \n sccb -> cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII ; \n sccb -> send_mask = SCLP_EVENT_MASK_MSG_ASCII ; \n sccb -> cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII ; \n sclp_service_call ( SCLP_CMD_WRITE_EVENT_MASK , sccb ) ; \n }", "idx": 26540}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int ( QJSON * json , const char * name , int64_t val ) \n { \n json_emit_element ( json , name ) ; \n qstring_append_int ( json -> str , val ) ; \n }", "idx": 26543}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci ( PIIX4PMState * s ) \n { \n int sci_level , pmsts ; \n pmsts = acpi_pm1_evt_get_sts ( & s -> ar ) ; \n sci_level = ( ( ( pmsts & s -> ar . pm1 . evt . en ) & \n ( ACPI_BITMASK_RT_CLOCK_ENABLE | \n ACPI_BITMASK_POWER_BUTTON_ENABLE | \n ACPI_BITMASK_GLOBAL_LOCK_ENABLE | \n ACPI_BITMASK_TIMER_ENABLE ) ) != 0 ) || \n ( ( ( s -> ar . gpe . sts [ 0 ] & s -> ar . gpe . en [ 0 ] ) & \n ( PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS ) ) != 0 ) ; \n qemu_set_irq ( s -> irq , sci_level ) ; \n acpi_pm_tmr_update ( & s -> ar , ( s -> ar . pm1 . evt . en & ACPI_BITMASK_TIMER_ENABLE ) && \n ! ( pmsts & ACPI_BITMASK_TIMER_STATUS ) ) ; \n }", "idx": 26552}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start ( Slirp * slirp )  \n { \n uint64_t now = qemu_get_clock_ns ( rt_clock ) ; \n int requeued = 0 ; \n struct mbuf * ifm , * ifqt ; \n DEBUG_CALL ( \" \" ) ; \n if ( slirp -> if_queued == 0 ) \n return ; \n again : \n if ( ! slirp_can_output ( slirp -> opaque ) ) \n return ; \n if ( slirp -> if_fastq . ifq_next != & slirp -> if_fastq ) { \n ifm = slirp -> if_fastq . ifq_next ; \n } else { \n if ( slirp -> next_m != & slirp -> if_batchq ) \n ifm = slirp -> next_m ; \n else \n ifm = slirp -> if_batchq . ifq_next ; \n slirp -> next_m = ifm -> ifq_next ; \n } \n ifqt = ifm -> ifq_prev ; \n remque ( ifm ) ; \n slirp -> if_queued -- ; \n if ( ifm -> ifs_next != \n ifm ) { \n insque ( ifm -> ifs_next , ifqt ) ; \n ifs_remque ( ifm ) ; \n } \n if ( ifm -> ifq_so ) { \n if ( -- ifm -> ifq_so -> so_queued == 0 ) \n ifm -> ifq_so -> so_nqueued = 0 ; \n } \n if ( ifm -> expiration_date < now ) { \n m_free ( ifm ) ; \n } else { \n if ( if_encap ( slirp , ifm ) ) { \n m_free ( ifm ) ; \n } else { \n insque ( ifm , ifqt ) ; \n requeued ++ ; \n } \n } \n if ( slirp -> if_queued ) \n goto again ; \n slirp -> if_queued = requeued ; \n }", "idx": 26587}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check ( ImageCheck * check ) \n { \n if ( ! ( check -> corruptions || check -> leaks || check -> check_errors ) ) { \n printf ( \" \\n \" ) ; \n } else { \n if ( check -> corruptions ) { \n printf ( \" \\n \" PRId64 \" \\n \" \n \" \" \n \" \\n \" , \n check -> corruptions ) ; \n } \n if ( check -> leaks ) { \n printf ( \" \\n \" PRId64 \" \\n \" \n \" \\n \" , \n check -> leaks ) ; \n } \n if ( check -> check_errors ) { \n printf ( \" \\n \" PRId64 \" \\n \" , \n check -> check_errors ) ; \n } \n } \n if ( check -> total_clusters != 0 && check -> allocated_clusters != 0 ) { \n printf ( \" \" PRId64 \" \" PRId64 \" \\n \" , \n check -> allocated_clusters , check -> total_clusters , \n check -> allocated_clusters * 100.0 / check -> total_clusters , \n check -> fragmented_clusters * 100.0 / check -> allocated_clusters ) ; \n } \n if ( check -> image_end_offset ) { \n printf ( \" \" PRId64 \" \\n \" , check -> image_end_offset ) ; \n } \n }", "idx": 26595}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32 ( int32 a STATUS_PARAM ) \n { \n flag zSign ; \n if ( a == 0 ) return 0 ; \n if ( a == ( sbits32 ) 0x80000000 ) return packFloat32 ( 1 , 0x9E , 0 ) ; \n zSign = ( a < 0 ) ; \n return normalizeRoundAndPackFloat32 ( zSign , 0x9C , zSign ? - a : a STATUS_VAR ) ; \n }", "idx": 26599}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection ( VFIOINTp * intp ) \n { \n int ret ; \n ret = vfio_set_trigger_eventfd ( intp , vfio_intp_interrupt ) ; \n if ( ret ) { \n error_report ( \" \" ) ; \n } \n return ret ; \n }", "idx": 26620}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in ( struct bt_hid_device_s * s ) \n { \n USBPacket p ; \n p . pid = USB_TOKEN_IN ; \n p . devep = 1 ; \n p . data = s -> datain . buffer ; \n p . len = sizeof ( s -> datain . buffer ) ; \n s -> datain . len = s -> usbdev -> info -> handle_data ( s -> usbdev , & p ) ; \n return s -> datain . len ; \n }", "idx": 26642}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi ( Error * * errp ) \n { \n #if defined ( TARGET_I386 )  \n  \n  CPUState * cs ; \n CPU_FOREACH ( cs ) { \n X86CPU * cpu = X86_CPU ( cs ) ; \n if ( ! cpu -> apic_state ) { \n cpu_interrupt ( cs , CPU_INTERRUPT_NMI ) ; \n } else { \n apic_deliver_nmi ( cpu -> apic_state ) ; \n } \n } \n #else \n nmi_monitor_handle ( monitor_get_cpu_index ( ) , errp ) ; \n #endif \n }", "idx": 26653}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation ( const void *  l2hdr , size_t  l2hdr_len , \n void * l3hdr , size_t l3hdr_len , \n size_t l3payload_len , \n size_t frag_offset , bool more_frags ) \n { \n if ( eth_get_l3_proto ( l2hdr , l2hdr_len ) == ETH_P_IP ) { \n uint16_t orig_flags ; \n struct ip_header * iphdr = ( struct ip_header * ) l3hdr ; \n uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE ; \n uint16_t new_ip_off ; \n assert ( frag_offset % IP_FRAG_UNIT_SIZE == 0 ) ; \n assert ( ( frag_off_units & ~ IP_OFFMASK ) == 0 ) ; \n orig_flags = be16_to_cpu ( iphdr -> ip_off ) & ~ ( IP_OFFMASK | IP_MF ) ; \n new_ip_off = frag_off_units | orig_flags | ( more_frags ? IP_MF : 0 ) ; \n iphdr -> ip_off = cpu_to_be16 ( new_ip_off ) ; \n iphdr -> ip_len = cpu_to_be16 ( l3payload_len + l3hdr_len ) ; \n } \n }", "idx": 26663}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER ( ucf64_subs ) ( float32 a , float32 b , CPUUniCore32State * env ) \n { \n return float32_sub ( a , b , & env -> ucf64 . fp_status ) ; \n }", "idx": 26671}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum ( uint8_t * dp , uint8_t * de )  \n { \n unsigned int bsum [ 2 ] = { 0 , 0 } , i , sum ; \n for ( i = 1 ; dp < de ; bsum [ i ^= 1 ] += * dp ++ ) \n ; \n sum = ( bsum [ 0 ] << 8 ) + bsum [ 1 ] ; \n sum = ( sum >> 16 ) + ( sum & 0xffff ) ; \n return ~ ( sum + ( sum >> 16 ) ) ; \n }", "idx": 26673}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize ( DeviceState * dev , Error * * errp ) \n { \n ICSState * ics = ICS_SIMPLE ( dev ) ; \n if ( ! ics -> nr_irqs ) { \n error_setg ( errp , \" \" ) ; \n return ; \n } \n ics -> irqs = g_malloc0 ( ics -> nr_irqs * sizeof ( ICSIRQState ) ) ; \n ics -> qirqs = qemu_allocate_irqs ( ics_simple_set_irq , ics , ics -> nr_irqs ) ; \n qemu_register_reset ( ics_simple_reset , dev ) ; \n }", "idx": 26680}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush ( VncState * vs ) \n { \n if ( vs -> output . offset ) \n vnc_client_write ( vs ) ; \n }", "idx": 26701}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work ( SubchDev * sch , ORB * orb ) \n { \n SCSW * s = & sch -> curr_status . scsw ; \n if ( s -> ctrl & SCSW_FCTL_CLEAR_FUNC ) { \n sch_handle_clear_func ( sch ) ; \n } else if ( s -> ctrl & SCSW_FCTL_HALT_FUNC ) { \n sch_handle_halt_func ( sch ) ; \n } else if ( s -> ctrl & SCSW_FCTL_START_FUNC ) { \n sch_handle_start_func ( sch , orb ) ; \n } else { \n return ; \n } \n css_inject_io_interrupt ( sch ) ; \n }", "idx": 26711}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate ( QEMUFile * f , void * opaque ) \n { \n int ret ; \n int64_t last_ftell = qemu_ftell ( f ) ; \n DPRINTF ( \" \\n \" , \n block_mig_state . submitted , block_mig_state . transferred ) ; \n ret = flush_blks ( f ) ; \n if ( ret ) { \n return ret ; \n } \n blk_mig_reset_dirty_cursor ( ) ; \n blk_mig_lock ( ) ; \n while ( ( block_mig_state . submitted + \n block_mig_state . read_done ) * BLOCK_SIZE < \n qemu_file_get_rate_limit ( f ) ) { \n blk_mig_unlock ( ) ; \n if ( block_mig_state . bulk_completed == 0 ) { \n if ( blk_mig_save_bulked_block ( f ) == 0 ) { \n block_mig_state . bulk_completed = 1 ; \n } \n ret = 0 ; \n } else { \n qemu_mutex_lock_iothread ( ) ; \n ret = blk_mig_save_dirty_block ( f , 1 ) ; \n qemu_mutex_unlock_iothread ( ) ; \n } \n if ( ret < 0 ) { \n return ret ; \n } \n blk_mig_lock ( ) ; \n if ( ret != 0 ) { \n break ; \n } \n } \n blk_mig_unlock ( ) ; \n ret = flush_blks ( f ) ; \n if ( ret ) { \n return ret ; \n } \n qemu_put_be64 ( f , BLK_MIG_FLAG_EOS ) ; \n return qemu_ftell ( f ) - last_ftell ; \n }", "idx": 26726}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob * vnc_job_new ( VncState * vs ) \n { \n VncJob * job = g_malloc0 ( sizeof ( VncJob ) ) ; \n job -> vs = vs ; \n vnc_lock_queue ( queue ) ; \n QLIST_INIT ( & job -> rectangles ) ; \n vnc_unlock_queue ( queue ) ; \n return job ; \n }", "idx": 26738}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed ( NBDClient * client ) \n { \n nb_fds -- ; \n if ( nb_fds == 0 && ! persistent && state == RUNNING ) { \n state = TERMINATE ; \n } \n nbd_update_server_watch ( ) ; \n nbd_client_put ( client ) ; \n }", "idx": 26745}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq ( NvmeCtrl * n , NvmeCmd * cmd ) \n { \n NvmeSQueue * sq ; \n NvmeCreateSq * c = ( NvmeCreateSq * ) cmd ; \n uint16_t cqid = le16_to_cpu ( c -> cqid ) ; \n uint16_t sqid = le16_to_cpu ( c -> sqid ) ; \n uint16_t qsize = le16_to_cpu ( c -> qsize ) ; \n uint16_t qflags = le16_to_cpu ( c -> sq_flags ) ; \n uint64_t prp1 = le64_to_cpu ( c -> prp1 ) ; \n if ( ! cqid || nvme_check_cqid ( n , cqid ) ) { \n return NVME_INVALID_CQID | NVME_DNR ; \n } \n if ( ! sqid || ! nvme_check_sqid ( n , sqid ) ) { \n return NVME_INVALID_QID | NVME_DNR ; \n } \n if ( ! qsize || qsize > NVME_CAP_MQES ( n -> bar . cap ) ) { \n return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR ; \n } \n if ( ! prp1 || prp1 & ( n -> page_size - 1 ) ) { \n return NVME_INVALID_FIELD | NVME_DNR ; \n } \n if ( ! ( NVME_SQ_FLAGS_PC ( qflags ) ) ) { \n return NVME_INVALID_FIELD | NVME_DNR ; \n } \n sq = g_malloc0 ( sizeof ( * sq ) ) ; \n nvme_init_sq ( sq , n , prp1 , sqid , cqid , qsize + 1 ) ; \n return NVME_SUCCESS ; \n }", "idx": 26749}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed ( struct vmsvga_state_s * s , \n int x , int y , int w , int h ) \n { \n struct vmsvga_rect_s * rect = & s -> redraw_fifo [ s -> redraw_fifo_last ++ ] ; \n s -> redraw_fifo_last &= REDRAW_FIFO_LEN - 1 ; \n rect -> x = x ; \n rect -> y = y ; \n rect -> w = w ; \n rect -> h = h ; \n }", "idx": 26776}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry ( DisasContext * dc , TCGv d ) \n { \n if ( dc -> flagx_known ) { \n if ( dc -> flags_x ) { \n TCGv c ; \n c = tcg_temp_new ( TCG_TYPE_TL ) ; \n t_gen_mov_TN_preg ( c , PR_CCS ) ; \n tcg_gen_andi_tl ( c , c , C_FLAG ) ; \n tcg_gen_add_tl ( d , d , c ) ; \n tcg_temp_free ( c ) ; \n } \n } else { \n TCGv x , c ; \n x = tcg_temp_new ( TCG_TYPE_TL ) ; \n c = tcg_temp_new ( TCG_TYPE_TL ) ; \n t_gen_mov_TN_preg ( x , PR_CCS ) ; \n tcg_gen_mov_tl ( c , x ) ; \n tcg_gen_andi_tl ( c , c , C_FLAG ) ; \n tcg_gen_andi_tl ( x , x , X_FLAG ) ; \n tcg_gen_shri_tl ( x , x , 4 ) ; \n tcg_gen_and_tl ( x , x , c ) ; \n tcg_gen_add_tl ( d , d , x ) ; \n tcg_temp_free ( x ) ; \n tcg_temp_free ( c ) ; \n } \n }", "idx": 26777}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu ( sPAPREnvironment * spapr , \n uint32_t token , uint32_t nargs , \n target_ulong args , \n uint32_t nret , target_ulong rets ) \n { \n target_ulong id , start , r3 ; \n CPUState * cs ; \n if ( nargs != 3 || nret != 1 ) { \n rtas_st ( rets , 0 , -3 ) ; \n return ; \n } \n id = rtas_ld ( args , 0 ) ; \n start = rtas_ld ( args , 1 ) ; \n r3 = rtas_ld ( args , 2 ) ; \n cs = qemu_get_cpu ( id ) ; \n if ( cs != NULL ) { \n PowerPCCPU * cpu = POWERPC_CPU ( cs ) ; \n CPUPPCState * env = & cpu -> env ; \n if ( ! cs -> halted ) { \n rtas_st ( rets , 0 , -1 ) ; \n return ; \n } \n kvm_cpu_synchronize_state ( cs ) ; \n env -> msr = ( 1ULL << MSR_SF ) | ( 1ULL << MSR_ME ) ; \n env -> nip = start ; \n env -> gpr [ 3 ] = r3 ; \n cs -> halted = 0 ; \n qemu_cpu_kick ( cs ) ; \n rtas_st ( rets , 0 , 0 ) ; \n return ; \n } \n rtas_st ( rets , 0 , -3 ) ; \n }", "idx": 26780}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer ( i2c_bus * bus , int address , int recv ) \n { \n DeviceState * qdev ; \n i2c_slave * slave = NULL ; \n LIST_FOREACH ( qdev , & bus -> qbus . children , sibling )  { \n slave = I2C_SLAVE_FROM_QDEV ( qdev ) ; \n if ( slave -> address == address ) \n break ; \n } \n if ( ! slave ) \n return 1 ; \n bus -> current_dev = slave ; \n slave -> info -> event ( slave , recv ? I2C_START_RECV : I2C_START_SEND ) ; \n return 0 ; \n }", "idx": 26792}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport ( SDHCIState * s , uint32_t value , unsigned size ) \n { \n unsigned i ; \n if ( ! ( s -> prnsts & SDHC_SPACE_AVAILABLE ) ) { \n ERRPRINT ( \" \\n \" ) ; \n return ; \n } \n for ( i = 0 ; i < size ; i ++ ) { \n s -> fifo_buffer [ s -> data_count ] = value & 0xFF ; \n s -> data_count ++ ; \n value >>= 8 ; \n if ( s -> data_count >= ( s -> blksize & 0x0fff ) ) { \n DPRINT_L2 ( \" \\n \" , \n s -> data_count ) ; \n s -> data_count = 0 ; \n s -> prnsts &= ~ SDHC_SPACE_AVAILABLE ; \n if ( s -> prnsts & SDHC_DOING_WRITE ) { \n sdhci_write_block_to_card ( s ) ; \n } \n } \n } \n }", "idx": 26841}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState * qemu_chr_open_pipe ( ChardevHostdev * opts ) \n { \n const char * filename = opts -> device ; \n CharDriverState * chr ; \n WinCharState * s ; \n chr = qemu_chr_alloc ( ) ; \n s = g_malloc0 ( sizeof ( WinCharState ) ) ; \n chr -> opaque = s ; \n chr -> chr_write = win_chr_write ; \n chr -> chr_close = win_chr_close ; \n if ( win_chr_pipe_init ( chr , filename ) < 0 ) { \n g_free ( s ) ; \n g_free ( chr ) ; \n return NULL ; \n } \n return chr ; \n }", "idx": 26848}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void * thread_func ( void * p ) \n { \n struct thread_info * info = p ; \n rcu_register_thread ( ) ; \n atomic_inc ( & n_ready_threads ) ; \n while ( ! atomic_mb_read ( & test_start ) ) { \n cpu_relax ( ) ; \n } \n rcu_read_lock ( ) ; \n while ( ! atomic_read ( & test_stop ) ) { \n info -> r = xorshift64star ( info -> r ) ; \n info -> func ( info ) ; \n } \n rcu_read_unlock ( ) ; \n rcu_unregister_thread ( ) ; \n return NULL ; \n }", "idx": 26873}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet ( VLANClientState * sender , const uint8_t * buf , int size )  \n { \n VLANClientState * vc ; \n for ( vc = sender -> vlan -> first_client ; vc != NULL ; vc = vc -> next ) { \n if ( vc != sender && ! vc -> link_down ) { \n vc -> receive ( vc -> opaque , buf , size ) ; \n } \n } \n }", "idx": 26904}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init ( CPUState * env ) \n { \n env -> irq_inputs = ( void * * ) qemu_allocate_irqs ( & ppc970_set_irq , env , 7 ) ; \n }", "idx": 26935}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu ( CPUState * env ) \n { \n env -> thread = qemu_mallocz ( sizeof ( QemuThread ) ) ; \n env -> halt_cond = qemu_mallocz ( sizeof ( QemuCond ) ) ; \n qemu_cond_init ( env -> halt_cond ) ; \n qemu_thread_create ( env -> thread , kvm_cpu_thread_fn , env ) ; \n while ( env -> created == 0 ) \n qemu_cond_timedwait ( & qemu_cpu_cond , & qemu_global_mutex , 100 ) ; \n }", "idx": 26945}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search ( PowerPCCPU * cpu , hwaddr hash , \n bool secondary , target_ulong ptem , \n ppc_hash_pte64_t * pte ) \n { \n CPUPPCState * env = & cpu -> env ; \n int i ; \n uint64_t token ; \n target_ulong pte0 , pte1 ; \n target_ulong pte_index ; \n pte_index = ( hash & env -> htab_mask ) * HPTES_PER_GROUP ; \n token = ppc_hash64_start_access ( cpu , pte_index ) ; \n if ( ! token ) { \n return -1 ; \n } \n for ( i = 0 ; i < HPTES_PER_GROUP ; i ++ ) { \n pte0 = ppc_hash64_load_hpte0 ( cpu , token , i ) ; \n pte1 = ppc_hash64_load_hpte1 ( cpu , token , i ) ; \n if ( ( pte0 & HPTE64_V_VALID ) \n && ( secondary == ! ! ( pte0 & HPTE64_V_SECONDARY ) ) \n && HPTE64_V_COMPARE ( pte0 , ptem ) ) { \n pte -> pte0 = pte0 ; \n pte -> pte1 = pte1 ; \n ppc_hash64_stop_access ( token ) ; \n return ( pte_index + i ) * HASH_PTE_SIZE_64 ; \n } \n } \n ppc_hash64_stop_access ( token ) ; \n return -1 ; \n }", "idx": 26946}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce ( VIOsPAPRDevice * dev , uint64_t taddr , uint64_t val ) \n { \n val = tswap64 ( val ) ; \n spapr_tce_dma_write ( dev , taddr , & val , sizeof ( val ) ) ; \n }", "idx": 26987}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited ( void ) \n { \n QemuOpts * opts ; \n Visitor * v ; \n UserDefOptions * userdef ; \n opts = qemu_opts_parse ( qemu_find_opts ( \" \" ) , \" \" , false , \n & error_abort ) ; \n v = opts_visitor_new ( opts ) ; \n visit_type_UserDefOptions ( v , NULL , & userdef , & error_abort ) ; \n visit_free ( v ) ; \n qemu_opts_del ( opts ) ; \n qapi_free_UserDefOptions ( userdef ) ; \n }", "idx": 26993}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status ( BlockDriverState * bs , \n int64_t sector_num , int nb_sectors , int * pnum ) \n { \n BDRVParallelsState * s = bs -> opaque ; \n int64_t offset ; \n qemu_co_mutex_lock ( & s -> lock ) ; \n offset = block_status ( s , sector_num , nb_sectors , pnum ) ; \n qemu_co_mutex_unlock ( & s -> lock ) ; \n if ( offset < 0 ) { \n return 0 ; \n } \n return ( offset << BDRV_SECTOR_BITS ) | \n BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID ; \n }", "idx": 27000}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all ( void * private , bool global , \n uint32_t index , uint32_t mask ) \n { \n int cnt = 0 ; \n MSIRouteEntry * entry ; \n MSIMessage msg ; \n QLIST_FOREACH ( entry , & msi_route_list , list )  { \n cnt ++ ; \n msg = pci_get_msi_message ( entry -> dev , entry -> vector ) ; \n kvm_irqchip_update_msi_route ( kvm_state , entry -> virq , \n msg , entry -> dev ) ; \n } \n kvm_irqchip_commit_routes ( kvm_state ) ; \n trace_kvm_x86_update_msi_routes ( cnt ) ; \n }", "idx": 27021}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu ( void * opaque , int sprn ) \n { \n DisasContext * ctx = opaque ; \n gen_op_store_601_batu ( ( sprn - SPR_IBAT0U ) / 2 ) ; \n RET_STOP ( ctx ) ; \n }", "idx": 27045}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write ( IDEState * s ) \n { \n int64_t sector_num ; \n int ret , n , n1 ; \n s -> status = READY_STAT | SEEK_STAT ; \n sector_num = ide_get_sector ( s ) ; \n #if defined ( DEBUG_IDE )  \n  \n  printf ( \" \\n \" , sector_num ) ; \n #endif \n n = s -> nsector ; \n if ( n > s -> req_nb_sectors ) \n n = s -> req_nb_sectors ; \n ret = bdrv_write ( s -> bs , sector_num , s -> io_buffer , n ) ; \n s -> nsector -= n ; \n if ( s -> nsector == 0 ) { \n ide_transfer_stop ( s ) ; \n } else { \n n1 = s -> nsector ; \n if ( n1 > s -> req_nb_sectors ) \n n1 = s -> req_nb_sectors ; \n ide_transfer_start ( s , s -> io_buffer , 512 * n1 , ide_sector_write ) ; \n } \n ide_set_sector ( s , sector_num + n ) ; \n #ifdef TARGET_I386 \n if ( win2k_install_hack ) { \n qemu_mod_timer ( s -> sector_write_timer , \n qemu_get_clock ( vm_clock ) + ( ticks_per_sec / 1000 ) ) ; \n } else \n #endif \n { \n ide_set_irq ( s ) ; \n } \n }", "idx": 27046}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext * iohandler_get_aio_context ( void ) \n { \n iohandler_init ( ) ; \n return iohandler_ctx ; \n }", "idx": 27048}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp ( DisasContext * s , uint32_t insn ) \n { \n unsigned int mos , type , rm , cond , rn , op , nzcv ; \n TCGv_i64 tcg_flags ; \n int label_continue = -1 ; \n mos = extract32 ( insn , 29 , 3 ) ; \n type = extract32 ( insn , 22 , 2 ) ; \n rm = extract32 ( insn , 16 , 5 ) ; \n cond = extract32 ( insn , 12 , 4 ) ; \n rn = extract32 ( insn , 5 , 5 ) ; \n op = extract32 ( insn , 4 , 1 ) ; \n nzcv = extract32 ( insn , 0 , 4 ) ; \n if ( mos || type > 1 ) { \n unallocated_encoding ( s ) ; \n return ; \n } \n if ( ! fp_access_check ( s ) ) { \n return ; \n } \n if ( cond < 0x0e ) { \n int label_match = gen_new_label ( ) ; \n label_continue = gen_new_label ( ) ; \n arm_gen_test_cc ( cond , label_match ) ; \n tcg_flags = tcg_const_i64 ( nzcv << 28 ) ; \n gen_set_nzcv ( tcg_flags ) ; \n tcg_temp_free_i64 ( tcg_flags ) ; \n tcg_gen_br ( label_continue ) ; \n gen_set_label ( label_match ) ; \n } \n handle_fp_compare ( s , type , rn , rm , false , op ) ; \n if ( cond < 0x0e ) { \n gen_set_label ( label_continue ) ; \n } \n }", "idx": 27083}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit ( unsigned int bit , const unsigned long * map ) \n { \n return ! ! ( ( map ) [ ( bit ) / BITS_PER_LONG ] & ( 1UL << ( ( bit ) % BITS_PER_LONG ) ) ) ; \n }", "idx": 27088}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode ( AioContext * ctx , bool blocking ) \n { \n if ( blocking && ctx -> poll_max_ns && ctx -> poll_disable_cnt == 0 ) { \n int64_t max_ns = MIN ( ( uint64_t ) aio_compute_timeout ( ctx ) , \n ( uint64_t ) ctx -> poll_ns ) ; \n if ( max_ns ) { \n poll_set_started ( ctx , true ) ; \n if ( run_poll_handlers ( ctx , max_ns ) ) { \n return true ; \n } \n } \n } \n poll_set_started ( ctx , false ) ; \n return run_poll_handlers_once ( ctx ) ; \n }", "idx": 27100}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature ( const char * id ) \n { \n QDict * response ; \n int ret ; \n response = qmp ( \" \" \n \" \" , id ) ; \n g_assert ( qdict_haskey ( response , \" \" ) ) ; \n ret = qdict_get_int ( response , \" \" ) ; \n QDECREF ( response ) ; \n return ret ; \n }", "idx": 27107}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug ( void ) \n { \n QVirtioPCIDevice * dev ; \n QOSState * qs ; \n const char * arch = qtest_get_arch ( ) ; \n qs = pci_test_start ( ) ; \n qpci_plug_device_test ( \" \" , \" \" , PCI_SLOT_HP , \n \" \" ) ; \n dev = virtio_blk_pci_init ( qs -> pcibus , PCI_SLOT_HP ) ; \n g_assert ( dev ) ; \n qvirtio_pci_device_disable ( dev ) ; \n g_free ( dev ) ; \n if ( strcmp ( arch , \" \" ) == 0 || strcmp ( arch , \" \" ) == 0 ) { \n qpci_unplug_acpi_device_test ( \" \" , PCI_SLOT_HP ) ; \n } \n qtest_shutdown ( qs ) ; \n }", "idx": 27148}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0 ( void ) \n { \n char * argv [ 256 ] ; \n int argc , ide_idx ; \n Backend i ; \n argc = setup_common ( argv , ARRAY_SIZE ( argv ) ) ; \n for ( i = 0 ; i <= backend_empty ; i ++ ) { \n ide_idx = backend_empty - i ; \n cur_ide [ ide_idx ] = & hd_chst [ i ] [ mbr_blank ] ; \n argc = setup_ide ( argc , argv , ARRAY_SIZE ( argv ) , \n ide_idx , NULL , i , mbr_blank , \" \" ) ; \n } \n qtest_start ( g_strjoinv ( \" \" , argv ) ) ; \n test_cmos ( ) ; \n qtest_end ( ) ; \n }", "idx": 27171}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit ( CPUState * cs , struct kvm_run * run ) \n { \n S390CPU * cpu = S390_CPU ( cs ) ; \n int ret = 0 ; \n switch ( run -> exit_reason ) { \n case KVM_EXIT_S390_SIEIC : \n ret = handle_intercept ( cpu ) ; \n break ; \n case KVM_EXIT_S390_RESET : \n qemu_system_reset_request ( ) ; \n break ; \n case KVM_EXIT_S390_TSCH : \n ret = handle_tsch ( cpu ) ; \n break ; \n case KVM_EXIT_DEBUG : \n ret = kvm_arch_handle_debug_exit ( cpu ) ; \n break ; \n default : \n fprintf ( stderr , \" \\n \" , run -> exit_reason ) ; \n break ; \n } \n if ( ret == 0 ) { \n ret = EXCP_INTERRUPT ; \n } \n return ret ; \n }", "idx": 27254}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace * pci_device_iommu_address_space ( PCIDevice * dev ) \n { \n PCIBus * bus = PCI_BUS ( dev -> bus ) ; \n PCIBus * iommu_bus = bus ; \n while ( iommu_bus && ! iommu_bus -> iommu_fn && iommu_bus -> parent_dev ) { \n iommu_bus = PCI_BUS ( iommu_bus -> parent_dev -> bus ) ; \n } \n if ( iommu_bus && iommu_bus -> iommu_fn ) { \n return iommu_bus -> iommu_fn ( bus , iommu_bus -> iommu_opaque , dev -> devfn ) ; \n } \n return & address_space_memory ; \n }", "idx": 27256}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo ( TCGv dst , TCGv src , \n unsigned int fcc_offset ) \n { \n gen_mov_reg_FCC0 ( dst , src , fcc_offset ) ; \n gen_mov_reg_FCC1 ( cpu_tmp0 , src , fcc_offset ) ; \n tcg_gen_and_tl ( dst , dst , cpu_tmp0 ) ; \n tcg_gen_xori_tl ( dst , dst , 0x1 ) ; \n }", "idx": 27257}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s * omap_mcbsp_init ( MemoryRegion * system_memory , \n target_phys_addr_t base , \n qemu_irq txirq , qemu_irq rxirq , \n qemu_irq * dma , omap_clk clk ) \n { \n struct omap_mcbsp_s * s = ( struct omap_mcbsp_s * ) \n g_malloc0 ( sizeof ( struct omap_mcbsp_s ) ) ; \n s -> txirq = txirq ; \n s -> rxirq = rxirq ; \n s -> txdrq = dma [ 0 ] ; \n s -> rxdrq = dma [ 1 ] ; \n s -> sink_timer = qemu_new_timer_ns ( vm_clock , omap_mcbsp_sink_tick , s ) ; \n s -> source_timer = qemu_new_timer_ns ( vm_clock , omap_mcbsp_source_tick , s ) ; \n omap_mcbsp_reset ( s ) ; \n memory_region_init_io ( & s -> iomem , & omap_mcbsp_ops , s , \" \" , 0x800 ) ; \n memory_region_add_subregion ( system_memory , base , & s -> iomem ) ; \n return s ; \n }", "idx": 27311}
