{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_16_bad()\n{\n    while(1)\n    {\n        signal(SIGINT, helperBad);\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood = 0;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperGood);\n        /* FIX: In this instance, the fix is to temporarily disable the signal\n         * handler while performing non-atomic operations.  Another way would\n         * be to use sigprocmask or sigvec, or to restructure the signal handler\n         * to operate in a safe manner.\n         */\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood = NULL;\n        }\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_05_bad()\n{\n    if(staticTrue)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void bad1() { }"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void good5() { }"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_16_bad()\n{\n    while(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(gGoodInt);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        signal(SIGINT, helperGood);\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valGoodSink;\n        valGoodSink = 0;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(valGoodSink);\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void bad9() { }"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_01_bad()\n{\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (ACCESS(filename, W_OK) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood = 0;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperGood);\n        /* FIX: In this instance, the fix is to temporarily disable the signal\n         * handler while performing non-atomic operations.  Another way would\n         * be to use sigprocmask or sigvec, or to restructure the signal handler\n         * to operate in a safe manner.\n         */\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood = NULL;\n        }\n        signal(SIGINT, helperGood);\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_03_bad()\n{\n    if(5==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_03_bad()\n{\n    if(5==5)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_02_bad()\n{\n    if(1)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_03_bad()\n{\n    if(5==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "void bad7() { }"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = NULL;\n            }\n        }\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void bad3() { }"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_02_bad()\n{\n    if(1)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_02_bad()\n{\n    if(1)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "void good3() { }"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valGoodSink;\n        valGoodSink = 0;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(valGoodSink);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_03_bad()\n{\n    if(5==5)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    signal(SIGINT, helperGood);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_02_bad()\n{\n    if(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "void good8() { }"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(gGoodInt);\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        signal(SIGINT, helperBad);\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void good1() { }"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valBadSink;\n        valBadSink = 0;\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(valBadSink);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void bad2() { }"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood = 0;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperGood);\n        /* FIX: In this instance, the fix is to temporarily disable the signal\n         * handler while performing non-atomic operations.  Another way would\n         * be to use sigprocmask or sigvec, or to restructure the signal handler\n         * to operate in a safe manner.\n         */\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicGood = NULL;\n        }\n        signal(SIGINT, helperGood);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_18_bad()\n{\n    goto sink;\nsink:\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = NULL;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperBad);\n        /* FLAW: This test, free, and set operation is not atomic, so if signal\n         * delivery occurs (for example) between the free and setting to NULL,\n         * the signal handler could corrupt the heap, cause an access violation,\n         * etc\n         *\n         * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n         * systems that don't actually exist, but this should trigger on\n         * theoretical as well as actual computer systems.\n         */\n        if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = NULL;\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_01_bad()\n{\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valBadSink;\n        valBadSink = 0;\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(valBadSink);\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        signal(SIGINT, helperGood);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_07_bad()\n{\n    if(staticFive==5)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_14_bad()\n{\n    if(globalFive==5)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_16_bad()\n{\n    while(1)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_18_bad()\n{\n    goto sink;\nsink:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (ACCESS(filename, W_OK) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (ACCESS(filename, W_OK) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood = 0;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperGood);\n        /* FIX: In this instance, the fix is to temporarily disable the signal\n         * handler while performing non-atomic operations.  Another way would\n         * be to use sigprocmask or sigvec, or to restructure the signal handler\n         * to operate in a safe manner.\n         */\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood);\n            CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood = NULL;\n        }\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "void good9() { }"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_01_bad()\n{\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = NULL;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperBad);\n        /* FLAW: This test, free, and set operation is not atomic, so if signal\n         * delivery occurs (for example) between the free and setting to NULL,\n         * the signal handler could corrupt the heap, cause an access violation,\n         * etc\n         *\n         * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n         * systems that don't actually exist, but this should trigger on\n         * theoretical as well as actual computer systems.\n         */\n        if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = NULL;\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_01_bad()\n{\n    signal(SIGINT, helperBad);\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(gGoodInt);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(gGoodInt);\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void bad4() { }"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void bad5() { }"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void bad6() { }"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_02_bad()\n{\n    if(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void bad8() { }"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_16_bad()\n{\n    while(1)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = NULL;\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    signal(SIGINT, helperGood);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad = NULL;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperBad);\n            /* FLAW: This test, free, and set operation is not atomic, so if signal\n             * delivery occurs (for example) between the free and setting to NULL,\n             * the signal handler could corrupt the heap, cause an access violation,\n             * etc\n             *\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n             * systems that don't actually exist, but this should trigger on\n             * theoretical as well as actual computer systems.\n             */\n            if (CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad);\n                CWE364_Signal_Handler_Race_Condition__basic_04StructSigAtomicBad = NULL;\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void good2() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        signal(SIGINT, helperGood);\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_10_bad()\n{\n    if(globalTrue)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_16_bad()\n{\n    while(1)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valGoodSink;\n        valGoodSink = 0;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(valGoodSink);\n    }\n    break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = NULL;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperBad);\n        /* FLAW: This test, free, and set operation is not atomic, so if signal\n         * delivery occurs (for example) between the free and setting to NULL,\n         * the signal handler could corrupt the heap, cause an access violation,\n         * etc\n         *\n         * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n         * systems that don't actually exist, but this should trigger on\n         * theoretical as well as actual computer systems.\n         */\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = NULL;\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_03_bad()\n{\n    if(5==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        gBadInt = 0;\n        if (!stdThreadCreate(helperBad, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(gBadInt);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_18_bad()\n{\n    goto sink;\nsink:\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        signal(SIGINT, helperBad);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_02_bad()\n{\n    if(1)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_03_bad()\n{\n    if(5==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "void good4() { }"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valGoodSink;\n        valGoodSink = 0;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(valGoodSink);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_01_bad()\n{\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        gBadInt = 0;\n        if (!stdThreadCreate(helperBad, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(gBadInt);\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        signal(SIGINT, helperGood);\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_18_bad()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valBadSink;\n        valBadSink = 0;\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(valBadSink);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_16_bad()\n{\n    while(1)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_18_bad()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        gBadInt = 0;\n        if (!stdThreadCreate(helperBad, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(gBadInt);\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void good6() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void good7() { }"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_18_bad()\n{\n    goto sink;\nsink:\n    signal(SIGINT, helperBad);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_01_bad()\n{\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
